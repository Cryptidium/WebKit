// Automatically generated from C:/WebKit/Source/JavaScriptCore/parser/Keywords.table using C:/WebKit/Source/JavaScriptCore/create_hash_table. DO NOT EDIT!

#include "Lookup.h"

namespace JSC {

static constinit const struct CompactHashIndex mainTableIndex[134] = {
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { 41, -1 },
    { 38, -1 },
    { 31, -1 },
    { 14, -1 },
    { 0, -1 },
    { -1, -1 },
    { 16, -1 },
    { -1, -1 },
    { 12, -1 },
    { 15, -1 },
    { -1, -1 },
    { 21, -1 },
    { -1, -1 },
    { 44, -1 },
    { 40, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { 32, -1 },
    { -1, -1 },
    { 8, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { 25, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { 43, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { 10, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { 35, -1 },
    { 36, -1 },
    { 24, -1 },
    { -1, -1 },
    { 27, -1 },
    { -1, -1 },
    { 20, -1 },
    { -1, -1 },
    { 11, 130 },
    { -1, -1 },
    { 4, 132 },
    { -1, -1 },
    { 13, -1 },
    { -1, -1 },
    { 33, -1 },
    { 30, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { 1, 128 },
    { 42, -1 },
    { 18, -1 },
    { -1, -1 },
    { 29, -1 },
    { 3, 129 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { 6, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { 28, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { 23, -1 },
    { -1, -1 },
    { 45, -1 },
    { -1, -1 },
    { -1, -1 },
    { 39, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { 5, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { 17, -1 },
    { 26, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { -1, -1 },
    { 7, 131 },
    { -1, -1 },
    { -1, -1 },
    { 2, -1 },
    { 9, -1 },
    { 19, -1 },
    { 22, -1 },
    { 34, 133 },
    { 37, -1 },
};

static constinit const struct HashTableValue mainTableValues[46] = {
   { "null"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, NULLTOKEN } },
   { "true"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, TRUETOKEN } },
   { "false"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, FALSETOKEN } },
   { "await"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, AWAIT } },
   { "break"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, BREAK } },
   { "case"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, CASE } },
   { "catch"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, CATCH } },
   { "class"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, CLASSTOKEN } },
   { "const"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, CONSTTOKEN } },
   { "default"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, DEFAULT } },
   { "extends"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, EXTENDS } },
   { "finally"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, FINALLY } },
   { "for"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, FOR } },
   { "instanceof"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, INSTANCEOF } },
   { "new"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, NEW } },
   { "var"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, VAR } },
   { "let"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, LET } },
   { "continue"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, CONTINUE } },
   { "function"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, FUNCTION } },
   { "return"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, RETURN } },
   { "void"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, VOIDTOKEN } },
   { "delete"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, DELETETOKEN } },
   { "if"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, IF } },
   { "this"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, THISTOKEN } },
   { "do"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, DO } },
   { "while"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, WHILE } },
   { "else"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, ELSE } },
   { "in"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, INTOKEN } },
   { "super"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, SUPER } },
   { "switch"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, SWITCH } },
   { "throw"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, THROW } },
   { "try"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, TRY } },
   { "typeof"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, TYPEOF } },
   { "with"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, WITH } },
   { "debugger"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, DEBUGGER } },
   { "yield"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, YIELD } },
   { "enum"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, RESERVED } },
   { "export"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, EXPORT_ } },
   { "import"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, IMPORT } },
   { "implements"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, RESERVED_IF_STRICT } },
   { "interface"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, RESERVED_IF_STRICT } },
   { "package"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, RESERVED_IF_STRICT } },
   { "private"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, RESERVED_IF_STRICT } },
   { "protected"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, RESERVED_IF_STRICT } },
   { "public"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, RESERVED_IF_STRICT } },
   { "static"_s, static_cast<unsigned>(PropertyAttribute::None), NoIntrinsic, { HashTableValue::LexerType, RESERVED_IF_STRICT } },
};

static constinit const struct HashTable mainTable =
    { 46, 127, false, nullptr, mainTableValues, mainTableIndex };

} // namespace JSC
