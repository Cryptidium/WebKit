/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from CombinedWebDriverBidiDomains.json by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#pragma once

#include <JavaScriptCore/InspectorProtocolTypes.h>
#include <wtf/JSONValues.h>
#include <wtf/text/WTFString.h>

namespace Inspector {



namespace Protocol {



// Forward declarations.
#if ENABLE(WEBDRIVER_BIDI)
namespace BidiBrowser {
class UserContextInfo;
} // BidiBrowser
#endif // ENABLE(WEBDRIVER_BIDI)

#if ENABLE(WEBDRIVER_BIDI)
namespace BidiBrowsingContext {
class Info;
enum class CreateType;
enum class ReadinessState;
enum class UserPromptType;
} // BidiBrowsingContext
#endif // ENABLE(WEBDRIVER_BIDI)

#if ENABLE(WEBDRIVER_BIDI)
namespace BidiScript {
class ExceptionDetails;
class LocalValue;
class RemoteValue;
class SerializationOptions;
class StackFrame;
class StackTrace;
class Target;
enum class EvaluateResultType;
enum class LocalValueType;
enum class RemoteValueType;
enum class ResultOwnership;
} // BidiScript
#endif // ENABLE(WEBDRIVER_BIDI)

#if ENABLE(WEBDRIVER_BIDI)
namespace BidiSession {
enum class UserPromptHandlerType;
} // BidiSession
#endif // ENABLE(WEBDRIVER_BIDI)

#if ENABLE(WEBDRIVER_BIDI)
namespace BidiStorage {
class PartitionKey;
class CookieFilter;
class BrowsingContextPartitionDescriptor;
class StorageKeyPartitionDescriptor;
class PartitionDescriptor;
class PartialCookie;
enum class PartitionDescriptorType;
enum class CookieSameSitePolicy;
} // BidiStorage
#endif // ENABLE(WEBDRIVER_BIDI)
// End of forward declarations.


// Typedefs.
#if ENABLE(WEBDRIVER_BIDI)
namespace BidiBrowser {
/* String uniquely identifying a client window. */
using ClientWindow = String;
/* Unique string identifying a user context with separate storage. */
using UserContext = String;
} // BidiBrowser
#endif // ENABLE(WEBDRIVER_BIDI)

#if ENABLE(WEBDRIVER_BIDI)
namespace BidiBrowsingContext {
/* A unique identifier for a navigable. */
using BrowsingContext = String;
/* Unique string identifying an ongoing navigation. */
using Navigation = String;
} // BidiBrowsingContext
#endif // ENABLE(WEBDRIVER_BIDI)

#if ENABLE(WEBDRIVER_BIDI)
namespace BidiScript {
/* Represents a handle to an object owned by the ECMAScript runtime. The handle is only valid in a specific <code>BidiScript.Realm</code>. */
using Handle = String;
/* Represents the id of a previously serialized <code>BidiScript.RemoteValue</code> during serialization. */
using InternalId = String;
/* Unique identifier for a script realm as defined at <https://tc39.es/ecma262/#realm>. */
using Realm = String;
} // BidiScript
#endif // ENABLE(WEBDRIVER_BIDI)
// End of typedefs.

namespace WebDriverBidiHelpers {

String getEnumConstantValue(int code);

template<typename T> String getEnumConstantValue(T enumValue)
{
    return getEnumConstantValue(static_cast<int>(enumValue));
}

} // namespace WebDriverBidiHelpers

#if ENABLE(WEBDRIVER_BIDI)
namespace BidiBrowser {

/* Represents properties of a user context. */
class UserContextInfo final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        UserContextSet = 1 << 0,
        AllFieldsSet = (UserContextSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*UserContextInfo*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            static_assert(STATE == NoFieldsSet, "builder created in non init state");
        }
        friend class UserContextInfo;
    public:

        Builder<STATE | UserContextSet>& setUserContext(const String& in_userContext)
        {
            static_assert(!(STATE & UserContextSet), "property userContext already set");
            m_result->setString("userContext"_s, in_userContext);
            return castState<UserContextSet>();
        }

        Ref<UserContextInfo> release()
        {
            static_assert(STATE == AllFieldsSet, "result is not ready");
            static_assert(sizeof(UserContextInfo) == sizeof(JSON::Object), "cannot cast");

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<UserContextInfo>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<UserContextInfo> result = UserContextInfo::create()
     *     .setUserContext(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

} // BidiBrowser
#endif // ENABLE(WEBDRIVER_BIDI)

#if ENABLE(WEBDRIVER_BIDI)
namespace BidiBrowsingContext {

/* The type of browsing context to be created. */
enum class CreateType {
    Tab = 0,
    Window = 1,
}; // enum class CreateType

/* Information about a navigable. */
class Info final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        ContextSet = 1 << 0,
        UrlSet = 1 << 1,
        OriginalOpenerSet = 1 << 2,
        ChildrenSet = 1 << 3,
        ClientWindowSet = 1 << 4,
        UserContextSet = 1 << 5,
        AllFieldsSet = (ContextSet | UrlSet | OriginalOpenerSet | ChildrenSet | ClientWindowSet | UserContextSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Info*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            static_assert(STATE == NoFieldsSet, "builder created in non init state");
        }
        friend class Info;
    public:

        Builder<STATE | ContextSet>& setContext(const String& in_context)
        {
            static_assert(!(STATE & ContextSet), "property context already set");
            m_result->setString("context"_s, in_context);
            return castState<ContextSet>();
        }

        Builder<STATE | UrlSet>& setUrl(const String& in_url)
        {
            static_assert(!(STATE & UrlSet), "property url already set");
            m_result->setString("url"_s, in_url);
            return castState<UrlSet>();
        }

        Builder<STATE | OriginalOpenerSet>& setOriginalOpener(const String& in_originalOpener)
        {
            static_assert(!(STATE & OriginalOpenerSet), "property originalOpener already set");
            m_result->setString("originalOpener"_s, in_originalOpener);
            return castState<OriginalOpenerSet>();
        }

        Builder<STATE | OriginalOpenerSet>& setOriginalOpenerIsNull()
        {
            static_assert(!(STATE & OriginalOpenerSet), "property originalOpener already set");
            m_result->setValue("originalOpener"_s, JSON::Value::null());
            return castState<OriginalOpenerSet>();
        }

        Builder<STATE | ChildrenSet>& setChildren(Ref<JSON::ArrayOf<Protocol::BidiBrowsingContext::Info>>&& in_children)
        {
            static_assert(!(STATE & ChildrenSet), "property children already set");
            m_result->setArray("children"_s, WTFMove(in_children));
            return castState<ChildrenSet>();
        }

        Builder<STATE | ChildrenSet>& setChildrenIsNull()
        {
            static_assert(!(STATE & ChildrenSet), "property children already set");
            m_result->setValue("children"_s, JSON::Value::null());
            return castState<ChildrenSet>();
        }

        Builder<STATE | ClientWindowSet>& setClientWindow(const String& in_clientWindow)
        {
            static_assert(!(STATE & ClientWindowSet), "property clientWindow already set");
            m_result->setString("clientWindow"_s, in_clientWindow);
            return castState<ClientWindowSet>();
        }

        Builder<STATE | UserContextSet>& setUserContext(const String& in_userContext)
        {
            static_assert(!(STATE & UserContextSet), "property userContext already set");
            m_result->setString("userContext"_s, in_userContext);
            return castState<UserContextSet>();
        }

        Ref<Info> release()
        {
            static_assert(STATE == AllFieldsSet, "result is not ready");
            static_assert(sizeof(Info) == sizeof(JSON::Object), "cannot cast");

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Info>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Info> result = Info::create()
     *     .setContext(...)
     *     .setUrl(...)
     *     .setOriginalOpener(...)
     *     .setChildren(...)
     *     .setClientWindow(...)
     *     .setUserContext(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setOriginalOpener(const String& in_opt_originalOpener)
    {
        JSON::ObjectBase::setString("originalOpener"_s, in_opt_originalOpener);
    }

    void setOriginalOpenerIsNull()
    {
        JSON::ObjectBase::setValue("originalOpener"_s, JSON::Value::null());
    }

    void setChildren(Ref<JSON::ArrayOf<Protocol::BidiBrowsingContext::Info>>&& in_opt_children)
    {
        JSON::ObjectBase::setArray("children"_s, WTFMove(in_opt_children));
    }

    void setChildrenIsNull()
    {
        JSON::ObjectBase::setValue("children"_s, JSON::Value::null());
    }

    void setParent(const String& in_opt_parent)
    {
        JSON::ObjectBase::setString("parent"_s, in_opt_parent);
    }

    void setParentIsNull()
    {
        JSON::ObjectBase::setValue("parent"_s, JSON::Value::null());
    }
};

/* Represents the stage of document loading at which a navigation command will return. */
enum class ReadinessState {
    None = 2,
    Interactive = 3,
    Complete = 4,
}; // enum class ReadinessState

/* Represents the possible user prompt types. */
enum class UserPromptType {
    Alert = 5,
    Beforeunload = 6,
    Confirm = 7,
    Prompt = 8,
}; // enum class UserPromptType

} // BidiBrowsingContext
#endif // ENABLE(WEBDRIVER_BIDI)

#if ENABLE(WEBDRIVER_BIDI)
namespace BidiScript {

/* Whether a script evaluation was successful or had thrown an exception. */
enum class EvaluateResultType {
    Success = 9,
    Exception = 10,
}; // enum class EvaluateResultType

/* Represents the details of a JavaScript exception. */
class ExceptionDetails final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        LineNumberSet = 1 << 0,
        ColumnNumberSet = 1 << 1,
        TextSet = 1 << 2,
        ExceptionSet = 1 << 3,
        StackTraceSet = 1 << 4,
        AllFieldsSet = (LineNumberSet | ColumnNumberSet | TextSet | ExceptionSet | StackTraceSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ExceptionDetails*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            static_assert(STATE == NoFieldsSet, "builder created in non init state");
        }
        friend class ExceptionDetails;
    public:

        Builder<STATE | LineNumberSet>& setLineNumber(double in_lineNumber)
        {
            static_assert(!(STATE & LineNumberSet), "property lineNumber already set");
            m_result->setDouble("lineNumber"_s, in_lineNumber);
            return castState<LineNumberSet>();
        }

        Builder<STATE | ColumnNumberSet>& setColumnNumber(double in_columnNumber)
        {
            static_assert(!(STATE & ColumnNumberSet), "property columnNumber already set");
            m_result->setDouble("columnNumber"_s, in_columnNumber);
            return castState<ColumnNumberSet>();
        }

        Builder<STATE | TextSet>& setText(const String& in_text)
        {
            static_assert(!(STATE & TextSet), "property text already set");
            m_result->setString("text"_s, in_text);
            return castState<TextSet>();
        }

        Builder<STATE | ExceptionSet>& setException(Ref<Protocol::BidiScript::RemoteValue>&& in_exception)
        {
            static_assert(!(STATE & ExceptionSet), "property exception already set");
            m_result->setObject("exception"_s, WTFMove(in_exception));
            return castState<ExceptionSet>();
        }

        Builder<STATE | StackTraceSet>& setStackTrace(Ref<Protocol::BidiScript::StackTrace>&& in_stackTrace)
        {
            static_assert(!(STATE & StackTraceSet), "property stackTrace already set");
            m_result->setObject("stackTrace"_s, WTFMove(in_stackTrace));
            return castState<StackTraceSet>();
        }

        Ref<ExceptionDetails> release()
        {
            static_assert(STATE == AllFieldsSet, "result is not ready");
            static_assert(sizeof(ExceptionDetails) == sizeof(JSON::Object), "cannot cast");

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<ExceptionDetails>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ExceptionDetails> result = ExceptionDetails::create()
     *     .setLineNumber(...)
     *     .setColumnNumber(...)
     *     .setText(...)
     *     .setException(...)
     *     .setStackTrace(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Represents a value which can be deserialized into ECMAScript. This includes both primitive and non-primitive values as well as remote references (<code>BidiScript.RemoteReference</code>) and channels (<code>BidiScript.Channel</code>). */
class LocalValue final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        ValueSet = 1 << 1,
        AllFieldsSet = (TypeSet | ValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*LocalValue*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            static_assert(STATE == NoFieldsSet, "builder created in non init state");
        }
        friend class LocalValue;
    public:

        Builder<STATE | TypeSet>& setType(Protocol::BidiScript::LocalValueType in_type)
        {
            static_assert(!(STATE & TypeSet), "property type already set");
            m_result->setString("type"_s, Protocol::WebDriverBidiHelpers::getEnumConstantValue(in_type));
            return castState<TypeSet>();
        }

        Builder<STATE | ValueSet>& setValue(Ref<JSON::Value>&& in_value)
        {
            static_assert(!(STATE & ValueSet), "property value already set");
            m_result->setValue("value"_s, WTFMove(in_value));
            return castState<ValueSet>();
        }

        Ref<LocalValue> release()
        {
            static_assert(STATE == AllFieldsSet, "result is not ready");
            static_assert(sizeof(LocalValue) == sizeof(JSON::Object), "cannot cast");

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<LocalValue>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<LocalValue> result = LocalValue::create()
     *     .setType(...)
     *     .setValue(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Represents the concrete type of a <code>BidiScript.LocalValue</code> */
enum class LocalValueType {
    Array = 11,
    Date = 12,
    Map = 13,
    Object = 14,
    Set = 15,
}; // enum class LocalValueType

/* A mirror object that is used to introspect values accessible from the ECMAScript runtime. The fields used and their semantics depends on the value's type (<cod>BidiScript.RemoteValueType</code>) */
class RemoteValue final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        AllFieldsSet = (TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*RemoteValue*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            static_assert(STATE == NoFieldsSet, "builder created in non init state");
        }
        friend class RemoteValue;
    public:

        Builder<STATE | TypeSet>& setType(Protocol::BidiScript::RemoteValueType in_type)
        {
            static_assert(!(STATE & TypeSet), "property type already set");
            m_result->setString("type"_s, Protocol::WebDriverBidiHelpers::getEnumConstantValue(in_type));
            return castState<TypeSet>();
        }

        Ref<RemoteValue> release()
        {
            static_assert(STATE == AllFieldsSet, "result is not ready");
            static_assert(sizeof(RemoteValue) == sizeof(JSON::Object), "cannot cast");

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<RemoteValue>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<RemoteValue> result = RemoteValue::create()
     *     .setType(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setValue(Ref<JSON::Value>&& in_opt_value)
    {
        JSON::ObjectBase::setValue("value"_s, WTFMove(in_opt_value));
    }

    void setHandle(const String& in_opt_handle)
    {
        JSON::ObjectBase::setString("handle"_s, in_opt_handle);
    }

    void setInternalId(const String& in_opt_internalId)
    {
        JSON::ObjectBase::setString("internalId"_s, in_opt_internalId);
    }
};

/* The type of a mirror object that represents a value accessible from the ECMAScript runtime. */
enum class RemoteValueType {
    Array = 11,
    Arraybuffer = 16,
    Date = 12,
    Error = 17,
    Function = 18,
    Generator = 19,
    HTMLcollection = 20,
    Map = 13,
    Node = 21,
    Nodelist = 22,
    Object = 14,
    Promise = 23,
    Proxy = 24,
    Regexp = 25,
    Set = 15,
    Symbol = 26,
    Typedarray = 27,
    Weakmap = 28,
    Weakset = 29,
    Window = 1,
}; // enum class RemoteValueType

/* Specifies whether a serialized value will be treated as a global root (and therefore except from garbage collection). */
enum class ResultOwnership {
    Root = 30,
    None = 2,
}; // enum class ResultOwnership

/* Describes options to be used when serializing JavaScript objects. */
class SerializationOptions final : public JSON::ObjectBase {
public:
    // Named after property name 'includesShadowTree' while generating SerializationOptions.
    enum class IncludesShadowTree {
        None = 2,
        Open = 31,
        All = 32,
    }; // enum class IncludesShadowTree

    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*SerializationOptions*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            static_assert(STATE == NoFieldsSet, "builder created in non init state");
        }
        friend class SerializationOptions;
    public:

        Ref<SerializationOptions> release()
        {
            static_assert(STATE == AllFieldsSet, "result is not ready");
            static_assert(sizeof(SerializationOptions) == sizeof(JSON::Object), "cannot cast");

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<SerializationOptions>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<SerializationOptions> result = SerializationOptions::create()
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setMaxDomDepth(double in_opt_maxDomDepth)
    {
        JSON::ObjectBase::setDouble("maxDomDepth"_s, in_opt_maxDomDepth);
    }

    void setMaxObjectDepth(double in_opt_maxObjectDepth)
    {
        JSON::ObjectBase::setDouble("maxObjectDepth"_s, in_opt_maxObjectDepth);
    }

    void setIncludesShadowTree(IncludesShadowTree in_opt_includesShadowTree)
    {
        JSON::ObjectBase::setString("includesShadowTree"_s, Protocol::WebDriverBidiHelpers::getEnumConstantValue(in_opt_includesShadowTree));
    }
};

/* Represents a single call frame within a <code>BidiScript.StackTrace</code>. */
class StackFrame final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        LineNumberSet = 1 << 0,
        ColumnNumberSet = 1 << 1,
        FunctionNameSet = 1 << 2,
        UrlSet = 1 << 3,
        AllFieldsSet = (LineNumberSet | ColumnNumberSet | FunctionNameSet | UrlSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*StackFrame*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            static_assert(STATE == NoFieldsSet, "builder created in non init state");
        }
        friend class StackFrame;
    public:

        Builder<STATE | LineNumberSet>& setLineNumber(double in_lineNumber)
        {
            static_assert(!(STATE & LineNumberSet), "property lineNumber already set");
            m_result->setDouble("lineNumber"_s, in_lineNumber);
            return castState<LineNumberSet>();
        }

        Builder<STATE | ColumnNumberSet>& setColumnNumber(double in_columnNumber)
        {
            static_assert(!(STATE & ColumnNumberSet), "property columnNumber already set");
            m_result->setDouble("columnNumber"_s, in_columnNumber);
            return castState<ColumnNumberSet>();
        }

        Builder<STATE | FunctionNameSet>& setFunctionName(const String& in_functionName)
        {
            static_assert(!(STATE & FunctionNameSet), "property functionName already set");
            m_result->setString("functionName"_s, in_functionName);
            return castState<FunctionNameSet>();
        }

        Builder<STATE | UrlSet>& setUrl(const String& in_url)
        {
            static_assert(!(STATE & UrlSet), "property url already set");
            m_result->setString("url"_s, in_url);
            return castState<UrlSet>();
        }

        Ref<StackFrame> release()
        {
            static_assert(STATE == AllFieldsSet, "result is not ready");
            static_assert(sizeof(StackFrame) == sizeof(JSON::Object), "cannot cast");

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<StackFrame>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<StackFrame> result = StackFrame::create()
     *     .setLineNumber(...)
     *     .setColumnNumber(...)
     *     .setFunctionName(...)
     *     .setUrl(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Represents the JavaScript stack at a point in script execution. */
class StackTrace final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        CallFramesSet = 1 << 0,
        AllFieldsSet = (CallFramesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*StackTrace*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            static_assert(STATE == NoFieldsSet, "builder created in non init state");
        }
        friend class StackTrace;
    public:

        Builder<STATE | CallFramesSet>& setCallFrames(Ref<JSON::ArrayOf<Protocol::BidiScript::StackFrame>>&& in_callFrames)
        {
            static_assert(!(STATE & CallFramesSet), "property callFrames already set");
            m_result->setArray("callFrames"_s, WTFMove(in_callFrames));
            return castState<CallFramesSet>();
        }

        Ref<StackTrace> release()
        {
            static_assert(STATE == AllFieldsSet, "result is not ready");
            static_assert(sizeof(StackTrace) == sizeof(JSON::Object), "cannot cast");

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<StackTrace>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<StackTrace> result = StackTrace::create()
     *     .setCallFrames(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* A type that represents a place to evaluate JavaScript. It is either a <code>BidiBrowsingContext.BrowsingContext</code> or a <code>BidiScript.Realm</code>. */
class Target final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Target*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            static_assert(STATE == NoFieldsSet, "builder created in non init state");
        }
        friend class Target;
    public:

        Ref<Target> release()
        {
            static_assert(STATE == AllFieldsSet, "result is not ready");
            static_assert(sizeof(Target) == sizeof(JSON::Object), "cannot cast");

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<Target>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Target> result = Target::create()
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setRealm(const String& in_opt_realm)
    {
        JSON::ObjectBase::setString("realm"_s, in_opt_realm);
    }

    void setContext(const String& in_opt_context)
    {
        JSON::ObjectBase::setString("context"_s, in_opt_context);
    }

    void setSandbox(const String& in_opt_sandbox)
    {
        JSON::ObjectBase::setString("sandbox"_s, in_opt_sandbox);
    }
};

} // BidiScript
#endif // ENABLE(WEBDRIVER_BIDI)

#if ENABLE(WEBDRIVER_BIDI)
namespace BidiSession {

/* A type that represents the behavior of the user prompt handler. */
enum class UserPromptHandlerType {
    Accept = 33,
    Dismiss = 34,
    Ignore = 35,
}; // enum class UserPromptHandlerType

} // BidiSession
#endif // ENABLE(WEBDRIVER_BIDI)

#if ENABLE(WEBDRIVER_BIDI)
namespace BidiStorage {

/* The <code>BidiStorage.PartitionKey</code> type represents a storage partition key. */
class PartitionKey final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*PartitionKey*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            static_assert(STATE == NoFieldsSet, "builder created in non init state");
        }
        friend class PartitionKey;
    public:

        Ref<PartitionKey> release()
        {
            static_assert(STATE == AllFieldsSet, "result is not ready");
            static_assert(sizeof(PartitionKey) == sizeof(JSON::Object), "cannot cast");

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<PartitionKey>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<PartitionKey> result = PartitionKey::create()
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setUserContext(const String& in_opt_userContext)
    {
        JSON::ObjectBase::setString("userContext"_s, in_opt_userContext);
    }

    void setSourceOrigin(const String& in_opt_sourceOrigin)
    {
        JSON::ObjectBase::setString("sourceOrigin"_s, in_opt_sourceOrigin);
    }
};

/* Filter parameters for cookie retrieval and deletion. */
class CookieFilter final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CookieFilter*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            static_assert(STATE == NoFieldsSet, "builder created in non init state");
        }
        friend class CookieFilter;
    public:

        Ref<CookieFilter> release()
        {
            static_assert(STATE == AllFieldsSet, "result is not ready");
            static_assert(sizeof(CookieFilter) == sizeof(JSON::Object), "cannot cast");

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<CookieFilter>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CookieFilter> result = CookieFilter::create()
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setName(const String& in_opt_name)
    {
        JSON::ObjectBase::setString("name"_s, in_opt_name);
    }

    void setValue(const String& in_opt_value)
    {
        JSON::ObjectBase::setString("value"_s, in_opt_value);
    }

    void setDomain(const String& in_opt_domain)
    {
        JSON::ObjectBase::setString("domain"_s, in_opt_domain);
    }

    void setPath(const String& in_opt_path)
    {
        JSON::ObjectBase::setString("path"_s, in_opt_path);
    }

    void setSize(int in_opt_size)
    {
        JSON::ObjectBase::setInteger("size"_s, in_opt_size);
    }

    void setHttpOnly(bool in_opt_httpOnly)
    {
        JSON::ObjectBase::setBoolean("httpOnly"_s, in_opt_httpOnly);
    }

    void setSecure(bool in_opt_secure)
    {
        JSON::ObjectBase::setBoolean("secure"_s, in_opt_secure);
    }

    void setSameSite(const String& in_opt_sameSite)
    {
        JSON::ObjectBase::setString("sameSite"_s, in_opt_sameSite);
    }

    void setExpiry(int in_opt_expiry)
    {
        JSON::ObjectBase::setInteger("expiry"_s, in_opt_expiry);
    }
};

/* Describes a storage partition based on a browsing context. */
class BrowsingContextPartitionDescriptor final : public JSON::ObjectBase {
public:
    // Named after property name 'type' while generating BrowsingContextPartitionDescriptor.
    enum class Type {
        Context = 36,
    }; // enum class Type

    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        ContextSet = 1 << 1,
        AllFieldsSet = (TypeSet | ContextSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*BrowsingContextPartitionDescriptor*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            static_assert(STATE == NoFieldsSet, "builder created in non init state");
        }
        friend class BrowsingContextPartitionDescriptor;
    public:

        Builder<STATE | TypeSet>& setType(Type in_type)
        {
            static_assert(!(STATE & TypeSet), "property type already set");
            m_result->setString("type"_s, Protocol::WebDriverBidiHelpers::getEnumConstantValue(in_type));
            return castState<TypeSet>();
        }

        Builder<STATE | ContextSet>& setContext(const String& in_context)
        {
            static_assert(!(STATE & ContextSet), "property context already set");
            m_result->setString("context"_s, in_context);
            return castState<ContextSet>();
        }

        Ref<BrowsingContextPartitionDescriptor> release()
        {
            static_assert(STATE == AllFieldsSet, "result is not ready");
            static_assert(sizeof(BrowsingContextPartitionDescriptor) == sizeof(JSON::Object), "cannot cast");

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<BrowsingContextPartitionDescriptor>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<BrowsingContextPartitionDescriptor> result = BrowsingContextPartitionDescriptor::create()
     *     .setType(...)
     *     .setContext(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Describes a storage partition based on a storage key. */
class StorageKeyPartitionDescriptor final : public JSON::ObjectBase {
public:
    // Named after property name 'type' while generating StorageKeyPartitionDescriptor.
    enum class Type {
        StorageKey = 37,
    }; // enum class Type

    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        AllFieldsSet = (TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*StorageKeyPartitionDescriptor*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            static_assert(STATE == NoFieldsSet, "builder created in non init state");
        }
        friend class StorageKeyPartitionDescriptor;
    public:

        Builder<STATE | TypeSet>& setType(Type in_type)
        {
            static_assert(!(STATE & TypeSet), "property type already set");
            m_result->setString("type"_s, Protocol::WebDriverBidiHelpers::getEnumConstantValue(in_type));
            return castState<TypeSet>();
        }

        Ref<StorageKeyPartitionDescriptor> release()
        {
            static_assert(STATE == AllFieldsSet, "result is not ready");
            static_assert(sizeof(StorageKeyPartitionDescriptor) == sizeof(JSON::Object), "cannot cast");

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<StorageKeyPartitionDescriptor>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<StorageKeyPartitionDescriptor> result = StorageKeyPartitionDescriptor::create()
     *     .setType(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setUserContext(const String& in_opt_userContext)
    {
        JSON::ObjectBase::setString("userContext"_s, in_opt_userContext);
    }

    void setSourceOrigin(const String& in_opt_sourceOrigin)
    {
        JSON::ObjectBase::setString("sourceOrigin"_s, in_opt_sourceOrigin);
    }
};

/* The type of storage partition descriptor. */
enum class PartitionDescriptorType {
    Context = 36,
    StorageKey = 37,
}; // enum class PartitionDescriptorType

/* Describes a storage partition. */
class PartitionDescriptor final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        AllFieldsSet = (TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*PartitionDescriptor*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            static_assert(STATE == NoFieldsSet, "builder created in non init state");
        }
        friend class PartitionDescriptor;
    public:

        Builder<STATE | TypeSet>& setType(Protocol::BidiStorage::PartitionDescriptorType in_type)
        {
            static_assert(!(STATE & TypeSet), "property type already set");
            m_result->setString("type"_s, Protocol::WebDriverBidiHelpers::getEnumConstantValue(in_type));
            return castState<TypeSet>();
        }

        Ref<PartitionDescriptor> release()
        {
            static_assert(STATE == AllFieldsSet, "result is not ready");
            static_assert(sizeof(PartitionDescriptor) == sizeof(JSON::Object), "cannot cast");

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<PartitionDescriptor>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<PartitionDescriptor> result = PartitionDescriptor::create()
     *     .setType(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setContext(const String& in_opt_context)
    {
        JSON::ObjectBase::setString("context"_s, in_opt_context);
    }

    void setUserContext(const String& in_opt_userContext)
    {
        JSON::ObjectBase::setString("userContext"_s, in_opt_userContext);
    }

    void setSourceOrigin(const String& in_opt_sourceOrigin)
    {
        JSON::ObjectBase::setString("sourceOrigin"_s, in_opt_sourceOrigin);
    }
};

/* Enumerates values for cookies same site policy. */
enum class CookieSameSitePolicy {
    None = 38,
    Lax = 39,
    Strict = 40,
}; // enum class CookieSameSitePolicy

/* Represents a cookie to be set. */
class PartialCookie final : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        ValueSet = 1 << 1,
        DomainSet = 1 << 2,
        AllFieldsSet = (NameSet | ValueSet | DomainSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*PartialCookie*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            static_assert(STATE == NoFieldsSet, "builder created in non init state");
        }
        friend class PartialCookie;
    public:

        Builder<STATE | NameSet>& setName(const String& in_name)
        {
            static_assert(!(STATE & NameSet), "property name already set");
            m_result->setString("name"_s, in_name);
            return castState<NameSet>();
        }

        Builder<STATE | ValueSet>& setValue(const String& in_value)
        {
            static_assert(!(STATE & ValueSet), "property value already set");
            m_result->setString("value"_s, in_value);
            return castState<ValueSet>();
        }

        Builder<STATE | DomainSet>& setDomain(const String& in_domain)
        {
            static_assert(!(STATE & DomainSet), "property domain already set");
            m_result->setString("domain"_s, in_domain);
            return castState<DomainSet>();
        }

        Ref<PartialCookie> release()
        {
            static_assert(STATE == AllFieldsSet, "result is not ready");
            static_assert(sizeof(PartialCookie) == sizeof(JSON::Object), "cannot cast");

            Ref<JSON::Object> jsonResult = m_result.releaseNonNull();
            auto result = WTFMove(*reinterpret_cast<Ref<PartialCookie>*>(&jsonResult));
            return result;
        }
    };

    /*
     * Synthetic constructor:
     * Ref<PartialCookie> result = PartialCookie::create()
     *     .setName(...)
     *     .setValue(...)
     *     .setDomain(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setPath(const String& in_opt_path)
    {
        JSON::ObjectBase::setString("path"_s, in_opt_path);
    }

    void setHttpOnly(bool in_opt_httpOnly)
    {
        JSON::ObjectBase::setBoolean("httpOnly"_s, in_opt_httpOnly);
    }

    void setSecure(bool in_opt_secure)
    {
        JSON::ObjectBase::setBoolean("secure"_s, in_opt_secure);
    }

    void setSameSite(Protocol::BidiStorage::CookieSameSitePolicy in_opt_sameSite)
    {
        JSON::ObjectBase::setString("sameSite"_s, Protocol::WebDriverBidiHelpers::getEnumConstantValue(in_opt_sameSite));
    }

    void setExpiry(int in_opt_expiry)
    {
        JSON::ObjectBase::setInteger("expiry"_s, in_opt_expiry);
    }
};

} // BidiStorage
#endif // ENABLE(WEBDRIVER_BIDI)



namespace WebDriverBidiHelpers {

template<typename ProtocolEnumType>
std::optional<ProtocolEnumType> parseEnumValueFromString(const String&);

#if ENABLE(WEBDRIVER_BIDI)
// Enums in the 'BidiBrowsingContext' Domain
template<>
std::optional<Protocol::BidiBrowsingContext::CreateType> parseEnumValueFromString<Protocol::BidiBrowsingContext::CreateType>(const String&);
template<>
std::optional<Protocol::BidiBrowsingContext::ReadinessState> parseEnumValueFromString<Protocol::BidiBrowsingContext::ReadinessState>(const String&);
template<>
std::optional<Protocol::BidiBrowsingContext::UserPromptType> parseEnumValueFromString<Protocol::BidiBrowsingContext::UserPromptType>(const String&);
#endif // ENABLE(WEBDRIVER_BIDI)

#if ENABLE(WEBDRIVER_BIDI)
// Enums in the 'BidiScript' Domain
template<>
std::optional<Protocol::BidiScript::EvaluateResultType> parseEnumValueFromString<Protocol::BidiScript::EvaluateResultType>(const String&);
template<>
std::optional<Protocol::BidiScript::LocalValueType> parseEnumValueFromString<Protocol::BidiScript::LocalValueType>(const String&);
template<>
std::optional<Protocol::BidiScript::RemoteValueType> parseEnumValueFromString<Protocol::BidiScript::RemoteValueType>(const String&);
template<>
std::optional<Protocol::BidiScript::ResultOwnership> parseEnumValueFromString<Protocol::BidiScript::ResultOwnership>(const String&);
template<>
std::optional<Protocol::BidiScript::SerializationOptions::IncludesShadowTree> parseEnumValueFromString<Protocol::BidiScript::SerializationOptions::IncludesShadowTree>(const String&);
#endif // ENABLE(WEBDRIVER_BIDI)

#if ENABLE(WEBDRIVER_BIDI)
// Enums in the 'BidiSession' Domain
template<>
std::optional<Protocol::BidiSession::UserPromptHandlerType> parseEnumValueFromString<Protocol::BidiSession::UserPromptHandlerType>(const String&);
#endif // ENABLE(WEBDRIVER_BIDI)

#if ENABLE(WEBDRIVER_BIDI)
// Enums in the 'BidiStorage' Domain
template<>
std::optional<Protocol::BidiStorage::PartitionDescriptorType> parseEnumValueFromString<Protocol::BidiStorage::PartitionDescriptorType>(const String&);
template<>
std::optional<Protocol::BidiStorage::CookieSameSitePolicy> parseEnumValueFromString<Protocol::BidiStorage::CookieSameSitePolicy>(const String&);
template<>
std::optional<Protocol::BidiStorage::BrowsingContextPartitionDescriptor::Type> parseEnumValueFromString<Protocol::BidiStorage::BrowsingContextPartitionDescriptor::Type>(const String&);
template<>
std::optional<Protocol::BidiStorage::StorageKeyPartitionDescriptor::Type> parseEnumValueFromString<Protocol::BidiStorage::StorageKeyPartitionDescriptor::Type>(const String&);
#endif // ENABLE(WEBDRIVER_BIDI)

} // namespace WebDriverBidiHelpers

} // namespace Protocol

} // namespace Inspector

namespace WTF {

template<typename T> struct DefaultHash;
#if ENABLE(WEBDRIVER_BIDI)

// Hash declarations in the 'BidiBrowsingContext' Domain
template<>
struct DefaultHash<Inspector::Protocol::BidiBrowsingContext::CreateType> : IntHash<Inspector::Protocol::BidiBrowsingContext::CreateType> { };
template<>
struct DefaultHash<Inspector::Protocol::BidiBrowsingContext::ReadinessState> : IntHash<Inspector::Protocol::BidiBrowsingContext::ReadinessState> { };
template<>
struct DefaultHash<Inspector::Protocol::BidiBrowsingContext::UserPromptType> : IntHash<Inspector::Protocol::BidiBrowsingContext::UserPromptType> { };
#endif // ENABLE(WEBDRIVER_BIDI)
#if ENABLE(WEBDRIVER_BIDI)

// Hash declarations in the 'BidiScript' Domain
template<>
struct DefaultHash<Inspector::Protocol::BidiScript::EvaluateResultType> : IntHash<Inspector::Protocol::BidiScript::EvaluateResultType> { };
template<>
struct DefaultHash<Inspector::Protocol::BidiScript::LocalValueType> : IntHash<Inspector::Protocol::BidiScript::LocalValueType> { };
template<>
struct DefaultHash<Inspector::Protocol::BidiScript::RemoteValueType> : IntHash<Inspector::Protocol::BidiScript::RemoteValueType> { };
template<>
struct DefaultHash<Inspector::Protocol::BidiScript::ResultOwnership> : IntHash<Inspector::Protocol::BidiScript::ResultOwnership> { };
#endif // ENABLE(WEBDRIVER_BIDI)
#if ENABLE(WEBDRIVER_BIDI)

// Hash declarations in the 'BidiSession' Domain
template<>
struct DefaultHash<Inspector::Protocol::BidiSession::UserPromptHandlerType> : IntHash<Inspector::Protocol::BidiSession::UserPromptHandlerType> { };
#endif // ENABLE(WEBDRIVER_BIDI)
#if ENABLE(WEBDRIVER_BIDI)

// Hash declarations in the 'BidiStorage' Domain
template<>
struct DefaultHash<Inspector::Protocol::BidiStorage::PartitionDescriptorType> : IntHash<Inspector::Protocol::BidiStorage::PartitionDescriptorType> { };
template<>
struct DefaultHash<Inspector::Protocol::BidiStorage::CookieSameSitePolicy> : IntHash<Inspector::Protocol::BidiStorage::CookieSameSitePolicy> { };
#endif // ENABLE(WEBDRIVER_BIDI)

} // namespace WTF
