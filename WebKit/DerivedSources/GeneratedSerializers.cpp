/*
 * Copyright (C) 2022-2023 Apple Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "config.h"
#include "GeneratedSerializers.h"
#include "GeneratedWebKitSecureCoding.h"

#include "APIArray.h"
#include "APIDictionary.h"
#include "APIError.h"
#include "APIFrameHandle.h"
#include "APIGeometry.h"
#include "APINumber.h"
#include "APIObject.h"
#include "APIPageHandle.h"
#include "APIString.h"
#include "APIURL.h"
#include "APIURLRequest.h"
#include "APIURLResponse.h"
#include "APIUserContentURLPattern.h"
#include "AccessibilityPreferences.h"
#include "ArgumentCoders.h"
#if USE(SOUP)
#include "ArgumentCodersGLib.h"
#endif
#if PLATFORM(GTK)
#include "ArgumentCodersGtk.h"
#endif
#if USE(UNIX_DOMAIN_SOCKETS)
#include "ArgumentCodersUnix.h"
#endif
#if ENABLE(GPU_PROCESS) && ENABLE(VIDEO)
#include "AudioTrackPrivateRemoteConfiguration.h"
#endif
#include "AuthenticationChallengeDisposition.h"
#include "AuxiliaryProcessCreationParameters.h"
#if ENABLE(MODEL_PROCESS)
#include "AuxiliaryProcessCreationParameters.h"
#endif
#include "BackgroundFetchChange.h"
#include "BackgroundFetchState.h"
#if ENABLE(GPU_PROCESS)
#include "BufferIdentifierSet.h"
#endif
#include "CacheModel.h"
#include "CallbackID.h"
#include "ContentWorldData.h"
#if ENABLE(CONTEXT_MENUS)
#include "ContextMenuContextData.h"
#endif
#include "CoordinateSystem.h"
#if USE(SKIA)
#include "CoreIPCSkColorSpace.h"
#endif
#if USE(SKIA)
#include "CoreIPCSkData.h"
#endif
#if USE(SKIA)
#include "CoreIPCSkFontStyleSlant.h"
#endif
#if USE(SKIA)
#include "CoreIPCSkString.h"
#endif
#include "DebuggableInfoData.h"
#if PLATFORM(IOS_FAMILY)
#include "DocumentEditingContext.h"
#endif
#include "DragControllerAction.h"
#include "EditingRange.h"
#include "EditorState.h"
#include "FileSystemStorageError.h"
#include "FileSystemSyncAccessHandleInfo.h"
#include "FocusedElementInformation.h"
#include "FormDataReference.h"
#include "FrameInfoData.h"
#include "FrameTreeCreationParameters.h"
#include "FrameTreeNodeData.h"
#include "FullScreenMediaDetails.h"
#if ENABLE(GPU_PROCESS)
#include "GPUProcessConnectionInfo.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "GPUProcessConnectionParameters.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "GPUProcessCreationParameters.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "GPUProcessPreferences.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "GPUProcessSessionParameters.h"
#endif
#if ENABLE(GAMEPAD)
#include "GamepadData.h"
#endif
#include "GoToBackForwardItemParameters.h"
#include "ITPThirdPartyData.h"
#include "ITPThirdPartyDataForSpecificFirstParty.h"
#include "ImageBufferBackendHandle.h"
#include "ImageOptions.h"
#if ENABLE(GPU_PROCESS) && ENABLE(MEDIA_SOURCE)
#include "InitializationSegmentInfo.h"
#endif
#include "InjectUserScriptImmediately.h"
#include "InspectorExtensionTypes.h"
#include "JavaScriptEvaluationResult.h"
#include "LayerTreeContext.h"
#include "LoadParameters.h"
#if ENABLE(GPU_PROCESS) && ENABLE(MEDIA_SOURCE)
#include "MediaDescriptionInfo.h"
#endif
#if ENABLE(MEDIA_STREAM)
#include "MediaDeviceSandboxExtensions.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "MediaOverridesForTesting.h"
#endif
#include "MediaPlaybackState.h"
#if ENABLE(GPU_PROCESS) && ENABLE(VIDEO)
#include "MediaPlayerPrivateRemote.h"
#endif
#if ENABLE(ARKIT_INLINE_PREVIEW)
#include "ModelIdentifier.h"
#endif
#if ENABLE(MODEL_PROCESS)
#include "ModelProcessConnectionInfo.h"
#endif
#if ENABLE(MODEL_PROCESS)
#include "ModelProcessConnectionParameters.h"
#endif
#if ENABLE(MODEL_PROCESS)
#include "ModelProcessCreationParameters.h"
#endif
#include "MonotonicObjectIdentifier.h"
#include "NavigationActionData.h"
#include "NetworkProcessConnectionInfo.h"
#include "NetworkProcessConnectionParameters.h"
#include "NetworkProcessCreationParameters.h"
#include "NetworkResourceLoadParameters.h"
#include "NetworkSessionCreationParameters.h"
#include "NodeInfo.h"
#include "PlatformFontInfo.h"
#include "PlatformPopupMenuData.h"
#include "PolicyDecision.h"
#if ENABLE(GPU_PROCESS) && PLATFORM(COCOA)
#include "PrepareBackingStoreBuffersData.h"
#endif
#include "PrintInfo.h"
#include "PrivateClickMeasurementManagerInterface.h"
#include "ProvisionalFrameCreationParameters.h"
#if USE(LIBWEBRTC)
#include "RTCNetwork.h"
#endif
#if USE(LIBWEBRTC)
#include "RTCPacketOptions.h"
#endif
#if (USE(LIBWEBRTC)) && (USE(LIBWEBRTC) && PLATFORM(COCOA))
#include "RTCWebKitEncodedFrameInfo.h"
#endif
#if ENABLE(GPU_PROCESS) && USE(AUDIO_SESSION)
#include "RemoteAudioSessionConfiguration.h"
#endif
#if ENABLE(GPU_PROCESS) && ENABLE(ENCRYPTED_MEDIA)
#include "RemoteCDMConfiguration.h"
#endif
#if ENABLE(GPU_PROCESS) && ENABLE(ENCRYPTED_MEDIA)
#include "RemoteCDMInstanceConfiguration.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "RemoteGPURequestAdapterResponse.h"
#endif
#if ENABLE(GPU_PROCESS) && ENABLE(WEBGL)
#include "RemoteGraphicsContextGLInitializationState.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "RemoteImageBufferSetConfiguration.h"
#endif
#if ENABLE(GPU_PROCESS) && PLATFORM(COCOA)
#include "RemoteImageBufferSetIdentifier.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "RemoteMediaPlayerConfiguration.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "RemoteMediaPlayerProxyConfiguration.h"
#endif
#if ENABLE(GPU_PROCESS) && ENABLE(VIDEO)
#include "RemoteMediaPlayerState.h"
#endif
#if ENABLE(GPU_PROCESS) && PLATFORM(IOS_FAMILY)
#include "RemoteMediaSessionHelper.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "RemoteSerializedImageBufferIdentifier.h"
#endif
#if ENABLE(GPU_PROCESS) && ENABLE(VIDEO)
#include "RemoteTrackInfo.h"
#endif
#if ENABLE(GPU_PROCESS) && ENABLE(VIDEO)
#include "RemoteVideoFrameIdentifier.h"
#endif
#if ENABLE(GPU_PROCESS) && ENABLE(VIDEO)
#include "RemoteVideoFrameProxyProperties.h"
#endif
#if ENABLE(TOUCH_EVENTS)
#include "RemoteWebTouchEvent.h"
#endif
#include "RemoteWorkerInitializationData.h"
#include "RemoteWorkerType.h"
#include "ResourceLoadInfo.h"
#include "ResourceLoadStatisticsParameters.h"
#include "RunJavaScriptParameters.h"
#include "SameDocumentNavigationType.h"
#include "ScriptTrackingPrivacyFilter.h"
#if ENABLE(MOMENTUM_EVENT_DISPATCHER)
#include "ScrollingAccelerationCurve.h"
#endif
#include "SessionState.h"
#include "SharedBufferReference.h"
#include "SharedFileHandle.h"
#include "SharedPreferencesForWebProcess.h"
#if ENABLE(GPU_PROCESS) && PLATFORM(COCOA) && ENABLE(VIDEO)
#include "SharedVideoFrame.h"
#endif
#include "StorageAccessStatus.h"
#include "StreamConnectionEncoder.h"
#include "StreamServerConnection.h"
#include "SyntheticEditingCommandType.h"
#include "TextRecognitionUpdateResult.h"
#if ENABLE(GPU_PROCESS) && ENABLE(VIDEO)
#include "TextTrackPrivateRemoteConfiguration.h"
#endif
#if ENABLE(GPU_PROCESS) && ENABLE(VIDEO)
#include "TrackPrivateRemoteConfiguration.h"
#endif
#include "URLSchemeTaskParameters.h"
#include "UndoOrRedo.h"
#include "UnifiedOriginStorageLevel.h"
#if USE(COORDINATED_GRAPHICS) || USE(TEXTURE_MAPPER)
#include "UpdateInfo.h"
#endif
#include "UserContentControllerParameters.h"
#include "UserData.h"
#if ENABLE(GPU_PROCESS) && ENABLE(VIDEO)
#include "VideoTrackPrivateRemoteConfiguration.h"
#endif
#if ENABLE(UI_SIDE_COMPOSITING)
#include "VisibleContentRectUpdateInfo.h"
#endif
#if USE(GRAPHICS_LAYER_WC)
#include "WCBackingStore.h"
#endif
#if USE(GRAPHICS_LAYER_WC)
#include "WCUpdateInfo.h"
#endif
#include "WebBackForwardListCounts.h"
#if ENABLE(CONTENT_EXTENSIONS)
#include "WebCompiledContentRuleListData.h"
#endif
#if ENABLE(CONTEXT_MENUS)
#include "WebContextMenuItemData.h"
#endif
#include "WebEvent.h"
#if ENABLE(WK_WEB_EXTENSIONS)
#include "WebExtension.h"
#endif
#if ENABLE(WK_WEB_EXTENSIONS_SIDEBAR)
#include "WebExtensionActionClickBehavior.h"
#endif
#if ENABLE(WK_WEB_EXTENSIONS)
#include "WebExtensionAlarmParameters.h"
#endif
#if ENABLE(WK_WEB_EXTENSIONS_BOOKMARKS)
#include "WebExtensionBookmarksParameters.h"
#endif
#if ENABLE(WK_WEB_EXTENSIONS)
#include "WebExtensionCommandParameters.h"
#endif
#if ENABLE(WK_WEB_EXTENSIONS)
#include "WebExtensionContentWorldType.h"
#endif
#if ENABLE(WK_WEB_EXTENSIONS)
#include "WebExtensionContext.h"
#endif
#if ENABLE(WK_WEB_EXTENSIONS)
#include "WebExtensionContextParameters.h"
#endif
#if ENABLE(WK_WEB_EXTENSIONS)
#include "WebExtensionControllerParameters.h"
#endif
#if ENABLE(WK_WEB_EXTENSIONS)
#include "WebExtensionCookieParameters.h"
#endif
#if ENABLE(WK_WEB_EXTENSIONS)
#include "WebExtensionDataType.h"
#endif
#if ENABLE(WK_WEB_EXTENSIONS)
#include "WebExtensionEventListenerType.h"
#endif
#if ENABLE(WK_WEB_EXTENSIONS)
#include "WebExtensionFrameParameters.h"
#endif
#if ENABLE(WK_WEB_EXTENSIONS)
#include "WebExtensionMatchedRuleParameters.h"
#endif
#if ENABLE(WK_WEB_EXTENSIONS)
#include "WebExtensionMenuItemContextParameters.h"
#endif
#if ENABLE(WK_WEB_EXTENSIONS)
#include "WebExtensionMenuItemParameters.h"
#endif
#if ENABLE(WK_WEB_EXTENSIONS)
#include "WebExtensionMessageSenderParameters.h"
#endif
#if ENABLE(WK_WEB_EXTENSIONS)
#include "WebExtensionMessageTargetParameters.h"
#endif
#if ENABLE(WK_WEB_EXTENSIONS)
#include "WebExtensionRegisteredScriptParameters.h"
#endif
#if ENABLE(WK_WEB_EXTENSIONS)
#include "WebExtensionScriptInjectionParameters.h"
#endif
#if ENABLE(WK_WEB_EXTENSIONS)
#include "WebExtensionScriptInjectionResultParameters.h"
#endif
#if ENABLE(WK_WEB_EXTENSIONS_SIDEBAR)
#include "WebExtensionSidebarParameters.h"
#endif
#if ENABLE(WK_WEB_EXTENSIONS)
#include "WebExtensionStorageAccessLevel.h"
#endif
#if ENABLE(WK_WEB_EXTENSIONS)
#include "WebExtensionTab.h"
#endif
#if ENABLE(WK_WEB_EXTENSIONS)
#include "WebExtensionTabParameters.h"
#endif
#if ENABLE(WK_WEB_EXTENSIONS)
#include "WebExtensionTabQueryParameters.h"
#endif
#if ENABLE(WK_WEB_EXTENSIONS)
#include "WebExtensionWindow.h"
#endif
#if ENABLE(WK_WEB_EXTENSIONS)
#include "WebExtensionWindowParameters.h"
#endif
#include "WebFindOptions.h"
#include "WebFoundTextRange.h"
#include "WebFrameMetrics.h"
#if ENABLE(GPU_PROCESS)
#include "WebGPUBindGroupDescriptor.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUBindGroupEntry.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUBindGroupLayoutDescriptor.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUBindGroupLayoutEntry.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUBlendComponent.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUBlendState.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUBufferBinding.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUBufferBindingLayout.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUBufferDescriptor.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUCanvasConfiguration.h"
#endif
#include "WebGPUColor.h"
#if ENABLE(GPU_PROCESS)
#include "WebGPUColorTargetState.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUCommandBufferDescriptor.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUCommandEncoderDescriptor.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUCompilationMessage.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUComputePassDescriptor.h"
#endif
#include "WebGPUComputePassTimestampWrites.h"
#if ENABLE(GPU_PROCESS)
#include "WebGPUComputePipelineDescriptor.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUDepthStencilState.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUDeviceDescriptor.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUError.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUExtent3D.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUExternalTextureBindingLayout.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUExternalTextureDescriptor.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUFragmentState.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUImageCopyBuffer.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUImageCopyExternalImage.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUImageCopyTexture.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUImageCopyTextureTagged.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUImageDataLayout.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUInternalError.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUMultisampleState.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUObjectDescriptorBase.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUOrigin2D.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUOrigin3D.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUOutOfMemoryError.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUPipelineDescriptorBase.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUPipelineLayoutDescriptor.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUPresentationContextDescriptor.h"
#endif
#include "WebGPUPrimitiveState.h"
#if ENABLE(GPU_PROCESS)
#include "WebGPUPrimitiveState.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUProgrammableStage.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUQuerySetDescriptor.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPURenderBundleDescriptor.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPURenderBundleEncoderDescriptor.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPURenderPassColorAttachment.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPURenderPassDepthStencilAttachment.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPURenderPassDescriptor.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPURenderPassLayout.h"
#endif
#include "WebGPURenderPassTimestampWrites.h"
#if ENABLE(GPU_PROCESS)
#include "WebGPURenderPipelineDescriptor.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPURequestAdapterOptions.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUSamplerBindingLayout.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUSamplerDescriptor.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUShaderModuleCompilationHint.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUShaderModuleDescriptor.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUStencilFaceState.h"
#endif
#include "WebGPUStorageTextureBindingLayout.h"
#if ENABLE(GPU_PROCESS)
#include "WebGPUStorageTextureBindingLayout.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUSupportedFeatures.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUSupportedLimits.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUTextureBindingLayout.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUTextureDescriptor.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUTextureViewDescriptor.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUValidationError.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUVertexAttribute.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUVertexBufferLayout.h"
#endif
#if ENABLE(GPU_PROCESS)
#include "WebGPUVertexState.h"
#endif
#if ENABLE(MAC_GESTURE_EVENTS)
#include "WebGestureEvent.h"
#endif
#include "WebHitTestResultData.h"
#include "WebIDBResult.h"
#include "WebImage.h"
#include "WebKeyboardEvent.h"
#include "WebMouseEvent.h"
#include "WebNavigationDataStore.h"
#include "WebPageCreationParameters.h"
#include "WebPageGroupData.h"
#include "WebPageNetworkParameters.h"
#include "WebPopupItem.h"
#include "WebPreferencesStore.h"
#include "WebProcessCreationParameters.h"
#include "WebProcessDataStoreParameters.h"
#if ENABLE(SPEECH_SYNTHESIS)
#include "WebSpeechSynthesisVoice.h"
#endif
#if ENABLE(TOUCH_EVENTS)
#include "WebTouchEvent.h"
#endif
#include "WebUserContentControllerDataTypes.h"
#include "WebWheelEvent.h"
#include "WebsiteAutoplayPolicy.h"
#include "WebsiteAutoplayQuirk.h"
#include "WebsiteData.h"
#include "WebsiteDataFetchOption.h"
#include "WebsiteDataStoreParameters.h"
#include "WebsiteDataType.h"
#include "WebsitePoliciesData.h"
#include "WebsitePopUpPolicy.h"
#include "WebsitePushAndNotificationsEnabledPolicy.h"
#if ENABLE(WEBXR)
#include "XRDeviceInfo.h"
#endif
#if (ENABLE(WEBXR)) && (USE(OPENXR))
#include "XRDeviceLayer.h"
#endif
#include <JavaScriptCore/ArrayBuffer.h>
#include <JavaScriptCore/ConsoleTypes.h>
#include <JavaScriptCore/InspectorFrontendChannel.h>
#include <JavaScriptCore/InspectorTarget.h>
#include <JavaScriptCore/SourceTaintedOrigin.h>
#include <JavaScriptCore/WasmModule.h>
#if USE(SYSTEM_PREVIEW)
#include <WebCore/ARKitBadgeSystemImage.h>
#endif
#include <WebCore/AXObjectCache.h>
#if ENABLE(THREADED_ANIMATION_RESOLUTION)
#include <WebCore/AcceleratedEffect.h>
#endif
#if ENABLE(THREADED_ANIMATION_RESOLUTION)
#include <WebCore/AcceleratedEffectValues.h>
#endif
#include <WebCore/AffineTransform.h>
#if ENABLE(WEB_AUTHN)
#include <WebCore/AllAcceptedCredentialsOptions.h>
#endif
#include <WebCore/Allowlist.h>
#if ENABLE(THREADED_ANIMATION_RESOLUTION)
#include <WebCore/AnimationEffectTiming.h>
#endif
#if ENABLE(APP_HIGHLIGHTS)
#include <WebCore/AppHighlight.h>
#endif
#if USE(APPKIT)
#include <WebCore/AppKitControlSystemImage.h>
#endif
#if ENABLE(APPLE_PAY_AMS_UI) && ENABLE(PAYMENT_REQUEST)
#include <WebCore/ApplePayAMSUIRequest.h>
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
#include <WebCore/ApplePayAutomaticReloadPaymentRequest.h>
#endif
#if ENABLE(APPLE_PAY)
#include <WebCore/ApplePayButtonPart.h>
#endif
#if ENABLE(APPLE_PAY)
#include <WebCore/ApplePayContactField.h>
#endif
#if ENABLE(APPLE_PAY_COUPON_CODE)
#include <WebCore/ApplePayCouponCodeUpdate.h>
#endif
#if ENABLE(APPLE_PAY_SHIPPING_METHOD_DATE_COMPONENTS_RANGE)
#include <WebCore/ApplePayDateComponents.h>
#endif
#if ENABLE(APPLE_PAY_SHIPPING_METHOD_DATE_COMPONENTS_RANGE)
#include <WebCore/ApplePayDateComponentsRange.h>
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
#include <WebCore/ApplePayDeferredPaymentRequest.h>
#endif
#if ENABLE(APPLE_PAY)
#include <WebCore/ApplePayDetailsUpdateBase.h>
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
#include <WebCore/ApplePayDisbursementRequest.h>
#endif
#if ENABLE(APPLE_PAY)
#include <WebCore/ApplePayError.h>
#endif
#if ENABLE(APPLE_PAY)
#include <WebCore/ApplePayFeature.h>
#endif
#if ENABLE(APPLE_PAY_INSTALLMENTS)
#include <WebCore/ApplePayInstallmentConfigurationWebCore.h>
#endif
#if ENABLE(APPLE_PAY_INSTALLMENTS)
#include <WebCore/ApplePayInstallmentItem.h>
#endif
#if ENABLE(APPLE_PAY)
#include <WebCore/ApplePayLineItem.h>
#endif
#if ENABLE(APPLE_PAY)
#include <WebCore/ApplePayLogoSystemImage.h>
#endif
#if ENABLE(APPLE_PAY)
#include <WebCore/ApplePayPaymentAuthorizationResult.h>
#endif
#if ENABLE(APPLE_PAY)
#include <WebCore/ApplePayPaymentMethodUpdate.h>
#endif
#if ENABLE(APPLE_PAY_PAYMENT_ORDER_DETAILS)
#include <WebCore/ApplePayPaymentOrderDetails.h>
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
#include <WebCore/ApplePayPaymentTokenContext.h>
#endif
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
#include <WebCore/ApplePayRecurringPaymentRequest.h>
#endif
#if ENABLE(APPLE_PAY)
#include <WebCore/ApplePaySetupConfiguration.h>
#endif
#if ENABLE(APPLE_PAY)
#include <WebCore/ApplePayShippingContactUpdate.h>
#endif
#if ENABLE(APPLE_PAY)
#include <WebCore/ApplePayShippingMethod.h>
#endif
#if ENABLE(APPLE_PAY)
#include <WebCore/ApplePayShippingMethodUpdate.h>
#endif
#if HAVE(CORE_MATERIAL)
#include <WebCore/AppleVisualEffect.h>
#endif
#if ENABLE(APPLICATION_MANIFEST)
#include <WebCore/ApplicationManifest.h>
#endif
#if PLATFORM(COCOA)
#include <WebCore/ArchiveResource.h>
#endif
#if ENABLE(ATTACHMENT_ELEMENT)
#include <WebCore/AttachmentAssociatedElement.h>
#endif
#include <WebCore/AttributionSecondsUntilSendData.h>
#include <WebCore/AudioConfiguration.h>
#include <WebCore/AudioIOCallback.h>
#if USE(AUDIO_SESSION)
#include <WebCore/AudioSession.h>
#endif
#if ENABLE(VIDEO)
#include <WebCore/AudioTrackPrivate.h>
#endif
#include <WebCore/AuthenticationChallenge.h>
#if ENABLE(WEB_AUTHN)
#include <WebCore/AuthenticationExtensionsClientInputs.h>
#endif
#if ENABLE(WEB_AUTHN)
#include <WebCore/AuthenticationExtensionsClientOutputs.h>
#endif
#if ENABLE(WEB_AUTHN)
#include <WebCore/AuthenticatorResponseData.h>
#endif
#if ENABLE(WEB_AUTHN)
#include <WebCore/AuthenticatorSelectionCriteria.h>
#endif
#include <WebCore/AutocapitalizeTypes.h>
#include <WebCore/Autofill.h>
#include <WebCore/AutoplayEvent.h>
#include <WebCore/BackgroundFetchFailureReason.h>
#include <WebCore/BackgroundFetchInformation.h>
#include <WebCore/BackgroundFetchOptions.h>
#include <WebCore/BackgroundFetchRecordInformation.h>
#include <WebCore/BackgroundFetchRequest.h>
#include <WebCore/BackgroundFetchResult.h>
#if ENABLE(GPU_PROCESS)
#include <WebCore/BarcodeDetectorOptionsInterface.h>
#endif
#if ENABLE(GPU_PROCESS)
#include <WebCore/BarcodeFormatInterface.h>
#endif
#include <WebCore/BlobPart.h>
#include <WebCore/BufferSource.h>
#include <WebCore/ButtonPart.h>
#include <WebCore/ByteArrayPixelBuffer.h>
#if PLATFORM(COCOA)
#include <WebCore/CAAudioStreamDescription.h>
#endif
#if ENABLE(ENCRYPTED_MEDIA)
#include <WebCore/CDMInstance.h>
#endif
#if ENABLE(ENCRYPTED_MEDIA)
#include <WebCore/CDMInstanceSession.h>
#endif
#if ENABLE(ENCRYPTED_MEDIA)
#include <WebCore/CDMKeySystemConfiguration.h>
#endif
#if ENABLE(ENCRYPTED_MEDIA)
#include <WebCore/CDMMediaCapability.h>
#endif
#if ENABLE(GPU_PROCESS) && ENABLE(ENCRYPTED_MEDIA)
#include <WebCore/CDMPrivate.h>
#endif
#if ENABLE(ENCRYPTED_MEDIA)
#include <WebCore/CDMRestrictions.h>
#endif
#include <WebCore/COEPInheritenceViolationReportBody.h>
#include <WebCore/CORPViolationReportBody.h>
#include <WebCore/CSPViolationReportBody.h>
#include <WebCore/CSSFilter.h>
#include <WebCore/CSSValueKey.h>
#include <WebCore/CacheQueryOptions.h>
#include <WebCore/CanvasActivityRecord.h>
#if ENABLE(VIDEO)
#include <WebCore/CaptionUserPreferences.h>
#endif
#if ENABLE(MEDIA_STREAM)
#include <WebCore/CaptureDevice.h>
#endif
#if ENABLE(MEDIA_STREAM)
#include <WebCore/CaptureDeviceWithCapabilities.h>
#endif
#if PLATFORM(MAC)
#include <WebCore/CaretAnimator.h>
#endif
#include <WebCore/CertificateInfo.h>
#include <WebCore/CharacterRange.h>
#include <WebCore/ClientOrigin.h>
#include <WebCore/Color.h>
#include <WebCore/ColorInterpolationMethod.h>
#include <WebCore/ColorTypes.h>
#include <WebCore/ColorWellPart.h>
#include <WebCore/CompositionHighlight.h>
#include <WebCore/CompositionUnderline.h>
#include <WebCore/ContactInfo.h>
#include <WebCore/ContactsRequestData.h>
#if ENABLE(CONTENT_EXTENSIONS)
#include <WebCore/ContentRuleListResults.h>
#endif
#include <WebCore/ContentSecurityPolicy.h>
#include <WebCore/ContentSecurityPolicyResponseHeaders.h>
#include <WebCore/ContentType.h>
#if ENABLE(CONTEXT_MENUS)
#include <WebCore/ContextMenuContext.h>
#endif
#include <WebCore/ContextMenuItem.h>
#include <WebCore/ControlPart.h>
#include <WebCore/ControlStyle.h>
#include <WebCore/Cookie.h>
#include <WebCore/CookieChangeSubscription.h>
#include <WebCore/CookieConsentDecisionResult.h>
#include <WebCore/CookieRequestHeaderFieldProxy.h>
#include <WebCore/CookieStoreGetOptions.h>
#include <WebCore/Credential.h>
#if PLATFORM(COCOA)
#include <WebCore/Credential.h>
#endif
#if USE(CURL)
#include <WebCore/Credential.h>
#endif
#if USE(SOUP)
#include <WebCore/Credential.h>
#endif
#if ENABLE(WEB_AUTHN)
#include <WebCore/CredentialPropertiesOutput.h>
#endif
#include <WebCore/CrossOriginAccessControl.h>
#include <WebCore/CrossOriginEmbedderPolicy.h>
#include <WebCore/CrossOriginOpenerPolicy.h>
#include <WebCore/CrossSiteNavigationDataTransfer.h>
#include <WebCore/CryptoKeyData.h>
#if USE(CURL)
#include <WebCore/CurlProxySettings.h>
#endif
#if ENABLE(WEB_AUTHN)
#include <WebCore/CurrentUserDetailsOptions.h>
#endif
#include <WebCore/Cursor.h>
#include <WebCore/CustomHeaderFields.h>
#if ENABLE(DOM_AUDIO_SESSION)
#include <WebCore/DOMAudioSession.h>
#endif
#include <WebCore/DOMCacheEngine.h>
#include <WebCore/DOMPasteAccess.h>
#if ENABLE(DATA_DETECTION)
#include <WebCore/DataDetectorElementInfo.h>
#endif
#if ENABLE(DATA_DETECTION)
#include <WebCore/DataDetectorType.h>
#endif
#include <WebCore/DataListSuggestionInformation.h>
#include <WebCore/DatabaseDetails.h>
#include <WebCore/DateTimeChooserParameters.h>
#include <WebCore/DeprecationReportBody.h>
#include <WebCore/DestinationColorSpace.h>
#if ENABLE(WEB_RTC)
#include <WebCore/DetachedRTCDataChannel.h>
#endif
#if ENABLE(GPU_PROCESS)
#include <WebCore/DetectedBarcodeInterface.h>
#endif
#if ENABLE(GPU_PROCESS)
#include <WebCore/DetectedFaceInterface.h>
#endif
#if ENABLE(GPU_PROCESS)
#include <WebCore/DetectedTextInterface.h>
#endif
#include <WebCore/DeviceOrientationOrMotionPermissionState.h>
#include <WebCore/DiagnosticLoggingClient.h>
#include <WebCore/DiagnosticLoggingDomain.h>
#include <WebCore/DictationAlternative.h>
#include <WebCore/DictionaryPopupInfo.h>
#if (ENABLE(WEB_AUTHN)) && (HAVE(DIGITAL_CREDENTIALS_UI))
#include <WebCore/DigitalCredentialsRequestData.h>
#endif
#if (ENABLE(WEB_AUTHN)) && (HAVE(DIGITAL_CREDENTIALS_UI))
#include <WebCore/DigitalCredentialsResponseData.h>
#endif
#if HAVE(SCREEN_CAPTURE_KIT)
#include <WebCore/DisplayCapturePromptType.h>
#endif
#include <WebCore/DisplayListItems.h>
#include <WebCore/DisplayUpdate.h>
#include <WebCore/DistantLightSource.h>
#include <WebCore/DocumentClasses.h>
#include <WebCore/DocumentLoader.h>
#include <WebCore/DocumentStorageAccess.h>
#include <WebCore/DocumentSyncData.h>
#include <WebCore/DragData.h>
#if ENABLE(DRAG_SUPPORT)
#include <WebCore/DragData.h>
#endif
#include <WebCore/DragImage.h>
#include <WebCore/DragItem.h>
#if ENABLE(RE_DYNAMIC_CONTENT_SCALING)
#include <WebCore/DynamicContentScalingDisplayList.h>
#endif
#include <WebCore/ElementAnimationContext.h>
#include <WebCore/ElementContext.h>
#include <WebCore/ElementTargetingTypes.h>
#include <WebCore/EventInit.h>
#include <WebCore/EventRegion.h>
#include <WebCore/EventTrackingRegions.h>
#include <WebCore/Exception.h>
#include <WebCore/ExceptionData.h>
#include <WebCore/ExceptionDetails.h>
#include <WebCore/FEBlend.h>
#include <WebCore/FEColorMatrix.h>
#include <WebCore/FEComponentTransfer.h>
#include <WebCore/FEComposite.h>
#include <WebCore/FEConvolveMatrix.h>
#include <WebCore/FEDiffuseLighting.h>
#include <WebCore/FEDisplacementMap.h>
#include <WebCore/FEDropShadow.h>
#include <WebCore/FEFlood.h>
#include <WebCore/FEGaussianBlur.h>
#include <WebCore/FEImage.h>
#include <WebCore/FEMerge.h>
#include <WebCore/FEMorphology.h>
#include <WebCore/FEOffset.h>
#include <WebCore/FESpecularLighting.h>
#include <WebCore/FETile.h>
#include <WebCore/FETurbulence.h>
#if ENABLE(GPU_PROCESS)
#include <WebCore/FaceDetectorOptionsInterface.h>
#endif
#include <WebCore/FetchOptions.h>
#include <WebCore/FileChooser.h>
#include <WebCore/FileSystemWriteCommandType.h>
#if ENABLE(MEDIA_STREAM)
#include <WebCore/FillLightMode.h>
#endif
#include <WebCore/Filter.h>
#include <WebCore/FilterEffect.h>
#include <WebCore/FilterEffectGeometry.h>
#include <WebCore/FilterFunction.h>
#include <WebCore/FilterOperation.h>
#if !USE(COORDINATED_GRAPHICS)
#include <WebCore/FilterOperation.h>
#endif
#if !USE(COORDINATED_GRAPHICS)
#include <WebCore/FilterOperations.h>
#endif
#include <WebCore/FilterRenderingMode.h>
#include <WebCore/FixedContainerEdges.h>
#include <WebCore/FloatLine.h>
#include <WebCore/FloatPoint.h>
#include <WebCore/FloatPoint3D.h>
#include <WebCore/FloatQuad.h>
#include <WebCore/FloatRect.h>
#include <WebCore/FloatRoundedRect.h>
#include <WebCore/FloatSegment.h>
#include <WebCore/FloatSize.h>
#include <WebCore/FocusController.h>
#include <WebCore/FocusDirection.h>
#include <WebCore/FocusEventData.h>
#include <WebCore/Font.h>
#include <WebCore/FontAttributeChanges.h>
#include <WebCore/FontAttributes.h>
#include <WebCore/FontCache.h>
#include <WebCore/FontCustomPlatformData.h>
#include <WebCore/FontPlatformData.h>
#if USE(SKIA)
#include <WebCore/FontPlatformData.h>
#endif
#include <WebCore/FontSelectionAlgorithm.h>
#include <WebCore/FontShadow.h>
#include <WebCore/FontTaggedSettings.h>
#include <WebCore/FormData.h>
#include <WebCore/FourCC.h>
#include <WebCore/FrameTreeSyncData.h>
#if ENABLE(GAMEPAD)
#include <WebCore/GamepadEffectParameters.h>
#endif
#if ENABLE(GAMEPAD)
#include <WebCore/GamepadHapticEffectType.h>
#endif
#include <WebCore/GeolocationPositionData.h>
#include <WebCore/GlobalFrameIdentifier.h>
#include <WebCore/GlobalWindowIdentifier.h>
#include <WebCore/Gradient.h>
#include <WebCore/GradientColorStop.h>
#include <WebCore/GradientColorStops.h>
#if ENABLE(WEBGL)
#include <WebCore/GraphicsContextGL.h>
#endif
#if PLATFORM(COCOA) && ENABLE(GPU_PROCESS) && ENABLE(WEBGL)
#include <WebCore/GraphicsContextGL.h>
#endif
#if ENABLE(GPU_PROCESS) && ENABLE(WEBGL)
#include <WebCore/GraphicsContextGLActiveInfo.h>
#endif
#if ENABLE(GPU_PROCESS) && ENABLE(WEBGL)
#include <WebCore/GraphicsContextGLAttributes.h>
#endif
#include <WebCore/GraphicsStyle.h>
#include <WebCore/GraphicsTypes.h>
#include <WebCore/GraphicsTypesGL.h>
#include <WebCore/HTMLModelElementCamera.h>
#include <WebCore/HTTPCookieAcceptPolicy.h>
#include <WebCore/HTTPHeaderField.h>
#include <WebCore/HTTPHeaderMap.h>
#include <WebCore/HostingContext.h>
#include <WebCore/IDBCursorInfo.h>
#include <WebCore/IDBCursorRecord.h>
#include <WebCore/IDBDatabaseIdentifier.h>
#include <WebCore/IDBDatabaseInfo.h>
#include <WebCore/IDBDatabaseNameAndVersion.h>
#include <WebCore/IDBError.h>
#include <WebCore/IDBGetAllRecordsData.h>
#include <WebCore/IDBGetAllResult.h>
#include <WebCore/IDBGetRecordData.h>
#include <WebCore/IDBGetResult.h>
#include <WebCore/IDBIndexInfo.h>
#include <WebCore/IDBIterateCursorData.h>
#include <WebCore/IDBKeyData.h>
#include <WebCore/IDBKeyRangeData.h>
#include <WebCore/IDBObjectStoreInfo.h>
#include <WebCore/IDBOpenRequestData.h>
#include <WebCore/IDBRequestData.h>
#include <WebCore/IDBResourceIdentifier.h>
#include <WebCore/IDBResultData.h>
#include <WebCore/IDBTransactionInfo.h>
#include <WebCore/IDBValue.h>
#if (ENABLE(WEB_AUTHN)) && (HAVE(DIGITAL_CREDENTIALS_UI))
#include <WebCore/ISO18013.h>
#endif
#include <WebCore/ISOVTTCue.h>
#include <WebCore/IdentityTransformOperation.h>
#include <WebCore/Image.h>
#include <WebCore/ImageBitmap.h>
#include <WebCore/ImageBuffer.h>
#include <WebCore/ImageBufferFormat.h>
#include <WebCore/ImageBufferResourceLimits.h>
#if ENABLE(SERVICE_CONTROLS)
#include <WebCore/ImageControlsButtonPart.h>
#endif
#include <WebCore/ImageDecoder.h>
#include <WebCore/ImageOrientation.h>
#include <WebCore/ImagePaintingOptions.h>
#include <WebCore/ImageResource.h>
#include <WebCore/ImageTypes.h>
#if PLATFORM(COCOA)
#include <WebCore/ImageUtilities.h>
#endif
#if ENABLE(VIDEO)
#include <WebCore/InbandGenericCue.h>
#endif
#include <WebCore/IndexKey.h>
#include <WebCore/InnerSpinButtonPart.h>
#include <WebCore/InspectorBackendClient.h>
#include <WebCore/InspectorFrontendClient.h>
#if ENABLE(INSPECTOR_EXTENSIONS)
#include <WebCore/InspectorFrontendClient.h>
#endif
#if PLATFORM(IOS_FAMILY)
#include <WebCore/InspectorOverlay.h>
#endif
#if PLATFORM(IOS_FAMILY)
#include <WebCore/InspectorOverlayLabel.h>
#endif
#include <WebCore/IntPoint.h>
#include <WebCore/IntRect.h>
#include <WebCore/IntSize.h>
#include <WebCore/InteractionRegion.h>
#include <WebCore/IsLoggedIn.h>
#include <WebCore/JsonWebKey.h>
#include <WebCore/KeyboardScroll.h>
#if PLATFORM(COCOA)
#include <WebCore/KeypressCommand.h>
#endif
#if ENABLE(GPU_PROCESS)
#include <WebCore/LandmarkInterface.h>
#endif
#if ENABLE(GPU_PROCESS)
#include <WebCore/LandmarkTypeInterface.h>
#endif
#include <WebCore/LayerTreeAsTextOptions.h>
#include <WebCore/LayoutPoint.h>
#include <WebCore/LayoutRect.h>
#include <WebCore/LayoutSize.h>
#include <WebCore/LayoutUnit.h>
#if PLATFORM(COCOA)
#include <WebCore/LegacyWebArchive.h>
#endif
#include <WebCore/Length.h>
#include <WebCore/LengthPoint.h>
#include <WebCore/LengthSize.h>
#include <WebCore/LightSource.h>
#include <WebCore/LinkDecorationFilteringData.h>
#include <WebCore/LinkIcon.h>
#include <WebCore/LoadSchedulingMode.h>
#include <WebCore/LocalFrameLoaderClient.h>
#include <WebCore/LoginStatus.h>
#include <WebCore/MDNSRegisterError.h>
#include <WebCore/MarkupExclusionRule.h>
#include <WebCore/Matrix3DTransformOperation.h>
#include <WebCore/MatrixTransformOperation.h>
#include <WebCore/MediaCapabilitiesDecodingInfo.h>
#include <WebCore/MediaCapabilitiesEncodingInfo.h>
#include <WebCore/MediaCapabilitiesInfo.h>
#include <WebCore/MediaConfiguration.h>
#if ENABLE(MEDIA_STREAM)
#include <WebCore/MediaConstraints.h>
#endif
#if ENABLE(MEDIA_CONTROLS_CONTEXT_MENUS) && USE(UICONTEXTMENU)
#include <WebCore/MediaControlsContextMenuItem.h>
#endif
#include <WebCore/MediaDecodingConfiguration.h>
#include <WebCore/MediaDeviceHashSalts.h>
#include <WebCore/MediaEncodingConfiguration.h>
#if ENABLE(VIDEO)
#include <WebCore/MediaPlayer.h>
#endif
#if ENABLE(MEDIA_SESSION)
#include <WebCore/MediaPositionState.h>
#endif
#include <WebCore/MediaProducer.h>
#include <WebCore/MediaSample.h>
#include <WebCore/MediaSelectionOption.h>
#if ENABLE(MEDIA_SESSION)
#include <WebCore/MediaSessionAction.h>
#endif
#if ENABLE(MEDIA_SESSION_COORDINATOR)
#include <WebCore/MediaSessionCoordinatorState.h>
#endif
#if ENABLE(MEDIA_SESSION)
#include <WebCore/MediaSessionPlaybackState.h>
#endif
#if ENABLE(MEDIA_SESSION_COORDINATOR)
#include <WebCore/MediaSessionReadyState.h>
#endif
#if ENABLE(MEDIA_STREAM)
#include <WebCore/MediaSettingsRange.h>
#endif
#if ENABLE(MEDIA_SOURCE)
#include <WebCore/MediaSourceConfiguration.h>
#endif
#if ENABLE(MEDIA_SOURCE)
#include <WebCore/MediaSourcePrivate.h>
#endif
#include <WebCore/MediaStreamRequest.h>
#if ! ENABLE(MEDIA_STREAM)
#include <WebCore/MediaStreamRequest.h>
#endif
#if ENABLE(MEDIA_STREAM)
#include <WebCore/MediaStreamRequest.h>
#endif
#include <WebCore/MediaUsageInfo.h>
#if ENABLE(WEB_AUTHN)
#include <WebCore/MediationRequirement.h>
#endif
#include <WebCore/MenuListButtonPart.h>
#include <WebCore/MenuListPart.h>
#include <WebCore/MessageForTesting.h>
#include <WebCore/MessagePort.h>
#include <WebCore/MessagePortIdentifier.h>
#include <WebCore/MessageWithMessagePorts.h>
#include <WebCore/MeterPart.h>
#if ENABLE(MEDIA_STREAM)
#include <WebCore/MeteringMode.h>
#endif
#if (ENABLE(WEB_AUTHN)) && (HAVE(DIGITAL_CREDENTIALS_UI))
#include <WebCore/MobileDocumentRequest.h>
#endif
#if ENABLE(CONTENT_FILTERING)
#include <WebCore/MockContentFilterSettings.h>
#endif
#if ENABLE(MEDIA_STREAM)
#include <WebCore/MockMediaDevice.h>
#endif
#if ENABLE(WEB_AUTHN)
#include <WebCore/MockWebAuthenticationConfiguration.h>
#endif
#include <WebCore/ModalContainerTypes.h>
#include <WebCore/Model.h>
#if ENABLE(MODEL_PROCESS)
#include <WebCore/ModelContext.h>
#endif
#include <WebCore/ModelPlayerAnimationState.h>
#include <WebCore/MotionPath.h>
#include <WebCore/NavigationPreloadState.h>
#include <WebCore/NavigationRequester.h>
#include <WebCore/NavigationScheduler.h>
#include <WebCore/NetworkLoadInformation.h>
#include <WebCore/NetworkLoadMetrics.h>
#include <WebCore/NotificationData.h>
#include <WebCore/NotificationOptionsPayload.h>
#include <WebCore/NotificationPayload.h>
#include <WebCore/NotificationResources.h>
#include <WebCore/NowPlayingInfo.h>
#include <WebCore/OffscreenCanvas.h>
#if (ENABLE(WEB_AUTHN)) && (HAVE(DIGITAL_CREDENTIALS_UI))
#include <WebCore/OpenID4VPRequest.h>
#endif
#include <WebCore/OrganizationStorageAccessPromptQuirk.h>
#include <WebCore/OwnerPermissionsPolicyData.h>
#include <WebCore/Pagination.h>
#include <WebCore/Pasteboard.h>
#include <WebCore/PasteboardCustomData.h>
#include <WebCore/PasteboardItemInfo.h>
#include <WebCore/Path.h>
#include <WebCore/PathOperation.h>
#include <WebCore/PathSegment.h>
#include <WebCore/PathSegmentData.h>
#include <WebCore/Pattern.h>
#if ENABLE(APPLE_PAY_INSTALLMENTS)
#include <WebCore/PaymentInstallmentConfigurationWebCore.h>
#endif
#include <WebCore/PermissionDescriptor.h>
#include <WebCore/PermissionQuerySource.h>
#include <WebCore/PermissionState.h>
#include <WebCore/PermissionsPolicy.h>
#include <WebCore/PerspectiveTransformOperation.h>
#if ENABLE(MEDIA_STREAM)
#include <WebCore/PhotoCapabilities.h>
#endif
#if ENABLE(MEDIA_STREAM)
#include <WebCore/PhotoSettings.h>
#endif
#include <WebCore/PixelBuffer.h>
#include <WebCore/PixelBufferFormat.h>
#if ENABLE(VIDEO)
#include <WebCore/PlatformAudioTrackConfiguration.h>
#endif
#if (!(USE(CG))) && (!(USE(SKIA)))
#include <WebCore/PlatformColorSpace.h>
#endif
#include <WebCore/PlatformDynamicRangeLimit.h>
#include <WebCore/PlatformMediaSession.h>
#if ENABLE(VIDEO)
#include <WebCore/PlatformTextTrack.h>
#endif
#include <WebCore/PlatformTimeRanges.h>
#if ENABLE(VIDEO)
#include <WebCore/PlatformTrackConfiguration.h>
#endif
#include <WebCore/PlatformVideoColorSpace.h>
#if ENABLE(VIDEO)
#include <WebCore/PlatformVideoTrackConfiguration.h>
#endif
#include <WebCore/PlatformWheelEvent.h>
#if (ENABLE(WEBXR)) && (USE(OPENXR))
#include <WebCore/PlatformXR.h>
#endif
#if ENABLE(WEBXR)
#include <WebCore/PlatformXR.h>
#endif
#include <WebCore/PluginData.h>
#include <WebCore/PointLightSource.h>
#include <WebCore/PolicyContainer.h>
#include <WebCore/PredefinedColorSpace.h>
#include <WebCore/PrewarmInformation.h>
#include <WebCore/PrivateClickMeasurement.h>
#include <WebCore/ProcessIdentity.h>
#include <WebCore/ProcessQualified.h>
#include <WebCore/ProcessSwapDisposition.h>
#include <WebCore/ProcessSyncData.h>
#include <WebCore/ProgressBarPart.h>
#include <WebCore/PromisedAttachmentInfo.h>
#include <WebCore/ProtectionSpace.h>
#include <WebCore/ProtectionSpaceBase.h>
#include <WebCore/PublicKeyCredentialCreationOptions.h>
#if ENABLE(WEB_AUTHN)
#include <WebCore/PublicKeyCredentialDescriptor.h>
#endif
#if ENABLE(WEB_AUTHN)
#include <WebCore/PublicKeyCredentialEntity.h>
#endif
#include <WebCore/PublicKeyCredentialRequestOptions.h>
#if ENABLE(WEB_AUTHN)
#include <WebCore/PublicKeyCredentialRpEntity.h>
#endif
#if ENABLE(WEB_AUTHN)
#include <WebCore/PublicKeyCredentialUserEntity.h>
#endif
#include <WebCore/PublicSuffix.h>
#include <WebCore/PushPermissionState.h>
#include <WebCore/PushSubscriptionData.h>
#if ENABLE(WEB_RTC)
#include <WebCore/RTCDataChannelHandler.h>
#endif
#include <WebCore/RTCErrorDetailType.h>
#if ENABLE(MEDIA_STREAM)
#include <WebCore/RealtimeMediaSource.h>
#endif
#if ENABLE(MEDIA_STREAM)
#include <WebCore/RealtimeMediaSourceCapabilities.h>
#endif
#if ENABLE(MEDIA_STREAM)
#include <WebCore/RealtimeMediaSourceCenter.h>
#endif
#if ENABLE(MEDIA_STREAM)
#include <WebCore/RealtimeMediaSourceSettings.h>
#endif
#if ENABLE(MEDIA_STREAM)
#include <WebCore/RealtimeMediaSourceSupportedConstraints.h>
#endif
#include <WebCore/RectEdges.h>
#if ENABLE(MEDIA_STREAM)
#include <WebCore/RedEyeReduction.h>
#endif
#include <WebCore/Region.h>
#include <WebCore/RegistrableDomain.h>
#include <WebCore/RemoteUserInputEventData.h>
#include <WebCore/RenderObject.h>
#include <WebCore/RenderStyleConstants.h>
#if ENABLE(THREADED_ANIMATION_RESOLUTION)
#include <WebCore/RenderStyleConstants.h>
#endif
#include <WebCore/RenderTreeAsText.h>
#include <WebCore/Report.h>
#include <WebCore/ReportBody.h>
#include <WebCore/ResourceError.h>
#include <WebCore/ResourceLoadStatistics.h>
#include <WebCore/ResourceLoaderOptions.h>
#include <WebCore/ResourceRequest.h>
#if !USE(CURL) && !PLATFORM(COCOA)
#include <WebCore/ResourceRequest.h>
#endif
#if PLATFORM(COCOA)
#include <WebCore/ResourceRequest.h>
#endif
#if USE(CURL)
#include <WebCore/ResourceRequest.h>
#endif
#if USE(SOUP)
#include <WebCore/ResourceRequest.h>
#endif
#include <WebCore/ResourceResponse.h>
#include <WebCore/ResourceResponseBase.h>
#include <WebCore/RetrieveRecordsOptions.h>
#include <WebCore/RotateTransformOperation.h>
#include <WebCore/RouterSourceDict.h>
#include <WebCore/RsaOtherPrimesInfo.h>
#include <WebCore/SVGFilter.h>
#include <WebCore/SVGFilterExpression.h>
#include <WebCore/SVGPathByteStream.h>
#include <WebCore/SVGPreserveAspectRatioValue.h>
#include <WebCore/SameSiteInfo.h>
#include <WebCore/ScaleTransformOperation.h>
#include <WebCore/ScreenOrientationLockType.h>
#include <WebCore/ScreenOrientationType.h>
#include <WebCore/ScreenProperties.h>
#if !ENABLE(SHAREABLE_RESOURCE) || !PLATFORM(COCOA)
#include <WebCore/ScriptBuffer.h>
#endif
#if ENABLE(SHAREABLE_RESOURCE) && PLATFORM(COCOA)
#include <WebCore/ScriptBuffer.h>
#endif
#include <WebCore/ScriptTrackingPrivacyCategory.h>
#include <WebCore/ScrollTypes.h>
#if USE(APPKIT)
#include <WebCore/ScrollbarTrackCornerSystemImageMac.h>
#endif
#include <WebCore/ScrollingConstraints.h>
#include <WebCore/ScrollingCoordinatorTypes.h>
#if ENABLE(ASYNC_SCROLLING)
#include <WebCore/ScrollingStateNode.h>
#endif
#include <WebCore/SearchFieldCancelButtonPart.h>
#include <WebCore/SearchFieldPart.h>
#include <WebCore/SearchFieldResultsPart.h>
#include <WebCore/SearchPopupMenu.h>
#include <WebCore/SecurityOrigin.h>
#include <WebCore/SecurityOriginData.h>
#include <WebCore/SecurityPolicyViolationEvent.h>
#include <WebCore/SecurityPolicyViolationEventDisposition.h>
#if PLATFORM(IOS_FAMILY)
#include <WebCore/SelectionGeometry.h>
#endif
#if ENABLE(ATTACHMENT_ELEMENT)
#include <WebCore/SerializedAttachmentData.h>
#endif
#include <WebCore/SerializedNode.h>
#if ENABLE(VIDEO)
#include <WebCore/SerializedPlatformDataCueValue.h>
#endif
#include <WebCore/SerializedScriptValue.h>
#include <WebCore/ServiceWorkerClientData.h>
#include <WebCore/ServiceWorkerClientPendingMessage.h>
#include <WebCore/ServiceWorkerClientQueryOptions.h>
#include <WebCore/ServiceWorkerContextData.h>
#include <WebCore/ServiceWorkerData.h>
#include <WebCore/ServiceWorkerImportedScript.h>
#include <WebCore/ServiceWorkerJobData.h>
#include <WebCore/ServiceWorkerJobDataIdentifier.h>
#include <WebCore/ServiceWorkerRegistrationData.h>
#include <WebCore/ServiceWorkerRegistrationKey.h>
#include <WebCore/ServiceWorkerRegistrationOptions.h>
#include <WebCore/ServiceWorkerRoute.h>
#include <WebCore/ShareData.h>
#include <WebCore/ShareableBitmap.h>
#if ENABLE(SHAREABLE_RESOURCE)
#include <WebCore/ShareableResource.h>
#endif
#include <WebCore/SharedBuffer.h>
#include <WebCore/SharedStringHash.h>
#include <WebCore/SharedWorkerKey.h>
#include <WebCore/ShouldTreatAsContinuingLoad.h>
#include <WebCore/Site.h>
#include <WebCore/SkewTransformOperation.h>
#include <WebCore/SliderThumbPart.h>
#include <WebCore/SliderTrackPart.h>
#include <WebCore/SocketStreamError.h>
#include <WebCore/SourceAlpha.h>
#if ENABLE(MEDIA_SOURCE)
#include <WebCore/SourceBufferPrivate.h>
#endif
#if ENABLE(MEDIA_SOURCE)
#include <WebCore/SourceBufferPrivateClient.h>
#endif
#include <WebCore/SourceGraphic.h>
#include <WebCore/SourceImage.h>
#if ENABLE(WEB_PAGE_SPATIAL_BACKDROP)
#include <WebCore/SpatialBackdropSource.h>
#endif
#if ENABLE(VIDEO)
#include <WebCore/SpatialVideoMetadata.h>
#endif
#include <WebCore/SpeechRecognitionError.h>
#include <WebCore/SpeechRecognitionRequestInfo.h>
#include <WebCore/SpeechRecognitionResultData.h>
#include <WebCore/SpeechRecognitionUpdate.h>
#include <WebCore/SpotLightSource.h>
#if ENABLE(MODEL_PROCESS)
#include <WebCore/StageModeOperations.h>
#endif
#include <WebCore/StorageBlockingPolicy.h>
#include <WebCore/StorageEstimate.h>
#include <WebCore/StorageType.h>
#include <WebCore/StyleBorderRadius.h>
#include <WebCore/StyleCircleFunction.h>
#include <WebCore/StyleEllipseFunction.h>
#include <WebCore/StyleFillRule.h>
#include <WebCore/StyleGradient.h>
#include <WebCore/StyleInsetFunction.h>
#include <WebCore/StyleListStyleType.h>
#if ENABLE(THREADED_ANIMATION_RESOLUTION)
#include <WebCore/StyleOffsetRotate.h>
#endif
#include <WebCore/StylePathFunction.h>
#include <WebCore/StylePolygonFunction.h>
#include <WebCore/StylePosition.h>
#include <WebCore/StylePrimitiveNumericTypes.h>
#include <WebCore/StyleRayFunction.h>
#include <WebCore/StyleShapeFunction.h>
#include <WebCore/SubstituteData.h>
#include <WebCore/SwitchThumbPart.h>
#include <WebCore/SwitchTrackPart.h>
#include <WebCore/SystemImage.h>
#include <WebCore/SystemPreviewInfo.h>
#include <WebCore/TestReportBody.h>
#include <WebCore/TextAreaPart.h>
#if PLATFORM(COCOA)
#include <WebCore/TextAttachmentForSerialization.h>
#endif
#include <WebCore/TextChecking.h>
#include <WebCore/TextExtractionTypes.h>
#include <WebCore/TextFieldPart.h>
#include <WebCore/TextFlags.h>
#include <WebCore/TextGranularity.h>
#include <WebCore/TextIndicator.h>
#include <WebCore/TextManipulationController.h>
#include <WebCore/TextManipulationControllerManipulationFailure.h>
#include <WebCore/TextManipulationItem.h>
#include <WebCore/TextManipulationToken.h>
#if ENABLE(IMAGE_ANALYSIS)
#include <WebCore/TextRecognitionResult.h>
#endif
#if ENABLE(IMAGE_ANALYSIS) && ENABLE(DATA_DETECTION)
#include <WebCore/TextRecognitionResult.h>
#endif
#include <WebCore/ThreadSafeDataBuffer.h>
#include <WebCore/TimingFunction.h>
#include <WebCore/ToggleButtonPart.h>
#include <WebCore/TransformOperation.h>
#include <WebCore/TransformOperationData.h>
#include <WebCore/TransformOperations.h>
#include <WebCore/TransformationMatrix.h>
#include <WebCore/TranslateTransformOperation.h>
#if HAVE(TRANSLATION_UI_SERVICES) && ENABLE(CONTEXT_MENUS)
#include <WebCore/TranslationContextMenuInfo.h>
#endif
#include <WebCore/TrustedFonts.h>
#if ENABLE(WEB_AUTHN)
#include <WebCore/UnknownCredentialOptions.h>
#endif
#include <WebCore/UserScript.h>
#include <WebCore/UserStyleSheet.h>
#include <WebCore/VP9Utilities.h>
#if ENABLE(VIDEO)
#include <WebCore/VTTCue.h>
#endif
#include <WebCore/VelocityData.h>
#include <WebCore/VideoCodecType.h>
#include <WebCore/VideoConfiguration.h>
#include <WebCore/VideoEncoderScalabilityMode.h>
#if ENABLE(VIDEO)
#include <WebCore/VideoFrame.h>
#endif
#if ENABLE(VIDEO) && USE(AVFOUNDATION)
#include <WebCore/VideoFrameCV.h>
#endif
#if ENABLE(VIDEO)
#include <WebCore/VideoFrameMetadata.h>
#endif
#include <WebCore/VideoFrameTimeMetadata.h>
#if ENABLE(VIDEO)
#include <WebCore/VideoPlaybackQualityMetrics.h>
#endif
#if ENABLE(MEDIA_STREAM)
#include <WebCore/VideoPreset.h>
#endif
#if ENABLE(VIDEO)
#include <WebCore/VideoProjectionMetadata.h>
#endif
#if ENABLE(VIDEO)
#include <WebCore/VideoTrackPrivate.h>
#endif
#if ENABLE(META_VIEWPORT)
#include <WebCore/ViewportArguments.h>
#endif
#include <WebCore/VisibleSelection.h>
#if ENABLE(THREADED_ANIMATION_RESOLUTION)
#include <WebCore/WebAnimationTime.h>
#endif
#if ENABLE(THREADED_ANIMATION_RESOLUTION)
#include <WebCore/WebAnimationTypes.h>
#endif
#include <WebCore/WebCodecsEncodedAudioChunk.h>
#if ENABLE(WEB_CODECS)
#include <WebCore/WebCodecsEncodedAudioChunk.h>
#endif
#if ENABLE(WEB_CODECS)
#include <WebCore/WebCodecsEncodedAudioChunkData.h>
#endif
#include <WebCore/WebCodecsEncodedVideoChunk.h>
#if ENABLE(WEB_CODECS)
#include <WebCore/WebCodecsEncodedVideoChunk.h>
#endif
#if ENABLE(WEB_CODECS)
#include <WebCore/WebCodecsEncodedVideoChunkData.h>
#endif
#include <WebCore/WebGPUAddressMode.h>
#include <WebCore/WebGPUBlendFactor.h>
#include <WebCore/WebGPUBlendOperation.h>
#include <WebCore/WebGPUBufferBindingType.h>
#include <WebCore/WebGPUBufferUsage.h>
#include <WebCore/WebGPUCanvasAlphaMode.h>
#include <WebCore/WebGPUCanvasToneMappingMode.h>
#include <WebCore/WebGPUColorWrite.h>
#include <WebCore/WebGPUCompareFunction.h>
#include <WebCore/WebGPUCompilationMessageType.h>
#include <WebCore/WebGPUCullMode.h>
#include <WebCore/WebGPUDeviceLostReason.h>
#include <WebCore/WebGPUErrorFilter.h>
#include <WebCore/WebGPUFilterMode.h>
#include <WebCore/WebGPUFrontFace.h>
#include <WebCore/WebGPUIndexFormat.h>
#include <WebCore/WebGPULoadOp.h>
#include <WebCore/WebGPUMapMode.h>
#include <WebCore/WebGPUPredefinedColorSpace.h>
#include <WebCore/WebGPUPrimitiveTopology.h>
#include <WebCore/WebGPUQueryType.h>
#include <WebCore/WebGPUSamplerBindingType.h>
#include <WebCore/WebGPUShaderStage.h>
#include <WebCore/WebGPUStencilOperation.h>
#include <WebCore/WebGPUStorageTextureAccess.h>
#include <WebCore/WebGPUStoreOp.h>
#include <WebCore/WebGPUTextureAspect.h>
#include <WebCore/WebGPUTextureDimension.h>
#include <WebCore/WebGPUTextureFormat.h>
#include <WebCore/WebGPUTextureSampleType.h>
#include <WebCore/WebGPUTextureUsage.h>
#include <WebCore/WebGPUTextureViewDimension.h>
#include <WebCore/WebGPUVertexFormat.h>
#include <WebCore/WebGPUVertexStepMode.h>
#include <WebCore/WebGPUXREye.h>
#include <WebCore/WebLockManagerSnapshot.h>
#include <WebCore/WheelEventTestMonitor.h>
#include <WebCore/WindowFeatures.h>
#include <WebCore/WorkerFetchResult.h>
#include <WebCore/WorkerInitializationData.h>
#include <WebCore/WorkerOptions.h>
#include <WebCore/WrappedCryptoKey.h>
#include <WebCore/WritingDirection.h>
#if ENABLE(WRITING_TOOLS)
#include <WebCore/WritingToolsTypes.h>
#endif
#if USE(SKIA)
#include <hb.h>
#endif
#include <pal/SessionID.h>
#include <skia/core/SkFontStyle.h>
#include <wtf/JSONValues.h>
#if OS(DARWIN)
#include <wtf/MachSendRight.h>
#endif
#if PLATFORM(COCOA)
#include <wtf/MachSendRightAnnotated.h>
#endif
#include <wtf/MediaTime.h>
#include <wtf/MemoryPressureHandler.h>
#include <wtf/MonotonicTime.h>
#include <wtf/ObjectIdentifier.h>
#if ENABLE(MODEL_PROCESS)
#include <wtf/ProcessID.h>
#endif
#include <wtf/RobinHoodHashTable.h>
#include <wtf/Seconds.h>
#include <wtf/URL.h>
#include <wtf/UUID.h>
#include <wtf/Variant.h>
#include <wtf/WallTime.h>
#include <wtf/text/AtomString.h>
#include <wtf/text/CString.h>
#if USE(UNIX_DOMAIN_SOCKETS)
#include <wtf/unix/UnixFileDescriptor.h>
#endif
#include <wtf/win/Win32Handle.h>

template<size_t...> struct MembersInCorrectOrder;
template<size_t onlyOffset> struct MembersInCorrectOrder<onlyOffset> {
    static constexpr bool value = true;
};
template<size_t firstOffset, size_t secondOffset, size_t... remainingOffsets> struct MembersInCorrectOrder<firstOffset, secondOffset, remainingOffsets...> {
    static constexpr bool value = firstOffset > secondOffset ? false : MembersInCorrectOrder<secondOffset, remainingOffsets...>::value;
};

template<uint64_t...> struct BitsInIncreasingOrder;
template<uint64_t onlyBit> struct BitsInIncreasingOrder<onlyBit> {
    static constexpr bool value = true;
};
template<uint64_t firstBit, uint64_t secondBit, uint64_t... remainingBits> struct BitsInIncreasingOrder<firstBit, secondBit, remainingBits...> {
    static constexpr bool value = firstBit == secondBit >> 1 && BitsInIncreasingOrder<secondBit, remainingBits...>::value;
};

template<bool, bool> struct VirtualTableAndRefCountOverhead;
template<> struct VirtualTableAndRefCountOverhead<true, true> : public RefCounted<VirtualTableAndRefCountOverhead<true, true>> {
    virtual ~VirtualTableAndRefCountOverhead() { }
};
template<> struct VirtualTableAndRefCountOverhead<false, true> : public RefCounted<VirtualTableAndRefCountOverhead<false, true>> { };
template<> struct VirtualTableAndRefCountOverhead<true, false> {
    virtual ~VirtualTableAndRefCountOverhead() { }
};
template<> struct VirtualTableAndRefCountOverhead<false, false> { };

IGNORE_WARNINGS_BEGIN("invalid-offsetof")

namespace IPC {


#if ENABLE(GPU_PROCESS) && ENABLE(MEDIA_SOURCE)
template<> struct ArgumentCoder<WebKit::InitializationSegmentInfo::TrackInformation> {
    static void encode(Encoder&, const WebKit::InitializationSegmentInfo::TrackInformation&);
    static std::optional<WebKit::InitializationSegmentInfo::TrackInformation> decode(Decoder&);
};
#endif

#if !USE(UNIX_DOMAIN_SOCKETS)
template<> struct ArgumentCoder<IPC::SharedBufferReference::SerializableBuffer> {
    static void encode(Encoder&, IPC::SharedBufferReference::SerializableBuffer&&);
    static std::optional<IPC::SharedBufferReference::SerializableBuffer> decode(Decoder&);
};
#endif

#if PLATFORM(IOS_FAMILY)
template<> struct ArgumentCoder<WebKit::DocumentEditingContext::Range> {
    static void encode(Encoder&, const WebKit::DocumentEditingContext::Range&);
    static std::optional<WebKit::DocumentEditingContext::Range> decode(Decoder&);
};
#endif

#if PLATFORM(IOS_FAMILY)
template<> struct ArgumentCoder<WebKit::DocumentEditingContext::TextRectAndRange> {
    static void encode(Encoder&, const WebKit::DocumentEditingContext::TextRectAndRange&);
    static std::optional<WebKit::DocumentEditingContext::TextRectAndRange> decode(Decoder&);
};
#endif

template<> struct ArgumentCoder<WebKit::EditorState::PostLayoutData> {
    static void encode(Encoder&, const WebKit::EditorState::PostLayoutData&);
    static std::optional<WebKit::EditorState::PostLayoutData> decode(Decoder&);
};

template<> struct ArgumentCoder<WebKit::EditorState::VisualData> {
    static void encode(Encoder&, const WebKit::EditorState::VisualData&);
    static std::optional<WebKit::EditorState::VisualData> decode(Decoder&);
};

template<> struct ArgumentCoder<WebKit::JavaScriptEvaluationResult::Value> {
    static void encode(Encoder&, const WebKit::JavaScriptEvaluationResult::Value&);
    static std::optional<WebKit::JavaScriptEvaluationResult::Value> decode(Decoder&);
};

#if USE(LIBWEBRTC)
template<> struct ArgumentCoder<WebKit::WebRTCNetwork::IPAddress::UnspecifiedFamily> {
    static void encode(Encoder&, const WebKit::WebRTCNetwork::IPAddress::UnspecifiedFamily&);
    static std::optional<WebKit::WebRTCNetwork::IPAddress::UnspecifiedFamily> decode(Decoder&);
};
#endif

#if (USE(LIBWEBRTC)) && (USE(LIBWEBRTC) && PLATFORM(COCOA))
template<> struct ArgumentCoder<webrtc::EncodedImage::Timing> {
    static void encode(Encoder&, const webrtc::EncodedImage::Timing&);
    static std::optional<webrtc::EncodedImage::Timing> decode(Decoder&);
};
#endif

#if USE(LIBWEBRTC)
template<> struct ArgumentCoder<WebKit::RTCPacketOptions::SerializableData> {
    static void encode(Encoder&, const WebKit::RTCPacketOptions::SerializableData&);
    static std::optional<WebKit::RTCPacketOptions::SerializableData> decode(Decoder&);
};
#endif

#if ENABLE(SANDBOX_EXTENSIONS)
template<> struct ArgumentCoder<WebKit::SandboxExtensionImpl> {
    static void encode(Encoder&, WebKit::SandboxExtensionImpl&&);
    static std::optional<WebKit::SandboxExtensionImpl> decode(Decoder&);
};
#endif

template<> struct ArgumentCoder<WebCore::SerializedNode::QualifiedName> {
    static void encode(Encoder&, const WebCore::SerializedNode::QualifiedName&);
    static std::optional<WebCore::SerializedNode::QualifiedName> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::SerializedNode::ContainerNode> {
    static void encode(Encoder&, const WebCore::SerializedNode::ContainerNode&);
    static std::optional<WebCore::SerializedNode::ContainerNode> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::SerializedNode::Attr> {
    static void encode(Encoder&, const WebCore::SerializedNode::Attr&);
    static std::optional<WebCore::SerializedNode::Attr> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::SerializedNode::CharacterData> {
    static void encode(Encoder&, const WebCore::SerializedNode::CharacterData&);
    static std::optional<WebCore::SerializedNode::CharacterData> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::SerializedNode::Document> {
    static void encode(Encoder&, const WebCore::SerializedNode::Document&);
    static std::optional<WebCore::SerializedNode::Document> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::SerializedNode::DocumentFragment> {
    static void encode(Encoder&, const WebCore::SerializedNode::DocumentFragment&);
    static std::optional<WebCore::SerializedNode::DocumentFragment> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::SerializedNode::DocumentType> {
    static void encode(Encoder&, const WebCore::SerializedNode::DocumentType&);
    static std::optional<WebCore::SerializedNode::DocumentType> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::SerializedNode::Element::Attribute> {
    static void encode(Encoder&, const WebCore::SerializedNode::Element::Attribute&);
    static std::optional<WebCore::SerializedNode::Element::Attribute> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::SerializedNode::Element> {
    static void encode(Encoder&, const WebCore::SerializedNode::Element&);
    static std::optional<WebCore::SerializedNode::Element> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::SerializedNode::Comment> {
    static void encode(Encoder&, const WebCore::SerializedNode::Comment&);
    static std::optional<WebCore::SerializedNode::Comment> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::SerializedNode::Text> {
    static void encode(Encoder&, const WebCore::SerializedNode::Text&);
    static std::optional<WebCore::SerializedNode::Text> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::SerializedNode::CDATASection> {
    static void encode(Encoder&, const WebCore::SerializedNode::CDATASection&);
    static std::optional<WebCore::SerializedNode::CDATASection> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::SerializedNode::ProcessingInstruction> {
    static void encode(Encoder&, const WebCore::SerializedNode::ProcessingInstruction&);
    static std::optional<WebCore::SerializedNode::ProcessingInstruction> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::SerializedNode::ShadowRoot> {
    static void encode(Encoder&, const WebCore::SerializedNode::ShadowRoot&);
    static std::optional<WebCore::SerializedNode::ShadowRoot> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::SerializedNode::HTMLTemplateElement> {
    static void encode(Encoder&, const WebCore::SerializedNode::HTMLTemplateElement&);
    static std::optional<WebCore::SerializedNode::HTMLTemplateElement> decode(Decoder&);
};

template<> struct ArgumentCoder<WebKit::HTTPBody::Element> {
    static void encode(Encoder&, const WebKit::HTTPBody::Element&);
    static std::optional<WebKit::HTTPBody::Element> decode(Decoder&);
};

template<> struct ArgumentCoder<WebKit::HTTPBody::Element::FileData> {
    static void encode(Encoder&, const WebKit::HTTPBody::Element::FileData&);
    static std::optional<WebKit::HTTPBody::Element::FileData> decode(Decoder&);
};

template<> struct ArgumentCoder<std::monostate> {
    static void encode(Encoder&, const std::monostate&);
    static void encode(StreamConnectionEncoder&, const std::monostate&);
    static std::optional<std::monostate> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::ListStyleType> {
    static void encode(Encoder&, const WebCore::Style::ListStyleType&);
    static std::optional<WebCore::Style::ListStyleType> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::ListStyleType::NoneData> {
    static void encode(Encoder&, const WebCore::Style::ListStyleType::NoneData&);
    static std::optional<WebCore::Style::ListStyleType::NoneData> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::ListStyleType::StringData> {
    static void encode(Encoder&, const WebCore::Style::ListStyleType::StringData&);
    static std::optional<WebCore::Style::ListStyleType::StringData> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::ListStyleType::CounterStyleData> {
    static void encode(Encoder&, const WebCore::Style::ListStyleType::CounterStyleData&);
    static std::optional<WebCore::Style::ListStyleType::CounterStyleData> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::IDBKeyData::Invalid> {
    static void encode(Encoder&, const WebCore::IDBKeyData::Invalid&);
    static std::optional<WebCore::IDBKeyData::Invalid> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::IDBKeyData::Min> {
    static void encode(Encoder&, const WebCore::IDBKeyData::Min&);
    static std::optional<WebCore::IDBKeyData::Min> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::IDBKeyData::Max> {
    static void encode(Encoder&, const WebCore::IDBKeyData::Max&);
    static std::optional<WebCore::IDBKeyData::Max> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::IDBKeyData::Date> {
    static void encode(Encoder&, const WebCore::IDBKeyData::Date&);
    static std::optional<WebCore::IDBKeyData::Date> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::LinearTimingFunction::Point> {
    static void encode(Encoder&, const WebCore::LinearTimingFunction::Point&);
    static std::optional<WebCore::LinearTimingFunction::Point> decode(Decoder&);
};

#if ENABLE(APPLICATION_MANIFEST)
template<> struct ArgumentCoder<WebCore::ApplicationManifest::Icon> {
    static void encode(Encoder&, const WebCore::ApplicationManifest::Icon&);
    static std::optional<WebCore::ApplicationManifest::Icon> decode(Decoder&);
};
#endif

#if ENABLE(APPLICATION_MANIFEST)
template<> struct ArgumentCoder<WebCore::ApplicationManifest::Shortcut> {
    static void encode(Encoder&, const WebCore::ApplicationManifest::Shortcut&);
    static std::optional<WebCore::ApplicationManifest::Shortcut> decode(Decoder&);
};
#endif

template<> struct ArgumentCoder<WebCore::WebLockManagerSnapshot::Info> {
    static void encode(Encoder&, const WebCore::WebLockManagerSnapshot::Info&);
    static std::optional<WebCore::WebLockManagerSnapshot::Info> decode(Decoder&);
};

#if ENABLE(WEB_AUTHN)
template<> struct ArgumentCoder<WebCore::AuthenticationExtensionsClientInputs::LargeBlobInputs> {
    static void encode(Encoder&, const WebCore::AuthenticationExtensionsClientInputs::LargeBlobInputs&);
    static std::optional<WebCore::AuthenticationExtensionsClientInputs::LargeBlobInputs> decode(Decoder&);
};
#endif

#if ENABLE(WEB_AUTHN)
template<> struct ArgumentCoder<WebCore::AuthenticationExtensionsClientInputs::PRFValues> {
    static void encode(Encoder&, const WebCore::AuthenticationExtensionsClientInputs::PRFValues&);
    static std::optional<WebCore::AuthenticationExtensionsClientInputs::PRFValues> decode(Decoder&);
};
#endif

#if ENABLE(WEB_AUTHN)
template<> struct ArgumentCoder<WebCore::AuthenticationExtensionsClientInputs::PRFInputs> {
    static void encode(Encoder&, const WebCore::AuthenticationExtensionsClientInputs::PRFInputs&);
    static std::optional<WebCore::AuthenticationExtensionsClientInputs::PRFInputs> decode(Decoder&);
};
#endif

#if ENABLE(WEB_AUTHN)
template<> struct ArgumentCoder<WebCore::AuthenticationExtensionsClientOutputs::LargeBlobOutputs> {
    static void encode(Encoder&, const WebCore::AuthenticationExtensionsClientOutputs::LargeBlobOutputs&);
    static std::optional<WebCore::AuthenticationExtensionsClientOutputs::LargeBlobOutputs> decode(Decoder&);
};
#endif

#if ENABLE(WEB_AUTHN)
template<> struct ArgumentCoder<WebCore::AuthenticationExtensionsClientOutputs::PRFValues> {
    static void encode(Encoder&, const WebCore::AuthenticationExtensionsClientOutputs::PRFValues&);
    static std::optional<WebCore::AuthenticationExtensionsClientOutputs::PRFValues> decode(Decoder&);
};
#endif

#if ENABLE(WEB_AUTHN)
template<> struct ArgumentCoder<WebCore::AuthenticationExtensionsClientOutputs::PRFOutputs> {
    static void encode(Encoder&, const WebCore::AuthenticationExtensionsClientOutputs::PRFOutputs&);
    static std::optional<WebCore::AuthenticationExtensionsClientOutputs::PRFOutputs> decode(Decoder&);
};
#endif

#if ENABLE(WEB_AUTHN)
template<> struct ArgumentCoder<WebCore::PublicKeyCredentialParameters> {
    static void encode(Encoder&, const WebCore::PublicKeyCredentialParameters&);
    static std::optional<WebCore::PublicKeyCredentialParameters> decode(Decoder&);
};
#endif

template<> struct ArgumentCoder<WebCore::HTTPHeaderMap::CommonHeader> {
    static void encode(Encoder&, const WebCore::HTTPHeaderMap::CommonHeader&);
    static std::optional<WebCore::HTTPHeaderMap::CommonHeader> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::HTTPHeaderMap::UncommonHeader> {
    static void encode(Encoder&, const WebCore::HTTPHeaderMap::UncommonHeader&);
    static std::optional<WebCore::HTTPHeaderMap::UncommonHeader> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::ResourceRequest::RequestData> {
    static void encode(Encoder&, const WebCore::ResourceRequest::RequestData&);
    static std::optional<WebCore::ResourceRequest::RequestData> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::ResourceError::IPCData> {
    static void encode(Encoder&, const WebCore::ResourceError::IPCData&);
    static std::optional<WebCore::ResourceError::IPCData> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::FormDataElement::EncodedFileData> {
    static void encode(Encoder&, const WebCore::FormDataElement::EncodedFileData&);
    static std::optional<WebCore::FormDataElement::EncodedFileData> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::FormDataElement::EncodedBlobData> {
    static void encode(Encoder&, const WebCore::FormDataElement::EncodedBlobData&);
    static std::optional<WebCore::FormDataElement::EncodedBlobData> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::PlatformTimeRanges::Range> {
    static void encode(Encoder&, const WebCore::PlatformTimeRanges::Range&);
    static std::optional<WebCore::PlatformTimeRanges::Range> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::PasteboardCustomData::Entry> {
    static void encode(Encoder&, const WebCore::PasteboardCustomData::Entry&);
    static std::optional<WebCore::PasteboardCustomData::Entry> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Gradient::LinearData> {
    static void encode(Encoder&, const WebCore::Gradient::LinearData&);
    static void encode(StreamConnectionEncoder&, const WebCore::Gradient::LinearData&);
    static std::optional<WebCore::Gradient::LinearData> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Gradient::RadialData> {
    static void encode(Encoder&, const WebCore::Gradient::RadialData&);
    static void encode(StreamConnectionEncoder&, const WebCore::Gradient::RadialData&);
    static std::optional<WebCore::Gradient::RadialData> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Gradient::ConicData> {
    static void encode(Encoder&, const WebCore::Gradient::ConicData&);
    static void encode(StreamConnectionEncoder&, const WebCore::Gradient::ConicData&);
    static std::optional<WebCore::Gradient::ConicData> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::Angle<WebCore::CSS::Nonnegative>> {
    static void encode(Encoder&, const WebCore::Style::Angle<WebCore::CSS::Nonnegative>&);
    static std::optional<WebCore::Style::Angle<WebCore::CSS::Nonnegative>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::Angle<WebCore::CSS::All>> {
    static void encode(Encoder&, const WebCore::Style::Angle<WebCore::CSS::All>&);
    static std::optional<WebCore::Style::Angle<WebCore::CSS::All>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::AngleAllFloat> {
    static void encode(Encoder&, const WebCore::Style::AngleAllFloat&);
    static std::optional<WebCore::Style::AngleAllFloat> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::PercentageNonnegativeFloat> {
    static void encode(Encoder&, const WebCore::Style::PercentageNonnegativeFloat&);
    static std::optional<WebCore::Style::PercentageNonnegativeFloat> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::PercentageAllFloat> {
    static void encode(Encoder&, const WebCore::Style::PercentageAllFloat&);
    static std::optional<WebCore::Style::PercentageAllFloat> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::LengthNonnegative> {
    static void encode(Encoder&, const WebCore::Style::LengthNonnegative&);
    static std::optional<WebCore::Style::LengthNonnegative> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::Length<WebCore::CSS::All>> {
    static void encode(Encoder&, const WebCore::Style::Length<WebCore::CSS::All>&);
    static std::optional<WebCore::Style::Length<WebCore::CSS::All>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::Percentage<WebCore::CSS::Nonnegative>> {
    static void encode(Encoder&, const WebCore::Style::Percentage<WebCore::CSS::Nonnegative>&);
    static std::optional<WebCore::Style::Percentage<WebCore::CSS::Nonnegative>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::Percentage<WebCore::CSS::All>> {
    static void encode(Encoder&, const WebCore::Style::Percentage<WebCore::CSS::All>&);
    static std::optional<WebCore::Style::Percentage<WebCore::CSS::All>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::LengthPercentage<WebCore::CSS::All>> {
    static void encode(Encoder&, const WebCore::Style::LengthPercentage<WebCore::CSS::All>&);
    static std::optional<WebCore::Style::LengthPercentage<WebCore::CSS::All>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::LengthPercentage<WebCore::CSS::Nonnegative>> {
    static void encode(Encoder&, const WebCore::Style::LengthPercentage<WebCore::CSS::Nonnegative>&);
    static std::optional<WebCore::Style::LengthPercentage<WebCore::CSS::Nonnegative>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageNonnegative>> {
    static void encode(Encoder&, const WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageNonnegative>&);
    static std::optional<WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageNonnegative>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageAll>> {
    static void encode(Encoder&, const WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageAll>&);
    static std::optional<WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageAll>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::SpaceSeparatedPair<WebCore::Style::CoordinatePair>> {
    static void encode(Encoder&, const WebCore::SpaceSeparatedPair<WebCore::Style::CoordinatePair>&);
    static std::optional<WebCore::SpaceSeparatedPair<WebCore::Style::CoordinatePair>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::SpaceSeparatedSize<WebCore::Style::LengthPercentageNonnegative>> {
    static void encode(Encoder&, const WebCore::SpaceSeparatedSize<WebCore::Style::LengthPercentageNonnegative>&);
    static std::optional<WebCore::SpaceSeparatedSize<WebCore::Style::LengthPercentageNonnegative>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::SpaceSeparatedSize<WebCore::Style::LengthPercentageAll>> {
    static void encode(Encoder&, const WebCore::SpaceSeparatedSize<WebCore::Style::LengthPercentageAll>&);
    static std::optional<WebCore::SpaceSeparatedSize<WebCore::Style::LengthPercentageAll>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::SpaceSeparatedPoint<WebCore::Style::LengthPercentageNonnegative>> {
    static void encode(Encoder&, const WebCore::SpaceSeparatedPoint<WebCore::Style::LengthPercentageNonnegative>&);
    static std::optional<WebCore::SpaceSeparatedPoint<WebCore::Style::LengthPercentageNonnegative>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::SpaceSeparatedPoint<WebCore::Style::LengthPercentageAll>> {
    static void encode(Encoder&, const WebCore::SpaceSeparatedPoint<WebCore::Style::LengthPercentageAll>&);
    static std::optional<WebCore::SpaceSeparatedPoint<WebCore::Style::LengthPercentageAll>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::MinimallySerializingSpaceSeparatedSize<WebCore::Style::LengthPercentageNonnegative>> {
    static void encode(Encoder&, const WebCore::MinimallySerializingSpaceSeparatedSize<WebCore::Style::LengthPercentageNonnegative>&);
    static std::optional<WebCore::MinimallySerializingSpaceSeparatedSize<WebCore::Style::LengthPercentageNonnegative>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::MinimallySerializingSpaceSeparatedSize<WebCore::Style::LengthPercentageAll>> {
    static void encode(Encoder&, const WebCore::MinimallySerializingSpaceSeparatedSize<WebCore::Style::LengthPercentageAll>&);
    static std::optional<WebCore::MinimallySerializingSpaceSeparatedSize<WebCore::Style::LengthPercentageAll>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::CommaSeparatedVector<WebCore::Style::LengthPercentageSpaceSeparatedPointAll>> {
    static void encode(Encoder&, const WebCore::CommaSeparatedVector<WebCore::Style::LengthPercentageSpaceSeparatedPointAll>&);
    static std::optional<WebCore::CommaSeparatedVector<WebCore::Style::LengthPercentageSpaceSeparatedPointAll>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::CommaSeparatedVector<WebCore::Style::LengthPercentageSpaceSeparatedPointNonnegative>> {
    static void encode(Encoder&, const WebCore::CommaSeparatedVector<WebCore::Style::LengthPercentageSpaceSeparatedPointNonnegative>&);
    static std::optional<WebCore::CommaSeparatedVector<WebCore::Style::LengthPercentageSpaceSeparatedPointNonnegative>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::MinimallySerializingSpaceSeparatedRectEdges<WebCore::Style::LengthPercentageAll>> {
    static void encode(Encoder&, const WebCore::MinimallySerializingSpaceSeparatedRectEdges<WebCore::Style::LengthPercentageAll>&);
    static std::optional<WebCore::MinimallySerializingSpaceSeparatedRectEdges<WebCore::Style::LengthPercentageAll>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::CommaSeparatedVector<WebCore::Style::ShapeCommand>> {
    static void encode(Encoder&, const WebCore::CommaSeparatedVector<WebCore::Style::ShapeCommand>&);
    static std::optional<WebCore::CommaSeparatedVector<WebCore::Style::ShapeCommand>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::PositionX> {
    static void encode(Encoder&, const WebCore::Style::PositionX&);
    static std::optional<WebCore::Style::PositionX> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::PositionY> {
    static void encode(Encoder&, const WebCore::Style::PositionY&);
    static std::optional<WebCore::Style::PositionY> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::Position> {
    static void encode(Encoder&, const WebCore::Style::Position&);
    static std::optional<WebCore::Style::Position> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::TwoComponentPositionHorizontal> {
    static void encode(Encoder&, const WebCore::Style::TwoComponentPositionHorizontal&);
    static std::optional<WebCore::Style::TwoComponentPositionHorizontal> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::TwoComponentPositionVertical> {
    static void encode(Encoder&, const WebCore::Style::TwoComponentPositionVertical&);
    static std::optional<WebCore::Style::TwoComponentPositionVertical> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Constant<WebCore::CSSValueClosestCorner>> {
    static void encode(Encoder&, const WebCore::Constant<WebCore::CSSValueClosestCorner>&);
    static std::optional<WebCore::Constant<WebCore::CSSValueClosestCorner>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Constant<WebCore::CSSValueClosestSide>> {
    static void encode(Encoder&, const WebCore::Constant<WebCore::CSSValueClosestSide>&);
    static std::optional<WebCore::Constant<WebCore::CSSValueClosestSide>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Constant<WebCore::CSSValueFarthestCorner>> {
    static void encode(Encoder&, const WebCore::Constant<WebCore::CSSValueFarthestCorner>&);
    static std::optional<WebCore::Constant<WebCore::CSSValueFarthestCorner>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Constant<WebCore::CSSValueFarthestSide>> {
    static void encode(Encoder&, const WebCore::Constant<WebCore::CSSValueFarthestSide>&);
    static std::optional<WebCore::Constant<WebCore::CSSValueFarthestSide>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::CircleFunction> {
    static void encode(Encoder&, const WebCore::Style::CircleFunction&);
    static std::optional<WebCore::Style::CircleFunction> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::Circle> {
    static void encode(Encoder&, const WebCore::Style::Circle&);
    static std::optional<WebCore::Style::Circle> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::SpaceSeparatedPair<WebCore::Style::Ellipse::RadialSize>> {
    static void encode(Encoder&, const WebCore::SpaceSeparatedPair<WebCore::Style::Ellipse::RadialSize>&);
    static std::optional<WebCore::SpaceSeparatedPair<WebCore::Style::Ellipse::RadialSize>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::EllipseFunction> {
    static void encode(Encoder&, const WebCore::Style::EllipseFunction&);
    static std::optional<WebCore::Style::EllipseFunction> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::Ellipse> {
    static void encode(Encoder&, const WebCore::Style::Ellipse&);
    static std::optional<WebCore::Style::Ellipse> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::InsetFunction> {
    static void encode(Encoder&, const WebCore::Style::InsetFunction&);
    static std::optional<WebCore::Style::InsetFunction> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::Inset> {
    static void encode(Encoder&, const WebCore::Style::Inset&);
    static std::optional<WebCore::Style::Inset> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::PathFunction> {
    static void encode(Encoder&, const WebCore::Style::PathFunction&);
    static std::optional<WebCore::Style::PathFunction> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::Path::Data> {
    static void encode(Encoder&, const WebCore::Style::Path::Data&);
    static std::optional<WebCore::Style::Path::Data> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::Path> {
    static void encode(Encoder&, const WebCore::Style::Path&);
    static std::optional<WebCore::Style::Path> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::PolygonFunction> {
    static void encode(Encoder&, const WebCore::Style::PolygonFunction&);
    static std::optional<WebCore::Style::PolygonFunction> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::Polygon> {
    static void encode(Encoder&, const WebCore::Style::Polygon&);
    static std::optional<WebCore::Style::Polygon> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Constant<WebCore::CSSValueNonzero>> {
    static void encode(Encoder&, const WebCore::Constant<WebCore::CSSValueNonzero>&);
    static std::optional<WebCore::Constant<WebCore::CSSValueNonzero>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Constant<WebCore::CSSValueEvenodd>> {
    static void encode(Encoder&, const WebCore::Constant<WebCore::CSSValueEvenodd>&);
    static std::optional<WebCore::Constant<WebCore::CSSValueEvenodd>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Constant<WebCore::CSSValueBy>> {
    static void encode(Encoder&, const WebCore::Constant<WebCore::CSSValueBy>&);
    static std::optional<WebCore::Constant<WebCore::CSSValueBy>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Constant<WebCore::CSSValueTo>> {
    static void encode(Encoder&, const WebCore::Constant<WebCore::CSSValueTo>&);
    static std::optional<WebCore::Constant<WebCore::CSSValueTo>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Constant<WebCore::CSSValueCcw>> {
    static void encode(Encoder&, const WebCore::Constant<WebCore::CSSValueCcw>&);
    static std::optional<WebCore::Constant<WebCore::CSSValueCcw>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Constant<WebCore::CSSValueCw>> {
    static void encode(Encoder&, const WebCore::Constant<WebCore::CSSValueCw>&);
    static std::optional<WebCore::Constant<WebCore::CSSValueCw>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Constant<WebCore::CSSValueLarge>> {
    static void encode(Encoder&, const WebCore::Constant<WebCore::CSSValueLarge>&);
    static std::optional<WebCore::Constant<WebCore::CSSValueLarge>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Constant<WebCore::CSSValueSmall>> {
    static void encode(Encoder&, const WebCore::Constant<WebCore::CSSValueSmall>&);
    static std::optional<WebCore::Constant<WebCore::CSSValueSmall>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Constant<WebCore::CSSValueStart>> {
    static void encode(Encoder&, const WebCore::Constant<WebCore::CSSValueStart>&);
    static std::optional<WebCore::Constant<WebCore::CSSValueStart>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Constant<WebCore::CSSValueEnd>> {
    static void encode(Encoder&, const WebCore::Constant<WebCore::CSSValueEnd>&);
    static std::optional<WebCore::Constant<WebCore::CSSValueEnd>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Constant<WebCore::CSSValueOrigin>> {
    static void encode(Encoder&, const WebCore::Constant<WebCore::CSSValueOrigin>&);
    static std::optional<WebCore::Constant<WebCore::CSSValueOrigin>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Constant<WebCore::CSSValueClose>> {
    static void encode(Encoder&, const WebCore::Constant<WebCore::CSSValueClose>&);
    static std::optional<WebCore::Constant<WebCore::CSSValueClose>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::ToPosition> {
    static void encode(Encoder&, const WebCore::Style::ToPosition&);
    static std::optional<WebCore::Style::ToPosition> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::ByCoordinatePair> {
    static void encode(Encoder&, const WebCore::Style::ByCoordinatePair&);
    static std::optional<WebCore::Style::ByCoordinatePair> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::RelativeControlPoint> {
    static void encode(Encoder&, const WebCore::Style::RelativeControlPoint&);
    static std::optional<WebCore::Style::RelativeControlPoint> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::AbsoluteControlPoint> {
    static void encode(Encoder&, const WebCore::Style::AbsoluteControlPoint&);
    static std::optional<WebCore::Style::AbsoluteControlPoint> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::ShapeFunction> {
    static void encode(Encoder&, const WebCore::Style::ShapeFunction&);
    static std::optional<WebCore::Style::ShapeFunction> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::Shape> {
    static void encode(Encoder&, const WebCore::Style::Shape&);
    static std::optional<WebCore::Style::Shape> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::MoveCommand> {
    static void encode(Encoder&, const WebCore::Style::MoveCommand&);
    static std::optional<WebCore::Style::MoveCommand> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::LineCommand> {
    static void encode(Encoder&, const WebCore::Style::LineCommand&);
    static std::optional<WebCore::Style::LineCommand> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::HLineCommand::To> {
    static void encode(Encoder&, const WebCore::Style::HLineCommand::To&);
    static std::optional<WebCore::Style::HLineCommand::To> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::HLineCommand::By> {
    static void encode(Encoder&, const WebCore::Style::HLineCommand::By&);
    static std::optional<WebCore::Style::HLineCommand::By> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::HLineCommand> {
    static void encode(Encoder&, const WebCore::Style::HLineCommand&);
    static std::optional<WebCore::Style::HLineCommand> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::VLineCommand::To> {
    static void encode(Encoder&, const WebCore::Style::VLineCommand::To&);
    static std::optional<WebCore::Style::VLineCommand::To> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::VLineCommand::By> {
    static void encode(Encoder&, const WebCore::Style::VLineCommand::By&);
    static std::optional<WebCore::Style::VLineCommand::By> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::VLineCommand> {
    static void encode(Encoder&, const WebCore::Style::VLineCommand&);
    static std::optional<WebCore::Style::VLineCommand> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::CurveCommand::To> {
    static void encode(Encoder&, const WebCore::Style::CurveCommand::To&);
    static std::optional<WebCore::Style::CurveCommand::To> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::CurveCommand::By> {
    static void encode(Encoder&, const WebCore::Style::CurveCommand::By&);
    static std::optional<WebCore::Style::CurveCommand::By> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::CurveCommand> {
    static void encode(Encoder&, const WebCore::Style::CurveCommand&);
    static std::optional<WebCore::Style::CurveCommand> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::SmoothCommand::To> {
    static void encode(Encoder&, const WebCore::Style::SmoothCommand::To&);
    static std::optional<WebCore::Style::SmoothCommand::To> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::SmoothCommand::By> {
    static void encode(Encoder&, const WebCore::Style::SmoothCommand::By&);
    static std::optional<WebCore::Style::SmoothCommand::By> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::SmoothCommand> {
    static void encode(Encoder&, const WebCore::Style::SmoothCommand&);
    static std::optional<WebCore::Style::SmoothCommand> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::ArcCommand> {
    static void encode(Encoder&, const WebCore::Style::ArcCommand&);
    static std::optional<WebCore::Style::ArcCommand> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::BorderRadius> {
    static void encode(Encoder&, const WebCore::Style::BorderRadius&);
    static std::optional<WebCore::Style::BorderRadius> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Constant<WebCore::CSSValueSides>> {
    static void encode(Encoder&, const WebCore::Constant<WebCore::CSSValueSides>&);
    static std::optional<WebCore::Constant<WebCore::CSSValueSides>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Constant<WebCore::CSSValueContain>> {
    static void encode(Encoder&, const WebCore::Constant<WebCore::CSSValueContain>&);
    static std::optional<WebCore::Constant<WebCore::CSSValueContain>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::RayFunction> {
    static void encode(Encoder&, const WebCore::Style::RayFunction&);
    static std::optional<WebCore::Style::RayFunction> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Style::Ray> {
    static void encode(Encoder&, const WebCore::Style::Ray&);
    static std::optional<WebCore::Style::Ray> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::TextManipulationControllerExclusionRule::ElementRule> {
    static void encode(Encoder&, const WebCore::TextManipulationControllerExclusionRule::ElementRule&);
    static std::optional<WebCore::TextManipulationControllerExclusionRule::ElementRule> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::TextManipulationControllerExclusionRule::AttributeRule> {
    static void encode(Encoder&, const WebCore::TextManipulationControllerExclusionRule::AttributeRule&);
    static std::optional<WebCore::TextManipulationControllerExclusionRule::AttributeRule> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::TextManipulationControllerExclusionRule::ClassRule> {
    static void encode(Encoder&, const WebCore::TextManipulationControllerExclusionRule::ClassRule&);
    static std::optional<WebCore::TextManipulationControllerExclusionRule::ClassRule> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::ColorInterpolationMethod::HSL> {
    static void encode(Encoder&, const WebCore::ColorInterpolationMethod::HSL&);
    static void encode(StreamConnectionEncoder&, const WebCore::ColorInterpolationMethod::HSL&);
    static std::optional<WebCore::ColorInterpolationMethod::HSL> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::ColorInterpolationMethod::HWB> {
    static void encode(Encoder&, const WebCore::ColorInterpolationMethod::HWB&);
    static void encode(StreamConnectionEncoder&, const WebCore::ColorInterpolationMethod::HWB&);
    static std::optional<WebCore::ColorInterpolationMethod::HWB> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::ColorInterpolationMethod::LCH> {
    static void encode(Encoder&, const WebCore::ColorInterpolationMethod::LCH&);
    static void encode(StreamConnectionEncoder&, const WebCore::ColorInterpolationMethod::LCH&);
    static std::optional<WebCore::ColorInterpolationMethod::LCH> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::ColorInterpolationMethod::Lab> {
    static void encode(Encoder&, const WebCore::ColorInterpolationMethod::Lab&);
    static void encode(StreamConnectionEncoder&, const WebCore::ColorInterpolationMethod::Lab&);
    static std::optional<WebCore::ColorInterpolationMethod::Lab> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::ColorInterpolationMethod::OKLCH> {
    static void encode(Encoder&, const WebCore::ColorInterpolationMethod::OKLCH&);
    static void encode(StreamConnectionEncoder&, const WebCore::ColorInterpolationMethod::OKLCH&);
    static std::optional<WebCore::ColorInterpolationMethod::OKLCH> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::ColorInterpolationMethod::OKLab> {
    static void encode(Encoder&, const WebCore::ColorInterpolationMethod::OKLab&);
    static void encode(StreamConnectionEncoder&, const WebCore::ColorInterpolationMethod::OKLab&);
    static std::optional<WebCore::ColorInterpolationMethod::OKLab> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::ColorInterpolationMethod::SRGB> {
    static void encode(Encoder&, const WebCore::ColorInterpolationMethod::SRGB&);
    static void encode(StreamConnectionEncoder&, const WebCore::ColorInterpolationMethod::SRGB&);
    static std::optional<WebCore::ColorInterpolationMethod::SRGB> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::ColorInterpolationMethod::SRGBLinear> {
    static void encode(Encoder&, const WebCore::ColorInterpolationMethod::SRGBLinear&);
    static void encode(StreamConnectionEncoder&, const WebCore::ColorInterpolationMethod::SRGBLinear&);
    static std::optional<WebCore::ColorInterpolationMethod::SRGBLinear> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::ColorInterpolationMethod::DisplayP3> {
    static void encode(Encoder&, const WebCore::ColorInterpolationMethod::DisplayP3&);
    static void encode(StreamConnectionEncoder&, const WebCore::ColorInterpolationMethod::DisplayP3&);
    static std::optional<WebCore::ColorInterpolationMethod::DisplayP3> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::ColorInterpolationMethod::A98RGB> {
    static void encode(Encoder&, const WebCore::ColorInterpolationMethod::A98RGB&);
    static void encode(StreamConnectionEncoder&, const WebCore::ColorInterpolationMethod::A98RGB&);
    static std::optional<WebCore::ColorInterpolationMethod::A98RGB> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::ColorInterpolationMethod::ProPhotoRGB> {
    static void encode(Encoder&, const WebCore::ColorInterpolationMethod::ProPhotoRGB&);
    static void encode(StreamConnectionEncoder&, const WebCore::ColorInterpolationMethod::ProPhotoRGB&);
    static std::optional<WebCore::ColorInterpolationMethod::ProPhotoRGB> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::ColorInterpolationMethod::Rec2020> {
    static void encode(Encoder&, const WebCore::ColorInterpolationMethod::Rec2020&);
    static void encode(StreamConnectionEncoder&, const WebCore::ColorInterpolationMethod::Rec2020&);
    static std::optional<WebCore::ColorInterpolationMethod::Rec2020> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::ColorInterpolationMethod::XYZD50> {
    static void encode(Encoder&, const WebCore::ColorInterpolationMethod::XYZD50&);
    static void encode(StreamConnectionEncoder&, const WebCore::ColorInterpolationMethod::XYZD50&);
    static std::optional<WebCore::ColorInterpolationMethod::XYZD50> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::ColorInterpolationMethod::XYZD65> {
    static void encode(Encoder&, const WebCore::ColorInterpolationMethod::XYZD65&);
    static void encode(StreamConnectionEncoder&, const WebCore::ColorInterpolationMethod::XYZD65&);
    static std::optional<WebCore::ColorInterpolationMethod::XYZD65> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::SecurityOriginData::Tuple> {
    static void encode(Encoder&, const WebCore::SecurityOriginData::Tuple&);
    static std::optional<WebCore::SecurityOriginData::Tuple> decode(Decoder&);
};

#if ENABLE(MEDIA_STREAM)
template<> struct ArgumentCoder<WebCore::RealtimeMediaSourceCenter::ValidDevices> {
    static void encode(Encoder&, const WebCore::RealtimeMediaSourceCenter::ValidDevices&);
    static std::optional<WebCore::RealtimeMediaSourceCenter::ValidDevices> decode(Decoder&);
};
#endif

#if ENABLE(CONTENT_EXTENSIONS)
template<> struct ArgumentCoder<WebCore::ContentRuleListResults::Result> {
    static void encode(Encoder&, const WebCore::ContentRuleListResults::Result&);
    static std::optional<WebCore::ContentRuleListResults::Result> decode(Decoder&);
};
#endif

#if ENABLE(CONTENT_EXTENSIONS)
template<> struct ArgumentCoder<WebCore::ContentRuleListResults::Summary> {
    static void encode(Encoder&, const WebCore::ContentRuleListResults::Summary&);
    static std::optional<WebCore::ContentRuleListResults::Summary> decode(Decoder&);
};
#endif

template<> struct ArgumentCoder<WebCore::Region::Span> {
    static void encode(Encoder&, const WebCore::Region::Span&);
    static void encode(StreamConnectionEncoder&, const WebCore::Region::Span&);
    static std::optional<WebCore::Region::Span> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Region::Shape> {
    static void encode(Encoder&, const WebCore::Region::Shape&);
    static void encode(StreamConnectionEncoder&, const WebCore::Region::Shape&);
    static std::optional<WebCore::Region::Shape> decode(Decoder&);
};

#if ENABLE(WEB_AUTHN)
template<> struct ArgumentCoder<WebCore::MockWebAuthenticationConfiguration::LocalConfiguration> {
    static void encode(Encoder&, const WebCore::MockWebAuthenticationConfiguration::LocalConfiguration&);
    static std::optional<WebCore::MockWebAuthenticationConfiguration::LocalConfiguration> decode(Decoder&);
};
#endif

#if ENABLE(WEB_AUTHN)
template<> struct ArgumentCoder<WebCore::MockWebAuthenticationConfiguration::HidConfiguration> {
    static void encode(Encoder&, const WebCore::MockWebAuthenticationConfiguration::HidConfiguration&);
    static std::optional<WebCore::MockWebAuthenticationConfiguration::HidConfiguration> decode(Decoder&);
};
#endif

#if ENABLE(WEB_AUTHN)
template<> struct ArgumentCoder<WebCore::MockWebAuthenticationConfiguration::NfcConfiguration> {
    static void encode(Encoder&, const WebCore::MockWebAuthenticationConfiguration::NfcConfiguration&);
    static std::optional<WebCore::MockWebAuthenticationConfiguration::NfcConfiguration> decode(Decoder&);
};
#endif

#if ENABLE(WEB_AUTHN)
template<> struct ArgumentCoder<WebCore::MockWebAuthenticationConfiguration::CcidConfiguration> {
    static void encode(Encoder&, const WebCore::MockWebAuthenticationConfiguration::CcidConfiguration&);
    static std::optional<WebCore::MockWebAuthenticationConfiguration::CcidConfiguration> decode(Decoder&);
};
#endif

#if (ENABLE(WEB_AUTHN)) && (HAVE(DIGITAL_CREDENTIALS_UI))
template<> struct ArgumentCoder<WebCore::ISO18013ElementInfo> {
    static void encode(Encoder&, const WebCore::ISO18013ElementInfo&);
    static std::optional<WebCore::ISO18013ElementInfo> decode(Decoder&);
};
#endif

#if (ENABLE(WEB_AUTHN)) && (HAVE(DIGITAL_CREDENTIALS_UI))
template<> struct ArgumentCoder<WebCore::ISO18013DocumentRequest> {
    static void encode(Encoder&, const WebCore::ISO18013DocumentRequest&);
    static std::optional<WebCore::ISO18013DocumentRequest> decode(Decoder&);
};
#endif

#if (ENABLE(WEB_AUTHN)) && (HAVE(DIGITAL_CREDENTIALS_UI))
template<> struct ArgumentCoder<WebCore::ISO18013DocumentRequestSet> {
    static void encode(Encoder&, const WebCore::ISO18013DocumentRequestSet&);
    static std::optional<WebCore::ISO18013DocumentRequestSet> decode(Decoder&);
};
#endif

#if (ENABLE(WEB_AUTHN)) && (HAVE(DIGITAL_CREDENTIALS_UI))
template<> struct ArgumentCoder<WebCore::ISO18013PresentmentRequest> {
    static void encode(Encoder&, const WebCore::ISO18013PresentmentRequest&);
    static std::optional<WebCore::ISO18013PresentmentRequest> decode(Decoder&);
};
#endif

#if (ENABLE(WEB_AUTHN)) && (HAVE(DIGITAL_CREDENTIALS_UI))
template<> struct ArgumentCoder<WebCore::ValidatedMobileDocumentRequest> {
    static void encode(Encoder&, const WebCore::ValidatedMobileDocumentRequest&);
    static std::optional<WebCore::ValidatedMobileDocumentRequest> decode(Decoder&);
};
#endif

#if ENABLE(THREADED_ANIMATION_RESOLUTION)
template<> struct ArgumentCoder<WebCore::Constant<WebCore::CSSValueAuto>> {
    static void encode(Encoder&, const WebCore::Constant<WebCore::CSSValueAuto>&);
    static std::optional<WebCore::Constant<WebCore::CSSValueAuto>> decode(Decoder&);
};
#endif

#if ENABLE(THREADED_ANIMATION_RESOLUTION)
template<> struct ArgumentCoder<WebCore::AcceleratedEffect::Keyframe> {
    static void encode(Encoder&, const WebCore::AcceleratedEffect::Keyframe&);
    static std::optional<WebCore::AcceleratedEffect::Keyframe> decode(Decoder&);
};
#endif

template<> struct ArgumentCoder<WebCore::Credential::NonPlatformData> {
    static void encode(Encoder&, const WebCore::Credential::NonPlatformData&);
    static std::optional<WebCore::Credential::NonPlatformData> decode(Decoder&);
};

#if USE(SOUP)
template<> struct ArgumentCoder<WebCore::Credential::PlatformData> {
    static void encode(Encoder&, const WebCore::Credential::PlatformData&);
    static std::optional<WebCore::Credential::PlatformData> decode(Decoder&);
};
#endif

#if PLATFORM(IOS_FAMILY)
template<> struct ArgumentCoder<WebCore::InspectorOverlayLabel::Content::Decoration> {
    static void encode(Encoder&, const WebCore::InspectorOverlayLabel::Content::Decoration&);
    static std::optional<WebCore::InspectorOverlayLabel::Content::Decoration> decode(Decoder&);
};
#endif

#if PLATFORM(IOS_FAMILY)
template<> struct ArgumentCoder<WebCore::InspectorOverlayLabel::Content> {
    static void encode(Encoder&, const WebCore::InspectorOverlayLabel::Content&);
    static std::optional<WebCore::InspectorOverlayLabel::Content> decode(Decoder&);
};
#endif

#if PLATFORM(IOS_FAMILY)
template<> struct ArgumentCoder<WebCore::InspectorOverlayLabel::Arrow> {
    static void encode(Encoder&, const WebCore::InspectorOverlayLabel::Arrow&);
    static std::optional<WebCore::InspectorOverlayLabel::Arrow> decode(Decoder&);
};
#endif

#if PLATFORM(IOS_FAMILY)
template<> struct ArgumentCoder<WebCore::InspectorOverlayHighlight::FlexHighlightOverlay> {
    static void encode(Encoder&, const WebCore::InspectorOverlayHighlight::FlexHighlightOverlay&);
    static std::optional<WebCore::InspectorOverlayHighlight::FlexHighlightOverlay> decode(Decoder&);
};
#endif

#if PLATFORM(IOS_FAMILY)
template<> struct ArgumentCoder<WebCore::InspectorOverlayHighlight::GridHighlightOverlay::Area> {
    static void encode(Encoder&, const WebCore::InspectorOverlayHighlight::GridHighlightOverlay::Area&);
    static std::optional<WebCore::InspectorOverlayHighlight::GridHighlightOverlay::Area> decode(Decoder&);
};
#endif

#if PLATFORM(IOS_FAMILY)
template<> struct ArgumentCoder<WebCore::InspectorOverlayHighlight::GridHighlightOverlay> {
    static void encode(Encoder&, const WebCore::InspectorOverlayHighlight::GridHighlightOverlay&);
    static std::optional<WebCore::InspectorOverlayHighlight::GridHighlightOverlay> decode(Decoder&);
};
#endif

template<> struct ArgumentCoder<WebCore::SerializedScriptValue::Internals> {
    static void encode(Encoder&, const WebCore::SerializedScriptValue::Internals&);
    static std::optional<WebCore::SerializedScriptValue::Internals> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Cursor::CustomCursorIPCData> {
    static void encode(Encoder&, const WebCore::Cursor::CustomCursorIPCData&);
    static std::optional<WebCore::Cursor::CustomCursorIPCData> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Length::AutoData> {
    static void encode(Encoder&, const WebCore::Length::AutoData&);
    static std::optional<WebCore::Length::AutoData> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Length::NormalData> {
    static void encode(Encoder&, const WebCore::Length::NormalData&);
    static std::optional<WebCore::Length::NormalData> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Length::RelativeData> {
    static void encode(Encoder&, const WebCore::Length::RelativeData&);
    static std::optional<WebCore::Length::RelativeData> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Length::PercentData> {
    static void encode(Encoder&, const WebCore::Length::PercentData&);
    static std::optional<WebCore::Length::PercentData> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Length::FixedData> {
    static void encode(Encoder&, const WebCore::Length::FixedData&);
    static std::optional<WebCore::Length::FixedData> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Length::IntrinsicData> {
    static void encode(Encoder&, const WebCore::Length::IntrinsicData&);
    static std::optional<WebCore::Length::IntrinsicData> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Length::MinIntrinsicData> {
    static void encode(Encoder&, const WebCore::Length::MinIntrinsicData&);
    static std::optional<WebCore::Length::MinIntrinsicData> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Length::MinContentData> {
    static void encode(Encoder&, const WebCore::Length::MinContentData&);
    static std::optional<WebCore::Length::MinContentData> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Length::MaxContentData> {
    static void encode(Encoder&, const WebCore::Length::MaxContentData&);
    static std::optional<WebCore::Length::MaxContentData> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Length::FillAvailableData> {
    static void encode(Encoder&, const WebCore::Length::FillAvailableData&);
    static std::optional<WebCore::Length::FillAvailableData> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Length::FitContentData> {
    static void encode(Encoder&, const WebCore::Length::FitContentData&);
    static std::optional<WebCore::Length::FitContentData> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Length::ContentData> {
    static void encode(Encoder&, const WebCore::Length::ContentData&);
    static std::optional<WebCore::Length::ContentData> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::Length::UndefinedData> {
    static void encode(Encoder&, const WebCore::Length::UndefinedData&);
    static std::optional<WebCore::Length::UndefinedData> decode(Decoder&);
};

#if ENABLE(VIDEO)
template<> struct ArgumentCoder<WebCore::SerializedPlatformDataCueValue::Data> {
    static void encode(Encoder&, const WebCore::SerializedPlatformDataCueValue::Data&);
    static std::optional<WebCore::SerializedPlatformDataCueValue::Data> decode(Decoder&);
};
#endif

template<> struct ArgumentCoder<WebCore::Allowlist::AllowAllOrigins> {
    static void encode(Encoder&, const WebCore::Allowlist::AllowAllOrigins&);
    static std::optional<WebCore::Allowlist::AllowAllOrigins> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::MediaSamplesBlock::MediaSampleItem> {
    static void encode(Encoder&, const WebCore::MediaSamplesBlock::MediaSampleItem&);
    static std::optional<WebCore::MediaSamplesBlock::MediaSampleItem> decode(Decoder&);
};

template<> struct ArgumentCoder<WebCore::RectEdges<WebCore::FixedContainerEdge>> {
    static void encode(Encoder&, const WebCore::RectEdges<WebCore::FixedContainerEdge>&);
    static std::optional<WebCore::RectEdges<WebCore::FixedContainerEdge>> decode(Decoder&);
};

template<> struct ArgumentCoder<WebKit::WebFoundTextRange::DOMData> {
    static void encode(Encoder&, const WebKit::WebFoundTextRange::DOMData&);
    static std::optional<WebKit::WebFoundTextRange::DOMData> decode(Decoder&);
};

template<> struct ArgumentCoder<WebKit::WebFoundTextRange::PDFData> {
    static void encode(Encoder&, const WebKit::WebFoundTextRange::PDFData&);
    static std::optional<WebKit::WebFoundTextRange::PDFData> decode(Decoder&);
};

template<> struct ArgumentCoder<WebKit::RemotePageParameters> {
    static void encode(Encoder&, const WebKit::RemotePageParameters&);
    static std::optional<WebKit::RemotePageParameters> decode(Decoder&);
};

template<> struct ArgumentCoder<WebKit::WebsiteData::Entry> {
    static void encode(Encoder&, const WebKit::WebsiteData::Entry&);
    static std::optional<WebKit::WebsiteData::Entry> decode(Decoder&);
};

#if ENABLE(WEBXR)
template<> struct ArgumentCoder<PlatformXR::DepthRange> {
    static void encode(Encoder&, const PlatformXR::DepthRange&);
    static std::optional<PlatformXR::DepthRange> decode(Decoder&);
};
#endif

#if ENABLE(WEBXR)
template<> struct ArgumentCoder<PlatformXR::FrameData::FloatQuaternion> {
    static void encode(Encoder&, const PlatformXR::FrameData::FloatQuaternion&);
    static std::optional<PlatformXR::FrameData::FloatQuaternion> decode(Decoder&);
};
#endif

#if ENABLE(WEBXR)
template<> struct ArgumentCoder<PlatformXR::FrameData::Pose> {
    static void encode(Encoder&, const PlatformXR::FrameData::Pose&);
    static std::optional<PlatformXR::FrameData::Pose> decode(Decoder&);
};
#endif

#if ENABLE(WEBXR)
template<> struct ArgumentCoder<PlatformXR::FrameData::Fov> {
    static void encode(Encoder&, const PlatformXR::FrameData::Fov&);
    static std::optional<PlatformXR::FrameData::Fov> decode(Decoder&);
};
#endif

#if ENABLE(WEBXR)
template<> struct ArgumentCoder<PlatformXR::FrameData::View> {
    static void encode(Encoder&, const PlatformXR::FrameData::View&);
    static std::optional<PlatformXR::FrameData::View> decode(Decoder&);
};
#endif

#if ENABLE(WEBXR)
template<> struct ArgumentCoder<PlatformXR::FrameData::StageParameters> {
    static void encode(Encoder&, const PlatformXR::FrameData::StageParameters&);
    static std::optional<PlatformXR::FrameData::StageParameters> decode(Decoder&);
};
#endif

#if (ENABLE(WEBXR)) && (PLATFORM(COCOA))
template<> struct ArgumentCoder<PlatformXR::FrameData::RateMapDescription> {
    static void encode(Encoder&, const PlatformXR::FrameData::RateMapDescription&);
    static std::optional<PlatformXR::FrameData::RateMapDescription> decode(Decoder&);
};
#endif

#if (ENABLE(WEBXR)) && (PLATFORM(COCOA))
template<> struct ArgumentCoder<PlatformXR::FrameData::LayerSetupData> {
    static void encode(Encoder&, PlatformXR::FrameData::LayerSetupData&&);
    static std::optional<PlatformXR::FrameData::LayerSetupData> decode(Decoder&);
};
#endif

#if (ENABLE(WEBXR)) && (PLATFORM(COCOA))
template<> struct ArgumentCoder<PlatformXR::FrameData::ExternalTexture> {
    static void encode(Encoder&, PlatformXR::FrameData::ExternalTexture&&);
    static std::optional<PlatformXR::FrameData::ExternalTexture> decode(Decoder&);
};
#endif

#if (ENABLE(WEBXR)) && (PLATFORM(COCOA))
template<> struct ArgumentCoder<PlatformXR::FrameData::ExternalTextureData> {
    static void encode(Encoder&, PlatformXR::FrameData::ExternalTextureData&&);
    static std::optional<PlatformXR::FrameData::ExternalTextureData> decode(Decoder&);
};
#endif

#if ENABLE(WEBXR)
template<> struct ArgumentCoder<PlatformXR::FrameData::LayerData> {
    static void encode(Encoder&, PlatformXR::FrameData::LayerData&&);
    static std::optional<PlatformXR::FrameData::LayerData> decode(Decoder&);
};
#endif

#if ENABLE(WEBXR)
template<> struct ArgumentCoder<PlatformXR::FrameData::InputSourceButton> {
    static void encode(Encoder&, const PlatformXR::FrameData::InputSourceButton&);
    static std::optional<PlatformXR::FrameData::InputSourceButton> decode(Decoder&);
};
#endif

#if ENABLE(WEBXR)
template<> struct ArgumentCoder<PlatformXR::FrameData::InputSourcePose> {
    static void encode(Encoder&, const PlatformXR::FrameData::InputSourcePose&);
    static std::optional<PlatformXR::FrameData::InputSourcePose> decode(Decoder&);
};
#endif

#if ENABLE(WEBXR_HANDS)
template<> struct ArgumentCoder<PlatformXR::FrameData::InputSourceHandJoint> {
    static void encode(Encoder&, const PlatformXR::FrameData::InputSourceHandJoint&);
    static std::optional<PlatformXR::FrameData::InputSourceHandJoint> decode(Decoder&);
};
#endif

#if ENABLE(WEBXR)
template<> struct ArgumentCoder<PlatformXR::FrameData::InputSource> {
    static void encode(Encoder&, const PlatformXR::FrameData::InputSource&);
    static std::optional<PlatformXR::FrameData::InputSource> decode(Decoder&);
};
#endif

#if (ENABLE(WEBXR)) && (USE(OPENXR))
template<> struct ArgumentCoder<PlatformXR::Device::LayerView> {
    static void encode(Encoder&, const PlatformXR::Device::LayerView&);
    static std::optional<PlatformXR::Device::LayerView> decode(Decoder&);
};
#endif

#if USE(CURL)
template<> struct ArgumentCoder<WebCore::CurlProxySettings::DefaultData> {
    static void encode(Encoder&, const WebCore::CurlProxySettings::DefaultData&);
    static std::optional<WebCore::CurlProxySettings::DefaultData> decode(Decoder&);
};
#endif

#if USE(CURL)
template<> struct ArgumentCoder<WebCore::CurlProxySettings::NoProxyData> {
    static void encode(Encoder&, const WebCore::CurlProxySettings::NoProxyData&);
    static std::optional<WebCore::CurlProxySettings::NoProxyData> decode(Decoder&);
};
#endif

#if USE(CURL)
template<> struct ArgumentCoder<WebCore::CurlProxySettings::CustomData> {
    static void encode(Encoder&, const WebCore::CurlProxySettings::CustomData&);
    static std::optional<WebCore::CurlProxySettings::CustomData> decode(Decoder&);
};
#endif

#if USE(GRAPHICS_LAYER_WC)
template<> struct ArgumentCoder<WebKit::WCLayerUpdateInfo::BackgroundChanges> {
    static void encode(Encoder&, const WebKit::WCLayerUpdateInfo::BackgroundChanges&);
    static std::optional<WebKit::WCLayerUpdateInfo::BackgroundChanges> decode(Decoder&);
};
#endif

#if USE(GRAPHICS_LAYER_WC)
template<> struct ArgumentCoder<WebKit::WCLayerUpdateInfo::PlatformLayerChanges> {
    static void encode(Encoder&, const WebKit::WCLayerUpdateInfo::PlatformLayerChanges&);
    static std::optional<WebKit::WCLayerUpdateInfo::PlatformLayerChanges> decode(Decoder&);
};
#endif

template<> struct ArgumentCoder<WTF::Win32Handle::IPCData> {
    static void encode(Encoder&, WTF::Win32Handle::IPCData&&);
    static std::optional<WTF::Win32Handle::IPCData> decode(Decoder&);
};

#if USE(SKIA)
template<> struct ArgumentCoder<SkFontStyle::Slant> {
    static void encode(Encoder&, const SkFontStyle::Slant&);
    static std::optional<SkFontStyle::Slant> decode(Decoder&);
};
#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::GPUProcessCreationParameters>::encode(Encoder& encoder, WebKit::GPUProcessCreationParameters&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.auxiliaryProcessParameters)>, WebKit::AuxiliaryProcessCreationParameters>);
#if ENABLE(MEDIA_STREAM)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.useMockCaptureDevices)>, bool>);
#endif
#if (ENABLE(MEDIA_STREAM)) && (PLATFORM(MAC))
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.microphoneSandboxExtensionHandle)>, WebKit::SandboxExtensionHandle>);
#endif
#if (ENABLE(MEDIA_STREAM)) && (PLATFORM(MAC))
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.launchServicesExtensionHandle)>, WebKit::SandboxExtensionHandle>);
#endif
#if USE(MODERN_AVCONTENTKEYSESSION)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldUseModernAVContentKeySession)>, bool>);
#endif
#if USE(SANDBOX_EXTENSIONS_FOR_CACHE_AND_TEMP_DIRECTORY_ACCESS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.containerCachesDirectoryExtensionHandle)>, WebKit::SandboxExtensionHandle>);
#endif
#if USE(SANDBOX_EXTENSIONS_FOR_CACHE_AND_TEMP_DIRECTORY_ACCESS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.containerTemporaryDirectoryExtensionHandle)>, WebKit::SandboxExtensionHandle>);
#endif
#if USE(SANDBOX_EXTENSIONS_FOR_CACHE_AND_TEMP_DIRECTORY_ACCESS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.containerCachesDirectory)>, String>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mobileGestaltExtensionHandle)>, std::optional<WebKit::SandboxExtensionHandle>>);
#if PLATFORM(COCOA) && ENABLE(REMOTE_INSPECTOR)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.gpuToolsExtensionHandles)>, Vector<WebKit::SandboxExtensionHandle>>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.applicationVisibleName)>, String>);
#if USE(GBM)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.renderDeviceFile)>, String>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.overrideLanguages)>, Vector<String>>);
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.enableMetalDebugDeviceForTesting)>, bool>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.enableMetalShaderValidationForTesting)>, bool>);
#endif
    struct ShouldBeSameSizeAsGPUProcessCreationParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::GPUProcessCreationParameters>, false> {
        WebKit::AuxiliaryProcessCreationParameters auxiliaryProcessParameters;
#if ENABLE(MEDIA_STREAM)
        bool useMockCaptureDevices;
#endif
#if (ENABLE(MEDIA_STREAM)) && (PLATFORM(MAC))
        WebKit::SandboxExtensionHandle microphoneSandboxExtensionHandle;
#endif
#if (ENABLE(MEDIA_STREAM)) && (PLATFORM(MAC))
        WebKit::SandboxExtensionHandle launchServicesExtensionHandle;
#endif
#if USE(MODERN_AVCONTENTKEYSESSION)
        bool shouldUseModernAVContentKeySession;
#endif
#if USE(SANDBOX_EXTENSIONS_FOR_CACHE_AND_TEMP_DIRECTORY_ACCESS)
        WebKit::SandboxExtensionHandle containerCachesDirectoryExtensionHandle;
#endif
#if USE(SANDBOX_EXTENSIONS_FOR_CACHE_AND_TEMP_DIRECTORY_ACCESS)
        WebKit::SandboxExtensionHandle containerTemporaryDirectoryExtensionHandle;
#endif
#if USE(SANDBOX_EXTENSIONS_FOR_CACHE_AND_TEMP_DIRECTORY_ACCESS)
        String containerCachesDirectory;
#endif
        std::optional<WebKit::SandboxExtensionHandle> mobileGestaltExtensionHandle;
#if PLATFORM(COCOA) && ENABLE(REMOTE_INSPECTOR)
        Vector<WebKit::SandboxExtensionHandle> gpuToolsExtensionHandles;
#endif
        String applicationVisibleName;
#if USE(GBM)
        String renderDeviceFile;
#endif
        Vector<String> overrideLanguages;
#if PLATFORM(COCOA)
        bool enableMetalDebugDeviceForTesting;
#endif
#if PLATFORM(COCOA)
        bool enableMetalShaderValidationForTesting;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsGPUProcessCreationParameters) == sizeof(WebKit::GPUProcessCreationParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::GPUProcessCreationParameters, auxiliaryProcessParameters)
#if ENABLE(MEDIA_STREAM)
        , offsetof(WebKit::GPUProcessCreationParameters, useMockCaptureDevices)
#endif
#if (ENABLE(MEDIA_STREAM)) && (PLATFORM(MAC))
        , offsetof(WebKit::GPUProcessCreationParameters, microphoneSandboxExtensionHandle)
#endif
#if (ENABLE(MEDIA_STREAM)) && (PLATFORM(MAC))
        , offsetof(WebKit::GPUProcessCreationParameters, launchServicesExtensionHandle)
#endif
#if USE(MODERN_AVCONTENTKEYSESSION)
        , offsetof(WebKit::GPUProcessCreationParameters, shouldUseModernAVContentKeySession)
#endif
#if USE(SANDBOX_EXTENSIONS_FOR_CACHE_AND_TEMP_DIRECTORY_ACCESS)
        , offsetof(WebKit::GPUProcessCreationParameters, containerCachesDirectoryExtensionHandle)
#endif
#if USE(SANDBOX_EXTENSIONS_FOR_CACHE_AND_TEMP_DIRECTORY_ACCESS)
        , offsetof(WebKit::GPUProcessCreationParameters, containerTemporaryDirectoryExtensionHandle)
#endif
#if USE(SANDBOX_EXTENSIONS_FOR_CACHE_AND_TEMP_DIRECTORY_ACCESS)
        , offsetof(WebKit::GPUProcessCreationParameters, containerCachesDirectory)
#endif
        , offsetof(WebKit::GPUProcessCreationParameters, mobileGestaltExtensionHandle)
#if PLATFORM(COCOA) && ENABLE(REMOTE_INSPECTOR)
        , offsetof(WebKit::GPUProcessCreationParameters, gpuToolsExtensionHandles)
#endif
        , offsetof(WebKit::GPUProcessCreationParameters, applicationVisibleName)
#if USE(GBM)
        , offsetof(WebKit::GPUProcessCreationParameters, renderDeviceFile)
#endif
        , offsetof(WebKit::GPUProcessCreationParameters, overrideLanguages)
#if PLATFORM(COCOA)
        , offsetof(WebKit::GPUProcessCreationParameters, enableMetalDebugDeviceForTesting)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::GPUProcessCreationParameters, enableMetalShaderValidationForTesting)
#endif
    >::value);

    encoder << WTFMove(instance.auxiliaryProcessParameters);
#if ENABLE(MEDIA_STREAM)
    encoder << WTFMove(instance.useMockCaptureDevices);
#endif
#if (ENABLE(MEDIA_STREAM)) && (PLATFORM(MAC))
    encoder << WTFMove(instance.microphoneSandboxExtensionHandle);
#endif
#if (ENABLE(MEDIA_STREAM)) && (PLATFORM(MAC))
    encoder << WTFMove(instance.launchServicesExtensionHandle);
#endif
#if USE(MODERN_AVCONTENTKEYSESSION)
    encoder << WTFMove(instance.shouldUseModernAVContentKeySession);
#endif
#if USE(SANDBOX_EXTENSIONS_FOR_CACHE_AND_TEMP_DIRECTORY_ACCESS)
    encoder << WTFMove(instance.containerCachesDirectoryExtensionHandle);
#endif
#if USE(SANDBOX_EXTENSIONS_FOR_CACHE_AND_TEMP_DIRECTORY_ACCESS)
    encoder << WTFMove(instance.containerTemporaryDirectoryExtensionHandle);
#endif
#if USE(SANDBOX_EXTENSIONS_FOR_CACHE_AND_TEMP_DIRECTORY_ACCESS)
    encoder << WTFMove(instance.containerCachesDirectory);
#endif
    encoder << WTFMove(instance.mobileGestaltExtensionHandle);
#if PLATFORM(COCOA) && ENABLE(REMOTE_INSPECTOR)
    encoder << WTFMove(instance.gpuToolsExtensionHandles);
#endif
    encoder << WTFMove(instance.applicationVisibleName);
#if USE(GBM)
    encoder << WTFMove(instance.renderDeviceFile);
#endif
    encoder << WTFMove(instance.overrideLanguages);
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.enableMetalDebugDeviceForTesting);
#endif
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.enableMetalShaderValidationForTesting);
#endif
}

std::optional<WebKit::GPUProcessCreationParameters> ArgumentCoder<WebKit::GPUProcessCreationParameters>::decode(Decoder& decoder)
{
    bool addedDecodingFailureIndex = false;
    auto auxiliaryProcessParameters = decoder.decode<WebKit::AuxiliaryProcessCreationParameters>();
    if (!auxiliaryProcessParameters && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(0);
        addedDecodingFailureIndex = true;
    }
#if ENABLE(MEDIA_STREAM)
    auto useMockCaptureDevices = decoder.decode<bool>();
    if (!useMockCaptureDevices && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(1);
        addedDecodingFailureIndex = true;
    }
#endif
#if (ENABLE(MEDIA_STREAM)) && (PLATFORM(MAC))
    auto microphoneSandboxExtensionHandle = decoder.decode<WebKit::SandboxExtensionHandle>();
    if (!microphoneSandboxExtensionHandle && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(2);
        addedDecodingFailureIndex = true;
    }
#endif
#if (ENABLE(MEDIA_STREAM)) && (PLATFORM(MAC))
    auto launchServicesExtensionHandle = decoder.decode<WebKit::SandboxExtensionHandle>();
    if (!launchServicesExtensionHandle && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(3);
        addedDecodingFailureIndex = true;
    }
#endif
#if USE(MODERN_AVCONTENTKEYSESSION)
    auto shouldUseModernAVContentKeySession = decoder.decode<bool>();
    if (!shouldUseModernAVContentKeySession && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(4);
        addedDecodingFailureIndex = true;
    }
#endif
#if USE(SANDBOX_EXTENSIONS_FOR_CACHE_AND_TEMP_DIRECTORY_ACCESS)
    auto containerCachesDirectoryExtensionHandle = decoder.decode<WebKit::SandboxExtensionHandle>();
    if (!containerCachesDirectoryExtensionHandle && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(5);
        addedDecodingFailureIndex = true;
    }
#endif
#if USE(SANDBOX_EXTENSIONS_FOR_CACHE_AND_TEMP_DIRECTORY_ACCESS)
    auto containerTemporaryDirectoryExtensionHandle = decoder.decode<WebKit::SandboxExtensionHandle>();
    if (!containerTemporaryDirectoryExtensionHandle && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(6);
        addedDecodingFailureIndex = true;
    }
#endif
#if USE(SANDBOX_EXTENSIONS_FOR_CACHE_AND_TEMP_DIRECTORY_ACCESS)
    auto containerCachesDirectory = decoder.decode<String>();
    if (!containerCachesDirectory && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(7);
        addedDecodingFailureIndex = true;
    }
#endif
    auto mobileGestaltExtensionHandle = decoder.decode<std::optional<WebKit::SandboxExtensionHandle>>();
    if (!mobileGestaltExtensionHandle && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(8);
        addedDecodingFailureIndex = true;
    }
#if PLATFORM(COCOA) && ENABLE(REMOTE_INSPECTOR)
    auto gpuToolsExtensionHandles = decoder.decode<Vector<WebKit::SandboxExtensionHandle>>();
    if (!gpuToolsExtensionHandles && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(9);
        addedDecodingFailureIndex = true;
    }
#endif
    auto applicationVisibleName = decoder.decode<String>();
    if (!applicationVisibleName && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(10);
        addedDecodingFailureIndex = true;
    }
#if USE(GBM)
    auto renderDeviceFile = decoder.decode<String>();
    if (!renderDeviceFile && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(11);
        addedDecodingFailureIndex = true;
    }
#endif
    auto overrideLanguages = decoder.decode<Vector<String>>();
    if (!overrideLanguages && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(12);
        addedDecodingFailureIndex = true;
    }
#if PLATFORM(COCOA)
    auto enableMetalDebugDeviceForTesting = decoder.decode<bool>();
    if (!enableMetalDebugDeviceForTesting && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(13);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(COCOA)
    auto enableMetalShaderValidationForTesting = decoder.decode<bool>();
    if (!enableMetalShaderValidationForTesting && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(14);
        addedDecodingFailureIndex = true;
    }
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::GPUProcessCreationParameters {
            WTFMove(*auxiliaryProcessParameters),
#if ENABLE(MEDIA_STREAM)
            WTFMove(*useMockCaptureDevices),
#endif
#if (ENABLE(MEDIA_STREAM)) && (PLATFORM(MAC))
            WTFMove(*microphoneSandboxExtensionHandle),
#endif
#if (ENABLE(MEDIA_STREAM)) && (PLATFORM(MAC))
            WTFMove(*launchServicesExtensionHandle),
#endif
#if USE(MODERN_AVCONTENTKEYSESSION)
            WTFMove(*shouldUseModernAVContentKeySession),
#endif
#if USE(SANDBOX_EXTENSIONS_FOR_CACHE_AND_TEMP_DIRECTORY_ACCESS)
            WTFMove(*containerCachesDirectoryExtensionHandle),
#endif
#if USE(SANDBOX_EXTENSIONS_FOR_CACHE_AND_TEMP_DIRECTORY_ACCESS)
            WTFMove(*containerTemporaryDirectoryExtensionHandle),
#endif
#if USE(SANDBOX_EXTENSIONS_FOR_CACHE_AND_TEMP_DIRECTORY_ACCESS)
            WTFMove(*containerCachesDirectory),
#endif
            WTFMove(*mobileGestaltExtensionHandle),
#if PLATFORM(COCOA) && ENABLE(REMOTE_INSPECTOR)
            WTFMove(*gpuToolsExtensionHandles),
#endif
            WTFMove(*applicationVisibleName),
#if USE(GBM)
            WTFMove(*renderDeviceFile),
#endif
            WTFMove(*overrideLanguages),
#if PLATFORM(COCOA)
            WTFMove(*enableMetalDebugDeviceForTesting),
#endif
#if PLATFORM(COCOA)
            WTFMove(*enableMetalShaderValidationForTesting)
#endif
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::GPUProcessPreferences>::encode(Encoder& encoder, const WebKit::GPUProcessPreferences& instance)
{
#if USE(MODERN_AVCONTENTKEYSESSION)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldUseModernAVContentKeySession)>, std::optional<bool>>);
#endif
#if ENABLE(VP9)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.vp9DecoderEnabled)>, std::optional<bool>>);
#endif
#if ENABLE(VP9)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.swVPDecodersAlwaysEnabled)>, bool>);
#endif
    struct ShouldBeSameSizeAsGPUProcessPreferences : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::GPUProcessPreferences>, false> {
#if USE(MODERN_AVCONTENTKEYSESSION)
        std::optional<bool> shouldUseModernAVContentKeySession;
#endif
#if ENABLE(VP9)
        std::optional<bool> vp9DecoderEnabled;
#endif
#if ENABLE(VP9)
        bool swVPDecodersAlwaysEnabled;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsGPUProcessPreferences) == sizeof(WebKit::GPUProcessPreferences));
    static_assert(MembersInCorrectOrder < 0
#if USE(MODERN_AVCONTENTKEYSESSION)
        , offsetof(WebKit::GPUProcessPreferences, shouldUseModernAVContentKeySession)
#endif
#if ENABLE(VP9)
        , offsetof(WebKit::GPUProcessPreferences, vp9DecoderEnabled)
#endif
#if ENABLE(VP9)
        , offsetof(WebKit::GPUProcessPreferences, swVPDecodersAlwaysEnabled)
#endif
    >::value);

#if USE(MODERN_AVCONTENTKEYSESSION)
    encoder << instance.shouldUseModernAVContentKeySession;
#endif
#if ENABLE(VP9)
    encoder << instance.vp9DecoderEnabled;
#endif
#if ENABLE(VP9)
    encoder << instance.swVPDecodersAlwaysEnabled;
#endif
}

std::optional<WebKit::GPUProcessPreferences> ArgumentCoder<WebKit::GPUProcessPreferences>::decode(Decoder& decoder)
{
#if USE(MODERN_AVCONTENTKEYSESSION)
    auto shouldUseModernAVContentKeySession = decoder.decode<std::optional<bool>>();
#endif
#if ENABLE(VP9)
    auto vp9DecoderEnabled = decoder.decode<std::optional<bool>>();
#endif
#if ENABLE(VP9)
    auto swVPDecodersAlwaysEnabled = decoder.decode<bool>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::GPUProcessPreferences {
#if USE(MODERN_AVCONTENTKEYSESSION)
            WTFMove(*shouldUseModernAVContentKeySession),
#endif
#if ENABLE(VP9)
            WTFMove(*vp9DecoderEnabled),
#endif
#if ENABLE(VP9)
            WTFMove(*swVPDecodersAlwaysEnabled)
#endif
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::GPUProcessSessionParameters>::encode(Encoder& encoder, WebKit::GPUProcessSessionParameters&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaCacheDirectory)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaCacheDirectorySandboxExtensionHandle)>, WebKit::SandboxExtensionHandle>);
#if ENABLE(LEGACY_ENCRYPTED_MEDIA) || ENABLE(ENCRYPTED_MEDIA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaKeysStorageDirectory)>, String>);
#endif
#if ENABLE(LEGACY_ENCRYPTED_MEDIA) || ENABLE(ENCRYPTED_MEDIA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaKeysStorageDirectorySandboxExtensionHandle)>, WebKit::SandboxExtensionHandle>);
#endif
    struct ShouldBeSameSizeAsGPUProcessSessionParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::GPUProcessSessionParameters>, false> {
        String mediaCacheDirectory;
        WebKit::SandboxExtensionHandle mediaCacheDirectorySandboxExtensionHandle;
#if ENABLE(LEGACY_ENCRYPTED_MEDIA) || ENABLE(ENCRYPTED_MEDIA)
        String mediaKeysStorageDirectory;
#endif
#if ENABLE(LEGACY_ENCRYPTED_MEDIA) || ENABLE(ENCRYPTED_MEDIA)
        WebKit::SandboxExtensionHandle mediaKeysStorageDirectorySandboxExtensionHandle;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsGPUProcessSessionParameters) == sizeof(WebKit::GPUProcessSessionParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::GPUProcessSessionParameters, mediaCacheDirectory)
        , offsetof(WebKit::GPUProcessSessionParameters, mediaCacheDirectorySandboxExtensionHandle)
#if ENABLE(LEGACY_ENCRYPTED_MEDIA) || ENABLE(ENCRYPTED_MEDIA)
        , offsetof(WebKit::GPUProcessSessionParameters, mediaKeysStorageDirectory)
#endif
#if ENABLE(LEGACY_ENCRYPTED_MEDIA) || ENABLE(ENCRYPTED_MEDIA)
        , offsetof(WebKit::GPUProcessSessionParameters, mediaKeysStorageDirectorySandboxExtensionHandle)
#endif
    >::value);

    encoder << WTFMove(instance.mediaCacheDirectory);
    encoder << WTFMove(instance.mediaCacheDirectorySandboxExtensionHandle);
#if ENABLE(LEGACY_ENCRYPTED_MEDIA) || ENABLE(ENCRYPTED_MEDIA)
    encoder << WTFMove(instance.mediaKeysStorageDirectory);
#endif
#if ENABLE(LEGACY_ENCRYPTED_MEDIA) || ENABLE(ENCRYPTED_MEDIA)
    encoder << WTFMove(instance.mediaKeysStorageDirectorySandboxExtensionHandle);
#endif
}

std::optional<WebKit::GPUProcessSessionParameters> ArgumentCoder<WebKit::GPUProcessSessionParameters>::decode(Decoder& decoder)
{
    auto mediaCacheDirectory = decoder.decode<String>();
    auto mediaCacheDirectorySandboxExtensionHandle = decoder.decode<WebKit::SandboxExtensionHandle>();
#if ENABLE(LEGACY_ENCRYPTED_MEDIA) || ENABLE(ENCRYPTED_MEDIA)
    auto mediaKeysStorageDirectory = decoder.decode<String>();
#endif
#if ENABLE(LEGACY_ENCRYPTED_MEDIA) || ENABLE(ENCRYPTED_MEDIA)
    auto mediaKeysStorageDirectorySandboxExtensionHandle = decoder.decode<WebKit::SandboxExtensionHandle>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::GPUProcessSessionParameters {
            WTFMove(*mediaCacheDirectory),
            WTFMove(*mediaCacheDirectorySandboxExtensionHandle),
#if ENABLE(LEGACY_ENCRYPTED_MEDIA) || ENABLE(ENCRYPTED_MEDIA)
            WTFMove(*mediaKeysStorageDirectory),
#endif
#if ENABLE(LEGACY_ENCRYPTED_MEDIA) || ENABLE(ENCRYPTED_MEDIA)
            WTFMove(*mediaKeysStorageDirectorySandboxExtensionHandle)
#endif
        }
    };
}

#endif

void ArgumentCoder<WebCore::PathMoveTo>::encode(Encoder& encoder, const WebCore::PathMoveTo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.point)>, WebCore::FloatPoint>);
    struct ShouldBeSameSizeAsPathMoveTo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathMoveTo>, false> {
        WebCore::FloatPoint point;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathMoveTo) == sizeof(WebCore::PathMoveTo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PathMoveTo, point)
    >::value);

    encoder << instance.point;
}

void ArgumentCoder<WebCore::PathMoveTo>::encode(StreamConnectionEncoder& encoder, const WebCore::PathMoveTo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.point)>, WebCore::FloatPoint>);
    struct ShouldBeSameSizeAsPathMoveTo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathMoveTo>, false> {
        WebCore::FloatPoint point;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathMoveTo) == sizeof(WebCore::PathMoveTo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PathMoveTo, point)
    >::value);

    encoder << instance.point;
}

std::optional<WebCore::PathMoveTo> ArgumentCoder<WebCore::PathMoveTo>::decode(Decoder& decoder)
{
    auto point = decoder.decode<WebCore::FloatPoint>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PathMoveTo {
            WTFMove(*point)
        }
    };
}

void ArgumentCoder<WebCore::PathLineTo>::encode(Encoder& encoder, const WebCore::PathLineTo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.point)>, WebCore::FloatPoint>);
    struct ShouldBeSameSizeAsPathLineTo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathLineTo>, false> {
        WebCore::FloatPoint point;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathLineTo) == sizeof(WebCore::PathLineTo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PathLineTo, point)
    >::value);

    encoder << instance.point;
}

void ArgumentCoder<WebCore::PathLineTo>::encode(StreamConnectionEncoder& encoder, const WebCore::PathLineTo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.point)>, WebCore::FloatPoint>);
    struct ShouldBeSameSizeAsPathLineTo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathLineTo>, false> {
        WebCore::FloatPoint point;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathLineTo) == sizeof(WebCore::PathLineTo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PathLineTo, point)
    >::value);

    encoder << instance.point;
}

std::optional<WebCore::PathLineTo> ArgumentCoder<WebCore::PathLineTo>::decode(Decoder& decoder)
{
    auto point = decoder.decode<WebCore::FloatPoint>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PathLineTo {
            WTFMove(*point)
        }
    };
}

void ArgumentCoder<WebCore::PathQuadCurveTo>::encode(Encoder& encoder, const WebCore::PathQuadCurveTo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlPoint)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.endPoint)>, WebCore::FloatPoint>);
    struct ShouldBeSameSizeAsPathQuadCurveTo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathQuadCurveTo>, false> {
        WebCore::FloatPoint controlPoint;
        WebCore::FloatPoint endPoint;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathQuadCurveTo) == sizeof(WebCore::PathQuadCurveTo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PathQuadCurveTo, controlPoint)
        , offsetof(WebCore::PathQuadCurveTo, endPoint)
    >::value);

    encoder << instance.controlPoint;
    encoder << instance.endPoint;
}

void ArgumentCoder<WebCore::PathQuadCurveTo>::encode(StreamConnectionEncoder& encoder, const WebCore::PathQuadCurveTo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlPoint)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.endPoint)>, WebCore::FloatPoint>);
    struct ShouldBeSameSizeAsPathQuadCurveTo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathQuadCurveTo>, false> {
        WebCore::FloatPoint controlPoint;
        WebCore::FloatPoint endPoint;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathQuadCurveTo) == sizeof(WebCore::PathQuadCurveTo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PathQuadCurveTo, controlPoint)
        , offsetof(WebCore::PathQuadCurveTo, endPoint)
    >::value);

    encoder << instance.controlPoint;
    encoder << instance.endPoint;
}

std::optional<WebCore::PathQuadCurveTo> ArgumentCoder<WebCore::PathQuadCurveTo>::decode(Decoder& decoder)
{
    auto controlPoint = decoder.decode<WebCore::FloatPoint>();
    auto endPoint = decoder.decode<WebCore::FloatPoint>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PathQuadCurveTo {
            WTFMove(*controlPoint),
            WTFMove(*endPoint)
        }
    };
}

void ArgumentCoder<WebCore::PathBezierCurveTo>::encode(Encoder& encoder, const WebCore::PathBezierCurveTo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlPoint1)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlPoint2)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.endPoint)>, WebCore::FloatPoint>);
    struct ShouldBeSameSizeAsPathBezierCurveTo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathBezierCurveTo>, false> {
        WebCore::FloatPoint controlPoint1;
        WebCore::FloatPoint controlPoint2;
        WebCore::FloatPoint endPoint;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathBezierCurveTo) == sizeof(WebCore::PathBezierCurveTo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PathBezierCurveTo, controlPoint1)
        , offsetof(WebCore::PathBezierCurveTo, controlPoint2)
        , offsetof(WebCore::PathBezierCurveTo, endPoint)
    >::value);

    encoder << instance.controlPoint1;
    encoder << instance.controlPoint2;
    encoder << instance.endPoint;
}

void ArgumentCoder<WebCore::PathBezierCurveTo>::encode(StreamConnectionEncoder& encoder, const WebCore::PathBezierCurveTo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlPoint1)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlPoint2)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.endPoint)>, WebCore::FloatPoint>);
    struct ShouldBeSameSizeAsPathBezierCurveTo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathBezierCurveTo>, false> {
        WebCore::FloatPoint controlPoint1;
        WebCore::FloatPoint controlPoint2;
        WebCore::FloatPoint endPoint;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathBezierCurveTo) == sizeof(WebCore::PathBezierCurveTo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PathBezierCurveTo, controlPoint1)
        , offsetof(WebCore::PathBezierCurveTo, controlPoint2)
        , offsetof(WebCore::PathBezierCurveTo, endPoint)
    >::value);

    encoder << instance.controlPoint1;
    encoder << instance.controlPoint2;
    encoder << instance.endPoint;
}

std::optional<WebCore::PathBezierCurveTo> ArgumentCoder<WebCore::PathBezierCurveTo>::decode(Decoder& decoder)
{
    auto controlPoint1 = decoder.decode<WebCore::FloatPoint>();
    auto controlPoint2 = decoder.decode<WebCore::FloatPoint>();
    auto endPoint = decoder.decode<WebCore::FloatPoint>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PathBezierCurveTo {
            WTFMove(*controlPoint1),
            WTFMove(*controlPoint2),
            WTFMove(*endPoint)
        }
    };
}

void ArgumentCoder<WebCore::PathArcTo>::encode(Encoder& encoder, const WebCore::PathArcTo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlPoint1)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlPoint2)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radius)>, float>);
    struct ShouldBeSameSizeAsPathArcTo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathArcTo>, false> {
        WebCore::FloatPoint controlPoint1;
        WebCore::FloatPoint controlPoint2;
        float radius;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathArcTo) == sizeof(WebCore::PathArcTo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PathArcTo, controlPoint1)
        , offsetof(WebCore::PathArcTo, controlPoint2)
        , offsetof(WebCore::PathArcTo, radius)
    >::value);

    encoder << instance.controlPoint1;
    encoder << instance.controlPoint2;
    encoder << instance.radius;
}

void ArgumentCoder<WebCore::PathArcTo>::encode(StreamConnectionEncoder& encoder, const WebCore::PathArcTo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlPoint1)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlPoint2)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radius)>, float>);
    struct ShouldBeSameSizeAsPathArcTo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathArcTo>, false> {
        WebCore::FloatPoint controlPoint1;
        WebCore::FloatPoint controlPoint2;
        float radius;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathArcTo) == sizeof(WebCore::PathArcTo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PathArcTo, controlPoint1)
        , offsetof(WebCore::PathArcTo, controlPoint2)
        , offsetof(WebCore::PathArcTo, radius)
    >::value);

    encoder << instance.controlPoint1;
    encoder << instance.controlPoint2;
    encoder << instance.radius;
}

std::optional<WebCore::PathArcTo> ArgumentCoder<WebCore::PathArcTo>::decode(Decoder& decoder)
{
    auto controlPoint1 = decoder.decode<WebCore::FloatPoint>();
    auto controlPoint2 = decoder.decode<WebCore::FloatPoint>();
    auto radius = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PathArcTo {
            WTFMove(*controlPoint1),
            WTFMove(*controlPoint2),
            WTFMove(*radius)
        }
    };
}

void ArgumentCoder<WebCore::PathArc>::encode(Encoder& encoder, const WebCore::PathArc& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.center)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radius)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.startAngle)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.endAngle)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.direction)>, WebCore::RotationDirection>);
    struct ShouldBeSameSizeAsPathArc : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathArc>, false> {
        WebCore::FloatPoint center;
        float radius;
        float startAngle;
        float endAngle;
        WebCore::RotationDirection direction;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathArc) == sizeof(WebCore::PathArc));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PathArc, center)
        , offsetof(WebCore::PathArc, radius)
        , offsetof(WebCore::PathArc, startAngle)
        , offsetof(WebCore::PathArc, endAngle)
        , offsetof(WebCore::PathArc, direction)
    >::value);

    encoder << instance.center;
    encoder << instance.radius;
    encoder << instance.startAngle;
    encoder << instance.endAngle;
    encoder << instance.direction;
}

void ArgumentCoder<WebCore::PathArc>::encode(StreamConnectionEncoder& encoder, const WebCore::PathArc& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.center)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radius)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.startAngle)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.endAngle)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.direction)>, WebCore::RotationDirection>);
    struct ShouldBeSameSizeAsPathArc : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathArc>, false> {
        WebCore::FloatPoint center;
        float radius;
        float startAngle;
        float endAngle;
        WebCore::RotationDirection direction;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathArc) == sizeof(WebCore::PathArc));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PathArc, center)
        , offsetof(WebCore::PathArc, radius)
        , offsetof(WebCore::PathArc, startAngle)
        , offsetof(WebCore::PathArc, endAngle)
        , offsetof(WebCore::PathArc, direction)
    >::value);

    encoder << instance.center;
    encoder << instance.radius;
    encoder << instance.startAngle;
    encoder << instance.endAngle;
    encoder << instance.direction;
}

std::optional<WebCore::PathArc> ArgumentCoder<WebCore::PathArc>::decode(Decoder& decoder)
{
    auto center = decoder.decode<WebCore::FloatPoint>();
    auto radius = decoder.decode<float>();
    auto startAngle = decoder.decode<float>();
    auto endAngle = decoder.decode<float>();
    auto direction = decoder.decode<WebCore::RotationDirection>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PathArc {
            WTFMove(*center),
            WTFMove(*radius),
            WTFMove(*startAngle),
            WTFMove(*endAngle),
            WTFMove(*direction)
        }
    };
}

void ArgumentCoder<WebCore::PathClosedArc>::encode(Encoder& encoder, const WebCore::PathClosedArc& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.arc)>, WebCore::PathArc>);
    struct ShouldBeSameSizeAsPathClosedArc : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathClosedArc>, false> {
        WebCore::PathArc arc;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathClosedArc) == sizeof(WebCore::PathClosedArc));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PathClosedArc, arc)
    >::value);

    encoder << instance.arc;
}

void ArgumentCoder<WebCore::PathClosedArc>::encode(StreamConnectionEncoder& encoder, const WebCore::PathClosedArc& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.arc)>, WebCore::PathArc>);
    struct ShouldBeSameSizeAsPathClosedArc : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathClosedArc>, false> {
        WebCore::PathArc arc;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathClosedArc) == sizeof(WebCore::PathClosedArc));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PathClosedArc, arc)
    >::value);

    encoder << instance.arc;
}

std::optional<WebCore::PathClosedArc> ArgumentCoder<WebCore::PathClosedArc>::decode(Decoder& decoder)
{
    auto arc = decoder.decode<WebCore::PathArc>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PathClosedArc {
            WTFMove(*arc)
        }
    };
}

void ArgumentCoder<WebCore::PathEllipse>::encode(Encoder& encoder, const WebCore::PathEllipse& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.center)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radiusX)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radiusY)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rotation)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.startAngle)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.endAngle)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.direction)>, WebCore::RotationDirection>);
    struct ShouldBeSameSizeAsPathEllipse : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathEllipse>, false> {
        WebCore::FloatPoint center;
        float radiusX;
        float radiusY;
        float rotation;
        float startAngle;
        float endAngle;
        WebCore::RotationDirection direction;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathEllipse) == sizeof(WebCore::PathEllipse));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PathEllipse, center)
        , offsetof(WebCore::PathEllipse, radiusX)
        , offsetof(WebCore::PathEllipse, radiusY)
        , offsetof(WebCore::PathEllipse, rotation)
        , offsetof(WebCore::PathEllipse, startAngle)
        , offsetof(WebCore::PathEllipse, endAngle)
        , offsetof(WebCore::PathEllipse, direction)
    >::value);

    encoder << instance.center;
    encoder << instance.radiusX;
    encoder << instance.radiusY;
    encoder << instance.rotation;
    encoder << instance.startAngle;
    encoder << instance.endAngle;
    encoder << instance.direction;
}

void ArgumentCoder<WebCore::PathEllipse>::encode(StreamConnectionEncoder& encoder, const WebCore::PathEllipse& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.center)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radiusX)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radiusY)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rotation)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.startAngle)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.endAngle)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.direction)>, WebCore::RotationDirection>);
    struct ShouldBeSameSizeAsPathEllipse : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathEllipse>, false> {
        WebCore::FloatPoint center;
        float radiusX;
        float radiusY;
        float rotation;
        float startAngle;
        float endAngle;
        WebCore::RotationDirection direction;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathEllipse) == sizeof(WebCore::PathEllipse));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PathEllipse, center)
        , offsetof(WebCore::PathEllipse, radiusX)
        , offsetof(WebCore::PathEllipse, radiusY)
        , offsetof(WebCore::PathEllipse, rotation)
        , offsetof(WebCore::PathEllipse, startAngle)
        , offsetof(WebCore::PathEllipse, endAngle)
        , offsetof(WebCore::PathEllipse, direction)
    >::value);

    encoder << instance.center;
    encoder << instance.radiusX;
    encoder << instance.radiusY;
    encoder << instance.rotation;
    encoder << instance.startAngle;
    encoder << instance.endAngle;
    encoder << instance.direction;
}

std::optional<WebCore::PathEllipse> ArgumentCoder<WebCore::PathEllipse>::decode(Decoder& decoder)
{
    auto center = decoder.decode<WebCore::FloatPoint>();
    auto radiusX = decoder.decode<float>();
    auto radiusY = decoder.decode<float>();
    auto rotation = decoder.decode<float>();
    auto startAngle = decoder.decode<float>();
    auto endAngle = decoder.decode<float>();
    auto direction = decoder.decode<WebCore::RotationDirection>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PathEllipse {
            WTFMove(*center),
            WTFMove(*radiusX),
            WTFMove(*radiusY),
            WTFMove(*rotation),
            WTFMove(*startAngle),
            WTFMove(*endAngle),
            WTFMove(*direction)
        }
    };
}

void ArgumentCoder<WebCore::PathEllipseInRect>::encode(Encoder& encoder, const WebCore::PathEllipseInRect& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rect)>, WebCore::FloatRect>);
    struct ShouldBeSameSizeAsPathEllipseInRect : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathEllipseInRect>, false> {
        WebCore::FloatRect rect;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathEllipseInRect) == sizeof(WebCore::PathEllipseInRect));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PathEllipseInRect, rect)
    >::value);

    encoder << instance.rect;
}

void ArgumentCoder<WebCore::PathEllipseInRect>::encode(StreamConnectionEncoder& encoder, const WebCore::PathEllipseInRect& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rect)>, WebCore::FloatRect>);
    struct ShouldBeSameSizeAsPathEllipseInRect : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathEllipseInRect>, false> {
        WebCore::FloatRect rect;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathEllipseInRect) == sizeof(WebCore::PathEllipseInRect));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PathEllipseInRect, rect)
    >::value);

    encoder << instance.rect;
}

std::optional<WebCore::PathEllipseInRect> ArgumentCoder<WebCore::PathEllipseInRect>::decode(Decoder& decoder)
{
    auto rect = decoder.decode<WebCore::FloatRect>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PathEllipseInRect {
            WTFMove(*rect)
        }
    };
}

void ArgumentCoder<WebCore::PathRect>::encode(Encoder& encoder, const WebCore::PathRect& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rect)>, WebCore::FloatRect>);
    struct ShouldBeSameSizeAsPathRect : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathRect>, false> {
        WebCore::FloatRect rect;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathRect) == sizeof(WebCore::PathRect));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PathRect, rect)
    >::value);

    encoder << instance.rect;
}

void ArgumentCoder<WebCore::PathRect>::encode(StreamConnectionEncoder& encoder, const WebCore::PathRect& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rect)>, WebCore::FloatRect>);
    struct ShouldBeSameSizeAsPathRect : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathRect>, false> {
        WebCore::FloatRect rect;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathRect) == sizeof(WebCore::PathRect));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PathRect, rect)
    >::value);

    encoder << instance.rect;
}

std::optional<WebCore::PathRect> ArgumentCoder<WebCore::PathRect>::decode(Decoder& decoder)
{
    auto rect = decoder.decode<WebCore::FloatRect>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PathRect {
            WTFMove(*rect)
        }
    };
}

void ArgumentCoder<WebCore::PathRoundedRect>::encode(Encoder& encoder, const WebCore::PathRoundedRect& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.roundedRect)>, WebCore::FloatRoundedRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.strategy)>, WebCore::PathRoundedRect::Strategy>);
    struct ShouldBeSameSizeAsPathRoundedRect : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathRoundedRect>, false> {
        WebCore::FloatRoundedRect roundedRect;
        WebCore::PathRoundedRect::Strategy strategy;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathRoundedRect) == sizeof(WebCore::PathRoundedRect));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PathRoundedRect, roundedRect)
        , offsetof(WebCore::PathRoundedRect, strategy)
    >::value);

    encoder << instance.roundedRect;
    encoder << instance.strategy;
}

void ArgumentCoder<WebCore::PathRoundedRect>::encode(StreamConnectionEncoder& encoder, const WebCore::PathRoundedRect& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.roundedRect)>, WebCore::FloatRoundedRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.strategy)>, WebCore::PathRoundedRect::Strategy>);
    struct ShouldBeSameSizeAsPathRoundedRect : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathRoundedRect>, false> {
        WebCore::FloatRoundedRect roundedRect;
        WebCore::PathRoundedRect::Strategy strategy;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathRoundedRect) == sizeof(WebCore::PathRoundedRect));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PathRoundedRect, roundedRect)
        , offsetof(WebCore::PathRoundedRect, strategy)
    >::value);

    encoder << instance.roundedRect;
    encoder << instance.strategy;
}

std::optional<WebCore::PathRoundedRect> ArgumentCoder<WebCore::PathRoundedRect>::decode(Decoder& decoder)
{
    auto roundedRect = decoder.decode<WebCore::FloatRoundedRect>();
    auto strategy = decoder.decode<WebCore::PathRoundedRect::Strategy>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PathRoundedRect {
            WTFMove(*roundedRect),
            WTFMove(*strategy)
        }
    };
}

void ArgumentCoder<WebCore::PathContinuousRoundedRect>::encode(Encoder& encoder, const WebCore::PathContinuousRoundedRect& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rect)>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cornerWidth)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cornerHeight)>, float>);
    struct ShouldBeSameSizeAsPathContinuousRoundedRect : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathContinuousRoundedRect>, false> {
        WebCore::FloatRect rect;
        float cornerWidth;
        float cornerHeight;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathContinuousRoundedRect) == sizeof(WebCore::PathContinuousRoundedRect));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PathContinuousRoundedRect, rect)
        , offsetof(WebCore::PathContinuousRoundedRect, cornerWidth)
        , offsetof(WebCore::PathContinuousRoundedRect, cornerHeight)
    >::value);

    encoder << instance.rect;
    encoder << instance.cornerWidth;
    encoder << instance.cornerHeight;
}

void ArgumentCoder<WebCore::PathContinuousRoundedRect>::encode(StreamConnectionEncoder& encoder, const WebCore::PathContinuousRoundedRect& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rect)>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cornerWidth)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cornerHeight)>, float>);
    struct ShouldBeSameSizeAsPathContinuousRoundedRect : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathContinuousRoundedRect>, false> {
        WebCore::FloatRect rect;
        float cornerWidth;
        float cornerHeight;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathContinuousRoundedRect) == sizeof(WebCore::PathContinuousRoundedRect));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PathContinuousRoundedRect, rect)
        , offsetof(WebCore::PathContinuousRoundedRect, cornerWidth)
        , offsetof(WebCore::PathContinuousRoundedRect, cornerHeight)
    >::value);

    encoder << instance.rect;
    encoder << instance.cornerWidth;
    encoder << instance.cornerHeight;
}

std::optional<WebCore::PathContinuousRoundedRect> ArgumentCoder<WebCore::PathContinuousRoundedRect>::decode(Decoder& decoder)
{
    auto rect = decoder.decode<WebCore::FloatRect>();
    auto cornerWidth = decoder.decode<float>();
    auto cornerHeight = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PathContinuousRoundedRect {
            WTFMove(*rect),
            WTFMove(*cornerWidth),
            WTFMove(*cornerHeight)
        }
    };
}

void ArgumentCoder<WebCore::PathDataLine>::encode(Encoder& encoder, const WebCore::PathDataLine& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.span())>, std::span<const float, 4>>);

    encoder << instance.span();
}

void ArgumentCoder<WebCore::PathDataLine>::encode(StreamConnectionEncoder& encoder, const WebCore::PathDataLine& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.span())>, std::span<const float, 4>>);

    encoder << instance.span();
}

std::optional<WebCore::PathDataLine> ArgumentCoder<WebCore::PathDataLine>::decode(Decoder& decoder)
{
    auto span = decoder.decode<std::span<const float, 4>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PathDataLine {
            WTFMove(*span)
        }
    };
}

void ArgumentCoder<WebCore::PathDataQuadCurve>::encode(Encoder& encoder, const WebCore::PathDataQuadCurve& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.start)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlPoint)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.endPoint)>, WebCore::FloatPoint>);
    struct ShouldBeSameSizeAsPathDataQuadCurve : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathDataQuadCurve>, false> {
        WebCore::FloatPoint start;
        WebCore::FloatPoint controlPoint;
        WebCore::FloatPoint endPoint;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathDataQuadCurve) == sizeof(WebCore::PathDataQuadCurve));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PathDataQuadCurve, start)
        , offsetof(WebCore::PathDataQuadCurve, controlPoint)
        , offsetof(WebCore::PathDataQuadCurve, endPoint)
    >::value);

    encoder << instance.start;
    encoder << instance.controlPoint;
    encoder << instance.endPoint;
}

void ArgumentCoder<WebCore::PathDataQuadCurve>::encode(StreamConnectionEncoder& encoder, const WebCore::PathDataQuadCurve& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.start)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlPoint)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.endPoint)>, WebCore::FloatPoint>);
    struct ShouldBeSameSizeAsPathDataQuadCurve : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathDataQuadCurve>, false> {
        WebCore::FloatPoint start;
        WebCore::FloatPoint controlPoint;
        WebCore::FloatPoint endPoint;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathDataQuadCurve) == sizeof(WebCore::PathDataQuadCurve));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PathDataQuadCurve, start)
        , offsetof(WebCore::PathDataQuadCurve, controlPoint)
        , offsetof(WebCore::PathDataQuadCurve, endPoint)
    >::value);

    encoder << instance.start;
    encoder << instance.controlPoint;
    encoder << instance.endPoint;
}

std::optional<WebCore::PathDataQuadCurve> ArgumentCoder<WebCore::PathDataQuadCurve>::decode(Decoder& decoder)
{
    auto start = decoder.decode<WebCore::FloatPoint>();
    auto controlPoint = decoder.decode<WebCore::FloatPoint>();
    auto endPoint = decoder.decode<WebCore::FloatPoint>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PathDataQuadCurve {
            WTFMove(*start),
            WTFMove(*controlPoint),
            WTFMove(*endPoint)
        }
    };
}

void ArgumentCoder<WebCore::PathDataBezierCurve>::encode(Encoder& encoder, const WebCore::PathDataBezierCurve& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.start)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlPoint1)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlPoint2)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.endPoint)>, WebCore::FloatPoint>);
    struct ShouldBeSameSizeAsPathDataBezierCurve : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathDataBezierCurve>, false> {
        WebCore::FloatPoint start;
        WebCore::FloatPoint controlPoint1;
        WebCore::FloatPoint controlPoint2;
        WebCore::FloatPoint endPoint;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathDataBezierCurve) == sizeof(WebCore::PathDataBezierCurve));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PathDataBezierCurve, start)
        , offsetof(WebCore::PathDataBezierCurve, controlPoint1)
        , offsetof(WebCore::PathDataBezierCurve, controlPoint2)
        , offsetof(WebCore::PathDataBezierCurve, endPoint)
    >::value);

    encoder << instance.start;
    encoder << instance.controlPoint1;
    encoder << instance.controlPoint2;
    encoder << instance.endPoint;
}

void ArgumentCoder<WebCore::PathDataBezierCurve>::encode(StreamConnectionEncoder& encoder, const WebCore::PathDataBezierCurve& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.start)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlPoint1)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlPoint2)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.endPoint)>, WebCore::FloatPoint>);
    struct ShouldBeSameSizeAsPathDataBezierCurve : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathDataBezierCurve>, false> {
        WebCore::FloatPoint start;
        WebCore::FloatPoint controlPoint1;
        WebCore::FloatPoint controlPoint2;
        WebCore::FloatPoint endPoint;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathDataBezierCurve) == sizeof(WebCore::PathDataBezierCurve));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PathDataBezierCurve, start)
        , offsetof(WebCore::PathDataBezierCurve, controlPoint1)
        , offsetof(WebCore::PathDataBezierCurve, controlPoint2)
        , offsetof(WebCore::PathDataBezierCurve, endPoint)
    >::value);

    encoder << instance.start;
    encoder << instance.controlPoint1;
    encoder << instance.controlPoint2;
    encoder << instance.endPoint;
}

std::optional<WebCore::PathDataBezierCurve> ArgumentCoder<WebCore::PathDataBezierCurve>::decode(Decoder& decoder)
{
    auto start = decoder.decode<WebCore::FloatPoint>();
    auto controlPoint1 = decoder.decode<WebCore::FloatPoint>();
    auto controlPoint2 = decoder.decode<WebCore::FloatPoint>();
    auto endPoint = decoder.decode<WebCore::FloatPoint>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PathDataBezierCurve {
            WTFMove(*start),
            WTFMove(*controlPoint1),
            WTFMove(*controlPoint2),
            WTFMove(*endPoint)
        }
    };
}

void ArgumentCoder<WebCore::PathDataArc>::encode(Encoder& encoder, const WebCore::PathDataArc& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.start)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlPoint1)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlPoint2)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radius)>, float>);
    struct ShouldBeSameSizeAsPathDataArc : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathDataArc>, false> {
        WebCore::FloatPoint start;
        WebCore::FloatPoint controlPoint1;
        WebCore::FloatPoint controlPoint2;
        float radius;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathDataArc) == sizeof(WebCore::PathDataArc));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PathDataArc, start)
        , offsetof(WebCore::PathDataArc, controlPoint1)
        , offsetof(WebCore::PathDataArc, controlPoint2)
        , offsetof(WebCore::PathDataArc, radius)
    >::value);

    encoder << instance.start;
    encoder << instance.controlPoint1;
    encoder << instance.controlPoint2;
    encoder << instance.radius;
}

void ArgumentCoder<WebCore::PathDataArc>::encode(StreamConnectionEncoder& encoder, const WebCore::PathDataArc& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.start)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlPoint1)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlPoint2)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radius)>, float>);
    struct ShouldBeSameSizeAsPathDataArc : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathDataArc>, false> {
        WebCore::FloatPoint start;
        WebCore::FloatPoint controlPoint1;
        WebCore::FloatPoint controlPoint2;
        float radius;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathDataArc) == sizeof(WebCore::PathDataArc));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PathDataArc, start)
        , offsetof(WebCore::PathDataArc, controlPoint1)
        , offsetof(WebCore::PathDataArc, controlPoint2)
        , offsetof(WebCore::PathDataArc, radius)
    >::value);

    encoder << instance.start;
    encoder << instance.controlPoint1;
    encoder << instance.controlPoint2;
    encoder << instance.radius;
}

std::optional<WebCore::PathDataArc> ArgumentCoder<WebCore::PathDataArc>::decode(Decoder& decoder)
{
    auto start = decoder.decode<WebCore::FloatPoint>();
    auto controlPoint1 = decoder.decode<WebCore::FloatPoint>();
    auto controlPoint2 = decoder.decode<WebCore::FloatPoint>();
    auto radius = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PathDataArc {
            WTFMove(*start),
            WTFMove(*controlPoint1),
            WTFMove(*controlPoint2),
            WTFMove(*radius)
        }
    };
}

void ArgumentCoder<WebCore::PathCloseSubpath>::encode(Encoder& encoder, const WebCore::PathCloseSubpath& instance)
{
    struct ShouldBeSameSizeAsPathCloseSubpath : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathCloseSubpath>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathCloseSubpath) == sizeof(WebCore::PathCloseSubpath));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

void ArgumentCoder<WebCore::PathCloseSubpath>::encode(StreamConnectionEncoder& encoder, const WebCore::PathCloseSubpath& instance)
{
    struct ShouldBeSameSizeAsPathCloseSubpath : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PathCloseSubpath>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathCloseSubpath) == sizeof(WebCore::PathCloseSubpath));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::PathCloseSubpath> ArgumentCoder<WebCore::PathCloseSubpath>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PathCloseSubpath {
        }
    };
}

void ArgumentCoder<WebCore::PathSegment>::encode(Encoder& encoder, const WebCore::PathSegment& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data())>, WebCore::PathSegment::Data>);

    encoder << instance.data();
}

void ArgumentCoder<WebCore::PathSegment>::encode(StreamConnectionEncoder& encoder, const WebCore::PathSegment& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data())>, WebCore::PathSegment::Data>);

    encoder << instance.data();
}

std::optional<WebCore::PathSegment> ArgumentCoder<WebCore::PathSegment>::decode(Decoder& decoder)
{
    auto data = decoder.decode<WebCore::PathSegment::Data>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PathSegment {
            WTFMove(*data)
        }
    };
}

#if ENABLE(GPU_PROCESS) && ENABLE(WEBGL)
void ArgumentCoder<WebKit::RemoteGraphicsContextGLInitializationState>::encode(Encoder& encoder, const WebKit::RemoteGraphicsContextGLInitializationState& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.availableExtensions)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requestableExtensions)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.externalImageTarget)>, GCGLenum>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.externalImageBindingQuery)>, GCGLenum>);
    struct ShouldBeSameSizeAsRemoteGraphicsContextGLInitializationState : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::RemoteGraphicsContextGLInitializationState>, false> {
        String availableExtensions;
        String requestableExtensions;
        GCGLenum externalImageTarget;
        GCGLenum externalImageBindingQuery;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRemoteGraphicsContextGLInitializationState) == sizeof(WebKit::RemoteGraphicsContextGLInitializationState));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::RemoteGraphicsContextGLInitializationState, availableExtensions)
        , offsetof(WebKit::RemoteGraphicsContextGLInitializationState, requestableExtensions)
        , offsetof(WebKit::RemoteGraphicsContextGLInitializationState, externalImageTarget)
        , offsetof(WebKit::RemoteGraphicsContextGLInitializationState, externalImageBindingQuery)
    >::value);

    encoder << instance.availableExtensions;
    encoder << instance.requestableExtensions;
    encoder << instance.externalImageTarget;
    encoder << instance.externalImageBindingQuery;
}

std::optional<WebKit::RemoteGraphicsContextGLInitializationState> ArgumentCoder<WebKit::RemoteGraphicsContextGLInitializationState>::decode(Decoder& decoder)
{
    auto availableExtensions = decoder.decode<String>();
    auto requestableExtensions = decoder.decode<String>();
    auto externalImageTarget = decoder.decode<GCGLenum>();
    auto externalImageBindingQuery = decoder.decode<GCGLenum>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::RemoteGraphicsContextGLInitializationState {
            WTFMove(*availableExtensions),
            WTFMove(*requestableExtensions),
            WTFMove(*externalImageTarget),
            WTFMove(*externalImageBindingQuery)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::RemoteGPURequestAdapterResponse>::encode(Encoder& encoder, const WebKit::RemoteGPURequestAdapterResponse& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.features)>, WebKit::WebGPU::SupportedFeatures>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.limits)>, WebKit::WebGPU::SupportedLimits>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isFallbackAdapter)>, bool>);
    struct ShouldBeSameSizeAsRemoteGPURequestAdapterResponse : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::RemoteGPURequestAdapterResponse>, false> {
        String name;
        WebKit::WebGPU::SupportedFeatures features;
        WebKit::WebGPU::SupportedLimits limits;
        bool isFallbackAdapter;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRemoteGPURequestAdapterResponse) == sizeof(WebKit::RemoteGPURequestAdapterResponse));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::RemoteGPURequestAdapterResponse, name)
        , offsetof(WebKit::RemoteGPURequestAdapterResponse, features)
        , offsetof(WebKit::RemoteGPURequestAdapterResponse, limits)
        , offsetof(WebKit::RemoteGPURequestAdapterResponse, isFallbackAdapter)
    >::value);

    encoder << instance.name;
    encoder << instance.features;
    encoder << instance.limits;
    encoder << instance.isFallbackAdapter;
}

void ArgumentCoder<WebKit::RemoteGPURequestAdapterResponse>::encode(StreamConnectionEncoder& encoder, const WebKit::RemoteGPURequestAdapterResponse& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.features)>, WebKit::WebGPU::SupportedFeatures>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.limits)>, WebKit::WebGPU::SupportedLimits>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isFallbackAdapter)>, bool>);
    struct ShouldBeSameSizeAsRemoteGPURequestAdapterResponse : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::RemoteGPURequestAdapterResponse>, false> {
        String name;
        WebKit::WebGPU::SupportedFeatures features;
        WebKit::WebGPU::SupportedLimits limits;
        bool isFallbackAdapter;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRemoteGPURequestAdapterResponse) == sizeof(WebKit::RemoteGPURequestAdapterResponse));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::RemoteGPURequestAdapterResponse, name)
        , offsetof(WebKit::RemoteGPURequestAdapterResponse, features)
        , offsetof(WebKit::RemoteGPURequestAdapterResponse, limits)
        , offsetof(WebKit::RemoteGPURequestAdapterResponse, isFallbackAdapter)
    >::value);

    encoder << instance.name;
    encoder << instance.features;
    encoder << instance.limits;
    encoder << instance.isFallbackAdapter;
}

std::optional<WebKit::RemoteGPURequestAdapterResponse> ArgumentCoder<WebKit::RemoteGPURequestAdapterResponse>::decode(Decoder& decoder)
{
    auto name = decoder.decode<String>();
    auto features = decoder.decode<WebKit::WebGPU::SupportedFeatures>();
    auto limits = decoder.decode<WebKit::WebGPU::SupportedLimits>();
    auto isFallbackAdapter = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::RemoteGPURequestAdapterResponse {
            WTFMove(*name),
            WTFMove(*features),
            WTFMove(*limits),
            WTFMove(*isFallbackAdapter)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS) && ENABLE(VIDEO)
void ArgumentCoder<WebKit::AudioTrackPrivateRemoteConfiguration>::encode(Encoder& encoder, const WebKit::AudioTrackPrivateRemoteConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.trackId)>, WebCore::TrackID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.language)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.startTimeVariance)>, MediaTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.trackIndex)>, int>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::TrackPrivateRemoteConfiguration, trackId)
        , offsetof(WebKit::TrackPrivateRemoteConfiguration, label)
        , offsetof(WebKit::TrackPrivateRemoteConfiguration, language)
        , offsetof(WebKit::TrackPrivateRemoteConfiguration, startTimeVariance)
        , offsetof(WebKit::TrackPrivateRemoteConfiguration, trackIndex)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.enabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.kind)>, WebCore::AudioTrackPrivate::Kind>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.trackConfiguration)>, WebCore::PlatformAudioTrackConfiguration>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::AudioTrackPrivateRemoteConfiguration, enabled)
        , offsetof(WebKit::AudioTrackPrivateRemoteConfiguration, kind)
        , offsetof(WebKit::AudioTrackPrivateRemoteConfiguration, trackConfiguration)
    >::value);

    encoder << instance.trackId;
    encoder << instance.label;
    encoder << instance.language;
    encoder << instance.startTimeVariance;
    encoder << instance.trackIndex;
    encoder << instance.enabled;
    encoder << instance.kind;
    encoder << instance.trackConfiguration;
}

std::optional<WebKit::AudioTrackPrivateRemoteConfiguration> ArgumentCoder<WebKit::AudioTrackPrivateRemoteConfiguration>::decode(Decoder& decoder)
{
    auto trackId = decoder.decode<WebCore::TrackID>();
    auto label = decoder.decode<String>();
    auto language = decoder.decode<String>();
    auto startTimeVariance = decoder.decode<MediaTime>();
    auto trackIndex = decoder.decode<int>();
    auto enabled = decoder.decode<bool>();
    auto kind = decoder.decode<WebCore::AudioTrackPrivate::Kind>();
    auto trackConfiguration = decoder.decode<WebCore::PlatformAudioTrackConfiguration>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::AudioTrackPrivateRemoteConfiguration {
            WebKit::TrackPrivateRemoteConfiguration {
                WTFMove(*trackId),
                WTFMove(*label),
                WTFMove(*language),
                WTFMove(*startTimeVariance),
                WTFMove(*trackIndex)
            },
            WTFMove(*enabled),
            WTFMove(*kind),
            WTFMove(*trackConfiguration)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS) && ENABLE(MEDIA_SOURCE)
void ArgumentCoder<WebKit::InitializationSegmentInfo>::encode(Encoder& encoder, const WebKit::InitializationSegmentInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.duration)>, MediaTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.audioTracks)>, Vector<WebKit::InitializationSegmentInfo::TrackInformation>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.videoTracks)>, Vector<WebKit::InitializationSegmentInfo::TrackInformation>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.textTracks)>, Vector<WebKit::InitializationSegmentInfo::TrackInformation>>);
    struct ShouldBeSameSizeAsInitializationSegmentInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::InitializationSegmentInfo>, false> {
        MediaTime duration;
        Vector<WebKit::InitializationSegmentInfo::TrackInformation> audioTracks;
        Vector<WebKit::InitializationSegmentInfo::TrackInformation> videoTracks;
        Vector<WebKit::InitializationSegmentInfo::TrackInformation> textTracks;
    };
    static_assert(sizeof(ShouldBeSameSizeAsInitializationSegmentInfo) == sizeof(WebKit::InitializationSegmentInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::InitializationSegmentInfo, duration)
        , offsetof(WebKit::InitializationSegmentInfo, audioTracks)
        , offsetof(WebKit::InitializationSegmentInfo, videoTracks)
        , offsetof(WebKit::InitializationSegmentInfo, textTracks)
    >::value);

    encoder << instance.duration;
    encoder << instance.audioTracks;
    encoder << instance.videoTracks;
    encoder << instance.textTracks;
}

std::optional<WebKit::InitializationSegmentInfo> ArgumentCoder<WebKit::InitializationSegmentInfo>::decode(Decoder& decoder)
{
    auto duration = decoder.decode<MediaTime>();
    auto audioTracks = decoder.decode<Vector<WebKit::InitializationSegmentInfo::TrackInformation>>();
    auto videoTracks = decoder.decode<Vector<WebKit::InitializationSegmentInfo::TrackInformation>>();
    auto textTracks = decoder.decode<Vector<WebKit::InitializationSegmentInfo::TrackInformation>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::InitializationSegmentInfo {
            WTFMove(*duration),
            WTFMove(*audioTracks),
            WTFMove(*videoTracks),
            WTFMove(*textTracks)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS) && ENABLE(MEDIA_SOURCE)
void ArgumentCoder<WebKit::InitializationSegmentInfo::TrackInformation>::encode(Encoder& encoder, const WebKit::InitializationSegmentInfo::TrackInformation& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.description)>, WebKit::MediaDescriptionInfo>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.id)>, WebCore::TrackID>);
    struct ShouldBeSameSizeAsTrackInformation : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::InitializationSegmentInfo::TrackInformation>, false> {
        WebKit::MediaDescriptionInfo description;
        WebCore::TrackID id;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTrackInformation) == sizeof(WebKit::InitializationSegmentInfo::TrackInformation));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::InitializationSegmentInfo::TrackInformation, description)
        , offsetof(WebKit::InitializationSegmentInfo::TrackInformation, id)
    >::value);

    encoder << instance.description;
    encoder << instance.id;
}

std::optional<WebKit::InitializationSegmentInfo::TrackInformation> ArgumentCoder<WebKit::InitializationSegmentInfo::TrackInformation>::decode(Decoder& decoder)
{
    auto description = decoder.decode<WebKit::MediaDescriptionInfo>();
    auto id = decoder.decode<WebCore::TrackID>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::InitializationSegmentInfo::TrackInformation {
            WTFMove(*description),
            WTFMove(*id)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS) && ENABLE(MEDIA_SOURCE)
void ArgumentCoder<WebKit::MediaDescriptionInfo>::encode(Encoder& encoder, const WebKit::MediaDescriptionInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_codec)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_isVideo)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_isAudio)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_isText)>, bool>);
    struct ShouldBeSameSizeAsMediaDescriptionInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::MediaDescriptionInfo>, false> {
        String m_codec;
        bool m_isVideo;
        bool m_isAudio;
        bool m_isText;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMediaDescriptionInfo) == sizeof(WebKit::MediaDescriptionInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::MediaDescriptionInfo, m_codec)
        , offsetof(WebKit::MediaDescriptionInfo, m_isVideo)
        , offsetof(WebKit::MediaDescriptionInfo, m_isAudio)
        , offsetof(WebKit::MediaDescriptionInfo, m_isText)
    >::value);

    encoder << instance.m_codec;
    encoder << instance.m_isVideo;
    encoder << instance.m_isAudio;
    encoder << instance.m_isText;
}

std::optional<WebKit::MediaDescriptionInfo> ArgumentCoder<WebKit::MediaDescriptionInfo>::decode(Decoder& decoder)
{
    auto m_codec = decoder.decode<String>();
    auto m_isVideo = decoder.decode<bool>();
    auto m_isAudio = decoder.decode<bool>();
    auto m_isText = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::MediaDescriptionInfo {
            WTFMove(*m_codec),
            WTFMove(*m_isVideo),
            WTFMove(*m_isAudio),
            WTFMove(*m_isText)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::RemoteMediaPlayerProxyConfiguration>::encode(Encoder& encoder, const WebKit::RemoteMediaPlayerProxyConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.referrer)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.userAgent)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceApplicationIdentifier)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.networkInterfaceName)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.audioOutputDeviceId)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaContentTypesRequiringHardwareSupport)>, Vector<WebCore::ContentType>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowedMediaContainerTypes)>, std::optional<Vector<String>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowedMediaCodecTypes)>, std::optional<Vector<String>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowedMediaVideoCodecIDs)>, std::optional<Vector<WebCore::FourCC>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowedMediaAudioCodecIDs)>, std::optional<Vector<WebCore::FourCC>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowedMediaCaptionFormatTypes)>, std::optional<Vector<WebCore::FourCC>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.playerContentBoxRect)>, WebCore::LayoutRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.preferredAudioCharacteristics)>, Vector<String>>);
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.outOfBandTrackData)>, Vector<WebCore::PlatformTextTrackData>>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.documentSecurityOrigin)>, WebCore::SecurityOriginData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.presentationSize)>, WebCore::IntSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.videoLayerSize)>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.logIdentifier)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldUsePersistentCache)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isVideo)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.renderingCanBeAccelerated)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldDisableHDR)>, bool>);
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.canShowWhileLocked)>, bool>);
#endif
#if HAVE(SPATIAL_AUDIO_EXPERIENCE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.prefersSpatialAudioExperience)>, bool>);
#endif
    struct ShouldBeSameSizeAsRemoteMediaPlayerProxyConfiguration : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::RemoteMediaPlayerProxyConfiguration>, false> {
        String referrer;
        String userAgent;
        String sourceApplicationIdentifier;
        String networkInterfaceName;
        String audioOutputDeviceId;
        Vector<WebCore::ContentType> mediaContentTypesRequiringHardwareSupport;
        std::optional<Vector<String>> allowedMediaContainerTypes;
        std::optional<Vector<String>> allowedMediaCodecTypes;
        std::optional<Vector<WebCore::FourCC>> allowedMediaVideoCodecIDs;
        std::optional<Vector<WebCore::FourCC>> allowedMediaAudioCodecIDs;
        std::optional<Vector<WebCore::FourCC>> allowedMediaCaptionFormatTypes;
        WebCore::LayoutRect playerContentBoxRect;
        Vector<String> preferredAudioCharacteristics;
#if PLATFORM(COCOA)
        Vector<WebCore::PlatformTextTrackData> outOfBandTrackData;
#endif
        WebCore::SecurityOriginData documentSecurityOrigin;
        WebCore::IntSize presentationSize;
        WebCore::FloatSize videoLayerSize;
        uint64_t logIdentifier;
        bool shouldUsePersistentCache;
        bool isVideo;
        bool renderingCanBeAccelerated;
        bool shouldDisableHDR;
#if PLATFORM(IOS_FAMILY)
        bool canShowWhileLocked;
#endif
#if HAVE(SPATIAL_AUDIO_EXPERIENCE)
        bool prefersSpatialAudioExperience;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsRemoteMediaPlayerProxyConfiguration) == sizeof(WebKit::RemoteMediaPlayerProxyConfiguration));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::RemoteMediaPlayerProxyConfiguration, referrer)
        , offsetof(WebKit::RemoteMediaPlayerProxyConfiguration, userAgent)
        , offsetof(WebKit::RemoteMediaPlayerProxyConfiguration, sourceApplicationIdentifier)
        , offsetof(WebKit::RemoteMediaPlayerProxyConfiguration, networkInterfaceName)
        , offsetof(WebKit::RemoteMediaPlayerProxyConfiguration, audioOutputDeviceId)
        , offsetof(WebKit::RemoteMediaPlayerProxyConfiguration, mediaContentTypesRequiringHardwareSupport)
        , offsetof(WebKit::RemoteMediaPlayerProxyConfiguration, allowedMediaContainerTypes)
        , offsetof(WebKit::RemoteMediaPlayerProxyConfiguration, allowedMediaCodecTypes)
        , offsetof(WebKit::RemoteMediaPlayerProxyConfiguration, allowedMediaVideoCodecIDs)
        , offsetof(WebKit::RemoteMediaPlayerProxyConfiguration, allowedMediaAudioCodecIDs)
        , offsetof(WebKit::RemoteMediaPlayerProxyConfiguration, allowedMediaCaptionFormatTypes)
        , offsetof(WebKit::RemoteMediaPlayerProxyConfiguration, playerContentBoxRect)
        , offsetof(WebKit::RemoteMediaPlayerProxyConfiguration, preferredAudioCharacteristics)
#if PLATFORM(COCOA)
        , offsetof(WebKit::RemoteMediaPlayerProxyConfiguration, outOfBandTrackData)
#endif
        , offsetof(WebKit::RemoteMediaPlayerProxyConfiguration, documentSecurityOrigin)
        , offsetof(WebKit::RemoteMediaPlayerProxyConfiguration, presentationSize)
        , offsetof(WebKit::RemoteMediaPlayerProxyConfiguration, videoLayerSize)
        , offsetof(WebKit::RemoteMediaPlayerProxyConfiguration, logIdentifier)
        , offsetof(WebKit::RemoteMediaPlayerProxyConfiguration, shouldUsePersistentCache)
        , offsetof(WebKit::RemoteMediaPlayerProxyConfiguration, isVideo)
        , offsetof(WebKit::RemoteMediaPlayerProxyConfiguration, renderingCanBeAccelerated)
        , offsetof(WebKit::RemoteMediaPlayerProxyConfiguration, shouldDisableHDR)
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::RemoteMediaPlayerProxyConfiguration, canShowWhileLocked)
#endif
#if HAVE(SPATIAL_AUDIO_EXPERIENCE)
        , offsetof(WebKit::RemoteMediaPlayerProxyConfiguration, prefersSpatialAudioExperience)
#endif
    >::value);

    encoder << instance.referrer;
    encoder << instance.userAgent;
    encoder << instance.sourceApplicationIdentifier;
    encoder << instance.networkInterfaceName;
    encoder << instance.audioOutputDeviceId;
    encoder << instance.mediaContentTypesRequiringHardwareSupport;
    encoder << instance.allowedMediaContainerTypes;
    encoder << instance.allowedMediaCodecTypes;
    encoder << instance.allowedMediaVideoCodecIDs;
    encoder << instance.allowedMediaAudioCodecIDs;
    encoder << instance.allowedMediaCaptionFormatTypes;
    encoder << instance.playerContentBoxRect;
    encoder << instance.preferredAudioCharacteristics;
#if PLATFORM(COCOA)
    encoder << instance.outOfBandTrackData;
#endif
    encoder << instance.documentSecurityOrigin;
    encoder << instance.presentationSize;
    encoder << instance.videoLayerSize;
    encoder << instance.logIdentifier;
    encoder << instance.shouldUsePersistentCache;
    encoder << instance.isVideo;
    encoder << instance.renderingCanBeAccelerated;
    encoder << instance.shouldDisableHDR;
#if PLATFORM(IOS_FAMILY)
    encoder << instance.canShowWhileLocked;
#endif
#if HAVE(SPATIAL_AUDIO_EXPERIENCE)
    encoder << instance.prefersSpatialAudioExperience;
#endif
}

std::optional<WebKit::RemoteMediaPlayerProxyConfiguration> ArgumentCoder<WebKit::RemoteMediaPlayerProxyConfiguration>::decode(Decoder& decoder)
{
    auto referrer = decoder.decode<String>();
    auto userAgent = decoder.decode<String>();
    auto sourceApplicationIdentifier = decoder.decode<String>();
    auto networkInterfaceName = decoder.decode<String>();
    auto audioOutputDeviceId = decoder.decode<String>();
    auto mediaContentTypesRequiringHardwareSupport = decoder.decode<Vector<WebCore::ContentType>>();
    auto allowedMediaContainerTypes = decoder.decode<std::optional<Vector<String>>>();
    auto allowedMediaCodecTypes = decoder.decode<std::optional<Vector<String>>>();
    auto allowedMediaVideoCodecIDs = decoder.decode<std::optional<Vector<WebCore::FourCC>>>();
    auto allowedMediaAudioCodecIDs = decoder.decode<std::optional<Vector<WebCore::FourCC>>>();
    auto allowedMediaCaptionFormatTypes = decoder.decode<std::optional<Vector<WebCore::FourCC>>>();
    auto playerContentBoxRect = decoder.decode<WebCore::LayoutRect>();
    auto preferredAudioCharacteristics = decoder.decode<Vector<String>>();
#if PLATFORM(COCOA)
    auto outOfBandTrackData = decoder.decode<Vector<WebCore::PlatformTextTrackData>>();
#endif
    auto documentSecurityOrigin = decoder.decode<WebCore::SecurityOriginData>();
    auto presentationSize = decoder.decode<WebCore::IntSize>();
    auto videoLayerSize = decoder.decode<WebCore::FloatSize>();
    auto logIdentifier = decoder.decode<uint64_t>();
    auto shouldUsePersistentCache = decoder.decode<bool>();
    auto isVideo = decoder.decode<bool>();
    auto renderingCanBeAccelerated = decoder.decode<bool>();
    auto shouldDisableHDR = decoder.decode<bool>();
#if PLATFORM(IOS_FAMILY)
    auto canShowWhileLocked = decoder.decode<bool>();
#endif
#if HAVE(SPATIAL_AUDIO_EXPERIENCE)
    auto prefersSpatialAudioExperience = decoder.decode<bool>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::RemoteMediaPlayerProxyConfiguration {
            WTFMove(*referrer),
            WTFMove(*userAgent),
            WTFMove(*sourceApplicationIdentifier),
            WTFMove(*networkInterfaceName),
            WTFMove(*audioOutputDeviceId),
            WTFMove(*mediaContentTypesRequiringHardwareSupport),
            WTFMove(*allowedMediaContainerTypes),
            WTFMove(*allowedMediaCodecTypes),
            WTFMove(*allowedMediaVideoCodecIDs),
            WTFMove(*allowedMediaAudioCodecIDs),
            WTFMove(*allowedMediaCaptionFormatTypes),
            WTFMove(*playerContentBoxRect),
            WTFMove(*preferredAudioCharacteristics),
#if PLATFORM(COCOA)
            WTFMove(*outOfBandTrackData),
#endif
            WTFMove(*documentSecurityOrigin),
            WTFMove(*presentationSize),
            WTFMove(*videoLayerSize),
            WTFMove(*logIdentifier),
            WTFMove(*shouldUsePersistentCache),
            WTFMove(*isVideo),
            WTFMove(*renderingCanBeAccelerated),
            WTFMove(*shouldDisableHDR),
#if PLATFORM(IOS_FAMILY)
            WTFMove(*canShowWhileLocked),
#endif
#if HAVE(SPATIAL_AUDIO_EXPERIENCE)
            WTFMove(*prefersSpatialAudioExperience)
#endif
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS) && ENABLE(VIDEO)
void ArgumentCoder<WebKit::RemoteAudioInfo>::encode(Encoder& encoder, const WebKit::RemoteAudioInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.codecName)>, WebCore::FourCC>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.codecString)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.trackID)>, WebCore::TrackID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rate)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.channels)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.framesPerPacket)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bitDepth)>, uint8_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cookieData)>, RefPtr<WebCore::SharedBuffer>>);
    struct ShouldBeSameSizeAsRemoteAudioInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::RemoteAudioInfo>, false> {
        WebCore::FourCC codecName;
        String codecString;
        WebCore::TrackID trackID;
        uint32_t rate;
        uint32_t channels;
        uint32_t framesPerPacket;
        uint8_t bitDepth;
        RefPtr<WebCore::SharedBuffer> cookieData;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRemoteAudioInfo) == sizeof(WebKit::RemoteAudioInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::RemoteAudioInfo, codecName)
        , offsetof(WebKit::RemoteAudioInfo, codecString)
        , offsetof(WebKit::RemoteAudioInfo, trackID)
        , offsetof(WebKit::RemoteAudioInfo, rate)
        , offsetof(WebKit::RemoteAudioInfo, channels)
        , offsetof(WebKit::RemoteAudioInfo, framesPerPacket)
        , offsetof(WebKit::RemoteAudioInfo, bitDepth)
        , offsetof(WebKit::RemoteAudioInfo, cookieData)
    >::value);

    encoder << instance.codecName;
    encoder << instance.codecString;
    encoder << instance.trackID;
    encoder << instance.rate;
    encoder << instance.channels;
    encoder << instance.framesPerPacket;
    encoder << instance.bitDepth;
    encoder << instance.cookieData;
}

std::optional<WebKit::RemoteAudioInfo> ArgumentCoder<WebKit::RemoteAudioInfo>::decode(Decoder& decoder)
{
    auto codecName = decoder.decode<WebCore::FourCC>();
    auto codecString = decoder.decode<String>();
    auto trackID = decoder.decode<WebCore::TrackID>();
    auto rate = decoder.decode<uint32_t>();
    auto channels = decoder.decode<uint32_t>();
    auto framesPerPacket = decoder.decode<uint32_t>();
    auto bitDepth = decoder.decode<uint8_t>();
    auto cookieData = decoder.decode<RefPtr<WebCore::SharedBuffer>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::RemoteAudioInfo {
            WTFMove(*codecName),
            WTFMove(*codecString),
            WTFMove(*trackID),
            WTFMove(*rate),
            WTFMove(*channels),
            WTFMove(*framesPerPacket),
            WTFMove(*bitDepth),
            WTFMove(*cookieData)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS) && ENABLE(VIDEO)
void ArgumentCoder<WebKit::RemoteVideoInfo>::encode(Encoder& encoder, const WebKit::RemoteVideoInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.codecName)>, WebCore::FourCC>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.codecString)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.trackID)>, WebCore::TrackID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size)>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.displaySize)>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bitDepth)>, uint8_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorSpace)>, WebCore::PlatformVideoColorSpace>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.atomData)>, RefPtr<WebCore::SharedBuffer>>);
    struct ShouldBeSameSizeAsRemoteVideoInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::RemoteVideoInfo>, false> {
        WebCore::FourCC codecName;
        String codecString;
        WebCore::TrackID trackID;
        WebCore::FloatSize size;
        WebCore::FloatSize displaySize;
        uint8_t bitDepth;
        WebCore::PlatformVideoColorSpace colorSpace;
        RefPtr<WebCore::SharedBuffer> atomData;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRemoteVideoInfo) == sizeof(WebKit::RemoteVideoInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::RemoteVideoInfo, codecName)
        , offsetof(WebKit::RemoteVideoInfo, codecString)
        , offsetof(WebKit::RemoteVideoInfo, trackID)
        , offsetof(WebKit::RemoteVideoInfo, size)
        , offsetof(WebKit::RemoteVideoInfo, displaySize)
        , offsetof(WebKit::RemoteVideoInfo, bitDepth)
        , offsetof(WebKit::RemoteVideoInfo, colorSpace)
        , offsetof(WebKit::RemoteVideoInfo, atomData)
    >::value);

    encoder << instance.codecName;
    encoder << instance.codecString;
    encoder << instance.trackID;
    encoder << instance.size;
    encoder << instance.displaySize;
    encoder << instance.bitDepth;
    encoder << instance.colorSpace;
    encoder << instance.atomData;
}

std::optional<WebKit::RemoteVideoInfo> ArgumentCoder<WebKit::RemoteVideoInfo>::decode(Decoder& decoder)
{
    auto codecName = decoder.decode<WebCore::FourCC>();
    auto codecString = decoder.decode<String>();
    auto trackID = decoder.decode<WebCore::TrackID>();
    auto size = decoder.decode<WebCore::FloatSize>();
    auto displaySize = decoder.decode<WebCore::FloatSize>();
    auto bitDepth = decoder.decode<uint8_t>();
    auto colorSpace = decoder.decode<WebCore::PlatformVideoColorSpace>();
    auto atomData = decoder.decode<RefPtr<WebCore::SharedBuffer>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::RemoteVideoInfo {
            WTFMove(*codecName),
            WTFMove(*codecString),
            WTFMove(*trackID),
            WTFMove(*size),
            WTFMove(*displaySize),
            WTFMove(*bitDepth),
            WTFMove(*colorSpace),
            WTFMove(*atomData)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS) && ENABLE(VIDEO)
void ArgumentCoder<WebKit::TextTrackPrivateRemoteConfiguration>::encode(Encoder& encoder, const WebKit::TextTrackPrivateRemoteConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.trackId)>, WebCore::TrackID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.language)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.inBandMetadataTrackDispatchType)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.startTimeVariance)>, MediaTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.trackIndex)>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cueFormat)>, WebCore::InbandTextTrackPrivate::CueFormat>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.kind)>, WebCore::InbandTextTrackPrivate::Kind>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isClosedCaptions)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isSDH)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.containsOnlyForcedSubtitles)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isMainProgramContent)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isEasyToRead)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isDefault)>, bool>);
    struct ShouldBeSameSizeAsTextTrackPrivateRemoteConfiguration : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::TextTrackPrivateRemoteConfiguration>, false> {
        WebCore::TrackID trackId;
        String label;
        String language;
        String inBandMetadataTrackDispatchType;
        MediaTime startTimeVariance;
        int trackIndex;
        WebCore::InbandTextTrackPrivate::CueFormat cueFormat;
        WebCore::InbandTextTrackPrivate::Kind kind;
        bool isClosedCaptions;
        bool isSDH;
        bool containsOnlyForcedSubtitles;
        bool isMainProgramContent;
        bool isEasyToRead;
        bool isDefault;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTextTrackPrivateRemoteConfiguration) == sizeof(WebKit::TextTrackPrivateRemoteConfiguration));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::TextTrackPrivateRemoteConfiguration, trackId)
        , offsetof(WebKit::TextTrackPrivateRemoteConfiguration, label)
        , offsetof(WebKit::TextTrackPrivateRemoteConfiguration, language)
        , offsetof(WebKit::TextTrackPrivateRemoteConfiguration, inBandMetadataTrackDispatchType)
        , offsetof(WebKit::TextTrackPrivateRemoteConfiguration, startTimeVariance)
        , offsetof(WebKit::TextTrackPrivateRemoteConfiguration, trackIndex)
        , offsetof(WebKit::TextTrackPrivateRemoteConfiguration, cueFormat)
        , offsetof(WebKit::TextTrackPrivateRemoteConfiguration, kind)
        , offsetof(WebKit::TextTrackPrivateRemoteConfiguration, isClosedCaptions)
        , offsetof(WebKit::TextTrackPrivateRemoteConfiguration, isSDH)
        , offsetof(WebKit::TextTrackPrivateRemoteConfiguration, containsOnlyForcedSubtitles)
        , offsetof(WebKit::TextTrackPrivateRemoteConfiguration, isMainProgramContent)
        , offsetof(WebKit::TextTrackPrivateRemoteConfiguration, isEasyToRead)
        , offsetof(WebKit::TextTrackPrivateRemoteConfiguration, isDefault)
    >::value);

    encoder << instance.trackId;
    encoder << instance.label;
    encoder << instance.language;
    encoder << instance.inBandMetadataTrackDispatchType;
    encoder << instance.startTimeVariance;
    encoder << instance.trackIndex;
    encoder << instance.cueFormat;
    encoder << instance.kind;
    encoder << instance.isClosedCaptions;
    encoder << instance.isSDH;
    encoder << instance.containsOnlyForcedSubtitles;
    encoder << instance.isMainProgramContent;
    encoder << instance.isEasyToRead;
    encoder << instance.isDefault;
}

std::optional<WebKit::TextTrackPrivateRemoteConfiguration> ArgumentCoder<WebKit::TextTrackPrivateRemoteConfiguration>::decode(Decoder& decoder)
{
    auto trackId = decoder.decode<WebCore::TrackID>();
    auto label = decoder.decode<String>();
    auto language = decoder.decode<String>();
    auto inBandMetadataTrackDispatchType = decoder.decode<String>();
    auto startTimeVariance = decoder.decode<MediaTime>();
    auto trackIndex = decoder.decode<int>();
    auto cueFormat = decoder.decode<WebCore::InbandTextTrackPrivate::CueFormat>();
    auto kind = decoder.decode<WebCore::InbandTextTrackPrivate::Kind>();
    auto isClosedCaptions = decoder.decode<bool>();
    auto isSDH = decoder.decode<bool>();
    auto containsOnlyForcedSubtitles = decoder.decode<bool>();
    auto isMainProgramContent = decoder.decode<bool>();
    auto isEasyToRead = decoder.decode<bool>();
    auto isDefault = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::TextTrackPrivateRemoteConfiguration {
            WTFMove(*trackId),
            WTFMove(*label),
            WTFMove(*language),
            WTFMove(*inBandMetadataTrackDispatchType),
            WTFMove(*startTimeVariance),
            WTFMove(*trackIndex),
            WTFMove(*cueFormat),
            WTFMove(*kind),
            WTFMove(*isClosedCaptions),
            WTFMove(*isSDH),
            WTFMove(*containsOnlyForcedSubtitles),
            WTFMove(*isMainProgramContent),
            WTFMove(*isEasyToRead),
            WTFMove(*isDefault)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS) && ENABLE(VIDEO)
void ArgumentCoder<WebKit::TrackPrivateRemoteConfiguration>::encode(Encoder& encoder, const WebKit::TrackPrivateRemoteConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.trackId)>, WebCore::TrackID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.language)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.startTimeVariance)>, MediaTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.trackIndex)>, int>);
    struct ShouldBeSameSizeAsTrackPrivateRemoteConfiguration : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::TrackPrivateRemoteConfiguration>, false> {
        WebCore::TrackID trackId;
        String label;
        String language;
        MediaTime startTimeVariance;
        int trackIndex;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTrackPrivateRemoteConfiguration) == sizeof(WebKit::TrackPrivateRemoteConfiguration));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::TrackPrivateRemoteConfiguration, trackId)
        , offsetof(WebKit::TrackPrivateRemoteConfiguration, label)
        , offsetof(WebKit::TrackPrivateRemoteConfiguration, language)
        , offsetof(WebKit::TrackPrivateRemoteConfiguration, startTimeVariance)
        , offsetof(WebKit::TrackPrivateRemoteConfiguration, trackIndex)
    >::value);

    encoder << instance.trackId;
    encoder << instance.label;
    encoder << instance.language;
    encoder << instance.startTimeVariance;
    encoder << instance.trackIndex;
}

std::optional<WebKit::TrackPrivateRemoteConfiguration> ArgumentCoder<WebKit::TrackPrivateRemoteConfiguration>::decode(Decoder& decoder)
{
    auto trackId = decoder.decode<WebCore::TrackID>();
    auto label = decoder.decode<String>();
    auto language = decoder.decode<String>();
    auto startTimeVariance = decoder.decode<MediaTime>();
    auto trackIndex = decoder.decode<int>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::TrackPrivateRemoteConfiguration {
            WTFMove(*trackId),
            WTFMove(*label),
            WTFMove(*language),
            WTFMove(*startTimeVariance),
            WTFMove(*trackIndex)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS) && ENABLE(VIDEO)
void ArgumentCoder<WebKit::VideoTrackPrivateRemoteConfiguration>::encode(Encoder& encoder, const WebKit::VideoTrackPrivateRemoteConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.trackId)>, WebCore::TrackID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.language)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.startTimeVariance)>, MediaTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.trackIndex)>, int>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::TrackPrivateRemoteConfiguration, trackId)
        , offsetof(WebKit::TrackPrivateRemoteConfiguration, label)
        , offsetof(WebKit::TrackPrivateRemoteConfiguration, language)
        , offsetof(WebKit::TrackPrivateRemoteConfiguration, startTimeVariance)
        , offsetof(WebKit::TrackPrivateRemoteConfiguration, trackIndex)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selected)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.kind)>, WebCore::VideoTrackPrivate::Kind>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.trackConfiguration)>, WebCore::PlatformVideoTrackConfiguration>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::VideoTrackPrivateRemoteConfiguration, selected)
        , offsetof(WebKit::VideoTrackPrivateRemoteConfiguration, kind)
        , offsetof(WebKit::VideoTrackPrivateRemoteConfiguration, trackConfiguration)
    >::value);

    encoder << instance.trackId;
    encoder << instance.label;
    encoder << instance.language;
    encoder << instance.startTimeVariance;
    encoder << instance.trackIndex;
    encoder << instance.selected;
    encoder << instance.kind;
    encoder << instance.trackConfiguration;
}

std::optional<WebKit::VideoTrackPrivateRemoteConfiguration> ArgumentCoder<WebKit::VideoTrackPrivateRemoteConfiguration>::decode(Decoder& decoder)
{
    auto trackId = decoder.decode<WebCore::TrackID>();
    auto label = decoder.decode<String>();
    auto language = decoder.decode<String>();
    auto startTimeVariance = decoder.decode<MediaTime>();
    auto trackIndex = decoder.decode<int>();
    auto selected = decoder.decode<bool>();
    auto kind = decoder.decode<WebCore::VideoTrackPrivate::Kind>();
    auto trackConfiguration = decoder.decode<WebCore::PlatformVideoTrackConfiguration>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::VideoTrackPrivateRemoteConfiguration {
            WebKit::TrackPrivateRemoteConfiguration {
                WTFMove(*trackId),
                WTFMove(*label),
                WTFMove(*language),
                WTFMove(*startTimeVariance),
                WTFMove(*trackIndex)
            },
            WTFMove(*selected),
            WTFMove(*kind),
            WTFMove(*trackConfiguration)
        }
    };
}

#endif

#if ENABLE(MODEL_PROCESS)
void ArgumentCoder<WebKit::ModelProcessCreationParameters>::encode(Encoder& encoder, WebKit::ModelProcessCreationParameters&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.auxiliaryProcessParameters)>, WebKit::AuxiliaryProcessCreationParameters>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.parentPID)>, ProcessID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.applicationVisibleName)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.restrictiveRenderingMode)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.debugEntityMemoryLimit)>, std::optional<int>>);
    struct ShouldBeSameSizeAsModelProcessCreationParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::ModelProcessCreationParameters>, false> {
        WebKit::AuxiliaryProcessCreationParameters auxiliaryProcessParameters;
        ProcessID parentPID;
        String applicationVisibleName;
        bool restrictiveRenderingMode;
        std::optional<int> debugEntityMemoryLimit;
    };
    static_assert(sizeof(ShouldBeSameSizeAsModelProcessCreationParameters) == sizeof(WebKit::ModelProcessCreationParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::ModelProcessCreationParameters, auxiliaryProcessParameters)
        , offsetof(WebKit::ModelProcessCreationParameters, parentPID)
        , offsetof(WebKit::ModelProcessCreationParameters, applicationVisibleName)
        , offsetof(WebKit::ModelProcessCreationParameters, restrictiveRenderingMode)
        , offsetof(WebKit::ModelProcessCreationParameters, debugEntityMemoryLimit)
    >::value);

    encoder << WTFMove(instance.auxiliaryProcessParameters);
    encoder << WTFMove(instance.parentPID);
    encoder << WTFMove(instance.applicationVisibleName);
    encoder << WTFMove(instance.restrictiveRenderingMode);
    encoder << WTFMove(instance.debugEntityMemoryLimit);
}

std::optional<WebKit::ModelProcessCreationParameters> ArgumentCoder<WebKit::ModelProcessCreationParameters>::decode(Decoder& decoder)
{
    auto auxiliaryProcessParameters = decoder.decode<WebKit::AuxiliaryProcessCreationParameters>();
    auto parentPID = decoder.decode<ProcessID>();
    auto applicationVisibleName = decoder.decode<String>();
    auto restrictiveRenderingMode = decoder.decode<bool>();
    auto debugEntityMemoryLimit = decoder.decode<std::optional<int>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::ModelProcessCreationParameters {
            WTFMove(*auxiliaryProcessParameters),
            WTFMove(*parentPID),
            WTFMove(*applicationVisibleName),
            WTFMove(*restrictiveRenderingMode),
            WTFMove(*debugEntityMemoryLimit)
        }
    };
}

#endif

void ArgumentCoder<WebKit::NetworkProcessCreationParameters>::encode(Encoder& encoder, WebKit::NetworkProcessCreationParameters&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.auxiliaryProcessParameters)>, WebKit::AuxiliaryProcessCreationParameters>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cacheModel)>, WebKit::CacheModel>);
#if PLATFORM(MAC) || PLATFORM(MACCATALYST)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.uiProcessCookieStorageIdentifier)>, Vector<uint8_t>>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldSuppressMemoryPressureHandler)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.urlSchemesRegisteredForCustomProtocols)>, Vector<String>>);
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.uiProcessBundleIdentifier)>, String>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.networkATSContext)>, RetainPtr<CFDataRef>>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isParentProcessFullWebBrowserOrRunningTest)>, bool>);
#endif
#if USE(SOUP)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cookieAcceptPolicy)>, WebCore::HTTPCookieAcceptPolicy>);
#endif
#if USE(SOUP)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.languages)>, Vector<String>>);
#endif
#if USE(SOUP)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.memoryPressureHandlerConfiguration)>, std::optional<MemoryPressureHandler::Configuration>>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.urlSchemesRegisteredAsSecure)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.urlSchemesRegisteredAsBypassingContentSecurityPolicy)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.urlSchemesRegisteredAsLocal)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.urlSchemesRegisteredAsNoAccess)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.enablePrivateClickMeasurement)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ftpEnabled)>, bool>);
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.enableModernDownloadProgress)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.websiteDataStoreParameters)>, Vector<WebKit::WebsiteDataStoreParameters>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowedFirstPartiesForCookies)>, Vector<std::pair<WebCore::ProcessIdentifier, WebCore::RegistrableDomain>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.localhostAliasesForTesting)>, HashSet<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.storageAccessPromptQuirksData)>, Vector<WebCore::OrganizationStorageAccessPromptQuirk>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.defaultRequestTimeoutInterval)>, Markable<double>>);
    struct ShouldBeSameSizeAsNetworkProcessCreationParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::NetworkProcessCreationParameters>, false> {
        WebKit::AuxiliaryProcessCreationParameters auxiliaryProcessParameters;
        WebKit::CacheModel cacheModel;
#if PLATFORM(MAC) || PLATFORM(MACCATALYST)
        Vector<uint8_t> uiProcessCookieStorageIdentifier;
#endif
        bool shouldSuppressMemoryPressureHandler;
        Vector<String> urlSchemesRegisteredForCustomProtocols;
#if PLATFORM(COCOA)
        String uiProcessBundleIdentifier;
#endif
#if PLATFORM(COCOA)
        RetainPtr<CFDataRef> networkATSContext;
#endif
#if PLATFORM(COCOA)
        bool isParentProcessFullWebBrowserOrRunningTest;
#endif
#if USE(SOUP)
        WebCore::HTTPCookieAcceptPolicy cookieAcceptPolicy;
#endif
#if USE(SOUP)
        Vector<String> languages;
#endif
#if USE(SOUP)
        std::optional<MemoryPressureHandler::Configuration> memoryPressureHandlerConfiguration;
#endif
        Vector<String> urlSchemesRegisteredAsSecure;
        Vector<String> urlSchemesRegisteredAsBypassingContentSecurityPolicy;
        Vector<String> urlSchemesRegisteredAsLocal;
        Vector<String> urlSchemesRegisteredAsNoAccess;
        bool enablePrivateClickMeasurement;
        bool ftpEnabled;
#if PLATFORM(COCOA)
        bool enableModernDownloadProgress;
#endif
        Vector<WebKit::WebsiteDataStoreParameters> websiteDataStoreParameters;
        Vector<std::pair<WebCore::ProcessIdentifier, WebCore::RegistrableDomain>> allowedFirstPartiesForCookies;
        HashSet<String> localhostAliasesForTesting;
        Vector<WebCore::OrganizationStorageAccessPromptQuirk> storageAccessPromptQuirksData;
        Markable<double> defaultRequestTimeoutInterval;
    };
    static_assert(sizeof(ShouldBeSameSizeAsNetworkProcessCreationParameters) == sizeof(WebKit::NetworkProcessCreationParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::NetworkProcessCreationParameters, auxiliaryProcessParameters)
        , offsetof(WebKit::NetworkProcessCreationParameters, cacheModel)
#if PLATFORM(MAC) || PLATFORM(MACCATALYST)
        , offsetof(WebKit::NetworkProcessCreationParameters, uiProcessCookieStorageIdentifier)
#endif
        , offsetof(WebKit::NetworkProcessCreationParameters, shouldSuppressMemoryPressureHandler)
        , offsetof(WebKit::NetworkProcessCreationParameters, urlSchemesRegisteredForCustomProtocols)
#if PLATFORM(COCOA)
        , offsetof(WebKit::NetworkProcessCreationParameters, uiProcessBundleIdentifier)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::NetworkProcessCreationParameters, networkATSContext)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::NetworkProcessCreationParameters, isParentProcessFullWebBrowserOrRunningTest)
#endif
#if USE(SOUP)
        , offsetof(WebKit::NetworkProcessCreationParameters, cookieAcceptPolicy)
#endif
#if USE(SOUP)
        , offsetof(WebKit::NetworkProcessCreationParameters, languages)
#endif
#if USE(SOUP)
        , offsetof(WebKit::NetworkProcessCreationParameters, memoryPressureHandlerConfiguration)
#endif
        , offsetof(WebKit::NetworkProcessCreationParameters, urlSchemesRegisteredAsSecure)
        , offsetof(WebKit::NetworkProcessCreationParameters, urlSchemesRegisteredAsBypassingContentSecurityPolicy)
        , offsetof(WebKit::NetworkProcessCreationParameters, urlSchemesRegisteredAsLocal)
        , offsetof(WebKit::NetworkProcessCreationParameters, urlSchemesRegisteredAsNoAccess)
        , offsetof(WebKit::NetworkProcessCreationParameters, enablePrivateClickMeasurement)
        , offsetof(WebKit::NetworkProcessCreationParameters, ftpEnabled)
#if PLATFORM(COCOA)
        , offsetof(WebKit::NetworkProcessCreationParameters, enableModernDownloadProgress)
#endif
        , offsetof(WebKit::NetworkProcessCreationParameters, websiteDataStoreParameters)
        , offsetof(WebKit::NetworkProcessCreationParameters, allowedFirstPartiesForCookies)
        , offsetof(WebKit::NetworkProcessCreationParameters, localhostAliasesForTesting)
        , offsetof(WebKit::NetworkProcessCreationParameters, storageAccessPromptQuirksData)
        , offsetof(WebKit::NetworkProcessCreationParameters, defaultRequestTimeoutInterval)
    >::value);

    encoder << WTFMove(instance.auxiliaryProcessParameters);
    encoder << WTFMove(instance.cacheModel);
#if PLATFORM(MAC) || PLATFORM(MACCATALYST)
    encoder << WTFMove(instance.uiProcessCookieStorageIdentifier);
#endif
    encoder << WTFMove(instance.shouldSuppressMemoryPressureHandler);
    encoder << WTFMove(instance.urlSchemesRegisteredForCustomProtocols);
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.uiProcessBundleIdentifier);
#endif
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.networkATSContext);
#endif
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.isParentProcessFullWebBrowserOrRunningTest);
#endif
#if USE(SOUP)
    encoder << WTFMove(instance.cookieAcceptPolicy);
#endif
#if USE(SOUP)
    encoder << WTFMove(instance.languages);
#endif
#if USE(SOUP)
    encoder << WTFMove(instance.memoryPressureHandlerConfiguration);
#endif
    encoder << WTFMove(instance.urlSchemesRegisteredAsSecure);
    encoder << WTFMove(instance.urlSchemesRegisteredAsBypassingContentSecurityPolicy);
    encoder << WTFMove(instance.urlSchemesRegisteredAsLocal);
    encoder << WTFMove(instance.urlSchemesRegisteredAsNoAccess);
    encoder << WTFMove(instance.enablePrivateClickMeasurement);
    encoder << WTFMove(instance.ftpEnabled);
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.enableModernDownloadProgress);
#endif
    encoder << WTFMove(instance.websiteDataStoreParameters);
    encoder << WTFMove(instance.allowedFirstPartiesForCookies);
    encoder << WTFMove(instance.localhostAliasesForTesting);
    encoder << WTFMove(instance.storageAccessPromptQuirksData);
    encoder << WTFMove(instance.defaultRequestTimeoutInterval);
}

std::optional<WebKit::NetworkProcessCreationParameters> ArgumentCoder<WebKit::NetworkProcessCreationParameters>::decode(Decoder& decoder)
{
    auto auxiliaryProcessParameters = decoder.decode<WebKit::AuxiliaryProcessCreationParameters>();
    auto cacheModel = decoder.decode<WebKit::CacheModel>();
#if PLATFORM(MAC) || PLATFORM(MACCATALYST)
    auto uiProcessCookieStorageIdentifier = decoder.decode<Vector<uint8_t>>();
#endif
    auto shouldSuppressMemoryPressureHandler = decoder.decode<bool>();
    auto urlSchemesRegisteredForCustomProtocols = decoder.decode<Vector<String>>();
#if PLATFORM(COCOA)
    auto uiProcessBundleIdentifier = decoder.decode<String>();
#endif
#if PLATFORM(COCOA)
    auto networkATSContext = decoder.decode<RetainPtr<CFDataRef>>();
#endif
#if PLATFORM(COCOA)
    auto isParentProcessFullWebBrowserOrRunningTest = decoder.decode<bool>();
#endif
#if USE(SOUP)
    auto cookieAcceptPolicy = decoder.decode<WebCore::HTTPCookieAcceptPolicy>();
#endif
#if USE(SOUP)
    auto languages = decoder.decode<Vector<String>>();
#endif
#if USE(SOUP)
    auto memoryPressureHandlerConfiguration = decoder.decode<std::optional<MemoryPressureHandler::Configuration>>();
#endif
    auto urlSchemesRegisteredAsSecure = decoder.decode<Vector<String>>();
    auto urlSchemesRegisteredAsBypassingContentSecurityPolicy = decoder.decode<Vector<String>>();
    auto urlSchemesRegisteredAsLocal = decoder.decode<Vector<String>>();
    auto urlSchemesRegisteredAsNoAccess = decoder.decode<Vector<String>>();
    auto enablePrivateClickMeasurement = decoder.decode<bool>();
    auto ftpEnabled = decoder.decode<bool>();
#if PLATFORM(COCOA)
    auto enableModernDownloadProgress = decoder.decode<bool>();
#endif
    auto websiteDataStoreParameters = decoder.decode<Vector<WebKit::WebsiteDataStoreParameters>>();
    auto allowedFirstPartiesForCookies = decoder.decode<Vector<std::pair<WebCore::ProcessIdentifier, WebCore::RegistrableDomain>>>();
    auto localhostAliasesForTesting = decoder.decode<HashSet<String>>();
    auto storageAccessPromptQuirksData = decoder.decode<Vector<WebCore::OrganizationStorageAccessPromptQuirk>>();
    auto defaultRequestTimeoutInterval = decoder.decode<Markable<double>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::NetworkProcessCreationParameters {
            WTFMove(*auxiliaryProcessParameters),
            WTFMove(*cacheModel),
#if PLATFORM(MAC) || PLATFORM(MACCATALYST)
            WTFMove(*uiProcessCookieStorageIdentifier),
#endif
            WTFMove(*shouldSuppressMemoryPressureHandler),
            WTFMove(*urlSchemesRegisteredForCustomProtocols),
#if PLATFORM(COCOA)
            WTFMove(*uiProcessBundleIdentifier),
#endif
#if PLATFORM(COCOA)
            WTFMove(*networkATSContext),
#endif
#if PLATFORM(COCOA)
            WTFMove(*isParentProcessFullWebBrowserOrRunningTest),
#endif
#if USE(SOUP)
            WTFMove(*cookieAcceptPolicy),
#endif
#if USE(SOUP)
            WTFMove(*languages),
#endif
#if USE(SOUP)
            WTFMove(*memoryPressureHandlerConfiguration),
#endif
            WTFMove(*urlSchemesRegisteredAsSecure),
            WTFMove(*urlSchemesRegisteredAsBypassingContentSecurityPolicy),
            WTFMove(*urlSchemesRegisteredAsLocal),
            WTFMove(*urlSchemesRegisteredAsNoAccess),
            WTFMove(*enablePrivateClickMeasurement),
            WTFMove(*ftpEnabled),
#if PLATFORM(COCOA)
            WTFMove(*enableModernDownloadProgress),
#endif
            WTFMove(*websiteDataStoreParameters),
            WTFMove(*allowedFirstPartiesForCookies),
            WTFMove(*localhostAliasesForTesting),
            WTFMove(*storageAccessPromptQuirksData),
            WTFMove(*defaultRequestTimeoutInterval)
        }
    };
}

void ArgumentCoder<WebKit::NetworkResourceLoadParameters>::encode(Encoder& encoder, WebKit::NetworkResourceLoadParameters&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webPageProxyID)>, WebKit::WebPageProxyIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webPageID)>, WebCore::PageIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webFrameID)>, WebCore::FrameIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.request)>, WebCore::ResourceRequest>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.topOrigin)>, RefPtr<WebCore::SecurityOrigin>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceOrigin)>, RefPtr<WebCore::SecurityOrigin>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.parentPID)>, WTF::ProcessID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentSniffingPolicy)>, WebCore::ContentSniffingPolicy>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentEncodingSniffingPolicy)>, WebCore::ContentEncodingSniffingPolicy>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.storedCredentialsPolicy)>, WebCore::StoredCredentialsPolicy>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.clientCredentialPolicy)>, WebCore::ClientCredentialPolicy>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldClearReferrerOnHTTPSToHTTPRedirect)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.needsCertificateInfo)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isMainFrameNavigation)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mainResourceNavigationDataForAnyFrame)>, std::optional<WebKit::NavigationActionData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldPreconnectOnly)>, WebKit::PreconnectOnly>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isNavigatingToAppBoundDomain)>, std::optional<WebKit::NavigatingToAppBoundDomain>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hadMainFrameMainResourcePrivateRelayed)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowPrivacyProxy)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.advancedPrivacyProtections)>, OptionSet<WebCore::AdvancedPrivacyProtections>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requiredCookiesVersion)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, Markable<WebCore::ResourceLoaderIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requestBodySandboxExtensions)>, Vector<WebKit::SandboxExtensionHandle>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.resourceSandboxExtension)>, std::optional<WebKit::SandboxExtensionHandle>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maximumBufferingTime)>, Seconds>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.options)>, WebCore::FetchOptions>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cspResponseHeaders)>, std::optional<WebCore::ContentSecurityPolicyResponseHeaders>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.parentFrameURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.parentCrossOriginEmbedderPolicy)>, WebCore::CrossOriginEmbedderPolicy>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.crossOriginEmbedderPolicy)>, WebCore::CrossOriginEmbedderPolicy>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.originalRequestHeaders)>, WebCore::HTTPHeaderMap>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldRestrictHTTPResponseAccess)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.preflightPolicy)>, WebCore::PreflightPolicy>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldEnableCrossOriginResourcePolicy)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameAncestorOrigins)>, Vector<Ref<WebCore::SecurityOrigin>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pageHasResourceLoadClient)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.parentFrameID)>, std::optional<WebCore::FrameIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.crossOriginAccessControlCheckEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.documentURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isCrossOriginOpenerPolicyEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isClearSiteDataHeaderEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isClearSiteDataExecutionContextEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isDisplayingInitialEmptyDocument)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.effectiveSandboxFlags)>, WebCore::SandboxFlags>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.openerURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceCrossOriginOpenerPolicy)>, WebCore::CrossOriginOpenerPolicy>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.navigationID)>, std::optional<WebCore::NavigationIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.navigationRequester)>, std::optional<WebCore::NavigationRequester>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.serviceWorkersMode)>, WebCore::ServiceWorkersMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.serviceWorkerRegistrationIdentifier)>, std::optional<WebCore::ServiceWorkerRegistrationIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.httpHeadersToKeep)>, OptionSet<WebCore::HTTPHeadersToKeepFromCleaning>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.navigationPreloadIdentifier)>, std::optional<WebCore::FetchIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.workerIdentifier)>, WebCore::FetchingWorkerIdentifier>);
#if ENABLE(CONTENT_EXTENSIONS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mainDocumentURL)>, URL>);
#endif
#if ENABLE(CONTENT_EXTENSIONS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.userContentControllerIdentifier)>, std::optional<WebKit::UserContentControllerIdentifier>>);
#endif
#if ENABLE(WK_WEB_EXTENSIONS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pageHasLoadedWebExtensions)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.linkPreconnectEarlyHintsEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldRecordFrameLoadForStorageAccess)>, bool>);
    struct ShouldBeSameSizeAsNetworkResourceLoadParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::NetworkResourceLoadParameters>, false> {
        WebKit::WebPageProxyIdentifier webPageProxyID;
        WebCore::PageIdentifier webPageID;
        WebCore::FrameIdentifier webFrameID;
        WebCore::ResourceRequest request;
        RefPtr<WebCore::SecurityOrigin> topOrigin;
        RefPtr<WebCore::SecurityOrigin> sourceOrigin;
        WTF::ProcessID parentPID;
        WebCore::ContentSniffingPolicy contentSniffingPolicy;
        WebCore::ContentEncodingSniffingPolicy contentEncodingSniffingPolicy;
        WebCore::StoredCredentialsPolicy storedCredentialsPolicy;
        WebCore::ClientCredentialPolicy clientCredentialPolicy;
        bool shouldClearReferrerOnHTTPSToHTTPRedirect;
        bool needsCertificateInfo;
        bool isMainFrameNavigation;
        std::optional<WebKit::NavigationActionData> mainResourceNavigationDataForAnyFrame;
        WebKit::PreconnectOnly shouldPreconnectOnly;
        std::optional<WebKit::NavigatingToAppBoundDomain> isNavigatingToAppBoundDomain;
        bool hadMainFrameMainResourcePrivateRelayed;
        bool allowPrivacyProxy;
        OptionSet<WebCore::AdvancedPrivacyProtections> advancedPrivacyProtections;
        uint64_t requiredCookiesVersion;
        Markable<WebCore::ResourceLoaderIdentifier> identifier;
        Vector<WebKit::SandboxExtensionHandle> requestBodySandboxExtensions;
        std::optional<WebKit::SandboxExtensionHandle> resourceSandboxExtension;
        Seconds maximumBufferingTime;
        WebCore::FetchOptions options;
        std::optional<WebCore::ContentSecurityPolicyResponseHeaders> cspResponseHeaders;
        URL parentFrameURL;
        URL frameURL;
        WebCore::CrossOriginEmbedderPolicy parentCrossOriginEmbedderPolicy;
        WebCore::CrossOriginEmbedderPolicy crossOriginEmbedderPolicy;
        WebCore::HTTPHeaderMap originalRequestHeaders;
        bool shouldRestrictHTTPResponseAccess;
        WebCore::PreflightPolicy preflightPolicy;
        bool shouldEnableCrossOriginResourcePolicy;
        Vector<Ref<WebCore::SecurityOrigin>> frameAncestorOrigins;
        bool pageHasResourceLoadClient;
        std::optional<WebCore::FrameIdentifier> parentFrameID;
        bool crossOriginAccessControlCheckEnabled;
        URL documentURL;
        bool isCrossOriginOpenerPolicyEnabled;
        bool isClearSiteDataHeaderEnabled;
        bool isClearSiteDataExecutionContextEnabled;
        bool isDisplayingInitialEmptyDocument;
        WebCore::SandboxFlags effectiveSandboxFlags;
        URL openerURL;
        WebCore::CrossOriginOpenerPolicy sourceCrossOriginOpenerPolicy;
        std::optional<WebCore::NavigationIdentifier> navigationID;
        std::optional<WebCore::NavigationRequester> navigationRequester;
        WebCore::ServiceWorkersMode serviceWorkersMode;
        std::optional<WebCore::ServiceWorkerRegistrationIdentifier> serviceWorkerRegistrationIdentifier;
        OptionSet<WebCore::HTTPHeadersToKeepFromCleaning> httpHeadersToKeep;
        std::optional<WebCore::FetchIdentifier> navigationPreloadIdentifier;
        WebCore::FetchingWorkerIdentifier workerIdentifier;
#if ENABLE(CONTENT_EXTENSIONS)
        URL mainDocumentURL;
#endif
#if ENABLE(CONTENT_EXTENSIONS)
        std::optional<WebKit::UserContentControllerIdentifier> userContentControllerIdentifier;
#endif
#if ENABLE(WK_WEB_EXTENSIONS)
        bool pageHasLoadedWebExtensions;
#endif
        bool linkPreconnectEarlyHintsEnabled;
        bool shouldRecordFrameLoadForStorageAccess;
    };
    static_assert(sizeof(ShouldBeSameSizeAsNetworkResourceLoadParameters) == sizeof(WebKit::NetworkResourceLoadParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::NetworkResourceLoadParameters, webPageProxyID)
        , offsetof(WebKit::NetworkResourceLoadParameters, webPageID)
        , offsetof(WebKit::NetworkResourceLoadParameters, webFrameID)
        , offsetof(WebKit::NetworkResourceLoadParameters, request)
        , offsetof(WebKit::NetworkResourceLoadParameters, topOrigin)
        , offsetof(WebKit::NetworkResourceLoadParameters, sourceOrigin)
        , offsetof(WebKit::NetworkResourceLoadParameters, parentPID)
        , offsetof(WebKit::NetworkResourceLoadParameters, contentSniffingPolicy)
        , offsetof(WebKit::NetworkResourceLoadParameters, contentEncodingSniffingPolicy)
        , offsetof(WebKit::NetworkResourceLoadParameters, storedCredentialsPolicy)
        , offsetof(WebKit::NetworkResourceLoadParameters, clientCredentialPolicy)
        , offsetof(WebKit::NetworkResourceLoadParameters, shouldClearReferrerOnHTTPSToHTTPRedirect)
        , offsetof(WebKit::NetworkResourceLoadParameters, needsCertificateInfo)
        , offsetof(WebKit::NetworkResourceLoadParameters, isMainFrameNavigation)
        , offsetof(WebKit::NetworkResourceLoadParameters, mainResourceNavigationDataForAnyFrame)
        , offsetof(WebKit::NetworkResourceLoadParameters, shouldPreconnectOnly)
        , offsetof(WebKit::NetworkResourceLoadParameters, isNavigatingToAppBoundDomain)
        , offsetof(WebKit::NetworkResourceLoadParameters, hadMainFrameMainResourcePrivateRelayed)
        , offsetof(WebKit::NetworkResourceLoadParameters, allowPrivacyProxy)
        , offsetof(WebKit::NetworkResourceLoadParameters, advancedPrivacyProtections)
        , offsetof(WebKit::NetworkResourceLoadParameters, requiredCookiesVersion)
        , offsetof(WebKit::NetworkResourceLoadParameters, identifier)
        , offsetof(WebKit::NetworkResourceLoadParameters, requestBodySandboxExtensions)
        , offsetof(WebKit::NetworkResourceLoadParameters, resourceSandboxExtension)
        , offsetof(WebKit::NetworkResourceLoadParameters, maximumBufferingTime)
        , offsetof(WebKit::NetworkResourceLoadParameters, options)
        , offsetof(WebKit::NetworkResourceLoadParameters, cspResponseHeaders)
        , offsetof(WebKit::NetworkResourceLoadParameters, parentFrameURL)
        , offsetof(WebKit::NetworkResourceLoadParameters, frameURL)
        , offsetof(WebKit::NetworkResourceLoadParameters, parentCrossOriginEmbedderPolicy)
        , offsetof(WebKit::NetworkResourceLoadParameters, crossOriginEmbedderPolicy)
        , offsetof(WebKit::NetworkResourceLoadParameters, originalRequestHeaders)
        , offsetof(WebKit::NetworkResourceLoadParameters, shouldRestrictHTTPResponseAccess)
        , offsetof(WebKit::NetworkResourceLoadParameters, preflightPolicy)
        , offsetof(WebKit::NetworkResourceLoadParameters, shouldEnableCrossOriginResourcePolicy)
        , offsetof(WebKit::NetworkResourceLoadParameters, frameAncestorOrigins)
        , offsetof(WebKit::NetworkResourceLoadParameters, pageHasResourceLoadClient)
        , offsetof(WebKit::NetworkResourceLoadParameters, parentFrameID)
        , offsetof(WebKit::NetworkResourceLoadParameters, crossOriginAccessControlCheckEnabled)
        , offsetof(WebKit::NetworkResourceLoadParameters, documentURL)
        , offsetof(WebKit::NetworkResourceLoadParameters, isCrossOriginOpenerPolicyEnabled)
        , offsetof(WebKit::NetworkResourceLoadParameters, isClearSiteDataHeaderEnabled)
        , offsetof(WebKit::NetworkResourceLoadParameters, isClearSiteDataExecutionContextEnabled)
        , offsetof(WebKit::NetworkResourceLoadParameters, isDisplayingInitialEmptyDocument)
        , offsetof(WebKit::NetworkResourceLoadParameters, effectiveSandboxFlags)
        , offsetof(WebKit::NetworkResourceLoadParameters, openerURL)
        , offsetof(WebKit::NetworkResourceLoadParameters, sourceCrossOriginOpenerPolicy)
        , offsetof(WebKit::NetworkResourceLoadParameters, navigationID)
        , offsetof(WebKit::NetworkResourceLoadParameters, navigationRequester)
        , offsetof(WebKit::NetworkResourceLoadParameters, serviceWorkersMode)
        , offsetof(WebKit::NetworkResourceLoadParameters, serviceWorkerRegistrationIdentifier)
        , offsetof(WebKit::NetworkResourceLoadParameters, httpHeadersToKeep)
        , offsetof(WebKit::NetworkResourceLoadParameters, navigationPreloadIdentifier)
        , offsetof(WebKit::NetworkResourceLoadParameters, workerIdentifier)
#if ENABLE(CONTENT_EXTENSIONS)
        , offsetof(WebKit::NetworkResourceLoadParameters, mainDocumentURL)
#endif
#if ENABLE(CONTENT_EXTENSIONS)
        , offsetof(WebKit::NetworkResourceLoadParameters, userContentControllerIdentifier)
#endif
#if ENABLE(WK_WEB_EXTENSIONS)
        , offsetof(WebKit::NetworkResourceLoadParameters, pageHasLoadedWebExtensions)
#endif
        , offsetof(WebKit::NetworkResourceLoadParameters, linkPreconnectEarlyHintsEnabled)
        , offsetof(WebKit::NetworkResourceLoadParameters, shouldRecordFrameLoadForStorageAccess)
    >::value);

    encoder << WTFMove(instance.webPageProxyID);
    encoder << WTFMove(instance.webPageID);
    encoder << WTFMove(instance.webFrameID);
    RefPtr requestBody = instance.request.httpBody();
    encoder << WTFMove(instance.request);
    encoder << IPC::FormDataReference { WTFMove(requestBody) };
    encoder << WTFMove(instance.topOrigin);
    encoder << WTFMove(instance.sourceOrigin);
    encoder << WTFMove(instance.parentPID);
    encoder << WTFMove(instance.contentSniffingPolicy);
    encoder << WTFMove(instance.contentEncodingSniffingPolicy);
    encoder << WTFMove(instance.storedCredentialsPolicy);
    encoder << WTFMove(instance.clientCredentialPolicy);
    encoder << WTFMove(instance.shouldClearReferrerOnHTTPSToHTTPRedirect);
    encoder << WTFMove(instance.needsCertificateInfo);
    encoder << WTFMove(instance.isMainFrameNavigation);
    encoder << WTFMove(instance.mainResourceNavigationDataForAnyFrame);
    encoder << WTFMove(instance.shouldPreconnectOnly);
    encoder << WTFMove(instance.isNavigatingToAppBoundDomain);
    encoder << WTFMove(instance.hadMainFrameMainResourcePrivateRelayed);
    encoder << WTFMove(instance.allowPrivacyProxy);
    encoder << WTFMove(instance.advancedPrivacyProtections);
    encoder << WTFMove(instance.requiredCookiesVersion);
    encoder << WTFMove(instance.identifier);
    encoder << WTFMove(instance.requestBodySandboxExtensions);
    encoder << WTFMove(instance.resourceSandboxExtension);
    encoder << WTFMove(instance.maximumBufferingTime);
    encoder << WTFMove(instance.options);
    encoder << WTFMove(instance.cspResponseHeaders);
    encoder << WTFMove(instance.parentFrameURL);
    encoder << WTFMove(instance.frameURL);
    encoder << WTFMove(instance.parentCrossOriginEmbedderPolicy);
    encoder << WTFMove(instance.crossOriginEmbedderPolicy);
    encoder << WTFMove(instance.originalRequestHeaders);
    encoder << WTFMove(instance.shouldRestrictHTTPResponseAccess);
    encoder << WTFMove(instance.preflightPolicy);
    encoder << WTFMove(instance.shouldEnableCrossOriginResourcePolicy);
    encoder << WTFMove(instance.frameAncestorOrigins);
    encoder << WTFMove(instance.pageHasResourceLoadClient);
    encoder << WTFMove(instance.parentFrameID);
    encoder << WTFMove(instance.crossOriginAccessControlCheckEnabled);
    encoder << WTFMove(instance.documentURL);
    encoder << WTFMove(instance.isCrossOriginOpenerPolicyEnabled);
    encoder << WTFMove(instance.isClearSiteDataHeaderEnabled);
    encoder << WTFMove(instance.isClearSiteDataExecutionContextEnabled);
    encoder << WTFMove(instance.isDisplayingInitialEmptyDocument);
    encoder << WTFMove(instance.effectiveSandboxFlags);
    encoder << WTFMove(instance.openerURL);
    encoder << WTFMove(instance.sourceCrossOriginOpenerPolicy);
    encoder << WTFMove(instance.navigationID);
    encoder << WTFMove(instance.navigationRequester);
    encoder << WTFMove(instance.serviceWorkersMode);
    encoder << WTFMove(instance.serviceWorkerRegistrationIdentifier);
    encoder << WTFMove(instance.httpHeadersToKeep);
    encoder << WTFMove(instance.navigationPreloadIdentifier);
    encoder << WTFMove(instance.workerIdentifier);
#if ENABLE(CONTENT_EXTENSIONS)
    encoder << WTFMove(instance.mainDocumentURL);
#endif
#if ENABLE(CONTENT_EXTENSIONS)
    encoder << WTFMove(instance.userContentControllerIdentifier);
#endif
#if ENABLE(WK_WEB_EXTENSIONS)
    encoder << WTFMove(instance.pageHasLoadedWebExtensions);
#endif
    encoder << WTFMove(instance.linkPreconnectEarlyHintsEnabled);
    encoder << WTFMove(instance.shouldRecordFrameLoadForStorageAccess);
}

std::optional<WebKit::NetworkResourceLoadParameters> ArgumentCoder<WebKit::NetworkResourceLoadParameters>::decode(Decoder& decoder)
{
    auto webPageProxyID = decoder.decode<WebKit::WebPageProxyIdentifier>();
    auto webPageID = decoder.decode<WebCore::PageIdentifier>();
    auto webFrameID = decoder.decode<WebCore::FrameIdentifier>();
    auto request = decoder.decode<WebCore::ResourceRequest>();
    if (request) {
        if (auto requestBody = decoder.decode<IPC::FormDataReference>())
            request->setHTTPBody(requestBody->takeData());
    }
    auto topOrigin = decoder.decode<RefPtr<WebCore::SecurityOrigin>>();
    auto sourceOrigin = decoder.decode<RefPtr<WebCore::SecurityOrigin>>();
    auto parentPID = decoder.decode<WTF::ProcessID>();
    auto contentSniffingPolicy = decoder.decode<WebCore::ContentSniffingPolicy>();
    auto contentEncodingSniffingPolicy = decoder.decode<WebCore::ContentEncodingSniffingPolicy>();
    auto storedCredentialsPolicy = decoder.decode<WebCore::StoredCredentialsPolicy>();
    auto clientCredentialPolicy = decoder.decode<WebCore::ClientCredentialPolicy>();
    auto shouldClearReferrerOnHTTPSToHTTPRedirect = decoder.decode<bool>();
    auto needsCertificateInfo = decoder.decode<bool>();
    auto isMainFrameNavigation = decoder.decode<bool>();
    auto mainResourceNavigationDataForAnyFrame = decoder.decode<std::optional<WebKit::NavigationActionData>>();
    auto shouldPreconnectOnly = decoder.decode<WebKit::PreconnectOnly>();
    auto isNavigatingToAppBoundDomain = decoder.decode<std::optional<WebKit::NavigatingToAppBoundDomain>>();
    auto hadMainFrameMainResourcePrivateRelayed = decoder.decode<bool>();
    auto allowPrivacyProxy = decoder.decode<bool>();
    auto advancedPrivacyProtections = decoder.decode<OptionSet<WebCore::AdvancedPrivacyProtections>>();
    auto requiredCookiesVersion = decoder.decode<uint64_t>();
    auto identifier = decoder.decode<Markable<WebCore::ResourceLoaderIdentifier>>();
    auto requestBodySandboxExtensions = decoder.decode<Vector<WebKit::SandboxExtensionHandle>>();
    auto resourceSandboxExtension = decoder.decode<std::optional<WebKit::SandboxExtensionHandle>>();
    auto maximumBufferingTime = decoder.decode<Seconds>();
    auto options = decoder.decode<WebCore::FetchOptions>();
    auto cspResponseHeaders = decoder.decode<std::optional<WebCore::ContentSecurityPolicyResponseHeaders>>();
    auto parentFrameURL = decoder.decode<URL>();
    auto frameURL = decoder.decode<URL>();
    auto parentCrossOriginEmbedderPolicy = decoder.decode<WebCore::CrossOriginEmbedderPolicy>();
    auto crossOriginEmbedderPolicy = decoder.decode<WebCore::CrossOriginEmbedderPolicy>();
    auto originalRequestHeaders = decoder.decode<WebCore::HTTPHeaderMap>();
    auto shouldRestrictHTTPResponseAccess = decoder.decode<bool>();
    auto preflightPolicy = decoder.decode<WebCore::PreflightPolicy>();
    auto shouldEnableCrossOriginResourcePolicy = decoder.decode<bool>();
    auto frameAncestorOrigins = decoder.decode<Vector<Ref<WebCore::SecurityOrigin>>>();
    auto pageHasResourceLoadClient = decoder.decode<bool>();
    auto parentFrameID = decoder.decode<std::optional<WebCore::FrameIdentifier>>();
    auto crossOriginAccessControlCheckEnabled = decoder.decode<bool>();
    auto documentURL = decoder.decode<URL>();
    auto isCrossOriginOpenerPolicyEnabled = decoder.decode<bool>();
    auto isClearSiteDataHeaderEnabled = decoder.decode<bool>();
    auto isClearSiteDataExecutionContextEnabled = decoder.decode<bool>();
    auto isDisplayingInitialEmptyDocument = decoder.decode<bool>();
    auto effectiveSandboxFlags = decoder.decode<WebCore::SandboxFlags>();
    auto openerURL = decoder.decode<URL>();
    auto sourceCrossOriginOpenerPolicy = decoder.decode<WebCore::CrossOriginOpenerPolicy>();
    auto navigationID = decoder.decode<std::optional<WebCore::NavigationIdentifier>>();
    auto navigationRequester = decoder.decode<std::optional<WebCore::NavigationRequester>>();
    auto serviceWorkersMode = decoder.decode<WebCore::ServiceWorkersMode>();
    auto serviceWorkerRegistrationIdentifier = decoder.decode<std::optional<WebCore::ServiceWorkerRegistrationIdentifier>>();
    auto httpHeadersToKeep = decoder.decode<OptionSet<WebCore::HTTPHeadersToKeepFromCleaning>>();
    auto navigationPreloadIdentifier = decoder.decode<std::optional<WebCore::FetchIdentifier>>();
    auto workerIdentifier = decoder.decode<WebCore::FetchingWorkerIdentifier>();
#if ENABLE(CONTENT_EXTENSIONS)
    auto mainDocumentURL = decoder.decode<URL>();
#endif
#if ENABLE(CONTENT_EXTENSIONS)
    auto userContentControllerIdentifier = decoder.decode<std::optional<WebKit::UserContentControllerIdentifier>>();
#endif
#if ENABLE(WK_WEB_EXTENSIONS)
    auto pageHasLoadedWebExtensions = decoder.decode<bool>();
#endif
    auto linkPreconnectEarlyHintsEnabled = decoder.decode<bool>();
    auto shouldRecordFrameLoadForStorageAccess = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::NetworkResourceLoadParameters {
            WTFMove(*webPageProxyID),
            WTFMove(*webPageID),
            WTFMove(*webFrameID),
            WTFMove(*request),
            WTFMove(*topOrigin),
            WTFMove(*sourceOrigin),
            WTFMove(*parentPID),
            WTFMove(*contentSniffingPolicy),
            WTFMove(*contentEncodingSniffingPolicy),
            WTFMove(*storedCredentialsPolicy),
            WTFMove(*clientCredentialPolicy),
            WTFMove(*shouldClearReferrerOnHTTPSToHTTPRedirect),
            WTFMove(*needsCertificateInfo),
            WTFMove(*isMainFrameNavigation),
            WTFMove(*mainResourceNavigationDataForAnyFrame),
            WTFMove(*shouldPreconnectOnly),
            WTFMove(*isNavigatingToAppBoundDomain),
            WTFMove(*hadMainFrameMainResourcePrivateRelayed),
            WTFMove(*allowPrivacyProxy),
            WTFMove(*advancedPrivacyProtections),
            WTFMove(*requiredCookiesVersion),
            WTFMove(*identifier),
            WTFMove(*requestBodySandboxExtensions),
            WTFMove(*resourceSandboxExtension),
            WTFMove(*maximumBufferingTime),
            WTFMove(*options),
            WTFMove(*cspResponseHeaders),
            WTFMove(*parentFrameURL),
            WTFMove(*frameURL),
            WTFMove(*parentCrossOriginEmbedderPolicy),
            WTFMove(*crossOriginEmbedderPolicy),
            WTFMove(*originalRequestHeaders),
            WTFMove(*shouldRestrictHTTPResponseAccess),
            WTFMove(*preflightPolicy),
            WTFMove(*shouldEnableCrossOriginResourcePolicy),
            WTFMove(*frameAncestorOrigins),
            WTFMove(*pageHasResourceLoadClient),
            WTFMove(*parentFrameID),
            WTFMove(*crossOriginAccessControlCheckEnabled),
            WTFMove(*documentURL),
            WTFMove(*isCrossOriginOpenerPolicyEnabled),
            WTFMove(*isClearSiteDataHeaderEnabled),
            WTFMove(*isClearSiteDataExecutionContextEnabled),
            WTFMove(*isDisplayingInitialEmptyDocument),
            WTFMove(*effectiveSandboxFlags),
            WTFMove(*openerURL),
            WTFMove(*sourceCrossOriginOpenerPolicy),
            WTFMove(*navigationID),
            WTFMove(*navigationRequester),
            WTFMove(*serviceWorkersMode),
            WTFMove(*serviceWorkerRegistrationIdentifier),
            WTFMove(*httpHeadersToKeep),
            WTFMove(*navigationPreloadIdentifier),
            WTFMove(*workerIdentifier),
#if ENABLE(CONTENT_EXTENSIONS)
            WTFMove(*mainDocumentURL),
#endif
#if ENABLE(CONTENT_EXTENSIONS)
            WTFMove(*userContentControllerIdentifier),
#endif
#if ENABLE(WK_WEB_EXTENSIONS)
            WTFMove(*pageHasLoadedWebExtensions),
#endif
            WTFMove(*linkPreconnectEarlyHintsEnabled),
            WTFMove(*shouldRecordFrameLoadForStorageAccess)
        }
    };
}

void ArgumentCoder<WebKit::NetworkSessionCreationParameters>::encode(Encoder& encoder, WebKit::NetworkSessionCreationParameters&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sessionID)>, PAL::SessionID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dataStoreIdentifier)>, Markable<WTF::UUID>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.boundInterfaceIdentifier)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowsCellularAccess)>, WebKit::AllowsCellularAccess>);
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.proxyConfiguration)>, RetainPtr<CFDictionaryRef>>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceApplicationBundleIdentifier)>, String>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceApplicationSecondaryIdentifier)>, String>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldLogCookieInformation)>, bool>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.httpProxy)>, URL>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.httpsProxy)>, URL>);
#endif
#if HAVE(ALTERNATIVE_SERVICE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.alternativeServiceDirectory)>, String>);
#endif
#if HAVE(ALTERNATIVE_SERVICE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.alternativeServiceDirectoryExtensionHandle)>, WebKit::SandboxExtensionHandle>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hstsStorageDirectory)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hstsStorageDirectoryExtensionHandle)>, WebKit::SandboxExtensionHandle>);
#if USE(SOUP)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cookiePersistentStoragePath)>, String>);
#endif
#if USE(SOUP)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cookiePersistentStorageType)>, WebKit::SoupCookiePersistentStorageType>);
#endif
#if USE(SOUP)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.persistentCredentialStorageEnabled)>, bool>);
#endif
#if USE(SOUP)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ignoreTLSErrors)>, bool>);
#endif
#if USE(SOUP)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.proxySettings)>, WebCore::SoupNetworkProxySettings>);
#endif
#if USE(SOUP)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cookieAcceptPolicy)>, WebCore::HTTPCookieAcceptPolicy>);
#endif
#if USE(CURL)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cookiePersistentStorageFile)>, String>);
#endif
#if USE(CURL)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.proxySettings)>, WebCore::CurlProxySettings>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.deviceManagementRestrictionsEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allLoadsBlockedByDeviceManagementRestrictionsForTesting)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webPushDaemonConnectionConfiguration)>, WebKit::WebPushD::WebPushDaemonConnectionConfiguration>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.networkCacheDirectory)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.networkCacheDirectoryExtensionHandle)>, WebKit::SandboxExtensionHandle>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dataConnectionServiceType)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fastServerTrustEvaluationEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.networkCacheSpeculativeValidationEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldUseTestingNetworkSession)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.staleWhileRevalidateEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.testSpeedMultiplier)>, unsigned>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.suppressesConnectionTerminationOnSystemChange)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowsServerPreconnect)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requiresSecureHTTPSProxyConnection)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldRunServiceWorkersOnMainThreadForTesting)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.overrideServiceWorkerRegistrationCountTestingValue)>, std::optional<unsigned>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.preventsSystemHTTPProxyAuthentication)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.useNetworkLoader)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowsHSTSWithUntrustedRootCertificate)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pcmMachServiceName)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webPushMachServiceName)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webPushPartitionString)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.enablePrivateClickMeasurementDebugMode)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isOptInCookiePartitioningEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldSendPrivateTokenIPCForTesting)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cookiesVersion)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.unifiedOriginStorageLevel)>, WebKit::UnifiedOriginStorageLevel>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.perOriginStorageQuota)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.originQuotaRatio)>, std::optional<double>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.totalQuotaRatio)>, std::optional<double>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.standardVolumeCapacity)>, std::optional<uint64_t>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.volumeCapacityOverride)>, std::optional<uint64_t>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.localStorageDirectory)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.localStorageDirectoryExtensionHandle)>, WebKit::SandboxExtensionHandle>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.indexedDBDirectory)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.indexedDBDirectoryExtensionHandle)>, WebKit::SandboxExtensionHandle>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cacheStorageDirectory)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cacheStorageDirectoryExtensionHandle)>, WebKit::SandboxExtensionHandle>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.generalStorageDirectory)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.generalStorageDirectoryHandle)>, WebKit::SandboxExtensionHandle>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.serviceWorkerRegistrationDirectory)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.serviceWorkerRegistrationDirectoryExtensionHandle)>, WebKit::SandboxExtensionHandle>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.serviceWorkerProcessTerminationDelayEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.inspectionForServiceWorkersAllowed)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.storageSiteValidationEnabled)>, bool>);
#if ENABLE(DECLARATIVE_WEB_PUSH)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isDeclarativeWebPushEnabled)>, bool>);
#endif
#if HAVE(NW_PROXY_CONFIG)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.proxyConfigData)>, std::optional<Vector<std::pair<Vector<uint8_t>, std::optional<WTF::UUID>>>>>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.resourceLoadStatisticsParameters)>, WebKit::ResourceLoadStatisticsParameters>);
#if ENABLE(CONTENT_EXTENSIONS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.resourceMonitorThrottlerDirectory)>, String>);
#endif
#if ENABLE(CONTENT_EXTENSIONS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.resourceMonitorThrottlerDirectoryExtensionHandle)>, WebKit::SandboxExtensionHandle>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isLegacyTLSAllowed)>, bool>);
#if HAVE(WEBCONTENTRESTRICTIONS_PATH_SPI)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webContentRestrictionsConfigurationFile)>, String>);
#endif
#if HAVE(WEBCONTENTRESTRICTIONS_PATH_SPI)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webContentRestrictionsConfigurationExtensionHandle)>, WebKit::SandboxExtension::Handle>);
#endif
    struct ShouldBeSameSizeAsNetworkSessionCreationParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::NetworkSessionCreationParameters>, false> {
        PAL::SessionID sessionID;
        Markable<WTF::UUID> dataStoreIdentifier;
        String boundInterfaceIdentifier;
        WebKit::AllowsCellularAccess allowsCellularAccess;
#if PLATFORM(COCOA)
        RetainPtr<CFDictionaryRef> proxyConfiguration;
#endif
#if PLATFORM(COCOA)
        String sourceApplicationBundleIdentifier;
#endif
#if PLATFORM(COCOA)
        String sourceApplicationSecondaryIdentifier;
#endif
#if PLATFORM(COCOA)
        bool shouldLogCookieInformation;
#endif
#if PLATFORM(COCOA)
        URL httpProxy;
#endif
#if PLATFORM(COCOA)
        URL httpsProxy;
#endif
#if HAVE(ALTERNATIVE_SERVICE)
        String alternativeServiceDirectory;
#endif
#if HAVE(ALTERNATIVE_SERVICE)
        WebKit::SandboxExtensionHandle alternativeServiceDirectoryExtensionHandle;
#endif
        String hstsStorageDirectory;
        WebKit::SandboxExtensionHandle hstsStorageDirectoryExtensionHandle;
#if USE(SOUP)
        String cookiePersistentStoragePath;
#endif
#if USE(SOUP)
        WebKit::SoupCookiePersistentStorageType cookiePersistentStorageType;
#endif
#if USE(SOUP)
        bool persistentCredentialStorageEnabled;
#endif
#if USE(SOUP)
        bool ignoreTLSErrors;
#endif
#if USE(SOUP)
        WebCore::SoupNetworkProxySettings proxySettings;
#endif
#if USE(SOUP)
        WebCore::HTTPCookieAcceptPolicy cookieAcceptPolicy;
#endif
#if USE(CURL)
        String cookiePersistentStorageFile;
#endif
#if USE(CURL)
        WebCore::CurlProxySettings proxySettings;
#endif
        bool deviceManagementRestrictionsEnabled;
        bool allLoadsBlockedByDeviceManagementRestrictionsForTesting;
        WebKit::WebPushD::WebPushDaemonConnectionConfiguration webPushDaemonConnectionConfiguration;
        String networkCacheDirectory;
        WebKit::SandboxExtensionHandle networkCacheDirectoryExtensionHandle;
        String dataConnectionServiceType;
        bool fastServerTrustEvaluationEnabled;
        bool networkCacheSpeculativeValidationEnabled;
        bool shouldUseTestingNetworkSession;
        bool staleWhileRevalidateEnabled;
        unsigned testSpeedMultiplier;
        bool suppressesConnectionTerminationOnSystemChange;
        bool allowsServerPreconnect;
        bool requiresSecureHTTPSProxyConnection;
        bool shouldRunServiceWorkersOnMainThreadForTesting;
        std::optional<unsigned> overrideServiceWorkerRegistrationCountTestingValue;
        bool preventsSystemHTTPProxyAuthentication;
        std::optional<bool> useNetworkLoader;
        bool allowsHSTSWithUntrustedRootCertificate;
        String pcmMachServiceName;
        String webPushMachServiceName;
        String webPushPartitionString;
        bool enablePrivateClickMeasurementDebugMode;
        bool isOptInCookiePartitioningEnabled;
        bool shouldSendPrivateTokenIPCForTesting;
        uint64_t cookiesVersion;
        WebKit::UnifiedOriginStorageLevel unifiedOriginStorageLevel;
        uint64_t perOriginStorageQuota;
        std::optional<double> originQuotaRatio;
        std::optional<double> totalQuotaRatio;
        std::optional<uint64_t> standardVolumeCapacity;
        std::optional<uint64_t> volumeCapacityOverride;
        String localStorageDirectory;
        WebKit::SandboxExtensionHandle localStorageDirectoryExtensionHandle;
        String indexedDBDirectory;
        WebKit::SandboxExtensionHandle indexedDBDirectoryExtensionHandle;
        String cacheStorageDirectory;
        WebKit::SandboxExtensionHandle cacheStorageDirectoryExtensionHandle;
        String generalStorageDirectory;
        WebKit::SandboxExtensionHandle generalStorageDirectoryHandle;
        String serviceWorkerRegistrationDirectory;
        WebKit::SandboxExtensionHandle serviceWorkerRegistrationDirectoryExtensionHandle;
        bool serviceWorkerProcessTerminationDelayEnabled;
        bool inspectionForServiceWorkersAllowed;
        bool storageSiteValidationEnabled;
#if ENABLE(DECLARATIVE_WEB_PUSH)
        bool isDeclarativeWebPushEnabled;
#endif
#if HAVE(NW_PROXY_CONFIG)
        std::optional<Vector<std::pair<Vector<uint8_t>, std::optional<WTF::UUID>>>> proxyConfigData;
#endif
        WebKit::ResourceLoadStatisticsParameters resourceLoadStatisticsParameters;
#if ENABLE(CONTENT_EXTENSIONS)
        String resourceMonitorThrottlerDirectory;
#endif
#if ENABLE(CONTENT_EXTENSIONS)
        WebKit::SandboxExtensionHandle resourceMonitorThrottlerDirectoryExtensionHandle;
#endif
        bool isLegacyTLSAllowed;
#if HAVE(WEBCONTENTRESTRICTIONS_PATH_SPI)
        String webContentRestrictionsConfigurationFile;
#endif
#if HAVE(WEBCONTENTRESTRICTIONS_PATH_SPI)
        WebKit::SandboxExtension::Handle webContentRestrictionsConfigurationExtensionHandle;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsNetworkSessionCreationParameters) == sizeof(WebKit::NetworkSessionCreationParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::NetworkSessionCreationParameters, sessionID)
        , offsetof(WebKit::NetworkSessionCreationParameters, dataStoreIdentifier)
        , offsetof(WebKit::NetworkSessionCreationParameters, boundInterfaceIdentifier)
        , offsetof(WebKit::NetworkSessionCreationParameters, allowsCellularAccess)
#if PLATFORM(COCOA)
        , offsetof(WebKit::NetworkSessionCreationParameters, proxyConfiguration)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::NetworkSessionCreationParameters, sourceApplicationBundleIdentifier)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::NetworkSessionCreationParameters, sourceApplicationSecondaryIdentifier)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::NetworkSessionCreationParameters, shouldLogCookieInformation)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::NetworkSessionCreationParameters, httpProxy)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::NetworkSessionCreationParameters, httpsProxy)
#endif
#if HAVE(ALTERNATIVE_SERVICE)
        , offsetof(WebKit::NetworkSessionCreationParameters, alternativeServiceDirectory)
#endif
#if HAVE(ALTERNATIVE_SERVICE)
        , offsetof(WebKit::NetworkSessionCreationParameters, alternativeServiceDirectoryExtensionHandle)
#endif
        , offsetof(WebKit::NetworkSessionCreationParameters, hstsStorageDirectory)
        , offsetof(WebKit::NetworkSessionCreationParameters, hstsStorageDirectoryExtensionHandle)
#if USE(SOUP)
        , offsetof(WebKit::NetworkSessionCreationParameters, cookiePersistentStoragePath)
#endif
#if USE(SOUP)
        , offsetof(WebKit::NetworkSessionCreationParameters, cookiePersistentStorageType)
#endif
#if USE(SOUP)
        , offsetof(WebKit::NetworkSessionCreationParameters, persistentCredentialStorageEnabled)
#endif
#if USE(SOUP)
        , offsetof(WebKit::NetworkSessionCreationParameters, ignoreTLSErrors)
#endif
#if USE(SOUP)
        , offsetof(WebKit::NetworkSessionCreationParameters, proxySettings)
#endif
#if USE(SOUP)
        , offsetof(WebKit::NetworkSessionCreationParameters, cookieAcceptPolicy)
#endif
#if USE(CURL)
        , offsetof(WebKit::NetworkSessionCreationParameters, cookiePersistentStorageFile)
#endif
#if USE(CURL)
        , offsetof(WebKit::NetworkSessionCreationParameters, proxySettings)
#endif
        , offsetof(WebKit::NetworkSessionCreationParameters, deviceManagementRestrictionsEnabled)
        , offsetof(WebKit::NetworkSessionCreationParameters, allLoadsBlockedByDeviceManagementRestrictionsForTesting)
        , offsetof(WebKit::NetworkSessionCreationParameters, webPushDaemonConnectionConfiguration)
        , offsetof(WebKit::NetworkSessionCreationParameters, networkCacheDirectory)
        , offsetof(WebKit::NetworkSessionCreationParameters, networkCacheDirectoryExtensionHandle)
        , offsetof(WebKit::NetworkSessionCreationParameters, dataConnectionServiceType)
        , offsetof(WebKit::NetworkSessionCreationParameters, fastServerTrustEvaluationEnabled)
        , offsetof(WebKit::NetworkSessionCreationParameters, networkCacheSpeculativeValidationEnabled)
        , offsetof(WebKit::NetworkSessionCreationParameters, shouldUseTestingNetworkSession)
        , offsetof(WebKit::NetworkSessionCreationParameters, staleWhileRevalidateEnabled)
        , offsetof(WebKit::NetworkSessionCreationParameters, testSpeedMultiplier)
        , offsetof(WebKit::NetworkSessionCreationParameters, suppressesConnectionTerminationOnSystemChange)
        , offsetof(WebKit::NetworkSessionCreationParameters, allowsServerPreconnect)
        , offsetof(WebKit::NetworkSessionCreationParameters, requiresSecureHTTPSProxyConnection)
        , offsetof(WebKit::NetworkSessionCreationParameters, shouldRunServiceWorkersOnMainThreadForTesting)
        , offsetof(WebKit::NetworkSessionCreationParameters, overrideServiceWorkerRegistrationCountTestingValue)
        , offsetof(WebKit::NetworkSessionCreationParameters, preventsSystemHTTPProxyAuthentication)
        , offsetof(WebKit::NetworkSessionCreationParameters, useNetworkLoader)
        , offsetof(WebKit::NetworkSessionCreationParameters, allowsHSTSWithUntrustedRootCertificate)
        , offsetof(WebKit::NetworkSessionCreationParameters, pcmMachServiceName)
        , offsetof(WebKit::NetworkSessionCreationParameters, webPushMachServiceName)
        , offsetof(WebKit::NetworkSessionCreationParameters, webPushPartitionString)
        , offsetof(WebKit::NetworkSessionCreationParameters, enablePrivateClickMeasurementDebugMode)
        , offsetof(WebKit::NetworkSessionCreationParameters, isOptInCookiePartitioningEnabled)
        , offsetof(WebKit::NetworkSessionCreationParameters, shouldSendPrivateTokenIPCForTesting)
        , offsetof(WebKit::NetworkSessionCreationParameters, cookiesVersion)
        , offsetof(WebKit::NetworkSessionCreationParameters, unifiedOriginStorageLevel)
        , offsetof(WebKit::NetworkSessionCreationParameters, perOriginStorageQuota)
        , offsetof(WebKit::NetworkSessionCreationParameters, originQuotaRatio)
        , offsetof(WebKit::NetworkSessionCreationParameters, totalQuotaRatio)
        , offsetof(WebKit::NetworkSessionCreationParameters, standardVolumeCapacity)
        , offsetof(WebKit::NetworkSessionCreationParameters, volumeCapacityOverride)
        , offsetof(WebKit::NetworkSessionCreationParameters, localStorageDirectory)
        , offsetof(WebKit::NetworkSessionCreationParameters, localStorageDirectoryExtensionHandle)
        , offsetof(WebKit::NetworkSessionCreationParameters, indexedDBDirectory)
        , offsetof(WebKit::NetworkSessionCreationParameters, indexedDBDirectoryExtensionHandle)
        , offsetof(WebKit::NetworkSessionCreationParameters, cacheStorageDirectory)
        , offsetof(WebKit::NetworkSessionCreationParameters, cacheStorageDirectoryExtensionHandle)
        , offsetof(WebKit::NetworkSessionCreationParameters, generalStorageDirectory)
        , offsetof(WebKit::NetworkSessionCreationParameters, generalStorageDirectoryHandle)
        , offsetof(WebKit::NetworkSessionCreationParameters, serviceWorkerRegistrationDirectory)
        , offsetof(WebKit::NetworkSessionCreationParameters, serviceWorkerRegistrationDirectoryExtensionHandle)
        , offsetof(WebKit::NetworkSessionCreationParameters, serviceWorkerProcessTerminationDelayEnabled)
        , offsetof(WebKit::NetworkSessionCreationParameters, inspectionForServiceWorkersAllowed)
        , offsetof(WebKit::NetworkSessionCreationParameters, storageSiteValidationEnabled)
#if ENABLE(DECLARATIVE_WEB_PUSH)
        , offsetof(WebKit::NetworkSessionCreationParameters, isDeclarativeWebPushEnabled)
#endif
#if HAVE(NW_PROXY_CONFIG)
        , offsetof(WebKit::NetworkSessionCreationParameters, proxyConfigData)
#endif
        , offsetof(WebKit::NetworkSessionCreationParameters, resourceLoadStatisticsParameters)
#if ENABLE(CONTENT_EXTENSIONS)
        , offsetof(WebKit::NetworkSessionCreationParameters, resourceMonitorThrottlerDirectory)
#endif
#if ENABLE(CONTENT_EXTENSIONS)
        , offsetof(WebKit::NetworkSessionCreationParameters, resourceMonitorThrottlerDirectoryExtensionHandle)
#endif
        , offsetof(WebKit::NetworkSessionCreationParameters, isLegacyTLSAllowed)
#if HAVE(WEBCONTENTRESTRICTIONS_PATH_SPI)
        , offsetof(WebKit::NetworkSessionCreationParameters, webContentRestrictionsConfigurationFile)
#endif
#if HAVE(WEBCONTENTRESTRICTIONS_PATH_SPI)
        , offsetof(WebKit::NetworkSessionCreationParameters, webContentRestrictionsConfigurationExtensionHandle)
#endif
    >::value);

    encoder << WTFMove(instance.sessionID);
    encoder << WTFMove(instance.dataStoreIdentifier);
    encoder << WTFMove(instance.boundInterfaceIdentifier);
    encoder << WTFMove(instance.allowsCellularAccess);
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.proxyConfiguration);
#endif
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.sourceApplicationBundleIdentifier);
#endif
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.sourceApplicationSecondaryIdentifier);
#endif
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.shouldLogCookieInformation);
#endif
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.httpProxy);
#endif
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.httpsProxy);
#endif
#if HAVE(ALTERNATIVE_SERVICE)
    encoder << WTFMove(instance.alternativeServiceDirectory);
#endif
#if HAVE(ALTERNATIVE_SERVICE)
    encoder << WTFMove(instance.alternativeServiceDirectoryExtensionHandle);
#endif
    encoder << WTFMove(instance.hstsStorageDirectory);
    encoder << WTFMove(instance.hstsStorageDirectoryExtensionHandle);
#if USE(SOUP)
    encoder << WTFMove(instance.cookiePersistentStoragePath);
#endif
#if USE(SOUP)
    encoder << WTFMove(instance.cookiePersistentStorageType);
#endif
#if USE(SOUP)
    encoder << WTFMove(instance.persistentCredentialStorageEnabled);
#endif
#if USE(SOUP)
    encoder << WTFMove(instance.ignoreTLSErrors);
#endif
#if USE(SOUP)
    encoder << WTFMove(instance.proxySettings);
#endif
#if USE(SOUP)
    encoder << WTFMove(instance.cookieAcceptPolicy);
#endif
#if USE(CURL)
    encoder << WTFMove(instance.cookiePersistentStorageFile);
#endif
#if USE(CURL)
    encoder << WTFMove(instance.proxySettings);
#endif
    encoder << WTFMove(instance.deviceManagementRestrictionsEnabled);
    encoder << WTFMove(instance.allLoadsBlockedByDeviceManagementRestrictionsForTesting);
    encoder << WTFMove(instance.webPushDaemonConnectionConfiguration);
    encoder << WTFMove(instance.networkCacheDirectory);
    encoder << WTFMove(instance.networkCacheDirectoryExtensionHandle);
    encoder << WTFMove(instance.dataConnectionServiceType);
    encoder << WTFMove(instance.fastServerTrustEvaluationEnabled);
    encoder << WTFMove(instance.networkCacheSpeculativeValidationEnabled);
    encoder << WTFMove(instance.shouldUseTestingNetworkSession);
    encoder << WTFMove(instance.staleWhileRevalidateEnabled);
    encoder << WTFMove(instance.testSpeedMultiplier);
    encoder << WTFMove(instance.suppressesConnectionTerminationOnSystemChange);
    encoder << WTFMove(instance.allowsServerPreconnect);
    encoder << WTFMove(instance.requiresSecureHTTPSProxyConnection);
    encoder << WTFMove(instance.shouldRunServiceWorkersOnMainThreadForTesting);
    encoder << WTFMove(instance.overrideServiceWorkerRegistrationCountTestingValue);
    encoder << WTFMove(instance.preventsSystemHTTPProxyAuthentication);
    encoder << WTFMove(instance.useNetworkLoader);
    encoder << WTFMove(instance.allowsHSTSWithUntrustedRootCertificate);
    encoder << WTFMove(instance.pcmMachServiceName);
    encoder << WTFMove(instance.webPushMachServiceName);
    encoder << WTFMove(instance.webPushPartitionString);
    encoder << WTFMove(instance.enablePrivateClickMeasurementDebugMode);
    encoder << WTFMove(instance.isOptInCookiePartitioningEnabled);
    encoder << WTFMove(instance.shouldSendPrivateTokenIPCForTesting);
    encoder << WTFMove(instance.cookiesVersion);
    encoder << WTFMove(instance.unifiedOriginStorageLevel);
    encoder << WTFMove(instance.perOriginStorageQuota);
    encoder << WTFMove(instance.originQuotaRatio);
    encoder << WTFMove(instance.totalQuotaRatio);
    encoder << WTFMove(instance.standardVolumeCapacity);
    encoder << WTFMove(instance.volumeCapacityOverride);
    encoder << WTFMove(instance.localStorageDirectory);
    encoder << WTFMove(instance.localStorageDirectoryExtensionHandle);
    encoder << WTFMove(instance.indexedDBDirectory);
    encoder << WTFMove(instance.indexedDBDirectoryExtensionHandle);
    encoder << WTFMove(instance.cacheStorageDirectory);
    encoder << WTFMove(instance.cacheStorageDirectoryExtensionHandle);
    encoder << WTFMove(instance.generalStorageDirectory);
    encoder << WTFMove(instance.generalStorageDirectoryHandle);
    encoder << WTFMove(instance.serviceWorkerRegistrationDirectory);
    encoder << WTFMove(instance.serviceWorkerRegistrationDirectoryExtensionHandle);
    encoder << WTFMove(instance.serviceWorkerProcessTerminationDelayEnabled);
    encoder << WTFMove(instance.inspectionForServiceWorkersAllowed);
    encoder << WTFMove(instance.storageSiteValidationEnabled);
#if ENABLE(DECLARATIVE_WEB_PUSH)
    encoder << WTFMove(instance.isDeclarativeWebPushEnabled);
#endif
#if HAVE(NW_PROXY_CONFIG)
    encoder << WTFMove(instance.proxyConfigData);
#endif
    encoder << WTFMove(instance.resourceLoadStatisticsParameters);
#if ENABLE(CONTENT_EXTENSIONS)
    encoder << WTFMove(instance.resourceMonitorThrottlerDirectory);
#endif
#if ENABLE(CONTENT_EXTENSIONS)
    encoder << WTFMove(instance.resourceMonitorThrottlerDirectoryExtensionHandle);
#endif
    encoder << WTFMove(instance.isLegacyTLSAllowed);
#if HAVE(WEBCONTENTRESTRICTIONS_PATH_SPI)
    encoder << WTFMove(instance.webContentRestrictionsConfigurationFile);
#endif
#if HAVE(WEBCONTENTRESTRICTIONS_PATH_SPI)
    encoder << WTFMove(instance.webContentRestrictionsConfigurationExtensionHandle);
#endif
}

std::optional<WebKit::NetworkSessionCreationParameters> ArgumentCoder<WebKit::NetworkSessionCreationParameters>::decode(Decoder& decoder)
{
    auto sessionID = decoder.decode<PAL::SessionID>();
    auto dataStoreIdentifier = decoder.decode<Markable<WTF::UUID>>();
    auto boundInterfaceIdentifier = decoder.decode<String>();
    auto allowsCellularAccess = decoder.decode<WebKit::AllowsCellularAccess>();
#if PLATFORM(COCOA)
    auto proxyConfiguration = decoder.decode<RetainPtr<CFDictionaryRef>>();
#endif
#if PLATFORM(COCOA)
    auto sourceApplicationBundleIdentifier = decoder.decode<String>();
#endif
#if PLATFORM(COCOA)
    auto sourceApplicationSecondaryIdentifier = decoder.decode<String>();
#endif
#if PLATFORM(COCOA)
    auto shouldLogCookieInformation = decoder.decode<bool>();
#endif
#if PLATFORM(COCOA)
    auto httpProxy = decoder.decode<URL>();
#endif
#if PLATFORM(COCOA)
    auto httpsProxy = decoder.decode<URL>();
#endif
#if HAVE(ALTERNATIVE_SERVICE)
    auto alternativeServiceDirectory = decoder.decode<String>();
#endif
#if HAVE(ALTERNATIVE_SERVICE)
    auto alternativeServiceDirectoryExtensionHandle = decoder.decode<WebKit::SandboxExtensionHandle>();
#endif
    auto hstsStorageDirectory = decoder.decode<String>();
    auto hstsStorageDirectoryExtensionHandle = decoder.decode<WebKit::SandboxExtensionHandle>();
#if USE(SOUP)
    auto cookiePersistentStoragePath = decoder.decode<String>();
#endif
#if USE(SOUP)
    auto cookiePersistentStorageType = decoder.decode<WebKit::SoupCookiePersistentStorageType>();
#endif
#if USE(SOUP)
    auto persistentCredentialStorageEnabled = decoder.decode<bool>();
#endif
#if USE(SOUP)
    auto ignoreTLSErrors = decoder.decode<bool>();
#endif
#if USE(SOUP)
    auto proxySettings = decoder.decode<WebCore::SoupNetworkProxySettings>();
#endif
#if USE(SOUP)
    auto cookieAcceptPolicy = decoder.decode<WebCore::HTTPCookieAcceptPolicy>();
#endif
#if USE(CURL)
    auto cookiePersistentStorageFile = decoder.decode<String>();
#endif
#if USE(CURL)
    auto proxySettings = decoder.decode<WebCore::CurlProxySettings>();
#endif
    auto deviceManagementRestrictionsEnabled = decoder.decode<bool>();
    auto allLoadsBlockedByDeviceManagementRestrictionsForTesting = decoder.decode<bool>();
    auto webPushDaemonConnectionConfiguration = decoder.decode<WebKit::WebPushD::WebPushDaemonConnectionConfiguration>();
    auto networkCacheDirectory = decoder.decode<String>();
    auto networkCacheDirectoryExtensionHandle = decoder.decode<WebKit::SandboxExtensionHandle>();
    auto dataConnectionServiceType = decoder.decode<String>();
    auto fastServerTrustEvaluationEnabled = decoder.decode<bool>();
    auto networkCacheSpeculativeValidationEnabled = decoder.decode<bool>();
    auto shouldUseTestingNetworkSession = decoder.decode<bool>();
    auto staleWhileRevalidateEnabled = decoder.decode<bool>();
    auto testSpeedMultiplier = decoder.decode<unsigned>();
    auto suppressesConnectionTerminationOnSystemChange = decoder.decode<bool>();
    auto allowsServerPreconnect = decoder.decode<bool>();
    auto requiresSecureHTTPSProxyConnection = decoder.decode<bool>();
    auto shouldRunServiceWorkersOnMainThreadForTesting = decoder.decode<bool>();
    auto overrideServiceWorkerRegistrationCountTestingValue = decoder.decode<std::optional<unsigned>>();
    auto preventsSystemHTTPProxyAuthentication = decoder.decode<bool>();
    auto useNetworkLoader = decoder.decode<std::optional<bool>>();
    auto allowsHSTSWithUntrustedRootCertificate = decoder.decode<bool>();
    auto pcmMachServiceName = decoder.decode<String>();
    auto webPushMachServiceName = decoder.decode<String>();
    auto webPushPartitionString = decoder.decode<String>();
    auto enablePrivateClickMeasurementDebugMode = decoder.decode<bool>();
    auto isOptInCookiePartitioningEnabled = decoder.decode<bool>();
    auto shouldSendPrivateTokenIPCForTesting = decoder.decode<bool>();
    auto cookiesVersion = decoder.decode<uint64_t>();
    auto unifiedOriginStorageLevel = decoder.decode<WebKit::UnifiedOriginStorageLevel>();
    auto perOriginStorageQuota = decoder.decode<uint64_t>();
    auto originQuotaRatio = decoder.decode<std::optional<double>>();
    auto totalQuotaRatio = decoder.decode<std::optional<double>>();
    auto standardVolumeCapacity = decoder.decode<std::optional<uint64_t>>();
    auto volumeCapacityOverride = decoder.decode<std::optional<uint64_t>>();
    auto localStorageDirectory = decoder.decode<String>();
    auto localStorageDirectoryExtensionHandle = decoder.decode<WebKit::SandboxExtensionHandle>();
    auto indexedDBDirectory = decoder.decode<String>();
    auto indexedDBDirectoryExtensionHandle = decoder.decode<WebKit::SandboxExtensionHandle>();
    auto cacheStorageDirectory = decoder.decode<String>();
    auto cacheStorageDirectoryExtensionHandle = decoder.decode<WebKit::SandboxExtensionHandle>();
    auto generalStorageDirectory = decoder.decode<String>();
    auto generalStorageDirectoryHandle = decoder.decode<WebKit::SandboxExtensionHandle>();
    auto serviceWorkerRegistrationDirectory = decoder.decode<String>();
    auto serviceWorkerRegistrationDirectoryExtensionHandle = decoder.decode<WebKit::SandboxExtensionHandle>();
    auto serviceWorkerProcessTerminationDelayEnabled = decoder.decode<bool>();
    auto inspectionForServiceWorkersAllowed = decoder.decode<bool>();
    auto storageSiteValidationEnabled = decoder.decode<bool>();
#if ENABLE(DECLARATIVE_WEB_PUSH)
    auto isDeclarativeWebPushEnabled = decoder.decode<bool>();
#endif
#if HAVE(NW_PROXY_CONFIG)
    auto proxyConfigData = decoder.decode<std::optional<Vector<std::pair<Vector<uint8_t>, std::optional<WTF::UUID>>>>>();
#endif
    auto resourceLoadStatisticsParameters = decoder.decode<WebKit::ResourceLoadStatisticsParameters>();
#if ENABLE(CONTENT_EXTENSIONS)
    auto resourceMonitorThrottlerDirectory = decoder.decode<String>();
#endif
#if ENABLE(CONTENT_EXTENSIONS)
    auto resourceMonitorThrottlerDirectoryExtensionHandle = decoder.decode<WebKit::SandboxExtensionHandle>();
#endif
    auto isLegacyTLSAllowed = decoder.decode<bool>();
#if HAVE(WEBCONTENTRESTRICTIONS_PATH_SPI)
    auto webContentRestrictionsConfigurationFile = decoder.decode<String>();
#endif
#if HAVE(WEBCONTENTRESTRICTIONS_PATH_SPI)
    auto webContentRestrictionsConfigurationExtensionHandle = decoder.decode<WebKit::SandboxExtension::Handle>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::NetworkSessionCreationParameters {
            WTFMove(*sessionID),
            WTFMove(*dataStoreIdentifier),
            WTFMove(*boundInterfaceIdentifier),
            WTFMove(*allowsCellularAccess),
#if PLATFORM(COCOA)
            WTFMove(*proxyConfiguration),
#endif
#if PLATFORM(COCOA)
            WTFMove(*sourceApplicationBundleIdentifier),
#endif
#if PLATFORM(COCOA)
            WTFMove(*sourceApplicationSecondaryIdentifier),
#endif
#if PLATFORM(COCOA)
            WTFMove(*shouldLogCookieInformation),
#endif
#if PLATFORM(COCOA)
            WTFMove(*httpProxy),
#endif
#if PLATFORM(COCOA)
            WTFMove(*httpsProxy),
#endif
#if HAVE(ALTERNATIVE_SERVICE)
            WTFMove(*alternativeServiceDirectory),
#endif
#if HAVE(ALTERNATIVE_SERVICE)
            WTFMove(*alternativeServiceDirectoryExtensionHandle),
#endif
            WTFMove(*hstsStorageDirectory),
            WTFMove(*hstsStorageDirectoryExtensionHandle),
#if USE(SOUP)
            WTFMove(*cookiePersistentStoragePath),
#endif
#if USE(SOUP)
            WTFMove(*cookiePersistentStorageType),
#endif
#if USE(SOUP)
            WTFMove(*persistentCredentialStorageEnabled),
#endif
#if USE(SOUP)
            WTFMove(*ignoreTLSErrors),
#endif
#if USE(SOUP)
            WTFMove(*proxySettings),
#endif
#if USE(SOUP)
            WTFMove(*cookieAcceptPolicy),
#endif
#if USE(CURL)
            WTFMove(*cookiePersistentStorageFile),
#endif
#if USE(CURL)
            WTFMove(*proxySettings),
#endif
            WTFMove(*deviceManagementRestrictionsEnabled),
            WTFMove(*allLoadsBlockedByDeviceManagementRestrictionsForTesting),
            WTFMove(*webPushDaemonConnectionConfiguration),
            WTFMove(*networkCacheDirectory),
            WTFMove(*networkCacheDirectoryExtensionHandle),
            WTFMove(*dataConnectionServiceType),
            WTFMove(*fastServerTrustEvaluationEnabled),
            WTFMove(*networkCacheSpeculativeValidationEnabled),
            WTFMove(*shouldUseTestingNetworkSession),
            WTFMove(*staleWhileRevalidateEnabled),
            WTFMove(*testSpeedMultiplier),
            WTFMove(*suppressesConnectionTerminationOnSystemChange),
            WTFMove(*allowsServerPreconnect),
            WTFMove(*requiresSecureHTTPSProxyConnection),
            WTFMove(*shouldRunServiceWorkersOnMainThreadForTesting),
            WTFMove(*overrideServiceWorkerRegistrationCountTestingValue),
            WTFMove(*preventsSystemHTTPProxyAuthentication),
            WTFMove(*useNetworkLoader),
            WTFMove(*allowsHSTSWithUntrustedRootCertificate),
            WTFMove(*pcmMachServiceName),
            WTFMove(*webPushMachServiceName),
            WTFMove(*webPushPartitionString),
            WTFMove(*enablePrivateClickMeasurementDebugMode),
            WTFMove(*isOptInCookiePartitioningEnabled),
            WTFMove(*shouldSendPrivateTokenIPCForTesting),
            WTFMove(*cookiesVersion),
            WTFMove(*unifiedOriginStorageLevel),
            WTFMove(*perOriginStorageQuota),
            WTFMove(*originQuotaRatio),
            WTFMove(*totalQuotaRatio),
            WTFMove(*standardVolumeCapacity),
            WTFMove(*volumeCapacityOverride),
            WTFMove(*localStorageDirectory),
            WTFMove(*localStorageDirectoryExtensionHandle),
            WTFMove(*indexedDBDirectory),
            WTFMove(*indexedDBDirectoryExtensionHandle),
            WTFMove(*cacheStorageDirectory),
            WTFMove(*cacheStorageDirectoryExtensionHandle),
            WTFMove(*generalStorageDirectory),
            WTFMove(*generalStorageDirectoryHandle),
            WTFMove(*serviceWorkerRegistrationDirectory),
            WTFMove(*serviceWorkerRegistrationDirectoryExtensionHandle),
            WTFMove(*serviceWorkerProcessTerminationDelayEnabled),
            WTFMove(*inspectionForServiceWorkersAllowed),
            WTFMove(*storageSiteValidationEnabled),
#if ENABLE(DECLARATIVE_WEB_PUSH)
            WTFMove(*isDeclarativeWebPushEnabled),
#endif
#if HAVE(NW_PROXY_CONFIG)
            WTFMove(*proxyConfigData),
#endif
            WTFMove(*resourceLoadStatisticsParameters),
#if ENABLE(CONTENT_EXTENSIONS)
            WTFMove(*resourceMonitorThrottlerDirectory),
#endif
#if ENABLE(CONTENT_EXTENSIONS)
            WTFMove(*resourceMonitorThrottlerDirectoryExtensionHandle),
#endif
            WTFMove(*isLegacyTLSAllowed),
#if HAVE(WEBCONTENTRESTRICTIONS_PATH_SPI)
            WTFMove(*webContentRestrictionsConfigurationFile),
#endif
#if HAVE(WEBCONTENTRESTRICTIONS_PATH_SPI)
            WTFMove(*webContentRestrictionsConfigurationExtensionHandle)
#endif
        }
    };
}

void ArgumentCoder<WebKit::ITPThirdPartyData>::encode(Encoder& encoder, const WebKit::ITPThirdPartyData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.thirdPartyDomain)>, WebCore::RegistrableDomain>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.underFirstParties)>, Vector<WebKit::ITPThirdPartyDataForSpecificFirstParty>>);
    struct ShouldBeSameSizeAsITPThirdPartyData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::ITPThirdPartyData>, false> {
        WebCore::RegistrableDomain thirdPartyDomain;
        Vector<WebKit::ITPThirdPartyDataForSpecificFirstParty> underFirstParties;
    };
    static_assert(sizeof(ShouldBeSameSizeAsITPThirdPartyData) == sizeof(WebKit::ITPThirdPartyData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::ITPThirdPartyData, thirdPartyDomain)
        , offsetof(WebKit::ITPThirdPartyData, underFirstParties)
    >::value);

    encoder << instance.thirdPartyDomain;
    encoder << instance.underFirstParties;
}

std::optional<WebKit::ITPThirdPartyData> ArgumentCoder<WebKit::ITPThirdPartyData>::decode(Decoder& decoder)
{
    auto thirdPartyDomain = decoder.decode<WebCore::RegistrableDomain>();
    auto underFirstParties = decoder.decode<Vector<WebKit::ITPThirdPartyDataForSpecificFirstParty>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::ITPThirdPartyData {
            WTFMove(*thirdPartyDomain),
            WTFMove(*underFirstParties)
        }
    };
}

void ArgumentCoder<WebKit::ITPThirdPartyDataForSpecificFirstParty>::encode(Encoder& encoder, const WebKit::ITPThirdPartyDataForSpecificFirstParty& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.firstPartyDomain)>, WebCore::RegistrableDomain>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.storageAccessGranted)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timeLastUpdated)>, Seconds>);
    struct ShouldBeSameSizeAsITPThirdPartyDataForSpecificFirstParty : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::ITPThirdPartyDataForSpecificFirstParty>, false> {
        WebCore::RegistrableDomain firstPartyDomain;
        bool storageAccessGranted;
        Seconds timeLastUpdated;
    };
    static_assert(sizeof(ShouldBeSameSizeAsITPThirdPartyDataForSpecificFirstParty) == sizeof(WebKit::ITPThirdPartyDataForSpecificFirstParty));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::ITPThirdPartyDataForSpecificFirstParty, firstPartyDomain)
        , offsetof(WebKit::ITPThirdPartyDataForSpecificFirstParty, storageAccessGranted)
        , offsetof(WebKit::ITPThirdPartyDataForSpecificFirstParty, timeLastUpdated)
    >::value);

    encoder << instance.firstPartyDomain;
    encoder << instance.storageAccessGranted;
    encoder << instance.timeLastUpdated;
}

std::optional<WebKit::ITPThirdPartyDataForSpecificFirstParty> ArgumentCoder<WebKit::ITPThirdPartyDataForSpecificFirstParty>::decode(Decoder& decoder)
{
    auto firstPartyDomain = decoder.decode<WebCore::RegistrableDomain>();
    auto storageAccessGranted = decoder.decode<bool>();
    auto timeLastUpdated = decoder.decode<Seconds>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::ITPThirdPartyDataForSpecificFirstParty {
            WTFMove(*firstPartyDomain),
            WTFMove(*storageAccessGranted),
            WTFMove(*timeLastUpdated)
        }
    };
}

void ArgumentCoder<IPC::FormDataReference>::encode(Encoder& encoder, const IPC::FormDataReference& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data())>, RefPtr<WebCore::FormData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sandboxExtensionHandles())>, Vector<WebKit::SandboxExtensionHandle>>);

    encoder << instance.data();
    encoder << instance.sandboxExtensionHandles();
}

std::optional<IPC::FormDataReference> ArgumentCoder<IPC::FormDataReference>::decode(Decoder& decoder)
{
    auto data = decoder.decode<RefPtr<WebCore::FormData>>();
    auto sandboxExtensionHandles = decoder.decode<Vector<WebKit::SandboxExtensionHandle>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        IPC::FormDataReference {
            WTFMove(*data),
            WTFMove(*sandboxExtensionHandles)
        }
    };
}

#if ENABLE(GPU_PROCESS) && ENABLE(VIDEO)
void ArgumentCoder<WebKit::RemoteVideoFrameReference>::encode(Encoder& encoder, const WebKit::RemoteVideoFrameReference& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier())>, WebKit::RemoteVideoFrameIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.version())>, uint64_t>);

    encoder << instance.identifier();
    encoder << instance.version();
}

void ArgumentCoder<WebKit::RemoteVideoFrameReference>::encode(StreamConnectionEncoder& encoder, const WebKit::RemoteVideoFrameReference& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier())>, WebKit::RemoteVideoFrameIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.version())>, uint64_t>);

    encoder << instance.identifier();
    encoder << instance.version();
}

std::optional<WebKit::RemoteVideoFrameReference> ArgumentCoder<WebKit::RemoteVideoFrameReference>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<WebKit::RemoteVideoFrameIdentifier>();
    auto version = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::RemoteVideoFrameReference {
            WTFMove(*identifier),
            WTFMove(*version)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS) && ENABLE(VIDEO)
void ArgumentCoder<WebKit::RemoteVideoFrameWriteReference>::encode(Encoder& encoder, const WebKit::RemoteVideoFrameWriteReference& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.reference())>, WebKit::RemoteVideoFrameReference>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pendingReads())>, uint64_t>);

    encoder << instance.reference();
    encoder << instance.pendingReads();
}

void ArgumentCoder<WebKit::RemoteVideoFrameWriteReference>::encode(StreamConnectionEncoder& encoder, const WebKit::RemoteVideoFrameWriteReference& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.reference())>, WebKit::RemoteVideoFrameReference>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pendingReads())>, uint64_t>);

    encoder << instance.reference();
    encoder << instance.pendingReads();
}

std::optional<WebKit::RemoteVideoFrameWriteReference> ArgumentCoder<WebKit::RemoteVideoFrameWriteReference>::decode(Decoder& decoder)
{
    auto reference = decoder.decode<WebKit::RemoteVideoFrameReference>();
    auto pendingReads = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::RemoteVideoFrameWriteReference {
            WTFMove(*reference),
            WTFMove(*pendingReads)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS) && ENABLE(VIDEO)
void ArgumentCoder<WebKit::RemoteVideoFrameReadReference>::encode(Encoder& encoder, const WebKit::RemoteVideoFrameReadReference& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.reference())>, WebKit::RemoteVideoFrameReference>);

    encoder << instance.reference();
}

void ArgumentCoder<WebKit::RemoteVideoFrameReadReference>::encode(StreamConnectionEncoder& encoder, const WebKit::RemoteVideoFrameReadReference& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.reference())>, WebKit::RemoteVideoFrameReference>);

    encoder << instance.reference();
}

std::optional<WebKit::RemoteVideoFrameReadReference> ArgumentCoder<WebKit::RemoteVideoFrameReadReference>::decode(Decoder& decoder)
{
    auto reference = decoder.decode<WebKit::RemoteVideoFrameReference>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::RemoteVideoFrameReadReference {
            WTFMove(*reference)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::RemoteSerializedImageBufferReference>::encode(Encoder& encoder, const WebKit::RemoteSerializedImageBufferReference& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier())>, WebKit::RemoteSerializedImageBufferIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.version())>, uint64_t>);

    encoder << instance.identifier();
    encoder << instance.version();
}

void ArgumentCoder<WebKit::RemoteSerializedImageBufferReference>::encode(StreamConnectionEncoder& encoder, const WebKit::RemoteSerializedImageBufferReference& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier())>, WebKit::RemoteSerializedImageBufferIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.version())>, uint64_t>);

    encoder << instance.identifier();
    encoder << instance.version();
}

std::optional<WebKit::RemoteSerializedImageBufferReference> ArgumentCoder<WebKit::RemoteSerializedImageBufferReference>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<WebKit::RemoteSerializedImageBufferIdentifier>();
    auto version = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::RemoteSerializedImageBufferReference {
            WTFMove(*identifier),
            WTFMove(*version)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::RemoteSerializedImageBufferWriteReference>::encode(Encoder& encoder, const WebKit::RemoteSerializedImageBufferWriteReference& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.reference())>, WebKit::RemoteSerializedImageBufferReference>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pendingReads())>, uint64_t>);

    encoder << instance.reference();
    encoder << instance.pendingReads();
}

void ArgumentCoder<WebKit::RemoteSerializedImageBufferWriteReference>::encode(StreamConnectionEncoder& encoder, const WebKit::RemoteSerializedImageBufferWriteReference& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.reference())>, WebKit::RemoteSerializedImageBufferReference>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pendingReads())>, uint64_t>);

    encoder << instance.reference();
    encoder << instance.pendingReads();
}

std::optional<WebKit::RemoteSerializedImageBufferWriteReference> ArgumentCoder<WebKit::RemoteSerializedImageBufferWriteReference>::decode(Decoder& decoder)
{
    auto reference = decoder.decode<WebKit::RemoteSerializedImageBufferReference>();
    auto pendingReads = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::RemoteSerializedImageBufferWriteReference {
            WTFMove(*reference),
            WTFMove(*pendingReads)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::RemoteSerializedImageBufferReadReference>::encode(Encoder& encoder, const WebKit::RemoteSerializedImageBufferReadReference& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.reference())>, WebKit::RemoteSerializedImageBufferReference>);

    encoder << instance.reference();
}

void ArgumentCoder<WebKit::RemoteSerializedImageBufferReadReference>::encode(StreamConnectionEncoder& encoder, const WebKit::RemoteSerializedImageBufferReadReference& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.reference())>, WebKit::RemoteSerializedImageBufferReference>);

    encoder << instance.reference();
}

std::optional<WebKit::RemoteSerializedImageBufferReadReference> ArgumentCoder<WebKit::RemoteSerializedImageBufferReadReference>::decode(Decoder& decoder)
{
    auto reference = decoder.decode<WebKit::RemoteSerializedImageBufferReference>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::RemoteSerializedImageBufferReadReference {
            WTFMove(*reference)
        }
    };
}

#endif

#if !USE(UNIX_DOMAIN_SOCKETS)
void ArgumentCoder<IPC::SharedBufferReference::SerializableBuffer>::encode(Encoder& encoder, IPC::SharedBufferReference::SerializableBuffer&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.handle)>, std::optional<WebCore::SharedMemory::Handle>>);
    struct ShouldBeSameSizeAsSerializableBuffer : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<IPC::SharedBufferReference::SerializableBuffer>, false> {
        uint64_t size;
        std::optional<WebCore::SharedMemory::Handle> handle;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSerializableBuffer) == sizeof(IPC::SharedBufferReference::SerializableBuffer));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(IPC::SharedBufferReference::SerializableBuffer, size)
        , offsetof(IPC::SharedBufferReference::SerializableBuffer, handle)
    >::value);

    encoder << WTFMove(instance.size);
    encoder << WTFMove(instance.handle);
}

std::optional<IPC::SharedBufferReference::SerializableBuffer> ArgumentCoder<IPC::SharedBufferReference::SerializableBuffer>::decode(Decoder& decoder)
{
    auto size = decoder.decode<uint64_t>();
    auto handle = decoder.decode<std::optional<WebCore::SharedMemory::Handle>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        IPC::SharedBufferReference::SerializableBuffer {
            WTFMove(*size),
            WTFMove(*handle)
        }
    };
}

#endif

void ArgumentCoder<IPC::SharedBufferReference>::encode(Encoder& encoder, const IPC::SharedBufferReference& instance)
{
#if USE(UNIX_DOMAIN_SOCKETS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.buffer())>, RefPtr<WebCore::FragmentedSharedBuffer>>);
#endif
#if !(USE(UNIX_DOMAIN_SOCKETS))
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.serializableBuffer())>, std::optional<IPC::SharedBufferReference::SerializableBuffer>>);
#endif

#if USE(UNIX_DOMAIN_SOCKETS)
    encoder << instance.buffer();
#endif
#if !(USE(UNIX_DOMAIN_SOCKETS))
    encoder << instance.serializableBuffer();
#endif
}

std::optional<IPC::SharedBufferReference> ArgumentCoder<IPC::SharedBufferReference>::decode(Decoder& decoder)
{
#if USE(UNIX_DOMAIN_SOCKETS)
    auto buffer = decoder.decode<RefPtr<WebCore::FragmentedSharedBuffer>>();
#endif
#if !(USE(UNIX_DOMAIN_SOCKETS))
    auto serializableBuffer = decoder.decode<std::optional<IPC::SharedBufferReference::SerializableBuffer>>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        IPC::SharedBufferReference {
#if USE(UNIX_DOMAIN_SOCKETS)
            WTFMove(*buffer),
#endif
#if !(USE(UNIX_DOMAIN_SOCKETS))
            WTFMove(*serializableBuffer)
#endif
        }
    };
}

void ArgumentCoder<IPC::SharedFileHandle>::encode(Encoder& encoder, const IPC::SharedFileHandle& instance)
{
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.toMachSendRight())>, MachSendRight>);
#endif

#if PLATFORM(COCOA)
    encoder << instance.toMachSendRight();
#endif
}

std::optional<IPC::SharedFileHandle> ArgumentCoder<IPC::SharedFileHandle>::decode(Decoder& decoder)
{
#if PLATFORM(COCOA)
    auto toMachSendRight = decoder.decode<MachSendRight>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        IPC::SharedFileHandle {
#if PLATFORM(COCOA)
            WTFMove(*toMachSendRight)
#endif
        }
    };
}

void ArgumentCoder<IPC::StreamServerConnectionHandle>::encode(Encoder& encoder, IPC::StreamServerConnectionHandle&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.outOfStreamConnection)>, IPC::ConnectionHandle>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.buffer)>, WebCore::SharedMemoryHandle>);
    struct ShouldBeSameSizeAsStreamServerConnectionHandle : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<IPC::StreamServerConnectionHandle>, false> {
        IPC::ConnectionHandle outOfStreamConnection;
        WebCore::SharedMemoryHandle buffer;
    };
    static_assert(sizeof(ShouldBeSameSizeAsStreamServerConnectionHandle) == sizeof(IPC::StreamServerConnectionHandle));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(IPC::StreamServerConnectionHandle, outOfStreamConnection)
        , offsetof(IPC::StreamServerConnectionHandle, buffer)
    >::value);

    encoder << WTFMove(instance.outOfStreamConnection);
    encoder << WTFMove(instance.buffer);
}

std::optional<IPC::StreamServerConnectionHandle> ArgumentCoder<IPC::StreamServerConnectionHandle>::decode(Decoder& decoder)
{
    auto outOfStreamConnection = decoder.decode<IPC::ConnectionHandle>();
    auto buffer = decoder.decode<WebCore::SharedMemoryHandle>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(IPC::StreamConnectionBuffer::sharedMemorySizeIsValid(buffer->size())))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        IPC::StreamServerConnectionHandle {
            WTFMove(*outOfStreamConnection),
            WTFMove(*buffer)
        }
    };
}

void ArgumentCoder<WebKit::AccessibilityPreferences>::encode(Encoder& encoder, const WebKit::AccessibilityPreferences& instance)
{
#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.reduceMotionEnabled)>, WebKit::WebKitAXValueState>);
#endif
#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.increaseButtonLegibility)>, WebKit::WebKitAXValueState>);
#endif
#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.enhanceTextLegibility)>, WebKit::WebKitAXValueState>);
#endif
#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.darkenSystemColors)>, WebKit::WebKitAXValueState>);
#endif
#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.invertColorsEnabled)>, WebKit::WebKitAXValueState>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.imageAnimationEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.enhanceTextLegibilityOverall)>, bool>);
#if ENABLE(ACCESSIBILITY_NON_BLINKING_CURSOR)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.prefersNonBlinkingCursor)>, bool>);
#endif
    struct ShouldBeSameSizeAsAccessibilityPreferences : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::AccessibilityPreferences>, false> {
#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
        WebKit::WebKitAXValueState reduceMotionEnabled;
#endif
#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
        WebKit::WebKitAXValueState increaseButtonLegibility;
#endif
#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
        WebKit::WebKitAXValueState enhanceTextLegibility;
#endif
#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
        WebKit::WebKitAXValueState darkenSystemColors;
#endif
#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
        WebKit::WebKitAXValueState invertColorsEnabled;
#endif
        bool imageAnimationEnabled;
        bool enhanceTextLegibilityOverall;
#if ENABLE(ACCESSIBILITY_NON_BLINKING_CURSOR)
        bool prefersNonBlinkingCursor;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsAccessibilityPreferences) == sizeof(WebKit::AccessibilityPreferences));
    static_assert(MembersInCorrectOrder < 0
#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
        , offsetof(WebKit::AccessibilityPreferences, reduceMotionEnabled)
#endif
#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
        , offsetof(WebKit::AccessibilityPreferences, increaseButtonLegibility)
#endif
#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
        , offsetof(WebKit::AccessibilityPreferences, enhanceTextLegibility)
#endif
#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
        , offsetof(WebKit::AccessibilityPreferences, darkenSystemColors)
#endif
#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
        , offsetof(WebKit::AccessibilityPreferences, invertColorsEnabled)
#endif
        , offsetof(WebKit::AccessibilityPreferences, imageAnimationEnabled)
        , offsetof(WebKit::AccessibilityPreferences, enhanceTextLegibilityOverall)
#if ENABLE(ACCESSIBILITY_NON_BLINKING_CURSOR)
        , offsetof(WebKit::AccessibilityPreferences, prefersNonBlinkingCursor)
#endif
    >::value);

#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
    encoder << instance.reduceMotionEnabled;
#endif
#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
    encoder << instance.increaseButtonLegibility;
#endif
#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
    encoder << instance.enhanceTextLegibility;
#endif
#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
    encoder << instance.darkenSystemColors;
#endif
#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
    encoder << instance.invertColorsEnabled;
#endif
    encoder << instance.imageAnimationEnabled;
    encoder << instance.enhanceTextLegibilityOverall;
#if ENABLE(ACCESSIBILITY_NON_BLINKING_CURSOR)
    encoder << instance.prefersNonBlinkingCursor;
#endif
}

std::optional<WebKit::AccessibilityPreferences> ArgumentCoder<WebKit::AccessibilityPreferences>::decode(Decoder& decoder)
{
#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
    auto reduceMotionEnabled = decoder.decode<WebKit::WebKitAXValueState>();
#endif
#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
    auto increaseButtonLegibility = decoder.decode<WebKit::WebKitAXValueState>();
#endif
#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
    auto enhanceTextLegibility = decoder.decode<WebKit::WebKitAXValueState>();
#endif
#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
    auto darkenSystemColors = decoder.decode<WebKit::WebKitAXValueState>();
#endif
#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
    auto invertColorsEnabled = decoder.decode<WebKit::WebKitAXValueState>();
#endif
    auto imageAnimationEnabled = decoder.decode<bool>();
    auto enhanceTextLegibilityOverall = decoder.decode<bool>();
#if ENABLE(ACCESSIBILITY_NON_BLINKING_CURSOR)
    auto prefersNonBlinkingCursor = decoder.decode<bool>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::AccessibilityPreferences {
#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
            WTFMove(*reduceMotionEnabled),
#endif
#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
            WTFMove(*increaseButtonLegibility),
#endif
#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
            WTFMove(*enhanceTextLegibility),
#endif
#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
            WTFMove(*darkenSystemColors),
#endif
#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
            WTFMove(*invertColorsEnabled),
#endif
            WTFMove(*imageAnimationEnabled),
            WTFMove(*enhanceTextLegibilityOverall),
#if ENABLE(ACCESSIBILITY_NON_BLINKING_CURSOR)
            WTFMove(*prefersNonBlinkingCursor)
#endif
        }
    };
}

void ArgumentCoder<WebKit::AuxiliaryProcessCreationParameters>::encode(Encoder& encoder, const WebKit::AuxiliaryProcessCreationParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.wtfLoggingChannels)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webCoreLoggingChannels)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webKitLoggingChannels)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.classNamesExemptFromSecureCodingCrash)>, std::unique_ptr<HashSet<String>>>);
    struct ShouldBeSameSizeAsAuxiliaryProcessCreationParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::AuxiliaryProcessCreationParameters>, false> {
        String wtfLoggingChannels;
        String webCoreLoggingChannels;
        String webKitLoggingChannels;
        std::unique_ptr<HashSet<String>> classNamesExemptFromSecureCodingCrash;
    };
    static_assert(sizeof(ShouldBeSameSizeAsAuxiliaryProcessCreationParameters) == sizeof(WebKit::AuxiliaryProcessCreationParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::AuxiliaryProcessCreationParameters, wtfLoggingChannels)
        , offsetof(WebKit::AuxiliaryProcessCreationParameters, webCoreLoggingChannels)
        , offsetof(WebKit::AuxiliaryProcessCreationParameters, webKitLoggingChannels)
        , offsetof(WebKit::AuxiliaryProcessCreationParameters, classNamesExemptFromSecureCodingCrash)
    >::value);

    encoder << instance.wtfLoggingChannels;
    encoder << instance.webCoreLoggingChannels;
    encoder << instance.webKitLoggingChannels;
    encoder << instance.classNamesExemptFromSecureCodingCrash;
}

std::optional<WebKit::AuxiliaryProcessCreationParameters> ArgumentCoder<WebKit::AuxiliaryProcessCreationParameters>::decode(Decoder& decoder)
{
    auto wtfLoggingChannels = decoder.decode<String>();
    auto webCoreLoggingChannels = decoder.decode<String>();
    auto webKitLoggingChannels = decoder.decode<String>();
    auto classNamesExemptFromSecureCodingCrash = decoder.decode<std::unique_ptr<HashSet<String>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::AuxiliaryProcessCreationParameters {
            WTFMove(*wtfLoggingChannels),
            WTFMove(*webCoreLoggingChannels),
            WTFMove(*webKitLoggingChannels),
            WTFMove(*classNamesExemptFromSecureCodingCrash)
        }
    };
}

void ArgumentCoder<WebKit::BackgroundFetchState>::encode(Encoder& encoder, const WebKit::BackgroundFetchState& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.topOrigin)>, WebCore::SecurityOriginData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scope)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.options)>, WebCore::BackgroundFetchOptions>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.downloadTotal)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.downloaded)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.uploadTotal)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.uploaded)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.result)>, WebCore::BackgroundFetchResult>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.failureReason)>, WebCore::BackgroundFetchFailureReason>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isPaused)>, bool>);
    struct ShouldBeSameSizeAsBackgroundFetchState : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::BackgroundFetchState>, false> {
        WebCore::SecurityOriginData topOrigin;
        URL scope;
        String identifier;
        WebCore::BackgroundFetchOptions options;
        uint64_t downloadTotal;
        uint64_t downloaded;
        uint64_t uploadTotal;
        uint64_t uploaded;
        WebCore::BackgroundFetchResult result;
        WebCore::BackgroundFetchFailureReason failureReason;
        bool isPaused;
    };
    static_assert(sizeof(ShouldBeSameSizeAsBackgroundFetchState) == sizeof(WebKit::BackgroundFetchState));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::BackgroundFetchState, topOrigin)
        , offsetof(WebKit::BackgroundFetchState, scope)
        , offsetof(WebKit::BackgroundFetchState, identifier)
        , offsetof(WebKit::BackgroundFetchState, options)
        , offsetof(WebKit::BackgroundFetchState, downloadTotal)
        , offsetof(WebKit::BackgroundFetchState, downloaded)
        , offsetof(WebKit::BackgroundFetchState, uploadTotal)
        , offsetof(WebKit::BackgroundFetchState, uploaded)
        , offsetof(WebKit::BackgroundFetchState, result)
        , offsetof(WebKit::BackgroundFetchState, failureReason)
        , offsetof(WebKit::BackgroundFetchState, isPaused)
    >::value);

    encoder << instance.topOrigin;
    encoder << instance.scope;
    encoder << instance.identifier;
    encoder << instance.options;
    encoder << instance.downloadTotal;
    encoder << instance.downloaded;
    encoder << instance.uploadTotal;
    encoder << instance.uploaded;
    encoder << instance.result;
    encoder << instance.failureReason;
    encoder << instance.isPaused;
}

std::optional<WebKit::BackgroundFetchState> ArgumentCoder<WebKit::BackgroundFetchState>::decode(Decoder& decoder)
{
    auto topOrigin = decoder.decode<WebCore::SecurityOriginData>();
    auto scope = decoder.decode<URL>();
    auto identifier = decoder.decode<String>();
    auto options = decoder.decode<WebCore::BackgroundFetchOptions>();
    auto downloadTotal = decoder.decode<uint64_t>();
    auto downloaded = decoder.decode<uint64_t>();
    auto uploadTotal = decoder.decode<uint64_t>();
    auto uploaded = decoder.decode<uint64_t>();
    auto result = decoder.decode<WebCore::BackgroundFetchResult>();
    auto failureReason = decoder.decode<WebCore::BackgroundFetchFailureReason>();
    auto isPaused = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::BackgroundFetchState {
            WTFMove(*topOrigin),
            WTFMove(*scope),
            WTFMove(*identifier),
            WTFMove(*options),
            WTFMove(*downloadTotal),
            WTFMove(*downloaded),
            WTFMove(*uploadTotal),
            WTFMove(*uploaded),
            WTFMove(*result),
            WTFMove(*failureReason),
            WTFMove(*isPaused)
        }
    };
}

void ArgumentCoder<WebKit::CallbackID>::encode(Encoder& encoder, const WebKit::CallbackID& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_id)>, uint64_t>);
    struct ShouldBeSameSizeAsCallbackID : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::CallbackID>, false> {
        uint64_t m_id;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCallbackID) == sizeof(WebKit::CallbackID));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::CallbackID, m_id)
    >::value);

    encoder << instance.m_id;
}

std::optional<WebKit::CallbackID> ArgumentCoder<WebKit::CallbackID>::decode(Decoder& decoder)
{
    auto m_id = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(WebKit::CallbackID::isValidCallbackID(*m_id)))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::CallbackID {
            WTFMove(*m_id)
        }
    };
}

void ArgumentCoder<WebKit::ContentWorldData>::encode(Encoder& encoder, const WebKit::ContentWorldData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, WebKit::ContentWorldIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.options)>, OptionSet<WebKit::ContentWorldOption>>);
    struct ShouldBeSameSizeAsContentWorldData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::ContentWorldData>, false> {
        WebKit::ContentWorldIdentifier identifier;
        String name;
        OptionSet<WebKit::ContentWorldOption> options;
    };
    static_assert(sizeof(ShouldBeSameSizeAsContentWorldData) == sizeof(WebKit::ContentWorldData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::ContentWorldData, identifier)
        , offsetof(WebKit::ContentWorldData, name)
        , offsetof(WebKit::ContentWorldData, options)
    >::value);

    encoder << instance.identifier;
    encoder << instance.name;
    encoder << instance.options;
}

std::optional<WebKit::ContentWorldData> ArgumentCoder<WebKit::ContentWorldData>::decode(Decoder& decoder)
{
    bool addedDecodingFailureIndex = false;
    auto identifier = decoder.decode<WebKit::ContentWorldIdentifier>();
    if (!identifier && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(0);
        addedDecodingFailureIndex = true;
    }
    auto name = decoder.decode<String>();
    if (!name && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(1);
        addedDecodingFailureIndex = true;
    }
    auto options = decoder.decode<OptionSet<WebKit::ContentWorldOption>>();
    if (!options && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(2);
        addedDecodingFailureIndex = true;
    }
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::ContentWorldData {
            WTFMove(*identifier),
            WTFMove(*name),
            WTFMove(*options)
        }
    };
}

#if ENABLE(CONTEXT_MENUS)
void ArgumentCoder<WebKit::ContextMenuContextData>::encode(Encoder& encoder, const WebKit::ContextMenuContextData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebCore::ContextMenuContextType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.menuLocation())>, WebCore::IntPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.menuItems())>, Vector<WebKit::WebContextMenuItemData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webHitTestResultData())>, std::optional<WebKit::WebHitTestResultData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selectedText())>, String>);
#if ENABLE(SERVICE_CONTROLS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.createControlledImageReadOnlyHandle())>, std::optional<WebCore::ShareableBitmapHandle>>);
#endif
#if ENABLE(SERVICE_CONTROLS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlledSelection())>, WebCore::AttributedString>);
#endif
#if ENABLE(SERVICE_CONTROLS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selectedTelephoneNumbers())>, Vector<String>>);
#endif
#if ENABLE(SERVICE_CONTROLS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selectionIsEditable())>, bool>);
#endif
#if ENABLE(SERVICE_CONTROLS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlledImageBounds())>, WebCore::IntRect>);
#endif
#if ENABLE(SERVICE_CONTROLS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlledImageAttachmentID())>, String>);
#endif
#if ENABLE(SERVICE_CONTROLS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlledImageElementContext())>, std::optional<WebCore::ElementContext>>);
#endif
#if ENABLE(SERVICE_CONTROLS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlledImageMIMEType())>, String>);
#endif
#if ENABLE(CONTEXT_MENU_QR_CODE_DETECTION)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.createPotentialQRCodeNodeSnapshotImageReadOnlyHandle())>, std::optional<WebCore::ShareableBitmapHandle>>);
#endif
#if ENABLE(CONTEXT_MENU_QR_CODE_DETECTION)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.createPotentialQRCodeViewportSnapshotImageReadOnlyHandle())>, std::optional<WebCore::ShareableBitmapHandle>>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasEntireImage())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowsFollowingLink())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowsFollowingImageURL())>, bool>);

    encoder << instance.type();
    encoder << instance.menuLocation();
    encoder << instance.menuItems();
    encoder << instance.webHitTestResultData();
    encoder << instance.selectedText();
#if ENABLE(SERVICE_CONTROLS)
    encoder << instance.createControlledImageReadOnlyHandle();
#endif
#if ENABLE(SERVICE_CONTROLS)
    encoder << instance.controlledSelection();
#endif
#if ENABLE(SERVICE_CONTROLS)
    encoder << instance.selectedTelephoneNumbers();
#endif
#if ENABLE(SERVICE_CONTROLS)
    encoder << instance.selectionIsEditable();
#endif
#if ENABLE(SERVICE_CONTROLS)
    encoder << instance.controlledImageBounds();
#endif
#if ENABLE(SERVICE_CONTROLS)
    encoder << instance.controlledImageAttachmentID();
#endif
#if ENABLE(SERVICE_CONTROLS)
    encoder << instance.controlledImageElementContext();
#endif
#if ENABLE(SERVICE_CONTROLS)
    encoder << instance.controlledImageMIMEType();
#endif
#if ENABLE(CONTEXT_MENU_QR_CODE_DETECTION)
    encoder << instance.createPotentialQRCodeNodeSnapshotImageReadOnlyHandle();
#endif
#if ENABLE(CONTEXT_MENU_QR_CODE_DETECTION)
    encoder << instance.createPotentialQRCodeViewportSnapshotImageReadOnlyHandle();
#endif
    encoder << instance.hasEntireImage();
    encoder << instance.allowsFollowingLink();
    encoder << instance.allowsFollowingImageURL();
}

std::optional<WebKit::ContextMenuContextData> ArgumentCoder<WebKit::ContextMenuContextData>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::ContextMenuContextType>();
    auto menuLocation = decoder.decode<WebCore::IntPoint>();
    auto menuItems = decoder.decode<Vector<WebKit::WebContextMenuItemData>>();
    auto webHitTestResultData = decoder.decode<std::optional<WebKit::WebHitTestResultData>>();
    auto selectedText = decoder.decode<String>();
#if ENABLE(SERVICE_CONTROLS)
    auto createControlledImageReadOnlyHandle = decoder.decode<std::optional<WebCore::ShareableBitmapHandle>>();
#endif
#if ENABLE(SERVICE_CONTROLS)
    auto controlledSelection = decoder.decode<WebCore::AttributedString>();
#endif
#if ENABLE(SERVICE_CONTROLS)
    auto selectedTelephoneNumbers = decoder.decode<Vector<String>>();
#endif
#if ENABLE(SERVICE_CONTROLS)
    auto selectionIsEditable = decoder.decode<bool>();
#endif
#if ENABLE(SERVICE_CONTROLS)
    auto controlledImageBounds = decoder.decode<WebCore::IntRect>();
#endif
#if ENABLE(SERVICE_CONTROLS)
    auto controlledImageAttachmentID = decoder.decode<String>();
#endif
#if ENABLE(SERVICE_CONTROLS)
    auto controlledImageElementContext = decoder.decode<std::optional<WebCore::ElementContext>>();
#endif
#if ENABLE(SERVICE_CONTROLS)
    auto controlledImageMIMEType = decoder.decode<String>();
#endif
#if ENABLE(CONTEXT_MENU_QR_CODE_DETECTION)
    auto createPotentialQRCodeNodeSnapshotImageReadOnlyHandle = decoder.decode<std::optional<WebCore::ShareableBitmapHandle>>();
#endif
#if ENABLE(CONTEXT_MENU_QR_CODE_DETECTION)
    auto createPotentialQRCodeViewportSnapshotImageReadOnlyHandle = decoder.decode<std::optional<WebCore::ShareableBitmapHandle>>();
#endif
    auto hasEntireImage = decoder.decode<bool>();
    auto allowsFollowingLink = decoder.decode<bool>();
    auto allowsFollowingImageURL = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::ContextMenuContextData {
            WTFMove(*type),
            WTFMove(*menuLocation),
            WTFMove(*menuItems),
            WTFMove(*webHitTestResultData),
            WTFMove(*selectedText),
#if ENABLE(SERVICE_CONTROLS)
            WTFMove(*createControlledImageReadOnlyHandle),
#endif
#if ENABLE(SERVICE_CONTROLS)
            WTFMove(*controlledSelection),
#endif
#if ENABLE(SERVICE_CONTROLS)
            WTFMove(*selectedTelephoneNumbers),
#endif
#if ENABLE(SERVICE_CONTROLS)
            WTFMove(*selectionIsEditable),
#endif
#if ENABLE(SERVICE_CONTROLS)
            WTFMove(*controlledImageBounds),
#endif
#if ENABLE(SERVICE_CONTROLS)
            WTFMove(*controlledImageAttachmentID),
#endif
#if ENABLE(SERVICE_CONTROLS)
            WTFMove(*controlledImageElementContext),
#endif
#if ENABLE(SERVICE_CONTROLS)
            WTFMove(*controlledImageMIMEType),
#endif
#if ENABLE(CONTEXT_MENU_QR_CODE_DETECTION)
            WTFMove(*createPotentialQRCodeNodeSnapshotImageReadOnlyHandle),
#endif
#if ENABLE(CONTEXT_MENU_QR_CODE_DETECTION)
            WTFMove(*createPotentialQRCodeViewportSnapshotImageReadOnlyHandle),
#endif
            WTFMove(*hasEntireImage),
            WTFMove(*allowsFollowingLink),
            WTFMove(*allowsFollowingImageURL)
        }
    };
}

#endif

void ArgumentCoder<WebKit::DebuggableInfoData>::encode(Encoder& encoder, const WebKit::DebuggableInfoData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.debuggableType)>, Inspector::DebuggableType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.targetPlatformName)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.targetBuildVersion)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.targetProductVersion)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.targetIsSimulator)>, bool>);
    struct ShouldBeSameSizeAsDebuggableInfoData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::DebuggableInfoData>, false> {
        Inspector::DebuggableType debuggableType;
        String targetPlatformName;
        String targetBuildVersion;
        String targetProductVersion;
        bool targetIsSimulator;
    };
    static_assert(sizeof(ShouldBeSameSizeAsDebuggableInfoData) == sizeof(WebKit::DebuggableInfoData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::DebuggableInfoData, debuggableType)
        , offsetof(WebKit::DebuggableInfoData, targetPlatformName)
        , offsetof(WebKit::DebuggableInfoData, targetBuildVersion)
        , offsetof(WebKit::DebuggableInfoData, targetProductVersion)
        , offsetof(WebKit::DebuggableInfoData, targetIsSimulator)
    >::value);

    encoder << instance.debuggableType;
    encoder << instance.targetPlatformName;
    encoder << instance.targetBuildVersion;
    encoder << instance.targetProductVersion;
    encoder << instance.targetIsSimulator;
}

std::optional<WebKit::DebuggableInfoData> ArgumentCoder<WebKit::DebuggableInfoData>::decode(Decoder& decoder)
{
    auto debuggableType = decoder.decode<Inspector::DebuggableType>();
    auto targetPlatformName = decoder.decode<String>();
    auto targetBuildVersion = decoder.decode<String>();
    auto targetProductVersion = decoder.decode<String>();
    auto targetIsSimulator = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::DebuggableInfoData {
            WTFMove(*debuggableType),
            WTFMove(*targetPlatformName),
            WTFMove(*targetBuildVersion),
            WTFMove(*targetProductVersion),
            WTFMove(*targetIsSimulator)
        }
    };
}

#if PLATFORM(IOS_FAMILY)
void ArgumentCoder<WebKit::DocumentEditingContext::Range>::encode(Encoder& encoder, const WebKit::DocumentEditingContext::Range& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.location)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.length)>, uint64_t>);
    struct ShouldBeSameSizeAsRange : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::DocumentEditingContext::Range>, false> {
        uint64_t location;
        uint64_t length;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRange) == sizeof(WebKit::DocumentEditingContext::Range));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::DocumentEditingContext::Range, location)
        , offsetof(WebKit::DocumentEditingContext::Range, length)
    >::value);

    encoder << instance.location;
    encoder << instance.length;
}

std::optional<WebKit::DocumentEditingContext::Range> ArgumentCoder<WebKit::DocumentEditingContext::Range>::decode(Decoder& decoder)
{
    auto location = decoder.decode<uint64_t>();
    auto length = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(!(CheckedUint64 { *location } + *length).hasOverflowed()))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::DocumentEditingContext::Range {
            WTFMove(*location),
            WTFMove(*length)
        }
    };
}

#endif

#if PLATFORM(IOS_FAMILY)
void ArgumentCoder<WebKit::DocumentEditingContext::TextRectAndRange>::encode(Encoder& encoder, const WebKit::DocumentEditingContext::TextRectAndRange& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rect)>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.range)>, WebKit::DocumentEditingContext::Range>);
    struct ShouldBeSameSizeAsTextRectAndRange : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::DocumentEditingContext::TextRectAndRange>, false> {
        WebCore::FloatRect rect;
        WebKit::DocumentEditingContext::Range range;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTextRectAndRange) == sizeof(WebKit::DocumentEditingContext::TextRectAndRange));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::DocumentEditingContext::TextRectAndRange, rect)
        , offsetof(WebKit::DocumentEditingContext::TextRectAndRange, range)
    >::value);

    encoder << instance.rect;
    encoder << instance.range;
}

std::optional<WebKit::DocumentEditingContext::TextRectAndRange> ArgumentCoder<WebKit::DocumentEditingContext::TextRectAndRange>::decode(Decoder& decoder)
{
    auto rect = decoder.decode<WebCore::FloatRect>();
    auto range = decoder.decode<WebKit::DocumentEditingContext::Range>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::DocumentEditingContext::TextRectAndRange {
            WTFMove(*rect),
            WTFMove(*range)
        }
    };
}

#endif

#if PLATFORM(IOS_FAMILY)
void ArgumentCoder<WebKit::DocumentEditingContextRequest>::encode(Encoder& encoder, const WebKit::DocumentEditingContextRequest& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.options)>, OptionSet<WebKit::DocumentEditingContextRequest::Options>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.surroundingGranularity)>, WebCore::TextGranularity>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.granularityCount)>, int64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rect)>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.textInputContext)>, std::optional<WebCore::ElementContext>>);
    struct ShouldBeSameSizeAsDocumentEditingContextRequest : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::DocumentEditingContextRequest>, false> {
        OptionSet<WebKit::DocumentEditingContextRequest::Options> options;
        WebCore::TextGranularity surroundingGranularity;
        int64_t granularityCount;
        WebCore::FloatRect rect;
        std::optional<WebCore::ElementContext> textInputContext;
    };
    static_assert(sizeof(ShouldBeSameSizeAsDocumentEditingContextRequest) == sizeof(WebKit::DocumentEditingContextRequest));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::DocumentEditingContextRequest, options)
        , offsetof(WebKit::DocumentEditingContextRequest, surroundingGranularity)
        , offsetof(WebKit::DocumentEditingContextRequest, granularityCount)
        , offsetof(WebKit::DocumentEditingContextRequest, rect)
        , offsetof(WebKit::DocumentEditingContextRequest, textInputContext)
    >::value);

    encoder << instance.options;
    encoder << instance.surroundingGranularity;
    encoder << instance.granularityCount;
    encoder << instance.rect;
    encoder << instance.textInputContext;
}

std::optional<WebKit::DocumentEditingContextRequest> ArgumentCoder<WebKit::DocumentEditingContextRequest>::decode(Decoder& decoder)
{
    auto options = decoder.decode<OptionSet<WebKit::DocumentEditingContextRequest::Options>>();
    auto surroundingGranularity = decoder.decode<WebCore::TextGranularity>();
    auto granularityCount = decoder.decode<int64_t>();
    auto rect = decoder.decode<WebCore::FloatRect>();
    auto textInputContext = decoder.decode<std::optional<WebCore::ElementContext>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::DocumentEditingContextRequest {
            WTFMove(*options),
            WTFMove(*surroundingGranularity),
            WTFMove(*granularityCount),
            WTFMove(*rect),
            WTFMove(*textInputContext)
        }
    };
}

#endif

#if PLATFORM(IOS_FAMILY)
void ArgumentCoder<WebKit::DocumentEditingContext>::encode(Encoder& encoder, const WebKit::DocumentEditingContext& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contextBefore)>, WebCore::AttributedString>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selectedText)>, WebCore::AttributedString>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contextAfter)>, WebCore::AttributedString>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.markedText)>, WebCore::AttributedString>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.annotatedText)>, WebCore::AttributedString>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selectedRangeInMarkedText)>, WebKit::DocumentEditingContext::Range>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.textRects)>, Vector<WebKit::DocumentEditingContext::TextRectAndRange>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.autocorrectedRanges)>, Vector<WebKit::DocumentEditingContext::Range>>);
    struct ShouldBeSameSizeAsDocumentEditingContext : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::DocumentEditingContext>, false> {
        WebCore::AttributedString contextBefore;
        WebCore::AttributedString selectedText;
        WebCore::AttributedString contextAfter;
        WebCore::AttributedString markedText;
        WebCore::AttributedString annotatedText;
        WebKit::DocumentEditingContext::Range selectedRangeInMarkedText;
        Vector<WebKit::DocumentEditingContext::TextRectAndRange> textRects;
        Vector<WebKit::DocumentEditingContext::Range> autocorrectedRanges;
    };
    static_assert(sizeof(ShouldBeSameSizeAsDocumentEditingContext) == sizeof(WebKit::DocumentEditingContext));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::DocumentEditingContext, contextBefore)
        , offsetof(WebKit::DocumentEditingContext, selectedText)
        , offsetof(WebKit::DocumentEditingContext, contextAfter)
        , offsetof(WebKit::DocumentEditingContext, markedText)
        , offsetof(WebKit::DocumentEditingContext, annotatedText)
        , offsetof(WebKit::DocumentEditingContext, selectedRangeInMarkedText)
        , offsetof(WebKit::DocumentEditingContext, textRects)
        , offsetof(WebKit::DocumentEditingContext, autocorrectedRanges)
    >::value);

    encoder << instance.contextBefore;
    encoder << instance.selectedText;
    encoder << instance.contextAfter;
    encoder << instance.markedText;
    encoder << instance.annotatedText;
    encoder << instance.selectedRangeInMarkedText;
    encoder << instance.textRects;
    encoder << instance.autocorrectedRanges;
}

std::optional<WebKit::DocumentEditingContext> ArgumentCoder<WebKit::DocumentEditingContext>::decode(Decoder& decoder)
{
    auto contextBefore = decoder.decode<WebCore::AttributedString>();
    auto selectedText = decoder.decode<WebCore::AttributedString>();
    auto contextAfter = decoder.decode<WebCore::AttributedString>();
    auto markedText = decoder.decode<WebCore::AttributedString>();
    auto annotatedText = decoder.decode<WebCore::AttributedString>();
    auto selectedRangeInMarkedText = decoder.decode<WebKit::DocumentEditingContext::Range>();
    auto textRects = decoder.decode<Vector<WebKit::DocumentEditingContext::TextRectAndRange>>();
    auto autocorrectedRanges = decoder.decode<Vector<WebKit::DocumentEditingContext::Range>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::DocumentEditingContext {
            WTFMove(*contextBefore),
            WTFMove(*selectedText),
            WTFMove(*contextAfter),
            WTFMove(*markedText),
            WTFMove(*annotatedText),
            WTFMove(*selectedRangeInMarkedText),
            WTFMove(*textRects),
            WTFMove(*autocorrectedRanges)
        }
    };
}

#endif

void ArgumentCoder<WebKit::EditingRange>::encode(Encoder& encoder, const WebKit::EditingRange& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.location)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.length)>, uint64_t>);
    struct ShouldBeSameSizeAsEditingRange : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::EditingRange>, false> {
        uint64_t location;
        uint64_t length;
    };
    static_assert(sizeof(ShouldBeSameSizeAsEditingRange) == sizeof(WebKit::EditingRange));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::EditingRange, location)
        , offsetof(WebKit::EditingRange, length)
    >::value);

    encoder << instance.location;
    encoder << instance.length;
}

std::optional<WebKit::EditingRange> ArgumentCoder<WebKit::EditingRange>::decode(Decoder& decoder)
{
    auto location = decoder.decode<uint64_t>();
    auto length = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(!(Checked<uint64_t> { *location } + *length).hasOverflowed()))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::EditingRange {
            WTFMove(*location),
            WTFMove(*length)
        }
    };
}

void ArgumentCoder<WebKit::EditorState>::encode(Encoder& encoder, const WebKit::EditorState& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, WebKit::EditorStateIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldIgnoreSelectionChanges)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selectionIsNone)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selectionIsRange)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selectionIsRangeInsideImageOverlay)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selectionIsRangeInAutoFilledAndViewableField)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isContentEditable)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isContentRichlyEditable)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isInPasswordField)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasComposition)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.triggeredByAccessibilitySelectionChange)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isInPlugin)>, bool>);
#if PLATFORM(MAC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.canEnableAutomaticSpellingCorrection)>, bool>);
#endif
#if PLATFORM(MAC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.inputMethodUsesCorrectKeyEventOrder)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.postLayoutData)>, std::optional<WebKit::EditorState::PostLayoutData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.visualData)>, std::optional<WebKit::EditorState::VisualData>>);
    struct ShouldBeSameSizeAsEditorState : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::EditorState>, false> {
        WebKit::EditorStateIdentifier identifier;
        bool shouldIgnoreSelectionChanges;
        bool selectionIsNone;
        bool selectionIsRange;
        bool selectionIsRangeInsideImageOverlay;
        bool selectionIsRangeInAutoFilledAndViewableField;
        bool isContentEditable;
        bool isContentRichlyEditable;
        bool isInPasswordField;
        bool hasComposition;
        bool triggeredByAccessibilitySelectionChange;
        bool isInPlugin;
#if PLATFORM(MAC)
        bool canEnableAutomaticSpellingCorrection;
#endif
#if PLATFORM(MAC)
        bool inputMethodUsesCorrectKeyEventOrder;
#endif
        std::optional<WebKit::EditorState::PostLayoutData> postLayoutData;
        std::optional<WebKit::EditorState::VisualData> visualData;
    };
    static_assert(sizeof(ShouldBeSameSizeAsEditorState) == sizeof(WebKit::EditorState));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::EditorState, identifier)
        , offsetof(WebKit::EditorState, shouldIgnoreSelectionChanges)
        , offsetof(WebKit::EditorState, selectionIsNone)
        , offsetof(WebKit::EditorState, selectionIsRange)
        , offsetof(WebKit::EditorState, selectionIsRangeInsideImageOverlay)
        , offsetof(WebKit::EditorState, selectionIsRangeInAutoFilledAndViewableField)
        , offsetof(WebKit::EditorState, isContentEditable)
        , offsetof(WebKit::EditorState, isContentRichlyEditable)
        , offsetof(WebKit::EditorState, isInPasswordField)
        , offsetof(WebKit::EditorState, hasComposition)
        , offsetof(WebKit::EditorState, triggeredByAccessibilitySelectionChange)
        , offsetof(WebKit::EditorState, isInPlugin)
#if PLATFORM(MAC)
        , offsetof(WebKit::EditorState, canEnableAutomaticSpellingCorrection)
#endif
#if PLATFORM(MAC)
        , offsetof(WebKit::EditorState, inputMethodUsesCorrectKeyEventOrder)
#endif
        , offsetof(WebKit::EditorState, postLayoutData)
        , offsetof(WebKit::EditorState, visualData)
    >::value);

    encoder << instance.identifier;
    encoder << instance.shouldIgnoreSelectionChanges;
    encoder << instance.selectionIsNone;
    encoder << instance.selectionIsRange;
    encoder << instance.selectionIsRangeInsideImageOverlay;
    encoder << instance.selectionIsRangeInAutoFilledAndViewableField;
    encoder << instance.isContentEditable;
    encoder << instance.isContentRichlyEditable;
    encoder << instance.isInPasswordField;
    encoder << instance.hasComposition;
    encoder << instance.triggeredByAccessibilitySelectionChange;
    encoder << instance.isInPlugin;
#if PLATFORM(MAC)
    encoder << instance.canEnableAutomaticSpellingCorrection;
#endif
#if PLATFORM(MAC)
    encoder << instance.inputMethodUsesCorrectKeyEventOrder;
#endif
    encoder << instance.postLayoutData;
    encoder << instance.visualData;
}

std::optional<WebKit::EditorState> ArgumentCoder<WebKit::EditorState>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<WebKit::EditorStateIdentifier>();
    auto shouldIgnoreSelectionChanges = decoder.decode<bool>();
    auto selectionIsNone = decoder.decode<bool>();
    auto selectionIsRange = decoder.decode<bool>();
    auto selectionIsRangeInsideImageOverlay = decoder.decode<bool>();
    auto selectionIsRangeInAutoFilledAndViewableField = decoder.decode<bool>();
    auto isContentEditable = decoder.decode<bool>();
    auto isContentRichlyEditable = decoder.decode<bool>();
    auto isInPasswordField = decoder.decode<bool>();
    auto hasComposition = decoder.decode<bool>();
    auto triggeredByAccessibilitySelectionChange = decoder.decode<bool>();
    auto isInPlugin = decoder.decode<bool>();
#if PLATFORM(MAC)
    auto canEnableAutomaticSpellingCorrection = decoder.decode<bool>();
#endif
#if PLATFORM(MAC)
    auto inputMethodUsesCorrectKeyEventOrder = decoder.decode<bool>();
#endif
    auto postLayoutData = decoder.decode<std::optional<WebKit::EditorState::PostLayoutData>>();
    auto visualData = decoder.decode<std::optional<WebKit::EditorState::VisualData>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::EditorState {
            WTFMove(*identifier),
            WTFMove(*shouldIgnoreSelectionChanges),
            WTFMove(*selectionIsNone),
            WTFMove(*selectionIsRange),
            WTFMove(*selectionIsRangeInsideImageOverlay),
            WTFMove(*selectionIsRangeInAutoFilledAndViewableField),
            WTFMove(*isContentEditable),
            WTFMove(*isContentRichlyEditable),
            WTFMove(*isInPasswordField),
            WTFMove(*hasComposition),
            WTFMove(*triggeredByAccessibilitySelectionChange),
            WTFMove(*isInPlugin),
#if PLATFORM(MAC)
            WTFMove(*canEnableAutomaticSpellingCorrection),
#endif
#if PLATFORM(MAC)
            WTFMove(*inputMethodUsesCorrectKeyEventOrder),
#endif
            WTFMove(*postLayoutData),
            WTFMove(*visualData)
        }
    };
}

void ArgumentCoder<WebKit::EditorState::PostLayoutData>::encode(Encoder& encoder, const WebKit::EditorState::PostLayoutData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.typingAttributes)>, OptionSet<WebKit::TypingAttribute>>);
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selectedTextLength)>, uint64_t>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.textAlignment)>, WebKit::TextAlignment>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.textColor)>, WebCore::Color>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.enclosingListType)>, WebKit::ListType>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.baseWritingDirection)>, WebCore::WritingDirection>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selectionIsTransparentOrFullyClipped)>, bool>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.canEnableWritingSuggestions)>, bool>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.markedText)>, String>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.wordAtSelection)>, String>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.characterAfterSelection)>, char32_t>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.characterBeforeSelection)>, char32_t>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.twoCharacterBeforeSelection)>, char32_t>);
#endif
#if PLATFORM(IOS_FAMILY) && USE(DICTATION_ALTERNATIVES)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dictationContextsForSelection)>, Vector<WebCore::DictationContext>>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isReplaceAllowed)>, bool>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasContent)>, bool>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isStableStateUpdate)>, bool>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.insideFixedPosition)>, bool>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasPlainText)>, bool>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.caretColor)>, WebCore::Color>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasCaretColorAuto)>, bool>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.atStartOfSentence)>, bool>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selectionStartIsAtParagraphBoundary)>, bool>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selectionEndIsAtParagraphBoundary)>, bool>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasGrammarDocumentMarkers)>, bool>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selectedEditableImage)>, std::optional<WebCore::ElementContext>>);
#endif
#if PLATFORM(MAC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selectionBoundingRect)>, WebCore::IntRect>);
#endif
#if PLATFORM(MAC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.candidateRequestStartPosition)>, uint64_t>);
#endif
#if PLATFORM(MAC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.paragraphContextForCandidateRequest)>, String>);
#endif
#if PLATFORM(MAC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stringForCandidateRequest)>, String>);
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.surroundingContext)>, String>);
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.surroundingContextCursorPosition)>, uint64_t>);
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.surroundingContextSelectionPosition)>, uint64_t>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fontAttributes)>, std::optional<WebCore::FontAttributes>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.canCut)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.canCopy)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.canPaste)>, bool>);
    struct ShouldBeSameSizeAsPostLayoutData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::EditorState::PostLayoutData>, false> {
        OptionSet<WebKit::TypingAttribute> typingAttributes;
#if PLATFORM(COCOA)
        uint64_t selectedTextLength;
#endif
#if PLATFORM(COCOA)
        WebKit::TextAlignment textAlignment;
#endif
#if PLATFORM(COCOA)
        WebCore::Color textColor;
#endif
#if PLATFORM(COCOA)
        WebKit::ListType enclosingListType;
#endif
#if PLATFORM(COCOA)
        WebCore::WritingDirection baseWritingDirection;
#endif
#if PLATFORM(COCOA)
        bool selectionIsTransparentOrFullyClipped;
#endif
#if PLATFORM(COCOA)
        bool canEnableWritingSuggestions;
#endif
#if PLATFORM(IOS_FAMILY)
        String markedText;
#endif
#if PLATFORM(IOS_FAMILY)
        String wordAtSelection;
#endif
#if PLATFORM(IOS_FAMILY)
        char32_t characterAfterSelection;
#endif
#if PLATFORM(IOS_FAMILY)
        char32_t characterBeforeSelection;
#endif
#if PLATFORM(IOS_FAMILY)
        char32_t twoCharacterBeforeSelection;
#endif
#if PLATFORM(IOS_FAMILY) && USE(DICTATION_ALTERNATIVES)
        Vector<WebCore::DictationContext> dictationContextsForSelection;
#endif
#if PLATFORM(IOS_FAMILY)
        bool isReplaceAllowed;
#endif
#if PLATFORM(IOS_FAMILY)
        bool hasContent;
#endif
#if PLATFORM(IOS_FAMILY)
        bool isStableStateUpdate;
#endif
#if PLATFORM(IOS_FAMILY)
        bool insideFixedPosition;
#endif
#if PLATFORM(IOS_FAMILY)
        bool hasPlainText;
#endif
#if PLATFORM(IOS_FAMILY)
        WebCore::Color caretColor;
#endif
#if PLATFORM(IOS_FAMILY)
        bool hasCaretColorAuto;
#endif
#if PLATFORM(IOS_FAMILY)
        bool atStartOfSentence;
#endif
#if PLATFORM(IOS_FAMILY)
        bool selectionStartIsAtParagraphBoundary;
#endif
#if PLATFORM(IOS_FAMILY)
        bool selectionEndIsAtParagraphBoundary;
#endif
#if PLATFORM(IOS_FAMILY)
        bool hasGrammarDocumentMarkers;
#endif
#if PLATFORM(IOS_FAMILY)
        std::optional<WebCore::ElementContext> selectedEditableImage;
#endif
#if PLATFORM(MAC)
        WebCore::IntRect selectionBoundingRect;
#endif
#if PLATFORM(MAC)
        uint64_t candidateRequestStartPosition;
#endif
#if PLATFORM(MAC)
        String paragraphContextForCandidateRequest;
#endif
#if PLATFORM(MAC)
        String stringForCandidateRequest;
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
        String surroundingContext;
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
        uint64_t surroundingContextCursorPosition;
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
        uint64_t surroundingContextSelectionPosition;
#endif
        std::optional<WebCore::FontAttributes> fontAttributes;
        bool canCut;
        bool canCopy;
        bool canPaste;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPostLayoutData) == sizeof(WebKit::EditorState::PostLayoutData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::EditorState::PostLayoutData, typingAttributes)
#if PLATFORM(COCOA)
        , offsetof(WebKit::EditorState::PostLayoutData, selectedTextLength)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::EditorState::PostLayoutData, textAlignment)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::EditorState::PostLayoutData, textColor)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::EditorState::PostLayoutData, enclosingListType)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::EditorState::PostLayoutData, baseWritingDirection)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::EditorState::PostLayoutData, selectionIsTransparentOrFullyClipped)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::EditorState::PostLayoutData, canEnableWritingSuggestions)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::PostLayoutData, markedText)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::PostLayoutData, wordAtSelection)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::PostLayoutData, characterAfterSelection)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::PostLayoutData, characterBeforeSelection)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::PostLayoutData, twoCharacterBeforeSelection)
#endif
#if PLATFORM(IOS_FAMILY) && USE(DICTATION_ALTERNATIVES)
        , offsetof(WebKit::EditorState::PostLayoutData, dictationContextsForSelection)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::PostLayoutData, isReplaceAllowed)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::PostLayoutData, hasContent)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::PostLayoutData, isStableStateUpdate)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::PostLayoutData, insideFixedPosition)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::PostLayoutData, hasPlainText)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::PostLayoutData, caretColor)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::PostLayoutData, hasCaretColorAuto)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::PostLayoutData, atStartOfSentence)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::PostLayoutData, selectionStartIsAtParagraphBoundary)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::PostLayoutData, selectionEndIsAtParagraphBoundary)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::PostLayoutData, hasGrammarDocumentMarkers)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::PostLayoutData, selectedEditableImage)
#endif
#if PLATFORM(MAC)
        , offsetof(WebKit::EditorState::PostLayoutData, selectionBoundingRect)
#endif
#if PLATFORM(MAC)
        , offsetof(WebKit::EditorState::PostLayoutData, candidateRequestStartPosition)
#endif
#if PLATFORM(MAC)
        , offsetof(WebKit::EditorState::PostLayoutData, paragraphContextForCandidateRequest)
#endif
#if PLATFORM(MAC)
        , offsetof(WebKit::EditorState::PostLayoutData, stringForCandidateRequest)
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
        , offsetof(WebKit::EditorState::PostLayoutData, surroundingContext)
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
        , offsetof(WebKit::EditorState::PostLayoutData, surroundingContextCursorPosition)
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
        , offsetof(WebKit::EditorState::PostLayoutData, surroundingContextSelectionPosition)
#endif
        , offsetof(WebKit::EditorState::PostLayoutData, fontAttributes)
        , offsetof(WebKit::EditorState::PostLayoutData, canCut)
        , offsetof(WebKit::EditorState::PostLayoutData, canCopy)
        , offsetof(WebKit::EditorState::PostLayoutData, canPaste)
    >::value);

    encoder << instance.typingAttributes;
#if PLATFORM(COCOA)
    encoder << instance.selectedTextLength;
#endif
#if PLATFORM(COCOA)
    encoder << instance.textAlignment;
#endif
#if PLATFORM(COCOA)
    encoder << instance.textColor;
#endif
#if PLATFORM(COCOA)
    encoder << instance.enclosingListType;
#endif
#if PLATFORM(COCOA)
    encoder << instance.baseWritingDirection;
#endif
#if PLATFORM(COCOA)
    encoder << instance.selectionIsTransparentOrFullyClipped;
#endif
#if PLATFORM(COCOA)
    encoder << instance.canEnableWritingSuggestions;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.markedText;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.wordAtSelection;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.characterAfterSelection;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.characterBeforeSelection;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.twoCharacterBeforeSelection;
#endif
#if PLATFORM(IOS_FAMILY) && USE(DICTATION_ALTERNATIVES)
    encoder << instance.dictationContextsForSelection;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.isReplaceAllowed;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.hasContent;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.isStableStateUpdate;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.insideFixedPosition;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.hasPlainText;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.caretColor;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.hasCaretColorAuto;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.atStartOfSentence;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.selectionStartIsAtParagraphBoundary;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.selectionEndIsAtParagraphBoundary;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.hasGrammarDocumentMarkers;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.selectedEditableImage;
#endif
#if PLATFORM(MAC)
    encoder << instance.selectionBoundingRect;
#endif
#if PLATFORM(MAC)
    encoder << instance.candidateRequestStartPosition;
#endif
#if PLATFORM(MAC)
    encoder << instance.paragraphContextForCandidateRequest;
#endif
#if PLATFORM(MAC)
    encoder << instance.stringForCandidateRequest;
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    encoder << instance.surroundingContext;
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    encoder << instance.surroundingContextCursorPosition;
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    encoder << instance.surroundingContextSelectionPosition;
#endif
    encoder << instance.fontAttributes;
    encoder << instance.canCut;
    encoder << instance.canCopy;
    encoder << instance.canPaste;
}

std::optional<WebKit::EditorState::PostLayoutData> ArgumentCoder<WebKit::EditorState::PostLayoutData>::decode(Decoder& decoder)
{
    auto typingAttributes = decoder.decode<OptionSet<WebKit::TypingAttribute>>();
#if PLATFORM(COCOA)
    auto selectedTextLength = decoder.decode<uint64_t>();
#endif
#if PLATFORM(COCOA)
    auto textAlignment = decoder.decode<WebKit::TextAlignment>();
#endif
#if PLATFORM(COCOA)
    auto textColor = decoder.decode<WebCore::Color>();
#endif
#if PLATFORM(COCOA)
    auto enclosingListType = decoder.decode<WebKit::ListType>();
#endif
#if PLATFORM(COCOA)
    auto baseWritingDirection = decoder.decode<WebCore::WritingDirection>();
#endif
#if PLATFORM(COCOA)
    auto selectionIsTransparentOrFullyClipped = decoder.decode<bool>();
#endif
#if PLATFORM(COCOA)
    auto canEnableWritingSuggestions = decoder.decode<bool>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto markedText = decoder.decode<String>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto wordAtSelection = decoder.decode<String>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto characterAfterSelection = decoder.decode<char32_t>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto characterBeforeSelection = decoder.decode<char32_t>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto twoCharacterBeforeSelection = decoder.decode<char32_t>();
#endif
#if PLATFORM(IOS_FAMILY) && USE(DICTATION_ALTERNATIVES)
    auto dictationContextsForSelection = decoder.decode<Vector<WebCore::DictationContext>>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto isReplaceAllowed = decoder.decode<bool>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto hasContent = decoder.decode<bool>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto isStableStateUpdate = decoder.decode<bool>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto insideFixedPosition = decoder.decode<bool>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto hasPlainText = decoder.decode<bool>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto caretColor = decoder.decode<WebCore::Color>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto hasCaretColorAuto = decoder.decode<bool>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto atStartOfSentence = decoder.decode<bool>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto selectionStartIsAtParagraphBoundary = decoder.decode<bool>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto selectionEndIsAtParagraphBoundary = decoder.decode<bool>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto hasGrammarDocumentMarkers = decoder.decode<bool>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto selectedEditableImage = decoder.decode<std::optional<WebCore::ElementContext>>();
#endif
#if PLATFORM(MAC)
    auto selectionBoundingRect = decoder.decode<WebCore::IntRect>();
#endif
#if PLATFORM(MAC)
    auto candidateRequestStartPosition = decoder.decode<uint64_t>();
#endif
#if PLATFORM(MAC)
    auto paragraphContextForCandidateRequest = decoder.decode<String>();
#endif
#if PLATFORM(MAC)
    auto stringForCandidateRequest = decoder.decode<String>();
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    auto surroundingContext = decoder.decode<String>();
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    auto surroundingContextCursorPosition = decoder.decode<uint64_t>();
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    auto surroundingContextSelectionPosition = decoder.decode<uint64_t>();
#endif
    auto fontAttributes = decoder.decode<std::optional<WebCore::FontAttributes>>();
    auto canCut = decoder.decode<bool>();
    auto canCopy = decoder.decode<bool>();
    auto canPaste = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::EditorState::PostLayoutData {
            WTFMove(*typingAttributes),
#if PLATFORM(COCOA)
            WTFMove(*selectedTextLength),
#endif
#if PLATFORM(COCOA)
            WTFMove(*textAlignment),
#endif
#if PLATFORM(COCOA)
            WTFMove(*textColor),
#endif
#if PLATFORM(COCOA)
            WTFMove(*enclosingListType),
#endif
#if PLATFORM(COCOA)
            WTFMove(*baseWritingDirection),
#endif
#if PLATFORM(COCOA)
            WTFMove(*selectionIsTransparentOrFullyClipped),
#endif
#if PLATFORM(COCOA)
            WTFMove(*canEnableWritingSuggestions),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*markedText),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*wordAtSelection),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*characterAfterSelection),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*characterBeforeSelection),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*twoCharacterBeforeSelection),
#endif
#if PLATFORM(IOS_FAMILY) && USE(DICTATION_ALTERNATIVES)
            WTFMove(*dictationContextsForSelection),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*isReplaceAllowed),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*hasContent),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*isStableStateUpdate),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*insideFixedPosition),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*hasPlainText),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*caretColor),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*hasCaretColorAuto),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*atStartOfSentence),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*selectionStartIsAtParagraphBoundary),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*selectionEndIsAtParagraphBoundary),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*hasGrammarDocumentMarkers),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*selectedEditableImage),
#endif
#if PLATFORM(MAC)
            WTFMove(*selectionBoundingRect),
#endif
#if PLATFORM(MAC)
            WTFMove(*candidateRequestStartPosition),
#endif
#if PLATFORM(MAC)
            WTFMove(*paragraphContextForCandidateRequest),
#endif
#if PLATFORM(MAC)
            WTFMove(*stringForCandidateRequest),
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
            WTFMove(*surroundingContext),
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
            WTFMove(*surroundingContextCursorPosition),
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
            WTFMove(*surroundingContextSelectionPosition),
#endif
            WTFMove(*fontAttributes),
            WTFMove(*canCut),
            WTFMove(*canCopy),
            WTFMove(*canPaste)
        }
    };
}

void ArgumentCoder<WebKit::EditorState::VisualData>::encode(Encoder& encoder, const WebKit::EditorState::VisualData& instance)
{
#if PLATFORM(IOS_FAMILY) || PLATFORM(GTK) || PLATFORM(WPE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.caretRectAtStart)>, WebCore::IntRect>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selectionClipRect)>, WebCore::IntRect>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.editableRootBounds)>, WebCore::IntRect>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.caretRectAtEnd)>, WebCore::IntRect>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selectionGeometries)>, Vector<WebCore::SelectionGeometry>>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.markedTextRects)>, Vector<WebCore::SelectionGeometry>>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.markedTextCaretRectAtStart)>, WebCore::IntRect>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.markedTextCaretRectAtEnd)>, WebCore::IntRect>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.enclosingLayerID)>, std::optional<WebCore::PlatformLayerIdentifier>>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.intersectingLayerIDs)>, Vector<WebCore::PlatformLayerIdentifier>>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.enclosingScrollingNodeID)>, std::optional<WebCore::ScrollingNodeID>>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scrollingNodeIDAtStart)>, std::optional<WebCore::ScrollingNodeID>>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scrollingNodeIDAtEnd)>, std::optional<WebCore::ScrollingNodeID>>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.enclosingScrollOffset)>, WebCore::ScrollOffset>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.enclosingLayerUsesContentsLayer)>, bool>);
#endif
    struct ShouldBeSameSizeAsVisualData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::EditorState::VisualData>, false> {
#if PLATFORM(IOS_FAMILY) || PLATFORM(GTK) || PLATFORM(WPE)
        WebCore::IntRect caretRectAtStart;
#endif
#if PLATFORM(IOS_FAMILY)
        WebCore::IntRect selectionClipRect;
#endif
#if PLATFORM(IOS_FAMILY)
        WebCore::IntRect editableRootBounds;
#endif
#if PLATFORM(IOS_FAMILY)
        WebCore::IntRect caretRectAtEnd;
#endif
#if PLATFORM(IOS_FAMILY)
        Vector<WebCore::SelectionGeometry> selectionGeometries;
#endif
#if PLATFORM(IOS_FAMILY)
        Vector<WebCore::SelectionGeometry> markedTextRects;
#endif
#if PLATFORM(IOS_FAMILY)
        WebCore::IntRect markedTextCaretRectAtStart;
#endif
#if PLATFORM(IOS_FAMILY)
        WebCore::IntRect markedTextCaretRectAtEnd;
#endif
#if PLATFORM(IOS_FAMILY)
        std::optional<WebCore::PlatformLayerIdentifier> enclosingLayerID;
#endif
#if PLATFORM(IOS_FAMILY)
        Vector<WebCore::PlatformLayerIdentifier> intersectingLayerIDs;
#endif
#if PLATFORM(IOS_FAMILY)
        std::optional<WebCore::ScrollingNodeID> enclosingScrollingNodeID;
#endif
#if PLATFORM(IOS_FAMILY)
        std::optional<WebCore::ScrollingNodeID> scrollingNodeIDAtStart;
#endif
#if PLATFORM(IOS_FAMILY)
        std::optional<WebCore::ScrollingNodeID> scrollingNodeIDAtEnd;
#endif
#if PLATFORM(IOS_FAMILY)
        WebCore::ScrollOffset enclosingScrollOffset;
#endif
#if PLATFORM(IOS_FAMILY)
        bool enclosingLayerUsesContentsLayer;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsVisualData) == sizeof(WebKit::EditorState::VisualData));
    static_assert(MembersInCorrectOrder < 0
#if PLATFORM(IOS_FAMILY) || PLATFORM(GTK) || PLATFORM(WPE)
        , offsetof(WebKit::EditorState::VisualData, caretRectAtStart)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::VisualData, selectionClipRect)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::VisualData, editableRootBounds)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::VisualData, caretRectAtEnd)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::VisualData, selectionGeometries)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::VisualData, markedTextRects)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::VisualData, markedTextCaretRectAtStart)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::VisualData, markedTextCaretRectAtEnd)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::VisualData, enclosingLayerID)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::VisualData, intersectingLayerIDs)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::VisualData, enclosingScrollingNodeID)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::VisualData, scrollingNodeIDAtStart)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::VisualData, scrollingNodeIDAtEnd)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::VisualData, enclosingScrollOffset)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::EditorState::VisualData, enclosingLayerUsesContentsLayer)
#endif
    >::value);

#if PLATFORM(IOS_FAMILY) || PLATFORM(GTK) || PLATFORM(WPE)
    encoder << instance.caretRectAtStart;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.selectionClipRect;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.editableRootBounds;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.caretRectAtEnd;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.selectionGeometries;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.markedTextRects;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.markedTextCaretRectAtStart;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.markedTextCaretRectAtEnd;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.enclosingLayerID;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.intersectingLayerIDs;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.enclosingScrollingNodeID;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.scrollingNodeIDAtStart;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.scrollingNodeIDAtEnd;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.enclosingScrollOffset;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.enclosingLayerUsesContentsLayer;
#endif
}

std::optional<WebKit::EditorState::VisualData> ArgumentCoder<WebKit::EditorState::VisualData>::decode(Decoder& decoder)
{
#if PLATFORM(IOS_FAMILY) || PLATFORM(GTK) || PLATFORM(WPE)
    auto caretRectAtStart = decoder.decode<WebCore::IntRect>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto selectionClipRect = decoder.decode<WebCore::IntRect>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto editableRootBounds = decoder.decode<WebCore::IntRect>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto caretRectAtEnd = decoder.decode<WebCore::IntRect>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto selectionGeometries = decoder.decode<Vector<WebCore::SelectionGeometry>>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto markedTextRects = decoder.decode<Vector<WebCore::SelectionGeometry>>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto markedTextCaretRectAtStart = decoder.decode<WebCore::IntRect>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto markedTextCaretRectAtEnd = decoder.decode<WebCore::IntRect>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto enclosingLayerID = decoder.decode<std::optional<WebCore::PlatformLayerIdentifier>>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto intersectingLayerIDs = decoder.decode<Vector<WebCore::PlatformLayerIdentifier>>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto enclosingScrollingNodeID = decoder.decode<std::optional<WebCore::ScrollingNodeID>>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto scrollingNodeIDAtStart = decoder.decode<std::optional<WebCore::ScrollingNodeID>>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto scrollingNodeIDAtEnd = decoder.decode<std::optional<WebCore::ScrollingNodeID>>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto enclosingScrollOffset = decoder.decode<WebCore::ScrollOffset>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto enclosingLayerUsesContentsLayer = decoder.decode<bool>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::EditorState::VisualData {
#if PLATFORM(IOS_FAMILY) || PLATFORM(GTK) || PLATFORM(WPE)
            WTFMove(*caretRectAtStart),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*selectionClipRect),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*editableRootBounds),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*caretRectAtEnd),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*selectionGeometries),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*markedTextRects),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*markedTextCaretRectAtStart),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*markedTextCaretRectAtEnd),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*enclosingLayerID),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*intersectingLayerIDs),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*enclosingScrollingNodeID),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*scrollingNodeIDAtStart),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*scrollingNodeIDAtEnd),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*enclosingScrollOffset),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*enclosingLayerUsesContentsLayer)
#endif
        }
    };
}

void ArgumentCoder<WebKit::FileSystemSyncAccessHandleInfo>::encode(Encoder& encoder, const WebKit::FileSystemSyncAccessHandleInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, Markable<WebCore::FileSystemSyncAccessHandleIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.handle)>, IPC::SharedFileHandle>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.capacity)>, uint64_t>);
    struct ShouldBeSameSizeAsFileSystemSyncAccessHandleInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::FileSystemSyncAccessHandleInfo>, false> {
        Markable<WebCore::FileSystemSyncAccessHandleIdentifier> identifier;
        IPC::SharedFileHandle handle;
        uint64_t capacity;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFileSystemSyncAccessHandleInfo) == sizeof(WebKit::FileSystemSyncAccessHandleInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::FileSystemSyncAccessHandleInfo, identifier)
        , offsetof(WebKit::FileSystemSyncAccessHandleInfo, handle)
        , offsetof(WebKit::FileSystemSyncAccessHandleInfo, capacity)
    >::value);

    encoder << instance.identifier;
    encoder << instance.handle;
    encoder << instance.capacity;
}

std::optional<WebKit::FileSystemSyncAccessHandleInfo> ArgumentCoder<WebKit::FileSystemSyncAccessHandleInfo>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<Markable<WebCore::FileSystemSyncAccessHandleIdentifier>>();
    auto handle = decoder.decode<IPC::SharedFileHandle>();
    auto capacity = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::FileSystemSyncAccessHandleInfo {
            WTFMove(*identifier),
            WTFMove(*handle),
            WTFMove(*capacity)
        }
    };
}

#if PLATFORM(IOS_FAMILY)
void ArgumentCoder<WebKit::OptionItem>::encode(Encoder& encoder, const WebKit::OptionItem& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.text)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isGroup)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isSelected)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.disabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.parentGroupID)>, int>);
    struct ShouldBeSameSizeAsOptionItem : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::OptionItem>, false> {
        String text;
        bool isGroup;
        bool isSelected;
        bool disabled;
        int parentGroupID;
    };
    static_assert(sizeof(ShouldBeSameSizeAsOptionItem) == sizeof(WebKit::OptionItem));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::OptionItem, text)
        , offsetof(WebKit::OptionItem, isGroup)
        , offsetof(WebKit::OptionItem, isSelected)
        , offsetof(WebKit::OptionItem, disabled)
        , offsetof(WebKit::OptionItem, parentGroupID)
    >::value);

    encoder << instance.text;
    encoder << instance.isGroup;
    encoder << instance.isSelected;
    encoder << instance.disabled;
    encoder << instance.parentGroupID;
}

std::optional<WebKit::OptionItem> ArgumentCoder<WebKit::OptionItem>::decode(Decoder& decoder)
{
    auto text = decoder.decode<String>();
    auto isGroup = decoder.decode<bool>();
    auto isSelected = decoder.decode<bool>();
    auto disabled = decoder.decode<bool>();
    auto parentGroupID = decoder.decode<int>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::OptionItem {
            WTFMove(*text),
            WTFMove(*isGroup),
            WTFMove(*isSelected),
            WTFMove(*disabled),
            WTFMove(*parentGroupID)
        }
    };
}

#endif

#if PLATFORM(IOS_FAMILY)
void ArgumentCoder<WebKit::FocusedElementInformation>::encode(Encoder& encoder, const WebKit::FocusedElementInformation& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.interactionRect)>, WebCore::IntRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.elementContext)>, WebCore::ElementContext>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lastInteractionLocation)>, WebCore::IntPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.minimumScaleFactor)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maximumScaleFactor)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maximumScaleFactorIgnoringAlwaysScalable)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.nodeFontSize)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasNextNode)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.nextNodeRect)>, WebCore::IntRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasPreviousNode)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.previousNodeRect)>, WebCore::IntRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isAutocorrect)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isRTL)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isMultiSelect)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isReadOnly)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowsUserScaling)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowsUserScalingIgnoringAlwaysScalable)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.insideFixedPosition)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasPlainText)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.autocapitalizeType)>, WebCore::AutocapitalizeType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.elementType)>, WebKit::InputType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.inputMode)>, WebCore::InputMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.enterKeyHint)>, WebCore::EnterKeyHint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.formAction)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selectOptions)>, Vector<WebKit::OptionItem>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selectedIndex)>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.valueAsNumber)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.title)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.acceptsAutofilledLoginCredentials)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isAutofillableUsernameField)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.representingPageURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.autofillFieldName)>, WebCore::AutofillFieldName>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.nonAutofillCredentialType)>, WebCore::NonAutofillCredentialType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.placeholder)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ariaLabel)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasSuggestions)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isFocusingWithDataListDropdown)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorValue)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsAlpha)>, WebKit::ColorControlSupportsAlpha>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.suggestedColors)>, Vector<WebCore::Color>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasEverBeenPasswordField)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldSynthesizeKeyEventsForEditing)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isSpellCheckingEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isWritingSuggestionsEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldAvoidResizingWhenInputViewBoundsChange)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldAvoidScrollingWhenFocusedContentIsVisible)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldUseLegacySelectPopoverDismissalBehaviorInDataActivation)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldHideSoftTopScrollEdgeEffect)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isFocusingWithValidationMessage)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.preventScroll)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, WebKit::FocusedElementInformationIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.containerScrollingNodeID)>, Markable<WebCore::ScrollingNodeID>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frame)>, std::optional<WebKit::FrameInfoData>>);
    struct ShouldBeSameSizeAsFocusedElementInformation : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::FocusedElementInformation>, false> {
        WebCore::IntRect interactionRect;
        WebCore::ElementContext elementContext;
        WebCore::IntPoint lastInteractionLocation;
        double minimumScaleFactor;
        double maximumScaleFactor;
        double maximumScaleFactorIgnoringAlwaysScalable;
        double nodeFontSize;
        bool hasNextNode;
        WebCore::IntRect nextNodeRect;
        bool hasPreviousNode;
        WebCore::IntRect previousNodeRect;
        bool isAutocorrect;
        bool isRTL;
        bool isMultiSelect;
        bool isReadOnly;
        bool allowsUserScaling;
        bool allowsUserScalingIgnoringAlwaysScalable;
        bool insideFixedPosition;
        bool hasPlainText;
        WebCore::AutocapitalizeType autocapitalizeType;
        WebKit::InputType elementType;
        WebCore::InputMode inputMode;
        WebCore::EnterKeyHint enterKeyHint;
        String formAction;
        Vector<WebKit::OptionItem> selectOptions;
        int selectedIndex;
        String value;
        double valueAsNumber;
        String title;
        bool acceptsAutofilledLoginCredentials;
        bool isAutofillableUsernameField;
        URL representingPageURL;
        WebCore::AutofillFieldName autofillFieldName;
        WebCore::NonAutofillCredentialType nonAutofillCredentialType;
        String placeholder;
        String label;
        String ariaLabel;
        bool hasSuggestions;
        bool isFocusingWithDataListDropdown;
        WebCore::Color colorValue;
        WebKit::ColorControlSupportsAlpha supportsAlpha;
        Vector<WebCore::Color> suggestedColors;
        bool hasEverBeenPasswordField;
        bool shouldSynthesizeKeyEventsForEditing;
        bool isSpellCheckingEnabled;
        bool isWritingSuggestionsEnabled;
        bool shouldAvoidResizingWhenInputViewBoundsChange;
        bool shouldAvoidScrollingWhenFocusedContentIsVisible;
        bool shouldUseLegacySelectPopoverDismissalBehaviorInDataActivation;
        bool shouldHideSoftTopScrollEdgeEffect;
        bool isFocusingWithValidationMessage;
        bool preventScroll;
        WebKit::FocusedElementInformationIdentifier identifier;
        Markable<WebCore::ScrollingNodeID> containerScrollingNodeID;
        std::optional<WebKit::FrameInfoData> frame;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFocusedElementInformation) == sizeof(WebKit::FocusedElementInformation));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::FocusedElementInformation, interactionRect)
        , offsetof(WebKit::FocusedElementInformation, elementContext)
        , offsetof(WebKit::FocusedElementInformation, lastInteractionLocation)
        , offsetof(WebKit::FocusedElementInformation, minimumScaleFactor)
        , offsetof(WebKit::FocusedElementInformation, maximumScaleFactor)
        , offsetof(WebKit::FocusedElementInformation, maximumScaleFactorIgnoringAlwaysScalable)
        , offsetof(WebKit::FocusedElementInformation, nodeFontSize)
        , offsetof(WebKit::FocusedElementInformation, hasNextNode)
        , offsetof(WebKit::FocusedElementInformation, nextNodeRect)
        , offsetof(WebKit::FocusedElementInformation, hasPreviousNode)
        , offsetof(WebKit::FocusedElementInformation, previousNodeRect)
        , offsetof(WebKit::FocusedElementInformation, isAutocorrect)
        , offsetof(WebKit::FocusedElementInformation, isRTL)
        , offsetof(WebKit::FocusedElementInformation, isMultiSelect)
        , offsetof(WebKit::FocusedElementInformation, isReadOnly)
        , offsetof(WebKit::FocusedElementInformation, allowsUserScaling)
        , offsetof(WebKit::FocusedElementInformation, allowsUserScalingIgnoringAlwaysScalable)
        , offsetof(WebKit::FocusedElementInformation, insideFixedPosition)
        , offsetof(WebKit::FocusedElementInformation, hasPlainText)
        , offsetof(WebKit::FocusedElementInformation, autocapitalizeType)
        , offsetof(WebKit::FocusedElementInformation, elementType)
        , offsetof(WebKit::FocusedElementInformation, inputMode)
        , offsetof(WebKit::FocusedElementInformation, enterKeyHint)
        , offsetof(WebKit::FocusedElementInformation, formAction)
        , offsetof(WebKit::FocusedElementInformation, selectOptions)
        , offsetof(WebKit::FocusedElementInformation, selectedIndex)
        , offsetof(WebKit::FocusedElementInformation, value)
        , offsetof(WebKit::FocusedElementInformation, valueAsNumber)
        , offsetof(WebKit::FocusedElementInformation, title)
        , offsetof(WebKit::FocusedElementInformation, acceptsAutofilledLoginCredentials)
        , offsetof(WebKit::FocusedElementInformation, isAutofillableUsernameField)
        , offsetof(WebKit::FocusedElementInformation, representingPageURL)
        , offsetof(WebKit::FocusedElementInformation, autofillFieldName)
        , offsetof(WebKit::FocusedElementInformation, nonAutofillCredentialType)
        , offsetof(WebKit::FocusedElementInformation, placeholder)
        , offsetof(WebKit::FocusedElementInformation, label)
        , offsetof(WebKit::FocusedElementInformation, ariaLabel)
        , offsetof(WebKit::FocusedElementInformation, hasSuggestions)
        , offsetof(WebKit::FocusedElementInformation, isFocusingWithDataListDropdown)
        , offsetof(WebKit::FocusedElementInformation, colorValue)
        , offsetof(WebKit::FocusedElementInformation, supportsAlpha)
        , offsetof(WebKit::FocusedElementInformation, suggestedColors)
        , offsetof(WebKit::FocusedElementInformation, hasEverBeenPasswordField)
        , offsetof(WebKit::FocusedElementInformation, shouldSynthesizeKeyEventsForEditing)
        , offsetof(WebKit::FocusedElementInformation, isSpellCheckingEnabled)
        , offsetof(WebKit::FocusedElementInformation, isWritingSuggestionsEnabled)
        , offsetof(WebKit::FocusedElementInformation, shouldAvoidResizingWhenInputViewBoundsChange)
        , offsetof(WebKit::FocusedElementInformation, shouldAvoidScrollingWhenFocusedContentIsVisible)
        , offsetof(WebKit::FocusedElementInformation, shouldUseLegacySelectPopoverDismissalBehaviorInDataActivation)
        , offsetof(WebKit::FocusedElementInformation, shouldHideSoftTopScrollEdgeEffect)
        , offsetof(WebKit::FocusedElementInformation, isFocusingWithValidationMessage)
        , offsetof(WebKit::FocusedElementInformation, preventScroll)
        , offsetof(WebKit::FocusedElementInformation, identifier)
        , offsetof(WebKit::FocusedElementInformation, containerScrollingNodeID)
        , offsetof(WebKit::FocusedElementInformation, frame)
    >::value);

    encoder << instance.interactionRect;
    encoder << instance.elementContext;
    encoder << instance.lastInteractionLocation;
    encoder << instance.minimumScaleFactor;
    encoder << instance.maximumScaleFactor;
    encoder << instance.maximumScaleFactorIgnoringAlwaysScalable;
    encoder << instance.nodeFontSize;
    encoder << instance.hasNextNode;
    encoder << instance.nextNodeRect;
    encoder << instance.hasPreviousNode;
    encoder << instance.previousNodeRect;
    encoder << instance.isAutocorrect;
    encoder << instance.isRTL;
    encoder << instance.isMultiSelect;
    encoder << instance.isReadOnly;
    encoder << instance.allowsUserScaling;
    encoder << instance.allowsUserScalingIgnoringAlwaysScalable;
    encoder << instance.insideFixedPosition;
    encoder << instance.hasPlainText;
    encoder << instance.autocapitalizeType;
    encoder << instance.elementType;
    encoder << instance.inputMode;
    encoder << instance.enterKeyHint;
    encoder << instance.formAction;
    encoder << instance.selectOptions;
    encoder << instance.selectedIndex;
    encoder << instance.value;
    encoder << instance.valueAsNumber;
    encoder << instance.title;
    encoder << instance.acceptsAutofilledLoginCredentials;
    encoder << instance.isAutofillableUsernameField;
    encoder << instance.representingPageURL;
    encoder << instance.autofillFieldName;
    encoder << instance.nonAutofillCredentialType;
    encoder << instance.placeholder;
    encoder << instance.label;
    encoder << instance.ariaLabel;
    encoder << instance.hasSuggestions;
    encoder << instance.isFocusingWithDataListDropdown;
    encoder << instance.colorValue;
    encoder << instance.supportsAlpha;
    encoder << instance.suggestedColors;
    encoder << instance.hasEverBeenPasswordField;
    encoder << instance.shouldSynthesizeKeyEventsForEditing;
    encoder << instance.isSpellCheckingEnabled;
    encoder << instance.isWritingSuggestionsEnabled;
    encoder << instance.shouldAvoidResizingWhenInputViewBoundsChange;
    encoder << instance.shouldAvoidScrollingWhenFocusedContentIsVisible;
    encoder << instance.shouldUseLegacySelectPopoverDismissalBehaviorInDataActivation;
    encoder << instance.shouldHideSoftTopScrollEdgeEffect;
    encoder << instance.isFocusingWithValidationMessage;
    encoder << instance.preventScroll;
    encoder << instance.identifier;
    encoder << instance.containerScrollingNodeID;
    encoder << instance.frame;
}

std::optional<WebKit::FocusedElementInformation> ArgumentCoder<WebKit::FocusedElementInformation>::decode(Decoder& decoder)
{
    auto interactionRect = decoder.decode<WebCore::IntRect>();
    auto elementContext = decoder.decode<WebCore::ElementContext>();
    auto lastInteractionLocation = decoder.decode<WebCore::IntPoint>();
    auto minimumScaleFactor = decoder.decode<double>();
    auto maximumScaleFactor = decoder.decode<double>();
    auto maximumScaleFactorIgnoringAlwaysScalable = decoder.decode<double>();
    auto nodeFontSize = decoder.decode<double>();
    auto hasNextNode = decoder.decode<bool>();
    auto nextNodeRect = decoder.decode<WebCore::IntRect>();
    auto hasPreviousNode = decoder.decode<bool>();
    auto previousNodeRect = decoder.decode<WebCore::IntRect>();
    auto isAutocorrect = decoder.decode<bool>();
    auto isRTL = decoder.decode<bool>();
    auto isMultiSelect = decoder.decode<bool>();
    auto isReadOnly = decoder.decode<bool>();
    auto allowsUserScaling = decoder.decode<bool>();
    auto allowsUserScalingIgnoringAlwaysScalable = decoder.decode<bool>();
    auto insideFixedPosition = decoder.decode<bool>();
    auto hasPlainText = decoder.decode<bool>();
    auto autocapitalizeType = decoder.decode<WebCore::AutocapitalizeType>();
    auto elementType = decoder.decode<WebKit::InputType>();
    auto inputMode = decoder.decode<WebCore::InputMode>();
    auto enterKeyHint = decoder.decode<WebCore::EnterKeyHint>();
    auto formAction = decoder.decode<String>();
    auto selectOptions = decoder.decode<Vector<WebKit::OptionItem>>();
    auto selectedIndex = decoder.decode<int>();
    auto value = decoder.decode<String>();
    auto valueAsNumber = decoder.decode<double>();
    auto title = decoder.decode<String>();
    auto acceptsAutofilledLoginCredentials = decoder.decode<bool>();
    auto isAutofillableUsernameField = decoder.decode<bool>();
    auto representingPageURL = decoder.decode<URL>();
    auto autofillFieldName = decoder.decode<WebCore::AutofillFieldName>();
    auto nonAutofillCredentialType = decoder.decode<WebCore::NonAutofillCredentialType>();
    auto placeholder = decoder.decode<String>();
    auto label = decoder.decode<String>();
    auto ariaLabel = decoder.decode<String>();
    auto hasSuggestions = decoder.decode<bool>();
    auto isFocusingWithDataListDropdown = decoder.decode<bool>();
    auto colorValue = decoder.decode<WebCore::Color>();
    auto supportsAlpha = decoder.decode<WebKit::ColorControlSupportsAlpha>();
    auto suggestedColors = decoder.decode<Vector<WebCore::Color>>();
    auto hasEverBeenPasswordField = decoder.decode<bool>();
    auto shouldSynthesizeKeyEventsForEditing = decoder.decode<bool>();
    auto isSpellCheckingEnabled = decoder.decode<bool>();
    auto isWritingSuggestionsEnabled = decoder.decode<bool>();
    auto shouldAvoidResizingWhenInputViewBoundsChange = decoder.decode<bool>();
    auto shouldAvoidScrollingWhenFocusedContentIsVisible = decoder.decode<bool>();
    auto shouldUseLegacySelectPopoverDismissalBehaviorInDataActivation = decoder.decode<bool>();
    auto shouldHideSoftTopScrollEdgeEffect = decoder.decode<bool>();
    auto isFocusingWithValidationMessage = decoder.decode<bool>();
    auto preventScroll = decoder.decode<bool>();
    auto identifier = decoder.decode<WebKit::FocusedElementInformationIdentifier>();
    auto containerScrollingNodeID = decoder.decode<Markable<WebCore::ScrollingNodeID>>();
    auto frame = decoder.decode<std::optional<WebKit::FrameInfoData>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::FocusedElementInformation {
            WTFMove(*interactionRect),
            WTFMove(*elementContext),
            WTFMove(*lastInteractionLocation),
            WTFMove(*minimumScaleFactor),
            WTFMove(*maximumScaleFactor),
            WTFMove(*maximumScaleFactorIgnoringAlwaysScalable),
            WTFMove(*nodeFontSize),
            WTFMove(*hasNextNode),
            WTFMove(*nextNodeRect),
            WTFMove(*hasPreviousNode),
            WTFMove(*previousNodeRect),
            WTFMove(*isAutocorrect),
            WTFMove(*isRTL),
            WTFMove(*isMultiSelect),
            WTFMove(*isReadOnly),
            WTFMove(*allowsUserScaling),
            WTFMove(*allowsUserScalingIgnoringAlwaysScalable),
            WTFMove(*insideFixedPosition),
            WTFMove(*hasPlainText),
            WTFMove(*autocapitalizeType),
            WTFMove(*elementType),
            WTFMove(*inputMode),
            WTFMove(*enterKeyHint),
            WTFMove(*formAction),
            WTFMove(*selectOptions),
            WTFMove(*selectedIndex),
            WTFMove(*value),
            WTFMove(*valueAsNumber),
            WTFMove(*title),
            WTFMove(*acceptsAutofilledLoginCredentials),
            WTFMove(*isAutofillableUsernameField),
            WTFMove(*representingPageURL),
            WTFMove(*autofillFieldName),
            WTFMove(*nonAutofillCredentialType),
            WTFMove(*placeholder),
            WTFMove(*label),
            WTFMove(*ariaLabel),
            WTFMove(*hasSuggestions),
            WTFMove(*isFocusingWithDataListDropdown),
            WTFMove(*colorValue),
            WTFMove(*supportsAlpha),
            WTFMove(*suggestedColors),
            WTFMove(*hasEverBeenPasswordField),
            WTFMove(*shouldSynthesizeKeyEventsForEditing),
            WTFMove(*isSpellCheckingEnabled),
            WTFMove(*isWritingSuggestionsEnabled),
            WTFMove(*shouldAvoidResizingWhenInputViewBoundsChange),
            WTFMove(*shouldAvoidScrollingWhenFocusedContentIsVisible),
            WTFMove(*shouldUseLegacySelectPopoverDismissalBehaviorInDataActivation),
            WTFMove(*shouldHideSoftTopScrollEdgeEffect),
            WTFMove(*isFocusingWithValidationMessage),
            WTFMove(*preventScroll),
            WTFMove(*identifier),
            WTFMove(*containerScrollingNodeID),
            WTFMove(*frame)
        }
    };
}

#endif

void ArgumentCoder<WebKit::FrameInfoData>::encode(Encoder& encoder, const WebKit::FrameInfoData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isMainFrame)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameType)>, WebKit::FrameType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.request)>, WebCore::ResourceRequest>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.securityOrigin)>, WebCore::SecurityOriginData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameName)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameID)>, WebCore::FrameIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.parentFrameID)>, Markable<WebCore::FrameIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.documentID)>, Markable<WebCore::ScriptExecutionContextIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.certificateInfo)>, WebCore::CertificateInfo>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processID)>, WTF::ProcessID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isFocused)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.errorOccurred)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameMetrics)>, WebKit::WebFrameMetrics>);
    struct ShouldBeSameSizeAsFrameInfoData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::FrameInfoData>, false> {
        bool isMainFrame;
        WebKit::FrameType frameType;
        WebCore::ResourceRequest request;
        WebCore::SecurityOriginData securityOrigin;
        String frameName;
        WebCore::FrameIdentifier frameID;
        Markable<WebCore::FrameIdentifier> parentFrameID;
        Markable<WebCore::ScriptExecutionContextIdentifier> documentID;
        WebCore::CertificateInfo certificateInfo;
        WTF::ProcessID processID;
        bool isFocused;
        bool errorOccurred;
        WebKit::WebFrameMetrics frameMetrics;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFrameInfoData) == sizeof(WebKit::FrameInfoData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::FrameInfoData, isMainFrame)
        , offsetof(WebKit::FrameInfoData, frameType)
        , offsetof(WebKit::FrameInfoData, request)
        , offsetof(WebKit::FrameInfoData, securityOrigin)
        , offsetof(WebKit::FrameInfoData, frameName)
        , offsetof(WebKit::FrameInfoData, frameID)
        , offsetof(WebKit::FrameInfoData, parentFrameID)
        , offsetof(WebKit::FrameInfoData, documentID)
        , offsetof(WebKit::FrameInfoData, certificateInfo)
        , offsetof(WebKit::FrameInfoData, processID)
        , offsetof(WebKit::FrameInfoData, isFocused)
        , offsetof(WebKit::FrameInfoData, errorOccurred)
        , offsetof(WebKit::FrameInfoData, frameMetrics)
    >::value);

    encoder << instance.isMainFrame;
    encoder << instance.frameType;
    encoder << instance.request;
    encoder << instance.securityOrigin;
    encoder << instance.frameName;
    encoder << instance.frameID;
    encoder << instance.parentFrameID;
    encoder << instance.documentID;
    encoder << instance.certificateInfo;
    encoder << instance.processID;
    encoder << instance.isFocused;
    encoder << instance.errorOccurred;
    encoder << instance.frameMetrics;
}

std::optional<WebKit::FrameInfoData> ArgumentCoder<WebKit::FrameInfoData>::decode(Decoder& decoder)
{
    auto isMainFrame = decoder.decode<bool>();
    auto frameType = decoder.decode<WebKit::FrameType>();
    auto request = decoder.decode<WebCore::ResourceRequest>();
    auto securityOrigin = decoder.decode<WebCore::SecurityOriginData>();
    auto frameName = decoder.decode<String>();
    auto frameID = decoder.decode<WebCore::FrameIdentifier>();
    auto parentFrameID = decoder.decode<Markable<WebCore::FrameIdentifier>>();
    auto documentID = decoder.decode<Markable<WebCore::ScriptExecutionContextIdentifier>>();
    auto certificateInfo = decoder.decode<WebCore::CertificateInfo>();
    auto processID = decoder.decode<WTF::ProcessID>();
    auto isFocused = decoder.decode<bool>();
    auto errorOccurred = decoder.decode<bool>();
    auto frameMetrics = decoder.decode<WebKit::WebFrameMetrics>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::FrameInfoData {
            WTFMove(*isMainFrame),
            WTFMove(*frameType),
            WTFMove(*request),
            WTFMove(*securityOrigin),
            WTFMove(*frameName),
            WTFMove(*frameID),
            WTFMove(*parentFrameID),
            WTFMove(*documentID),
            WTFMove(*certificateInfo),
            WTFMove(*processID),
            WTFMove(*isFocused),
            WTFMove(*errorOccurred),
            WTFMove(*frameMetrics)
        }
    };
}

void ArgumentCoder<WebKit::FrameTreeCreationParameters>::encode(Encoder& encoder, const WebKit::FrameTreeCreationParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameID)>, WebCore::FrameIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.openerFrameID)>, std::optional<WebCore::FrameIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameName)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameTreeSyncData)>, Ref<WebCore::FrameTreeSyncData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.children)>, Vector<WebKit::FrameTreeCreationParameters>>);
    struct ShouldBeSameSizeAsFrameTreeCreationParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::FrameTreeCreationParameters>, false> {
        WebCore::FrameIdentifier frameID;
        std::optional<WebCore::FrameIdentifier> openerFrameID;
        String frameName;
        Ref<WebCore::FrameTreeSyncData> frameTreeSyncData;
        Vector<WebKit::FrameTreeCreationParameters> children;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFrameTreeCreationParameters) == sizeof(WebKit::FrameTreeCreationParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::FrameTreeCreationParameters, frameID)
        , offsetof(WebKit::FrameTreeCreationParameters, openerFrameID)
        , offsetof(WebKit::FrameTreeCreationParameters, frameName)
        , offsetof(WebKit::FrameTreeCreationParameters, frameTreeSyncData)
        , offsetof(WebKit::FrameTreeCreationParameters, children)
    >::value);

    encoder << instance.frameID;
    encoder << instance.openerFrameID;
    encoder << instance.frameName;
    encoder << instance.frameTreeSyncData;
    encoder << instance.children;
}

std::optional<WebKit::FrameTreeCreationParameters> ArgumentCoder<WebKit::FrameTreeCreationParameters>::decode(Decoder& decoder)
{
    auto frameID = decoder.decode<WebCore::FrameIdentifier>();
    auto openerFrameID = decoder.decode<std::optional<WebCore::FrameIdentifier>>();
    auto frameName = decoder.decode<String>();
    auto frameTreeSyncData = decoder.decode<Ref<WebCore::FrameTreeSyncData>>();
    auto children = decoder.decode<Vector<WebKit::FrameTreeCreationParameters>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::FrameTreeCreationParameters {
            WTFMove(*frameID),
            WTFMove(*openerFrameID),
            WTFMove(*frameName),
            WTFMove(*frameTreeSyncData),
            WTFMove(*children)
        }
    };
}

void ArgumentCoder<WebKit::FrameTreeNodeData>::encode(Encoder& encoder, const WebKit::FrameTreeNodeData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.info)>, WebKit::FrameInfoData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.children)>, Vector<WebKit::FrameTreeNodeData>>);
    struct ShouldBeSameSizeAsFrameTreeNodeData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::FrameTreeNodeData>, false> {
        WebKit::FrameInfoData info;
        Vector<WebKit::FrameTreeNodeData> children;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFrameTreeNodeData) == sizeof(WebKit::FrameTreeNodeData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::FrameTreeNodeData, info)
        , offsetof(WebKit::FrameTreeNodeData, children)
    >::value);

    encoder << instance.info;
    encoder << instance.children;
}

std::optional<WebKit::FrameTreeNodeData> ArgumentCoder<WebKit::FrameTreeNodeData>::decode(Decoder& decoder)
{
    auto info = decoder.decode<WebKit::FrameInfoData>();
    auto children = decoder.decode<Vector<WebKit::FrameTreeNodeData>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::FrameTreeNodeData {
            WTFMove(*info),
            WTFMove(*children)
        }
    };
}

void ArgumentCoder<WebKit::FullScreenMediaDetails>::encode(Encoder& encoder, WebKit::FullScreenMediaDetails&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebKit::FullScreenMediaDetails::Type>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaDimensions)>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mimeType)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.imageHandle)>, std::optional<WebCore::SharedMemory::Handle>>);
    struct ShouldBeSameSizeAsFullScreenMediaDetails : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::FullScreenMediaDetails>, false> {
        WebKit::FullScreenMediaDetails::Type type;
        WebCore::FloatSize mediaDimensions;
        String mimeType;
        std::optional<WebCore::SharedMemory::Handle> imageHandle;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFullScreenMediaDetails) == sizeof(WebKit::FullScreenMediaDetails));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::FullScreenMediaDetails, type)
        , offsetof(WebKit::FullScreenMediaDetails, mediaDimensions)
        , offsetof(WebKit::FullScreenMediaDetails, mimeType)
        , offsetof(WebKit::FullScreenMediaDetails, imageHandle)
    >::value);

    encoder << WTFMove(instance.type);
    encoder << WTFMove(instance.mediaDimensions);
    encoder << WTFMove(instance.mimeType);
    encoder << WTFMove(instance.imageHandle);
}

std::optional<WebKit::FullScreenMediaDetails> ArgumentCoder<WebKit::FullScreenMediaDetails>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebKit::FullScreenMediaDetails::Type>();
    auto mediaDimensions = decoder.decode<WebCore::FloatSize>();
    auto mimeType = decoder.decode<String>();
    auto imageHandle = decoder.decode<std::optional<WebCore::SharedMemory::Handle>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::FullScreenMediaDetails {
            WTFMove(*type),
            WTFMove(*mediaDimensions),
            WTFMove(*mimeType),
            WTFMove(*imageHandle)
        }
    };
}

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::GPUProcessConnectionParameters>::encode(Encoder& encoder, WebKit::GPUProcessConnectionParameters&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webProcessIdentity)>, WebCore::ProcessIdentity>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sharedPreferencesForWebProcess)>, WebKit::SharedPreferencesForWebProcess>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isLockdownModeEnabled)>, bool>);
#if ENABLE(IPC_TESTING_API)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ignoreInvalidMessageForTesting)>, bool>);
#endif
#if HAVE(AUDIT_TOKEN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.presentingApplicationAuditTokens)>, HashMap<WebCore::PageIdentifier, WebKit::CoreIPCAuditToken>>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.applicationBundleIdentifier)>, String>);
#endif
#if ENABLE(VP9)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasVP9HardwareDecoder)>, std::optional<bool>>);
#endif
#if ENABLE(AV1)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasAV1HardwareDecoder)>, std::optional<bool>>);
#endif
    struct ShouldBeSameSizeAsGPUProcessConnectionParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::GPUProcessConnectionParameters>, false> {
        WebCore::ProcessIdentity webProcessIdentity;
        WebKit::SharedPreferencesForWebProcess sharedPreferencesForWebProcess;
        bool isLockdownModeEnabled;
#if ENABLE(IPC_TESTING_API)
        bool ignoreInvalidMessageForTesting;
#endif
#if HAVE(AUDIT_TOKEN)
        HashMap<WebCore::PageIdentifier, WebKit::CoreIPCAuditToken> presentingApplicationAuditTokens;
#endif
#if PLATFORM(COCOA)
        String applicationBundleIdentifier;
#endif
#if ENABLE(VP9)
        std::optional<bool> hasVP9HardwareDecoder;
#endif
#if ENABLE(AV1)
        std::optional<bool> hasAV1HardwareDecoder;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsGPUProcessConnectionParameters) == sizeof(WebKit::GPUProcessConnectionParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::GPUProcessConnectionParameters, webProcessIdentity)
        , offsetof(WebKit::GPUProcessConnectionParameters, sharedPreferencesForWebProcess)
        , offsetof(WebKit::GPUProcessConnectionParameters, isLockdownModeEnabled)
#if ENABLE(IPC_TESTING_API)
        , offsetof(WebKit::GPUProcessConnectionParameters, ignoreInvalidMessageForTesting)
#endif
#if HAVE(AUDIT_TOKEN)
        , offsetof(WebKit::GPUProcessConnectionParameters, presentingApplicationAuditTokens)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::GPUProcessConnectionParameters, applicationBundleIdentifier)
#endif
#if ENABLE(VP9)
        , offsetof(WebKit::GPUProcessConnectionParameters, hasVP9HardwareDecoder)
#endif
#if ENABLE(AV1)
        , offsetof(WebKit::GPUProcessConnectionParameters, hasAV1HardwareDecoder)
#endif
    >::value);

    encoder << WTFMove(instance.webProcessIdentity);
    encoder << WTFMove(instance.sharedPreferencesForWebProcess);
    encoder << WTFMove(instance.isLockdownModeEnabled);
#if ENABLE(IPC_TESTING_API)
    encoder << WTFMove(instance.ignoreInvalidMessageForTesting);
#endif
#if HAVE(AUDIT_TOKEN)
    encoder << WTFMove(instance.presentingApplicationAuditTokens);
#endif
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.applicationBundleIdentifier);
#endif
#if ENABLE(VP9)
    encoder << WTFMove(instance.hasVP9HardwareDecoder);
#endif
#if ENABLE(AV1)
    encoder << WTFMove(instance.hasAV1HardwareDecoder);
#endif
}

std::optional<WebKit::GPUProcessConnectionParameters> ArgumentCoder<WebKit::GPUProcessConnectionParameters>::decode(Decoder& decoder)
{
    auto webProcessIdentity = decoder.decode<WebCore::ProcessIdentity>();
    auto sharedPreferencesForWebProcess = decoder.decode<WebKit::SharedPreferencesForWebProcess>();
    auto isLockdownModeEnabled = decoder.decode<bool>();
#if ENABLE(IPC_TESTING_API)
    auto ignoreInvalidMessageForTesting = decoder.decode<bool>();
#endif
#if HAVE(AUDIT_TOKEN)
    auto presentingApplicationAuditTokens = decoder.decode<HashMap<WebCore::PageIdentifier, WebKit::CoreIPCAuditToken>>();
#endif
#if PLATFORM(COCOA)
    auto applicationBundleIdentifier = decoder.decode<String>();
#endif
#if ENABLE(VP9)
    auto hasVP9HardwareDecoder = decoder.decode<std::optional<bool>>();
#endif
#if ENABLE(AV1)
    auto hasAV1HardwareDecoder = decoder.decode<std::optional<bool>>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::GPUProcessConnectionParameters {
            WTFMove(*webProcessIdentity),
            WTFMove(*sharedPreferencesForWebProcess),
            WTFMove(*isLockdownModeEnabled),
#if ENABLE(IPC_TESTING_API)
            WTFMove(*ignoreInvalidMessageForTesting),
#endif
#if HAVE(AUDIT_TOKEN)
            WTFMove(*presentingApplicationAuditTokens),
#endif
#if PLATFORM(COCOA)
            WTFMove(*applicationBundleIdentifier),
#endif
#if ENABLE(VP9)
            WTFMove(*hasVP9HardwareDecoder),
#endif
#if ENABLE(AV1)
            WTFMove(*hasAV1HardwareDecoder)
#endif
        }
    };
}

#endif

void ArgumentCoder<WebKit::GoToBackForwardItemParameters>::encode(Encoder& encoder, WebKit::GoToBackForwardItemParameters&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.navigationID)>, WebCore::NavigationIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameState)>, Ref<WebKit::FrameState>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.backForwardType)>, WebCore::FrameLoadType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldTreatAsContinuingLoad)>, WebCore::ShouldTreatAsContinuingLoad>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.websitePolicies)>, std::optional<WebKit::WebsitePoliciesData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lastNavigationWasAppInitiated)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.existingNetworkResourceLoadIdentifierToResume)>, std::optional<WebKit::NetworkResourceLoadIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.publicSuffix)>, WebCore::PublicSuffix>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sandboxExtensionHandle)>, WebKit::SandboxExtensionHandle>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processSwapDisposition)>, WebCore::ProcessSwapDisposition>);
    struct ShouldBeSameSizeAsGoToBackForwardItemParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::GoToBackForwardItemParameters>, false> {
        WebCore::NavigationIdentifier navigationID;
        Ref<WebKit::FrameState> frameState;
        WebCore::FrameLoadType backForwardType;
        WebCore::ShouldTreatAsContinuingLoad shouldTreatAsContinuingLoad;
        std::optional<WebKit::WebsitePoliciesData> websitePolicies;
        bool lastNavigationWasAppInitiated;
        std::optional<WebKit::NetworkResourceLoadIdentifier> existingNetworkResourceLoadIdentifierToResume;
        WebCore::PublicSuffix publicSuffix;
        WebKit::SandboxExtensionHandle sandboxExtensionHandle;
        WebCore::ProcessSwapDisposition processSwapDisposition;
    };
    static_assert(sizeof(ShouldBeSameSizeAsGoToBackForwardItemParameters) == sizeof(WebKit::GoToBackForwardItemParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::GoToBackForwardItemParameters, navigationID)
        , offsetof(WebKit::GoToBackForwardItemParameters, frameState)
        , offsetof(WebKit::GoToBackForwardItemParameters, backForwardType)
        , offsetof(WebKit::GoToBackForwardItemParameters, shouldTreatAsContinuingLoad)
        , offsetof(WebKit::GoToBackForwardItemParameters, websitePolicies)
        , offsetof(WebKit::GoToBackForwardItemParameters, lastNavigationWasAppInitiated)
        , offsetof(WebKit::GoToBackForwardItemParameters, existingNetworkResourceLoadIdentifierToResume)
        , offsetof(WebKit::GoToBackForwardItemParameters, publicSuffix)
        , offsetof(WebKit::GoToBackForwardItemParameters, sandboxExtensionHandle)
        , offsetof(WebKit::GoToBackForwardItemParameters, processSwapDisposition)
    >::value);

    encoder << WTFMove(instance.navigationID);
    encoder << WTFMove(instance.frameState);
    encoder << WTFMove(instance.backForwardType);
    encoder << WTFMove(instance.shouldTreatAsContinuingLoad);
    encoder << WTFMove(instance.websitePolicies);
    encoder << WTFMove(instance.lastNavigationWasAppInitiated);
    encoder << WTFMove(instance.existingNetworkResourceLoadIdentifierToResume);
    encoder << WTFMove(instance.publicSuffix);
    encoder << WTFMove(instance.sandboxExtensionHandle);
    encoder << WTFMove(instance.processSwapDisposition);
}

std::optional<WebKit::GoToBackForwardItemParameters> ArgumentCoder<WebKit::GoToBackForwardItemParameters>::decode(Decoder& decoder)
{
    auto navigationID = decoder.decode<WebCore::NavigationIdentifier>();
    auto frameState = decoder.decode<Ref<WebKit::FrameState>>();
    auto backForwardType = decoder.decode<WebCore::FrameLoadType>();
    auto shouldTreatAsContinuingLoad = decoder.decode<WebCore::ShouldTreatAsContinuingLoad>();
    auto websitePolicies = decoder.decode<std::optional<WebKit::WebsitePoliciesData>>();
    auto lastNavigationWasAppInitiated = decoder.decode<bool>();
    auto existingNetworkResourceLoadIdentifierToResume = decoder.decode<std::optional<WebKit::NetworkResourceLoadIdentifier>>();
    auto publicSuffix = decoder.decode<WebCore::PublicSuffix>();
    auto sandboxExtensionHandle = decoder.decode<WebKit::SandboxExtensionHandle>();
    auto processSwapDisposition = decoder.decode<WebCore::ProcessSwapDisposition>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::GoToBackForwardItemParameters {
            WTFMove(*navigationID),
            WTFMove(*frameState),
            WTFMove(*backForwardType),
            WTFMove(*shouldTreatAsContinuingLoad),
            WTFMove(*websitePolicies),
            WTFMove(*lastNavigationWasAppInitiated),
            WTFMove(*existingNetworkResourceLoadIdentifierToResume),
            WTFMove(*publicSuffix),
            WTFMove(*sandboxExtensionHandle),
            WTFMove(*processSwapDisposition)
        }
    };
}

void ArgumentCoder<WebKit::NodeInfo>::encode(Encoder& encoder, const WebKit::NodeInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.nodeIdentifier)>, WebCore::NodeIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentFrameIdentifier)>, Markable<WebCore::FrameIdentifier>>);
    struct ShouldBeSameSizeAsNodeInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::NodeInfo>, false> {
        WebCore::NodeIdentifier nodeIdentifier;
        Markable<WebCore::FrameIdentifier> contentFrameIdentifier;
    };
    static_assert(sizeof(ShouldBeSameSizeAsNodeInfo) == sizeof(WebKit::NodeInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::NodeInfo, nodeIdentifier)
        , offsetof(WebKit::NodeInfo, contentFrameIdentifier)
    >::value);

    encoder << instance.nodeIdentifier;
    encoder << instance.contentFrameIdentifier;
}

std::optional<WebKit::NodeInfo> ArgumentCoder<WebKit::NodeInfo>::decode(Decoder& decoder)
{
    auto nodeIdentifier = decoder.decode<WebCore::NodeIdentifier>();
    auto contentFrameIdentifier = decoder.decode<Markable<WebCore::FrameIdentifier>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::NodeInfo {
            WTFMove(*nodeIdentifier),
            WTFMove(*contentFrameIdentifier)
        }
    };
}

void ArgumentCoder<WebKit::JavaScriptEvaluationResult::Value>::encode(Encoder& encoder, const WebKit::JavaScriptEvaluationResult::Value& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, Variant<WebKit::JavaScriptEvaluationResult::EmptyType, bool, double, String, Seconds, Vector<WebKit::JSObjectID>, HashMap<WebKit::JSObjectID, WebKit::JSObjectID>, WebKit::NodeInfo, WebCore::SerializedNode>>);
    struct ShouldBeSameSizeAsValue : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::JavaScriptEvaluationResult::Value>, false> {
        Variant<WebKit::JavaScriptEvaluationResult::EmptyType, bool, double, String, Seconds, Vector<WebKit::JSObjectID>, HashMap<WebKit::JSObjectID, WebKit::JSObjectID>, WebKit::NodeInfo, WebCore::SerializedNode> value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsValue) == sizeof(WebKit::JavaScriptEvaluationResult::Value));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::JavaScriptEvaluationResult::Value, value)
    >::value);

    encoder << instance.value;
}

std::optional<WebKit::JavaScriptEvaluationResult::Value> ArgumentCoder<WebKit::JavaScriptEvaluationResult::Value>::decode(Decoder& decoder)
{
    auto value = decoder.decode<Variant<WebKit::JavaScriptEvaluationResult::EmptyType, bool, double, String, Seconds, Vector<WebKit::JSObjectID>, HashMap<WebKit::JSObjectID, WebKit::JSObjectID>, WebKit::NodeInfo, WebCore::SerializedNode>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::JavaScriptEvaluationResult::Value {
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebKit::JavaScriptEvaluationResult>::encode(Encoder& encoder, const WebKit::JavaScriptEvaluationResult& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.root())>, WebKit::JSObjectID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.map())>, HashMap<WebKit::JSObjectID, UniqueRef<WebKit::JavaScriptEvaluationResult::Value>>>);

    encoder << instance.root();
    encoder << instance.map();
}

std::optional<WebKit::JavaScriptEvaluationResult> ArgumentCoder<WebKit::JavaScriptEvaluationResult>::decode(Decoder& decoder)
{
    auto root = decoder.decode<WebKit::JSObjectID>();
    auto map = decoder.decode<HashMap<WebKit::JSObjectID, UniqueRef<WebKit::JavaScriptEvaluationResult::Value>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::JavaScriptEvaluationResult {
            WTFMove(*root),
            WTFMove(*map)
        }
    };
}

void ArgumentCoder<WebKit::LayerTreeContext>::encode(Encoder& encoder, const WebKit::LayerTreeContext& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contextID)>, uint64_t>);
    struct ShouldBeSameSizeAsLayerTreeContext : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::LayerTreeContext>, false> {
        uint64_t contextID;
    };
    static_assert(sizeof(ShouldBeSameSizeAsLayerTreeContext) == sizeof(WebKit::LayerTreeContext));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::LayerTreeContext, contextID)
    >::value);

    encoder << instance.contextID;
}

std::optional<WebKit::LayerTreeContext> ArgumentCoder<WebKit::LayerTreeContext>::decode(Decoder& decoder)
{
    auto contextID = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::LayerTreeContext {
            WTFMove(*contextID)
        }
    };
}

void ArgumentCoder<WebKit::LoadParameters>::encode(Encoder& encoder, WebKit::LoadParameters&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.publicSuffix)>, WebCore::PublicSuffix>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.navigationID)>, std::optional<WebCore::NavigationIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameIdentifier)>, std::optional<WebCore::FrameIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.request)>, WebCore::ResourceRequest>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sandboxExtensionHandle)>, WebKit::SandboxExtensionHandle>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data)>, RefPtr<WebCore::SharedBuffer>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.MIMEType)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.encodingName)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.baseURLString)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.unreachableURLString)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.provisionalLoadErrorURLString)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.websitePolicies)>, std::optional<WebKit::WebsitePoliciesData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.originatingFrame)>, std::optional<WebKit::FrameInfoData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldOpenExternalURLsPolicy)>, WebCore::ShouldOpenExternalURLsPolicy>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldTreatAsContinuingLoad)>, WebCore::ShouldTreatAsContinuingLoad>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.userData)>, WebKit::UserData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lockHistory)>, WebCore::LockHistory>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lockBackForwardList)>, WebCore::LockBackForwardList>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sessionHistoryVisibility)>, WebCore::SubstituteData::SessionHistoryVisibility>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.clientRedirectSourceForHistory)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.effectiveSandboxFlags)>, WebCore::SandboxFlags>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ownerPermissionsPolicy)>, std::optional<WebCore::OwnerPermissionsPolicyData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isNavigatingToAppBoundDomain)>, std::optional<WebKit::NavigatingToAppBoundDomain>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.existingNetworkResourceLoadIdentifierToResume)>, std::optional<WebKit::NetworkResourceLoadIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isServiceWorkerLoad)>, bool>);
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dataDetectionReferenceDate)>, std::optional<double>>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isRequestFromClientOrUserInput)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isPerformingHTTPFallback)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isHandledByAboutSchemeHandler)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.advancedPrivacyProtections)>, std::optional<OptionSet<WebCore::AdvancedPrivacyProtections>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requiredCookiesVersion)>, uint64_t>);
    struct ShouldBeSameSizeAsLoadParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::LoadParameters>, false> {
        WebCore::PublicSuffix publicSuffix;
        std::optional<WebCore::NavigationIdentifier> navigationID;
        std::optional<WebCore::FrameIdentifier> frameIdentifier;
        WebCore::ResourceRequest request;
        WebKit::SandboxExtensionHandle sandboxExtensionHandle;
        RefPtr<WebCore::SharedBuffer> data;
        String MIMEType;
        String encodingName;
        String baseURLString;
        String unreachableURLString;
        String provisionalLoadErrorURLString;
        std::optional<WebKit::WebsitePoliciesData> websitePolicies;
        std::optional<WebKit::FrameInfoData> originatingFrame;
        WebCore::ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicy;
        WebCore::ShouldTreatAsContinuingLoad shouldTreatAsContinuingLoad;
        WebKit::UserData userData;
        WebCore::LockHistory lockHistory;
        WebCore::LockBackForwardList lockBackForwardList;
        WebCore::SubstituteData::SessionHistoryVisibility sessionHistoryVisibility;
        String clientRedirectSourceForHistory;
        WebCore::SandboxFlags effectiveSandboxFlags;
        std::optional<WebCore::OwnerPermissionsPolicyData> ownerPermissionsPolicy;
        std::optional<WebKit::NavigatingToAppBoundDomain> isNavigatingToAppBoundDomain;
        std::optional<WebKit::NetworkResourceLoadIdentifier> existingNetworkResourceLoadIdentifierToResume;
        bool isServiceWorkerLoad;
#if PLATFORM(COCOA)
        std::optional<double> dataDetectionReferenceDate;
#endif
        bool isRequestFromClientOrUserInput;
        bool isPerformingHTTPFallback;
        bool isHandledByAboutSchemeHandler;
        std::optional<OptionSet<WebCore::AdvancedPrivacyProtections>> advancedPrivacyProtections;
        uint64_t requiredCookiesVersion;
    };
    static_assert(sizeof(ShouldBeSameSizeAsLoadParameters) == sizeof(WebKit::LoadParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::LoadParameters, publicSuffix)
        , offsetof(WebKit::LoadParameters, navigationID)
        , offsetof(WebKit::LoadParameters, frameIdentifier)
        , offsetof(WebKit::LoadParameters, request)
        , offsetof(WebKit::LoadParameters, sandboxExtensionHandle)
        , offsetof(WebKit::LoadParameters, data)
        , offsetof(WebKit::LoadParameters, MIMEType)
        , offsetof(WebKit::LoadParameters, encodingName)
        , offsetof(WebKit::LoadParameters, baseURLString)
        , offsetof(WebKit::LoadParameters, unreachableURLString)
        , offsetof(WebKit::LoadParameters, provisionalLoadErrorURLString)
        , offsetof(WebKit::LoadParameters, websitePolicies)
        , offsetof(WebKit::LoadParameters, originatingFrame)
        , offsetof(WebKit::LoadParameters, shouldOpenExternalURLsPolicy)
        , offsetof(WebKit::LoadParameters, shouldTreatAsContinuingLoad)
        , offsetof(WebKit::LoadParameters, userData)
        , offsetof(WebKit::LoadParameters, lockHistory)
        , offsetof(WebKit::LoadParameters, lockBackForwardList)
        , offsetof(WebKit::LoadParameters, sessionHistoryVisibility)
        , offsetof(WebKit::LoadParameters, clientRedirectSourceForHistory)
        , offsetof(WebKit::LoadParameters, effectiveSandboxFlags)
        , offsetof(WebKit::LoadParameters, ownerPermissionsPolicy)
        , offsetof(WebKit::LoadParameters, isNavigatingToAppBoundDomain)
        , offsetof(WebKit::LoadParameters, existingNetworkResourceLoadIdentifierToResume)
        , offsetof(WebKit::LoadParameters, isServiceWorkerLoad)
#if PLATFORM(COCOA)
        , offsetof(WebKit::LoadParameters, dataDetectionReferenceDate)
#endif
        , offsetof(WebKit::LoadParameters, isRequestFromClientOrUserInput)
        , offsetof(WebKit::LoadParameters, isPerformingHTTPFallback)
        , offsetof(WebKit::LoadParameters, isHandledByAboutSchemeHandler)
        , offsetof(WebKit::LoadParameters, advancedPrivacyProtections)
        , offsetof(WebKit::LoadParameters, requiredCookiesVersion)
    >::value);

    encoder << WTFMove(instance.publicSuffix);
    encoder << WTFMove(instance.navigationID);
    encoder << WTFMove(instance.frameIdentifier);
    RefPtr requestBody = instance.request.httpBody();
    encoder << WTFMove(instance.request);
    encoder << IPC::FormDataReference { WTFMove(requestBody) };
    encoder << WTFMove(instance.sandboxExtensionHandle);
    encoder << WTFMove(instance.data);
    encoder << WTFMove(instance.MIMEType);
    encoder << WTFMove(instance.encodingName);
    encoder << WTFMove(instance.baseURLString);
    encoder << WTFMove(instance.unreachableURLString);
    encoder << WTFMove(instance.provisionalLoadErrorURLString);
    encoder << WTFMove(instance.websitePolicies);
    encoder << WTFMove(instance.originatingFrame);
    encoder << WTFMove(instance.shouldOpenExternalURLsPolicy);
    encoder << WTFMove(instance.shouldTreatAsContinuingLoad);
    encoder << WTFMove(instance.userData);
    encoder << WTFMove(instance.lockHistory);
    encoder << WTFMove(instance.lockBackForwardList);
    encoder << WTFMove(instance.sessionHistoryVisibility);
    encoder << WTFMove(instance.clientRedirectSourceForHistory);
    encoder << WTFMove(instance.effectiveSandboxFlags);
    encoder << WTFMove(instance.ownerPermissionsPolicy);
    encoder << WTFMove(instance.isNavigatingToAppBoundDomain);
    encoder << WTFMove(instance.existingNetworkResourceLoadIdentifierToResume);
    encoder << WTFMove(instance.isServiceWorkerLoad);
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.dataDetectionReferenceDate);
#endif
    encoder << WTFMove(instance.isRequestFromClientOrUserInput);
    encoder << WTFMove(instance.isPerformingHTTPFallback);
    encoder << WTFMove(instance.isHandledByAboutSchemeHandler);
    encoder << WTFMove(instance.advancedPrivacyProtections);
    encoder << WTFMove(instance.requiredCookiesVersion);
}

std::optional<WebKit::LoadParameters> ArgumentCoder<WebKit::LoadParameters>::decode(Decoder& decoder)
{
    auto publicSuffix = decoder.decode<WebCore::PublicSuffix>();
    auto navigationID = decoder.decode<std::optional<WebCore::NavigationIdentifier>>();
    auto frameIdentifier = decoder.decode<std::optional<WebCore::FrameIdentifier>>();
    auto request = decoder.decode<WebCore::ResourceRequest>();
    if (request) {
        if (auto requestBody = decoder.decode<IPC::FormDataReference>())
            request->setHTTPBody(requestBody->takeData());
    }
    auto sandboxExtensionHandle = decoder.decode<WebKit::SandboxExtensionHandle>();
    auto data = decoder.decode<RefPtr<WebCore::SharedBuffer>>();
    auto MIMEType = decoder.decode<String>();
    auto encodingName = decoder.decode<String>();
    auto baseURLString = decoder.decode<String>();
    auto unreachableURLString = decoder.decode<String>();
    auto provisionalLoadErrorURLString = decoder.decode<String>();
    auto websitePolicies = decoder.decode<std::optional<WebKit::WebsitePoliciesData>>();
    auto originatingFrame = decoder.decode<std::optional<WebKit::FrameInfoData>>();
    auto shouldOpenExternalURLsPolicy = decoder.decode<WebCore::ShouldOpenExternalURLsPolicy>();
    auto shouldTreatAsContinuingLoad = decoder.decode<WebCore::ShouldTreatAsContinuingLoad>();
    auto userData = decoder.decode<WebKit::UserData>();
    auto lockHistory = decoder.decode<WebCore::LockHistory>();
    auto lockBackForwardList = decoder.decode<WebCore::LockBackForwardList>();
    auto sessionHistoryVisibility = decoder.decode<WebCore::SubstituteData::SessionHistoryVisibility>();
    auto clientRedirectSourceForHistory = decoder.decode<String>();
    auto effectiveSandboxFlags = decoder.decode<WebCore::SandboxFlags>();
    auto ownerPermissionsPolicy = decoder.decode<std::optional<WebCore::OwnerPermissionsPolicyData>>();
    auto isNavigatingToAppBoundDomain = decoder.decode<std::optional<WebKit::NavigatingToAppBoundDomain>>();
    auto existingNetworkResourceLoadIdentifierToResume = decoder.decode<std::optional<WebKit::NetworkResourceLoadIdentifier>>();
    auto isServiceWorkerLoad = decoder.decode<bool>();
#if PLATFORM(COCOA)
    auto dataDetectionReferenceDate = decoder.decode<std::optional<double>>();
#endif
    auto isRequestFromClientOrUserInput = decoder.decode<bool>();
    auto isPerformingHTTPFallback = decoder.decode<bool>();
    auto isHandledByAboutSchemeHandler = decoder.decode<bool>();
    auto advancedPrivacyProtections = decoder.decode<std::optional<OptionSet<WebCore::AdvancedPrivacyProtections>>>();
    auto requiredCookiesVersion = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::LoadParameters {
            WTFMove(*publicSuffix),
            WTFMove(*navigationID),
            WTFMove(*frameIdentifier),
            WTFMove(*request),
            WTFMove(*sandboxExtensionHandle),
            WTFMove(*data),
            WTFMove(*MIMEType),
            WTFMove(*encodingName),
            WTFMove(*baseURLString),
            WTFMove(*unreachableURLString),
            WTFMove(*provisionalLoadErrorURLString),
            WTFMove(*websitePolicies),
            WTFMove(*originatingFrame),
            WTFMove(*shouldOpenExternalURLsPolicy),
            WTFMove(*shouldTreatAsContinuingLoad),
            WTFMove(*userData),
            WTFMove(*lockHistory),
            WTFMove(*lockBackForwardList),
            WTFMove(*sessionHistoryVisibility),
            WTFMove(*clientRedirectSourceForHistory),
            WTFMove(*effectiveSandboxFlags),
            WTFMove(*ownerPermissionsPolicy),
            WTFMove(*isNavigatingToAppBoundDomain),
            WTFMove(*existingNetworkResourceLoadIdentifierToResume),
            WTFMove(*isServiceWorkerLoad),
#if PLATFORM(COCOA)
            WTFMove(*dataDetectionReferenceDate),
#endif
            WTFMove(*isRequestFromClientOrUserInput),
            WTFMove(*isPerformingHTTPFallback),
            WTFMove(*isHandledByAboutSchemeHandler),
            WTFMove(*advancedPrivacyProtections),
            WTFMove(*requiredCookiesVersion)
        }
    };
}

#if ENABLE(ARKIT_INLINE_PREVIEW)
void ArgumentCoder<WebKit::ModelIdentifier>::encode(Encoder& encoder, const WebKit::ModelIdentifier& instance)
{
#if ENABLE(ARKIT_INLINE_PREVIEW_MAC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.uuid)>, String>);
#endif
#if ENABLE(ARKIT_INLINE_PREVIEW_IOS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.layerIdentifier)>, WebCore::PlatformLayerIdentifier>);
#endif
    struct ShouldBeSameSizeAsModelIdentifier : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::ModelIdentifier>, false> {
#if ENABLE(ARKIT_INLINE_PREVIEW_MAC)
        String uuid;
#endif
#if ENABLE(ARKIT_INLINE_PREVIEW_IOS)
        WebCore::PlatformLayerIdentifier layerIdentifier;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsModelIdentifier) == sizeof(WebKit::ModelIdentifier));
    static_assert(MembersInCorrectOrder < 0
#if ENABLE(ARKIT_INLINE_PREVIEW_MAC)
        , offsetof(WebKit::ModelIdentifier, uuid)
#endif
#if ENABLE(ARKIT_INLINE_PREVIEW_IOS)
        , offsetof(WebKit::ModelIdentifier, layerIdentifier)
#endif
    >::value);

#if ENABLE(ARKIT_INLINE_PREVIEW_MAC)
    encoder << instance.uuid;
#endif
#if ENABLE(ARKIT_INLINE_PREVIEW_IOS)
    encoder << instance.layerIdentifier;
#endif
}

std::optional<WebKit::ModelIdentifier> ArgumentCoder<WebKit::ModelIdentifier>::decode(Decoder& decoder)
{
#if ENABLE(ARKIT_INLINE_PREVIEW_MAC)
    auto uuid = decoder.decode<String>();
#endif
#if ENABLE(ARKIT_INLINE_PREVIEW_IOS)
    auto layerIdentifier = decoder.decode<WebCore::PlatformLayerIdentifier>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::ModelIdentifier {
#if ENABLE(ARKIT_INLINE_PREVIEW_MAC)
            WTFMove(*uuid),
#endif
#if ENABLE(ARKIT_INLINE_PREVIEW_IOS)
            WTFMove(*layerIdentifier)
#endif
        }
    };
}

#endif

#if ENABLE(MODEL_PROCESS)
void ArgumentCoder<WebKit::ModelProcessConnectionParameters>::encode(Encoder& encoder, WebKit::ModelProcessConnectionParameters&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webProcessIdentity)>, WebCore::ProcessIdentity>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sharedPreferencesForWebProcess)>, WebKit::SharedPreferencesForWebProcess>);
#if ENABLE(IPC_TESTING_API)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ignoreInvalidMessageForTesting)>, bool>);
#endif
#if HAVE(AUDIT_TOKEN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.presentingApplicationAuditToken)>, std::optional<WebKit::CoreIPCAuditToken>>);
#endif
    struct ShouldBeSameSizeAsModelProcessConnectionParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::ModelProcessConnectionParameters>, false> {
        WebCore::ProcessIdentity webProcessIdentity;
        WebKit::SharedPreferencesForWebProcess sharedPreferencesForWebProcess;
#if ENABLE(IPC_TESTING_API)
        bool ignoreInvalidMessageForTesting;
#endif
#if HAVE(AUDIT_TOKEN)
        std::optional<WebKit::CoreIPCAuditToken> presentingApplicationAuditToken;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsModelProcessConnectionParameters) == sizeof(WebKit::ModelProcessConnectionParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::ModelProcessConnectionParameters, webProcessIdentity)
        , offsetof(WebKit::ModelProcessConnectionParameters, sharedPreferencesForWebProcess)
#if ENABLE(IPC_TESTING_API)
        , offsetof(WebKit::ModelProcessConnectionParameters, ignoreInvalidMessageForTesting)
#endif
#if HAVE(AUDIT_TOKEN)
        , offsetof(WebKit::ModelProcessConnectionParameters, presentingApplicationAuditToken)
#endif
    >::value);

    encoder << WTFMove(instance.webProcessIdentity);
    encoder << WTFMove(instance.sharedPreferencesForWebProcess);
#if ENABLE(IPC_TESTING_API)
    encoder << WTFMove(instance.ignoreInvalidMessageForTesting);
#endif
#if HAVE(AUDIT_TOKEN)
    encoder << WTFMove(instance.presentingApplicationAuditToken);
#endif
}

std::optional<WebKit::ModelProcessConnectionParameters> ArgumentCoder<WebKit::ModelProcessConnectionParameters>::decode(Decoder& decoder)
{
    auto webProcessIdentity = decoder.decode<WebCore::ProcessIdentity>();
    auto sharedPreferencesForWebProcess = decoder.decode<WebKit::SharedPreferencesForWebProcess>();
#if ENABLE(IPC_TESTING_API)
    auto ignoreInvalidMessageForTesting = decoder.decode<bool>();
#endif
#if HAVE(AUDIT_TOKEN)
    auto presentingApplicationAuditToken = decoder.decode<std::optional<WebKit::CoreIPCAuditToken>>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::ModelProcessConnectionParameters {
            WTFMove(*webProcessIdentity),
            WTFMove(*sharedPreferencesForWebProcess),
#if ENABLE(IPC_TESTING_API)
            WTFMove(*ignoreInvalidMessageForTesting),
#endif
#if HAVE(AUDIT_TOKEN)
            WTFMove(*presentingApplicationAuditToken)
#endif
        }
    };
}

#endif

void ArgumentCoder<WebKit::EditorStateIdentifier>::encode(Encoder& encoder, const WebKit::EditorStateIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.toUInt64())>, uint64_t>);

    encoder << instance.toUInt64();
}

void ArgumentCoder<WebKit::EditorStateIdentifier>::encode(StreamConnectionEncoder& encoder, const WebKit::EditorStateIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.toUInt64())>, uint64_t>);

    encoder << instance.toUInt64();
}

std::optional<WebKit::EditorStateIdentifier> ArgumentCoder<WebKit::EditorStateIdentifier>::decode(Decoder& decoder)
{
    auto toUInt64 = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(WebKit::MonotonicObjectIdentifier<WebKit::EditorStateIdentifierType>::isValidIdentifier(*toUInt64)))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::EditorStateIdentifier {
            WTFMove(*toUInt64)
        }
    };
}

void ArgumentCoder<WebKit::RenderingUpdateID>::encode(Encoder& encoder, const WebKit::RenderingUpdateID& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.toUInt64())>, uint64_t>);

    encoder << instance.toUInt64();
}

void ArgumentCoder<WebKit::RenderingUpdateID>::encode(StreamConnectionEncoder& encoder, const WebKit::RenderingUpdateID& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.toUInt64())>, uint64_t>);

    encoder << instance.toUInt64();
}

std::optional<WebKit::RenderingUpdateID> ArgumentCoder<WebKit::RenderingUpdateID>::decode(Decoder& decoder)
{
    auto toUInt64 = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(WebKit::MonotonicObjectIdentifier<WebKit::RenderingUpdateIDType>::isValidIdentifier(*toUInt64)))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::RenderingUpdateID {
            WTFMove(*toUInt64)
        }
    };
}

void ArgumentCoder<WebKit::TransactionIdentifier>::encode(Encoder& encoder, const WebKit::TransactionIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.toUInt64())>, uint64_t>);

    encoder << instance.toUInt64();
}

void ArgumentCoder<WebKit::TransactionIdentifier>::encode(StreamConnectionEncoder& encoder, const WebKit::TransactionIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.toUInt64())>, uint64_t>);

    encoder << instance.toUInt64();
}

std::optional<WebKit::TransactionIdentifier> ArgumentCoder<WebKit::TransactionIdentifier>::decode(Decoder& decoder)
{
    auto toUInt64 = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(WebKit::MonotonicObjectIdentifier<WebKit::TransactionIDType>::isValidIdentifier(*toUInt64)))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::TransactionIdentifier {
            WTFMove(*toUInt64)
        }
    };
}

void ArgumentCoder<WebKit::FocusedElementInformationIdentifier>::encode(Encoder& encoder, const WebKit::FocusedElementInformationIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.toUInt64())>, uint64_t>);

    encoder << instance.toUInt64();
}

void ArgumentCoder<WebKit::FocusedElementInformationIdentifier>::encode(StreamConnectionEncoder& encoder, const WebKit::FocusedElementInformationIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.toUInt64())>, uint64_t>);

    encoder << instance.toUInt64();
}

std::optional<WebKit::FocusedElementInformationIdentifier> ArgumentCoder<WebKit::FocusedElementInformationIdentifier>::decode(Decoder& decoder)
{
    auto toUInt64 = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(WebKit::MonotonicObjectIdentifier<WebKit::FocusedElementInformationIdentifierType>::isValidIdentifier(*toUInt64)))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::FocusedElementInformationIdentifier {
            WTFMove(*toUInt64)
        }
    };
}

void ArgumentCoder<WebKit::NavigationActionData>::encode(Encoder& encoder, const WebKit::NavigationActionData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.navigationType)>, WebCore::NavigationType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.modifiers)>, OptionSet<WebKit::WebEventModifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mouseButton)>, WebKit::WebMouseEventButton>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.syntheticClickType)>, WebKit::WebMouseEventSyntheticClickType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.userGestureTokenIdentifier)>, std::optional<WebCore::UserGestureTokenIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.userGestureAuthorizationToken)>, std::optional<WTF::UUID>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.canHandleRequest)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldOpenExternalURLsPolicy)>, WebCore::ShouldOpenExternalURLsPolicy>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.downloadAttribute)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.clickLocationInRootViewCoordinates)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.redirectResponse)>, WebCore::ResourceResponse>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isRequestFromClientOrUserInput)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.treatAsSameOriginNavigation)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasOpenedFrames)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.openedByDOMWithOpener)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasOpener)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isPerformingHTTPFallback)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isInitialFrameSrcLoad)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isContentRuleListRedirect)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.openedMainFrameName)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requesterOrigin)>, WebCore::SecurityOriginData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requesterTopOrigin)>, WebCore::SecurityOriginData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.targetBackForwardItemIdentifier)>, std::optional<WebCore::BackForwardItemIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceBackForwardItemIdentifier)>, std::optional<WebCore::BackForwardItemIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lockHistory)>, WebCore::LockHistory>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lockBackForwardList)>, WebCore::LockBackForwardList>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.clientRedirectSourceForHistory)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.effectiveSandboxFlags)>, WebCore::SandboxFlags>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ownerPermissionsPolicy)>, std::optional<WebCore::OwnerPermissionsPolicyData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.privateClickMeasurement)>, std::optional<WebCore::PrivateClickMeasurement>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.advancedPrivacyProtections)>, OptionSet<WebCore::AdvancedPrivacyProtections>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.originatorAdvancedPrivacyProtections)>, std::optional<OptionSet<WebCore::AdvancedPrivacyProtections>>>);
#if PLATFORM(MAC) || HAVE(UIKIT_WITH_MOUSE_SUPPORT)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webHitTestResultData)>, std::optional<WebKit::WebHitTestResultData>>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.originatingFrameInfoData)>, WebKit::FrameInfoData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.originatingPageID)>, std::optional<WebKit::WebPageProxyIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameInfo)>, WebKit::FrameInfoData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.navigationID)>, std::optional<WebCore::NavigationIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.originalRequest)>, WebCore::ResourceRequest>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.request)>, WebCore::ResourceRequest>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.invalidURLString)>, String>);
    struct ShouldBeSameSizeAsNavigationActionData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::NavigationActionData>, false> {
        WebCore::NavigationType navigationType;
        OptionSet<WebKit::WebEventModifier> modifiers;
        WebKit::WebMouseEventButton mouseButton;
        WebKit::WebMouseEventSyntheticClickType syntheticClickType;
        std::optional<WebCore::UserGestureTokenIdentifier> userGestureTokenIdentifier;
        std::optional<WTF::UUID> userGestureAuthorizationToken;
        bool canHandleRequest;
        WebCore::ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicy;
        String downloadAttribute;
        WebCore::FloatPoint clickLocationInRootViewCoordinates;
        WebCore::ResourceResponse redirectResponse;
        bool isRequestFromClientOrUserInput;
        bool treatAsSameOriginNavigation;
        bool hasOpenedFrames;
        bool openedByDOMWithOpener;
        bool hasOpener;
        bool isPerformingHTTPFallback;
        bool isInitialFrameSrcLoad;
        bool isContentRuleListRedirect;
        String openedMainFrameName;
        WebCore::SecurityOriginData requesterOrigin;
        WebCore::SecurityOriginData requesterTopOrigin;
        std::optional<WebCore::BackForwardItemIdentifier> targetBackForwardItemIdentifier;
        std::optional<WebCore::BackForwardItemIdentifier> sourceBackForwardItemIdentifier;
        WebCore::LockHistory lockHistory;
        WebCore::LockBackForwardList lockBackForwardList;
        String clientRedirectSourceForHistory;
        WebCore::SandboxFlags effectiveSandboxFlags;
        std::optional<WebCore::OwnerPermissionsPolicyData> ownerPermissionsPolicy;
        std::optional<WebCore::PrivateClickMeasurement> privateClickMeasurement;
        OptionSet<WebCore::AdvancedPrivacyProtections> advancedPrivacyProtections;
        std::optional<OptionSet<WebCore::AdvancedPrivacyProtections>> originatorAdvancedPrivacyProtections;
#if PLATFORM(MAC) || HAVE(UIKIT_WITH_MOUSE_SUPPORT)
        std::optional<WebKit::WebHitTestResultData> webHitTestResultData;
#endif
        WebKit::FrameInfoData originatingFrameInfoData;
        std::optional<WebKit::WebPageProxyIdentifier> originatingPageID;
        WebKit::FrameInfoData frameInfo;
        std::optional<WebCore::NavigationIdentifier> navigationID;
        WebCore::ResourceRequest originalRequest;
        WebCore::ResourceRequest request;
        String invalidURLString;
    };
    static_assert(sizeof(ShouldBeSameSizeAsNavigationActionData) == sizeof(WebKit::NavigationActionData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::NavigationActionData, navigationType)
        , offsetof(WebKit::NavigationActionData, modifiers)
        , offsetof(WebKit::NavigationActionData, mouseButton)
        , offsetof(WebKit::NavigationActionData, syntheticClickType)
        , offsetof(WebKit::NavigationActionData, userGestureTokenIdentifier)
        , offsetof(WebKit::NavigationActionData, userGestureAuthorizationToken)
        , offsetof(WebKit::NavigationActionData, canHandleRequest)
        , offsetof(WebKit::NavigationActionData, shouldOpenExternalURLsPolicy)
        , offsetof(WebKit::NavigationActionData, downloadAttribute)
        , offsetof(WebKit::NavigationActionData, clickLocationInRootViewCoordinates)
        , offsetof(WebKit::NavigationActionData, redirectResponse)
        , offsetof(WebKit::NavigationActionData, isRequestFromClientOrUserInput)
        , offsetof(WebKit::NavigationActionData, treatAsSameOriginNavigation)
        , offsetof(WebKit::NavigationActionData, hasOpenedFrames)
        , offsetof(WebKit::NavigationActionData, openedByDOMWithOpener)
        , offsetof(WebKit::NavigationActionData, hasOpener)
        , offsetof(WebKit::NavigationActionData, isPerformingHTTPFallback)
        , offsetof(WebKit::NavigationActionData, isInitialFrameSrcLoad)
        , offsetof(WebKit::NavigationActionData, isContentRuleListRedirect)
        , offsetof(WebKit::NavigationActionData, openedMainFrameName)
        , offsetof(WebKit::NavigationActionData, requesterOrigin)
        , offsetof(WebKit::NavigationActionData, requesterTopOrigin)
        , offsetof(WebKit::NavigationActionData, targetBackForwardItemIdentifier)
        , offsetof(WebKit::NavigationActionData, sourceBackForwardItemIdentifier)
        , offsetof(WebKit::NavigationActionData, lockHistory)
        , offsetof(WebKit::NavigationActionData, lockBackForwardList)
        , offsetof(WebKit::NavigationActionData, clientRedirectSourceForHistory)
        , offsetof(WebKit::NavigationActionData, effectiveSandboxFlags)
        , offsetof(WebKit::NavigationActionData, ownerPermissionsPolicy)
        , offsetof(WebKit::NavigationActionData, privateClickMeasurement)
        , offsetof(WebKit::NavigationActionData, advancedPrivacyProtections)
        , offsetof(WebKit::NavigationActionData, originatorAdvancedPrivacyProtections)
#if PLATFORM(MAC) || HAVE(UIKIT_WITH_MOUSE_SUPPORT)
        , offsetof(WebKit::NavigationActionData, webHitTestResultData)
#endif
        , offsetof(WebKit::NavigationActionData, originatingFrameInfoData)
        , offsetof(WebKit::NavigationActionData, originatingPageID)
        , offsetof(WebKit::NavigationActionData, frameInfo)
        , offsetof(WebKit::NavigationActionData, navigationID)
        , offsetof(WebKit::NavigationActionData, originalRequest)
        , offsetof(WebKit::NavigationActionData, request)
        , offsetof(WebKit::NavigationActionData, invalidURLString)
    >::value);

    encoder << instance.navigationType;
    encoder << instance.modifiers;
    encoder << instance.mouseButton;
    encoder << instance.syntheticClickType;
    encoder << instance.userGestureTokenIdentifier;
    encoder << instance.userGestureAuthorizationToken;
    encoder << instance.canHandleRequest;
    encoder << instance.shouldOpenExternalURLsPolicy;
    encoder << instance.downloadAttribute;
    encoder << instance.clickLocationInRootViewCoordinates;
    encoder << instance.redirectResponse;
    encoder << instance.isRequestFromClientOrUserInput;
    encoder << instance.treatAsSameOriginNavigation;
    encoder << instance.hasOpenedFrames;
    encoder << instance.openedByDOMWithOpener;
    encoder << instance.hasOpener;
    encoder << instance.isPerformingHTTPFallback;
    encoder << instance.isInitialFrameSrcLoad;
    encoder << instance.isContentRuleListRedirect;
    encoder << instance.openedMainFrameName;
    encoder << instance.requesterOrigin;
    encoder << instance.requesterTopOrigin;
    encoder << instance.targetBackForwardItemIdentifier;
    encoder << instance.sourceBackForwardItemIdentifier;
    encoder << instance.lockHistory;
    encoder << instance.lockBackForwardList;
    encoder << instance.clientRedirectSourceForHistory;
    encoder << instance.effectiveSandboxFlags;
    encoder << instance.ownerPermissionsPolicy;
    encoder << instance.privateClickMeasurement;
    encoder << instance.advancedPrivacyProtections;
    encoder << instance.originatorAdvancedPrivacyProtections;
#if PLATFORM(MAC) || HAVE(UIKIT_WITH_MOUSE_SUPPORT)
    encoder << instance.webHitTestResultData;
#endif
    encoder << instance.originatingFrameInfoData;
    encoder << instance.originatingPageID;
    encoder << instance.frameInfo;
    encoder << instance.navigationID;
    encoder << instance.originalRequest;
    encoder << instance.request;
    encoder << IPC::FormDataReference { instance.request.httpBody() };
    encoder << instance.invalidURLString;
}

std::optional<WebKit::NavigationActionData> ArgumentCoder<WebKit::NavigationActionData>::decode(Decoder& decoder)
{
    auto navigationType = decoder.decode<WebCore::NavigationType>();
    auto modifiers = decoder.decode<OptionSet<WebKit::WebEventModifier>>();
    auto mouseButton = decoder.decode<WebKit::WebMouseEventButton>();
    auto syntheticClickType = decoder.decode<WebKit::WebMouseEventSyntheticClickType>();
    auto userGestureTokenIdentifier = decoder.decode<std::optional<WebCore::UserGestureTokenIdentifier>>();
    auto userGestureAuthorizationToken = decoder.decode<std::optional<WTF::UUID>>();
    auto canHandleRequest = decoder.decode<bool>();
    auto shouldOpenExternalURLsPolicy = decoder.decode<WebCore::ShouldOpenExternalURLsPolicy>();
    auto downloadAttribute = decoder.decode<String>();
    auto clickLocationInRootViewCoordinates = decoder.decode<WebCore::FloatPoint>();
    auto redirectResponse = decoder.decode<WebCore::ResourceResponse>();
    auto isRequestFromClientOrUserInput = decoder.decode<bool>();
    auto treatAsSameOriginNavigation = decoder.decode<bool>();
    auto hasOpenedFrames = decoder.decode<bool>();
    auto openedByDOMWithOpener = decoder.decode<bool>();
    auto hasOpener = decoder.decode<bool>();
    auto isPerformingHTTPFallback = decoder.decode<bool>();
    auto isInitialFrameSrcLoad = decoder.decode<bool>();
    auto isContentRuleListRedirect = decoder.decode<bool>();
    auto openedMainFrameName = decoder.decode<String>();
    auto requesterOrigin = decoder.decode<WebCore::SecurityOriginData>();
    auto requesterTopOrigin = decoder.decode<WebCore::SecurityOriginData>();
    auto targetBackForwardItemIdentifier = decoder.decode<std::optional<WebCore::BackForwardItemIdentifier>>();
    auto sourceBackForwardItemIdentifier = decoder.decode<std::optional<WebCore::BackForwardItemIdentifier>>();
    auto lockHistory = decoder.decode<WebCore::LockHistory>();
    auto lockBackForwardList = decoder.decode<WebCore::LockBackForwardList>();
    auto clientRedirectSourceForHistory = decoder.decode<String>();
    auto effectiveSandboxFlags = decoder.decode<WebCore::SandboxFlags>();
    auto ownerPermissionsPolicy = decoder.decode<std::optional<WebCore::OwnerPermissionsPolicyData>>();
    auto privateClickMeasurement = decoder.decode<std::optional<WebCore::PrivateClickMeasurement>>();
    auto advancedPrivacyProtections = decoder.decode<OptionSet<WebCore::AdvancedPrivacyProtections>>();
    auto originatorAdvancedPrivacyProtections = decoder.decode<std::optional<OptionSet<WebCore::AdvancedPrivacyProtections>>>();
#if PLATFORM(MAC) || HAVE(UIKIT_WITH_MOUSE_SUPPORT)
    auto webHitTestResultData = decoder.decode<std::optional<WebKit::WebHitTestResultData>>();
#endif
    auto originatingFrameInfoData = decoder.decode<WebKit::FrameInfoData>();
    auto originatingPageID = decoder.decode<std::optional<WebKit::WebPageProxyIdentifier>>();
    auto frameInfo = decoder.decode<WebKit::FrameInfoData>();
    auto navigationID = decoder.decode<std::optional<WebCore::NavigationIdentifier>>();
    auto originalRequest = decoder.decode<WebCore::ResourceRequest>();
    auto request = decoder.decode<WebCore::ResourceRequest>();
    if (request) {
        if (auto requestBody = decoder.decode<IPC::FormDataReference>())
            request->setHTTPBody(requestBody->takeData());
    }
    auto invalidURLString = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::NavigationActionData {
            WTFMove(*navigationType),
            WTFMove(*modifiers),
            WTFMove(*mouseButton),
            WTFMove(*syntheticClickType),
            WTFMove(*userGestureTokenIdentifier),
            WTFMove(*userGestureAuthorizationToken),
            WTFMove(*canHandleRequest),
            WTFMove(*shouldOpenExternalURLsPolicy),
            WTFMove(*downloadAttribute),
            WTFMove(*clickLocationInRootViewCoordinates),
            WTFMove(*redirectResponse),
            WTFMove(*isRequestFromClientOrUserInput),
            WTFMove(*treatAsSameOriginNavigation),
            WTFMove(*hasOpenedFrames),
            WTFMove(*openedByDOMWithOpener),
            WTFMove(*hasOpener),
            WTFMove(*isPerformingHTTPFallback),
            WTFMove(*isInitialFrameSrcLoad),
            WTFMove(*isContentRuleListRedirect),
            WTFMove(*openedMainFrameName),
            WTFMove(*requesterOrigin),
            WTFMove(*requesterTopOrigin),
            WTFMove(*targetBackForwardItemIdentifier),
            WTFMove(*sourceBackForwardItemIdentifier),
            WTFMove(*lockHistory),
            WTFMove(*lockBackForwardList),
            WTFMove(*clientRedirectSourceForHistory),
            WTFMove(*effectiveSandboxFlags),
            WTFMove(*ownerPermissionsPolicy),
            WTFMove(*privateClickMeasurement),
            WTFMove(*advancedPrivacyProtections),
            WTFMove(*originatorAdvancedPrivacyProtections),
#if PLATFORM(MAC) || HAVE(UIKIT_WITH_MOUSE_SUPPORT)
            WTFMove(*webHitTestResultData),
#endif
            WTFMove(*originatingFrameInfoData),
            WTFMove(*originatingPageID),
            WTFMove(*frameInfo),
            WTFMove(*navigationID),
            WTFMove(*originalRequest),
            WTFMove(*request),
            WTFMove(*invalidURLString)
        }
    };
}

void ArgumentCoder<WebKit::NetworkProcessConnectionParameters>::encode(Encoder& encoder, const WebKit::NetworkProcessConnectionParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sharedPreferencesForWebProcess)>, WebKit::SharedPreferencesForWebProcess>);
#if ENABLE(IPC_TESTING_API)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ignoreInvalidMessageForTesting)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pagesWithRelaxedThirdPartyCookieBlocking)>, Vector<WebKit::WebPageProxyIdentifier>>);
    struct ShouldBeSameSizeAsNetworkProcessConnectionParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::NetworkProcessConnectionParameters>, false> {
        WebKit::SharedPreferencesForWebProcess sharedPreferencesForWebProcess;
#if ENABLE(IPC_TESTING_API)
        bool ignoreInvalidMessageForTesting;
#endif
        Vector<WebKit::WebPageProxyIdentifier> pagesWithRelaxedThirdPartyCookieBlocking;
    };
    static_assert(sizeof(ShouldBeSameSizeAsNetworkProcessConnectionParameters) == sizeof(WebKit::NetworkProcessConnectionParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::NetworkProcessConnectionParameters, sharedPreferencesForWebProcess)
#if ENABLE(IPC_TESTING_API)
        , offsetof(WebKit::NetworkProcessConnectionParameters, ignoreInvalidMessageForTesting)
#endif
        , offsetof(WebKit::NetworkProcessConnectionParameters, pagesWithRelaxedThirdPartyCookieBlocking)
    >::value);

    encoder << instance.sharedPreferencesForWebProcess;
#if ENABLE(IPC_TESTING_API)
    encoder << instance.ignoreInvalidMessageForTesting;
#endif
    encoder << instance.pagesWithRelaxedThirdPartyCookieBlocking;
}

std::optional<WebKit::NetworkProcessConnectionParameters> ArgumentCoder<WebKit::NetworkProcessConnectionParameters>::decode(Decoder& decoder)
{
    auto sharedPreferencesForWebProcess = decoder.decode<WebKit::SharedPreferencesForWebProcess>();
#if ENABLE(IPC_TESTING_API)
    auto ignoreInvalidMessageForTesting = decoder.decode<bool>();
#endif
    auto pagesWithRelaxedThirdPartyCookieBlocking = decoder.decode<Vector<WebKit::WebPageProxyIdentifier>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::NetworkProcessConnectionParameters {
            WTFMove(*sharedPreferencesForWebProcess),
#if ENABLE(IPC_TESTING_API)
            WTFMove(*ignoreInvalidMessageForTesting),
#endif
            WTFMove(*pagesWithRelaxedThirdPartyCookieBlocking)
        }
    };
}

void ArgumentCoder<WebCore::PasteboardImage>::encode(Encoder& encoder, const WebCore::PasteboardImage& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.image)>, RefPtr<WebCore::Image>>);
#if PLATFORM(MAC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dataInWebArchiveFormat)>, RefPtr<WebCore::SharedBuffer>>);
#endif
#if PLATFORM(MAC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dataInHTMLFormat)>, String>);
#endif
#if !PLATFORM(WIN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url)>, WebCore::PasteboardURL>);
#endif
#if !(PLATFORM(GTK) || PLATFORM(WPE) || PLATFORM(WIN))
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.resourceData)>, RefPtr<WebCore::SharedBuffer>>);
#endif
#if !(PLATFORM(GTK) || PLATFORM(WPE) || PLATFORM(WIN))
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.resourceMIMEType)>, String>);
#endif
#if !(PLATFORM(GTK) || PLATFORM(WPE) || PLATFORM(WIN))
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.clientTypesAndData)>, Vector<std::pair<String, RefPtr<WebCore::SharedBuffer>>>>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.suggestedName)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.imageSize)>, WebCore::FloatSize>);
    struct ShouldBeSameSizeAsPasteboardImage : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PasteboardImage>, false> {
        RefPtr<WebCore::Image> image;
#if PLATFORM(MAC)
        RefPtr<WebCore::SharedBuffer> dataInWebArchiveFormat;
#endif
#if PLATFORM(MAC)
        String dataInHTMLFormat;
#endif
#if !PLATFORM(WIN)
        WebCore::PasteboardURL url;
#endif
#if !(PLATFORM(GTK) || PLATFORM(WPE) || PLATFORM(WIN))
        RefPtr<WebCore::SharedBuffer> resourceData;
#endif
#if !(PLATFORM(GTK) || PLATFORM(WPE) || PLATFORM(WIN))
        String resourceMIMEType;
#endif
#if !(PLATFORM(GTK) || PLATFORM(WPE) || PLATFORM(WIN))
        Vector<std::pair<String, RefPtr<WebCore::SharedBuffer>>> clientTypesAndData;
#endif
        String suggestedName;
        WebCore::FloatSize imageSize;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPasteboardImage) == sizeof(WebCore::PasteboardImage));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PasteboardImage, image)
#if PLATFORM(MAC)
        , offsetof(WebCore::PasteboardImage, dataInWebArchiveFormat)
#endif
#if PLATFORM(MAC)
        , offsetof(WebCore::PasteboardImage, dataInHTMLFormat)
#endif
#if !PLATFORM(WIN)
        , offsetof(WebCore::PasteboardImage, url)
#endif
#if !(PLATFORM(GTK) || PLATFORM(WPE) || PLATFORM(WIN))
        , offsetof(WebCore::PasteboardImage, resourceData)
#endif
#if !(PLATFORM(GTK) || PLATFORM(WPE) || PLATFORM(WIN))
        , offsetof(WebCore::PasteboardImage, resourceMIMEType)
#endif
#if !(PLATFORM(GTK) || PLATFORM(WPE) || PLATFORM(WIN))
        , offsetof(WebCore::PasteboardImage, clientTypesAndData)
#endif
        , offsetof(WebCore::PasteboardImage, suggestedName)
        , offsetof(WebCore::PasteboardImage, imageSize)
    >::value);

    encoder << instance.image;
#if PLATFORM(MAC)
    encoder << instance.dataInWebArchiveFormat;
#endif
#if PLATFORM(MAC)
    encoder << instance.dataInHTMLFormat;
#endif
#if !PLATFORM(WIN)
    encoder << instance.url;
#endif
#if !(PLATFORM(GTK) || PLATFORM(WPE) || PLATFORM(WIN))
    encoder << instance.resourceData;
#endif
#if !(PLATFORM(GTK) || PLATFORM(WPE) || PLATFORM(WIN))
    encoder << instance.resourceMIMEType;
#endif
#if !(PLATFORM(GTK) || PLATFORM(WPE) || PLATFORM(WIN))
    encoder << instance.clientTypesAndData;
#endif
    encoder << instance.suggestedName;
    encoder << instance.imageSize;
}

std::optional<WebCore::PasteboardImage> ArgumentCoder<WebCore::PasteboardImage>::decode(Decoder& decoder)
{
    auto image = decoder.decode<RefPtr<WebCore::Image>>();
#if PLATFORM(MAC)
    auto dataInWebArchiveFormat = decoder.decode<RefPtr<WebCore::SharedBuffer>>();
#endif
#if PLATFORM(MAC)
    auto dataInHTMLFormat = decoder.decode<String>();
#endif
#if !PLATFORM(WIN)
    auto url = decoder.decode<WebCore::PasteboardURL>();
#endif
#if !(PLATFORM(GTK) || PLATFORM(WPE) || PLATFORM(WIN))
    auto resourceData = decoder.decode<RefPtr<WebCore::SharedBuffer>>();
#endif
#if !(PLATFORM(GTK) || PLATFORM(WPE) || PLATFORM(WIN))
    auto resourceMIMEType = decoder.decode<String>();
#endif
#if !(PLATFORM(GTK) || PLATFORM(WPE) || PLATFORM(WIN))
    auto clientTypesAndData = decoder.decode<Vector<std::pair<String, RefPtr<WebCore::SharedBuffer>>>>();
#endif
    auto suggestedName = decoder.decode<String>();
    auto imageSize = decoder.decode<WebCore::FloatSize>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PasteboardImage {
            WTFMove(*image),
#if PLATFORM(MAC)
            WTFMove(*dataInWebArchiveFormat),
#endif
#if PLATFORM(MAC)
            WTFMove(*dataInHTMLFormat),
#endif
#if !PLATFORM(WIN)
            WTFMove(*url),
#endif
#if !(PLATFORM(GTK) || PLATFORM(WPE) || PLATFORM(WIN))
            WTFMove(*resourceData),
#endif
#if !(PLATFORM(GTK) || PLATFORM(WPE) || PLATFORM(WIN))
            WTFMove(*resourceMIMEType),
#endif
#if !(PLATFORM(GTK) || PLATFORM(WPE) || PLATFORM(WIN))
            WTFMove(*clientTypesAndData),
#endif
            WTFMove(*suggestedName),
            WTFMove(*imageSize)
        }
    };
}

void ArgumentCoder<WebCore::PasteboardWebContent>::encode(Encoder& encoder, const WebCore::PasteboardWebContent& instance)
{
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentOrigin)>, String>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.canSmartCopyOrDelete)>, bool>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dataInWebArchiveFormat)>, RefPtr<WebCore::SharedBuffer>>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dataInRTFDFormat)>, RefPtr<WebCore::SharedBuffer>>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dataInRTFFormat)>, RefPtr<WebCore::SharedBuffer>>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dataInAttributedStringFormat)>, RefPtr<WebCore::SharedBuffer>>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dataInHTMLFormat)>, String>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dataInStringFormat)>, String>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.clientTypesAndData)>, Vector<std::pair<String, RefPtr<WebCore::SharedBuffer>>>>);
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentOrigin)>, String>);
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.canSmartCopyOrDelete)>, bool>);
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.text)>, String>);
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.markup)>, String>);
#endif
#if USE(LIBWPE) && !PLATFORM(WPE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.text)>, String>);
#endif
#if USE(LIBWPE) && !PLATFORM(WPE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.markup)>, String>);
#endif
    struct ShouldBeSameSizeAsPasteboardWebContent : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PasteboardWebContent>, false> {
#if PLATFORM(COCOA)
        String contentOrigin;
#endif
#if PLATFORM(COCOA)
        bool canSmartCopyOrDelete;
#endif
#if PLATFORM(COCOA)
        RefPtr<WebCore::SharedBuffer> dataInWebArchiveFormat;
#endif
#if PLATFORM(COCOA)
        RefPtr<WebCore::SharedBuffer> dataInRTFDFormat;
#endif
#if PLATFORM(COCOA)
        RefPtr<WebCore::SharedBuffer> dataInRTFFormat;
#endif
#if PLATFORM(COCOA)
        RefPtr<WebCore::SharedBuffer> dataInAttributedStringFormat;
#endif
#if PLATFORM(COCOA)
        String dataInHTMLFormat;
#endif
#if PLATFORM(COCOA)
        String dataInStringFormat;
#endif
#if PLATFORM(COCOA)
        Vector<std::pair<String, RefPtr<WebCore::SharedBuffer>>> clientTypesAndData;
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
        String contentOrigin;
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
        bool canSmartCopyOrDelete;
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
        String text;
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
        String markup;
#endif
#if USE(LIBWPE) && !PLATFORM(WPE)
        String text;
#endif
#if USE(LIBWPE) && !PLATFORM(WPE)
        String markup;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsPasteboardWebContent) == sizeof(WebCore::PasteboardWebContent));
    static_assert(MembersInCorrectOrder < 0
#if PLATFORM(COCOA)
        , offsetof(WebCore::PasteboardWebContent, contentOrigin)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebCore::PasteboardWebContent, canSmartCopyOrDelete)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebCore::PasteboardWebContent, dataInWebArchiveFormat)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebCore::PasteboardWebContent, dataInRTFDFormat)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebCore::PasteboardWebContent, dataInRTFFormat)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebCore::PasteboardWebContent, dataInAttributedStringFormat)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebCore::PasteboardWebContent, dataInHTMLFormat)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebCore::PasteboardWebContent, dataInStringFormat)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebCore::PasteboardWebContent, clientTypesAndData)
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
        , offsetof(WebCore::PasteboardWebContent, contentOrigin)
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
        , offsetof(WebCore::PasteboardWebContent, canSmartCopyOrDelete)
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
        , offsetof(WebCore::PasteboardWebContent, text)
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
        , offsetof(WebCore::PasteboardWebContent, markup)
#endif
#if USE(LIBWPE) && !PLATFORM(WPE)
        , offsetof(WebCore::PasteboardWebContent, text)
#endif
#if USE(LIBWPE) && !PLATFORM(WPE)
        , offsetof(WebCore::PasteboardWebContent, markup)
#endif
    >::value);

#if PLATFORM(COCOA)
    encoder << instance.contentOrigin;
#endif
#if PLATFORM(COCOA)
    encoder << instance.canSmartCopyOrDelete;
#endif
#if PLATFORM(COCOA)
    encoder << instance.dataInWebArchiveFormat;
#endif
#if PLATFORM(COCOA)
    encoder << instance.dataInRTFDFormat;
#endif
#if PLATFORM(COCOA)
    encoder << instance.dataInRTFFormat;
#endif
#if PLATFORM(COCOA)
    encoder << instance.dataInAttributedStringFormat;
#endif
#if PLATFORM(COCOA)
    encoder << instance.dataInHTMLFormat;
#endif
#if PLATFORM(COCOA)
    encoder << instance.dataInStringFormat;
#endif
#if PLATFORM(COCOA)
    encoder << instance.clientTypesAndData;
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    encoder << instance.contentOrigin;
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    encoder << instance.canSmartCopyOrDelete;
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    encoder << instance.text;
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    encoder << instance.markup;
#endif
#if USE(LIBWPE) && !PLATFORM(WPE)
    encoder << instance.text;
#endif
#if USE(LIBWPE) && !PLATFORM(WPE)
    encoder << instance.markup;
#endif
}

std::optional<WebCore::PasteboardWebContent> ArgumentCoder<WebCore::PasteboardWebContent>::decode(Decoder& decoder)
{
#if PLATFORM(COCOA)
    auto contentOrigin = decoder.decode<String>();
#endif
#if PLATFORM(COCOA)
    auto canSmartCopyOrDelete = decoder.decode<bool>();
#endif
#if PLATFORM(COCOA)
    auto dataInWebArchiveFormat = decoder.decode<RefPtr<WebCore::SharedBuffer>>();
#endif
#if PLATFORM(COCOA)
    auto dataInRTFDFormat = decoder.decode<RefPtr<WebCore::SharedBuffer>>();
#endif
#if PLATFORM(COCOA)
    auto dataInRTFFormat = decoder.decode<RefPtr<WebCore::SharedBuffer>>();
#endif
#if PLATFORM(COCOA)
    auto dataInAttributedStringFormat = decoder.decode<RefPtr<WebCore::SharedBuffer>>();
#endif
#if PLATFORM(COCOA)
    auto dataInHTMLFormat = decoder.decode<String>();
#endif
#if PLATFORM(COCOA)
    auto dataInStringFormat = decoder.decode<String>();
#endif
#if PLATFORM(COCOA)
    auto clientTypesAndData = decoder.decode<Vector<std::pair<String, RefPtr<WebCore::SharedBuffer>>>>();
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    auto contentOrigin = decoder.decode<String>();
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    auto canSmartCopyOrDelete = decoder.decode<bool>();
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    auto text = decoder.decode<String>();
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    auto markup = decoder.decode<String>();
#endif
#if USE(LIBWPE) && !PLATFORM(WPE)
    auto text = decoder.decode<String>();
#endif
#if USE(LIBWPE) && !PLATFORM(WPE)
    auto markup = decoder.decode<String>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PasteboardWebContent {
#if PLATFORM(COCOA)
            WTFMove(*contentOrigin),
#endif
#if PLATFORM(COCOA)
            WTFMove(*canSmartCopyOrDelete),
#endif
#if PLATFORM(COCOA)
            WTFMove(*dataInWebArchiveFormat),
#endif
#if PLATFORM(COCOA)
            WTFMove(*dataInRTFDFormat),
#endif
#if PLATFORM(COCOA)
            WTFMove(*dataInRTFFormat),
#endif
#if PLATFORM(COCOA)
            WTFMove(*dataInAttributedStringFormat),
#endif
#if PLATFORM(COCOA)
            WTFMove(*dataInHTMLFormat),
#endif
#if PLATFORM(COCOA)
            WTFMove(*dataInStringFormat),
#endif
#if PLATFORM(COCOA)
            WTFMove(*clientTypesAndData),
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
            WTFMove(*contentOrigin),
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
            WTFMove(*canSmartCopyOrDelete),
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
            WTFMove(*text),
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
            WTFMove(*markup),
#endif
#if USE(LIBWPE) && !PLATFORM(WPE)
            WTFMove(*text),
#endif
#if USE(LIBWPE) && !PLATFORM(WPE)
            WTFMove(*markup)
#endif
        }
    };
}

void ArgumentCoder<WebCore::PasteboardURL>::encode(Encoder& encoder, const WebCore::PasteboardURL& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.title)>, String>);
#if PLATFORM(MAC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.userVisibleForm)>, String>);
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.markup)>, String>);
#endif
    struct ShouldBeSameSizeAsPasteboardURL : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PasteboardURL>, false> {
        URL url;
        String title;
#if PLATFORM(MAC)
        String userVisibleForm;
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
        String markup;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsPasteboardURL) == sizeof(WebCore::PasteboardURL));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PasteboardURL, url)
        , offsetof(WebCore::PasteboardURL, title)
#if PLATFORM(MAC)
        , offsetof(WebCore::PasteboardURL, userVisibleForm)
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
        , offsetof(WebCore::PasteboardURL, markup)
#endif
    >::value);

    encoder << instance.url;
    encoder << instance.title;
#if PLATFORM(MAC)
    encoder << instance.userVisibleForm;
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    encoder << instance.markup;
#endif
}

std::optional<WebCore::PasteboardURL> ArgumentCoder<WebCore::PasteboardURL>::decode(Decoder& decoder)
{
    auto url = decoder.decode<URL>();
    auto title = decoder.decode<String>();
#if PLATFORM(MAC)
    auto userVisibleForm = decoder.decode<String>();
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    auto markup = decoder.decode<String>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PasteboardURL {
            WTFMove(*url),
            WTFMove(*title),
#if PLATFORM(MAC)
            WTFMove(*userVisibleForm),
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
            WTFMove(*markup)
#endif
        }
    };
}

void ArgumentCoder<WebCore::PasteboardBuffer>::encode(Encoder& encoder, const WebCore::PasteboardBuffer& instance)
{
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentOrigin)>, String>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data)>, RefPtr<WebCore::SharedBuffer>>);
    struct ShouldBeSameSizeAsPasteboardBuffer : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PasteboardBuffer>, false> {
#if PLATFORM(COCOA)
        String contentOrigin;
#endif
        String type;
        RefPtr<WebCore::SharedBuffer> data;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPasteboardBuffer) == sizeof(WebCore::PasteboardBuffer));
    static_assert(MembersInCorrectOrder < 0
#if PLATFORM(COCOA)
        , offsetof(WebCore::PasteboardBuffer, contentOrigin)
#endif
        , offsetof(WebCore::PasteboardBuffer, type)
        , offsetof(WebCore::PasteboardBuffer, data)
    >::value);

#if PLATFORM(COCOA)
    encoder << instance.contentOrigin;
#endif
    encoder << instance.type;
    encoder << instance.data;
}

std::optional<WebCore::PasteboardBuffer> ArgumentCoder<WebCore::PasteboardBuffer>::decode(Decoder& decoder)
{
#if PLATFORM(COCOA)
    auto contentOrigin = decoder.decode<String>();
#endif
    auto type = decoder.decode<String>();
    auto data = decoder.decode<RefPtr<WebCore::SharedBuffer>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PasteboardBuffer {
#if PLATFORM(COCOA)
            WTFMove(*contentOrigin),
#endif
            WTFMove(*type),
            WTFMove(*data)
        }
    };
}

void ArgumentCoder<WebKit::PlatformFontInfo>::encode(Encoder& encoder, const WebKit::PlatformFontInfo& instance)
{
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fontAttributeDictionary)>, RetainPtr<CFDictionaryRef>>);
#endif
    struct ShouldBeSameSizeAsPlatformFontInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::PlatformFontInfo>, false> {
#if PLATFORM(COCOA)
        RetainPtr<CFDictionaryRef> fontAttributeDictionary;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsPlatformFontInfo) == sizeof(WebKit::PlatformFontInfo));
    static_assert(MembersInCorrectOrder < 0
#if PLATFORM(COCOA)
        , offsetof(WebKit::PlatformFontInfo, fontAttributeDictionary)
#endif
    >::value);

#if PLATFORM(COCOA)
    encoder << instance.fontAttributeDictionary;
#endif
}

std::optional<WebKit::PlatformFontInfo> ArgumentCoder<WebKit::PlatformFontInfo>::decode(Decoder& decoder)
{
#if PLATFORM(COCOA)
    auto fontAttributeDictionary = decoder.decode<RetainPtr<CFDictionaryRef>>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::PlatformFontInfo {
#if PLATFORM(COCOA)
            WTFMove(*fontAttributeDictionary)
#endif
        }
    };
}

void ArgumentCoder<WebKit::PlatformPopupMenuData>::encode(Encoder& encoder, const WebKit::PlatformPopupMenuData& instance)
{
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fontInfo)>, WebKit::PlatformFontInfo>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldPopOver)>, bool>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hideArrows)>, bool>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.menuSize)>, WebCore::PopupMenuStyle::Size>);
#endif
#if PLATFORM(WIN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_clientPaddingLeft)>, int>);
#endif
#if PLATFORM(WIN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_clientPaddingRight)>, int>);
#endif
#if PLATFORM(WIN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_clientInsetLeft)>, int>);
#endif
#if PLATFORM(WIN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_clientInsetRight)>, int>);
#endif
#if PLATFORM(WIN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_popupWidth)>, int>);
#endif
#if PLATFORM(WIN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_itemHeight)>, float>);
#endif
#if PLATFORM(WIN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_isRTL)>, bool>);
#endif
#if PLATFORM(WIN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_notSelectedBackingStore)>, RefPtr<WebCore::ShareableBitmap>>);
#endif
#if PLATFORM(WIN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_selectedBackingStore)>, RefPtr<WebCore::ShareableBitmap>>);
#endif
    struct ShouldBeSameSizeAsPlatformPopupMenuData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::PlatformPopupMenuData>, false> {
#if PLATFORM(COCOA)
        WebKit::PlatformFontInfo fontInfo;
#endif
#if PLATFORM(COCOA)
        bool shouldPopOver;
#endif
#if PLATFORM(COCOA)
        bool hideArrows;
#endif
#if PLATFORM(COCOA)
        WebCore::PopupMenuStyle::Size menuSize;
#endif
#if PLATFORM(WIN)
        int m_clientPaddingLeft;
#endif
#if PLATFORM(WIN)
        int m_clientPaddingRight;
#endif
#if PLATFORM(WIN)
        int m_clientInsetLeft;
#endif
#if PLATFORM(WIN)
        int m_clientInsetRight;
#endif
#if PLATFORM(WIN)
        int m_popupWidth;
#endif
#if PLATFORM(WIN)
        float m_itemHeight;
#endif
#if PLATFORM(WIN)
        bool m_isRTL;
#endif
#if PLATFORM(WIN)
        RefPtr<WebCore::ShareableBitmap> m_notSelectedBackingStore;
#endif
#if PLATFORM(WIN)
        RefPtr<WebCore::ShareableBitmap> m_selectedBackingStore;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsPlatformPopupMenuData) == sizeof(WebKit::PlatformPopupMenuData));
    static_assert(MembersInCorrectOrder < 0
#if PLATFORM(COCOA)
        , offsetof(WebKit::PlatformPopupMenuData, fontInfo)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::PlatformPopupMenuData, shouldPopOver)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::PlatformPopupMenuData, hideArrows)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::PlatformPopupMenuData, menuSize)
#endif
#if PLATFORM(WIN)
        , offsetof(WebKit::PlatformPopupMenuData, m_clientPaddingLeft)
#endif
#if PLATFORM(WIN)
        , offsetof(WebKit::PlatformPopupMenuData, m_clientPaddingRight)
#endif
#if PLATFORM(WIN)
        , offsetof(WebKit::PlatformPopupMenuData, m_clientInsetLeft)
#endif
#if PLATFORM(WIN)
        , offsetof(WebKit::PlatformPopupMenuData, m_clientInsetRight)
#endif
#if PLATFORM(WIN)
        , offsetof(WebKit::PlatformPopupMenuData, m_popupWidth)
#endif
#if PLATFORM(WIN)
        , offsetof(WebKit::PlatformPopupMenuData, m_itemHeight)
#endif
#if PLATFORM(WIN)
        , offsetof(WebKit::PlatformPopupMenuData, m_isRTL)
#endif
#if PLATFORM(WIN)
        , offsetof(WebKit::PlatformPopupMenuData, m_notSelectedBackingStore)
#endif
#if PLATFORM(WIN)
        , offsetof(WebKit::PlatformPopupMenuData, m_selectedBackingStore)
#endif
    >::value);

#if PLATFORM(COCOA)
    encoder << instance.fontInfo;
#endif
#if PLATFORM(COCOA)
    encoder << instance.shouldPopOver;
#endif
#if PLATFORM(COCOA)
    encoder << instance.hideArrows;
#endif
#if PLATFORM(COCOA)
    encoder << instance.menuSize;
#endif
#if PLATFORM(WIN)
    encoder << instance.m_clientPaddingLeft;
#endif
#if PLATFORM(WIN)
    encoder << instance.m_clientPaddingRight;
#endif
#if PLATFORM(WIN)
    encoder << instance.m_clientInsetLeft;
#endif
#if PLATFORM(WIN)
    encoder << instance.m_clientInsetRight;
#endif
#if PLATFORM(WIN)
    encoder << instance.m_popupWidth;
#endif
#if PLATFORM(WIN)
    encoder << instance.m_itemHeight;
#endif
#if PLATFORM(WIN)
    encoder << instance.m_isRTL;
#endif
#if PLATFORM(WIN)
    encoder << instance.m_notSelectedBackingStore;
#endif
#if PLATFORM(WIN)
    encoder << instance.m_selectedBackingStore;
#endif
}

std::optional<WebKit::PlatformPopupMenuData> ArgumentCoder<WebKit::PlatformPopupMenuData>::decode(Decoder& decoder)
{
#if PLATFORM(COCOA)
    auto fontInfo = decoder.decode<WebKit::PlatformFontInfo>();
#endif
#if PLATFORM(COCOA)
    auto shouldPopOver = decoder.decode<bool>();
#endif
#if PLATFORM(COCOA)
    auto hideArrows = decoder.decode<bool>();
#endif
#if PLATFORM(COCOA)
    auto menuSize = decoder.decode<WebCore::PopupMenuStyle::Size>();
#endif
#if PLATFORM(WIN)
    auto m_clientPaddingLeft = decoder.decode<int>();
#endif
#if PLATFORM(WIN)
    auto m_clientPaddingRight = decoder.decode<int>();
#endif
#if PLATFORM(WIN)
    auto m_clientInsetLeft = decoder.decode<int>();
#endif
#if PLATFORM(WIN)
    auto m_clientInsetRight = decoder.decode<int>();
#endif
#if PLATFORM(WIN)
    auto m_popupWidth = decoder.decode<int>();
#endif
#if PLATFORM(WIN)
    auto m_itemHeight = decoder.decode<float>();
#endif
#if PLATFORM(WIN)
    auto m_isRTL = decoder.decode<bool>();
#endif
#if PLATFORM(WIN)
    auto m_notSelectedBackingStore = decoder.decode<RefPtr<WebCore::ShareableBitmap>>();
#endif
#if PLATFORM(WIN)
    auto m_selectedBackingStore = decoder.decode<RefPtr<WebCore::ShareableBitmap>>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::PlatformPopupMenuData {
#if PLATFORM(COCOA)
            WTFMove(*fontInfo),
#endif
#if PLATFORM(COCOA)
            WTFMove(*shouldPopOver),
#endif
#if PLATFORM(COCOA)
            WTFMove(*hideArrows),
#endif
#if PLATFORM(COCOA)
            WTFMove(*menuSize),
#endif
#if PLATFORM(WIN)
            WTFMove(*m_clientPaddingLeft),
#endif
#if PLATFORM(WIN)
            WTFMove(*m_clientPaddingRight),
#endif
#if PLATFORM(WIN)
            WTFMove(*m_clientInsetLeft),
#endif
#if PLATFORM(WIN)
            WTFMove(*m_clientInsetRight),
#endif
#if PLATFORM(WIN)
            WTFMove(*m_popupWidth),
#endif
#if PLATFORM(WIN)
            WTFMove(*m_itemHeight),
#endif
#if PLATFORM(WIN)
            WTFMove(*m_isRTL),
#endif
#if PLATFORM(WIN)
            WTFMove(*m_notSelectedBackingStore),
#endif
#if PLATFORM(WIN)
            WTFMove(*m_selectedBackingStore)
#endif
        }
    };
}

void ArgumentCoder<WebKit::PolicyDecision>::encode(Encoder& encoder, WebKit::PolicyDecision&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isNavigatingToAppBoundDomain)>, std::optional<WebKit::NavigatingToAppBoundDomain>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.policyAction)>, WebCore::PolicyAction>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.navigationID)>, std::optional<WebCore::NavigationIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.downloadID)>, std::optional<WebKit::DownloadID>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.websitePoliciesData)>, std::optional<WebKit::WebsitePoliciesData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sandboxExtensionHandle)>, std::optional<WebKit::SandboxExtensionHandle>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.consoleMessage)>, std::optional<WebKit::PolicyDecisionConsoleMessage>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isSafeBrowsingCheckOngoing)>, WebKit::SafeBrowsingCheckOngoing>);
    struct ShouldBeSameSizeAsPolicyDecision : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::PolicyDecision>, false> {
        std::optional<WebKit::NavigatingToAppBoundDomain> isNavigatingToAppBoundDomain;
        WebCore::PolicyAction policyAction;
        std::optional<WebCore::NavigationIdentifier> navigationID;
        std::optional<WebKit::DownloadID> downloadID;
        std::optional<WebKit::WebsitePoliciesData> websitePoliciesData;
        std::optional<WebKit::SandboxExtensionHandle> sandboxExtensionHandle;
        std::optional<WebKit::PolicyDecisionConsoleMessage> consoleMessage;
        WebKit::SafeBrowsingCheckOngoing isSafeBrowsingCheckOngoing;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPolicyDecision) == sizeof(WebKit::PolicyDecision));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::PolicyDecision, isNavigatingToAppBoundDomain)
        , offsetof(WebKit::PolicyDecision, policyAction)
        , offsetof(WebKit::PolicyDecision, navigationID)
        , offsetof(WebKit::PolicyDecision, downloadID)
        , offsetof(WebKit::PolicyDecision, websitePoliciesData)
        , offsetof(WebKit::PolicyDecision, sandboxExtensionHandle)
        , offsetof(WebKit::PolicyDecision, consoleMessage)
        , offsetof(WebKit::PolicyDecision, isSafeBrowsingCheckOngoing)
    >::value);

    encoder << WTFMove(instance.isNavigatingToAppBoundDomain);
    encoder << WTFMove(instance.policyAction);
    encoder << WTFMove(instance.navigationID);
    encoder << WTFMove(instance.downloadID);
    encoder << WTFMove(instance.websitePoliciesData);
    encoder << WTFMove(instance.sandboxExtensionHandle);
    encoder << WTFMove(instance.consoleMessage);
    encoder << WTFMove(instance.isSafeBrowsingCheckOngoing);
}

std::optional<WebKit::PolicyDecision> ArgumentCoder<WebKit::PolicyDecision>::decode(Decoder& decoder)
{
    auto isNavigatingToAppBoundDomain = decoder.decode<std::optional<WebKit::NavigatingToAppBoundDomain>>();
    auto policyAction = decoder.decode<WebCore::PolicyAction>();
    auto navigationID = decoder.decode<std::optional<WebCore::NavigationIdentifier>>();
    auto downloadID = decoder.decode<std::optional<WebKit::DownloadID>>();
    auto websitePoliciesData = decoder.decode<std::optional<WebKit::WebsitePoliciesData>>();
    auto sandboxExtensionHandle = decoder.decode<std::optional<WebKit::SandboxExtensionHandle>>();
    auto consoleMessage = decoder.decode<std::optional<WebKit::PolicyDecisionConsoleMessage>>();
    auto isSafeBrowsingCheckOngoing = decoder.decode<WebKit::SafeBrowsingCheckOngoing>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::PolicyDecision {
            WTFMove(*isNavigatingToAppBoundDomain),
            WTFMove(*policyAction),
            WTFMove(*navigationID),
            WTFMove(*downloadID),
            WTFMove(*websitePoliciesData),
            WTFMove(*sandboxExtensionHandle),
            WTFMove(*consoleMessage),
            WTFMove(*isSafeBrowsingCheckOngoing)
        }
    };
}

void ArgumentCoder<WebKit::PolicyDecisionConsoleMessage>::encode(Encoder& encoder, const WebKit::PolicyDecisionConsoleMessage& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.messageLevel)>, JSC::MessageLevel>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.messageSource)>, JSC::MessageSource>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.message)>, String>);
    struct ShouldBeSameSizeAsPolicyDecisionConsoleMessage : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::PolicyDecisionConsoleMessage>, false> {
        JSC::MessageLevel messageLevel;
        JSC::MessageSource messageSource;
        String message;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPolicyDecisionConsoleMessage) == sizeof(WebKit::PolicyDecisionConsoleMessage));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::PolicyDecisionConsoleMessage, messageLevel)
        , offsetof(WebKit::PolicyDecisionConsoleMessage, messageSource)
        , offsetof(WebKit::PolicyDecisionConsoleMessage, message)
    >::value);

    encoder << instance.messageLevel;
    encoder << instance.messageSource;
    encoder << instance.message;
}

std::optional<WebKit::PolicyDecisionConsoleMessage> ArgumentCoder<WebKit::PolicyDecisionConsoleMessage>::decode(Decoder& decoder)
{
    auto messageLevel = decoder.decode<JSC::MessageLevel>();
    auto messageSource = decoder.decode<JSC::MessageSource>();
    auto message = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::PolicyDecisionConsoleMessage {
            WTFMove(*messageLevel),
            WTFMove(*messageSource),
            WTFMove(*message)
        }
    };
}

void ArgumentCoder<WebKit::PrintInfo>::encode(Encoder& encoder, const WebKit::PrintInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pageSetupScaleFactor)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.availablePaperWidth)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.availablePaperHeight)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.margin)>, WebCore::FloatBoxExtent>);
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.snapshotFirstPage)>, bool>);
#endif
#if PLATFORM(GTK)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.printSettings)>, GRefPtr<GtkPrintSettings>>);
#endif
#if PLATFORM(GTK)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pageSetup)>, GRefPtr<GtkPageSetup>>);
#endif
#if PLATFORM(GTK)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.printMode)>, WebKit::PrintInfo::PrintMode>);
#endif
    struct ShouldBeSameSizeAsPrintInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::PrintInfo>, false> {
        float pageSetupScaleFactor;
        float availablePaperWidth;
        float availablePaperHeight;
        WebCore::FloatBoxExtent margin;
#if PLATFORM(IOS_FAMILY)
        bool snapshotFirstPage;
#endif
#if PLATFORM(GTK)
        GRefPtr<GtkPrintSettings> printSettings;
#endif
#if PLATFORM(GTK)
        GRefPtr<GtkPageSetup> pageSetup;
#endif
#if PLATFORM(GTK)
        WebKit::PrintInfo::PrintMode printMode;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsPrintInfo) == sizeof(WebKit::PrintInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::PrintInfo, pageSetupScaleFactor)
        , offsetof(WebKit::PrintInfo, availablePaperWidth)
        , offsetof(WebKit::PrintInfo, availablePaperHeight)
        , offsetof(WebKit::PrintInfo, margin)
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::PrintInfo, snapshotFirstPage)
#endif
#if PLATFORM(GTK)
        , offsetof(WebKit::PrintInfo, printSettings)
#endif
#if PLATFORM(GTK)
        , offsetof(WebKit::PrintInfo, pageSetup)
#endif
#if PLATFORM(GTK)
        , offsetof(WebKit::PrintInfo, printMode)
#endif
    >::value);

    encoder << instance.pageSetupScaleFactor;
    encoder << instance.availablePaperWidth;
    encoder << instance.availablePaperHeight;
    encoder << instance.margin;
#if PLATFORM(IOS_FAMILY)
    encoder << instance.snapshotFirstPage;
#endif
#if PLATFORM(GTK)
    encoder << instance.printSettings;
#endif
#if PLATFORM(GTK)
    encoder << instance.pageSetup;
#endif
#if PLATFORM(GTK)
    encoder << instance.printMode;
#endif
}

std::optional<WebKit::PrintInfo> ArgumentCoder<WebKit::PrintInfo>::decode(Decoder& decoder)
{
    auto pageSetupScaleFactor = decoder.decode<float>();
    auto availablePaperWidth = decoder.decode<float>();
    auto availablePaperHeight = decoder.decode<float>();
    auto margin = decoder.decode<WebCore::FloatBoxExtent>();
#if PLATFORM(IOS_FAMILY)
    auto snapshotFirstPage = decoder.decode<bool>();
#endif
#if PLATFORM(GTK)
    auto printSettings = decoder.decode<GRefPtr<GtkPrintSettings>>();
#endif
#if PLATFORM(GTK)
    auto pageSetup = decoder.decode<GRefPtr<GtkPageSetup>>();
#endif
#if PLATFORM(GTK)
    auto printMode = decoder.decode<WebKit::PrintInfo::PrintMode>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::PrintInfo {
            WTFMove(*pageSetupScaleFactor),
            WTFMove(*availablePaperWidth),
            WTFMove(*availablePaperHeight),
            WTFMove(*margin),
#if PLATFORM(IOS_FAMILY)
            WTFMove(*snapshotFirstPage),
#endif
#if PLATFORM(GTK)
            WTFMove(*printSettings),
#endif
#if PLATFORM(GTK)
            WTFMove(*pageSetup),
#endif
#if PLATFORM(GTK)
            WTFMove(*printMode)
#endif
        }
    };
}

void ArgumentCoder<WebCore::BackForwardFrameItemIdentifier>::encode(Encoder& encoder, const WebCore::BackForwardFrameItemIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.object())>, WebCore::BackForwardFrameItemIdentifierID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processIdentifier())>, WebCore::ProcessIdentifier>);

    encoder << instance.object();
    encoder << instance.processIdentifier();
}

void ArgumentCoder<WebCore::BackForwardFrameItemIdentifier>::encode(StreamConnectionEncoder& encoder, const WebCore::BackForwardFrameItemIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.object())>, WebCore::BackForwardFrameItemIdentifierID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processIdentifier())>, WebCore::ProcessIdentifier>);

    encoder << instance.object();
    encoder << instance.processIdentifier();
}

std::optional<WebCore::BackForwardFrameItemIdentifier> ArgumentCoder<WebCore::BackForwardFrameItemIdentifier>::decode(Decoder& decoder)
{
    auto object = decoder.decode<WebCore::BackForwardFrameItemIdentifierID>();
    auto processIdentifier = decoder.decode<WebCore::ProcessIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::BackForwardFrameItemIdentifier {
            WTFMove(*object),
            WTFMove(*processIdentifier)
        }
    };
}

void ArgumentCoder<WebCore::BackForwardItemIdentifier>::encode(Encoder& encoder, const WebCore::BackForwardItemIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.object())>, WebCore::BackForwardItemIdentifierID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processIdentifier())>, WebCore::ProcessIdentifier>);

    encoder << instance.object();
    encoder << instance.processIdentifier();
}

void ArgumentCoder<WebCore::BackForwardItemIdentifier>::encode(StreamConnectionEncoder& encoder, const WebCore::BackForwardItemIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.object())>, WebCore::BackForwardItemIdentifierID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processIdentifier())>, WebCore::ProcessIdentifier>);

    encoder << instance.object();
    encoder << instance.processIdentifier();
}

std::optional<WebCore::BackForwardItemIdentifier> ArgumentCoder<WebCore::BackForwardItemIdentifier>::decode(Decoder& decoder)
{
    auto object = decoder.decode<WebCore::BackForwardItemIdentifierID>();
    auto processIdentifier = decoder.decode<WebCore::ProcessIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::BackForwardItemIdentifier {
            WTFMove(*object),
            WTFMove(*processIdentifier)
        }
    };
}

void ArgumentCoder<WebCore::DOMCacheIdentifier>::encode(Encoder& encoder, const WebCore::DOMCacheIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.object())>, WebCore::DOMCacheIdentifierID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processIdentifier())>, WebCore::ProcessIdentifier>);

    encoder << instance.object();
    encoder << instance.processIdentifier();
}

void ArgumentCoder<WebCore::DOMCacheIdentifier>::encode(StreamConnectionEncoder& encoder, const WebCore::DOMCacheIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.object())>, WebCore::DOMCacheIdentifierID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processIdentifier())>, WebCore::ProcessIdentifier>);

    encoder << instance.object();
    encoder << instance.processIdentifier();
}

std::optional<WebCore::DOMCacheIdentifier> ArgumentCoder<WebCore::DOMCacheIdentifier>::decode(Decoder& decoder)
{
    auto object = decoder.decode<WebCore::DOMCacheIdentifierID>();
    auto processIdentifier = decoder.decode<WebCore::ProcessIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DOMCacheIdentifier {
            WTFMove(*object),
            WTFMove(*processIdentifier)
        }
    };
}

void ArgumentCoder<WebCore::OpaqueOriginIdentifierProcessQualified>::encode(Encoder& encoder, const WebCore::OpaqueOriginIdentifierProcessQualified& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.object())>, WebCore::OpaqueOriginIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processIdentifier())>, WebCore::ProcessIdentifier>);

    encoder << instance.object();
    encoder << instance.processIdentifier();
}

void ArgumentCoder<WebCore::OpaqueOriginIdentifierProcessQualified>::encode(StreamConnectionEncoder& encoder, const WebCore::OpaqueOriginIdentifierProcessQualified& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.object())>, WebCore::OpaqueOriginIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processIdentifier())>, WebCore::ProcessIdentifier>);

    encoder << instance.object();
    encoder << instance.processIdentifier();
}

std::optional<WebCore::OpaqueOriginIdentifierProcessQualified> ArgumentCoder<WebCore::OpaqueOriginIdentifierProcessQualified>::decode(Decoder& decoder)
{
    auto object = decoder.decode<WebCore::OpaqueOriginIdentifier>();
    auto processIdentifier = decoder.decode<WebCore::ProcessIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::OpaqueOriginIdentifierProcessQualified {
            WTFMove(*object),
            WTFMove(*processIdentifier)
        }
    };
}

void ArgumentCoder<WebCore::PlatformLayerIdentifier>::encode(Encoder& encoder, const WebCore::PlatformLayerIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.object())>, WebCore::PlatformLayerIdentifierID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processIdentifier())>, WebCore::ProcessIdentifier>);

    encoder << instance.object();
    encoder << instance.processIdentifier();
}

void ArgumentCoder<WebCore::PlatformLayerIdentifier>::encode(StreamConnectionEncoder& encoder, const WebCore::PlatformLayerIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.object())>, WebCore::PlatformLayerIdentifierID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processIdentifier())>, WebCore::ProcessIdentifier>);

    encoder << instance.object();
    encoder << instance.processIdentifier();
}

std::optional<WebCore::PlatformLayerIdentifier> ArgumentCoder<WebCore::PlatformLayerIdentifier>::decode(Decoder& decoder)
{
    auto object = decoder.decode<WebCore::PlatformLayerIdentifierID>();
    auto processIdentifier = decoder.decode<WebCore::ProcessIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PlatformLayerIdentifier {
            WTFMove(*object),
            WTFMove(*processIdentifier)
        }
    };
}

void ArgumentCoder<WebCore::PlaybackTargetClientContextIdentifier>::encode(Encoder& encoder, const WebCore::PlaybackTargetClientContextIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.object())>, WebCore::PlaybackTargetClientContextID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processIdentifier())>, WebCore::ProcessIdentifier>);

    encoder << instance.object();
    encoder << instance.processIdentifier();
}

void ArgumentCoder<WebCore::PlaybackTargetClientContextIdentifier>::encode(StreamConnectionEncoder& encoder, const WebCore::PlaybackTargetClientContextIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.object())>, WebCore::PlaybackTargetClientContextID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processIdentifier())>, WebCore::ProcessIdentifier>);

    encoder << instance.object();
    encoder << instance.processIdentifier();
}

std::optional<WebCore::PlaybackTargetClientContextIdentifier> ArgumentCoder<WebCore::PlaybackTargetClientContextIdentifier>::decode(Decoder& decoder)
{
    auto object = decoder.decode<WebCore::PlaybackTargetClientContextID>();
    auto processIdentifier = decoder.decode<WebCore::ProcessIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PlaybackTargetClientContextIdentifier {
            WTFMove(*object),
            WTFMove(*processIdentifier)
        }
    };
}

void ArgumentCoder<WebCore::RTCDataChannelIdentifier>::encode(Encoder& encoder, const WebCore::RTCDataChannelIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.object())>, WebCore::RTCDataChannelLocalIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processIdentifier())>, WebCore::ProcessIdentifier>);

    encoder << instance.object();
    encoder << instance.processIdentifier();
}

void ArgumentCoder<WebCore::RTCDataChannelIdentifier>::encode(StreamConnectionEncoder& encoder, const WebCore::RTCDataChannelIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.object())>, WebCore::RTCDataChannelLocalIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processIdentifier())>, WebCore::ProcessIdentifier>);

    encoder << instance.object();
    encoder << instance.processIdentifier();
}

std::optional<WebCore::RTCDataChannelIdentifier> ArgumentCoder<WebCore::RTCDataChannelIdentifier>::decode(Decoder& decoder)
{
    auto object = decoder.decode<WebCore::RTCDataChannelLocalIdentifier>();
    auto processIdentifier = decoder.decode<WebCore::ProcessIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::RTCDataChannelIdentifier {
            WTFMove(*object),
            WTFMove(*processIdentifier)
        }
    };
}

void ArgumentCoder<WebCore::SharedWorkerObjectIdentifier>::encode(Encoder& encoder, const WebCore::SharedWorkerObjectIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.object())>, WebCore::SharedWorkerObjectIdentifierID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processIdentifier())>, WebCore::ProcessIdentifier>);

    encoder << instance.object();
    encoder << instance.processIdentifier();
}

void ArgumentCoder<WebCore::SharedWorkerObjectIdentifier>::encode(StreamConnectionEncoder& encoder, const WebCore::SharedWorkerObjectIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.object())>, WebCore::SharedWorkerObjectIdentifierID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processIdentifier())>, WebCore::ProcessIdentifier>);

    encoder << instance.object();
    encoder << instance.processIdentifier();
}

std::optional<WebCore::SharedWorkerObjectIdentifier> ArgumentCoder<WebCore::SharedWorkerObjectIdentifier>::decode(Decoder& decoder)
{
    auto object = decoder.decode<WebCore::SharedWorkerObjectIdentifierID>();
    auto processIdentifier = decoder.decode<WebCore::ProcessIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SharedWorkerObjectIdentifier {
            WTFMove(*object),
            WTFMove(*processIdentifier)
        }
    };
}

void ArgumentCoder<WebCore::UserGestureTokenIdentifier>::encode(Encoder& encoder, const WebCore::UserGestureTokenIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.object())>, WebCore::UserGestureTokenIdentifierID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processIdentifier())>, WebCore::ProcessIdentifier>);

    encoder << instance.object();
    encoder << instance.processIdentifier();
}

void ArgumentCoder<WebCore::UserGestureTokenIdentifier>::encode(StreamConnectionEncoder& encoder, const WebCore::UserGestureTokenIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.object())>, WebCore::UserGestureTokenIdentifierID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processIdentifier())>, WebCore::ProcessIdentifier>);

    encoder << instance.object();
    encoder << instance.processIdentifier();
}

std::optional<WebCore::UserGestureTokenIdentifier> ArgumentCoder<WebCore::UserGestureTokenIdentifier>::decode(Decoder& decoder)
{
    auto object = decoder.decode<WebCore::UserGestureTokenIdentifierID>();
    auto processIdentifier = decoder.decode<WebCore::ProcessIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::UserGestureTokenIdentifier {
            WTFMove(*object),
            WTFMove(*processIdentifier)
        }
    };
}

void ArgumentCoder<WebCore::WebLockIdentifier>::encode(Encoder& encoder, const WebCore::WebLockIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.object())>, WebCore::WebLockIdentifierID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processIdentifier())>, WebCore::ProcessIdentifier>);

    encoder << instance.object();
    encoder << instance.processIdentifier();
}

void ArgumentCoder<WebCore::WebLockIdentifier>::encode(StreamConnectionEncoder& encoder, const WebCore::WebLockIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.object())>, WebCore::WebLockIdentifierID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processIdentifier())>, WebCore::ProcessIdentifier>);

    encoder << instance.object();
    encoder << instance.processIdentifier();
}

std::optional<WebCore::WebLockIdentifier> ArgumentCoder<WebCore::WebLockIdentifier>::decode(Decoder& decoder)
{
    auto object = decoder.decode<WebCore::WebLockIdentifierID>();
    auto processIdentifier = decoder.decode<WebCore::ProcessIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::WebLockIdentifier {
            WTFMove(*object),
            WTFMove(*processIdentifier)
        }
    };
}

void ArgumentCoder<WebCore::ScrollingNodeID>::encode(Encoder& encoder, const WebCore::ScrollingNodeID& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.object())>, WebCore::ScrollingNodeIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processIdentifier())>, WebCore::ProcessIdentifier>);

    encoder << instance.object();
    encoder << instance.processIdentifier();
}

void ArgumentCoder<WebCore::ScrollingNodeID>::encode(StreamConnectionEncoder& encoder, const WebCore::ScrollingNodeID& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.object())>, WebCore::ScrollingNodeIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processIdentifier())>, WebCore::ProcessIdentifier>);

    encoder << instance.object();
    encoder << instance.processIdentifier();
}

std::optional<WebCore::ScrollingNodeID> ArgumentCoder<WebCore::ScrollingNodeID>::decode(Decoder& decoder)
{
    auto object = decoder.decode<WebCore::ScrollingNodeIdentifier>();
    auto processIdentifier = decoder.decode<WebCore::ProcessIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ScrollingNodeID {
            WTFMove(*object),
            WTFMove(*processIdentifier)
        }
    };
}

void ArgumentCoder<WebCore::ScriptExecutionContextIdentifier>::encode(Encoder& encoder, const WebCore::ScriptExecutionContextIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.object())>, WTF::UUID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processIdentifier())>, WebCore::ProcessIdentifier>);

    encoder << instance.object();
    encoder << instance.processIdentifier();
}

std::optional<WebCore::ScriptExecutionContextIdentifier> ArgumentCoder<WebCore::ScriptExecutionContextIdentifier>::decode(Decoder& decoder)
{
    auto object = decoder.decode<WTF::UUID>();
    auto processIdentifier = decoder.decode<WebCore::ProcessIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ScriptExecutionContextIdentifier {
            WTFMove(*object),
            WTFMove(*processIdentifier)
        }
    };
}

void ArgumentCoder<WebKit::TransactionID>::encode(Encoder& encoder, const WebKit::TransactionID& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.object())>, WebKit::TransactionIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processIdentifier())>, WebCore::ProcessIdentifier>);

    encoder << instance.object();
    encoder << instance.processIdentifier();
}

std::optional<WebKit::TransactionID> ArgumentCoder<WebKit::TransactionID>::decode(Decoder& decoder)
{
    auto object = decoder.decode<WebKit::TransactionIdentifier>();
    auto processIdentifier = decoder.decode<WebCore::ProcessIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::TransactionID {
            WTFMove(*object),
            WTFMove(*processIdentifier)
        }
    };
}

void ArgumentCoder<WebKit::PlaybackSessionContextIdentifier>::encode(Encoder& encoder, const WebKit::PlaybackSessionContextIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.object())>, WebCore::MediaPlayerClientIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processIdentifier())>, WebCore::ProcessIdentifier>);

    encoder << instance.object();
    encoder << instance.processIdentifier();
}

std::optional<WebKit::PlaybackSessionContextIdentifier> ArgumentCoder<WebKit::PlaybackSessionContextIdentifier>::decode(Decoder& decoder)
{
    auto object = decoder.decode<WebCore::MediaPlayerClientIdentifier>();
    auto processIdentifier = decoder.decode<WebCore::ProcessIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::PlaybackSessionContextIdentifier {
            WTFMove(*object),
            WTFMove(*processIdentifier)
        }
    };
}

void ArgumentCoder<WebKit::ProvisionalFrameCreationParameters>::encode(Encoder& encoder, const WebKit::ProvisionalFrameCreationParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameID)>, WebCore::FrameIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameIDBeforeProvisionalNavigation)>, std::optional<WebCore::FrameIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.layerHostingContextIdentifier)>, std::optional<WebCore::LayerHostingContextIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.effectiveSandboxFlags)>, WebCore::SandboxFlags>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scrollingMode)>, WebCore::ScrollbarMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.initialSize)>, std::optional<WebCore::IntSize>>);
    struct ShouldBeSameSizeAsProvisionalFrameCreationParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::ProvisionalFrameCreationParameters>, false> {
        WebCore::FrameIdentifier frameID;
        std::optional<WebCore::FrameIdentifier> frameIDBeforeProvisionalNavigation;
        std::optional<WebCore::LayerHostingContextIdentifier> layerHostingContextIdentifier;
        WebCore::SandboxFlags effectiveSandboxFlags;
        WebCore::ScrollbarMode scrollingMode;
        std::optional<WebCore::IntSize> initialSize;
    };
    static_assert(sizeof(ShouldBeSameSizeAsProvisionalFrameCreationParameters) == sizeof(WebKit::ProvisionalFrameCreationParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::ProvisionalFrameCreationParameters, frameID)
        , offsetof(WebKit::ProvisionalFrameCreationParameters, frameIDBeforeProvisionalNavigation)
        , offsetof(WebKit::ProvisionalFrameCreationParameters, layerHostingContextIdentifier)
        , offsetof(WebKit::ProvisionalFrameCreationParameters, effectiveSandboxFlags)
        , offsetof(WebKit::ProvisionalFrameCreationParameters, scrollingMode)
        , offsetof(WebKit::ProvisionalFrameCreationParameters, initialSize)
    >::value);

    encoder << instance.frameID;
    encoder << instance.frameIDBeforeProvisionalNavigation;
    encoder << instance.layerHostingContextIdentifier;
    encoder << instance.effectiveSandboxFlags;
    encoder << instance.scrollingMode;
    encoder << instance.initialSize;
}

std::optional<WebKit::ProvisionalFrameCreationParameters> ArgumentCoder<WebKit::ProvisionalFrameCreationParameters>::decode(Decoder& decoder)
{
    auto frameID = decoder.decode<WebCore::FrameIdentifier>();
    auto frameIDBeforeProvisionalNavigation = decoder.decode<std::optional<WebCore::FrameIdentifier>>();
    auto layerHostingContextIdentifier = decoder.decode<std::optional<WebCore::LayerHostingContextIdentifier>>();
    auto effectiveSandboxFlags = decoder.decode<WebCore::SandboxFlags>();
    auto scrollingMode = decoder.decode<WebCore::ScrollbarMode>();
    auto initialSize = decoder.decode<std::optional<WebCore::IntSize>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::ProvisionalFrameCreationParameters {
            WTFMove(*frameID),
            WTFMove(*frameIDBeforeProvisionalNavigation),
            WTFMove(*layerHostingContextIdentifier),
            WTFMove(*effectiveSandboxFlags),
            WTFMove(*scrollingMode),
            WTFMove(*initialSize)
        }
    };
}

#if USE(LIBWEBRTC)
void ArgumentCoder<WebKit::WebRTCNetwork::IPAddress>::encode(Encoder& encoder, const WebKit::WebRTCNetwork::IPAddress& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, Variant<WebKit::WebRTCNetwork::IPAddress::UnspecifiedFamily, uint32_t, std::array<uint32_t, 4>>>);
    struct ShouldBeSameSizeAsIPAddress : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebRTCNetwork::IPAddress>, false> {
        Variant<WebKit::WebRTCNetwork::IPAddress::UnspecifiedFamily, uint32_t, std::array<uint32_t, 4>> value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsIPAddress) == sizeof(WebKit::WebRTCNetwork::IPAddress));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebRTCNetwork::IPAddress, value)
    >::value);

    encoder << instance.value;
}

std::optional<WebKit::WebRTCNetwork::IPAddress> ArgumentCoder<WebKit::WebRTCNetwork::IPAddress>::decode(Decoder& decoder)
{
    auto value = decoder.decode<Variant<WebKit::WebRTCNetwork::IPAddress::UnspecifiedFamily, uint32_t, std::array<uint32_t, 4>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebRTCNetwork::IPAddress {
            WTFMove(*value)
        }
    };
}

#endif

#if USE(LIBWEBRTC)
void ArgumentCoder<WebKit::WebRTCNetwork::IPAddress::UnspecifiedFamily>::encode(Encoder& encoder, const WebKit::WebRTCNetwork::IPAddress::UnspecifiedFamily& instance)
{
    struct ShouldBeSameSizeAsUnspecifiedFamily : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebRTCNetwork::IPAddress::UnspecifiedFamily>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsUnspecifiedFamily) == sizeof(WebKit::WebRTCNetwork::IPAddress::UnspecifiedFamily));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebKit::WebRTCNetwork::IPAddress::UnspecifiedFamily> ArgumentCoder<WebKit::WebRTCNetwork::IPAddress::UnspecifiedFamily>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebRTCNetwork::IPAddress::UnspecifiedFamily {
        }
    };
}

#endif

#if USE(LIBWEBRTC)
void ArgumentCoder<WebKit::WebRTCNetwork::InterfaceAddress>::encode(Encoder& encoder, const WebKit::WebRTCNetwork::InterfaceAddress& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.address)>, WebKit::WebRTCNetwork::IPAddress>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ipv6Flags)>, int>);
    struct ShouldBeSameSizeAsInterfaceAddress : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebRTCNetwork::InterfaceAddress>, false> {
        WebKit::WebRTCNetwork::IPAddress address;
        int ipv6Flags;
    };
    static_assert(sizeof(ShouldBeSameSizeAsInterfaceAddress) == sizeof(WebKit::WebRTCNetwork::InterfaceAddress));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebRTCNetwork::InterfaceAddress, address)
        , offsetof(WebKit::WebRTCNetwork::InterfaceAddress, ipv6Flags)
    >::value);

    encoder << instance.address;
    encoder << instance.ipv6Flags;
}

std::optional<WebKit::WebRTCNetwork::InterfaceAddress> ArgumentCoder<WebKit::WebRTCNetwork::InterfaceAddress>::decode(Decoder& decoder)
{
    auto address = decoder.decode<WebKit::WebRTCNetwork::IPAddress>();
    auto ipv6Flags = decoder.decode<int>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebRTCNetwork::InterfaceAddress {
            WTFMove(*address),
            WTFMove(*ipv6Flags)
        }
    };
}

#endif

#if USE(LIBWEBRTC)
void ArgumentCoder<WebKit::WebRTCNetwork::SocketAddress>::encode(Encoder& encoder, const WebKit::WebRTCNetwork::SocketAddress& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.port)>, uint16_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scopeID)>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hostname)>, Vector<char>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ipAddress)>, std::optional<WebKit::WebRTCNetwork::IPAddress>>);
    struct ShouldBeSameSizeAsSocketAddress : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebRTCNetwork::SocketAddress>, false> {
        uint16_t port;
        int scopeID;
        Vector<char> hostname;
        std::optional<WebKit::WebRTCNetwork::IPAddress> ipAddress;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSocketAddress) == sizeof(WebKit::WebRTCNetwork::SocketAddress));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebRTCNetwork::SocketAddress, port)
        , offsetof(WebKit::WebRTCNetwork::SocketAddress, scopeID)
        , offsetof(WebKit::WebRTCNetwork::SocketAddress, hostname)
        , offsetof(WebKit::WebRTCNetwork::SocketAddress, ipAddress)
    >::value);

    encoder << instance.port;
    encoder << instance.scopeID;
    encoder << instance.hostname;
    encoder << instance.ipAddress;
}

std::optional<WebKit::WebRTCNetwork::SocketAddress> ArgumentCoder<WebKit::WebRTCNetwork::SocketAddress>::decode(Decoder& decoder)
{
    auto port = decoder.decode<uint16_t>();
    auto scopeID = decoder.decode<int>();
    auto hostname = decoder.decode<Vector<char>>();
    auto ipAddress = decoder.decode<std::optional<WebKit::WebRTCNetwork::IPAddress>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebRTCNetwork::SocketAddress {
            WTFMove(*port),
            WTFMove(*scopeID),
            WTFMove(*hostname),
            WTFMove(*ipAddress)
        }
    };
}

#endif

#if USE(LIBWEBRTC)
void ArgumentCoder<WebKit::RTCNetwork>::encode(Encoder& encoder, const WebKit::RTCNetwork& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, Vector<char>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.description)>, Vector<char>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.prefix)>, WebKit::WebRTCNetwork::IPAddress>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.prefixLength)>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.id)>, uint16_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.preference)>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.active)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ignored)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scopeID)>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ips)>, Vector<WebKit::WebRTCNetwork::InterfaceAddress>>);
    struct ShouldBeSameSizeAsRTCNetwork : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::RTCNetwork>, false> {
        Vector<char> name;
        Vector<char> description;
        WebKit::WebRTCNetwork::IPAddress prefix;
        int prefixLength;
        int type;
        uint16_t id;
        int preference;
        bool active;
        bool ignored;
        int scopeID;
        Vector<WebKit::WebRTCNetwork::InterfaceAddress> ips;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRTCNetwork) == sizeof(WebKit::RTCNetwork));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::RTCNetwork, name)
        , offsetof(WebKit::RTCNetwork, description)
        , offsetof(WebKit::RTCNetwork, prefix)
        , offsetof(WebKit::RTCNetwork, prefixLength)
        , offsetof(WebKit::RTCNetwork, type)
        , offsetof(WebKit::RTCNetwork, id)
        , offsetof(WebKit::RTCNetwork, preference)
        , offsetof(WebKit::RTCNetwork, active)
        , offsetof(WebKit::RTCNetwork, ignored)
        , offsetof(WebKit::RTCNetwork, scopeID)
        , offsetof(WebKit::RTCNetwork, ips)
    >::value);

    encoder << instance.name;
    encoder << instance.description;
    encoder << instance.prefix;
    encoder << instance.prefixLength;
    encoder << instance.type;
    encoder << instance.id;
    encoder << instance.preference;
    encoder << instance.active;
    encoder << instance.ignored;
    encoder << instance.scopeID;
    encoder << instance.ips;
}

std::optional<WebKit::RTCNetwork> ArgumentCoder<WebKit::RTCNetwork>::decode(Decoder& decoder)
{
    auto name = decoder.decode<Vector<char>>();
    auto description = decoder.decode<Vector<char>>();
    auto prefix = decoder.decode<WebKit::WebRTCNetwork::IPAddress>();
    auto prefixLength = decoder.decode<int>();
    auto type = decoder.decode<int>();
    auto id = decoder.decode<uint16_t>();
    auto preference = decoder.decode<int>();
    auto active = decoder.decode<bool>();
    auto ignored = decoder.decode<bool>();
    auto scopeID = decoder.decode<int>();
    auto ips = decoder.decode<Vector<WebKit::WebRTCNetwork::InterfaceAddress>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::RTCNetwork {
            WTFMove(*name),
            WTFMove(*description),
            WTFMove(*prefix),
            WTFMove(*prefixLength),
            WTFMove(*type),
            WTFMove(*id),
            WTFMove(*preference),
            WTFMove(*active),
            WTFMove(*ignored),
            WTFMove(*scopeID),
            WTFMove(*ips)
        }
    };
}

#endif

#if (USE(LIBWEBRTC)) && (USE(LIBWEBRTC) && PLATFORM(COCOA))
void ArgumentCoder<webrtc::WebKitEncodedFrameInfo>::encode(Encoder& encoder, const webrtc::WebKitEncodedFrameInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.width)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.height)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timeStamp)>, int64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.duration)>, std::optional<uint64_t>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ntpTimeMS)>, int64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.captureTimeMS)>, int64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameType)>, webrtc::VideoFrameType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rotation)>, webrtc::WebKitEncodedVideoRotation>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentType)>, webrtc::VideoContentType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.completeFrame)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.qp)>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.temporalIndex)>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timing)>, webrtc::WebKitEncodedFrameTiming>);
    struct ShouldBeSameSizeAsWebKitEncodedFrameInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<webrtc::WebKitEncodedFrameInfo>, false> {
        uint32_t width;
        uint32_t height;
        int64_t timeStamp;
        std::optional<uint64_t> duration;
        int64_t ntpTimeMS;
        int64_t captureTimeMS;
        webrtc::VideoFrameType frameType;
        webrtc::WebKitEncodedVideoRotation rotation;
        webrtc::VideoContentType contentType;
        bool completeFrame;
        int qp;
        int temporalIndex;
        webrtc::WebKitEncodedFrameTiming timing;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebKitEncodedFrameInfo) == sizeof(webrtc::WebKitEncodedFrameInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(webrtc::WebKitEncodedFrameInfo, width)
        , offsetof(webrtc::WebKitEncodedFrameInfo, height)
        , offsetof(webrtc::WebKitEncodedFrameInfo, timeStamp)
        , offsetof(webrtc::WebKitEncodedFrameInfo, duration)
        , offsetof(webrtc::WebKitEncodedFrameInfo, ntpTimeMS)
        , offsetof(webrtc::WebKitEncodedFrameInfo, captureTimeMS)
        , offsetof(webrtc::WebKitEncodedFrameInfo, frameType)
        , offsetof(webrtc::WebKitEncodedFrameInfo, rotation)
        , offsetof(webrtc::WebKitEncodedFrameInfo, contentType)
        , offsetof(webrtc::WebKitEncodedFrameInfo, completeFrame)
        , offsetof(webrtc::WebKitEncodedFrameInfo, qp)
        , offsetof(webrtc::WebKitEncodedFrameInfo, temporalIndex)
        , offsetof(webrtc::WebKitEncodedFrameInfo, timing)
    >::value);

    encoder << instance.width;
    encoder << instance.height;
    encoder << instance.timeStamp;
    encoder << instance.duration;
    encoder << instance.ntpTimeMS;
    encoder << instance.captureTimeMS;
    encoder << instance.frameType;
    encoder << instance.rotation;
    encoder << instance.contentType;
    encoder << instance.completeFrame;
    encoder << instance.qp;
    encoder << instance.temporalIndex;
    encoder << instance.timing;
}

std::optional<webrtc::WebKitEncodedFrameInfo> ArgumentCoder<webrtc::WebKitEncodedFrameInfo>::decode(Decoder& decoder)
{
    auto width = decoder.decode<uint32_t>();
    auto height = decoder.decode<uint32_t>();
    auto timeStamp = decoder.decode<int64_t>();
    auto duration = decoder.decode<std::optional<uint64_t>>();
    auto ntpTimeMS = decoder.decode<int64_t>();
    auto captureTimeMS = decoder.decode<int64_t>();
    auto frameType = decoder.decode<webrtc::VideoFrameType>();
    auto rotation = decoder.decode<webrtc::WebKitEncodedVideoRotation>();
    auto contentType = decoder.decode<webrtc::VideoContentType>();
    auto completeFrame = decoder.decode<bool>();
    auto qp = decoder.decode<int>();
    auto temporalIndex = decoder.decode<int>();
    auto timing = decoder.decode<webrtc::WebKitEncodedFrameTiming>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        webrtc::WebKitEncodedFrameInfo {
            WTFMove(*width),
            WTFMove(*height),
            WTFMove(*timeStamp),
            WTFMove(*duration),
            WTFMove(*ntpTimeMS),
            WTFMove(*captureTimeMS),
            WTFMove(*frameType),
            WTFMove(*rotation),
            WTFMove(*contentType),
            WTFMove(*completeFrame),
            WTFMove(*qp),
            WTFMove(*temporalIndex),
            WTFMove(*timing)
        }
    };
}

#endif

#if (USE(LIBWEBRTC)) && (USE(LIBWEBRTC) && PLATFORM(COCOA))
void ArgumentCoder<webrtc::EncodedImage::Timing>::encode(Encoder& encoder, const webrtc::EncodedImage::Timing& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.flags)>, uint8_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.encode_start_ms)>, int64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.encode_finish_ms)>, int64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.packetization_finish_ms)>, int64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pacer_exit_ms)>, int64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.network_timestamp_ms)>, int64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.network2_timestamp_ms)>, int64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.receive_start_ms)>, int64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.receive_finish_ms)>, int64_t>);
    struct ShouldBeSameSizeAsTiming : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<webrtc::EncodedImage::Timing>, false> {
        uint8_t flags;
        int64_t encode_start_ms;
        int64_t encode_finish_ms;
        int64_t packetization_finish_ms;
        int64_t pacer_exit_ms;
        int64_t network_timestamp_ms;
        int64_t network2_timestamp_ms;
        int64_t receive_start_ms;
        int64_t receive_finish_ms;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTiming) == sizeof(webrtc::EncodedImage::Timing));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(webrtc::EncodedImage::Timing, flags)
        , offsetof(webrtc::EncodedImage::Timing, encode_start_ms)
        , offsetof(webrtc::EncodedImage::Timing, encode_finish_ms)
        , offsetof(webrtc::EncodedImage::Timing, packetization_finish_ms)
        , offsetof(webrtc::EncodedImage::Timing, pacer_exit_ms)
        , offsetof(webrtc::EncodedImage::Timing, network_timestamp_ms)
        , offsetof(webrtc::EncodedImage::Timing, network2_timestamp_ms)
        , offsetof(webrtc::EncodedImage::Timing, receive_start_ms)
        , offsetof(webrtc::EncodedImage::Timing, receive_finish_ms)
    >::value);

    encoder << instance.flags;
    encoder << instance.encode_start_ms;
    encoder << instance.encode_finish_ms;
    encoder << instance.packetization_finish_ms;
    encoder << instance.pacer_exit_ms;
    encoder << instance.network_timestamp_ms;
    encoder << instance.network2_timestamp_ms;
    encoder << instance.receive_start_ms;
    encoder << instance.receive_finish_ms;
}

std::optional<webrtc::EncodedImage::Timing> ArgumentCoder<webrtc::EncodedImage::Timing>::decode(Decoder& decoder)
{
    auto flags = decoder.decode<uint8_t>();
    auto encode_start_ms = decoder.decode<int64_t>();
    auto encode_finish_ms = decoder.decode<int64_t>();
    auto packetization_finish_ms = decoder.decode<int64_t>();
    auto pacer_exit_ms = decoder.decode<int64_t>();
    auto network_timestamp_ms = decoder.decode<int64_t>();
    auto network2_timestamp_ms = decoder.decode<int64_t>();
    auto receive_start_ms = decoder.decode<int64_t>();
    auto receive_finish_ms = decoder.decode<int64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        webrtc::EncodedImage::Timing {
            WTFMove(*flags),
            WTFMove(*encode_start_ms),
            WTFMove(*encode_finish_ms),
            WTFMove(*packetization_finish_ms),
            WTFMove(*pacer_exit_ms),
            WTFMove(*network_timestamp_ms),
            WTFMove(*network2_timestamp_ms),
            WTFMove(*receive_start_ms),
            WTFMove(*receive_finish_ms)
        }
    };
}

#endif

#if USE(LIBWEBRTC)
void ArgumentCoder<WebKit::RTCPacketOptions::SerializableData>::encode(Encoder& encoder, const WebKit::RTCPacketOptions::SerializableData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dscp)>, WebKit::RTCPacketOptions::DifferentiatedServicesCodePoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.packetId)>, int32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rtpSendtimeExtensionId)>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.srtpAuthTagLength)>, int64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.srtpAuthKey)>, std::span<const char>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.srtpPacketIndex)>, int64_t>);
    struct ShouldBeSameSizeAsSerializableData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::RTCPacketOptions::SerializableData>, false> {
        WebKit::RTCPacketOptions::DifferentiatedServicesCodePoint dscp;
        int32_t packetId;
        int rtpSendtimeExtensionId;
        int64_t srtpAuthTagLength;
        std::span<const char> srtpAuthKey;
        int64_t srtpPacketIndex;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSerializableData) == sizeof(WebKit::RTCPacketOptions::SerializableData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::RTCPacketOptions::SerializableData, dscp)
        , offsetof(WebKit::RTCPacketOptions::SerializableData, packetId)
        , offsetof(WebKit::RTCPacketOptions::SerializableData, rtpSendtimeExtensionId)
        , offsetof(WebKit::RTCPacketOptions::SerializableData, srtpAuthTagLength)
        , offsetof(WebKit::RTCPacketOptions::SerializableData, srtpAuthKey)
        , offsetof(WebKit::RTCPacketOptions::SerializableData, srtpPacketIndex)
    >::value);

    encoder << instance.dscp;
    encoder << instance.packetId;
    encoder << instance.rtpSendtimeExtensionId;
    encoder << instance.srtpAuthTagLength;
    encoder << instance.srtpAuthKey;
    encoder << instance.srtpPacketIndex;
}

std::optional<WebKit::RTCPacketOptions::SerializableData> ArgumentCoder<WebKit::RTCPacketOptions::SerializableData>::decode(Decoder& decoder)
{
    auto dscp = decoder.decode<WebKit::RTCPacketOptions::DifferentiatedServicesCodePoint>();
    auto packetId = decoder.decode<int32_t>();
    auto rtpSendtimeExtensionId = decoder.decode<int>();
    auto srtpAuthTagLength = decoder.decode<int64_t>();
    auto srtpAuthKey = decoder.decode<std::span<const char>>();
    auto srtpPacketIndex = decoder.decode<int64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::RTCPacketOptions::SerializableData {
            WTFMove(*dscp),
            WTFMove(*packetId),
            WTFMove(*rtpSendtimeExtensionId),
            WTFMove(*srtpAuthTagLength),
            WTFMove(*srtpAuthKey),
            WTFMove(*srtpPacketIndex)
        }
    };
}

#endif

#if USE(LIBWEBRTC)
void ArgumentCoder<WebKit::RTCPacketOptions>::encode(Encoder& encoder, const WebKit::RTCPacketOptions& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.serializableData())>, WebKit::RTCPacketOptions::SerializableData>);

    encoder << instance.serializableData();
}

std::optional<WebKit::RTCPacketOptions> ArgumentCoder<WebKit::RTCPacketOptions>::decode(Decoder& decoder)
{
    auto serializableData = decoder.decode<WebKit::RTCPacketOptions::SerializableData>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::RTCPacketOptions {
            WTFMove(*serializableData)
        }
    };
}

#endif

#if ENABLE(TOUCH_EVENTS)
void ArgumentCoder<WebKit::RemoteWebTouchEvent>::encode(Encoder& encoder, const WebKit::RemoteWebTouchEvent& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.targetFrameID)>, WebCore::FrameIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.transformedEvent)>, WebKit::WebTouchEvent>);
    struct ShouldBeSameSizeAsRemoteWebTouchEvent : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::RemoteWebTouchEvent>, false> {
        WebCore::FrameIdentifier targetFrameID;
        WebKit::WebTouchEvent transformedEvent;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRemoteWebTouchEvent) == sizeof(WebKit::RemoteWebTouchEvent));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::RemoteWebTouchEvent, targetFrameID)
        , offsetof(WebKit::RemoteWebTouchEvent, transformedEvent)
    >::value);

    encoder << instance.targetFrameID;
    encoder << instance.transformedEvent;
}

std::optional<WebKit::RemoteWebTouchEvent> ArgumentCoder<WebKit::RemoteWebTouchEvent>::decode(Decoder& decoder)
{
    auto targetFrameID = decoder.decode<WebCore::FrameIdentifier>();
    auto transformedEvent = decoder.decode<WebKit::WebTouchEvent>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::RemoteWebTouchEvent {
            WTFMove(*targetFrameID),
            WTFMove(*transformedEvent)
        }
    };
}

#endif

void ArgumentCoder<WebKit::RemoteWorkerInitializationData>::encode(Encoder& encoder, const WebKit::RemoteWorkerInitializationData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.userContentControllerIdentifier)>, WebKit::UserContentControllerIdentifier>);
#if ENABLE(CONTENT_EXTENSIONS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentRuleLists)>, Vector<std::pair<WebKit::WebCompiledContentRuleListData, URL>>>);
#endif
    struct ShouldBeSameSizeAsRemoteWorkerInitializationData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::RemoteWorkerInitializationData>, false> {
        WebKit::UserContentControllerIdentifier userContentControllerIdentifier;
#if ENABLE(CONTENT_EXTENSIONS)
        Vector<std::pair<WebKit::WebCompiledContentRuleListData, URL>> contentRuleLists;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsRemoteWorkerInitializationData) == sizeof(WebKit::RemoteWorkerInitializationData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::RemoteWorkerInitializationData, userContentControllerIdentifier)
#if ENABLE(CONTENT_EXTENSIONS)
        , offsetof(WebKit::RemoteWorkerInitializationData, contentRuleLists)
#endif
    >::value);

    encoder << instance.userContentControllerIdentifier;
#if ENABLE(CONTENT_EXTENSIONS)
    encoder << instance.contentRuleLists;
#endif
}

std::optional<WebKit::RemoteWorkerInitializationData> ArgumentCoder<WebKit::RemoteWorkerInitializationData>::decode(Decoder& decoder)
{
    auto userContentControllerIdentifier = decoder.decode<WebKit::UserContentControllerIdentifier>();
#if ENABLE(CONTENT_EXTENSIONS)
    auto contentRuleLists = decoder.decode<Vector<std::pair<WebKit::WebCompiledContentRuleListData, URL>>>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::RemoteWorkerInitializationData {
            WTFMove(*userContentControllerIdentifier),
#if ENABLE(CONTENT_EXTENSIONS)
            WTFMove(*contentRuleLists)
#endif
        }
    };
}

void ArgumentCoder<WebKit::ResourceLoadInfo>::encode(Encoder& encoder, const WebKit::ResourceLoadInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.resourceLoadID)>, WebKit::NetworkResourceLoadIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameID)>, std::optional<WebCore::FrameIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.parentFrameID)>, std::optional<WebCore::FrameIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.documentID)>, Markable<WTF::UUID>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.originalURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.originalHTTPMethod)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.eventTimestamp)>, WallTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.loadedFromCache)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebKit::ResourceLoadInfo::Type>);
    struct ShouldBeSameSizeAsResourceLoadInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::ResourceLoadInfo>, false> {
        WebKit::NetworkResourceLoadIdentifier resourceLoadID;
        std::optional<WebCore::FrameIdentifier> frameID;
        std::optional<WebCore::FrameIdentifier> parentFrameID;
        Markable<WTF::UUID> documentID;
        URL originalURL;
        String originalHTTPMethod;
        WallTime eventTimestamp;
        bool loadedFromCache;
        WebKit::ResourceLoadInfo::Type type;
    };
    static_assert(sizeof(ShouldBeSameSizeAsResourceLoadInfo) == sizeof(WebKit::ResourceLoadInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::ResourceLoadInfo, resourceLoadID)
        , offsetof(WebKit::ResourceLoadInfo, frameID)
        , offsetof(WebKit::ResourceLoadInfo, parentFrameID)
        , offsetof(WebKit::ResourceLoadInfo, documentID)
        , offsetof(WebKit::ResourceLoadInfo, originalURL)
        , offsetof(WebKit::ResourceLoadInfo, originalHTTPMethod)
        , offsetof(WebKit::ResourceLoadInfo, eventTimestamp)
        , offsetof(WebKit::ResourceLoadInfo, loadedFromCache)
        , offsetof(WebKit::ResourceLoadInfo, type)
    >::value);

    encoder << instance.resourceLoadID;
    encoder << instance.frameID;
    encoder << instance.parentFrameID;
    encoder << instance.documentID;
    encoder << instance.originalURL;
    encoder << instance.originalHTTPMethod;
    encoder << instance.eventTimestamp;
    encoder << instance.loadedFromCache;
    encoder << instance.type;
}

std::optional<WebKit::ResourceLoadInfo> ArgumentCoder<WebKit::ResourceLoadInfo>::decode(Decoder& decoder)
{
    auto resourceLoadID = decoder.decode<WebKit::NetworkResourceLoadIdentifier>();
    auto frameID = decoder.decode<std::optional<WebCore::FrameIdentifier>>();
    auto parentFrameID = decoder.decode<std::optional<WebCore::FrameIdentifier>>();
    auto documentID = decoder.decode<Markable<WTF::UUID>>();
    auto originalURL = decoder.decode<URL>();
    auto originalHTTPMethod = decoder.decode<String>();
    auto eventTimestamp = decoder.decode<WallTime>();
    auto loadedFromCache = decoder.decode<bool>();
    auto type = decoder.decode<WebKit::ResourceLoadInfo::Type>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::ResourceLoadInfo {
            WTFMove(*resourceLoadID),
            WTFMove(*frameID),
            WTFMove(*parentFrameID),
            WTFMove(*documentID),
            WTFMove(*originalURL),
            WTFMove(*originalHTTPMethod),
            WTFMove(*eventTimestamp),
            WTFMove(*loadedFromCache),
            WTFMove(*type)
        }
    };
}

void ArgumentCoder<WebKit::ResourceLoadStatisticsParameters>::encode(Encoder& encoder, WebKit::ResourceLoadStatisticsParameters&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.directory)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.directoryExtensionHandle)>, WebKit::SandboxExtensionHandle>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.enabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.enableLogTestingEvent)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldIncludeLocalhost)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.enableDebugMode)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.thirdPartyCookieBlockingMode)>, WebCore::ThirdPartyCookieBlockingMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sameSiteStrictEnforcementEnabled)>, WebCore::SameSiteStrictEnforcementEnabled>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.firstPartyWebsiteDataRemovalMode)>, WebCore::FirstPartyWebsiteDataRemovalMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.standaloneApplicationDomain)>, WebCore::RegistrableDomain>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.appBoundDomains)>, HashSet<WebCore::RegistrableDomain>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.managedDomains)>, HashSet<WebCore::RegistrableDomain>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.persistedDomains)>, HashSet<WebCore::RegistrableDomain>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.manualPrevalentResource)>, WebCore::RegistrableDomain>);
    struct ShouldBeSameSizeAsResourceLoadStatisticsParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::ResourceLoadStatisticsParameters>, false> {
        String directory;
        WebKit::SandboxExtensionHandle directoryExtensionHandle;
        bool enabled;
        bool enableLogTestingEvent;
        bool shouldIncludeLocalhost;
        bool enableDebugMode;
        WebCore::ThirdPartyCookieBlockingMode thirdPartyCookieBlockingMode;
        WebCore::SameSiteStrictEnforcementEnabled sameSiteStrictEnforcementEnabled;
        WebCore::FirstPartyWebsiteDataRemovalMode firstPartyWebsiteDataRemovalMode;
        WebCore::RegistrableDomain standaloneApplicationDomain;
        HashSet<WebCore::RegistrableDomain> appBoundDomains;
        HashSet<WebCore::RegistrableDomain> managedDomains;
        HashSet<WebCore::RegistrableDomain> persistedDomains;
        WebCore::RegistrableDomain manualPrevalentResource;
    };
    static_assert(sizeof(ShouldBeSameSizeAsResourceLoadStatisticsParameters) == sizeof(WebKit::ResourceLoadStatisticsParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::ResourceLoadStatisticsParameters, directory)
        , offsetof(WebKit::ResourceLoadStatisticsParameters, directoryExtensionHandle)
        , offsetof(WebKit::ResourceLoadStatisticsParameters, enabled)
        , offsetof(WebKit::ResourceLoadStatisticsParameters, enableLogTestingEvent)
        , offsetof(WebKit::ResourceLoadStatisticsParameters, shouldIncludeLocalhost)
        , offsetof(WebKit::ResourceLoadStatisticsParameters, enableDebugMode)
        , offsetof(WebKit::ResourceLoadStatisticsParameters, thirdPartyCookieBlockingMode)
        , offsetof(WebKit::ResourceLoadStatisticsParameters, sameSiteStrictEnforcementEnabled)
        , offsetof(WebKit::ResourceLoadStatisticsParameters, firstPartyWebsiteDataRemovalMode)
        , offsetof(WebKit::ResourceLoadStatisticsParameters, standaloneApplicationDomain)
        , offsetof(WebKit::ResourceLoadStatisticsParameters, appBoundDomains)
        , offsetof(WebKit::ResourceLoadStatisticsParameters, managedDomains)
        , offsetof(WebKit::ResourceLoadStatisticsParameters, persistedDomains)
        , offsetof(WebKit::ResourceLoadStatisticsParameters, manualPrevalentResource)
    >::value);

    encoder << WTFMove(instance.directory);
    encoder << WTFMove(instance.directoryExtensionHandle);
    encoder << WTFMove(instance.enabled);
    encoder << WTFMove(instance.enableLogTestingEvent);
    encoder << WTFMove(instance.shouldIncludeLocalhost);
    encoder << WTFMove(instance.enableDebugMode);
    encoder << WTFMove(instance.thirdPartyCookieBlockingMode);
    encoder << WTFMove(instance.sameSiteStrictEnforcementEnabled);
    encoder << WTFMove(instance.firstPartyWebsiteDataRemovalMode);
    encoder << WTFMove(instance.standaloneApplicationDomain);
    encoder << WTFMove(instance.appBoundDomains);
    encoder << WTFMove(instance.managedDomains);
    encoder << WTFMove(instance.persistedDomains);
    encoder << WTFMove(instance.manualPrevalentResource);
}

std::optional<WebKit::ResourceLoadStatisticsParameters> ArgumentCoder<WebKit::ResourceLoadStatisticsParameters>::decode(Decoder& decoder)
{
    auto directory = decoder.decode<String>();
    auto directoryExtensionHandle = decoder.decode<WebKit::SandboxExtensionHandle>();
    auto enabled = decoder.decode<bool>();
    auto enableLogTestingEvent = decoder.decode<bool>();
    auto shouldIncludeLocalhost = decoder.decode<bool>();
    auto enableDebugMode = decoder.decode<bool>();
    auto thirdPartyCookieBlockingMode = decoder.decode<WebCore::ThirdPartyCookieBlockingMode>();
    auto sameSiteStrictEnforcementEnabled = decoder.decode<WebCore::SameSiteStrictEnforcementEnabled>();
    auto firstPartyWebsiteDataRemovalMode = decoder.decode<WebCore::FirstPartyWebsiteDataRemovalMode>();
    auto standaloneApplicationDomain = decoder.decode<WebCore::RegistrableDomain>();
    auto appBoundDomains = decoder.decode<HashSet<WebCore::RegistrableDomain>>();
    auto managedDomains = decoder.decode<HashSet<WebCore::RegistrableDomain>>();
    auto persistedDomains = decoder.decode<HashSet<WebCore::RegistrableDomain>>();
    auto manualPrevalentResource = decoder.decode<WebCore::RegistrableDomain>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::ResourceLoadStatisticsParameters {
            WTFMove(*directory),
            WTFMove(*directoryExtensionHandle),
            WTFMove(*enabled),
            WTFMove(*enableLogTestingEvent),
            WTFMove(*shouldIncludeLocalhost),
            WTFMove(*enableDebugMode),
            WTFMove(*thirdPartyCookieBlockingMode),
            WTFMove(*sameSiteStrictEnforcementEnabled),
            WTFMove(*firstPartyWebsiteDataRemovalMode),
            WTFMove(*standaloneApplicationDomain),
            WTFMove(*appBoundDomains),
            WTFMove(*managedDomains),
            WTFMove(*persistedDomains),
            WTFMove(*manualPrevalentResource)
        }
    };
}

void ArgumentCoder<WebKit::SandboxExtensionHandle>::encode(Encoder& encoder, WebKit::SandboxExtensionHandle&& instance)
{
#if ENABLE(SANDBOX_EXTENSIONS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.takeImpl())>, std::unique_ptr<WebKit::SandboxExtensionImpl>>);
#endif

#if ENABLE(SANDBOX_EXTENSIONS)
    encoder << instance.takeImpl();
#endif
}

std::optional<WebKit::SandboxExtensionHandle> ArgumentCoder<WebKit::SandboxExtensionHandle>::decode(Decoder& decoder)
{
#if ENABLE(SANDBOX_EXTENSIONS)
    auto takeImpl = decoder.decode<std::unique_ptr<WebKit::SandboxExtensionImpl>>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::SandboxExtensionHandle {
#if ENABLE(SANDBOX_EXTENSIONS)
            WTFMove(*takeImpl)
#endif
        }
    };
}

#if ENABLE(SANDBOX_EXTENSIONS)
void ArgumentCoder<WebKit::SandboxExtensionImpl>::encode(Encoder& encoder, WebKit::SandboxExtensionImpl&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.getSerializedFormat())>, std::span<const uint8_t>>);

    encoder << instance.getSerializedFormat();
}

std::optional<WebKit::SandboxExtensionImpl> ArgumentCoder<WebKit::SandboxExtensionImpl>::decode(Decoder& decoder)
{
    auto getSerializedFormat = decoder.decode<std::span<const uint8_t>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::SandboxExtensionImpl {
            WTFMove(*getSerializedFormat)
        }
    };
}

#endif

void ArgumentCoder<WebKit::ScriptTrackingPrivacyHost>::encode(Encoder& encoder, const WebKit::ScriptTrackingPrivacyHost& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hostName)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowedCategories)>, OptionSet<WebCore::ScriptTrackingPrivacyFlag>>);
    struct ShouldBeSameSizeAsScriptTrackingPrivacyHost : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::ScriptTrackingPrivacyHost>, false> {
        String hostName;
        OptionSet<WebCore::ScriptTrackingPrivacyFlag> allowedCategories;
    };
    static_assert(sizeof(ShouldBeSameSizeAsScriptTrackingPrivacyHost) == sizeof(WebKit::ScriptTrackingPrivacyHost));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::ScriptTrackingPrivacyHost, hostName)
        , offsetof(WebKit::ScriptTrackingPrivacyHost, allowedCategories)
    >::value);

    encoder << instance.hostName;
    encoder << instance.allowedCategories;
}

std::optional<WebKit::ScriptTrackingPrivacyHost> ArgumentCoder<WebKit::ScriptTrackingPrivacyHost>::decode(Decoder& decoder)
{
    auto hostName = decoder.decode<String>();
    auto allowedCategories = decoder.decode<OptionSet<WebCore::ScriptTrackingPrivacyFlag>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::ScriptTrackingPrivacyHost {
            WTFMove(*hostName),
            WTFMove(*allowedCategories)
        }
    };
}

void ArgumentCoder<WebKit::ScriptTrackingPrivacyRules>::encode(Encoder& encoder, const WebKit::ScriptTrackingPrivacyRules& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.thirdPartyHosts)>, Vector<WebKit::ScriptTrackingPrivacyHost>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.thirdPartyTopDomains)>, Vector<WebKit::ScriptTrackingPrivacyHost>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.firstPartyHosts)>, Vector<WebKit::ScriptTrackingPrivacyHost>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.firstPartyTopDomains)>, Vector<WebKit::ScriptTrackingPrivacyHost>>);
    struct ShouldBeSameSizeAsScriptTrackingPrivacyRules : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::ScriptTrackingPrivacyRules>, false> {
        Vector<WebKit::ScriptTrackingPrivacyHost> thirdPartyHosts;
        Vector<WebKit::ScriptTrackingPrivacyHost> thirdPartyTopDomains;
        Vector<WebKit::ScriptTrackingPrivacyHost> firstPartyHosts;
        Vector<WebKit::ScriptTrackingPrivacyHost> firstPartyTopDomains;
    };
    static_assert(sizeof(ShouldBeSameSizeAsScriptTrackingPrivacyRules) == sizeof(WebKit::ScriptTrackingPrivacyRules));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::ScriptTrackingPrivacyRules, thirdPartyHosts)
        , offsetof(WebKit::ScriptTrackingPrivacyRules, thirdPartyTopDomains)
        , offsetof(WebKit::ScriptTrackingPrivacyRules, firstPartyHosts)
        , offsetof(WebKit::ScriptTrackingPrivacyRules, firstPartyTopDomains)
    >::value);

    encoder << instance.thirdPartyHosts;
    encoder << instance.thirdPartyTopDomains;
    encoder << instance.firstPartyHosts;
    encoder << instance.firstPartyTopDomains;
}

std::optional<WebKit::ScriptTrackingPrivacyRules> ArgumentCoder<WebKit::ScriptTrackingPrivacyRules>::decode(Decoder& decoder)
{
    auto thirdPartyHosts = decoder.decode<Vector<WebKit::ScriptTrackingPrivacyHost>>();
    auto thirdPartyTopDomains = decoder.decode<Vector<WebKit::ScriptTrackingPrivacyHost>>();
    auto firstPartyHosts = decoder.decode<Vector<WebKit::ScriptTrackingPrivacyHost>>();
    auto firstPartyTopDomains = decoder.decode<Vector<WebKit::ScriptTrackingPrivacyHost>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::ScriptTrackingPrivacyRules {
            WTFMove(*thirdPartyHosts),
            WTFMove(*thirdPartyTopDomains),
            WTFMove(*firstPartyHosts),
            WTFMove(*firstPartyTopDomains)
        }
    };
}

#if ENABLE(MOMENTUM_EVENT_DISPATCHER)
void ArgumentCoder<WebKit::ScrollingAccelerationCurve>::encode(Encoder& encoder, const WebKit::ScrollingAccelerationCurve& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.gainLinear())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.gainParabolic())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.gainCubic())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.gainQuartic())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tangentSpeedLinear())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tangentSpeedParabolicRoot())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.resolution())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameRate())>, float>);

    encoder << instance.gainLinear();
    encoder << instance.gainParabolic();
    encoder << instance.gainCubic();
    encoder << instance.gainQuartic();
    encoder << instance.tangentSpeedLinear();
    encoder << instance.tangentSpeedParabolicRoot();
    encoder << instance.resolution();
    encoder << instance.frameRate();
}

std::optional<WebKit::ScrollingAccelerationCurve> ArgumentCoder<WebKit::ScrollingAccelerationCurve>::decode(Decoder& decoder)
{
    auto gainLinear = decoder.decode<float>();
    auto gainParabolic = decoder.decode<float>();
    auto gainCubic = decoder.decode<float>();
    auto gainQuartic = decoder.decode<float>();
    auto tangentSpeedLinear = decoder.decode<float>();
    auto tangentSpeedParabolicRoot = decoder.decode<float>();
    auto resolution = decoder.decode<float>();
    auto frameRate = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::ScrollingAccelerationCurve {
            WTFMove(*gainLinear),
            WTFMove(*gainParabolic),
            WTFMove(*gainCubic),
            WTFMove(*gainQuartic),
            WTFMove(*tangentSpeedLinear),
            WTFMove(*tangentSpeedParabolicRoot),
            WTFMove(*resolution),
            WTFMove(*frameRate)
        }
    };
}

#endif

void ArgumentCoder<WebCore::SerializedNode::QualifiedName>::encode(Encoder& encoder, const WebCore::SerializedNode::QualifiedName& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.prefix)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.localName)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.namespaceURI)>, String>);
    struct ShouldBeSameSizeAsQualifiedName : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SerializedNode::QualifiedName>, false> {
        String prefix;
        String localName;
        String namespaceURI;
    };
    static_assert(sizeof(ShouldBeSameSizeAsQualifiedName) == sizeof(WebCore::SerializedNode::QualifiedName));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SerializedNode::QualifiedName, prefix)
        , offsetof(WebCore::SerializedNode::QualifiedName, localName)
        , offsetof(WebCore::SerializedNode::QualifiedName, namespaceURI)
    >::value);

    encoder << instance.prefix;
    encoder << instance.localName;
    encoder << instance.namespaceURI;
}

std::optional<WebCore::SerializedNode::QualifiedName> ArgumentCoder<WebCore::SerializedNode::QualifiedName>::decode(Decoder& decoder)
{
    auto prefix = decoder.decode<String>();
    auto localName = decoder.decode<String>();
    auto namespaceURI = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SerializedNode::QualifiedName {
            WTFMove(*prefix),
            WTFMove(*localName),
            WTFMove(*namespaceURI)
        }
    };
}

void ArgumentCoder<WebCore::SerializedNode::ContainerNode>::encode(Encoder& encoder, const WebCore::SerializedNode::ContainerNode& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.children)>, Vector<WebCore::SerializedNode>>);
    struct ShouldBeSameSizeAsContainerNode : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SerializedNode::ContainerNode>, false> {
        Vector<WebCore::SerializedNode> children;
    };
    static_assert(sizeof(ShouldBeSameSizeAsContainerNode) == sizeof(WebCore::SerializedNode::ContainerNode));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SerializedNode::ContainerNode, children)
    >::value);

    encoder << instance.children;
}

std::optional<WebCore::SerializedNode::ContainerNode> ArgumentCoder<WebCore::SerializedNode::ContainerNode>::decode(Decoder& decoder)
{
    auto children = decoder.decode<Vector<WebCore::SerializedNode>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SerializedNode::ContainerNode {
            WTFMove(*children)
        }
    };
}

void ArgumentCoder<WebCore::SerializedNode::Attr>::encode(Encoder& encoder, const WebCore::SerializedNode::Attr& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, WebCore::SerializedNode::QualifiedName>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, String>);
    struct ShouldBeSameSizeAsAttr : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SerializedNode::Attr>, false> {
        WebCore::SerializedNode::QualifiedName name;
        String value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsAttr) == sizeof(WebCore::SerializedNode::Attr));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SerializedNode::Attr, name)
        , offsetof(WebCore::SerializedNode::Attr, value)
    >::value);

    encoder << instance.name;
    encoder << instance.value;
}

std::optional<WebCore::SerializedNode::Attr> ArgumentCoder<WebCore::SerializedNode::Attr>::decode(Decoder& decoder)
{
    auto name = decoder.decode<WebCore::SerializedNode::QualifiedName>();
    auto value = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SerializedNode::Attr {
            WTFMove(*name),
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebCore::SerializedNode::CharacterData>::encode(Encoder& encoder, const WebCore::SerializedNode::CharacterData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data)>, String>);
    struct ShouldBeSameSizeAsCharacterData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SerializedNode::CharacterData>, false> {
        String data;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCharacterData) == sizeof(WebCore::SerializedNode::CharacterData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SerializedNode::CharacterData, data)
    >::value);

    encoder << instance.data;
}

std::optional<WebCore::SerializedNode::CharacterData> ArgumentCoder<WebCore::SerializedNode::CharacterData>::decode(Decoder& decoder)
{
    auto data = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SerializedNode::CharacterData {
            WTFMove(*data)
        }
    };
}

void ArgumentCoder<WebCore::SerializedNode::Document>::encode(Encoder& encoder, const WebCore::SerializedNode::Document& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.children)>, Vector<WebCore::SerializedNode>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SerializedNode::ContainerNode, children)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::ClonedDocumentType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.baseURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.baseURLOverride)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.documentURI)>, Variant<String, URL>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentType)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SerializedNode::Document, type)
        , offsetof(WebCore::SerializedNode::Document, url)
        , offsetof(WebCore::SerializedNode::Document, baseURL)
        , offsetof(WebCore::SerializedNode::Document, baseURLOverride)
        , offsetof(WebCore::SerializedNode::Document, documentURI)
        , offsetof(WebCore::SerializedNode::Document, contentType)
    >::value);

    encoder << instance.children;
    encoder << instance.type;
    encoder << instance.url;
    encoder << instance.baseURL;
    encoder << instance.baseURLOverride;
    encoder << instance.documentURI;
    encoder << instance.contentType;
}

std::optional<WebCore::SerializedNode::Document> ArgumentCoder<WebCore::SerializedNode::Document>::decode(Decoder& decoder)
{
    auto children = decoder.decode<Vector<WebCore::SerializedNode>>();
    auto type = decoder.decode<WebCore::ClonedDocumentType>();
    auto url = decoder.decode<URL>();
    auto baseURL = decoder.decode<URL>();
    auto baseURLOverride = decoder.decode<URL>();
    auto documentURI = decoder.decode<Variant<String, URL>>();
    auto contentType = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SerializedNode::Document {
            WebCore::SerializedNode::ContainerNode {
                WTFMove(*children)
            },
            WTFMove(*type),
            WTFMove(*url),
            WTFMove(*baseURL),
            WTFMove(*baseURLOverride),
            WTFMove(*documentURI),
            WTFMove(*contentType)
        }
    };
}

void ArgumentCoder<WebCore::SerializedNode::DocumentFragment>::encode(Encoder& encoder, const WebCore::SerializedNode::DocumentFragment& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.children)>, Vector<WebCore::SerializedNode>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SerializedNode::ContainerNode, children)
    >::value);

    static_assert(MembersInCorrectOrder < 0
    >::value);

    encoder << instance.children;
}

std::optional<WebCore::SerializedNode::DocumentFragment> ArgumentCoder<WebCore::SerializedNode::DocumentFragment>::decode(Decoder& decoder)
{
    auto children = decoder.decode<Vector<WebCore::SerializedNode>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SerializedNode::DocumentFragment {
            WebCore::SerializedNode::ContainerNode {
                WTFMove(*children)
            }
        }
    };
}

void ArgumentCoder<WebCore::SerializedNode::DocumentType>::encode(Encoder& encoder, const WebCore::SerializedNode::DocumentType& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.publicId)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.systemId)>, String>);
    struct ShouldBeSameSizeAsDocumentType : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SerializedNode::DocumentType>, false> {
        String name;
        String publicId;
        String systemId;
    };
    static_assert(sizeof(ShouldBeSameSizeAsDocumentType) == sizeof(WebCore::SerializedNode::DocumentType));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SerializedNode::DocumentType, name)
        , offsetof(WebCore::SerializedNode::DocumentType, publicId)
        , offsetof(WebCore::SerializedNode::DocumentType, systemId)
    >::value);

    encoder << instance.name;
    encoder << instance.publicId;
    encoder << instance.systemId;
}

std::optional<WebCore::SerializedNode::DocumentType> ArgumentCoder<WebCore::SerializedNode::DocumentType>::decode(Decoder& decoder)
{
    auto name = decoder.decode<String>();
    auto publicId = decoder.decode<String>();
    auto systemId = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SerializedNode::DocumentType {
            WTFMove(*name),
            WTFMove(*publicId),
            WTFMove(*systemId)
        }
    };
}

void ArgumentCoder<WebCore::SerializedNode::Element::Attribute>::encode(Encoder& encoder, const WebCore::SerializedNode::Element::Attribute& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, WebCore::SerializedNode::QualifiedName>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, String>);
    struct ShouldBeSameSizeAsAttribute : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SerializedNode::Element::Attribute>, false> {
        WebCore::SerializedNode::QualifiedName name;
        String value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsAttribute) == sizeof(WebCore::SerializedNode::Element::Attribute));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SerializedNode::Element::Attribute, name)
        , offsetof(WebCore::SerializedNode::Element::Attribute, value)
    >::value);

    encoder << instance.name;
    encoder << instance.value;
}

std::optional<WebCore::SerializedNode::Element::Attribute> ArgumentCoder<WebCore::SerializedNode::Element::Attribute>::decode(Decoder& decoder)
{
    auto name = decoder.decode<WebCore::SerializedNode::QualifiedName>();
    auto value = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SerializedNode::Element::Attribute {
            WTFMove(*name),
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebCore::SerializedNode::Element>::encode(Encoder& encoder, const WebCore::SerializedNode::Element& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.children)>, Vector<WebCore::SerializedNode>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SerializedNode::ContainerNode, children)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, WebCore::SerializedNode::QualifiedName>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.attributes)>, Vector<WebCore::SerializedNode::Element::Attribute>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SerializedNode::Element, name)
        , offsetof(WebCore::SerializedNode::Element, attributes)
    >::value);

    encoder << instance.children;
    encoder << instance.name;
    encoder << instance.attributes;
}

std::optional<WebCore::SerializedNode::Element> ArgumentCoder<WebCore::SerializedNode::Element>::decode(Decoder& decoder)
{
    auto children = decoder.decode<Vector<WebCore::SerializedNode>>();
    auto name = decoder.decode<WebCore::SerializedNode::QualifiedName>();
    auto attributes = decoder.decode<Vector<WebCore::SerializedNode::Element::Attribute>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SerializedNode::Element {
            WebCore::SerializedNode::ContainerNode {
                WTFMove(*children)
            },
            WTFMove(*name),
            WTFMove(*attributes)
        }
    };
}

void ArgumentCoder<WebCore::SerializedNode::Comment>::encode(Encoder& encoder, const WebCore::SerializedNode::Comment& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SerializedNode::CharacterData, data)
    >::value);

    static_assert(MembersInCorrectOrder < 0
    >::value);

    encoder << instance.data;
}

std::optional<WebCore::SerializedNode::Comment> ArgumentCoder<WebCore::SerializedNode::Comment>::decode(Decoder& decoder)
{
    auto data = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SerializedNode::Comment {
            WebCore::SerializedNode::CharacterData {
                WTFMove(*data)
            }
        }
    };
}

void ArgumentCoder<WebCore::SerializedNode::Text>::encode(Encoder& encoder, const WebCore::SerializedNode::Text& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SerializedNode::CharacterData, data)
    >::value);

    static_assert(MembersInCorrectOrder < 0
    >::value);

    encoder << instance.data;
}

std::optional<WebCore::SerializedNode::Text> ArgumentCoder<WebCore::SerializedNode::Text>::decode(Decoder& decoder)
{
    auto data = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SerializedNode::Text {
            WebCore::SerializedNode::CharacterData {
                WTFMove(*data)
            }
        }
    };
}

void ArgumentCoder<WebCore::SerializedNode::CDATASection>::encode(Encoder& encoder, const WebCore::SerializedNode::CDATASection& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SerializedNode::CharacterData, data)
    >::value);

    static_assert(MembersInCorrectOrder < 0
    >::value);

    static_assert(MembersInCorrectOrder < 0
    >::value);

    encoder << instance.data;
}

std::optional<WebCore::SerializedNode::CDATASection> ArgumentCoder<WebCore::SerializedNode::CDATASection>::decode(Decoder& decoder)
{
    auto data = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SerializedNode::CDATASection {
            WebCore::SerializedNode::Text {
                WebCore::SerializedNode::CharacterData {
                    WTFMove(*data)
                }
            }
        }
    };
}

void ArgumentCoder<WebCore::SerializedNode::ProcessingInstruction>::encode(Encoder& encoder, const WebCore::SerializedNode::ProcessingInstruction& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SerializedNode::CharacterData, data)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.target)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SerializedNode::ProcessingInstruction, target)
    >::value);

    encoder << instance.data;
    encoder << instance.target;
}

std::optional<WebCore::SerializedNode::ProcessingInstruction> ArgumentCoder<WebCore::SerializedNode::ProcessingInstruction>::decode(Decoder& decoder)
{
    auto data = decoder.decode<String>();
    auto target = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SerializedNode::ProcessingInstruction {
            WebCore::SerializedNode::CharacterData {
                WTFMove(*data)
            },
            WTFMove(*target)
        }
    };
}

void ArgumentCoder<WebCore::SerializedNode::ShadowRoot>::encode(Encoder& encoder, const WebCore::SerializedNode::ShadowRoot& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.children)>, Vector<WebCore::SerializedNode>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SerializedNode::ContainerNode, children)
    >::value);

    static_assert(MembersInCorrectOrder < 0
    >::value);

    static_assert(MembersInCorrectOrder < 0
    >::value);

    encoder << instance.children;
}

std::optional<WebCore::SerializedNode::ShadowRoot> ArgumentCoder<WebCore::SerializedNode::ShadowRoot>::decode(Decoder& decoder)
{
    auto children = decoder.decode<Vector<WebCore::SerializedNode>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SerializedNode::ShadowRoot {
            WebCore::SerializedNode::DocumentFragment {
                WebCore::SerializedNode::ContainerNode {
                    WTFMove(*children)
                }
            }
        }
    };
}

void ArgumentCoder<WebCore::SerializedNode::HTMLTemplateElement>::encode(Encoder& encoder, const WebCore::SerializedNode::HTMLTemplateElement& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.children)>, Vector<WebCore::SerializedNode>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SerializedNode::ContainerNode, children)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, WebCore::SerializedNode::QualifiedName>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.attributes)>, Vector<WebCore::SerializedNode::Element::Attribute>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SerializedNode::Element, name)
        , offsetof(WebCore::SerializedNode::Element, attributes)
    >::value);

    static_assert(MembersInCorrectOrder < 0
    >::value);

    encoder << instance.children;
    encoder << instance.name;
    encoder << instance.attributes;
}

std::optional<WebCore::SerializedNode::HTMLTemplateElement> ArgumentCoder<WebCore::SerializedNode::HTMLTemplateElement>::decode(Decoder& decoder)
{
    auto children = decoder.decode<Vector<WebCore::SerializedNode>>();
    auto name = decoder.decode<WebCore::SerializedNode::QualifiedName>();
    auto attributes = decoder.decode<Vector<WebCore::SerializedNode::Element::Attribute>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SerializedNode::HTMLTemplateElement {
            WebCore::SerializedNode::Element {
                WebCore::SerializedNode::ContainerNode {
                    WTFMove(*children)
                },
                WTFMove(*name),
                WTFMove(*attributes)
            }
        }
    };
}

void ArgumentCoder<WebCore::SerializedNode>::encode(Encoder& encoder, const WebCore::SerializedNode& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data)>, Variant<WebCore::SerializedNode::Attr, WebCore::SerializedNode::CDATASection, WebCore::SerializedNode::Comment, WebCore::SerializedNode::Document, WebCore::SerializedNode::DocumentFragment, WebCore::SerializedNode::DocumentType, WebCore::SerializedNode::Element, WebCore::SerializedNode::ProcessingInstruction, WebCore::SerializedNode::ShadowRoot, WebCore::SerializedNode::Text, WebCore::SerializedNode::HTMLTemplateElement>>);
    struct ShouldBeSameSizeAsSerializedNode : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SerializedNode>, false> {
        Variant<WebCore::SerializedNode::Attr, WebCore::SerializedNode::CDATASection, WebCore::SerializedNode::Comment, WebCore::SerializedNode::Document, WebCore::SerializedNode::DocumentFragment, WebCore::SerializedNode::DocumentType, WebCore::SerializedNode::Element, WebCore::SerializedNode::ProcessingInstruction, WebCore::SerializedNode::ShadowRoot, WebCore::SerializedNode::Text, WebCore::SerializedNode::HTMLTemplateElement> data;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSerializedNode) == sizeof(WebCore::SerializedNode));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SerializedNode, data)
    >::value);

    encoder << instance.data;
}

std::optional<WebCore::SerializedNode> ArgumentCoder<WebCore::SerializedNode>::decode(Decoder& decoder)
{
    auto data = decoder.decode<Variant<WebCore::SerializedNode::Attr, WebCore::SerializedNode::CDATASection, WebCore::SerializedNode::Comment, WebCore::SerializedNode::Document, WebCore::SerializedNode::DocumentFragment, WebCore::SerializedNode::DocumentType, WebCore::SerializedNode::Element, WebCore::SerializedNode::ProcessingInstruction, WebCore::SerializedNode::ShadowRoot, WebCore::SerializedNode::Text, WebCore::SerializedNode::HTMLTemplateElement>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SerializedNode {
            WTFMove(*data)
        }
    };
}

void ArgumentCoder<WebKit::HTTPBody>::encode(Encoder& encoder, const WebKit::HTTPBody& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentType)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.elements)>, Vector<WebKit::HTTPBody::Element>>);
    struct ShouldBeSameSizeAsHTTPBody : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::HTTPBody>, false> {
        String contentType;
        Vector<WebKit::HTTPBody::Element> elements;
    };
    static_assert(sizeof(ShouldBeSameSizeAsHTTPBody) == sizeof(WebKit::HTTPBody));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::HTTPBody, contentType)
        , offsetof(WebKit::HTTPBody, elements)
    >::value);

    encoder << instance.contentType;
    encoder << instance.elements;
}

std::optional<WebKit::HTTPBody> ArgumentCoder<WebKit::HTTPBody>::decode(Decoder& decoder)
{
    auto contentType = decoder.decode<String>();
    auto elements = decoder.decode<Vector<WebKit::HTTPBody::Element>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::HTTPBody {
            WTFMove(*contentType),
            WTFMove(*elements)
        }
    };
}

void ArgumentCoder<WebKit::HTTPBody::Element>::encode(Encoder& encoder, const WebKit::HTTPBody::Element& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data)>, Variant<Vector<uint8_t>, WebKit::HTTPBody::Element::FileData, String>>);
    struct ShouldBeSameSizeAsElement : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::HTTPBody::Element>, false> {
        Variant<Vector<uint8_t>, WebKit::HTTPBody::Element::FileData, String> data;
    };
    static_assert(sizeof(ShouldBeSameSizeAsElement) == sizeof(WebKit::HTTPBody::Element));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::HTTPBody::Element, data)
    >::value);

    encoder << instance.data;
}

std::optional<WebKit::HTTPBody::Element> ArgumentCoder<WebKit::HTTPBody::Element>::decode(Decoder& decoder)
{
    auto data = decoder.decode<Variant<Vector<uint8_t>, WebKit::HTTPBody::Element::FileData, String>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::HTTPBody::Element {
            WTFMove(*data)
        }
    };
}

void ArgumentCoder<WebKit::HTTPBody::Element::FileData>::encode(Encoder& encoder, const WebKit::HTTPBody::Element::FileData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.filePath)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fileStart)>, int64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fileLength)>, std::optional<int64_t>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.expectedFileModificationTime)>, std::optional<WallTime>>);
    struct ShouldBeSameSizeAsFileData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::HTTPBody::Element::FileData>, false> {
        String filePath;
        int64_t fileStart;
        std::optional<int64_t> fileLength;
        std::optional<WallTime> expectedFileModificationTime;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFileData) == sizeof(WebKit::HTTPBody::Element::FileData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::HTTPBody::Element::FileData, filePath)
        , offsetof(WebKit::HTTPBody::Element::FileData, fileStart)
        , offsetof(WebKit::HTTPBody::Element::FileData, fileLength)
        , offsetof(WebKit::HTTPBody::Element::FileData, expectedFileModificationTime)
    >::value);

    encoder << instance.filePath;
    encoder << instance.fileStart;
    encoder << instance.fileLength;
    encoder << instance.expectedFileModificationTime;
}

std::optional<WebKit::HTTPBody::Element::FileData> ArgumentCoder<WebKit::HTTPBody::Element::FileData>::decode(Decoder& decoder)
{
    auto filePath = decoder.decode<String>();
    auto fileStart = decoder.decode<int64_t>();
    auto fileLength = decoder.decode<std::optional<int64_t>>();
    auto expectedFileModificationTime = decoder.decode<std::optional<WallTime>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::HTTPBody::Element::FileData {
            WTFMove(*filePath),
            WTFMove(*fileStart),
            WTFMove(*fileLength),
            WTFMove(*expectedFileModificationTime)
        }
    };
}

void ArgumentCoder<WebKit::FrameState>::encode(Encoder& encoder, const WebKit::FrameState& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.urlString)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.originalURLString)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.referrer)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.target)>, AtomString>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameID)>, std::optional<WebCore::FrameIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stateObjectData)>, std::optional<Vector<uint8_t>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.documentSequenceNumber)>, int64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.itemSequenceNumber)>, int64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scrollPosition)>, WebCore::IntPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldRestoreScrollPosition)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pageScaleFactor)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.httpBody)>, std::optional<WebKit::HTTPBody>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.itemID)>, Markable<WebCore::BackForwardItemIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameItemID)>, Markable<WebCore::BackForwardFrameItemIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasCachedPage)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.title)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldOpenExternalURLsPolicy)>, WebCore::ShouldOpenExternalURLsPolicy>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sessionStateObject)>, RefPtr<WebCore::SerializedScriptValue>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.wasCreatedByJSWithoutUserInteraction)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.wasRestoredFromSession)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.policyContainer)>, std::optional<WebCore::PolicyContainer>>);
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.exposedContentRect)>, WebCore::FloatRect>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.unobscuredContentRect)>, WebCore::IntRect>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.minimumLayoutSizeInScrollViewCoordinates)>, WebCore::FloatSize>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentSize)>, WebCore::IntSize>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scaleIsInitial)>, bool>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.obscuredInsets)>, WebCore::FloatBoxExtent>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.children)>, Vector<Ref<WebKit::FrameState>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.documentState())>, Vector<AtomString>>);

    encoder << instance.urlString;
    encoder << instance.originalURLString;
    encoder << instance.referrer;
    encoder << instance.target;
    encoder << instance.frameID;
    encoder << instance.stateObjectData;
    encoder << instance.documentSequenceNumber;
    encoder << instance.itemSequenceNumber;
    encoder << instance.scrollPosition;
    encoder << instance.shouldRestoreScrollPosition;
    encoder << instance.pageScaleFactor;
    encoder << instance.httpBody;
    encoder << instance.itemID;
    encoder << instance.frameItemID;
    encoder << instance.hasCachedPage;
    encoder << instance.title;
    encoder << instance.shouldOpenExternalURLsPolicy;
    encoder << instance.sessionStateObject;
    encoder << instance.wasCreatedByJSWithoutUserInteraction;
    encoder << instance.wasRestoredFromSession;
    encoder << instance.policyContainer;
#if PLATFORM(IOS_FAMILY)
    encoder << instance.exposedContentRect;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.unobscuredContentRect;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.minimumLayoutSizeInScrollViewCoordinates;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.contentSize;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.scaleIsInitial;
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.obscuredInsets;
#endif
    encoder << instance.children;
    encoder << instance.documentState();
}

std::optional<Ref<WebKit::FrameState>> ArgumentCoder<WebKit::FrameState>::decode(Decoder& decoder)
{
    auto urlString = decoder.decode<String>();
    auto originalURLString = decoder.decode<String>();
    auto referrer = decoder.decode<String>();
    auto target = decoder.decode<AtomString>();
    auto frameID = decoder.decode<std::optional<WebCore::FrameIdentifier>>();
    auto stateObjectData = decoder.decode<std::optional<Vector<uint8_t>>>();
    auto documentSequenceNumber = decoder.decode<int64_t>();
    auto itemSequenceNumber = decoder.decode<int64_t>();
    auto scrollPosition = decoder.decode<WebCore::IntPoint>();
    auto shouldRestoreScrollPosition = decoder.decode<bool>();
    auto pageScaleFactor = decoder.decode<float>();
    auto httpBody = decoder.decode<std::optional<WebKit::HTTPBody>>();
    auto itemID = decoder.decode<Markable<WebCore::BackForwardItemIdentifier>>();
    auto frameItemID = decoder.decode<Markable<WebCore::BackForwardFrameItemIdentifier>>();
    auto hasCachedPage = decoder.decode<bool>();
    auto title = decoder.decode<String>();
    auto shouldOpenExternalURLsPolicy = decoder.decode<WebCore::ShouldOpenExternalURLsPolicy>();
    auto sessionStateObject = decoder.decode<RefPtr<WebCore::SerializedScriptValue>>();
    auto wasCreatedByJSWithoutUserInteraction = decoder.decode<bool>();
    auto wasRestoredFromSession = decoder.decode<bool>();
    auto policyContainer = decoder.decode<std::optional<WebCore::PolicyContainer>>();
#if PLATFORM(IOS_FAMILY)
    auto exposedContentRect = decoder.decode<WebCore::FloatRect>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto unobscuredContentRect = decoder.decode<WebCore::IntRect>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto minimumLayoutSizeInScrollViewCoordinates = decoder.decode<WebCore::FloatSize>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto contentSize = decoder.decode<WebCore::IntSize>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto scaleIsInitial = decoder.decode<bool>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto obscuredInsets = decoder.decode<WebCore::FloatBoxExtent>();
#endif
    auto children = decoder.decode<Vector<Ref<WebKit::FrameState>>>();
    auto documentState = decoder.decode<Vector<AtomString>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(WebKit::FrameState::validateDocumentState(*documentState)))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::FrameState::create(
            WTFMove(*urlString),
            WTFMove(*originalURLString),
            WTFMove(*referrer),
            WTFMove(*target),
            WTFMove(*frameID),
            WTFMove(*stateObjectData),
            WTFMove(*documentSequenceNumber),
            WTFMove(*itemSequenceNumber),
            WTFMove(*scrollPosition),
            WTFMove(*shouldRestoreScrollPosition),
            WTFMove(*pageScaleFactor),
            WTFMove(*httpBody),
            WTFMove(*itemID),
            WTFMove(*frameItemID),
            WTFMove(*hasCachedPage),
            WTFMove(*title),
            WTFMove(*shouldOpenExternalURLsPolicy),
            WTFMove(*sessionStateObject),
            WTFMove(*wasCreatedByJSWithoutUserInteraction),
            WTFMove(*wasRestoredFromSession),
            WTFMove(*policyContainer),
#if PLATFORM(IOS_FAMILY)
            WTFMove(*exposedContentRect),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*unobscuredContentRect),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*minimumLayoutSizeInScrollViewCoordinates),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*contentSize),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*scaleIsInitial),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*obscuredInsets),
#endif
            WTFMove(*children),
            WTFMove(*documentState)
        )
    };
}

void ArgumentCoder<WebKit::BackForwardListState>::encode(Encoder& encoder, const WebKit::BackForwardListState& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.items)>, Vector<Ref<WebKit::FrameState>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.currentIndex)>, std::optional<uint32_t>>);
    struct ShouldBeSameSizeAsBackForwardListState : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::BackForwardListState>, false> {
        Vector<Ref<WebKit::FrameState>> items;
        std::optional<uint32_t> currentIndex;
    };
    static_assert(sizeof(ShouldBeSameSizeAsBackForwardListState) == sizeof(WebKit::BackForwardListState));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::BackForwardListState, items)
        , offsetof(WebKit::BackForwardListState, currentIndex)
    >::value);

    encoder << instance.items;
    encoder << instance.currentIndex;
}

std::optional<WebKit::BackForwardListState> ArgumentCoder<WebKit::BackForwardListState>::decode(Decoder& decoder)
{
    auto items = decoder.decode<Vector<Ref<WebKit::FrameState>>>();
    auto currentIndex = decoder.decode<std::optional<uint32_t>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::BackForwardListState {
            WTFMove(*items),
            WTFMove(*currentIndex)
        }
    };
}

#if ENABLE(IMAGE_ANALYSIS)
void ArgumentCoder<WebCore::TextRecognitionWordData>::encode(Encoder& encoder, const WebCore::TextRecognitionWordData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.text)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.normalizedQuad)>, WebCore::FloatQuad>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasLeadingWhitespace)>, bool>);
    struct ShouldBeSameSizeAsTextRecognitionWordData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::TextRecognitionWordData>, false> {
        String text;
        WebCore::FloatQuad normalizedQuad;
        bool hasLeadingWhitespace;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTextRecognitionWordData) == sizeof(WebCore::TextRecognitionWordData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::TextRecognitionWordData, text)
        , offsetof(WebCore::TextRecognitionWordData, normalizedQuad)
        , offsetof(WebCore::TextRecognitionWordData, hasLeadingWhitespace)
    >::value);

    encoder << instance.text;
    encoder << instance.normalizedQuad;
    encoder << instance.hasLeadingWhitespace;
}

std::optional<WebCore::TextRecognitionWordData> ArgumentCoder<WebCore::TextRecognitionWordData>::decode(Decoder& decoder)
{
    auto text = decoder.decode<String>();
    auto normalizedQuad = decoder.decode<WebCore::FloatQuad>();
    auto hasLeadingWhitespace = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TextRecognitionWordData {
            WTFMove(*text),
            WTFMove(*normalizedQuad),
            WTFMove(*hasLeadingWhitespace)
        }
    };
}

#endif

#if ENABLE(IMAGE_ANALYSIS)
void ArgumentCoder<WebCore::TextRecognitionLineData>::encode(Encoder& encoder, const WebCore::TextRecognitionLineData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.normalizedQuad)>, WebCore::FloatQuad>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.children)>, Vector<WebCore::TextRecognitionWordData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasTrailingNewline)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isVertical)>, bool>);
    struct ShouldBeSameSizeAsTextRecognitionLineData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::TextRecognitionLineData>, false> {
        WebCore::FloatQuad normalizedQuad;
        Vector<WebCore::TextRecognitionWordData> children;
        bool hasTrailingNewline;
        bool isVertical;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTextRecognitionLineData) == sizeof(WebCore::TextRecognitionLineData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::TextRecognitionLineData, normalizedQuad)
        , offsetof(WebCore::TextRecognitionLineData, children)
        , offsetof(WebCore::TextRecognitionLineData, hasTrailingNewline)
        , offsetof(WebCore::TextRecognitionLineData, isVertical)
    >::value);

    encoder << instance.normalizedQuad;
    encoder << instance.children;
    encoder << instance.hasTrailingNewline;
    encoder << instance.isVertical;
}

std::optional<WebCore::TextRecognitionLineData> ArgumentCoder<WebCore::TextRecognitionLineData>::decode(Decoder& decoder)
{
    auto normalizedQuad = decoder.decode<WebCore::FloatQuad>();
    auto children = decoder.decode<Vector<WebCore::TextRecognitionWordData>>();
    auto hasTrailingNewline = decoder.decode<bool>();
    auto isVertical = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TextRecognitionLineData {
            WTFMove(*normalizedQuad),
            WTFMove(*children),
            WTFMove(*hasTrailingNewline),
            WTFMove(*isVertical)
        }
    };
}

#endif

#if ENABLE(IMAGE_ANALYSIS)
void ArgumentCoder<WebCore::TextRecognitionBlockData>::encode(Encoder& encoder, const WebCore::TextRecognitionBlockData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.text)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.normalizedQuad)>, WebCore::FloatQuad>);
    struct ShouldBeSameSizeAsTextRecognitionBlockData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::TextRecognitionBlockData>, false> {
        String text;
        WebCore::FloatQuad normalizedQuad;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTextRecognitionBlockData) == sizeof(WebCore::TextRecognitionBlockData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::TextRecognitionBlockData, text)
        , offsetof(WebCore::TextRecognitionBlockData, normalizedQuad)
    >::value);

    encoder << instance.text;
    encoder << instance.normalizedQuad;
}

std::optional<WebCore::TextRecognitionBlockData> ArgumentCoder<WebCore::TextRecognitionBlockData>::decode(Decoder& decoder)
{
    auto text = decoder.decode<String>();
    auto normalizedQuad = decoder.decode<WebCore::FloatQuad>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TextRecognitionBlockData {
            WTFMove(*text),
            WTFMove(*normalizedQuad)
        }
    };
}

#endif

#if ENABLE(IMAGE_ANALYSIS)
void ArgumentCoder<WebCore::TextRecognitionResult>::encode(Encoder& encoder, const WebCore::TextRecognitionResult& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lines)>, Vector<WebCore::TextRecognitionLineData>>);
#if ENABLE(DATA_DETECTION)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dataDetectors)>, Vector<WebCore::TextRecognitionDataDetector>>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.blocks)>, Vector<WebCore::TextRecognitionBlockData>>);
#if ENABLE(IMAGE_ANALYSIS_ENHANCEMENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.imageAnalysisData)>, RetainPtr<NSData>>);
#endif
    struct ShouldBeSameSizeAsTextRecognitionResult : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::TextRecognitionResult>, false> {
        Vector<WebCore::TextRecognitionLineData> lines;
#if ENABLE(DATA_DETECTION)
        Vector<WebCore::TextRecognitionDataDetector> dataDetectors;
#endif
        Vector<WebCore::TextRecognitionBlockData> blocks;
#if ENABLE(IMAGE_ANALYSIS_ENHANCEMENTS)
        RetainPtr<NSData> imageAnalysisData;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsTextRecognitionResult) == sizeof(WebCore::TextRecognitionResult));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::TextRecognitionResult, lines)
#if ENABLE(DATA_DETECTION)
        , offsetof(WebCore::TextRecognitionResult, dataDetectors)
#endif
        , offsetof(WebCore::TextRecognitionResult, blocks)
#if ENABLE(IMAGE_ANALYSIS_ENHANCEMENTS)
        , offsetof(WebCore::TextRecognitionResult, imageAnalysisData)
#endif
    >::value);

    encoder << instance.lines;
#if ENABLE(DATA_DETECTION)
    encoder << instance.dataDetectors;
#endif
    encoder << instance.blocks;
#if ENABLE(IMAGE_ANALYSIS_ENHANCEMENTS)
    encoder << instance.imageAnalysisData;
#endif
}

std::optional<WebCore::TextRecognitionResult> ArgumentCoder<WebCore::TextRecognitionResult>::decode(Decoder& decoder)
{
    auto lines = decoder.decode<Vector<WebCore::TextRecognitionLineData>>();
#if ENABLE(DATA_DETECTION)
    auto dataDetectors = decoder.decode<Vector<WebCore::TextRecognitionDataDetector>>();
#endif
    auto blocks = decoder.decode<Vector<WebCore::TextRecognitionBlockData>>();
#if ENABLE(IMAGE_ANALYSIS_ENHANCEMENTS)
    auto imageAnalysisData = decoder.decode<RetainPtr<NSData>>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TextRecognitionResult {
            WTFMove(*lines),
#if ENABLE(DATA_DETECTION)
            WTFMove(*dataDetectors),
#endif
            WTFMove(*blocks),
#if ENABLE(IMAGE_ANALYSIS_ENHANCEMENTS)
            WTFMove(*imageAnalysisData)
#endif
        }
    };
}

#endif

void ArgumentCoder<WebKit::URLSchemeTaskParameters>::encode(Encoder& encoder, const WebKit::URLSchemeTaskParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.handlerIdentifier)>, WebKit::WebURLSchemeHandlerIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.taskIdentifier)>, WebCore::ResourceLoaderIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.request)>, WebCore::ResourceRequest>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameInfo)>, WebKit::FrameInfoData>);
    struct ShouldBeSameSizeAsURLSchemeTaskParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::URLSchemeTaskParameters>, false> {
        WebKit::WebURLSchemeHandlerIdentifier handlerIdentifier;
        WebCore::ResourceLoaderIdentifier taskIdentifier;
        WebCore::ResourceRequest request;
        WebKit::FrameInfoData frameInfo;
    };
    static_assert(sizeof(ShouldBeSameSizeAsURLSchemeTaskParameters) == sizeof(WebKit::URLSchemeTaskParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::URLSchemeTaskParameters, handlerIdentifier)
        , offsetof(WebKit::URLSchemeTaskParameters, taskIdentifier)
        , offsetof(WebKit::URLSchemeTaskParameters, request)
        , offsetof(WebKit::URLSchemeTaskParameters, frameInfo)
    >::value);

    encoder << instance.handlerIdentifier;
    encoder << instance.taskIdentifier;
    encoder << instance.request;
    encoder << IPC::FormDataReference { instance.request.httpBody() };
    encoder << instance.frameInfo;
}

std::optional<WebKit::URLSchemeTaskParameters> ArgumentCoder<WebKit::URLSchemeTaskParameters>::decode(Decoder& decoder)
{
    auto handlerIdentifier = decoder.decode<WebKit::WebURLSchemeHandlerIdentifier>();
    auto taskIdentifier = decoder.decode<WebCore::ResourceLoaderIdentifier>();
    auto request = decoder.decode<WebCore::ResourceRequest>();
    if (request) {
        if (auto requestBody = decoder.decode<IPC::FormDataReference>())
            request->setHTTPBody(requestBody->takeData());
    }
    auto frameInfo = decoder.decode<WebKit::FrameInfoData>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::URLSchemeTaskParameters {
            WTFMove(*handlerIdentifier),
            WTFMove(*taskIdentifier),
            WTFMove(*request),
            WTFMove(*frameInfo)
        }
    };
}

#if USE(COORDINATED_GRAPHICS) || USE(TEXTURE_MAPPER)
void ArgumentCoder<WebKit::UpdateInfo>::encode(Encoder& encoder, WebKit::UpdateInfo&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.viewSize)>, WebCore::IntSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.deviceScaleFactor)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scrollRect)>, WebCore::IntRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scrollOffset)>, WebCore::IntSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.updateRectBounds)>, WebCore::IntRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.updateRects)>, Vector<WebCore::IntRect>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.updateScaleFactor)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bitmapHandle)>, std::optional<WebCore::ShareableBitmapHandle>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bitmapOffset)>, WebCore::IntPoint>);
    struct ShouldBeSameSizeAsUpdateInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::UpdateInfo>, false> {
        WebCore::IntSize viewSize;
        float deviceScaleFactor;
        WebCore::IntRect scrollRect;
        WebCore::IntSize scrollOffset;
        WebCore::IntRect updateRectBounds;
        Vector<WebCore::IntRect> updateRects;
        float updateScaleFactor;
        std::optional<WebCore::ShareableBitmapHandle> bitmapHandle;
        WebCore::IntPoint bitmapOffset;
    };
    static_assert(sizeof(ShouldBeSameSizeAsUpdateInfo) == sizeof(WebKit::UpdateInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::UpdateInfo, viewSize)
        , offsetof(WebKit::UpdateInfo, deviceScaleFactor)
        , offsetof(WebKit::UpdateInfo, scrollRect)
        , offsetof(WebKit::UpdateInfo, scrollOffset)
        , offsetof(WebKit::UpdateInfo, updateRectBounds)
        , offsetof(WebKit::UpdateInfo, updateRects)
        , offsetof(WebKit::UpdateInfo, updateScaleFactor)
        , offsetof(WebKit::UpdateInfo, bitmapHandle)
        , offsetof(WebKit::UpdateInfo, bitmapOffset)
    >::value);

    encoder << WTFMove(instance.viewSize);
    encoder << WTFMove(instance.deviceScaleFactor);
    encoder << WTFMove(instance.scrollRect);
    encoder << WTFMove(instance.scrollOffset);
    encoder << WTFMove(instance.updateRectBounds);
    encoder << WTFMove(instance.updateRects);
    encoder << WTFMove(instance.updateScaleFactor);
    encoder << WTFMove(instance.bitmapHandle);
    encoder << WTFMove(instance.bitmapOffset);
}

std::optional<WebKit::UpdateInfo> ArgumentCoder<WebKit::UpdateInfo>::decode(Decoder& decoder)
{
    auto viewSize = decoder.decode<WebCore::IntSize>();
    auto deviceScaleFactor = decoder.decode<float>();
    auto scrollRect = decoder.decode<WebCore::IntRect>();
    auto scrollOffset = decoder.decode<WebCore::IntSize>();
    auto updateRectBounds = decoder.decode<WebCore::IntRect>();
    auto updateRects = decoder.decode<Vector<WebCore::IntRect>>();
    auto updateScaleFactor = decoder.decode<float>();
    auto bitmapHandle = decoder.decode<std::optional<WebCore::ShareableBitmapHandle>>();
    auto bitmapOffset = decoder.decode<WebCore::IntPoint>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::UpdateInfo {
            WTFMove(*viewSize),
            WTFMove(*deviceScaleFactor),
            WTFMove(*scrollRect),
            WTFMove(*scrollOffset),
            WTFMove(*updateRectBounds),
            WTFMove(*updateRects),
            WTFMove(*updateScaleFactor),
            WTFMove(*bitmapHandle),
            WTFMove(*bitmapOffset)
        }
    };
}

#endif

void ArgumentCoder<WebKit::UserContentControllerParameters>::encode(Encoder& encoder, const WebKit::UserContentControllerParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, WebKit::UserContentControllerIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.userContentWorlds)>, Vector<WebKit::ContentWorldData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.userScripts)>, Vector<WebKit::WebUserScriptData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.userStyleSheets)>, Vector<WebKit::WebUserStyleSheetData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.messageHandlers)>, Vector<WebKit::WebScriptMessageHandlerData>>);
#if ENABLE(CONTENT_EXTENSIONS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentRuleLists)>, Vector<std::pair<WebKit::WebCompiledContentRuleListData, URL>>>);
#endif
    struct ShouldBeSameSizeAsUserContentControllerParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::UserContentControllerParameters>, false> {
        WebKit::UserContentControllerIdentifier identifier;
        Vector<WebKit::ContentWorldData> userContentWorlds;
        Vector<WebKit::WebUserScriptData> userScripts;
        Vector<WebKit::WebUserStyleSheetData> userStyleSheets;
        Vector<WebKit::WebScriptMessageHandlerData> messageHandlers;
#if ENABLE(CONTENT_EXTENSIONS)
        Vector<std::pair<WebKit::WebCompiledContentRuleListData, URL>> contentRuleLists;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsUserContentControllerParameters) == sizeof(WebKit::UserContentControllerParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::UserContentControllerParameters, identifier)
        , offsetof(WebKit::UserContentControllerParameters, userContentWorlds)
        , offsetof(WebKit::UserContentControllerParameters, userScripts)
        , offsetof(WebKit::UserContentControllerParameters, userStyleSheets)
        , offsetof(WebKit::UserContentControllerParameters, messageHandlers)
#if ENABLE(CONTENT_EXTENSIONS)
        , offsetof(WebKit::UserContentControllerParameters, contentRuleLists)
#endif
    >::value);

    encoder << instance.identifier;
    encoder << instance.userContentWorlds;
    encoder << instance.userScripts;
    encoder << instance.userStyleSheets;
    encoder << instance.messageHandlers;
#if ENABLE(CONTENT_EXTENSIONS)
    encoder << instance.contentRuleLists;
#endif
}

std::optional<WebKit::UserContentControllerParameters> ArgumentCoder<WebKit::UserContentControllerParameters>::decode(Decoder& decoder)
{
    bool addedDecodingFailureIndex = false;
    auto identifier = decoder.decode<WebKit::UserContentControllerIdentifier>();
    if (!identifier && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(0);
        addedDecodingFailureIndex = true;
    }
    auto userContentWorlds = decoder.decode<Vector<WebKit::ContentWorldData>>();
    if (!userContentWorlds && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(1);
        addedDecodingFailureIndex = true;
    }
    auto userScripts = decoder.decode<Vector<WebKit::WebUserScriptData>>();
    if (!userScripts && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(2);
        addedDecodingFailureIndex = true;
    }
    auto userStyleSheets = decoder.decode<Vector<WebKit::WebUserStyleSheetData>>();
    if (!userStyleSheets && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(3);
        addedDecodingFailureIndex = true;
    }
    auto messageHandlers = decoder.decode<Vector<WebKit::WebScriptMessageHandlerData>>();
    if (!messageHandlers && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(4);
        addedDecodingFailureIndex = true;
    }
#if ENABLE(CONTENT_EXTENSIONS)
    auto contentRuleLists = decoder.decode<Vector<std::pair<WebKit::WebCompiledContentRuleListData, URL>>>();
    if (!contentRuleLists && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(5);
        addedDecodingFailureIndex = true;
    }
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::UserContentControllerParameters {
            WTFMove(*identifier),
            WTFMove(*userContentWorlds),
            WTFMove(*userScripts),
            WTFMove(*userStyleSheets),
            WTFMove(*messageHandlers),
#if ENABLE(CONTENT_EXTENSIONS)
            WTFMove(*contentRuleLists)
#endif
        }
    };
}

void ArgumentCoder<WebKit::UserData>::encode(Encoder& encoder, const WebKit::UserData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.protectedObject())>, RefPtr<API::Object>>);

    encoder << instance.protectedObject();
}

std::optional<WebKit::UserData> ArgumentCoder<WebKit::UserData>::decode(Decoder& decoder)
{
    auto protectedObject = decoder.decode<RefPtr<API::Object>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::UserData {
            WTFMove(*protectedObject)
        }
    };
}

#if ENABLE(UI_SIDE_COMPOSITING)
void ArgumentCoder<WebKit::VisibleContentRectUpdateInfo>::encode(Encoder& encoder, const WebKit::VisibleContentRectUpdateInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.exposedContentRect())>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.unobscuredContentRect())>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentInsets())>, WebCore::FloatBoxExtent>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.unobscuredRectInScrollViewCoordinates())>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.unobscuredContentRectRespectingInputViewBounds())>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.layoutViewportRect())>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.obscuredInsets())>, WebCore::FloatBoxExtent>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.unobscuredSafeAreaInsets())>, WebCore::FloatBoxExtent>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scale())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.viewStability())>, OptionSet<WebKit::ViewStabilityFlag>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isFirstUpdateForNewViewSize())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowShrinkToFit())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.enclosedInScrollableAncestorView())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scrollVelocity())>, WebCore::VelocityData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lastLayerTreeTransactionID())>, WebKit::TransactionID>);

    encoder << instance.exposedContentRect();
    encoder << instance.unobscuredContentRect();
    encoder << instance.contentInsets();
    encoder << instance.unobscuredRectInScrollViewCoordinates();
    encoder << instance.unobscuredContentRectRespectingInputViewBounds();
    encoder << instance.layoutViewportRect();
    encoder << instance.obscuredInsets();
    encoder << instance.unobscuredSafeAreaInsets();
    encoder << instance.scale();
    encoder << instance.viewStability();
    encoder << instance.isFirstUpdateForNewViewSize();
    encoder << instance.allowShrinkToFit();
    encoder << instance.enclosedInScrollableAncestorView();
    encoder << instance.scrollVelocity();
    encoder << instance.lastLayerTreeTransactionID();
}

std::optional<WebKit::VisibleContentRectUpdateInfo> ArgumentCoder<WebKit::VisibleContentRectUpdateInfo>::decode(Decoder& decoder)
{
    auto exposedContentRect = decoder.decode<WebCore::FloatRect>();
    auto unobscuredContentRect = decoder.decode<WebCore::FloatRect>();
    auto contentInsets = decoder.decode<WebCore::FloatBoxExtent>();
    auto unobscuredRectInScrollViewCoordinates = decoder.decode<WebCore::FloatRect>();
    auto unobscuredContentRectRespectingInputViewBounds = decoder.decode<WebCore::FloatRect>();
    auto layoutViewportRect = decoder.decode<WebCore::FloatRect>();
    auto obscuredInsets = decoder.decode<WebCore::FloatBoxExtent>();
    auto unobscuredSafeAreaInsets = decoder.decode<WebCore::FloatBoxExtent>();
    auto scale = decoder.decode<double>();
    auto viewStability = decoder.decode<OptionSet<WebKit::ViewStabilityFlag>>();
    auto isFirstUpdateForNewViewSize = decoder.decode<bool>();
    auto allowShrinkToFit = decoder.decode<bool>();
    auto enclosedInScrollableAncestorView = decoder.decode<bool>();
    auto scrollVelocity = decoder.decode<WebCore::VelocityData>();
    auto lastLayerTreeTransactionID = decoder.decode<WebKit::TransactionID>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::VisibleContentRectUpdateInfo {
            WTFMove(*exposedContentRect),
            WTFMove(*unobscuredContentRect),
            WTFMove(*contentInsets),
            WTFMove(*unobscuredRectInScrollViewCoordinates),
            WTFMove(*unobscuredContentRectRespectingInputViewBounds),
            WTFMove(*layoutViewportRect),
            WTFMove(*obscuredInsets),
            WTFMove(*unobscuredSafeAreaInsets),
            WTFMove(*scale),
            WTFMove(*viewStability),
            WTFMove(*isFirstUpdateForNewViewSize),
            WTFMove(*allowShrinkToFit),
            WTFMove(*enclosedInScrollableAncestorView),
            WTFMove(*scrollVelocity),
            WTFMove(*lastLayerTreeTransactionID)
        }
    };
}

#endif

void ArgumentCoder<WTF::MediaTime>::encode(Encoder& encoder, const WTF::MediaTime& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timeValue())>, int64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timeScale())>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timeFlags())>, uint8_t>);

    encoder << instance.timeValue();
    encoder << instance.timeScale();
    encoder << instance.timeFlags();
}

void ArgumentCoder<WTF::MediaTime>::encode(StreamConnectionEncoder& encoder, const WTF::MediaTime& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timeValue())>, int64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timeScale())>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timeFlags())>, uint8_t>);

    encoder << instance.timeValue();
    encoder << instance.timeScale();
    encoder << instance.timeFlags();
}

std::optional<WTF::MediaTime> ArgumentCoder<WTF::MediaTime>::decode(Decoder& decoder)
{
    auto timeValue = decoder.decode<int64_t>();
    auto timeScale = decoder.decode<uint32_t>();
    auto timeFlags = decoder.decode<uint8_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WTF::MediaTime {
            WTFMove(*timeValue),
            WTFMove(*timeScale),
            WTFMove(*timeFlags)
        }
    };
}

void ArgumentCoder<WTF::Seconds>::encode(Encoder& encoder, const WTF::Seconds& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value())>, double>);

    encoder << instance.value();
}

void ArgumentCoder<WTF::Seconds>::encode(StreamConnectionEncoder& encoder, const WTF::Seconds& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value())>, double>);

    encoder << instance.value();
}

std::optional<WTF::Seconds> ArgumentCoder<WTF::Seconds>::decode(Decoder& decoder)
{
    auto value = decoder.decode<double>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WTF::Seconds {
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WTF::MonotonicTime>::encode(Encoder& encoder, const WTF::MonotonicTime& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.secondsSinceEpoch().seconds())>, double>);

    encoder << instance.secondsSinceEpoch().seconds();
}

std::optional<WTF::MonotonicTime> ArgumentCoder<WTF::MonotonicTime>::decode(Decoder& decoder)
{
    auto secondsSinceEpochseconds = decoder.decode<double>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WTF::MonotonicTime::fromRawSeconds(
            WTFMove(*secondsSinceEpochseconds)
        )
    };
}

void ArgumentCoder<WTF::WallTime>::encode(Encoder& encoder, const WTF::WallTime& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.secondsSinceEpoch().seconds())>, double>);

    encoder << instance.secondsSinceEpoch().seconds();
}

std::optional<WTF::WallTime> ArgumentCoder<WTF::WallTime>::decode(Decoder& decoder)
{
    auto secondsSinceEpochseconds = decoder.decode<double>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WTF::WallTime::fromRawSeconds(
            WTFMove(*secondsSinceEpochseconds)
        )
    };
}

void ArgumentCoder<WTF::AtomString>::encode(Encoder& encoder, const WTF::AtomString& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.string())>, String>);

    encoder << instance.string();
}

void ArgumentCoder<WTF::AtomString>::encode(StreamConnectionEncoder& encoder, const WTF::AtomString& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.string())>, String>);

    encoder << instance.string();
}

std::optional<WTF::AtomString> ArgumentCoder<WTF::AtomString>::decode(Decoder& decoder)
{
    auto string = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WTF::AtomString {
            WTFMove(*string)
        }
    };
}

void ArgumentCoder<WTF::JSONImpl::Value>::encode(Encoder& encoder, const WTF::JSONImpl::Value& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.toJSONString())>, String>);

    encoder << instance.toJSONString();
}

std::optional<Ref<WTF::JSONImpl::Value>> ArgumentCoder<WTF::JSONImpl::Value>::decode(Decoder& decoder)
{
    auto toJSONString = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WTF::JSONImpl::Value::optionalParseJSON(
            WTFMove(*toJSONString)
        )
    };
}

void ArgumentCoder<WTF::MemoryPressureHandlerConfiguration>::encode(Encoder& encoder, const WTF::MemoryPressureHandlerConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.baseThreshold)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.conservativeThresholdFraction)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.strictThresholdFraction)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.killThresholdFraction)>, std::optional<double>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pollInterval)>, Seconds>);
    struct ShouldBeSameSizeAsMemoryPressureHandlerConfiguration : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WTF::MemoryPressureHandlerConfiguration>, false> {
        uint64_t baseThreshold;
        double conservativeThresholdFraction;
        double strictThresholdFraction;
        std::optional<double> killThresholdFraction;
        Seconds pollInterval;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMemoryPressureHandlerConfiguration) == sizeof(WTF::MemoryPressureHandlerConfiguration));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WTF::MemoryPressureHandlerConfiguration, baseThreshold)
        , offsetof(WTF::MemoryPressureHandlerConfiguration, conservativeThresholdFraction)
        , offsetof(WTF::MemoryPressureHandlerConfiguration, strictThresholdFraction)
        , offsetof(WTF::MemoryPressureHandlerConfiguration, killThresholdFraction)
        , offsetof(WTF::MemoryPressureHandlerConfiguration, pollInterval)
    >::value);

    encoder << instance.baseThreshold;
    encoder << instance.conservativeThresholdFraction;
    encoder << instance.strictThresholdFraction;
    encoder << instance.killThresholdFraction;
    encoder << instance.pollInterval;
}

std::optional<WTF::MemoryPressureHandlerConfiguration> ArgumentCoder<WTF::MemoryPressureHandlerConfiguration>::decode(Decoder& decoder)
{
    auto baseThreshold = decoder.decode<uint64_t>();
    auto conservativeThresholdFraction = decoder.decode<double>();
    auto strictThresholdFraction = decoder.decode<double>();
    auto killThresholdFraction = decoder.decode<std::optional<double>>();
    auto pollInterval = decoder.decode<Seconds>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WTF::MemoryPressureHandlerConfiguration {
            WTFMove(*baseThreshold),
            WTFMove(*conservativeThresholdFraction),
            WTFMove(*strictThresholdFraction),
            WTFMove(*killThresholdFraction),
            WTFMove(*pollInterval)
        }
    };
}

void ArgumentCoder<std::monostate>::encode(Encoder& encoder, const std::monostate& instance)
{
    struct ShouldBeSameSizeAsmonostate : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<std::monostate>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsmonostate) == sizeof(std::monostate));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

void ArgumentCoder<std::monostate>::encode(StreamConnectionEncoder& encoder, const std::monostate& instance)
{
    struct ShouldBeSameSizeAsmonostate : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<std::monostate>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsmonostate) == sizeof(std::monostate));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<std::monostate> ArgumentCoder<std::monostate>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        std::monostate {
        }
    };
}

#if PLATFORM(COCOA)
std::optional<WTF::MachSendRightAnnotated> ArgumentCoder<WTF::MachSendRightAnnotated>::decode(Decoder& decoder)
{
    auto sendRight = decoder.decode<MachSendRight>();
    auto data = decoder.decode<FixedVector<uint8_t>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WTF::MachSendRightAnnotated {
            WTFMove(*sendRight),
            WTFMove(*data)
        }
    };
}

#endif

void ArgumentCoder<WebKit::WebBackForwardListCounts>::encode(Encoder& encoder, const WebKit::WebBackForwardListCounts& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.backCount)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.forwardCount)>, uint32_t>);
    struct ShouldBeSameSizeAsWebBackForwardListCounts : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebBackForwardListCounts>, false> {
        uint32_t backCount;
        uint32_t forwardCount;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebBackForwardListCounts) == sizeof(WebKit::WebBackForwardListCounts));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebBackForwardListCounts, backCount)
        , offsetof(WebKit::WebBackForwardListCounts, forwardCount)
    >::value);

    encoder << instance.backCount;
    encoder << instance.forwardCount;
}

std::optional<WebKit::WebBackForwardListCounts> ArgumentCoder<WebKit::WebBackForwardListCounts>::decode(Decoder& decoder)
{
    auto backCount = decoder.decode<uint32_t>();
    auto forwardCount = decoder.decode<uint32_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebBackForwardListCounts {
            WTFMove(*backCount),
            WTFMove(*forwardCount)
        }
    };
}

#if ENABLE(CONTEXT_MENUS)
void ArgumentCoder<WebKit::WebContextMenuItemData>::encode(Encoder& encoder, const WebKit::WebContextMenuItemData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebCore::ContextMenuItemType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.action())>, WebCore::ContextMenuAction>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.title())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.enabled())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.checked())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.indentationLevel())>, unsigned>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.submenu())>, Vector<WebKit::WebContextMenuItemData>>);

    encoder << instance.type();
    encoder << instance.action();
    encoder << instance.title();
    encoder << instance.enabled();
    encoder << instance.checked();
    encoder << instance.indentationLevel();
    encoder << instance.submenu();
}

std::optional<WebKit::WebContextMenuItemData> ArgumentCoder<WebKit::WebContextMenuItemData>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::ContextMenuItemType>();
    auto action = decoder.decode<WebCore::ContextMenuAction>();
    auto title = decoder.decode<String>();
    auto enabled = decoder.decode<bool>();
    auto checked = decoder.decode<bool>();
    auto indentationLevel = decoder.decode<unsigned>();
    auto submenu = decoder.decode<Vector<WebKit::WebContextMenuItemData>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebContextMenuItemData {
            WTFMove(*type),
            WTFMove(*action),
            WTFMove(*title),
            WTFMove(*enabled),
            WTFMove(*checked),
            WTFMove(*indentationLevel),
            WTFMove(*submenu)
        }
    };
}

#endif

void ArgumentCoder<WebCore::DOMCacheEngine::CacheInfo>::encode(Encoder& encoder, const WebCore::DOMCacheEngine::CacheInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, WebCore::DOMCacheIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, String>);
    struct ShouldBeSameSizeAsCacheInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::DOMCacheEngine::CacheInfo>, false> {
        WebCore::DOMCacheIdentifier identifier;
        String name;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCacheInfo) == sizeof(WebCore::DOMCacheEngine::CacheInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::DOMCacheEngine::CacheInfo, identifier)
        , offsetof(WebCore::DOMCacheEngine::CacheInfo, name)
    >::value);

    encoder << instance.identifier;
    encoder << instance.name;
}

std::optional<WebCore::DOMCacheEngine::CacheInfo> ArgumentCoder<WebCore::DOMCacheEngine::CacheInfo>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<WebCore::DOMCacheIdentifier>();
    auto name = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DOMCacheEngine::CacheInfo {
            WTFMove(*identifier),
            WTFMove(*name)
        }
    };
}

void ArgumentCoder<WebCore::DOMCacheEngine::CacheInfos>::encode(Encoder& encoder, const WebCore::DOMCacheEngine::CacheInfos& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.infos)>, Vector<WebCore::DOMCacheEngine::CacheInfo>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.updateCounter)>, uint64_t>);
    struct ShouldBeSameSizeAsCacheInfos : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::DOMCacheEngine::CacheInfos>, false> {
        Vector<WebCore::DOMCacheEngine::CacheInfo> infos;
        uint64_t updateCounter;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCacheInfos) == sizeof(WebCore::DOMCacheEngine::CacheInfos));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::DOMCacheEngine::CacheInfos, infos)
        , offsetof(WebCore::DOMCacheEngine::CacheInfos, updateCounter)
    >::value);

    encoder << instance.infos;
    encoder << instance.updateCounter;
}

std::optional<WebCore::DOMCacheEngine::CacheInfos> ArgumentCoder<WebCore::DOMCacheEngine::CacheInfos>::decode(Decoder& decoder)
{
    auto infos = decoder.decode<Vector<WebCore::DOMCacheEngine::CacheInfo>>();
    auto updateCounter = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DOMCacheEngine::CacheInfos {
            WTFMove(*infos),
            WTFMove(*updateCounter)
        }
    };
}

void ArgumentCoder<WebCore::DOMCacheEngine::CacheIdentifierOperationResult>::encode(Encoder& encoder, const WebCore::DOMCacheEngine::CacheIdentifierOperationResult& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, WebCore::DOMCacheIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hadStorageError)>, bool>);
    struct ShouldBeSameSizeAsCacheIdentifierOperationResult : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::DOMCacheEngine::CacheIdentifierOperationResult>, false> {
        WebCore::DOMCacheIdentifier identifier;
        bool hadStorageError;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCacheIdentifierOperationResult) == sizeof(WebCore::DOMCacheEngine::CacheIdentifierOperationResult));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::DOMCacheEngine::CacheIdentifierOperationResult, identifier)
        , offsetof(WebCore::DOMCacheEngine::CacheIdentifierOperationResult, hadStorageError)
    >::value);

    encoder << instance.identifier;
    encoder << instance.hadStorageError;
}

std::optional<WebCore::DOMCacheEngine::CacheIdentifierOperationResult> ArgumentCoder<WebCore::DOMCacheEngine::CacheIdentifierOperationResult>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<WebCore::DOMCacheIdentifier>();
    auto hadStorageError = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DOMCacheEngine::CacheIdentifierOperationResult {
            WTFMove(*identifier),
            WTFMove(*hadStorageError)
        }
    };
}

#if HAVE(TRANSLATION_UI_SERVICES) && ENABLE(CONTEXT_MENUS)
void ArgumentCoder<WebCore::TranslationContextMenuInfo>::encode(Encoder& encoder, const WebCore::TranslationContextMenuInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.text)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selectionBoundsInRootView)>, WebCore::IntRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.locationInRootView)>, WebCore::IntPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mode)>, WebCore::TranslationContextMenuMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.source)>, WebCore::TranslationContextMenuSource>);
    struct ShouldBeSameSizeAsTranslationContextMenuInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::TranslationContextMenuInfo>, false> {
        String text;
        WebCore::IntRect selectionBoundsInRootView;
        WebCore::IntPoint locationInRootView;
        WebCore::TranslationContextMenuMode mode;
        WebCore::TranslationContextMenuSource source;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTranslationContextMenuInfo) == sizeof(WebCore::TranslationContextMenuInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::TranslationContextMenuInfo, text)
        , offsetof(WebCore::TranslationContextMenuInfo, selectionBoundsInRootView)
        , offsetof(WebCore::TranslationContextMenuInfo, locationInRootView)
        , offsetof(WebCore::TranslationContextMenuInfo, mode)
        , offsetof(WebCore::TranslationContextMenuInfo, source)
    >::value);

    encoder << instance.text;
    encoder << instance.selectionBoundsInRootView;
    encoder << instance.locationInRootView;
    encoder << instance.mode;
    encoder << instance.source;
}

std::optional<WebCore::TranslationContextMenuInfo> ArgumentCoder<WebCore::TranslationContextMenuInfo>::decode(Decoder& decoder)
{
    auto text = decoder.decode<String>();
    auto selectionBoundsInRootView = decoder.decode<WebCore::IntRect>();
    auto locationInRootView = decoder.decode<WebCore::IntPoint>();
    auto mode = decoder.decode<WebCore::TranslationContextMenuMode>();
    auto source = decoder.decode<WebCore::TranslationContextMenuSource>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TranslationContextMenuInfo {
            WTFMove(*text),
            WTFMove(*selectionBoundsInRootView),
            WTFMove(*locationInRootView),
            WTFMove(*mode),
            WTFMove(*source)
        }
    };
}

#endif

#if USE(APPKIT)
void ArgumentCoder<WebCore::AppKitControlSystemImage>::encode(Encoder& encoder, const WebCore::AppKitControlSystemImage& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_controlType)>, WebCore::AppKitControlSystemImageType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_tintColor)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_useDarkAppearance)>, bool>);
    struct ShouldBeSameSizeAsAppKitControlSystemImage : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::AppKitControlSystemImage>, true> {
        WebCore::AppKitControlSystemImageType m_controlType;
        WebCore::Color m_tintColor;
        bool m_useDarkAppearance;
    };
    static_assert(sizeof(ShouldBeSameSizeAsAppKitControlSystemImage) == sizeof(WebCore::AppKitControlSystemImage));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::AppKitControlSystemImage, m_controlType)
        , offsetof(WebCore::AppKitControlSystemImage, m_tintColor)
        , offsetof(WebCore::AppKitControlSystemImage, m_useDarkAppearance)
    >::value);

    encoder << instance.m_tintColor;
    encoder << instance.m_useDarkAppearance;
}

void ArgumentCoder<WebCore::AppKitControlSystemImage>::encode(StreamConnectionEncoder& encoder, const WebCore::AppKitControlSystemImage& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_controlType)>, WebCore::AppKitControlSystemImageType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_tintColor)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_useDarkAppearance)>, bool>);
    struct ShouldBeSameSizeAsAppKitControlSystemImage : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::AppKitControlSystemImage>, true> {
        WebCore::AppKitControlSystemImageType m_controlType;
        WebCore::Color m_tintColor;
        bool m_useDarkAppearance;
    };
    static_assert(sizeof(ShouldBeSameSizeAsAppKitControlSystemImage) == sizeof(WebCore::AppKitControlSystemImage));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::AppKitControlSystemImage, m_controlType)
        , offsetof(WebCore::AppKitControlSystemImage, m_tintColor)
        , offsetof(WebCore::AppKitControlSystemImage, m_useDarkAppearance)
    >::value);

    encoder << instance.m_tintColor;
    encoder << instance.m_useDarkAppearance;
}

std::optional<Ref<WebCore::AppKitControlSystemImage>> ArgumentCoder<WebCore::AppKitControlSystemImage>::decode(Decoder& decoder)
{
    auto m_tintColor = decoder.decode<WebCore::Color>();
    auto m_useDarkAppearance = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ScrollbarTrackCornerSystemImageMac::create(
            WTFMove(*m_tintColor),
            WTFMove(*m_useDarkAppearance)
        )
    };
}

#endif

void ArgumentCoder<WebCore::Style::ListStyleType>::encode(Encoder& encoder, const WebCore::Style::ListStyleType& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ipcData())>, Variant<WebCore::Style::ListStyleType::NoneData, WebCore::Style::ListStyleType::StringData, WebCore::Style::ListStyleType::CounterStyleData>>);

    encoder << instance.ipcData();
}

std::optional<WebCore::Style::ListStyleType> ArgumentCoder<WebCore::Style::ListStyleType>::decode(Decoder& decoder)
{
    auto ipcData = decoder.decode<Variant<WebCore::Style::ListStyleType::NoneData, WebCore::Style::ListStyleType::StringData, WebCore::Style::ListStyleType::CounterStyleData>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::ListStyleType {
            WTFMove(*ipcData)
        }
    };
}

void ArgumentCoder<WebCore::Style::ListStyleType::NoneData>::encode(Encoder& encoder, const WebCore::Style::ListStyleType::NoneData& instance)
{
    struct ShouldBeSameSizeAsNoneData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::ListStyleType::NoneData>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsNoneData) == sizeof(WebCore::Style::ListStyleType::NoneData));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::Style::ListStyleType::NoneData> ArgumentCoder<WebCore::Style::ListStyleType::NoneData>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::ListStyleType::NoneData {
        }
    };
}

void ArgumentCoder<WebCore::Style::ListStyleType::StringData>::encode(Encoder& encoder, const WebCore::Style::ListStyleType::StringData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, AtomString>);
    struct ShouldBeSameSizeAsStringData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::ListStyleType::StringData>, false> {
        AtomString identifier;
    };
    static_assert(sizeof(ShouldBeSameSizeAsStringData) == sizeof(WebCore::Style::ListStyleType::StringData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::ListStyleType::StringData, identifier)
    >::value);

    encoder << instance.identifier;
}

std::optional<WebCore::Style::ListStyleType::StringData> ArgumentCoder<WebCore::Style::ListStyleType::StringData>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<AtomString>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::ListStyleType::StringData {
            WTFMove(*identifier)
        }
    };
}

void ArgumentCoder<WebCore::Style::ListStyleType::CounterStyleData>::encode(Encoder& encoder, const WebCore::Style::ListStyleType::CounterStyleData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, AtomString>);
    struct ShouldBeSameSizeAsCounterStyleData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::ListStyleType::CounterStyleData>, false> {
        AtomString identifier;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCounterStyleData) == sizeof(WebCore::Style::ListStyleType::CounterStyleData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::ListStyleType::CounterStyleData, identifier)
    >::value);

    encoder << instance.identifier;
}

std::optional<WebCore::Style::ListStyleType::CounterStyleData> ArgumentCoder<WebCore::Style::ListStyleType::CounterStyleData>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<AtomString>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::ListStyleType::CounterStyleData {
            WTFMove(*identifier)
        }
    };
}

void ArgumentCoder<WebCore::DOMCacheEngine::CrossThreadRecord>::encode(Encoder& encoder, const WebCore::DOMCacheEngine::CrossThreadRecord& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.updateResponseCounter)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requestHeadersGuard)>, WebCore::FetchHeadersGuard>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.request)>, WebCore::ResourceRequest>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.options)>, WebCore::FetchOptions>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.referrer)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.responseHeadersGuard)>, WebCore::FetchHeadersGuard>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.response)>, WebCore::ResourceResponseData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.responseBody)>, Variant<std::nullptr_t, Ref<WebCore::FormData>, Ref<WebCore::SharedBuffer>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.responseBodySize)>, uint64_t>);
    struct ShouldBeSameSizeAsCrossThreadRecord : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::DOMCacheEngine::CrossThreadRecord>, false> {
        uint64_t identifier;
        uint64_t updateResponseCounter;
        WebCore::FetchHeadersGuard requestHeadersGuard;
        WebCore::ResourceRequest request;
        WebCore::FetchOptions options;
        String referrer;
        WebCore::FetchHeadersGuard responseHeadersGuard;
        WebCore::ResourceResponseData response;
        Variant<std::nullptr_t, Ref<WebCore::FormData>, Ref<WebCore::SharedBuffer>> responseBody;
        uint64_t responseBodySize;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCrossThreadRecord) == sizeof(WebCore::DOMCacheEngine::CrossThreadRecord));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::DOMCacheEngine::CrossThreadRecord, identifier)
        , offsetof(WebCore::DOMCacheEngine::CrossThreadRecord, updateResponseCounter)
        , offsetof(WebCore::DOMCacheEngine::CrossThreadRecord, requestHeadersGuard)
        , offsetof(WebCore::DOMCacheEngine::CrossThreadRecord, request)
        , offsetof(WebCore::DOMCacheEngine::CrossThreadRecord, options)
        , offsetof(WebCore::DOMCacheEngine::CrossThreadRecord, referrer)
        , offsetof(WebCore::DOMCacheEngine::CrossThreadRecord, responseHeadersGuard)
        , offsetof(WebCore::DOMCacheEngine::CrossThreadRecord, response)
        , offsetof(WebCore::DOMCacheEngine::CrossThreadRecord, responseBody)
        , offsetof(WebCore::DOMCacheEngine::CrossThreadRecord, responseBodySize)
    >::value);

    encoder << instance.identifier;
    encoder << instance.updateResponseCounter;
    encoder << instance.requestHeadersGuard;
    encoder << instance.request;
    encoder << instance.options;
    encoder << instance.referrer;
    encoder << instance.responseHeadersGuard;
    encoder << instance.response;
    encoder << instance.responseBody;
    encoder << instance.responseBodySize;
}

std::optional<WebCore::DOMCacheEngine::CrossThreadRecord> ArgumentCoder<WebCore::DOMCacheEngine::CrossThreadRecord>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<uint64_t>();
    auto updateResponseCounter = decoder.decode<uint64_t>();
    auto requestHeadersGuard = decoder.decode<WebCore::FetchHeadersGuard>();
    auto request = decoder.decode<WebCore::ResourceRequest>();
    auto options = decoder.decode<WebCore::FetchOptions>();
    auto referrer = decoder.decode<String>();
    auto responseHeadersGuard = decoder.decode<WebCore::FetchHeadersGuard>();
    auto response = decoder.decode<WebCore::ResourceResponseData>();
    auto responseBody = decoder.decode<Variant<std::nullptr_t, Ref<WebCore::FormData>, Ref<WebCore::SharedBuffer>>>();
    auto responseBodySize = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DOMCacheEngine::CrossThreadRecord {
            WTFMove(*identifier),
            WTFMove(*updateResponseCounter),
            WTFMove(*requestHeadersGuard),
            WTFMove(*request),
            WTFMove(*options),
            WTFMove(*referrer),
            WTFMove(*responseHeadersGuard),
            WTFMove(*response),
            WTFMove(*responseBody),
            WTFMove(*responseBodySize)
        }
    };
}

void ArgumentCoder<WebCore::TransformationMatrix>::encode(Encoder& encoder, const WebCore::TransformationMatrix& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m11())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m12())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m13())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m14())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m21())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m22())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m23())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m24())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m31())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m32())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m33())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m34())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m41())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m42())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m43())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m44())>, double>);

    encoder << instance.m11();
    encoder << instance.m12();
    encoder << instance.m13();
    encoder << instance.m14();
    encoder << instance.m21();
    encoder << instance.m22();
    encoder << instance.m23();
    encoder << instance.m24();
    encoder << instance.m31();
    encoder << instance.m32();
    encoder << instance.m33();
    encoder << instance.m34();
    encoder << instance.m41();
    encoder << instance.m42();
    encoder << instance.m43();
    encoder << instance.m44();
}

void ArgumentCoder<WebCore::TransformationMatrix>::encode(StreamConnectionEncoder& encoder, const WebCore::TransformationMatrix& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m11())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m12())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m13())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m14())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m21())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m22())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m23())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m24())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m31())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m32())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m33())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m34())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m41())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m42())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m43())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m44())>, double>);

    encoder << instance.m11();
    encoder << instance.m12();
    encoder << instance.m13();
    encoder << instance.m14();
    encoder << instance.m21();
    encoder << instance.m22();
    encoder << instance.m23();
    encoder << instance.m24();
    encoder << instance.m31();
    encoder << instance.m32();
    encoder << instance.m33();
    encoder << instance.m34();
    encoder << instance.m41();
    encoder << instance.m42();
    encoder << instance.m43();
    encoder << instance.m44();
}

std::optional<WebCore::TransformationMatrix> ArgumentCoder<WebCore::TransformationMatrix>::decode(Decoder& decoder)
{
    auto m11 = decoder.decode<double>();
    auto m12 = decoder.decode<double>();
    auto m13 = decoder.decode<double>();
    auto m14 = decoder.decode<double>();
    auto m21 = decoder.decode<double>();
    auto m22 = decoder.decode<double>();
    auto m23 = decoder.decode<double>();
    auto m24 = decoder.decode<double>();
    auto m31 = decoder.decode<double>();
    auto m32 = decoder.decode<double>();
    auto m33 = decoder.decode<double>();
    auto m34 = decoder.decode<double>();
    auto m41 = decoder.decode<double>();
    auto m42 = decoder.decode<double>();
    auto m43 = decoder.decode<double>();
    auto m44 = decoder.decode<double>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TransformationMatrix {
            WTFMove(*m11),
            WTFMove(*m12),
            WTFMove(*m13),
            WTFMove(*m14),
            WTFMove(*m21),
            WTFMove(*m22),
            WTFMove(*m23),
            WTFMove(*m24),
            WTFMove(*m31),
            WTFMove(*m32),
            WTFMove(*m33),
            WTFMove(*m34),
            WTFMove(*m41),
            WTFMove(*m42),
            WTFMove(*m43),
            WTFMove(*m44)
        }
    };
}

void ArgumentCoder<WebCore::CacheQueryOptions>::encode(Encoder& encoder, const WebCore::CacheQueryOptions& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ignoreSearch)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ignoreMethod)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ignoreVary)>, bool>);
    struct ShouldBeSameSizeAsCacheQueryOptions : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::CacheQueryOptions>, false> {
        bool ignoreSearch;
        bool ignoreMethod;
        bool ignoreVary;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCacheQueryOptions) == sizeof(WebCore::CacheQueryOptions));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::CacheQueryOptions, ignoreSearch)
        , offsetof(WebCore::CacheQueryOptions, ignoreMethod)
        , offsetof(WebCore::CacheQueryOptions, ignoreVary)
    >::value);

    encoder << instance.ignoreSearch;
    encoder << instance.ignoreMethod;
    encoder << instance.ignoreVary;
}

std::optional<WebCore::CacheQueryOptions> ArgumentCoder<WebCore::CacheQueryOptions>::decode(Decoder& decoder)
{
    auto ignoreSearch = decoder.decode<bool>();
    auto ignoreMethod = decoder.decode<bool>();
    auto ignoreVary = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CacheQueryOptions {
            WTFMove(*ignoreSearch),
            WTFMove(*ignoreMethod),
            WTFMove(*ignoreVary)
        }
    };
}

void ArgumentCoder<WebCore::CharacterRange>::encode(Encoder& encoder, const WebCore::CharacterRange& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.location)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.length)>, uint64_t>);
    struct ShouldBeSameSizeAsCharacterRange : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::CharacterRange>, false> {
        uint64_t location;
        uint64_t length;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCharacterRange) == sizeof(WebCore::CharacterRange));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::CharacterRange, location)
        , offsetof(WebCore::CharacterRange, length)
    >::value);

    encoder << instance.location;
    encoder << instance.length;
}

std::optional<WebCore::CharacterRange> ArgumentCoder<WebCore::CharacterRange>::decode(Decoder& decoder)
{
    auto location = decoder.decode<uint64_t>();
    auto length = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(!(CheckedUint64 { *location } + *length).hasOverflowed()))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CharacterRange {
            WTFMove(*location),
            WTFMove(*length)
        }
    };
}

void ArgumentCoder<WebCore::AffineTransform>::encode(Encoder& encoder, const WebCore::AffineTransform& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.span())>, std::span<const double, 6>>);

    encoder << instance.span();
}

void ArgumentCoder<WebCore::AffineTransform>::encode(StreamConnectionEncoder& encoder, const WebCore::AffineTransform& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.span())>, std::span<const double, 6>>);

    encoder << instance.span();
}

std::optional<WebCore::AffineTransform> ArgumentCoder<WebCore::AffineTransform>::decode(Decoder& decoder)
{
    auto span = decoder.decode<std::span<const double, 6>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::AffineTransform {
            WTFMove(*span)
        }
    };
}

void ArgumentCoder<WebCore::FloatPoint>::encode(Encoder& encoder, const WebCore::FloatPoint& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.x())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.y())>, float>);

    encoder << instance.x();
    encoder << instance.y();
}

void ArgumentCoder<WebCore::FloatPoint>::encode(StreamConnectionEncoder& encoder, const WebCore::FloatPoint& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.x())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.y())>, float>);

    encoder << instance.x();
    encoder << instance.y();
}

std::optional<WebCore::FloatPoint> ArgumentCoder<WebCore::FloatPoint>::decode(Decoder& decoder)
{
    auto x = decoder.decode<float>();
    auto y = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FloatPoint {
            WTFMove(*x),
            WTFMove(*y)
        }
    };
}

void ArgumentCoder<WebCore::FloatPoint3D>::encode(Encoder& encoder, const WebCore::FloatPoint3D& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.x())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.y())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.z())>, float>);

    encoder << instance.x();
    encoder << instance.y();
    encoder << instance.z();
}

void ArgumentCoder<WebCore::FloatPoint3D>::encode(StreamConnectionEncoder& encoder, const WebCore::FloatPoint3D& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.x())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.y())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.z())>, float>);

    encoder << instance.x();
    encoder << instance.y();
    encoder << instance.z();
}

std::optional<WebCore::FloatPoint3D> ArgumentCoder<WebCore::FloatPoint3D>::decode(Decoder& decoder)
{
    auto x = decoder.decode<float>();
    auto y = decoder.decode<float>();
    auto z = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FloatPoint3D {
            WTFMove(*x),
            WTFMove(*y),
            WTFMove(*z)
        }
    };
}

void ArgumentCoder<WebCore::FloatQuad>::encode(Encoder& encoder, const WebCore::FloatQuad& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.p1())>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.p2())>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.p3())>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.p4())>, WebCore::FloatPoint>);

    encoder << instance.p1();
    encoder << instance.p2();
    encoder << instance.p3();
    encoder << instance.p4();
}

std::optional<WebCore::FloatQuad> ArgumentCoder<WebCore::FloatQuad>::decode(Decoder& decoder)
{
    auto p1 = decoder.decode<WebCore::FloatPoint>();
    auto p2 = decoder.decode<WebCore::FloatPoint>();
    auto p3 = decoder.decode<WebCore::FloatPoint>();
    auto p4 = decoder.decode<WebCore::FloatPoint>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FloatQuad {
            WTFMove(*p1),
            WTFMove(*p2),
            WTFMove(*p3),
            WTFMove(*p4)
        }
    };
}

void ArgumentCoder<WebCore::IDBCursorRecord>::encode(Encoder& encoder, const WebCore::IDBCursorRecord& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.key)>, WebCore::IDBKeyData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.primaryKey)>, WebCore::IDBKeyData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, WebCore::IDBValue>);
    struct ShouldBeSameSizeAsIDBCursorRecord : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::IDBCursorRecord>, false> {
        WebCore::IDBKeyData key;
        WebCore::IDBKeyData primaryKey;
        WebCore::IDBValue value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsIDBCursorRecord) == sizeof(WebCore::IDBCursorRecord));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::IDBCursorRecord, key)
        , offsetof(WebCore::IDBCursorRecord, primaryKey)
        , offsetof(WebCore::IDBCursorRecord, value)
    >::value);

    encoder << instance.key;
    encoder << instance.primaryKey;
    encoder << instance.value;
}

std::optional<WebCore::IDBCursorRecord> ArgumentCoder<WebCore::IDBCursorRecord>::decode(Decoder& decoder)
{
    auto key = decoder.decode<WebCore::IDBKeyData>();
    auto primaryKey = decoder.decode<WebCore::IDBKeyData>();
    auto value = decoder.decode<WebCore::IDBValue>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::IDBCursorRecord {
            WTFMove(*key),
            WTFMove(*primaryKey),
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebCore::IDBCursorInfo>::encode(Encoder& encoder, const WebCore::IDBCursorInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier())>, WebCore::IDBResourceIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.transactionIdentifier())>, WebCore::IDBResourceIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.objectStoreIdentifier())>, WebCore::IDBObjectStoreIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceIdentifier())>, Variant<WebCore::IDBObjectStoreIdentifier, WebCore::IDBIndexIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.range())>, WebCore::IDBKeyRangeData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cursorSource())>, WebCore::IndexedDB::CursorSource>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cursorDirection())>, WebCore::IndexedDB::CursorDirection>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cursorType())>, WebCore::IndexedDB::CursorType>);

    encoder << instance.identifier();
    encoder << instance.transactionIdentifier();
    encoder << instance.objectStoreIdentifier();
    encoder << instance.sourceIdentifier();
    encoder << instance.range();
    encoder << instance.cursorSource();
    encoder << instance.cursorDirection();
    encoder << instance.cursorType();
}

std::optional<WebCore::IDBCursorInfo> ArgumentCoder<WebCore::IDBCursorInfo>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<WebCore::IDBResourceIdentifier>();
    auto transactionIdentifier = decoder.decode<WebCore::IDBResourceIdentifier>();
    auto objectStoreIdentifier = decoder.decode<WebCore::IDBObjectStoreIdentifier>();
    auto sourceIdentifier = decoder.decode<Variant<WebCore::IDBObjectStoreIdentifier, WebCore::IDBIndexIdentifier>>();
    auto range = decoder.decode<WebCore::IDBKeyRangeData>();
    auto cursorSource = decoder.decode<WebCore::IndexedDB::CursorSource>();
    auto cursorDirection = decoder.decode<WebCore::IndexedDB::CursorDirection>();
    auto cursorType = decoder.decode<WebCore::IndexedDB::CursorType>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::IDBCursorInfo {
            WTFMove(*identifier),
            WTFMove(*transactionIdentifier),
            WTFMove(*objectStoreIdentifier),
            WTFMove(*sourceIdentifier),
            WTFMove(*range),
            WTFMove(*cursorSource),
            WTFMove(*cursorDirection),
            WTFMove(*cursorType)
        }
    };
}

void ArgumentCoder<WebCore::IDBError>::encode(Encoder& encoder, const WebCore::IDBError& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.code())>, std::optional<WebCore::ExceptionCode>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.messageForSerialization())>, String>);

    encoder << instance.code();
    encoder << instance.messageForSerialization();
}

std::optional<WebCore::IDBError> ArgumentCoder<WebCore::IDBError>::decode(Decoder& decoder)
{
    auto code = decoder.decode<std::optional<WebCore::ExceptionCode>>();
    auto messageForSerialization = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::IDBError {
            WTFMove(*code),
            WTFMove(*messageForSerialization)
        }
    };
}

void ArgumentCoder<WebCore::IDBGetAllRecordsData>::encode(Encoder& encoder, const WebCore::IDBGetAllRecordsData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.keyRangeData)>, WebCore::IDBKeyRangeData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.getAllType)>, WebCore::IndexedDB::GetAllType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.count)>, std::optional<uint32_t>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.objectStoreIdentifier)>, WebCore::IDBObjectStoreIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.indexIdentifier)>, std::optional<WebCore::IDBIndexIdentifier>>);
    struct ShouldBeSameSizeAsIDBGetAllRecordsData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::IDBGetAllRecordsData>, false> {
        WebCore::IDBKeyRangeData keyRangeData;
        WebCore::IndexedDB::GetAllType getAllType;
        std::optional<uint32_t> count;
        WebCore::IDBObjectStoreIdentifier objectStoreIdentifier;
        std::optional<WebCore::IDBIndexIdentifier> indexIdentifier;
    };
    static_assert(sizeof(ShouldBeSameSizeAsIDBGetAllRecordsData) == sizeof(WebCore::IDBGetAllRecordsData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::IDBGetAllRecordsData, keyRangeData)
        , offsetof(WebCore::IDBGetAllRecordsData, getAllType)
        , offsetof(WebCore::IDBGetAllRecordsData, count)
        , offsetof(WebCore::IDBGetAllRecordsData, objectStoreIdentifier)
        , offsetof(WebCore::IDBGetAllRecordsData, indexIdentifier)
    >::value);

    encoder << instance.keyRangeData;
    encoder << instance.getAllType;
    encoder << instance.count;
    encoder << instance.objectStoreIdentifier;
    encoder << instance.indexIdentifier;
}

std::optional<WebCore::IDBGetAllRecordsData> ArgumentCoder<WebCore::IDBGetAllRecordsData>::decode(Decoder& decoder)
{
    auto keyRangeData = decoder.decode<WebCore::IDBKeyRangeData>();
    auto getAllType = decoder.decode<WebCore::IndexedDB::GetAllType>();
    auto count = decoder.decode<std::optional<uint32_t>>();
    auto objectStoreIdentifier = decoder.decode<WebCore::IDBObjectStoreIdentifier>();
    auto indexIdentifier = decoder.decode<std::optional<WebCore::IDBIndexIdentifier>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::IDBGetAllRecordsData {
            WTFMove(*keyRangeData),
            WTFMove(*getAllType),
            WTFMove(*count),
            WTFMove(*objectStoreIdentifier),
            WTFMove(*indexIdentifier)
        }
    };
}

void ArgumentCoder<WebCore::IDBGetResult>::encode(Encoder& encoder, const WebCore::IDBGetResult& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.keyData())>, WebCore::IDBKeyData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.primaryKeyData())>, WebCore::IDBKeyData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value())>, WebCore::IDBValue>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.keyPath())>, std::optional<WebCore::IDBKeyPath>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.prefetchedRecords())>, Vector<WebCore::IDBCursorRecord>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isDefined())>, bool>);

    encoder << instance.keyData();
    encoder << instance.primaryKeyData();
    encoder << instance.value();
    encoder << instance.keyPath();
    encoder << instance.prefetchedRecords();
    encoder << instance.isDefined();
}

std::optional<WebCore::IDBGetResult> ArgumentCoder<WebCore::IDBGetResult>::decode(Decoder& decoder)
{
    auto keyData = decoder.decode<WebCore::IDBKeyData>();
    auto primaryKeyData = decoder.decode<WebCore::IDBKeyData>();
    auto value = decoder.decode<WebCore::IDBValue>();
    auto keyPath = decoder.decode<std::optional<WebCore::IDBKeyPath>>();
    auto prefetchedRecords = decoder.decode<Vector<WebCore::IDBCursorRecord>>();
    auto isDefined = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::IDBGetResult {
            WTFMove(*keyData),
            WTFMove(*primaryKeyData),
            WTFMove(*value),
            WTFMove(*keyPath),
            WTFMove(*prefetchedRecords),
            WTFMove(*isDefined)
        }
    };
}

void ArgumentCoder<WebCore::IDBGetAllResult>::encode(Encoder& encoder, const WebCore::IDBGetAllResult& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebCore::IndexedDB::GetAllType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.keys())>, Vector<WebCore::IDBKeyData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.values())>, Vector<WebCore::IDBValue>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.keyPath())>, std::optional<WebCore::IDBKeyPath>>);

    encoder << instance.type();
    encoder << instance.keys();
    encoder << instance.values();
    encoder << instance.keyPath();
}

std::optional<WebCore::IDBGetAllResult> ArgumentCoder<WebCore::IDBGetAllResult>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::IndexedDB::GetAllType>();
    auto keys = decoder.decode<Vector<WebCore::IDBKeyData>>();
    auto values = decoder.decode<Vector<WebCore::IDBValue>>();
    auto keyPath = decoder.decode<std::optional<WebCore::IDBKeyPath>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::IDBGetAllResult {
            WTFMove(*type),
            WTFMove(*keys),
            WTFMove(*values),
            WTFMove(*keyPath)
        }
    };
}

void ArgumentCoder<WebCore::IDBDatabaseInfo>::encode(Encoder& encoder, const WebCore::IDBDatabaseInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_name)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_version)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_maxIndexID)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_objectStoreMap)>, HashMap<WebCore::IDBObjectStoreIdentifier, WebCore::IDBObjectStoreInfo>>);
    struct ShouldBeSameSizeAsIDBDatabaseInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::IDBDatabaseInfo>, false> {
        String m_name;
        uint64_t m_version;
        uint64_t m_maxIndexID;
        HashMap<WebCore::IDBObjectStoreIdentifier, WebCore::IDBObjectStoreInfo> m_objectStoreMap;
    };
    static_assert(sizeof(ShouldBeSameSizeAsIDBDatabaseInfo) == sizeof(WebCore::IDBDatabaseInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::IDBDatabaseInfo, m_name)
        , offsetof(WebCore::IDBDatabaseInfo, m_version)
        , offsetof(WebCore::IDBDatabaseInfo, m_maxIndexID)
        , offsetof(WebCore::IDBDatabaseInfo, m_objectStoreMap)
    >::value);

    encoder << instance.m_name;
    encoder << instance.m_version;
    encoder << instance.m_maxIndexID;
    encoder << instance.m_objectStoreMap;
}

std::optional<WebCore::IDBDatabaseInfo> ArgumentCoder<WebCore::IDBDatabaseInfo>::decode(Decoder& decoder)
{
    auto m_name = decoder.decode<String>();
    auto m_version = decoder.decode<uint64_t>();
    auto m_maxIndexID = decoder.decode<uint64_t>();
    auto m_objectStoreMap = decoder.decode<HashMap<WebCore::IDBObjectStoreIdentifier, WebCore::IDBObjectStoreInfo>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::IDBDatabaseInfo {
            WTFMove(*m_name),
            WTFMove(*m_version),
            WTFMove(*m_maxIndexID),
            WTFMove(*m_objectStoreMap)
        }
    };
}

void ArgumentCoder<WebCore::IDBKeyRangeData>::encode(Encoder& encoder, const WebCore::IDBKeyRangeData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lowerKey)>, WebCore::IDBKeyData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.upperKey)>, WebCore::IDBKeyData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lowerOpen)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.upperOpen)>, bool>);
    struct ShouldBeSameSizeAsIDBKeyRangeData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::IDBKeyRangeData>, false> {
        WebCore::IDBKeyData lowerKey;
        WebCore::IDBKeyData upperKey;
        bool lowerOpen;
        bool upperOpen;
    };
    static_assert(sizeof(ShouldBeSameSizeAsIDBKeyRangeData) == sizeof(WebCore::IDBKeyRangeData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::IDBKeyRangeData, lowerKey)
        , offsetof(WebCore::IDBKeyRangeData, upperKey)
        , offsetof(WebCore::IDBKeyRangeData, lowerOpen)
        , offsetof(WebCore::IDBKeyRangeData, upperOpen)
    >::value);

    encoder << instance.lowerKey;
    encoder << instance.upperKey;
    encoder << instance.lowerOpen;
    encoder << instance.upperOpen;
}

std::optional<WebCore::IDBKeyRangeData> ArgumentCoder<WebCore::IDBKeyRangeData>::decode(Decoder& decoder)
{
    auto lowerKey = decoder.decode<WebCore::IDBKeyData>();
    auto upperKey = decoder.decode<WebCore::IDBKeyData>();
    auto lowerOpen = decoder.decode<bool>();
    auto upperOpen = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::IDBKeyRangeData {
            WTFMove(*lowerKey),
            WTFMove(*upperKey),
            WTFMove(*lowerOpen),
            WTFMove(*upperOpen)
        }
    };
}

void ArgumentCoder<WebCore::IDBTransactionInfo>::encode(Encoder& encoder, const WebCore::IDBTransactionInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier())>, WebCore::IDBResourceIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mode())>, WebCore::IDBTransactionMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.durability())>, WebCore::IDBTransactionDurability>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newVersion())>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.objectStores())>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.originalDatabaseInfo())>, std::unique_ptr<WebCore::IDBDatabaseInfo>>);

    encoder << instance.identifier();
    encoder << instance.mode();
    encoder << instance.durability();
    encoder << instance.newVersion();
    encoder << instance.objectStores();
    encoder << instance.originalDatabaseInfo();
}

std::optional<WebCore::IDBTransactionInfo> ArgumentCoder<WebCore::IDBTransactionInfo>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<WebCore::IDBResourceIdentifier>();
    auto mode = decoder.decode<WebCore::IDBTransactionMode>();
    auto durability = decoder.decode<WebCore::IDBTransactionDurability>();
    auto newVersion = decoder.decode<uint64_t>();
    auto objectStores = decoder.decode<Vector<String>>();
    auto originalDatabaseInfo = decoder.decode<std::unique_ptr<WebCore::IDBDatabaseInfo>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::IDBTransactionInfo {
            WTFMove(*identifier),
            WTFMove(*mode),
            WTFMove(*durability),
            WTFMove(*newVersion),
            WTFMove(*objectStores),
            WTFMove(*originalDatabaseInfo)
        }
    };
}

void ArgumentCoder<WebCore::IDBGetRecordData>::encode(Encoder& encoder, const WebCore::IDBGetRecordData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.keyRangeData)>, WebCore::IDBKeyRangeData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::IDBGetRecordDataType>);
    struct ShouldBeSameSizeAsIDBGetRecordData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::IDBGetRecordData>, false> {
        WebCore::IDBKeyRangeData keyRangeData;
        WebCore::IDBGetRecordDataType type;
    };
    static_assert(sizeof(ShouldBeSameSizeAsIDBGetRecordData) == sizeof(WebCore::IDBGetRecordData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::IDBGetRecordData, keyRangeData)
        , offsetof(WebCore::IDBGetRecordData, type)
    >::value);

    encoder << instance.keyRangeData;
    encoder << instance.type;
}

std::optional<WebCore::IDBGetRecordData> ArgumentCoder<WebCore::IDBGetRecordData>::decode(Decoder& decoder)
{
    auto keyRangeData = decoder.decode<WebCore::IDBKeyRangeData>();
    auto type = decoder.decode<WebCore::IDBGetRecordDataType>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::IDBGetRecordData {
            WTFMove(*keyRangeData),
            WTFMove(*type)
        }
    };
}

void ArgumentCoder<WebCore::IDBIndexInfo>::encode(Encoder& encoder, const WebCore::IDBIndexInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier())>, WebCore::IDBIndexIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.objectStoreIdentifier())>, WebCore::IDBObjectStoreIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.keyPath())>, WebCore::IDBKeyPath>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.unique())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.multiEntry())>, bool>);

    encoder << instance.identifier();
    encoder << instance.objectStoreIdentifier();
    encoder << instance.name();
    encoder << instance.keyPath();
    encoder << instance.unique();
    encoder << instance.multiEntry();
}

std::optional<WebCore::IDBIndexInfo> ArgumentCoder<WebCore::IDBIndexInfo>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<WebCore::IDBIndexIdentifier>();
    auto objectStoreIdentifier = decoder.decode<WebCore::IDBObjectStoreIdentifier>();
    auto name = decoder.decode<String>();
    auto keyPath = decoder.decode<WebCore::IDBKeyPath>();
    auto unique = decoder.decode<bool>();
    auto multiEntry = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::IDBIndexInfo {
            WTFMove(*identifier),
            WTFMove(*objectStoreIdentifier),
            WTFMove(*name),
            WTFMove(*keyPath),
            WTFMove(*unique),
            WTFMove(*multiEntry)
        }
    };
}

void ArgumentCoder<WebCore::IDBObjectStoreInfo>::encode(Encoder& encoder, const WebCore::IDBObjectStoreInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier())>, WebCore::IDBObjectStoreIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.keyPath())>, std::optional<WebCore::IDBKeyPath>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.autoIncrement())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.indexMap())>, HashMap<WebCore::IDBIndexIdentifier, WebCore::IDBIndexInfo>>);

    encoder << instance.identifier();
    encoder << instance.name();
    encoder << instance.keyPath();
    encoder << instance.autoIncrement();
    encoder << instance.indexMap();
}

std::optional<WebCore::IDBObjectStoreInfo> ArgumentCoder<WebCore::IDBObjectStoreInfo>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<WebCore::IDBObjectStoreIdentifier>();
    auto name = decoder.decode<String>();
    auto keyPath = decoder.decode<std::optional<WebCore::IDBKeyPath>>();
    auto autoIncrement = decoder.decode<bool>();
    auto indexMap = decoder.decode<HashMap<WebCore::IDBIndexIdentifier, WebCore::IDBIndexInfo>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::IDBObjectStoreInfo {
            WTFMove(*identifier),
            WTFMove(*name),
            WTFMove(*keyPath),
            WTFMove(*autoIncrement),
            WTFMove(*indexMap)
        }
    };
}

void ArgumentCoder<WebCore::IDBIterateCursorData>::encode(Encoder& encoder, const WebCore::IDBIterateCursorData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.keyData)>, WebCore::IDBKeyData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.primaryKeyData)>, WebCore::IDBKeyData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.count)>, unsigned>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.option)>, WebCore::IndexedDB::CursorIterateOption>);
    struct ShouldBeSameSizeAsIDBIterateCursorData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::IDBIterateCursorData>, false> {
        WebCore::IDBKeyData keyData;
        WebCore::IDBKeyData primaryKeyData;
        unsigned count;
        WebCore::IndexedDB::CursorIterateOption option;
    };
    static_assert(sizeof(ShouldBeSameSizeAsIDBIterateCursorData) == sizeof(WebCore::IDBIterateCursorData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::IDBIterateCursorData, keyData)
        , offsetof(WebCore::IDBIterateCursorData, primaryKeyData)
        , offsetof(WebCore::IDBIterateCursorData, count)
        , offsetof(WebCore::IDBIterateCursorData, option)
    >::value);

    encoder << instance.keyData;
    encoder << instance.primaryKeyData;
    encoder << instance.count;
    encoder << instance.option;
}

std::optional<WebCore::IDBIterateCursorData> ArgumentCoder<WebCore::IDBIterateCursorData>::decode(Decoder& decoder)
{
    auto keyData = decoder.decode<WebCore::IDBKeyData>();
    auto primaryKeyData = decoder.decode<WebCore::IDBKeyData>();
    auto count = decoder.decode<unsigned>();
    auto option = decoder.decode<WebCore::IndexedDB::CursorIterateOption>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::IDBIterateCursorData {
            WTFMove(*keyData),
            WTFMove(*primaryKeyData),
            WTFMove(*count),
            WTFMove(*option)
        }
    };
}

void ArgumentCoder<WebCore::IDBResourceIdentifier>::encode(Encoder& encoder, const WebCore::IDBResourceIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_idbConnectionIdentifier)>, Markable<WebCore::IDBConnectionIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_resourceNumber)>, Markable<WebCore::IDBResourceObjectIdentifier>>);
    struct ShouldBeSameSizeAsIDBResourceIdentifier : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::IDBResourceIdentifier>, false> {
        Markable<WebCore::IDBConnectionIdentifier> m_idbConnectionIdentifier;
        Markable<WebCore::IDBResourceObjectIdentifier> m_resourceNumber;
    };
    static_assert(sizeof(ShouldBeSameSizeAsIDBResourceIdentifier) == sizeof(WebCore::IDBResourceIdentifier));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::IDBResourceIdentifier, m_idbConnectionIdentifier)
        , offsetof(WebCore::IDBResourceIdentifier, m_resourceNumber)
    >::value);

    encoder << instance.m_idbConnectionIdentifier;
    encoder << instance.m_resourceNumber;
}

std::optional<WebCore::IDBResourceIdentifier> ArgumentCoder<WebCore::IDBResourceIdentifier>::decode(Decoder& decoder)
{
    auto m_idbConnectionIdentifier = decoder.decode<Markable<WebCore::IDBConnectionIdentifier>>();
    auto m_resourceNumber = decoder.decode<Markable<WebCore::IDBResourceObjectIdentifier>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::IDBResourceIdentifier {
            WTFMove(*m_idbConnectionIdentifier),
            WTFMove(*m_resourceNumber)
        }
    };
}

void ArgumentCoder<WebCore::IDBValue>::encode(Encoder& encoder, const WebCore::IDBValue& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data())>, WebCore::ThreadSafeDataBuffer>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.blobURLs())>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.blobFilePaths())>, Vector<String>>);

    encoder << instance.data();
    encoder << instance.blobURLs();
    encoder << instance.blobFilePaths();
}

std::optional<WebCore::IDBValue> ArgumentCoder<WebCore::IDBValue>::decode(Decoder& decoder)
{
    auto data = decoder.decode<WebCore::ThreadSafeDataBuffer>();
    auto blobURLs = decoder.decode<Vector<String>>();
    auto blobFilePaths = decoder.decode<Vector<String>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::IDBValue {
            WTFMove(*data),
            WTFMove(*blobURLs),
            WTFMove(*blobFilePaths)
        }
    };
}

void ArgumentCoder<WebCore::IDBOpenRequestData>::encode(Encoder& encoder, const WebCore::IDBOpenRequestData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_serverConnectionIdentifier)>, WebCore::IDBConnectionIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_requestIdentifier)>, WebCore::IDBResourceIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_databaseIdentifier)>, WebCore::IDBDatabaseIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_requestedVersion)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_requestType)>, WebCore::IndexedDB::RequestType>);
    struct ShouldBeSameSizeAsIDBOpenRequestData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::IDBOpenRequestData>, false> {
        WebCore::IDBConnectionIdentifier m_serverConnectionIdentifier;
        WebCore::IDBResourceIdentifier m_requestIdentifier;
        WebCore::IDBDatabaseIdentifier m_databaseIdentifier;
        uint64_t m_requestedVersion;
        WebCore::IndexedDB::RequestType m_requestType;
    };
    static_assert(sizeof(ShouldBeSameSizeAsIDBOpenRequestData) == sizeof(WebCore::IDBOpenRequestData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::IDBOpenRequestData, m_serverConnectionIdentifier)
        , offsetof(WebCore::IDBOpenRequestData, m_requestIdentifier)
        , offsetof(WebCore::IDBOpenRequestData, m_databaseIdentifier)
        , offsetof(WebCore::IDBOpenRequestData, m_requestedVersion)
        , offsetof(WebCore::IDBOpenRequestData, m_requestType)
    >::value);

    encoder << instance.m_serverConnectionIdentifier;
    encoder << instance.m_requestIdentifier;
    encoder << instance.m_databaseIdentifier;
    encoder << instance.m_requestedVersion;
    encoder << instance.m_requestType;
}

std::optional<WebCore::IDBOpenRequestData> ArgumentCoder<WebCore::IDBOpenRequestData>::decode(Decoder& decoder)
{
    auto m_serverConnectionIdentifier = decoder.decode<WebCore::IDBConnectionIdentifier>();
    auto m_requestIdentifier = decoder.decode<WebCore::IDBResourceIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(!m_requestIdentifier->isEmpty()))
        return std::nullopt;
    auto m_databaseIdentifier = decoder.decode<WebCore::IDBDatabaseIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(m_databaseIdentifier->isValid()))
        return std::nullopt;
    auto m_requestedVersion = decoder.decode<uint64_t>();
    auto m_requestType = decoder.decode<WebCore::IndexedDB::RequestType>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::IDBOpenRequestData {
            WTFMove(*m_serverConnectionIdentifier),
            WTFMove(*m_requestIdentifier),
            WTFMove(*m_databaseIdentifier),
            WTFMove(*m_requestedVersion),
            WTFMove(*m_requestType)
        }
    };
}

void ArgumentCoder<WebCore::IDBRequestData>::encode(Encoder& encoder, const WebCore::IDBRequestData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_serverConnectionIdentifier)>, WebCore::IDBConnectionIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_requestIdentifier)>, WebCore::IDBResourceIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_transactionIdentifier)>, WebCore::IDBResourceIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_cursorIdentifier)>, std::optional<WebCore::IDBResourceIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_objectStoreIdentifier)>, Markable<WebCore::IDBObjectStoreIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_indexIdentifier)>, Markable<WebCore::IDBIndexIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_indexRecordType)>, WebCore::IndexedDB::IndexRecordType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_requestedVersion)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_requestType)>, WebCore::IndexedDB::RequestType>);
    struct ShouldBeSameSizeAsIDBRequestData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::IDBRequestData>, false> {
        WebCore::IDBConnectionIdentifier m_serverConnectionIdentifier;
        WebCore::IDBResourceIdentifier m_requestIdentifier;
        WebCore::IDBResourceIdentifier m_transactionIdentifier;
        std::optional<WebCore::IDBResourceIdentifier> m_cursorIdentifier;
        Markable<WebCore::IDBObjectStoreIdentifier> m_objectStoreIdentifier;
        Markable<WebCore::IDBIndexIdentifier> m_indexIdentifier;
        WebCore::IndexedDB::IndexRecordType m_indexRecordType;
        uint64_t m_requestedVersion;
        WebCore::IndexedDB::RequestType m_requestType;
    };
    static_assert(sizeof(ShouldBeSameSizeAsIDBRequestData) == sizeof(WebCore::IDBRequestData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::IDBRequestData, m_serverConnectionIdentifier)
        , offsetof(WebCore::IDBRequestData, m_requestIdentifier)
        , offsetof(WebCore::IDBRequestData, m_transactionIdentifier)
        , offsetof(WebCore::IDBRequestData, m_cursorIdentifier)
        , offsetof(WebCore::IDBRequestData, m_objectStoreIdentifier)
        , offsetof(WebCore::IDBRequestData, m_indexIdentifier)
        , offsetof(WebCore::IDBRequestData, m_indexRecordType)
        , offsetof(WebCore::IDBRequestData, m_requestedVersion)
        , offsetof(WebCore::IDBRequestData, m_requestType)
    >::value);

    encoder << instance.m_serverConnectionIdentifier;
    encoder << instance.m_requestIdentifier;
    encoder << instance.m_transactionIdentifier;
    encoder << instance.m_cursorIdentifier;
    encoder << instance.m_objectStoreIdentifier;
    encoder << instance.m_indexIdentifier;
    encoder << instance.m_indexRecordType;
    encoder << instance.m_requestedVersion;
    encoder << instance.m_requestType;
}

std::optional<WebCore::IDBRequestData> ArgumentCoder<WebCore::IDBRequestData>::decode(Decoder& decoder)
{
    auto m_serverConnectionIdentifier = decoder.decode<WebCore::IDBConnectionIdentifier>();
    auto m_requestIdentifier = decoder.decode<WebCore::IDBResourceIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(!m_requestIdentifier->isEmpty()))
        return std::nullopt;
    auto m_transactionIdentifier = decoder.decode<WebCore::IDBResourceIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(!m_transactionIdentifier->isEmpty()))
        return std::nullopt;
    auto m_cursorIdentifier = decoder.decode<std::optional<WebCore::IDBResourceIdentifier>>();
    auto m_objectStoreIdentifier = decoder.decode<Markable<WebCore::IDBObjectStoreIdentifier>>();
    auto m_indexIdentifier = decoder.decode<Markable<WebCore::IDBIndexIdentifier>>();
    auto m_indexRecordType = decoder.decode<WebCore::IndexedDB::IndexRecordType>();
    auto m_requestedVersion = decoder.decode<uint64_t>();
    auto m_requestType = decoder.decode<WebCore::IndexedDB::RequestType>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::IDBRequestData {
            WTFMove(*m_serverConnectionIdentifier),
            WTFMove(*m_requestIdentifier),
            WTFMove(*m_transactionIdentifier),
            WTFMove(*m_cursorIdentifier),
            WTFMove(*m_objectStoreIdentifier),
            WTFMove(*m_indexIdentifier),
            WTFMove(*m_indexRecordType),
            WTFMove(*m_requestedVersion),
            WTFMove(*m_requestType)
        }
    };
}

void ArgumentCoder<WebCore::IDBDatabaseIdentifier>::encode(Encoder& encoder, const WebCore::IDBDatabaseIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_databaseName)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_origin)>, WebCore::ClientOrigin>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_isTransient)>, bool>);
    struct ShouldBeSameSizeAsIDBDatabaseIdentifier : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::IDBDatabaseIdentifier>, false> {
        String m_databaseName;
        WebCore::ClientOrigin m_origin;
        bool m_isTransient;
    };
    static_assert(sizeof(ShouldBeSameSizeAsIDBDatabaseIdentifier) == sizeof(WebCore::IDBDatabaseIdentifier));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::IDBDatabaseIdentifier, m_databaseName)
        , offsetof(WebCore::IDBDatabaseIdentifier, m_origin)
        , offsetof(WebCore::IDBDatabaseIdentifier, m_isTransient)
    >::value);

    encoder << instance.m_databaseName;
    encoder << instance.m_origin;
    encoder << instance.m_isTransient;
}

std::optional<WebCore::IDBDatabaseIdentifier> ArgumentCoder<WebCore::IDBDatabaseIdentifier>::decode(Decoder& decoder)
{
    auto m_databaseName = decoder.decode<String>();
    auto m_origin = decoder.decode<WebCore::ClientOrigin>();
    auto m_isTransient = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    WebCore::IDBDatabaseIdentifier result;
    result.m_databaseName = WTFMove(*m_databaseName);
    result.m_origin = WTFMove(*m_origin);
    result.m_isTransient = WTFMove(*m_isTransient);
    return { WTFMove(result) };
}

void ArgumentCoder<WebCore::IDBDatabaseNameAndVersion>::encode(Encoder& encoder, const WebCore::IDBDatabaseNameAndVersion& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.version)>, uint64_t>);
    struct ShouldBeSameSizeAsIDBDatabaseNameAndVersion : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::IDBDatabaseNameAndVersion>, false> {
        String name;
        uint64_t version;
    };
    static_assert(sizeof(ShouldBeSameSizeAsIDBDatabaseNameAndVersion) == sizeof(WebCore::IDBDatabaseNameAndVersion));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::IDBDatabaseNameAndVersion, name)
        , offsetof(WebCore::IDBDatabaseNameAndVersion, version)
    >::value);

    encoder << instance.name;
    encoder << instance.version;
}

std::optional<WebCore::IDBDatabaseNameAndVersion> ArgumentCoder<WebCore::IDBDatabaseNameAndVersion>::decode(Decoder& decoder)
{
    auto name = decoder.decode<String>();
    auto version = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::IDBDatabaseNameAndVersion {
            WTFMove(*name),
            WTFMove(*version)
        }
    };
}

void ArgumentCoder<WebCore::IDBResultData>::encode(Encoder& encoder, const WebCore::IDBResultData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_type)>, WebCore::IDBResultType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_requestIdentifier)>, WebCore::IDBResourceIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_error)>, WebCore::IDBError>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_databaseConnectionIdentifier)>, std::optional<WebCore::IDBDatabaseConnectionIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_databaseInfo)>, std::unique_ptr<WebCore::IDBDatabaseInfo>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_transactionInfo)>, std::unique_ptr<WebCore::IDBTransactionInfo>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_resultKey)>, std::unique_ptr<WebCore::IDBKeyData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_getResult)>, std::unique_ptr<WebCore::IDBGetResult>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_getAllResult)>, std::unique_ptr<WebCore::IDBGetAllResult>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_resultInteger)>, uint64_t>);
    struct ShouldBeSameSizeAsIDBResultData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::IDBResultData>, false> {
        WebCore::IDBResultType m_type;
        WebCore::IDBResourceIdentifier m_requestIdentifier;
        WebCore::IDBError m_error;
        std::optional<WebCore::IDBDatabaseConnectionIdentifier> m_databaseConnectionIdentifier;
        std::unique_ptr<WebCore::IDBDatabaseInfo> m_databaseInfo;
        std::unique_ptr<WebCore::IDBTransactionInfo> m_transactionInfo;
        std::unique_ptr<WebCore::IDBKeyData> m_resultKey;
        std::unique_ptr<WebCore::IDBGetResult> m_getResult;
        std::unique_ptr<WebCore::IDBGetAllResult> m_getAllResult;
        uint64_t m_resultInteger;
    };
    static_assert(sizeof(ShouldBeSameSizeAsIDBResultData) == sizeof(WebCore::IDBResultData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::IDBResultData, m_type)
        , offsetof(WebCore::IDBResultData, m_requestIdentifier)
        , offsetof(WebCore::IDBResultData, m_error)
        , offsetof(WebCore::IDBResultData, m_databaseConnectionIdentifier)
        , offsetof(WebCore::IDBResultData, m_databaseInfo)
        , offsetof(WebCore::IDBResultData, m_transactionInfo)
        , offsetof(WebCore::IDBResultData, m_resultKey)
        , offsetof(WebCore::IDBResultData, m_getResult)
        , offsetof(WebCore::IDBResultData, m_getAllResult)
        , offsetof(WebCore::IDBResultData, m_resultInteger)
    >::value);

    encoder << instance.m_type;
    encoder << instance.m_requestIdentifier;
    encoder << instance.m_error;
    encoder << instance.m_databaseConnectionIdentifier;
    encoder << instance.m_databaseInfo;
    encoder << instance.m_transactionInfo;
    encoder << instance.m_resultKey;
    encoder << instance.m_getResult;
    encoder << instance.m_getAllResult;
    encoder << instance.m_resultInteger;
}

std::optional<WebCore::IDBResultData> ArgumentCoder<WebCore::IDBResultData>::decode(Decoder& decoder)
{
    auto m_type = decoder.decode<WebCore::IDBResultType>();
    auto m_requestIdentifier = decoder.decode<WebCore::IDBResourceIdentifier>();
    auto m_error = decoder.decode<WebCore::IDBError>();
    auto m_databaseConnectionIdentifier = decoder.decode<std::optional<WebCore::IDBDatabaseConnectionIdentifier>>();
    auto m_databaseInfo = decoder.decode<std::unique_ptr<WebCore::IDBDatabaseInfo>>();
    auto m_transactionInfo = decoder.decode<std::unique_ptr<WebCore::IDBTransactionInfo>>();
    auto m_resultKey = decoder.decode<std::unique_ptr<WebCore::IDBKeyData>>();
    auto m_getResult = decoder.decode<std::unique_ptr<WebCore::IDBGetResult>>();
    auto m_getAllResult = decoder.decode<std::unique_ptr<WebCore::IDBGetAllResult>>();
    auto m_resultInteger = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    WebCore::IDBResultData result;
    result.m_type = WTFMove(*m_type);
    result.m_requestIdentifier = WTFMove(*m_requestIdentifier);
    result.m_error = WTFMove(*m_error);
    result.m_databaseConnectionIdentifier = WTFMove(*m_databaseConnectionIdentifier);
    result.m_databaseInfo = WTFMove(*m_databaseInfo);
    result.m_transactionInfo = WTFMove(*m_transactionInfo);
    result.m_resultKey = WTFMove(*m_resultKey);
    result.m_getResult = WTFMove(*m_getResult);
    result.m_getAllResult = WTFMove(*m_getAllResult);
    result.m_resultInteger = WTFMove(*m_resultInteger);
    return { WTFMove(result) };
}

void ArgumentCoder<WebCore::IDBKeyData>::encode(Encoder& encoder, const WebCore::IDBKeyData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isPlaceholder())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value())>, Variant<std::nullptr_t, WebCore::IDBKeyData::Invalid, Vector<WebCore::IDBKeyData>, String, double, WebCore::IDBKeyData::Date, WebCore::ThreadSafeDataBuffer, WebCore::IDBKeyData::Min, WebCore::IDBKeyData::Max>>);

    encoder << instance.isPlaceholder();
    encoder << instance.value();
}

std::optional<WebCore::IDBKeyData> ArgumentCoder<WebCore::IDBKeyData>::decode(Decoder& decoder)
{
    auto isPlaceholder = decoder.decode<bool>();
    auto value = decoder.decode<Variant<std::nullptr_t, WebCore::IDBKeyData::Invalid, Vector<WebCore::IDBKeyData>, String, double, WebCore::IDBKeyData::Date, WebCore::ThreadSafeDataBuffer, WebCore::IDBKeyData::Min, WebCore::IDBKeyData::Max>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(WebCore::IDBKeyData::isValidValue(*value)))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::IDBKeyData {
            WTFMove(*isPlaceholder),
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebCore::IDBKeyData::Invalid>::encode(Encoder& encoder, const WebCore::IDBKeyData::Invalid& instance)
{
    struct ShouldBeSameSizeAsInvalid : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::IDBKeyData::Invalid>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsInvalid) == sizeof(WebCore::IDBKeyData::Invalid));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::IDBKeyData::Invalid> ArgumentCoder<WebCore::IDBKeyData::Invalid>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::IDBKeyData::Invalid {
        }
    };
}

void ArgumentCoder<WebCore::IDBKeyData::Min>::encode(Encoder& encoder, const WebCore::IDBKeyData::Min& instance)
{
    struct ShouldBeSameSizeAsMin : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::IDBKeyData::Min>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsMin) == sizeof(WebCore::IDBKeyData::Min));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::IDBKeyData::Min> ArgumentCoder<WebCore::IDBKeyData::Min>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::IDBKeyData::Min {
        }
    };
}

void ArgumentCoder<WebCore::IDBKeyData::Max>::encode(Encoder& encoder, const WebCore::IDBKeyData::Max& instance)
{
    struct ShouldBeSameSizeAsMax : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::IDBKeyData::Max>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsMax) == sizeof(WebCore::IDBKeyData::Max));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::IDBKeyData::Max> ArgumentCoder<WebCore::IDBKeyData::Max>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::IDBKeyData::Max {
        }
    };
}

void ArgumentCoder<WebCore::IDBKeyData::Date>::encode(Encoder& encoder, const WebCore::IDBKeyData::Date& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, double>);
    struct ShouldBeSameSizeAsDate : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::IDBKeyData::Date>, false> {
        double value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsDate) == sizeof(WebCore::IDBKeyData::Date));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::IDBKeyData::Date, value)
    >::value);

    encoder << instance.value;
}

std::optional<WebCore::IDBKeyData::Date> ArgumentCoder<WebCore::IDBKeyData::Date>::decode(Decoder& decoder)
{
    auto value = decoder.decode<double>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::IDBKeyData::Date {
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebCore::IndexKey>::encode(Encoder& encoder, const WebCore::IndexKey& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data())>, Variant<std::nullptr_t, WebCore::IDBKeyData, Vector<WebCore::IDBKeyData>>>);

    encoder << instance.data();
}

std::optional<WebCore::IndexKey> ArgumentCoder<WebCore::IndexKey>::decode(Decoder& decoder)
{
    auto data = decoder.decode<Variant<std::nullptr_t, WebCore::IDBKeyData, Vector<WebCore::IDBKeyData>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::IndexKey {
            WTFMove(*data)
        }
    };
}

void ArgumentCoder<WebCore::FloatRect>::encode(Encoder& encoder, const WebCore::FloatRect& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.location())>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size())>, WebCore::FloatSize>);

    encoder << instance.location();
    encoder << instance.size();
}

void ArgumentCoder<WebCore::FloatRect>::encode(StreamConnectionEncoder& encoder, const WebCore::FloatRect& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.location())>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size())>, WebCore::FloatSize>);

    encoder << instance.location();
    encoder << instance.size();
}

std::optional<WebCore::FloatRect> ArgumentCoder<WebCore::FloatRect>::decode(Decoder& decoder)
{
    auto location = decoder.decode<WebCore::FloatPoint>();
    auto size = decoder.decode<WebCore::FloatSize>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FloatRect {
            WTFMove(*location),
            WTFMove(*size)
        }
    };
}

void ArgumentCoder<WebCore::LinearTimingFunction::Point>::encode(Encoder& encoder, const WebCore::LinearTimingFunction::Point& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.progress)>, double>);
    struct ShouldBeSameSizeAsPoint : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::LinearTimingFunction::Point>, false> {
        double value;
        double progress;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPoint) == sizeof(WebCore::LinearTimingFunction::Point));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::LinearTimingFunction::Point, value)
        , offsetof(WebCore::LinearTimingFunction::Point, progress)
    >::value);

    encoder << instance.value;
    encoder << instance.progress;
}

std::optional<WebCore::LinearTimingFunction::Point> ArgumentCoder<WebCore::LinearTimingFunction::Point>::decode(Decoder& decoder)
{
    auto value = decoder.decode<double>();
    auto progress = decoder.decode<double>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::LinearTimingFunction::Point {
            WTFMove(*value),
            WTFMove(*progress)
        }
    };
}

void ArgumentCoder<WebCore::LinearTimingFunction>::encode(Encoder& encoder, const WebCore::LinearTimingFunction& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.points())>, Vector<WebCore::LinearTimingFunction::Point>>);

    encoder << instance.points();
}

std::optional<Ref<WebCore::LinearTimingFunction>> ArgumentCoder<WebCore::LinearTimingFunction>::decode(Decoder& decoder)
{
    auto points = decoder.decode<Vector<WebCore::LinearTimingFunction::Point>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::LinearTimingFunction::create(
            WTFMove(*points)
        )
    };
}

void ArgumentCoder<WebCore::CubicBezierTimingFunction>::encode(Encoder& encoder, const WebCore::CubicBezierTimingFunction& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timingFunctionPreset())>, WebCore::CubicBezierTimingFunction::TimingFunctionPreset>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.x1())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.y1())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.x2())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.y2())>, double>);

    encoder << instance.timingFunctionPreset();
    encoder << instance.x1();
    encoder << instance.y1();
    encoder << instance.x2();
    encoder << instance.y2();
}

std::optional<Ref<WebCore::CubicBezierTimingFunction>> ArgumentCoder<WebCore::CubicBezierTimingFunction>::decode(Decoder& decoder)
{
    auto timingFunctionPreset = decoder.decode<WebCore::CubicBezierTimingFunction::TimingFunctionPreset>();
    auto x1 = decoder.decode<double>();
    auto y1 = decoder.decode<double>();
    auto x2 = decoder.decode<double>();
    auto y2 = decoder.decode<double>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CubicBezierTimingFunction::create(
            WTFMove(*timingFunctionPreset),
            WTFMove(*x1),
            WTFMove(*y1),
            WTFMove(*x2),
            WTFMove(*y2)
        )
    };
}

void ArgumentCoder<WebCore::StepsTimingFunction>::encode(Encoder& encoder, const WebCore::StepsTimingFunction& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.numberOfSteps())>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stepPosition())>, std::optional<WebCore::StepsTimingFunction::StepPosition>>);

    encoder << instance.numberOfSteps();
    encoder << instance.stepPosition();
}

std::optional<Ref<WebCore::StepsTimingFunction>> ArgumentCoder<WebCore::StepsTimingFunction>::decode(Decoder& decoder)
{
    auto numberOfSteps = decoder.decode<int>();
    auto stepPosition = decoder.decode<std::optional<WebCore::StepsTimingFunction::StepPosition>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::StepsTimingFunction::create(
            WTFMove(*numberOfSteps),
            WTFMove(*stepPosition)
        )
    };
}

void ArgumentCoder<WebCore::SpringTimingFunction>::encode(Encoder& encoder, const WebCore::SpringTimingFunction& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mass())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stiffness())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.damping())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.initialVelocity())>, double>);

    encoder << instance.mass();
    encoder << instance.stiffness();
    encoder << instance.damping();
    encoder << instance.initialVelocity();
}

std::optional<Ref<WebCore::SpringTimingFunction>> ArgumentCoder<WebCore::SpringTimingFunction>::decode(Decoder& decoder)
{
    auto mass = decoder.decode<double>();
    auto stiffness = decoder.decode<double>();
    auto damping = decoder.decode<double>();
    auto initialVelocity = decoder.decode<double>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SpringTimingFunction::create(
            WTFMove(*mass),
            WTFMove(*stiffness),
            WTFMove(*damping),
            WTFMove(*initialVelocity)
        )
    };
}

void ArgumentCoder<WebCore::ResourceLoadStatistics>::encode(Encoder& encoder, const WebCore::ResourceLoadStatistics& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.registrableDomain)>, WebCore::RegistrableDomain>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lastSeen)>, WallTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hadUserInteraction)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mostRecentUserInteractionTime)>, WallTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.grandfathered)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.storageAccessUnderTopFrameDomains)>, HashSet<WebCore::RegistrableDomain>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.topFrameUniqueRedirectsTo)>, HashSet<WebCore::RegistrableDomain>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.topFrameUniqueRedirectsToSinceSameSiteStrictEnforcement)>, HashSet<WebCore::RegistrableDomain>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.topFrameUniqueRedirectsFrom)>, HashSet<WebCore::RegistrableDomain>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.topFrameLinkDecorationsFrom)>, HashSet<WebCore::RegistrableDomain>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.gotLinkDecorationFromPrevalentResource)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.topFrameLoadedThirdPartyScripts)>, HashSet<WebCore::RegistrableDomain>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.subframeUnderTopFrameDomains)>, HashSet<WebCore::RegistrableDomain>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.subresourceUnderTopFrameDomains)>, HashSet<WebCore::RegistrableDomain>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.subresourceUniqueRedirectsTo)>, HashSet<WebCore::RegistrableDomain>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.subresourceUniqueRedirectsFrom)>, HashSet<WebCore::RegistrableDomain>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isPrevalentResource)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isVeryPrevalentResource)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dataRecordsRemoved)>, unsigned>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timesAccessedAsFirstPartyDueToUserInteraction)>, unsigned>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timesAccessedAsFirstPartyDueToStorageAccessAPI)>, unsigned>);
#if ENABLE(WEB_API_STATISTICS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.topFrameRegistrableDomainsWhichAccessedWebAPIs)>, HashSet<WebCore::RegistrableDomain>>);
#endif
#if ENABLE(WEB_API_STATISTICS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fontsFailedToLoad)>, HashSet<String>>);
#endif
#if ENABLE(WEB_API_STATISTICS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fontsSuccessfullyLoaded)>, HashSet<String>>);
#endif
#if ENABLE(WEB_API_STATISTICS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.canvasActivityRecord)>, WebCore::CanvasActivityRecord>);
#endif
#if ENABLE(WEB_API_STATISTICS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.navigatorFunctionsAccessed)>, OptionSet<WebCore::NavigatorAPIsAccessed>>);
#endif
#if ENABLE(WEB_API_STATISTICS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.screenFunctionsAccessed)>, OptionSet<WebCore::ScreenAPIsAccessed>>);
#endif
    struct ShouldBeSameSizeAsResourceLoadStatistics : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ResourceLoadStatistics>, false> {
        WebCore::RegistrableDomain registrableDomain;
        WallTime lastSeen;
        bool hadUserInteraction;
        WallTime mostRecentUserInteractionTime;
        bool grandfathered;
        HashSet<WebCore::RegistrableDomain> storageAccessUnderTopFrameDomains;
        HashSet<WebCore::RegistrableDomain> topFrameUniqueRedirectsTo;
        HashSet<WebCore::RegistrableDomain> topFrameUniqueRedirectsToSinceSameSiteStrictEnforcement;
        HashSet<WebCore::RegistrableDomain> topFrameUniqueRedirectsFrom;
        HashSet<WebCore::RegistrableDomain> topFrameLinkDecorationsFrom;
        bool gotLinkDecorationFromPrevalentResource;
        HashSet<WebCore::RegistrableDomain> topFrameLoadedThirdPartyScripts;
        HashSet<WebCore::RegistrableDomain> subframeUnderTopFrameDomains;
        HashSet<WebCore::RegistrableDomain> subresourceUnderTopFrameDomains;
        HashSet<WebCore::RegistrableDomain> subresourceUniqueRedirectsTo;
        HashSet<WebCore::RegistrableDomain> subresourceUniqueRedirectsFrom;
        bool isPrevalentResource;
        bool isVeryPrevalentResource;
        unsigned dataRecordsRemoved;
        unsigned timesAccessedAsFirstPartyDueToUserInteraction;
        unsigned timesAccessedAsFirstPartyDueToStorageAccessAPI;
#if ENABLE(WEB_API_STATISTICS)
        HashSet<WebCore::RegistrableDomain> topFrameRegistrableDomainsWhichAccessedWebAPIs;
#endif
#if ENABLE(WEB_API_STATISTICS)
        HashSet<String> fontsFailedToLoad;
#endif
#if ENABLE(WEB_API_STATISTICS)
        HashSet<String> fontsSuccessfullyLoaded;
#endif
#if ENABLE(WEB_API_STATISTICS)
        WebCore::CanvasActivityRecord canvasActivityRecord;
#endif
#if ENABLE(WEB_API_STATISTICS)
        OptionSet<WebCore::NavigatorAPIsAccessed> navigatorFunctionsAccessed;
#endif
#if ENABLE(WEB_API_STATISTICS)
        OptionSet<WebCore::ScreenAPIsAccessed> screenFunctionsAccessed;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsResourceLoadStatistics) == sizeof(WebCore::ResourceLoadStatistics));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ResourceLoadStatistics, registrableDomain)
        , offsetof(WebCore::ResourceLoadStatistics, lastSeen)
        , offsetof(WebCore::ResourceLoadStatistics, hadUserInteraction)
        , offsetof(WebCore::ResourceLoadStatistics, mostRecentUserInteractionTime)
        , offsetof(WebCore::ResourceLoadStatistics, grandfathered)
        , offsetof(WebCore::ResourceLoadStatistics, storageAccessUnderTopFrameDomains)
        , offsetof(WebCore::ResourceLoadStatistics, topFrameUniqueRedirectsTo)
        , offsetof(WebCore::ResourceLoadStatistics, topFrameUniqueRedirectsToSinceSameSiteStrictEnforcement)
        , offsetof(WebCore::ResourceLoadStatistics, topFrameUniqueRedirectsFrom)
        , offsetof(WebCore::ResourceLoadStatistics, topFrameLinkDecorationsFrom)
        , offsetof(WebCore::ResourceLoadStatistics, gotLinkDecorationFromPrevalentResource)
        , offsetof(WebCore::ResourceLoadStatistics, topFrameLoadedThirdPartyScripts)
        , offsetof(WebCore::ResourceLoadStatistics, subframeUnderTopFrameDomains)
        , offsetof(WebCore::ResourceLoadStatistics, subresourceUnderTopFrameDomains)
        , offsetof(WebCore::ResourceLoadStatistics, subresourceUniqueRedirectsTo)
        , offsetof(WebCore::ResourceLoadStatistics, subresourceUniqueRedirectsFrom)
        , offsetof(WebCore::ResourceLoadStatistics, isPrevalentResource)
        , offsetof(WebCore::ResourceLoadStatistics, isVeryPrevalentResource)
        , offsetof(WebCore::ResourceLoadStatistics, dataRecordsRemoved)
        , offsetof(WebCore::ResourceLoadStatistics, timesAccessedAsFirstPartyDueToUserInteraction)
        , offsetof(WebCore::ResourceLoadStatistics, timesAccessedAsFirstPartyDueToStorageAccessAPI)
#if ENABLE(WEB_API_STATISTICS)
        , offsetof(WebCore::ResourceLoadStatistics, topFrameRegistrableDomainsWhichAccessedWebAPIs)
#endif
#if ENABLE(WEB_API_STATISTICS)
        , offsetof(WebCore::ResourceLoadStatistics, fontsFailedToLoad)
#endif
#if ENABLE(WEB_API_STATISTICS)
        , offsetof(WebCore::ResourceLoadStatistics, fontsSuccessfullyLoaded)
#endif
#if ENABLE(WEB_API_STATISTICS)
        , offsetof(WebCore::ResourceLoadStatistics, canvasActivityRecord)
#endif
#if ENABLE(WEB_API_STATISTICS)
        , offsetof(WebCore::ResourceLoadStatistics, navigatorFunctionsAccessed)
#endif
#if ENABLE(WEB_API_STATISTICS)
        , offsetof(WebCore::ResourceLoadStatistics, screenFunctionsAccessed)
#endif
    >::value);

    encoder << instance.registrableDomain;
    encoder << instance.lastSeen;
    encoder << instance.hadUserInteraction;
    encoder << instance.mostRecentUserInteractionTime;
    encoder << instance.grandfathered;
    encoder << instance.storageAccessUnderTopFrameDomains;
    encoder << instance.topFrameUniqueRedirectsTo;
    encoder << instance.topFrameUniqueRedirectsToSinceSameSiteStrictEnforcement;
    encoder << instance.topFrameUniqueRedirectsFrom;
    encoder << instance.topFrameLinkDecorationsFrom;
    encoder << instance.gotLinkDecorationFromPrevalentResource;
    encoder << instance.topFrameLoadedThirdPartyScripts;
    encoder << instance.subframeUnderTopFrameDomains;
    encoder << instance.subresourceUnderTopFrameDomains;
    encoder << instance.subresourceUniqueRedirectsTo;
    encoder << instance.subresourceUniqueRedirectsFrom;
    encoder << instance.isPrevalentResource;
    encoder << instance.isVeryPrevalentResource;
    encoder << instance.dataRecordsRemoved;
    encoder << instance.timesAccessedAsFirstPartyDueToUserInteraction;
    encoder << instance.timesAccessedAsFirstPartyDueToStorageAccessAPI;
#if ENABLE(WEB_API_STATISTICS)
    encoder << instance.topFrameRegistrableDomainsWhichAccessedWebAPIs;
#endif
#if ENABLE(WEB_API_STATISTICS)
    encoder << instance.fontsFailedToLoad;
#endif
#if ENABLE(WEB_API_STATISTICS)
    encoder << instance.fontsSuccessfullyLoaded;
#endif
#if ENABLE(WEB_API_STATISTICS)
    encoder << instance.canvasActivityRecord;
#endif
#if ENABLE(WEB_API_STATISTICS)
    encoder << instance.navigatorFunctionsAccessed;
#endif
#if ENABLE(WEB_API_STATISTICS)
    encoder << instance.screenFunctionsAccessed;
#endif
}

std::optional<WebCore::ResourceLoadStatistics> ArgumentCoder<WebCore::ResourceLoadStatistics>::decode(Decoder& decoder)
{
    auto registrableDomain = decoder.decode<WebCore::RegistrableDomain>();
    auto lastSeen = decoder.decode<WallTime>();
    auto hadUserInteraction = decoder.decode<bool>();
    auto mostRecentUserInteractionTime = decoder.decode<WallTime>();
    auto grandfathered = decoder.decode<bool>();
    auto storageAccessUnderTopFrameDomains = decoder.decode<HashSet<WebCore::RegistrableDomain>>();
    auto topFrameUniqueRedirectsTo = decoder.decode<HashSet<WebCore::RegistrableDomain>>();
    auto topFrameUniqueRedirectsToSinceSameSiteStrictEnforcement = decoder.decode<HashSet<WebCore::RegistrableDomain>>();
    auto topFrameUniqueRedirectsFrom = decoder.decode<HashSet<WebCore::RegistrableDomain>>();
    auto topFrameLinkDecorationsFrom = decoder.decode<HashSet<WebCore::RegistrableDomain>>();
    auto gotLinkDecorationFromPrevalentResource = decoder.decode<bool>();
    auto topFrameLoadedThirdPartyScripts = decoder.decode<HashSet<WebCore::RegistrableDomain>>();
    auto subframeUnderTopFrameDomains = decoder.decode<HashSet<WebCore::RegistrableDomain>>();
    auto subresourceUnderTopFrameDomains = decoder.decode<HashSet<WebCore::RegistrableDomain>>();
    auto subresourceUniqueRedirectsTo = decoder.decode<HashSet<WebCore::RegistrableDomain>>();
    auto subresourceUniqueRedirectsFrom = decoder.decode<HashSet<WebCore::RegistrableDomain>>();
    auto isPrevalentResource = decoder.decode<bool>();
    auto isVeryPrevalentResource = decoder.decode<bool>();
    auto dataRecordsRemoved = decoder.decode<unsigned>();
    auto timesAccessedAsFirstPartyDueToUserInteraction = decoder.decode<unsigned>();
    auto timesAccessedAsFirstPartyDueToStorageAccessAPI = decoder.decode<unsigned>();
#if ENABLE(WEB_API_STATISTICS)
    auto topFrameRegistrableDomainsWhichAccessedWebAPIs = decoder.decode<HashSet<WebCore::RegistrableDomain>>();
#endif
#if ENABLE(WEB_API_STATISTICS)
    auto fontsFailedToLoad = decoder.decode<HashSet<String>>();
#endif
#if ENABLE(WEB_API_STATISTICS)
    auto fontsSuccessfullyLoaded = decoder.decode<HashSet<String>>();
#endif
#if ENABLE(WEB_API_STATISTICS)
    auto canvasActivityRecord = decoder.decode<WebCore::CanvasActivityRecord>();
#endif
#if ENABLE(WEB_API_STATISTICS)
    auto navigatorFunctionsAccessed = decoder.decode<OptionSet<WebCore::NavigatorAPIsAccessed>>();
#endif
#if ENABLE(WEB_API_STATISTICS)
    auto screenFunctionsAccessed = decoder.decode<OptionSet<WebCore::ScreenAPIsAccessed>>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    WebCore::ResourceLoadStatistics result;
    result.registrableDomain = WTFMove(*registrableDomain);
    result.lastSeen = WTFMove(*lastSeen);
    result.hadUserInteraction = WTFMove(*hadUserInteraction);
    result.mostRecentUserInteractionTime = WTFMove(*mostRecentUserInteractionTime);
    result.grandfathered = WTFMove(*grandfathered);
    result.storageAccessUnderTopFrameDomains = WTFMove(*storageAccessUnderTopFrameDomains);
    result.topFrameUniqueRedirectsTo = WTFMove(*topFrameUniqueRedirectsTo);
    result.topFrameUniqueRedirectsToSinceSameSiteStrictEnforcement = WTFMove(*topFrameUniqueRedirectsToSinceSameSiteStrictEnforcement);
    result.topFrameUniqueRedirectsFrom = WTFMove(*topFrameUniqueRedirectsFrom);
    result.topFrameLinkDecorationsFrom = WTFMove(*topFrameLinkDecorationsFrom);
    result.gotLinkDecorationFromPrevalentResource = WTFMove(*gotLinkDecorationFromPrevalentResource);
    result.topFrameLoadedThirdPartyScripts = WTFMove(*topFrameLoadedThirdPartyScripts);
    result.subframeUnderTopFrameDomains = WTFMove(*subframeUnderTopFrameDomains);
    result.subresourceUnderTopFrameDomains = WTFMove(*subresourceUnderTopFrameDomains);
    result.subresourceUniqueRedirectsTo = WTFMove(*subresourceUniqueRedirectsTo);
    result.subresourceUniqueRedirectsFrom = WTFMove(*subresourceUniqueRedirectsFrom);
    result.isPrevalentResource = WTFMove(*isPrevalentResource);
    result.isVeryPrevalentResource = WTFMove(*isVeryPrevalentResource);
    result.dataRecordsRemoved = WTFMove(*dataRecordsRemoved);
    result.timesAccessedAsFirstPartyDueToUserInteraction = WTFMove(*timesAccessedAsFirstPartyDueToUserInteraction);
    result.timesAccessedAsFirstPartyDueToStorageAccessAPI = WTFMove(*timesAccessedAsFirstPartyDueToStorageAccessAPI);
#if ENABLE(WEB_API_STATISTICS)
    result.topFrameRegistrableDomainsWhichAccessedWebAPIs = WTFMove(*topFrameRegistrableDomainsWhichAccessedWebAPIs);
#endif
#if ENABLE(WEB_API_STATISTICS)
    result.fontsFailedToLoad = WTFMove(*fontsFailedToLoad);
#endif
#if ENABLE(WEB_API_STATISTICS)
    result.fontsSuccessfullyLoaded = WTFMove(*fontsSuccessfullyLoaded);
#endif
#if ENABLE(WEB_API_STATISTICS)
    result.canvasActivityRecord = WTFMove(*canvasActivityRecord);
#endif
#if ENABLE(WEB_API_STATISTICS)
    result.navigatorFunctionsAccessed = WTFMove(*navigatorFunctionsAccessed);
#endif
#if ENABLE(WEB_API_STATISTICS)
    result.screenFunctionsAccessed = WTFMove(*screenFunctionsAccessed);
#endif
    return { WTFMove(result) };
}

#if ENABLE(GPU_PROCESS) && ENABLE(WEBGL)
void ArgumentCoder<WebCore::GraphicsContextGLActiveInfo>::encode(Encoder& encoder, const WebCore::GraphicsContextGLActiveInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, GCGLenum>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size)>, GCGLint>);
    struct ShouldBeSameSizeAsGraphicsContextGLActiveInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::GraphicsContextGLActiveInfo>, false> {
        String name;
        GCGLenum type;
        GCGLint size;
    };
    static_assert(sizeof(ShouldBeSameSizeAsGraphicsContextGLActiveInfo) == sizeof(WebCore::GraphicsContextGLActiveInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::GraphicsContextGLActiveInfo, name)
        , offsetof(WebCore::GraphicsContextGLActiveInfo, type)
        , offsetof(WebCore::GraphicsContextGLActiveInfo, size)
    >::value);

    encoder << instance.name;
    encoder << instance.type;
    encoder << instance.size;
}

void ArgumentCoder<WebCore::GraphicsContextGLActiveInfo>::encode(StreamConnectionEncoder& encoder, const WebCore::GraphicsContextGLActiveInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, GCGLenum>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size)>, GCGLint>);
    struct ShouldBeSameSizeAsGraphicsContextGLActiveInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::GraphicsContextGLActiveInfo>, false> {
        String name;
        GCGLenum type;
        GCGLint size;
    };
    static_assert(sizeof(ShouldBeSameSizeAsGraphicsContextGLActiveInfo) == sizeof(WebCore::GraphicsContextGLActiveInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::GraphicsContextGLActiveInfo, name)
        , offsetof(WebCore::GraphicsContextGLActiveInfo, type)
        , offsetof(WebCore::GraphicsContextGLActiveInfo, size)
    >::value);

    encoder << instance.name;
    encoder << instance.type;
    encoder << instance.size;
}

std::optional<WebCore::GraphicsContextGLActiveInfo> ArgumentCoder<WebCore::GraphicsContextGLActiveInfo>::decode(Decoder& decoder)
{
    auto name = decoder.decode<String>();
    auto type = decoder.decode<GCGLenum>();
    auto size = decoder.decode<GCGLint>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::GraphicsContextGLActiveInfo {
            WTFMove(*name),
            WTFMove(*type),
            WTFMove(*size)
        }
    };
}

#endif

void ArgumentCoder<WebCore::ShareDataWithParsedURL>::encode(Encoder& encoder, const WebCore::ShareDataWithParsedURL& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shareData)>, WebCore::ShareData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url)>, std::optional<URL>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.files)>, Vector<WebCore::RawFile>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.originator)>, WebCore::ShareDataOriginator>);
    struct ShouldBeSameSizeAsShareDataWithParsedURL : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ShareDataWithParsedURL>, false> {
        WebCore::ShareData shareData;
        std::optional<URL> url;
        Vector<WebCore::RawFile> files;
        WebCore::ShareDataOriginator originator;
    };
    static_assert(sizeof(ShouldBeSameSizeAsShareDataWithParsedURL) == sizeof(WebCore::ShareDataWithParsedURL));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ShareDataWithParsedURL, shareData)
        , offsetof(WebCore::ShareDataWithParsedURL, url)
        , offsetof(WebCore::ShareDataWithParsedURL, files)
        , offsetof(WebCore::ShareDataWithParsedURL, originator)
    >::value);

    encoder << instance.shareData;
    encoder << instance.url;
    encoder << instance.files;
    encoder << instance.originator;
}

std::optional<WebCore::ShareDataWithParsedURL> ArgumentCoder<WebCore::ShareDataWithParsedURL>::decode(Decoder& decoder)
{
    auto shareData = decoder.decode<WebCore::ShareData>();
    auto url = decoder.decode<std::optional<URL>>();
    auto files = decoder.decode<Vector<WebCore::RawFile>>();
    auto originator = decoder.decode<WebCore::ShareDataOriginator>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ShareDataWithParsedURL {
            WTFMove(*shareData),
            WTFMove(*url),
            WTFMove(*files),
            WTFMove(*originator)
        }
    };
}

void ArgumentCoder<WebCore::ShareData>::encode(Encoder& encoder, const WebCore::ShareData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.title)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.text)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.files)>, Vector<Ref<WebCore::File>>>);
    struct ShouldBeSameSizeAsShareData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ShareData>, false> {
        String title;
        String text;
        String url;
        Vector<Ref<WebCore::File>> files;
    };
    static_assert(sizeof(ShouldBeSameSizeAsShareData) == sizeof(WebCore::ShareData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ShareData, title)
        , offsetof(WebCore::ShareData, text)
        , offsetof(WebCore::ShareData, url)
        , offsetof(WebCore::ShareData, files)
    >::value);

    encoder << instance.title;
    encoder << instance.text;
    encoder << instance.url;
}

std::optional<WebCore::ShareData> ArgumentCoder<WebCore::ShareData>::decode(Decoder& decoder)
{
    auto title = decoder.decode<String>();
    auto text = decoder.decode<String>();
    auto url = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ShareData {
            WTFMove(*title),
            WTFMove(*text),
            WTFMove(*url)
        }
    };
}

#if ENABLE(WEB_PAGE_SPATIAL_BACKDROP)
void ArgumentCoder<WebCore::SpatialBackdropSource>::encode(Encoder& encoder, const WebCore::SpatialBackdropSource& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_sourceURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_modelURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_environmentMapURL)>, std::optional<URL>>);
    struct ShouldBeSameSizeAsSpatialBackdropSource : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SpatialBackdropSource>, false> {
        URL m_sourceURL;
        URL m_modelURL;
        std::optional<URL> m_environmentMapURL;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSpatialBackdropSource) == sizeof(WebCore::SpatialBackdropSource));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SpatialBackdropSource, m_sourceURL)
        , offsetof(WebCore::SpatialBackdropSource, m_modelURL)
        , offsetof(WebCore::SpatialBackdropSource, m_environmentMapURL)
    >::value);

    encoder << instance.m_sourceURL;
    encoder << instance.m_modelURL;
    encoder << instance.m_environmentMapURL;
}

std::optional<WebCore::SpatialBackdropSource> ArgumentCoder<WebCore::SpatialBackdropSource>::decode(Decoder& decoder)
{
    auto m_sourceURL = decoder.decode<URL>();
    auto m_modelURL = decoder.decode<URL>();
    auto m_environmentMapURL = decoder.decode<std::optional<URL>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SpatialBackdropSource {
            WTFMove(*m_sourceURL),
            WTFMove(*m_modelURL),
            WTFMove(*m_environmentMapURL)
        }
    };
}

#endif

void ArgumentCoder<WebCore::TargetedElementAdjustment>::encode(Encoder& encoder, const WebCore::TargetedElementAdjustment& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifiers)>, WebCore::TargetedElementIdentifiers>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selectors)>, WebCore::TargetedElementSelectors>);
    struct ShouldBeSameSizeAsTargetedElementAdjustment : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::TargetedElementAdjustment>, false> {
        WebCore::TargetedElementIdentifiers identifiers;
        WebCore::TargetedElementSelectors selectors;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTargetedElementAdjustment) == sizeof(WebCore::TargetedElementAdjustment));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::TargetedElementAdjustment, identifiers)
        , offsetof(WebCore::TargetedElementAdjustment, selectors)
    >::value);

    encoder << instance.identifiers;
    encoder << instance.selectors;
}

std::optional<WebCore::TargetedElementAdjustment> ArgumentCoder<WebCore::TargetedElementAdjustment>::decode(Decoder& decoder)
{
    auto identifiers = decoder.decode<WebCore::TargetedElementIdentifiers>();
    auto selectors = decoder.decode<WebCore::TargetedElementSelectors>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TargetedElementAdjustment {
            WTFMove(*identifiers),
            WTFMove(*selectors)
        }
    };
}

void ArgumentCoder<WebCore::TargetedElementRequest>::encode(Encoder& encoder, const WebCore::TargetedElementRequest& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data)>, Variant<WebCore::FloatPoint, String, WebCore::TargetedElementSelectors>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.canIncludeNearbyElements)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldIgnorePointerEventsNone)>, bool>);
    struct ShouldBeSameSizeAsTargetedElementRequest : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::TargetedElementRequest>, false> {
        Variant<WebCore::FloatPoint, String, WebCore::TargetedElementSelectors> data;
        bool canIncludeNearbyElements;
        bool shouldIgnorePointerEventsNone;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTargetedElementRequest) == sizeof(WebCore::TargetedElementRequest));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::TargetedElementRequest, data)
        , offsetof(WebCore::TargetedElementRequest, canIncludeNearbyElements)
        , offsetof(WebCore::TargetedElementRequest, shouldIgnorePointerEventsNone)
    >::value);

    encoder << instance.data;
    encoder << instance.canIncludeNearbyElements;
    encoder << instance.shouldIgnorePointerEventsNone;
}

std::optional<WebCore::TargetedElementRequest> ArgumentCoder<WebCore::TargetedElementRequest>::decode(Decoder& decoder)
{
    auto data = decoder.decode<Variant<WebCore::FloatPoint, String, WebCore::TargetedElementSelectors>>();
    auto canIncludeNearbyElements = decoder.decode<bool>();
    auto shouldIgnorePointerEventsNone = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TargetedElementRequest {
            WTFMove(*data),
            WTFMove(*canIncludeNearbyElements),
            WTFMove(*shouldIgnorePointerEventsNone)
        }
    };
}

void ArgumentCoder<WebCore::TargetedElementInfo>::encode(Encoder& encoder, const WebCore::TargetedElementInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.nodeIdentifier)>, WebCore::NodeIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.documentIdentifier)>, WebCore::ScriptExecutionContextIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offsetEdges)>, WebCore::RectEdges<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.renderedText)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.searchableText)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.screenReaderText)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selectors)>, Vector<Vector<String>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.boundsInRootView)>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.boundsInClientCoordinates)>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.positionType)>, WebCore::PositionType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.childFrameIdentifiers)>, Vector<WebCore::FrameIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaAndLinkURLs)>, HashSet<URL>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isNearbyTarget)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isPseudoElement)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isInShadowTree)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isInVisibilityAdjustmentSubtree)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasLargeReplacedDescendant)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasAudibleMedia)>, bool>);
    struct ShouldBeSameSizeAsTargetedElementInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::TargetedElementInfo>, false> {
        WebCore::NodeIdentifier nodeIdentifier;
        WebCore::ScriptExecutionContextIdentifier documentIdentifier;
        WebCore::RectEdges<bool> offsetEdges;
        String renderedText;
        String searchableText;
        String screenReaderText;
        Vector<Vector<String>> selectors;
        WebCore::FloatRect boundsInRootView;
        WebCore::FloatRect boundsInClientCoordinates;
        WebCore::PositionType positionType;
        Vector<WebCore::FrameIdentifier> childFrameIdentifiers;
        HashSet<URL> mediaAndLinkURLs;
        bool isNearbyTarget;
        bool isPseudoElement;
        bool isInShadowTree;
        bool isInVisibilityAdjustmentSubtree;
        bool hasLargeReplacedDescendant;
        bool hasAudibleMedia;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTargetedElementInfo) == sizeof(WebCore::TargetedElementInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::TargetedElementInfo, nodeIdentifier)
        , offsetof(WebCore::TargetedElementInfo, documentIdentifier)
        , offsetof(WebCore::TargetedElementInfo, offsetEdges)
        , offsetof(WebCore::TargetedElementInfo, renderedText)
        , offsetof(WebCore::TargetedElementInfo, searchableText)
        , offsetof(WebCore::TargetedElementInfo, screenReaderText)
        , offsetof(WebCore::TargetedElementInfo, selectors)
        , offsetof(WebCore::TargetedElementInfo, boundsInRootView)
        , offsetof(WebCore::TargetedElementInfo, boundsInClientCoordinates)
        , offsetof(WebCore::TargetedElementInfo, positionType)
        , offsetof(WebCore::TargetedElementInfo, childFrameIdentifiers)
        , offsetof(WebCore::TargetedElementInfo, mediaAndLinkURLs)
        , offsetof(WebCore::TargetedElementInfo, isNearbyTarget)
        , offsetof(WebCore::TargetedElementInfo, isPseudoElement)
        , offsetof(WebCore::TargetedElementInfo, isInShadowTree)
        , offsetof(WebCore::TargetedElementInfo, isInVisibilityAdjustmentSubtree)
        , offsetof(WebCore::TargetedElementInfo, hasLargeReplacedDescendant)
        , offsetof(WebCore::TargetedElementInfo, hasAudibleMedia)
    >::value);

    encoder << instance.nodeIdentifier;
    encoder << instance.documentIdentifier;
    encoder << instance.offsetEdges;
    encoder << instance.renderedText;
    encoder << instance.searchableText;
    encoder << instance.screenReaderText;
    encoder << instance.selectors;
    encoder << instance.boundsInRootView;
    encoder << instance.boundsInClientCoordinates;
    encoder << instance.positionType;
    encoder << instance.childFrameIdentifiers;
    encoder << instance.mediaAndLinkURLs;
    encoder << instance.isNearbyTarget;
    encoder << instance.isPseudoElement;
    encoder << instance.isInShadowTree;
    encoder << instance.isInVisibilityAdjustmentSubtree;
    encoder << instance.hasLargeReplacedDescendant;
    encoder << instance.hasAudibleMedia;
}

std::optional<WebCore::TargetedElementInfo> ArgumentCoder<WebCore::TargetedElementInfo>::decode(Decoder& decoder)
{
    auto nodeIdentifier = decoder.decode<WebCore::NodeIdentifier>();
    auto documentIdentifier = decoder.decode<WebCore::ScriptExecutionContextIdentifier>();
    auto offsetEdges = decoder.decode<WebCore::RectEdges<bool>>();
    auto renderedText = decoder.decode<String>();
    auto searchableText = decoder.decode<String>();
    auto screenReaderText = decoder.decode<String>();
    auto selectors = decoder.decode<Vector<Vector<String>>>();
    auto boundsInRootView = decoder.decode<WebCore::FloatRect>();
    auto boundsInClientCoordinates = decoder.decode<WebCore::FloatRect>();
    auto positionType = decoder.decode<WebCore::PositionType>();
    auto childFrameIdentifiers = decoder.decode<Vector<WebCore::FrameIdentifier>>();
    auto mediaAndLinkURLs = decoder.decode<HashSet<URL>>();
    auto isNearbyTarget = decoder.decode<bool>();
    auto isPseudoElement = decoder.decode<bool>();
    auto isInShadowTree = decoder.decode<bool>();
    auto isInVisibilityAdjustmentSubtree = decoder.decode<bool>();
    auto hasLargeReplacedDescendant = decoder.decode<bool>();
    auto hasAudibleMedia = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TargetedElementInfo {
            WTFMove(*nodeIdentifier),
            WTFMove(*documentIdentifier),
            WTFMove(*offsetEdges),
            WTFMove(*renderedText),
            WTFMove(*searchableText),
            WTFMove(*screenReaderText),
            WTFMove(*selectors),
            WTFMove(*boundsInRootView),
            WTFMove(*boundsInClientCoordinates),
            WTFMove(*positionType),
            WTFMove(*childFrameIdentifiers),
            WTFMove(*mediaAndLinkURLs),
            WTFMove(*isNearbyTarget),
            WTFMove(*isPseudoElement),
            WTFMove(*isInShadowTree),
            WTFMove(*isInVisibilityAdjustmentSubtree),
            WTFMove(*hasLargeReplacedDescendant),
            WTFMove(*hasAudibleMedia)
        }
    };
}

void ArgumentCoder<WebCore::RawFile>::encode(Encoder& encoder, const WebCore::RawFile& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fileName)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fileData)>, RefPtr<WebCore::SharedBuffer>>);
    struct ShouldBeSameSizeAsRawFile : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::RawFile>, false> {
        String fileName;
        RefPtr<WebCore::SharedBuffer> fileData;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRawFile) == sizeof(WebCore::RawFile));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::RawFile, fileName)
        , offsetof(WebCore::RawFile, fileData)
    >::value);

    encoder << instance.fileName;
    encoder << instance.fileData;
}

std::optional<WebCore::RawFile> ArgumentCoder<WebCore::RawFile>::decode(Decoder& decoder)
{
    auto fileName = decoder.decode<String>();
    auto fileData = decoder.decode<RefPtr<WebCore::SharedBuffer>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::RawFile {
            WTFMove(*fileName),
            WTFMove(*fileData)
        }
    };
}

void ArgumentCoder<WebCore::FloatRoundedRect>::encode(Encoder& encoder, const WebCore::FloatRoundedRect& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rect())>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radii().topLeft())>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radii().topRight())>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radii().bottomLeft())>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radii().bottomRight())>, WebCore::FloatSize>);

    encoder << instance.rect();
    encoder << instance.radii().topLeft();
    encoder << instance.radii().topRight();
    encoder << instance.radii().bottomLeft();
    encoder << instance.radii().bottomRight();
}

void ArgumentCoder<WebCore::FloatRoundedRect>::encode(StreamConnectionEncoder& encoder, const WebCore::FloatRoundedRect& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rect())>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radii().topLeft())>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radii().topRight())>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radii().bottomLeft())>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radii().bottomRight())>, WebCore::FloatSize>);

    encoder << instance.rect();
    encoder << instance.radii().topLeft();
    encoder << instance.radii().topRight();
    encoder << instance.radii().bottomLeft();
    encoder << instance.radii().bottomRight();
}

std::optional<WebCore::FloatRoundedRect> ArgumentCoder<WebCore::FloatRoundedRect>::decode(Decoder& decoder)
{
    auto rect = decoder.decode<WebCore::FloatRect>();
    auto radiitopLeft = decoder.decode<WebCore::FloatSize>();
    auto radiitopRight = decoder.decode<WebCore::FloatSize>();
    auto radiibottomLeft = decoder.decode<WebCore::FloatSize>();
    auto radiibottomRight = decoder.decode<WebCore::FloatSize>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FloatRoundedRect {
            WTFMove(*rect),
            WTFMove(*radiitopLeft),
            WTFMove(*radiitopRight),
            WTFMove(*radiibottomLeft),
            WTFMove(*radiibottomRight)
        }
    };
}

void ArgumentCoder<WebCore::IntRect>::encode(Encoder& encoder, const WebCore::IntRect& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.location())>, WebCore::IntPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size())>, WebCore::IntSize>);

    encoder << instance.location();
    encoder << instance.size();
}

void ArgumentCoder<WebCore::IntRect>::encode(StreamConnectionEncoder& encoder, const WebCore::IntRect& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.location())>, WebCore::IntPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size())>, WebCore::IntSize>);

    encoder << instance.location();
    encoder << instance.size();
}

std::optional<WebCore::IntRect> ArgumentCoder<WebCore::IntRect>::decode(Decoder& decoder)
{
    auto location = decoder.decode<WebCore::IntPoint>();
    auto size = decoder.decode<WebCore::IntSize>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(WebCore::IntRect { *location, *size }.isValid()))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::IntRect {
            WTFMove(*location),
            WTFMove(*size)
        }
    };
}

void ArgumentCoder<WebCore::IntPoint>::encode(Encoder& encoder, const WebCore::IntPoint& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.x())>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.y())>, int>);

    encoder << instance.x();
    encoder << instance.y();
}

void ArgumentCoder<WebCore::IntPoint>::encode(StreamConnectionEncoder& encoder, const WebCore::IntPoint& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.x())>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.y())>, int>);

    encoder << instance.x();
    encoder << instance.y();
}

std::optional<WebCore::IntPoint> ArgumentCoder<WebCore::IntPoint>::decode(Decoder& decoder)
{
    auto x = decoder.decode<int>();
    auto y = decoder.decode<int>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::IntPoint {
            WTFMove(*x),
            WTFMove(*y)
        }
    };
}

void ArgumentCoder<WebCore::IntSize>::encode(Encoder& encoder, const WebCore::IntSize& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.width())>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.height())>, int>);

    encoder << instance.width();
    encoder << instance.height();
}

void ArgumentCoder<WebCore::IntSize>::encode(StreamConnectionEncoder& encoder, const WebCore::IntSize& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.width())>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.height())>, int>);

    encoder << instance.width();
    encoder << instance.height();
}

std::optional<WebCore::IntSize> ArgumentCoder<WebCore::IntSize>::decode(Decoder& decoder)
{
    auto width = decoder.decode<int>();
    auto height = decoder.decode<int>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::IntSize {
            WTFMove(*width),
            WTFMove(*height)
        }
    };
}

void ArgumentCoder<WebCore::FloatSize>::encode(Encoder& encoder, const WebCore::FloatSize& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.width())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.height())>, float>);

    encoder << instance.width();
    encoder << instance.height();
}

void ArgumentCoder<WebCore::FloatSize>::encode(StreamConnectionEncoder& encoder, const WebCore::FloatSize& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.width())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.height())>, float>);

    encoder << instance.width();
    encoder << instance.height();
}

std::optional<WebCore::FloatSize> ArgumentCoder<WebCore::FloatSize>::decode(Decoder& decoder)
{
    auto width = decoder.decode<float>();
    auto height = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FloatSize {
            WTFMove(*width),
            WTFMove(*height)
        }
    };
}

void ArgumentCoder<WebCore::LayoutUnit>::encode(Encoder& encoder, const WebCore::LayoutUnit& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rawValue())>, int>);

    encoder << instance.rawValue();
}

void ArgumentCoder<WebCore::LayoutUnit>::encode(StreamConnectionEncoder& encoder, const WebCore::LayoutUnit& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rawValue())>, int>);

    encoder << instance.rawValue();
}

std::optional<WebCore::LayoutUnit> ArgumentCoder<WebCore::LayoutUnit>::decode(Decoder& decoder)
{
    auto rawValue = decoder.decode<int>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::LayoutUnit::fromRawValue(
            WTFMove(*rawValue)
        )
    };
}

void ArgumentCoder<WebCore::LayoutPoint>::encode(Encoder& encoder, const WebCore::LayoutPoint& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.x())>, WebCore::LayoutUnit>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.y())>, WebCore::LayoutUnit>);

    encoder << instance.x();
    encoder << instance.y();
}

void ArgumentCoder<WebCore::LayoutPoint>::encode(StreamConnectionEncoder& encoder, const WebCore::LayoutPoint& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.x())>, WebCore::LayoutUnit>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.y())>, WebCore::LayoutUnit>);

    encoder << instance.x();
    encoder << instance.y();
}

std::optional<WebCore::LayoutPoint> ArgumentCoder<WebCore::LayoutPoint>::decode(Decoder& decoder)
{
    auto x = decoder.decode<WebCore::LayoutUnit>();
    auto y = decoder.decode<WebCore::LayoutUnit>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::LayoutPoint {
            WTFMove(*x),
            WTFMove(*y)
        }
    };
}

void ArgumentCoder<WebCore::LayoutSize>::encode(Encoder& encoder, const WebCore::LayoutSize& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.width())>, WebCore::LayoutUnit>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.height())>, WebCore::LayoutUnit>);

    encoder << instance.width();
    encoder << instance.height();
}

void ArgumentCoder<WebCore::LayoutSize>::encode(StreamConnectionEncoder& encoder, const WebCore::LayoutSize& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.width())>, WebCore::LayoutUnit>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.height())>, WebCore::LayoutUnit>);

    encoder << instance.width();
    encoder << instance.height();
}

std::optional<WebCore::LayoutSize> ArgumentCoder<WebCore::LayoutSize>::decode(Decoder& decoder)
{
    auto width = decoder.decode<WebCore::LayoutUnit>();
    auto height = decoder.decode<WebCore::LayoutUnit>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::LayoutSize {
            WTFMove(*width),
            WTFMove(*height)
        }
    };
}

void ArgumentCoder<WebCore::DictionaryPopupInfo>::encode(Encoder& encoder, const WebCore::DictionaryPopupInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.origin)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.textIndicator)>, RefPtr<WebCore::TextIndicator>>);
#if ENABLE(LEGACY_PDFKIT_PLUGIN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.platformData)>, WebCore::DictionaryPopupInfoCocoa>);
#endif
#if !(ENABLE(LEGACY_PDFKIT_PLUGIN))
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.text)>, String>);
#endif
    struct ShouldBeSameSizeAsDictionaryPopupInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::DictionaryPopupInfo>, false> {
        WebCore::FloatPoint origin;
        RefPtr<WebCore::TextIndicator> textIndicator;
#if ENABLE(LEGACY_PDFKIT_PLUGIN)
        WebCore::DictionaryPopupInfoCocoa platformData;
#endif
#if !(ENABLE(LEGACY_PDFKIT_PLUGIN))
        String text;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsDictionaryPopupInfo) == sizeof(WebCore::DictionaryPopupInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::DictionaryPopupInfo, origin)
        , offsetof(WebCore::DictionaryPopupInfo, textIndicator)
#if ENABLE(LEGACY_PDFKIT_PLUGIN)
        , offsetof(WebCore::DictionaryPopupInfo, platformData)
#endif
#if !(ENABLE(LEGACY_PDFKIT_PLUGIN))
        , offsetof(WebCore::DictionaryPopupInfo, text)
#endif
    >::value);

    encoder << instance.origin;
    encoder << instance.textIndicator;
#if ENABLE(LEGACY_PDFKIT_PLUGIN)
    encoder << instance.platformData;
#endif
#if !(ENABLE(LEGACY_PDFKIT_PLUGIN))
    encoder << instance.text;
#endif
}

std::optional<WebCore::DictionaryPopupInfo> ArgumentCoder<WebCore::DictionaryPopupInfo>::decode(Decoder& decoder)
{
    auto origin = decoder.decode<WebCore::FloatPoint>();
    auto textIndicator = decoder.decode<RefPtr<WebCore::TextIndicator>>();
#if ENABLE(LEGACY_PDFKIT_PLUGIN)
    auto platformData = decoder.decode<WebCore::DictionaryPopupInfoCocoa>();
#endif
#if !(ENABLE(LEGACY_PDFKIT_PLUGIN))
    auto text = decoder.decode<String>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DictionaryPopupInfo {
            WTFMove(*origin),
            WTFMove(*textIndicator),
#if ENABLE(LEGACY_PDFKIT_PLUGIN)
            WTFMove(*platformData),
#endif
#if !(ENABLE(LEGACY_PDFKIT_PLUGIN))
            WTFMove(*text)
#endif
        }
    };
}

void ArgumentCoder<WebCore::PrivateClickMeasurement>::encode(Encoder& encoder, const WebCore::PrivateClickMeasurement& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceID())>, uint8_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceSite())>, WebCore::PCM::SourceSite>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.destinationSite())>, WebCore::PCM::AttributionDestinationSite>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timeOfAdClick())>, WallTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isEphemeral())>, WebCore::PCM::AttributionEphemeral>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.adamID())>, std::optional<uint64_t>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.attributionTriggerData())>, std::optional<WebCore::PCM::AttributionTriggerData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timesToSend())>, WebCore::PCM::AttributionTimeToSendData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ephemeralSourceNonce())>, std::optional<WebCore::PCM::EphemeralNonce>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceApplicationBundleID())>, String>);

    encoder << instance.sourceID();
    encoder << instance.sourceSite();
    encoder << instance.destinationSite();
    encoder << instance.timeOfAdClick();
    encoder << instance.isEphemeral();
    encoder << instance.adamID();
    encoder << instance.attributionTriggerData();
    encoder << instance.timesToSend();
    encoder << instance.ephemeralSourceNonce();
    encoder << instance.sourceApplicationBundleID();
}

std::optional<WebCore::PrivateClickMeasurement> ArgumentCoder<WebCore::PrivateClickMeasurement>::decode(Decoder& decoder)
{
    auto sourceID = decoder.decode<uint8_t>();
    auto sourceSite = decoder.decode<WebCore::PCM::SourceSite>();
    auto destinationSite = decoder.decode<WebCore::PCM::AttributionDestinationSite>();
    auto timeOfAdClick = decoder.decode<WallTime>();
    auto isEphemeral = decoder.decode<WebCore::PCM::AttributionEphemeral>();
    auto adamID = decoder.decode<std::optional<uint64_t>>();
    auto attributionTriggerData = decoder.decode<std::optional<WebCore::PCM::AttributionTriggerData>>();
    auto timesToSend = decoder.decode<WebCore::PCM::AttributionTimeToSendData>();
    auto ephemeralSourceNonce = decoder.decode<std::optional<WebCore::PCM::EphemeralNonce>>();
    auto sourceApplicationBundleID = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PrivateClickMeasurement {
            WTFMove(*sourceID),
            WTFMove(*sourceSite),
            WTFMove(*destinationSite),
            WTFMove(*timeOfAdClick),
            WTFMove(*isEphemeral),
            WTFMove(*adamID),
            WTFMove(*attributionTriggerData),
            WTFMove(*timesToSend),
            WTFMove(*ephemeralSourceNonce),
            WTFMove(*sourceApplicationBundleID)
        }
    };
}

void ArgumentCoder<WebCore::PCM::SourceSite>::encode(Encoder& encoder, const WebCore::PCM::SourceSite& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.registrableDomain)>, WebCore::RegistrableDomain>);
    struct ShouldBeSameSizeAsSourceSite : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PCM::SourceSite>, false> {
        WebCore::RegistrableDomain registrableDomain;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSourceSite) == sizeof(WebCore::PCM::SourceSite));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PCM::SourceSite, registrableDomain)
    >::value);

    encoder << instance.registrableDomain;
}

std::optional<WebCore::PCM::SourceSite> ArgumentCoder<WebCore::PCM::SourceSite>::decode(Decoder& decoder)
{
    auto registrableDomain = decoder.decode<WebCore::RegistrableDomain>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PCM::SourceSite {
            WTFMove(*registrableDomain)
        }
    };
}

void ArgumentCoder<WebCore::PCM::AttributionDestinationSite>::encode(Encoder& encoder, const WebCore::PCM::AttributionDestinationSite& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.registrableDomain)>, WebCore::RegistrableDomain>);
    struct ShouldBeSameSizeAsAttributionDestinationSite : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PCM::AttributionDestinationSite>, false> {
        WebCore::RegistrableDomain registrableDomain;
    };
    static_assert(sizeof(ShouldBeSameSizeAsAttributionDestinationSite) == sizeof(WebCore::PCM::AttributionDestinationSite));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PCM::AttributionDestinationSite, registrableDomain)
    >::value);

    encoder << instance.registrableDomain;
}

std::optional<WebCore::PCM::AttributionDestinationSite> ArgumentCoder<WebCore::PCM::AttributionDestinationSite>::decode(Decoder& decoder)
{
    auto registrableDomain = decoder.decode<WebCore::RegistrableDomain>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PCM::AttributionDestinationSite {
            WTFMove(*registrableDomain)
        }
    };
}

void ArgumentCoder<WebCore::PCM::EphemeralNonce>::encode(Encoder& encoder, const WebCore::PCM::EphemeralNonce& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.nonce)>, String>);
    struct ShouldBeSameSizeAsEphemeralNonce : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PCM::EphemeralNonce>, false> {
        String nonce;
    };
    static_assert(sizeof(ShouldBeSameSizeAsEphemeralNonce) == sizeof(WebCore::PCM::EphemeralNonce));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PCM::EphemeralNonce, nonce)
    >::value);

    encoder << instance.nonce;
}

std::optional<WebCore::PCM::EphemeralNonce> ArgumentCoder<WebCore::PCM::EphemeralNonce>::decode(Decoder& decoder)
{
    auto nonce = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PCM::EphemeralNonce {
            WTFMove(*nonce)
        }
    };
}

void ArgumentCoder<WebCore::PCM::AttributionTriggerData>::encode(Encoder& encoder, const WebCore::PCM::AttributionTriggerData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data)>, uint8_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.priority)>, uint8_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.wasSent)>, WebCore::PCM::WasSent>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceRegistrableDomain)>, std::optional<WebCore::RegistrableDomain>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ephemeralDestinationNonce)>, std::optional<WebCore::PCM::EphemeralNonce>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.destinationSite)>, std::optional<WebCore::RegistrableDomain>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.destinationUnlinkableToken)>, std::optional<WebCore::PCM::DestinationUnlinkableToken>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.destinationSecretToken)>, std::optional<WebCore::PCM::DestinationSecretToken>>);
    struct ShouldBeSameSizeAsAttributionTriggerData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PCM::AttributionTriggerData>, false> {
        uint8_t data;
        uint8_t priority;
        WebCore::PCM::WasSent wasSent;
        std::optional<WebCore::RegistrableDomain> sourceRegistrableDomain;
        std::optional<WebCore::PCM::EphemeralNonce> ephemeralDestinationNonce;
        std::optional<WebCore::RegistrableDomain> destinationSite;
        std::optional<WebCore::PCM::DestinationUnlinkableToken> destinationUnlinkableToken;
        std::optional<WebCore::PCM::DestinationSecretToken> destinationSecretToken;
    };
    static_assert(sizeof(ShouldBeSameSizeAsAttributionTriggerData) == sizeof(WebCore::PCM::AttributionTriggerData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PCM::AttributionTriggerData, data)
        , offsetof(WebCore::PCM::AttributionTriggerData, priority)
        , offsetof(WebCore::PCM::AttributionTriggerData, wasSent)
        , offsetof(WebCore::PCM::AttributionTriggerData, sourceRegistrableDomain)
        , offsetof(WebCore::PCM::AttributionTriggerData, ephemeralDestinationNonce)
        , offsetof(WebCore::PCM::AttributionTriggerData, destinationSite)
        , offsetof(WebCore::PCM::AttributionTriggerData, destinationUnlinkableToken)
        , offsetof(WebCore::PCM::AttributionTriggerData, destinationSecretToken)
    >::value);

    encoder << instance.data;
    encoder << instance.priority;
    encoder << instance.wasSent;
    encoder << instance.sourceRegistrableDomain;
    encoder << instance.ephemeralDestinationNonce;
    encoder << instance.destinationSite;
}

std::optional<WebCore::PCM::AttributionTriggerData> ArgumentCoder<WebCore::PCM::AttributionTriggerData>::decode(Decoder& decoder)
{
    auto data = decoder.decode<uint8_t>();
    auto priority = decoder.decode<uint8_t>();
    auto wasSent = decoder.decode<WebCore::PCM::WasSent>();
    auto sourceRegistrableDomain = decoder.decode<std::optional<WebCore::RegistrableDomain>>();
    auto ephemeralDestinationNonce = decoder.decode<std::optional<WebCore::PCM::EphemeralNonce>>();
    auto destinationSite = decoder.decode<std::optional<WebCore::RegistrableDomain>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PCM::AttributionTriggerData {
            WTFMove(*data),
            WTFMove(*priority),
            WTFMove(*wasSent),
            WTFMove(*sourceRegistrableDomain),
            WTFMove(*ephemeralDestinationNonce),
            WTFMove(*destinationSite)
        }
    };
}

void ArgumentCoder<WebCore::PCM::AttributionTimeToSendData>::encode(Encoder& encoder, const WebCore::PCM::AttributionTimeToSendData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceEarliestTimeToSend)>, std::optional<WallTime>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.destinationEarliestTimeToSend)>, std::optional<WallTime>>);
    struct ShouldBeSameSizeAsAttributionTimeToSendData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PCM::AttributionTimeToSendData>, false> {
        std::optional<WallTime> sourceEarliestTimeToSend;
        std::optional<WallTime> destinationEarliestTimeToSend;
    };
    static_assert(sizeof(ShouldBeSameSizeAsAttributionTimeToSendData) == sizeof(WebCore::PCM::AttributionTimeToSendData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PCM::AttributionTimeToSendData, sourceEarliestTimeToSend)
        , offsetof(WebCore::PCM::AttributionTimeToSendData, destinationEarliestTimeToSend)
    >::value);

    encoder << instance.sourceEarliestTimeToSend;
    encoder << instance.destinationEarliestTimeToSend;
}

std::optional<WebCore::PCM::AttributionTimeToSendData> ArgumentCoder<WebCore::PCM::AttributionTimeToSendData>::decode(Decoder& decoder)
{
    auto sourceEarliestTimeToSend = decoder.decode<std::optional<WallTime>>();
    auto destinationEarliestTimeToSend = decoder.decode<std::optional<WallTime>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PCM::AttributionTimeToSendData {
            WTFMove(*sourceEarliestTimeToSend),
            WTFMove(*destinationEarliestTimeToSend)
        }
    };
}

#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
void ArgumentCoder<WebCore::ApplePayRecurringPaymentRequest>::encode(Encoder& encoder, const WebCore::ApplePayRecurringPaymentRequest& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.paymentDescription)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.regularBilling)>, WebCore::ApplePayLineItem>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.trialBilling)>, std::optional<WebCore::ApplePayLineItem>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.billingAgreement)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.managementURL)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tokenNotificationURL)>, String>);
    struct ShouldBeSameSizeAsApplePayRecurringPaymentRequest : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ApplePayRecurringPaymentRequest>, false> {
        String paymentDescription;
        WebCore::ApplePayLineItem regularBilling;
        std::optional<WebCore::ApplePayLineItem> trialBilling;
        String billingAgreement;
        String managementURL;
        String tokenNotificationURL;
    };
    static_assert(sizeof(ShouldBeSameSizeAsApplePayRecurringPaymentRequest) == sizeof(WebCore::ApplePayRecurringPaymentRequest));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ApplePayRecurringPaymentRequest, paymentDescription)
        , offsetof(WebCore::ApplePayRecurringPaymentRequest, regularBilling)
        , offsetof(WebCore::ApplePayRecurringPaymentRequest, trialBilling)
        , offsetof(WebCore::ApplePayRecurringPaymentRequest, billingAgreement)
        , offsetof(WebCore::ApplePayRecurringPaymentRequest, managementURL)
        , offsetof(WebCore::ApplePayRecurringPaymentRequest, tokenNotificationURL)
    >::value);

    encoder << instance.paymentDescription;
    encoder << instance.regularBilling;
    encoder << instance.trialBilling;
    encoder << instance.billingAgreement;
    encoder << instance.managementURL;
    encoder << instance.tokenNotificationURL;
}

std::optional<WebCore::ApplePayRecurringPaymentRequest> ArgumentCoder<WebCore::ApplePayRecurringPaymentRequest>::decode(Decoder& decoder)
{
    auto paymentDescription = decoder.decode<String>();
    auto regularBilling = decoder.decode<WebCore::ApplePayLineItem>();
    auto trialBilling = decoder.decode<std::optional<WebCore::ApplePayLineItem>>();
    auto billingAgreement = decoder.decode<String>();
    auto managementURL = decoder.decode<String>();
    auto tokenNotificationURL = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ApplePayRecurringPaymentRequest {
            WTFMove(*paymentDescription),
            WTFMove(*regularBilling),
            WTFMove(*trialBilling),
            WTFMove(*billingAgreement),
            WTFMove(*managementURL),
            WTFMove(*tokenNotificationURL)
        }
    };
}

#endif

#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
void ArgumentCoder<WebCore::ApplePayPaymentTokenContext>::encode(Encoder& encoder, const WebCore::ApplePayPaymentTokenContext& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.merchantIdentifier)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.externalIdentifier)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.merchantName)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.merchantDomain)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.amount)>, String>);
    struct ShouldBeSameSizeAsApplePayPaymentTokenContext : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ApplePayPaymentTokenContext>, false> {
        String merchantIdentifier;
        String externalIdentifier;
        String merchantName;
        String merchantDomain;
        String amount;
    };
    static_assert(sizeof(ShouldBeSameSizeAsApplePayPaymentTokenContext) == sizeof(WebCore::ApplePayPaymentTokenContext));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ApplePayPaymentTokenContext, merchantIdentifier)
        , offsetof(WebCore::ApplePayPaymentTokenContext, externalIdentifier)
        , offsetof(WebCore::ApplePayPaymentTokenContext, merchantName)
        , offsetof(WebCore::ApplePayPaymentTokenContext, merchantDomain)
        , offsetof(WebCore::ApplePayPaymentTokenContext, amount)
    >::value);

    encoder << instance.merchantIdentifier;
    encoder << instance.externalIdentifier;
    encoder << instance.merchantName;
    encoder << instance.merchantDomain;
    encoder << instance.amount;
}

std::optional<WebCore::ApplePayPaymentTokenContext> ArgumentCoder<WebCore::ApplePayPaymentTokenContext>::decode(Decoder& decoder)
{
    auto merchantIdentifier = decoder.decode<String>();
    auto externalIdentifier = decoder.decode<String>();
    auto merchantName = decoder.decode<String>();
    auto merchantDomain = decoder.decode<String>();
    auto amount = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ApplePayPaymentTokenContext {
            WTFMove(*merchantIdentifier),
            WTFMove(*externalIdentifier),
            WTFMove(*merchantName),
            WTFMove(*merchantDomain),
            WTFMove(*amount)
        }
    };
}

#endif

#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
void ArgumentCoder<WebCore::ApplePayDeferredPaymentRequest>::encode(Encoder& encoder, const WebCore::ApplePayDeferredPaymentRequest& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.billingAgreement)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.deferredBilling)>, WebCore::ApplePayLineItem>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.freeCancellationDate)>, WallTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.freeCancellationDateTimeZone)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.managementURL)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.paymentDescription)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tokenNotificationURL)>, String>);
    struct ShouldBeSameSizeAsApplePayDeferredPaymentRequest : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ApplePayDeferredPaymentRequest>, false> {
        String billingAgreement;
        WebCore::ApplePayLineItem deferredBilling;
        WallTime freeCancellationDate;
        String freeCancellationDateTimeZone;
        String managementURL;
        String paymentDescription;
        String tokenNotificationURL;
    };
    static_assert(sizeof(ShouldBeSameSizeAsApplePayDeferredPaymentRequest) == sizeof(WebCore::ApplePayDeferredPaymentRequest));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ApplePayDeferredPaymentRequest, billingAgreement)
        , offsetof(WebCore::ApplePayDeferredPaymentRequest, deferredBilling)
        , offsetof(WebCore::ApplePayDeferredPaymentRequest, freeCancellationDate)
        , offsetof(WebCore::ApplePayDeferredPaymentRequest, freeCancellationDateTimeZone)
        , offsetof(WebCore::ApplePayDeferredPaymentRequest, managementURL)
        , offsetof(WebCore::ApplePayDeferredPaymentRequest, paymentDescription)
        , offsetof(WebCore::ApplePayDeferredPaymentRequest, tokenNotificationURL)
    >::value);

    encoder << instance.billingAgreement;
    encoder << instance.deferredBilling;
    encoder << instance.freeCancellationDate;
    encoder << instance.freeCancellationDateTimeZone;
    encoder << instance.managementURL;
    encoder << instance.paymentDescription;
    encoder << instance.tokenNotificationURL;
}

std::optional<WebCore::ApplePayDeferredPaymentRequest> ArgumentCoder<WebCore::ApplePayDeferredPaymentRequest>::decode(Decoder& decoder)
{
    auto billingAgreement = decoder.decode<String>();
    auto deferredBilling = decoder.decode<WebCore::ApplePayLineItem>();
    auto freeCancellationDate = decoder.decode<WallTime>();
    auto freeCancellationDateTimeZone = decoder.decode<String>();
    auto managementURL = decoder.decode<String>();
    auto paymentDescription = decoder.decode<String>();
    auto tokenNotificationURL = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ApplePayDeferredPaymentRequest {
            WTFMove(*billingAgreement),
            WTFMove(*deferredBilling),
            WTFMove(*freeCancellationDate),
            WTFMove(*freeCancellationDateTimeZone),
            WTFMove(*managementURL),
            WTFMove(*paymentDescription),
            WTFMove(*tokenNotificationURL)
        }
    };
}

#endif

#if ENABLE(APPLE_PAY_PAYMENT_ORDER_DETAILS)
void ArgumentCoder<WebCore::ApplePayPaymentOrderDetails>::encode(Encoder& encoder, const WebCore::ApplePayPaymentOrderDetails& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.orderTypeIdentifier)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.orderIdentifier)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webServiceURL)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.authenticationToken)>, String>);
    struct ShouldBeSameSizeAsApplePayPaymentOrderDetails : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ApplePayPaymentOrderDetails>, false> {
        String orderTypeIdentifier;
        String orderIdentifier;
        String webServiceURL;
        String authenticationToken;
    };
    static_assert(sizeof(ShouldBeSameSizeAsApplePayPaymentOrderDetails) == sizeof(WebCore::ApplePayPaymentOrderDetails));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ApplePayPaymentOrderDetails, orderTypeIdentifier)
        , offsetof(WebCore::ApplePayPaymentOrderDetails, orderIdentifier)
        , offsetof(WebCore::ApplePayPaymentOrderDetails, webServiceURL)
        , offsetof(WebCore::ApplePayPaymentOrderDetails, authenticationToken)
    >::value);

    encoder << instance.orderTypeIdentifier;
    encoder << instance.orderIdentifier;
    encoder << instance.webServiceURL;
    encoder << instance.authenticationToken;
}

std::optional<WebCore::ApplePayPaymentOrderDetails> ArgumentCoder<WebCore::ApplePayPaymentOrderDetails>::decode(Decoder& decoder)
{
    auto orderTypeIdentifier = decoder.decode<String>();
    auto orderIdentifier = decoder.decode<String>();
    auto webServiceURL = decoder.decode<String>();
    auto authenticationToken = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ApplePayPaymentOrderDetails {
            WTFMove(*orderTypeIdentifier),
            WTFMove(*orderIdentifier),
            WTFMove(*webServiceURL),
            WTFMove(*authenticationToken)
        }
    };
}

#endif

#if ENABLE(APPLE_PAY_AMS_UI) && ENABLE(PAYMENT_REQUEST)
void ArgumentCoder<WebCore::ApplePayAMSUIRequest>::encode(Encoder& encoder, const WebCore::ApplePayAMSUIRequest& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.engagementRequest)>, String>);
    struct ShouldBeSameSizeAsApplePayAMSUIRequest : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ApplePayAMSUIRequest>, false> {
        String engagementRequest;
    };
    static_assert(sizeof(ShouldBeSameSizeAsApplePayAMSUIRequest) == sizeof(WebCore::ApplePayAMSUIRequest));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ApplePayAMSUIRequest, engagementRequest)
    >::value);

    encoder << instance.engagementRequest;
}

std::optional<WebCore::ApplePayAMSUIRequest> ArgumentCoder<WebCore::ApplePayAMSUIRequest>::decode(Decoder& decoder)
{
    auto engagementRequest = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ApplePayAMSUIRequest {
            WTFMove(*engagementRequest)
        }
    };
}

#endif

#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
void ArgumentCoder<WebCore::ApplePayAutomaticReloadPaymentRequest>::encode(Encoder& encoder, const WebCore::ApplePayAutomaticReloadPaymentRequest& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.paymentDescription)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.automaticReloadBilling)>, WebCore::ApplePayLineItem>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.billingAgreement)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.managementURL)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tokenNotificationURL)>, String>);
    struct ShouldBeSameSizeAsApplePayAutomaticReloadPaymentRequest : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ApplePayAutomaticReloadPaymentRequest>, false> {
        String paymentDescription;
        WebCore::ApplePayLineItem automaticReloadBilling;
        String billingAgreement;
        String managementURL;
        String tokenNotificationURL;
    };
    static_assert(sizeof(ShouldBeSameSizeAsApplePayAutomaticReloadPaymentRequest) == sizeof(WebCore::ApplePayAutomaticReloadPaymentRequest));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ApplePayAutomaticReloadPaymentRequest, paymentDescription)
        , offsetof(WebCore::ApplePayAutomaticReloadPaymentRequest, automaticReloadBilling)
        , offsetof(WebCore::ApplePayAutomaticReloadPaymentRequest, billingAgreement)
        , offsetof(WebCore::ApplePayAutomaticReloadPaymentRequest, managementURL)
        , offsetof(WebCore::ApplePayAutomaticReloadPaymentRequest, tokenNotificationURL)
    >::value);

    encoder << instance.paymentDescription;
    encoder << instance.automaticReloadBilling;
    encoder << instance.billingAgreement;
    encoder << instance.managementURL;
    encoder << instance.tokenNotificationURL;
}

std::optional<WebCore::ApplePayAutomaticReloadPaymentRequest> ArgumentCoder<WebCore::ApplePayAutomaticReloadPaymentRequest>::decode(Decoder& decoder)
{
    auto paymentDescription = decoder.decode<String>();
    auto automaticReloadBilling = decoder.decode<WebCore::ApplePayLineItem>();
    auto billingAgreement = decoder.decode<String>();
    auto managementURL = decoder.decode<String>();
    auto tokenNotificationURL = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ApplePayAutomaticReloadPaymentRequest {
            WTFMove(*paymentDescription),
            WTFMove(*automaticReloadBilling),
            WTFMove(*billingAgreement),
            WTFMove(*managementURL),
            WTFMove(*tokenNotificationURL)
        }
    };
}

#endif

#if ENABLE(APPLE_PAY_SHIPPING_METHOD_DATE_COMPONENTS_RANGE)
void ArgumentCoder<WebCore::ApplePayDateComponents>::encode(Encoder& encoder, const WebCore::ApplePayDateComponents& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.years)>, std::optional<unsigned>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.months)>, std::optional<unsigned>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.days)>, std::optional<unsigned>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hours)>, std::optional<unsigned>>);
    struct ShouldBeSameSizeAsApplePayDateComponents : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ApplePayDateComponents>, false> {
        std::optional<unsigned> years;
        std::optional<unsigned> months;
        std::optional<unsigned> days;
        std::optional<unsigned> hours;
    };
    static_assert(sizeof(ShouldBeSameSizeAsApplePayDateComponents) == sizeof(WebCore::ApplePayDateComponents));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ApplePayDateComponents, years)
        , offsetof(WebCore::ApplePayDateComponents, months)
        , offsetof(WebCore::ApplePayDateComponents, days)
        , offsetof(WebCore::ApplePayDateComponents, hours)
    >::value);

    encoder << instance.years;
    encoder << instance.months;
    encoder << instance.days;
    encoder << instance.hours;
}

std::optional<WebCore::ApplePayDateComponents> ArgumentCoder<WebCore::ApplePayDateComponents>::decode(Decoder& decoder)
{
    auto years = decoder.decode<std::optional<unsigned>>();
    auto months = decoder.decode<std::optional<unsigned>>();
    auto days = decoder.decode<std::optional<unsigned>>();
    auto hours = decoder.decode<std::optional<unsigned>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ApplePayDateComponents {
            WTFMove(*years),
            WTFMove(*months),
            WTFMove(*days),
            WTFMove(*hours)
        }
    };
}

#endif

#if ENABLE(APPLE_PAY_SHIPPING_METHOD_DATE_COMPONENTS_RANGE)
void ArgumentCoder<WebCore::ApplePayDateComponentsRange>::encode(Encoder& encoder, const WebCore::ApplePayDateComponentsRange& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.startDateComponents)>, WebCore::ApplePayDateComponents>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.endDateComponents)>, WebCore::ApplePayDateComponents>);
    struct ShouldBeSameSizeAsApplePayDateComponentsRange : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ApplePayDateComponentsRange>, false> {
        WebCore::ApplePayDateComponents startDateComponents;
        WebCore::ApplePayDateComponents endDateComponents;
    };
    static_assert(sizeof(ShouldBeSameSizeAsApplePayDateComponentsRange) == sizeof(WebCore::ApplePayDateComponentsRange));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ApplePayDateComponentsRange, startDateComponents)
        , offsetof(WebCore::ApplePayDateComponentsRange, endDateComponents)
    >::value);

    encoder << instance.startDateComponents;
    encoder << instance.endDateComponents;
}

std::optional<WebCore::ApplePayDateComponentsRange> ArgumentCoder<WebCore::ApplePayDateComponentsRange>::decode(Decoder& decoder)
{
    auto startDateComponents = decoder.decode<WebCore::ApplePayDateComponents>();
    auto endDateComponents = decoder.decode<WebCore::ApplePayDateComponents>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ApplePayDateComponentsRange {
            WTFMove(*startDateComponents),
            WTFMove(*endDateComponents)
        }
    };
}

#endif

#if ENABLE(APPLE_PAY)
void ArgumentCoder<WebCore::ApplePaySetupConfiguration>::encode(Encoder& encoder, const WebCore::ApplePaySetupConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.merchantIdentifier)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.referrerIdentifier)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.signature)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.signedFields)>, Vector<String>>);
    struct ShouldBeSameSizeAsApplePaySetupConfiguration : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ApplePaySetupConfiguration>, false> {
        String merchantIdentifier;
        String referrerIdentifier;
        String signature;
        Vector<String> signedFields;
    };
    static_assert(sizeof(ShouldBeSameSizeAsApplePaySetupConfiguration) == sizeof(WebCore::ApplePaySetupConfiguration));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ApplePaySetupConfiguration, merchantIdentifier)
        , offsetof(WebCore::ApplePaySetupConfiguration, referrerIdentifier)
        , offsetof(WebCore::ApplePaySetupConfiguration, signature)
        , offsetof(WebCore::ApplePaySetupConfiguration, signedFields)
    >::value);

    encoder << instance.merchantIdentifier;
    encoder << instance.referrerIdentifier;
    encoder << instance.signature;
    encoder << instance.signedFields;
}

std::optional<WebCore::ApplePaySetupConfiguration> ArgumentCoder<WebCore::ApplePaySetupConfiguration>::decode(Decoder& decoder)
{
    auto merchantIdentifier = decoder.decode<String>();
    auto referrerIdentifier = decoder.decode<String>();
    auto signature = decoder.decode<String>();
    auto signedFields = decoder.decode<Vector<String>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ApplePaySetupConfiguration {
            WTFMove(*merchantIdentifier),
            WTFMove(*referrerIdentifier),
            WTFMove(*signature),
            WTFMove(*signedFields)
        }
    };
}

#endif

#if ENABLE(APPLE_PAY)
void ArgumentCoder<WebCore::ApplePayLineItem>::encode(Encoder& encoder, const WebCore::ApplePayLineItem& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::ApplePayLineItem::Type>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.amount)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.paymentTiming)>, WebCore::ApplePayPaymentTiming>);
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.recurringPaymentStartDate)>, WallTime>);
#endif
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.recurringPaymentIntervalUnit)>, WebCore::ApplePayRecurringPaymentDateUnit>);
#endif
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.recurringPaymentIntervalCount)>, unsigned>);
#endif
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.recurringPaymentEndDate)>, WallTime>);
#endif
#if ENABLE(APPLE_PAY_DEFERRED_LINE_ITEM)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.deferredPaymentDate)>, WallTime>);
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_LINE_ITEM)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.automaticReloadPaymentThresholdAmount)>, String>);
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.disbursementLineItemType)>, std::optional<WebCore::ApplePayLineItem::DisbursementLineItemType>>);
#endif
    struct ShouldBeSameSizeAsApplePayLineItem : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ApplePayLineItem>, false> {
        WebCore::ApplePayLineItem::Type type;
        String label;
        String amount;
        WebCore::ApplePayPaymentTiming paymentTiming;
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
        WallTime recurringPaymentStartDate;
#endif
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
        WebCore::ApplePayRecurringPaymentDateUnit recurringPaymentIntervalUnit;
#endif
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
        unsigned recurringPaymentIntervalCount;
#endif
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
        WallTime recurringPaymentEndDate;
#endif
#if ENABLE(APPLE_PAY_DEFERRED_LINE_ITEM)
        WallTime deferredPaymentDate;
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_LINE_ITEM)
        String automaticReloadPaymentThresholdAmount;
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
        std::optional<WebCore::ApplePayLineItem::DisbursementLineItemType> disbursementLineItemType;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsApplePayLineItem) == sizeof(WebCore::ApplePayLineItem));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ApplePayLineItem, type)
        , offsetof(WebCore::ApplePayLineItem, label)
        , offsetof(WebCore::ApplePayLineItem, amount)
        , offsetof(WebCore::ApplePayLineItem, paymentTiming)
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
        , offsetof(WebCore::ApplePayLineItem, recurringPaymentStartDate)
#endif
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
        , offsetof(WebCore::ApplePayLineItem, recurringPaymentIntervalUnit)
#endif
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
        , offsetof(WebCore::ApplePayLineItem, recurringPaymentIntervalCount)
#endif
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
        , offsetof(WebCore::ApplePayLineItem, recurringPaymentEndDate)
#endif
#if ENABLE(APPLE_PAY_DEFERRED_LINE_ITEM)
        , offsetof(WebCore::ApplePayLineItem, deferredPaymentDate)
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_LINE_ITEM)
        , offsetof(WebCore::ApplePayLineItem, automaticReloadPaymentThresholdAmount)
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
        , offsetof(WebCore::ApplePayLineItem, disbursementLineItemType)
#endif
    >::value);

    encoder << instance.type;
    encoder << instance.label;
    encoder << instance.amount;
    encoder << instance.paymentTiming;
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
    encoder << instance.recurringPaymentStartDate;
#endif
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
    encoder << instance.recurringPaymentIntervalUnit;
#endif
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
    encoder << instance.recurringPaymentIntervalCount;
#endif
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
    encoder << instance.recurringPaymentEndDate;
#endif
#if ENABLE(APPLE_PAY_DEFERRED_LINE_ITEM)
    encoder << instance.deferredPaymentDate;
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_LINE_ITEM)
    encoder << instance.automaticReloadPaymentThresholdAmount;
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
    encoder << instance.disbursementLineItemType;
#endif
}

std::optional<WebCore::ApplePayLineItem> ArgumentCoder<WebCore::ApplePayLineItem>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::ApplePayLineItem::Type>();
    auto label = decoder.decode<String>();
    auto amount = decoder.decode<String>();
    auto paymentTiming = decoder.decode<WebCore::ApplePayPaymentTiming>();
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
    auto recurringPaymentStartDate = decoder.decode<WallTime>();
#endif
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
    auto recurringPaymentIntervalUnit = decoder.decode<WebCore::ApplePayRecurringPaymentDateUnit>();
#endif
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
    auto recurringPaymentIntervalCount = decoder.decode<unsigned>();
#endif
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
    auto recurringPaymentEndDate = decoder.decode<WallTime>();
#endif
#if ENABLE(APPLE_PAY_DEFERRED_LINE_ITEM)
    auto deferredPaymentDate = decoder.decode<WallTime>();
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_LINE_ITEM)
    auto automaticReloadPaymentThresholdAmount = decoder.decode<String>();
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
    auto disbursementLineItemType = decoder.decode<std::optional<WebCore::ApplePayLineItem::DisbursementLineItemType>>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ApplePayLineItem {
            WTFMove(*type),
            WTFMove(*label),
            WTFMove(*amount),
            WTFMove(*paymentTiming),
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
            WTFMove(*recurringPaymentStartDate),
#endif
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
            WTFMove(*recurringPaymentIntervalUnit),
#endif
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
            WTFMove(*recurringPaymentIntervalCount),
#endif
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
            WTFMove(*recurringPaymentEndDate),
#endif
#if ENABLE(APPLE_PAY_DEFERRED_LINE_ITEM)
            WTFMove(*deferredPaymentDate),
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_LINE_ITEM)
            WTFMove(*automaticReloadPaymentThresholdAmount),
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
            WTFMove(*disbursementLineItemType)
#endif
        }
    };
}

#endif

#if ENABLE(APPLE_PAY)
void ArgumentCoder<WebCore::ApplePayShippingMethod>::encode(Encoder& encoder, const WebCore::ApplePayShippingMethod& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.detail)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.amount)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, String>);
#if ENABLE(APPLE_PAY_SHIPPING_METHOD_DATE_COMPONENTS_RANGE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dateComponentsRange)>, std::optional<WebCore::ApplePayDateComponentsRange>>);
#endif
#if ENABLE(APPLE_PAY_SELECTED_SHIPPING_METHOD)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selected)>, bool>);
#endif
    struct ShouldBeSameSizeAsApplePayShippingMethod : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ApplePayShippingMethod>, false> {
        String label;
        String detail;
        String amount;
        String identifier;
#if ENABLE(APPLE_PAY_SHIPPING_METHOD_DATE_COMPONENTS_RANGE)
        std::optional<WebCore::ApplePayDateComponentsRange> dateComponentsRange;
#endif
#if ENABLE(APPLE_PAY_SELECTED_SHIPPING_METHOD)
        bool selected;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsApplePayShippingMethod) == sizeof(WebCore::ApplePayShippingMethod));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ApplePayShippingMethod, label)
        , offsetof(WebCore::ApplePayShippingMethod, detail)
        , offsetof(WebCore::ApplePayShippingMethod, amount)
        , offsetof(WebCore::ApplePayShippingMethod, identifier)
#if ENABLE(APPLE_PAY_SHIPPING_METHOD_DATE_COMPONENTS_RANGE)
        , offsetof(WebCore::ApplePayShippingMethod, dateComponentsRange)
#endif
#if ENABLE(APPLE_PAY_SELECTED_SHIPPING_METHOD)
        , offsetof(WebCore::ApplePayShippingMethod, selected)
#endif
    >::value);

    encoder << instance.label;
    encoder << instance.detail;
    encoder << instance.amount;
    encoder << instance.identifier;
#if ENABLE(APPLE_PAY_SHIPPING_METHOD_DATE_COMPONENTS_RANGE)
    encoder << instance.dateComponentsRange;
#endif
#if ENABLE(APPLE_PAY_SELECTED_SHIPPING_METHOD)
    encoder << instance.selected;
#endif
}

std::optional<WebCore::ApplePayShippingMethod> ArgumentCoder<WebCore::ApplePayShippingMethod>::decode(Decoder& decoder)
{
    auto label = decoder.decode<String>();
    auto detail = decoder.decode<String>();
    auto amount = decoder.decode<String>();
    auto identifier = decoder.decode<String>();
#if ENABLE(APPLE_PAY_SHIPPING_METHOD_DATE_COMPONENTS_RANGE)
    auto dateComponentsRange = decoder.decode<std::optional<WebCore::ApplePayDateComponentsRange>>();
#endif
#if ENABLE(APPLE_PAY_SELECTED_SHIPPING_METHOD)
    auto selected = decoder.decode<bool>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ApplePayShippingMethod {
            WTFMove(*label),
            WTFMove(*detail),
            WTFMove(*amount),
            WTFMove(*identifier),
#if ENABLE(APPLE_PAY_SHIPPING_METHOD_DATE_COMPONENTS_RANGE)
            WTFMove(*dateComponentsRange),
#endif
#if ENABLE(APPLE_PAY_SELECTED_SHIPPING_METHOD)
            WTFMove(*selected)
#endif
        }
    };
}

#endif

#if ENABLE(APPLE_PAY)
void ArgumentCoder<WebCore::ApplePayError>::encode(Encoder& encoder, const WebCore::ApplePayError& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.code())>, WebCore::ApplePayErrorCode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contactField())>, std::optional<WebCore::ApplePayErrorContactField>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.message())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.domain())>, std::optional<WebCore::ApplePayError::Domain>>);

    encoder << instance.code();
    encoder << instance.contactField();
    encoder << instance.message();
    encoder << instance.domain();
}

std::optional<Ref<WebCore::ApplePayError>> ArgumentCoder<WebCore::ApplePayError>::decode(Decoder& decoder)
{
    auto code = decoder.decode<WebCore::ApplePayErrorCode>();
    auto contactField = decoder.decode<std::optional<WebCore::ApplePayErrorContactField>>();
    auto message = decoder.decode<String>();
    auto domain = decoder.decode<std::optional<WebCore::ApplePayError::Domain>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ApplePayError::create(
            WTFMove(*code),
            WTFMove(*contactField),
            WTFMove(*message),
            WTFMove(*domain)
        )
    };
}

#endif

#if ENABLE(APPLE_PAY)
void ArgumentCoder<WebCore::ApplePayLogoSystemImage>::encode(Encoder& encoder, const WebCore::ApplePayLogoSystemImage& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.applePayLogoStyle())>, WebCore::ApplePayLogoStyle>);

    encoder << instance.applePayLogoStyle();
}

void ArgumentCoder<WebCore::ApplePayLogoSystemImage>::encode(StreamConnectionEncoder& encoder, const WebCore::ApplePayLogoSystemImage& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.applePayLogoStyle())>, WebCore::ApplePayLogoStyle>);

    encoder << instance.applePayLogoStyle();
}

std::optional<Ref<WebCore::ApplePayLogoSystemImage>> ArgumentCoder<WebCore::ApplePayLogoSystemImage>::decode(Decoder& decoder)
{
    auto applePayLogoStyle = decoder.decode<WebCore::ApplePayLogoStyle>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ApplePayLogoSystemImage::create(
            WTFMove(*applePayLogoStyle)
        )
    };
}

#endif

#if ENABLE(APPLE_PAY)
void ArgumentCoder<WebCore::ApplePayDetailsUpdateBase>::encode(Encoder& encoder, const WebCore::ApplePayDetailsUpdateBase& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newTotal)>, WebCore::ApplePayLineItem>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newLineItems)>, Vector<WebCore::ApplePayLineItem>>);
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newRecurringPaymentRequest)>, std::optional<WebCore::ApplePayRecurringPaymentRequest>>);
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newAutomaticReloadPaymentRequest)>, std::optional<WebCore::ApplePayAutomaticReloadPaymentRequest>>);
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newMultiTokenContexts)>, std::optional<Vector<WebCore::ApplePayPaymentTokenContext>>>);
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newDeferredPaymentRequest)>, std::optional<WebCore::ApplePayDeferredPaymentRequest>>);
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newDisbursementRequest)>, std::optional<WebCore::ApplePayDisbursementRequest>>);
#endif
    struct ShouldBeSameSizeAsApplePayDetailsUpdateBase : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ApplePayDetailsUpdateBase>, false> {
        WebCore::ApplePayLineItem newTotal;
        Vector<WebCore::ApplePayLineItem> newLineItems;
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
        std::optional<WebCore::ApplePayRecurringPaymentRequest> newRecurringPaymentRequest;
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
        std::optional<WebCore::ApplePayAutomaticReloadPaymentRequest> newAutomaticReloadPaymentRequest;
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
        std::optional<Vector<WebCore::ApplePayPaymentTokenContext>> newMultiTokenContexts;
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
        std::optional<WebCore::ApplePayDeferredPaymentRequest> newDeferredPaymentRequest;
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
        std::optional<WebCore::ApplePayDisbursementRequest> newDisbursementRequest;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsApplePayDetailsUpdateBase) == sizeof(WebCore::ApplePayDetailsUpdateBase));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newTotal)
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newLineItems)
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newRecurringPaymentRequest)
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newAutomaticReloadPaymentRequest)
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newMultiTokenContexts)
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newDeferredPaymentRequest)
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newDisbursementRequest)
#endif
    >::value);

    encoder << instance.newTotal;
    encoder << instance.newLineItems;
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
    encoder << instance.newRecurringPaymentRequest;
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
    encoder << instance.newAutomaticReloadPaymentRequest;
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
    encoder << instance.newMultiTokenContexts;
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
    encoder << instance.newDeferredPaymentRequest;
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
    encoder << instance.newDisbursementRequest;
#endif
}

std::optional<WebCore::ApplePayDetailsUpdateBase> ArgumentCoder<WebCore::ApplePayDetailsUpdateBase>::decode(Decoder& decoder)
{
    auto newTotal = decoder.decode<WebCore::ApplePayLineItem>();
    auto newLineItems = decoder.decode<Vector<WebCore::ApplePayLineItem>>();
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
    auto newRecurringPaymentRequest = decoder.decode<std::optional<WebCore::ApplePayRecurringPaymentRequest>>();
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
    auto newAutomaticReloadPaymentRequest = decoder.decode<std::optional<WebCore::ApplePayAutomaticReloadPaymentRequest>>();
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
    auto newMultiTokenContexts = decoder.decode<std::optional<Vector<WebCore::ApplePayPaymentTokenContext>>>();
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
    auto newDeferredPaymentRequest = decoder.decode<std::optional<WebCore::ApplePayDeferredPaymentRequest>>();
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
    auto newDisbursementRequest = decoder.decode<std::optional<WebCore::ApplePayDisbursementRequest>>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ApplePayDetailsUpdateBase {
            WTFMove(*newTotal),
            WTFMove(*newLineItems),
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
            WTFMove(*newRecurringPaymentRequest),
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
            WTFMove(*newAutomaticReloadPaymentRequest),
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
            WTFMove(*newMultiTokenContexts),
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
            WTFMove(*newDeferredPaymentRequest),
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
            WTFMove(*newDisbursementRequest)
#endif
        }
    };
}

#endif

#if ENABLE(APPLE_PAY)
void ArgumentCoder<WebCore::ApplePayPaymentMethodUpdate>::encode(Encoder& encoder, const WebCore::ApplePayPaymentMethodUpdate& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newTotal)>, WebCore::ApplePayLineItem>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newLineItems)>, Vector<WebCore::ApplePayLineItem>>);
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newRecurringPaymentRequest)>, std::optional<WebCore::ApplePayRecurringPaymentRequest>>);
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newAutomaticReloadPaymentRequest)>, std::optional<WebCore::ApplePayAutomaticReloadPaymentRequest>>);
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newMultiTokenContexts)>, std::optional<Vector<WebCore::ApplePayPaymentTokenContext>>>);
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newDeferredPaymentRequest)>, std::optional<WebCore::ApplePayDeferredPaymentRequest>>);
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newDisbursementRequest)>, std::optional<WebCore::ApplePayDisbursementRequest>>);
#endif
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newTotal)
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newLineItems)
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newRecurringPaymentRequest)
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newAutomaticReloadPaymentRequest)
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newMultiTokenContexts)
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newDeferredPaymentRequest)
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newDisbursementRequest)
#endif
    >::value);

#if ENABLE(APPLE_PAY_UPDATE_SHIPPING_METHODS_WHEN_CHANGING_LINE_ITEMS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.errors)>, Vector<Ref<WebCore::ApplePayError>>>);
#endif
#if ENABLE(APPLE_PAY_UPDATE_SHIPPING_METHODS_WHEN_CHANGING_LINE_ITEMS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newShippingMethods)>, Vector<WebCore::ApplePayShippingMethod>>);
#endif
#if ENABLE(APPLE_PAY_INSTALLMENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.installmentGroupIdentifier)>, String>);
#endif
    static_assert(MembersInCorrectOrder < 0
#if ENABLE(APPLE_PAY_UPDATE_SHIPPING_METHODS_WHEN_CHANGING_LINE_ITEMS)
        , offsetof(WebCore::ApplePayPaymentMethodUpdate, errors)
#endif
#if ENABLE(APPLE_PAY_UPDATE_SHIPPING_METHODS_WHEN_CHANGING_LINE_ITEMS)
        , offsetof(WebCore::ApplePayPaymentMethodUpdate, newShippingMethods)
#endif
#if ENABLE(APPLE_PAY_INSTALLMENTS)
        , offsetof(WebCore::ApplePayPaymentMethodUpdate, installmentGroupIdentifier)
#endif
    >::value);

    encoder << instance.newTotal;
    encoder << instance.newLineItems;
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
    encoder << instance.newRecurringPaymentRequest;
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
    encoder << instance.newAutomaticReloadPaymentRequest;
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
    encoder << instance.newMultiTokenContexts;
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
    encoder << instance.newDeferredPaymentRequest;
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
    encoder << instance.newDisbursementRequest;
#endif
#if ENABLE(APPLE_PAY_UPDATE_SHIPPING_METHODS_WHEN_CHANGING_LINE_ITEMS)
    encoder << instance.errors;
#endif
#if ENABLE(APPLE_PAY_UPDATE_SHIPPING_METHODS_WHEN_CHANGING_LINE_ITEMS)
    encoder << instance.newShippingMethods;
#endif
#if ENABLE(APPLE_PAY_INSTALLMENTS)
    encoder << instance.installmentGroupIdentifier;
#endif
}

std::optional<WebCore::ApplePayPaymentMethodUpdate> ArgumentCoder<WebCore::ApplePayPaymentMethodUpdate>::decode(Decoder& decoder)
{
    auto newTotal = decoder.decode<WebCore::ApplePayLineItem>();
    auto newLineItems = decoder.decode<Vector<WebCore::ApplePayLineItem>>();
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
    auto newRecurringPaymentRequest = decoder.decode<std::optional<WebCore::ApplePayRecurringPaymentRequest>>();
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
    auto newAutomaticReloadPaymentRequest = decoder.decode<std::optional<WebCore::ApplePayAutomaticReloadPaymentRequest>>();
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
    auto newMultiTokenContexts = decoder.decode<std::optional<Vector<WebCore::ApplePayPaymentTokenContext>>>();
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
    auto newDeferredPaymentRequest = decoder.decode<std::optional<WebCore::ApplePayDeferredPaymentRequest>>();
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
    auto newDisbursementRequest = decoder.decode<std::optional<WebCore::ApplePayDisbursementRequest>>();
#endif
#if ENABLE(APPLE_PAY_UPDATE_SHIPPING_METHODS_WHEN_CHANGING_LINE_ITEMS)
    auto errors = decoder.decode<Vector<Ref<WebCore::ApplePayError>>>();
#endif
#if ENABLE(APPLE_PAY_UPDATE_SHIPPING_METHODS_WHEN_CHANGING_LINE_ITEMS)
    auto newShippingMethods = decoder.decode<Vector<WebCore::ApplePayShippingMethod>>();
#endif
#if ENABLE(APPLE_PAY_INSTALLMENTS)
    auto installmentGroupIdentifier = decoder.decode<String>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ApplePayPaymentMethodUpdate {
            WebCore::ApplePayDetailsUpdateBase {
                WTFMove(*newTotal),
                WTFMove(*newLineItems),
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
                WTFMove(*newRecurringPaymentRequest),
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
                WTFMove(*newAutomaticReloadPaymentRequest),
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
                WTFMove(*newMultiTokenContexts),
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
                WTFMove(*newDeferredPaymentRequest),
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
                WTFMove(*newDisbursementRequest)
#endif
            },
#if ENABLE(APPLE_PAY_UPDATE_SHIPPING_METHODS_WHEN_CHANGING_LINE_ITEMS)
            WTFMove(*errors),
#endif
#if ENABLE(APPLE_PAY_UPDATE_SHIPPING_METHODS_WHEN_CHANGING_LINE_ITEMS)
            WTFMove(*newShippingMethods),
#endif
#if ENABLE(APPLE_PAY_INSTALLMENTS)
            WTFMove(*installmentGroupIdentifier)
#endif
        }
    };
}

#endif

#if ENABLE(APPLE_PAY)
void ArgumentCoder<WebCore::ApplePayShippingContactUpdate>::encode(Encoder& encoder, const WebCore::ApplePayShippingContactUpdate& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newTotal)>, WebCore::ApplePayLineItem>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newLineItems)>, Vector<WebCore::ApplePayLineItem>>);
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newRecurringPaymentRequest)>, std::optional<WebCore::ApplePayRecurringPaymentRequest>>);
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newAutomaticReloadPaymentRequest)>, std::optional<WebCore::ApplePayAutomaticReloadPaymentRequest>>);
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newMultiTokenContexts)>, std::optional<Vector<WebCore::ApplePayPaymentTokenContext>>>);
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newDeferredPaymentRequest)>, std::optional<WebCore::ApplePayDeferredPaymentRequest>>);
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newDisbursementRequest)>, std::optional<WebCore::ApplePayDisbursementRequest>>);
#endif
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newTotal)
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newLineItems)
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newRecurringPaymentRequest)
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newAutomaticReloadPaymentRequest)
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newMultiTokenContexts)
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newDeferredPaymentRequest)
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newDisbursementRequest)
#endif
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.errors)>, Vector<Ref<WebCore::ApplePayError>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newShippingMethods)>, Vector<WebCore::ApplePayShippingMethod>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ApplePayShippingContactUpdate, errors)
        , offsetof(WebCore::ApplePayShippingContactUpdate, newShippingMethods)
    >::value);

    encoder << instance.newTotal;
    encoder << instance.newLineItems;
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
    encoder << instance.newRecurringPaymentRequest;
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
    encoder << instance.newAutomaticReloadPaymentRequest;
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
    encoder << instance.newMultiTokenContexts;
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
    encoder << instance.newDeferredPaymentRequest;
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
    encoder << instance.newDisbursementRequest;
#endif
    encoder << instance.errors;
    encoder << instance.newShippingMethods;
}

std::optional<WebCore::ApplePayShippingContactUpdate> ArgumentCoder<WebCore::ApplePayShippingContactUpdate>::decode(Decoder& decoder)
{
    auto newTotal = decoder.decode<WebCore::ApplePayLineItem>();
    auto newLineItems = decoder.decode<Vector<WebCore::ApplePayLineItem>>();
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
    auto newRecurringPaymentRequest = decoder.decode<std::optional<WebCore::ApplePayRecurringPaymentRequest>>();
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
    auto newAutomaticReloadPaymentRequest = decoder.decode<std::optional<WebCore::ApplePayAutomaticReloadPaymentRequest>>();
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
    auto newMultiTokenContexts = decoder.decode<std::optional<Vector<WebCore::ApplePayPaymentTokenContext>>>();
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
    auto newDeferredPaymentRequest = decoder.decode<std::optional<WebCore::ApplePayDeferredPaymentRequest>>();
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
    auto newDisbursementRequest = decoder.decode<std::optional<WebCore::ApplePayDisbursementRequest>>();
#endif
    auto errors = decoder.decode<Vector<Ref<WebCore::ApplePayError>>>();
    auto newShippingMethods = decoder.decode<Vector<WebCore::ApplePayShippingMethod>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ApplePayShippingContactUpdate {
            WebCore::ApplePayDetailsUpdateBase {
                WTFMove(*newTotal),
                WTFMove(*newLineItems),
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
                WTFMove(*newRecurringPaymentRequest),
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
                WTFMove(*newAutomaticReloadPaymentRequest),
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
                WTFMove(*newMultiTokenContexts),
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
                WTFMove(*newDeferredPaymentRequest),
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
                WTFMove(*newDisbursementRequest)
#endif
            },
            WTFMove(*errors),
            WTFMove(*newShippingMethods)
        }
    };
}

#endif

#if ENABLE(APPLE_PAY)
void ArgumentCoder<WebCore::ApplePayShippingMethodUpdate>::encode(Encoder& encoder, const WebCore::ApplePayShippingMethodUpdate& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newTotal)>, WebCore::ApplePayLineItem>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newLineItems)>, Vector<WebCore::ApplePayLineItem>>);
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newRecurringPaymentRequest)>, std::optional<WebCore::ApplePayRecurringPaymentRequest>>);
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newAutomaticReloadPaymentRequest)>, std::optional<WebCore::ApplePayAutomaticReloadPaymentRequest>>);
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newMultiTokenContexts)>, std::optional<Vector<WebCore::ApplePayPaymentTokenContext>>>);
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newDeferredPaymentRequest)>, std::optional<WebCore::ApplePayDeferredPaymentRequest>>);
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newDisbursementRequest)>, std::optional<WebCore::ApplePayDisbursementRequest>>);
#endif
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newTotal)
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newLineItems)
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newRecurringPaymentRequest)
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newAutomaticReloadPaymentRequest)
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newMultiTokenContexts)
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newDeferredPaymentRequest)
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newDisbursementRequest)
#endif
    >::value);

#if ENABLE(APPLE_PAY_UPDATE_SHIPPING_METHODS_WHEN_CHANGING_LINE_ITEMS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newShippingMethods)>, Vector<WebCore::ApplePayShippingMethod>>);
#endif
    static_assert(MembersInCorrectOrder < 0
#if ENABLE(APPLE_PAY_UPDATE_SHIPPING_METHODS_WHEN_CHANGING_LINE_ITEMS)
        , offsetof(WebCore::ApplePayShippingMethodUpdate, newShippingMethods)
#endif
    >::value);

    encoder << instance.newTotal;
    encoder << instance.newLineItems;
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
    encoder << instance.newRecurringPaymentRequest;
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
    encoder << instance.newAutomaticReloadPaymentRequest;
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
    encoder << instance.newMultiTokenContexts;
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
    encoder << instance.newDeferredPaymentRequest;
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
    encoder << instance.newDisbursementRequest;
#endif
#if ENABLE(APPLE_PAY_UPDATE_SHIPPING_METHODS_WHEN_CHANGING_LINE_ITEMS)
    encoder << instance.newShippingMethods;
#endif
}

std::optional<WebCore::ApplePayShippingMethodUpdate> ArgumentCoder<WebCore::ApplePayShippingMethodUpdate>::decode(Decoder& decoder)
{
    auto newTotal = decoder.decode<WebCore::ApplePayLineItem>();
    auto newLineItems = decoder.decode<Vector<WebCore::ApplePayLineItem>>();
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
    auto newRecurringPaymentRequest = decoder.decode<std::optional<WebCore::ApplePayRecurringPaymentRequest>>();
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
    auto newAutomaticReloadPaymentRequest = decoder.decode<std::optional<WebCore::ApplePayAutomaticReloadPaymentRequest>>();
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
    auto newMultiTokenContexts = decoder.decode<std::optional<Vector<WebCore::ApplePayPaymentTokenContext>>>();
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
    auto newDeferredPaymentRequest = decoder.decode<std::optional<WebCore::ApplePayDeferredPaymentRequest>>();
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
    auto newDisbursementRequest = decoder.decode<std::optional<WebCore::ApplePayDisbursementRequest>>();
#endif
#if ENABLE(APPLE_PAY_UPDATE_SHIPPING_METHODS_WHEN_CHANGING_LINE_ITEMS)
    auto newShippingMethods = decoder.decode<Vector<WebCore::ApplePayShippingMethod>>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ApplePayShippingMethodUpdate {
            WebCore::ApplePayDetailsUpdateBase {
                WTFMove(*newTotal),
                WTFMove(*newLineItems),
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
                WTFMove(*newRecurringPaymentRequest),
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
                WTFMove(*newAutomaticReloadPaymentRequest),
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
                WTFMove(*newMultiTokenContexts),
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
                WTFMove(*newDeferredPaymentRequest),
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
                WTFMove(*newDisbursementRequest)
#endif
            },
#if ENABLE(APPLE_PAY_UPDATE_SHIPPING_METHODS_WHEN_CHANGING_LINE_ITEMS)
            WTFMove(*newShippingMethods)
#endif
        }
    };
}

#endif

#if ENABLE(APPLE_PAY)
void ArgumentCoder<WebCore::ApplePayPaymentAuthorizationResult>::encode(Encoder& encoder, const WebCore::ApplePayPaymentAuthorizationResult& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.status)>, unsigned short>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.errors)>, Vector<Ref<WebCore::ApplePayError>>>);
#if ENABLE(APPLE_PAY_PAYMENT_ORDER_DETAILS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.orderDetails)>, std::optional<WebCore::ApplePayPaymentOrderDetails>>);
#endif
    struct ShouldBeSameSizeAsApplePayPaymentAuthorizationResult : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ApplePayPaymentAuthorizationResult>, false> {
        unsigned short status;
        Vector<Ref<WebCore::ApplePayError>> errors;
#if ENABLE(APPLE_PAY_PAYMENT_ORDER_DETAILS)
        std::optional<WebCore::ApplePayPaymentOrderDetails> orderDetails;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsApplePayPaymentAuthorizationResult) == sizeof(WebCore::ApplePayPaymentAuthorizationResult));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ApplePayPaymentAuthorizationResult, status)
        , offsetof(WebCore::ApplePayPaymentAuthorizationResult, errors)
#if ENABLE(APPLE_PAY_PAYMENT_ORDER_DETAILS)
        , offsetof(WebCore::ApplePayPaymentAuthorizationResult, orderDetails)
#endif
    >::value);

    encoder << instance.status;
    encoder << instance.errors;
#if ENABLE(APPLE_PAY_PAYMENT_ORDER_DETAILS)
    encoder << instance.orderDetails;
#endif
}

std::optional<WebCore::ApplePayPaymentAuthorizationResult> ArgumentCoder<WebCore::ApplePayPaymentAuthorizationResult>::decode(Decoder& decoder)
{
    auto status = decoder.decode<unsigned short>();
    auto errors = decoder.decode<Vector<Ref<WebCore::ApplePayError>>>();
#if ENABLE(APPLE_PAY_PAYMENT_ORDER_DETAILS)
    auto orderDetails = decoder.decode<std::optional<WebCore::ApplePayPaymentOrderDetails>>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ApplePayPaymentAuthorizationResult {
            WTFMove(*status),
            WTFMove(*errors),
#if ENABLE(APPLE_PAY_PAYMENT_ORDER_DETAILS)
            WTFMove(*orderDetails)
#endif
        }
    };
}

#endif

#if ENABLE(APPLE_PAY_DISBURSEMENTS)
void ArgumentCoder<WebCore::ApplePayDisbursementRequest>::encode(Encoder& encoder, const WebCore::ApplePayDisbursementRequest& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requiredRecipientContactFields)>, std::optional<Vector<WebCore::ApplePayContactField>>>);
    struct ShouldBeSameSizeAsApplePayDisbursementRequest : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ApplePayDisbursementRequest>, false> {
        std::optional<Vector<WebCore::ApplePayContactField>> requiredRecipientContactFields;
    };
    static_assert(sizeof(ShouldBeSameSizeAsApplePayDisbursementRequest) == sizeof(WebCore::ApplePayDisbursementRequest));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ApplePayDisbursementRequest, requiredRecipientContactFields)
    >::value);

    encoder << instance.requiredRecipientContactFields;
}

std::optional<WebCore::ApplePayDisbursementRequest> ArgumentCoder<WebCore::ApplePayDisbursementRequest>::decode(Decoder& decoder)
{
    auto requiredRecipientContactFields = decoder.decode<std::optional<Vector<WebCore::ApplePayContactField>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ApplePayDisbursementRequest {
            WTFMove(*requiredRecipientContactFields)
        }
    };
}

#endif

#if ENABLE(APPLE_PAY_INSTALLMENTS)
void ArgumentCoder<WebCore::ApplePayInstallmentConfiguration>::encode(Encoder& encoder, const WebCore::ApplePayInstallmentConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.featureType)>, WebCore::ApplePaySetupFeatureType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.merchandisingImageData)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.openToBuyThresholdAmount)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bindingTotalAmount)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.currencyCode)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isInStorePurchase)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.merchantIdentifier)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.referrerIdentifier)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.items)>, Vector<WebCore::ApplePayInstallmentItem>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.applicationMetadata)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.retailChannel)>, WebCore::ApplePayInstallmentRetailChannel>);
    struct ShouldBeSameSizeAsApplePayInstallmentConfiguration : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ApplePayInstallmentConfiguration>, false> {
        WebCore::ApplePaySetupFeatureType featureType;
        String merchandisingImageData;
        String openToBuyThresholdAmount;
        String bindingTotalAmount;
        String currencyCode;
        bool isInStorePurchase;
        String merchantIdentifier;
        String referrerIdentifier;
        Vector<WebCore::ApplePayInstallmentItem> items;
        String applicationMetadata;
        WebCore::ApplePayInstallmentRetailChannel retailChannel;
    };
    static_assert(sizeof(ShouldBeSameSizeAsApplePayInstallmentConfiguration) == sizeof(WebCore::ApplePayInstallmentConfiguration));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ApplePayInstallmentConfiguration, featureType)
        , offsetof(WebCore::ApplePayInstallmentConfiguration, merchandisingImageData)
        , offsetof(WebCore::ApplePayInstallmentConfiguration, openToBuyThresholdAmount)
        , offsetof(WebCore::ApplePayInstallmentConfiguration, bindingTotalAmount)
        , offsetof(WebCore::ApplePayInstallmentConfiguration, currencyCode)
        , offsetof(WebCore::ApplePayInstallmentConfiguration, isInStorePurchase)
        , offsetof(WebCore::ApplePayInstallmentConfiguration, merchantIdentifier)
        , offsetof(WebCore::ApplePayInstallmentConfiguration, referrerIdentifier)
        , offsetof(WebCore::ApplePayInstallmentConfiguration, items)
        , offsetof(WebCore::ApplePayInstallmentConfiguration, applicationMetadata)
        , offsetof(WebCore::ApplePayInstallmentConfiguration, retailChannel)
    >::value);

    encoder << instance.featureType;
    encoder << instance.merchandisingImageData;
    encoder << instance.openToBuyThresholdAmount;
    encoder << instance.bindingTotalAmount;
    encoder << instance.currencyCode;
    encoder << instance.isInStorePurchase;
    encoder << instance.merchantIdentifier;
    encoder << instance.referrerIdentifier;
    encoder << instance.items;
    encoder << instance.applicationMetadata;
    encoder << instance.retailChannel;
}

std::optional<WebCore::ApplePayInstallmentConfiguration> ArgumentCoder<WebCore::ApplePayInstallmentConfiguration>::decode(Decoder& decoder)
{
    auto featureType = decoder.decode<WebCore::ApplePaySetupFeatureType>();
    auto merchandisingImageData = decoder.decode<String>();
    auto openToBuyThresholdAmount = decoder.decode<String>();
    auto bindingTotalAmount = decoder.decode<String>();
    auto currencyCode = decoder.decode<String>();
    auto isInStorePurchase = decoder.decode<bool>();
    auto merchantIdentifier = decoder.decode<String>();
    auto referrerIdentifier = decoder.decode<String>();
    auto items = decoder.decode<Vector<WebCore::ApplePayInstallmentItem>>();
    auto applicationMetadata = decoder.decode<String>();
    auto retailChannel = decoder.decode<WebCore::ApplePayInstallmentRetailChannel>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ApplePayInstallmentConfiguration {
            WTFMove(*featureType),
            WTFMove(*merchandisingImageData),
            WTFMove(*openToBuyThresholdAmount),
            WTFMove(*bindingTotalAmount),
            WTFMove(*currencyCode),
            WTFMove(*isInStorePurchase),
            WTFMove(*merchantIdentifier),
            WTFMove(*referrerIdentifier),
            WTFMove(*items),
            WTFMove(*applicationMetadata),
            WTFMove(*retailChannel)
        }
    };
}

#endif

#if ENABLE(APPLE_PAY_INSTALLMENTS)
void ArgumentCoder<WebCore::PaymentInstallmentConfiguration>::encode(Encoder& encoder, const WebCore::PaymentInstallmentConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.applePayInstallmentConfiguration())>, std::optional<WebCore::ApplePayInstallmentConfiguration>>);

    encoder << instance.applePayInstallmentConfiguration();
}

std::optional<WebCore::PaymentInstallmentConfiguration> ArgumentCoder<WebCore::PaymentInstallmentConfiguration>::decode(Decoder& decoder)
{
    auto applePayInstallmentConfiguration = decoder.decode<std::optional<WebCore::ApplePayInstallmentConfiguration>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PaymentInstallmentConfiguration {
            WTFMove(*applePayInstallmentConfiguration)
        }
    };
}

#endif

#if ENABLE(APPLE_PAY_INSTALLMENTS)
void ArgumentCoder<WebCore::ApplePayInstallmentItem>::encode(Encoder& encoder, const WebCore::ApplePayInstallmentItem& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::ApplePayInstallmentItemType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.amount)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.currencyCode)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.programIdentifier)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.apr)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.programTerms)>, String>);
    struct ShouldBeSameSizeAsApplePayInstallmentItem : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ApplePayInstallmentItem>, false> {
        WebCore::ApplePayInstallmentItemType type;
        String amount;
        String currencyCode;
        String programIdentifier;
        String apr;
        String programTerms;
    };
    static_assert(sizeof(ShouldBeSameSizeAsApplePayInstallmentItem) == sizeof(WebCore::ApplePayInstallmentItem));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ApplePayInstallmentItem, type)
        , offsetof(WebCore::ApplePayInstallmentItem, amount)
        , offsetof(WebCore::ApplePayInstallmentItem, currencyCode)
        , offsetof(WebCore::ApplePayInstallmentItem, programIdentifier)
        , offsetof(WebCore::ApplePayInstallmentItem, apr)
        , offsetof(WebCore::ApplePayInstallmentItem, programTerms)
    >::value);

    encoder << instance.type;
    encoder << instance.amount;
    encoder << instance.currencyCode;
    encoder << instance.programIdentifier;
    encoder << instance.apr;
    encoder << instance.programTerms;
}

std::optional<WebCore::ApplePayInstallmentItem> ArgumentCoder<WebCore::ApplePayInstallmentItem>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::ApplePayInstallmentItemType>();
    auto amount = decoder.decode<String>();
    auto currencyCode = decoder.decode<String>();
    auto programIdentifier = decoder.decode<String>();
    auto apr = decoder.decode<String>();
    auto programTerms = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ApplePayInstallmentItem {
            WTFMove(*type),
            WTFMove(*amount),
            WTFMove(*currencyCode),
            WTFMove(*programIdentifier),
            WTFMove(*apr),
            WTFMove(*programTerms)
        }
    };
}

#endif

#if ENABLE(APPLE_PAY_COUPON_CODE)
void ArgumentCoder<WebCore::ApplePayCouponCodeUpdate>::encode(Encoder& encoder, const WebCore::ApplePayCouponCodeUpdate& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newTotal)>, WebCore::ApplePayLineItem>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newLineItems)>, Vector<WebCore::ApplePayLineItem>>);
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newRecurringPaymentRequest)>, std::optional<WebCore::ApplePayRecurringPaymentRequest>>);
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newAutomaticReloadPaymentRequest)>, std::optional<WebCore::ApplePayAutomaticReloadPaymentRequest>>);
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newMultiTokenContexts)>, std::optional<Vector<WebCore::ApplePayPaymentTokenContext>>>);
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newDeferredPaymentRequest)>, std::optional<WebCore::ApplePayDeferredPaymentRequest>>);
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newDisbursementRequest)>, std::optional<WebCore::ApplePayDisbursementRequest>>);
#endif
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newTotal)
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newLineItems)
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newRecurringPaymentRequest)
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newAutomaticReloadPaymentRequest)
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newMultiTokenContexts)
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newDeferredPaymentRequest)
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
        , offsetof(WebCore::ApplePayDetailsUpdateBase, newDisbursementRequest)
#endif
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.errors)>, Vector<Ref<WebCore::ApplePayError>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.newShippingMethods)>, Vector<WebCore::ApplePayShippingMethod>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ApplePayCouponCodeUpdate, errors)
        , offsetof(WebCore::ApplePayCouponCodeUpdate, newShippingMethods)
    >::value);

    encoder << instance.newTotal;
    encoder << instance.newLineItems;
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
    encoder << instance.newRecurringPaymentRequest;
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
    encoder << instance.newAutomaticReloadPaymentRequest;
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
    encoder << instance.newMultiTokenContexts;
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
    encoder << instance.newDeferredPaymentRequest;
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
    encoder << instance.newDisbursementRequest;
#endif
    encoder << instance.errors;
    encoder << instance.newShippingMethods;
}

std::optional<WebCore::ApplePayCouponCodeUpdate> ArgumentCoder<WebCore::ApplePayCouponCodeUpdate>::decode(Decoder& decoder)
{
    auto newTotal = decoder.decode<WebCore::ApplePayLineItem>();
    auto newLineItems = decoder.decode<Vector<WebCore::ApplePayLineItem>>();
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
    auto newRecurringPaymentRequest = decoder.decode<std::optional<WebCore::ApplePayRecurringPaymentRequest>>();
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
    auto newAutomaticReloadPaymentRequest = decoder.decode<std::optional<WebCore::ApplePayAutomaticReloadPaymentRequest>>();
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
    auto newMultiTokenContexts = decoder.decode<std::optional<Vector<WebCore::ApplePayPaymentTokenContext>>>();
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
    auto newDeferredPaymentRequest = decoder.decode<std::optional<WebCore::ApplePayDeferredPaymentRequest>>();
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
    auto newDisbursementRequest = decoder.decode<std::optional<WebCore::ApplePayDisbursementRequest>>();
#endif
    auto errors = decoder.decode<Vector<Ref<WebCore::ApplePayError>>>();
    auto newShippingMethods = decoder.decode<Vector<WebCore::ApplePayShippingMethod>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ApplePayCouponCodeUpdate {
            WebCore::ApplePayDetailsUpdateBase {
                WTFMove(*newTotal),
                WTFMove(*newLineItems),
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
                WTFMove(*newRecurringPaymentRequest),
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
                WTFMove(*newAutomaticReloadPaymentRequest),
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
                WTFMove(*newMultiTokenContexts),
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
                WTFMove(*newDeferredPaymentRequest),
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
                WTFMove(*newDisbursementRequest)
#endif
            },
            WTFMove(*errors),
            WTFMove(*newShippingMethods)
        }
    };
}

#endif

#if ENABLE(APPLICATION_MANIFEST)
void ArgumentCoder<WebCore::ApplicationManifest::Icon>::encode(Encoder& encoder, const WebCore::ApplicationManifest::Icon& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.src)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sizes)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.purposes)>, OptionSet<WebCore::ApplicationManifest::Icon::Purpose>>);
    struct ShouldBeSameSizeAsIcon : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ApplicationManifest::Icon>, false> {
        URL src;
        Vector<String> sizes;
        String type;
        OptionSet<WebCore::ApplicationManifest::Icon::Purpose> purposes;
    };
    static_assert(sizeof(ShouldBeSameSizeAsIcon) == sizeof(WebCore::ApplicationManifest::Icon));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ApplicationManifest::Icon, src)
        , offsetof(WebCore::ApplicationManifest::Icon, sizes)
        , offsetof(WebCore::ApplicationManifest::Icon, type)
        , offsetof(WebCore::ApplicationManifest::Icon, purposes)
    >::value);

    encoder << instance.src;
    encoder << instance.sizes;
    encoder << instance.type;
    encoder << instance.purposes;
}

std::optional<WebCore::ApplicationManifest::Icon> ArgumentCoder<WebCore::ApplicationManifest::Icon>::decode(Decoder& decoder)
{
    auto src = decoder.decode<URL>();
    auto sizes = decoder.decode<Vector<String>>();
    auto type = decoder.decode<String>();
    auto purposes = decoder.decode<OptionSet<WebCore::ApplicationManifest::Icon::Purpose>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ApplicationManifest::Icon {
            WTFMove(*src),
            WTFMove(*sizes),
            WTFMove(*type),
            WTFMove(*purposes)
        }
    };
}

#endif

#if ENABLE(APPLICATION_MANIFEST)
void ArgumentCoder<WebCore::ApplicationManifest::Shortcut>::encode(Encoder& encoder, const WebCore::ApplicationManifest::Shortcut& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.icons)>, Vector<WebCore::ApplicationManifest::Icon>>);
    struct ShouldBeSameSizeAsShortcut : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ApplicationManifest::Shortcut>, false> {
        String name;
        URL url;
        Vector<WebCore::ApplicationManifest::Icon> icons;
    };
    static_assert(sizeof(ShouldBeSameSizeAsShortcut) == sizeof(WebCore::ApplicationManifest::Shortcut));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ApplicationManifest::Shortcut, name)
        , offsetof(WebCore::ApplicationManifest::Shortcut, url)
        , offsetof(WebCore::ApplicationManifest::Shortcut, icons)
    >::value);

    encoder << instance.name;
    encoder << instance.url;
    encoder << instance.icons;
}

std::optional<WebCore::ApplicationManifest::Shortcut> ArgumentCoder<WebCore::ApplicationManifest::Shortcut>::decode(Decoder& decoder)
{
    auto name = decoder.decode<String>();
    auto url = decoder.decode<URL>();
    auto icons = decoder.decode<Vector<WebCore::ApplicationManifest::Icon>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ApplicationManifest::Shortcut {
            WTFMove(*name),
            WTFMove(*url),
            WTFMove(*icons)
        }
    };
}

#endif

#if ENABLE(APPLICATION_MANIFEST)
void ArgumentCoder<WebCore::ApplicationManifest>::encode(Encoder& encoder, const WebCore::ApplicationManifest& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rawJSON)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dir)>, WebCore::ApplicationManifest::Direction>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shortName)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.description)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scope)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isDefaultScope)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.display)>, WebCore::ApplicationManifest::Display>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.orientation)>, std::optional<WebCore::ScreenOrientationLockType>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.manifestURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.startURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.id)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.backgroundColor)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.themeColor)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.categories)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.icons)>, Vector<WebCore::ApplicationManifest::Icon>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shortcuts)>, Vector<WebCore::ApplicationManifest::Shortcut>>);
    struct ShouldBeSameSizeAsApplicationManifest : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ApplicationManifest>, false> {
        String rawJSON;
        WebCore::ApplicationManifest::Direction dir;
        String name;
        String shortName;
        String description;
        URL scope;
        bool isDefaultScope;
        WebCore::ApplicationManifest::Display display;
        std::optional<WebCore::ScreenOrientationLockType> orientation;
        URL manifestURL;
        URL startURL;
        URL id;
        WebCore::Color backgroundColor;
        WebCore::Color themeColor;
        Vector<String> categories;
        Vector<WebCore::ApplicationManifest::Icon> icons;
        Vector<WebCore::ApplicationManifest::Shortcut> shortcuts;
    };
    static_assert(sizeof(ShouldBeSameSizeAsApplicationManifest) == sizeof(WebCore::ApplicationManifest));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ApplicationManifest, rawJSON)
        , offsetof(WebCore::ApplicationManifest, dir)
        , offsetof(WebCore::ApplicationManifest, name)
        , offsetof(WebCore::ApplicationManifest, shortName)
        , offsetof(WebCore::ApplicationManifest, description)
        , offsetof(WebCore::ApplicationManifest, scope)
        , offsetof(WebCore::ApplicationManifest, isDefaultScope)
        , offsetof(WebCore::ApplicationManifest, display)
        , offsetof(WebCore::ApplicationManifest, orientation)
        , offsetof(WebCore::ApplicationManifest, manifestURL)
        , offsetof(WebCore::ApplicationManifest, startURL)
        , offsetof(WebCore::ApplicationManifest, id)
        , offsetof(WebCore::ApplicationManifest, backgroundColor)
        , offsetof(WebCore::ApplicationManifest, themeColor)
        , offsetof(WebCore::ApplicationManifest, categories)
        , offsetof(WebCore::ApplicationManifest, icons)
        , offsetof(WebCore::ApplicationManifest, shortcuts)
    >::value);

    encoder << instance.rawJSON;
    encoder << instance.dir;
    encoder << instance.name;
    encoder << instance.shortName;
    encoder << instance.description;
    encoder << instance.scope;
    encoder << instance.isDefaultScope;
    encoder << instance.display;
    encoder << instance.orientation;
    encoder << instance.manifestURL;
    encoder << instance.startURL;
    encoder << instance.id;
    encoder << instance.backgroundColor;
    encoder << instance.themeColor;
    encoder << instance.categories;
    encoder << instance.icons;
    encoder << instance.shortcuts;
}

std::optional<WebCore::ApplicationManifest> ArgumentCoder<WebCore::ApplicationManifest>::decode(Decoder& decoder)
{
    auto rawJSON = decoder.decode<String>();
    auto dir = decoder.decode<WebCore::ApplicationManifest::Direction>();
    auto name = decoder.decode<String>();
    auto shortName = decoder.decode<String>();
    auto description = decoder.decode<String>();
    auto scope = decoder.decode<URL>();
    auto isDefaultScope = decoder.decode<bool>();
    auto display = decoder.decode<WebCore::ApplicationManifest::Display>();
    auto orientation = decoder.decode<std::optional<WebCore::ScreenOrientationLockType>>();
    auto manifestURL = decoder.decode<URL>();
    auto startURL = decoder.decode<URL>();
    auto id = decoder.decode<URL>();
    auto backgroundColor = decoder.decode<WebCore::Color>();
    auto themeColor = decoder.decode<WebCore::Color>();
    auto categories = decoder.decode<Vector<String>>();
    auto icons = decoder.decode<Vector<WebCore::ApplicationManifest::Icon>>();
    auto shortcuts = decoder.decode<Vector<WebCore::ApplicationManifest::Shortcut>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ApplicationManifest {
            WTFMove(*rawJSON),
            WTFMove(*dir),
            WTFMove(*name),
            WTFMove(*shortName),
            WTFMove(*description),
            WTFMove(*scope),
            WTFMove(*isDefaultScope),
            WTFMove(*display),
            WTFMove(*orientation),
            WTFMove(*manifestURL),
            WTFMove(*startURL),
            WTFMove(*id),
            WTFMove(*backgroundColor),
            WTFMove(*themeColor),
            WTFMove(*categories),
            WTFMove(*icons),
            WTFMove(*shortcuts)
        }
    };
}

#endif

void ArgumentCoder<WebCore::RetrieveRecordsOptions>::encode(Encoder& encoder, const WebCore::RetrieveRecordsOptions& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.request)>, WebCore::ResourceRequest>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.crossOriginEmbedderPolicy)>, WebCore::CrossOriginEmbedderPolicy>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceOrigin)>, Ref<WebCore::SecurityOrigin>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ignoreSearch)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ignoreMethod)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ignoreVary)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldProvideResponse)>, bool>);
    struct ShouldBeSameSizeAsRetrieveRecordsOptions : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::RetrieveRecordsOptions>, false> {
        WebCore::ResourceRequest request;
        WebCore::CrossOriginEmbedderPolicy crossOriginEmbedderPolicy;
        Ref<WebCore::SecurityOrigin> sourceOrigin;
        bool ignoreSearch;
        bool ignoreMethod;
        bool ignoreVary;
        bool shouldProvideResponse;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRetrieveRecordsOptions) == sizeof(WebCore::RetrieveRecordsOptions));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::RetrieveRecordsOptions, request)
        , offsetof(WebCore::RetrieveRecordsOptions, crossOriginEmbedderPolicy)
        , offsetof(WebCore::RetrieveRecordsOptions, sourceOrigin)
        , offsetof(WebCore::RetrieveRecordsOptions, ignoreSearch)
        , offsetof(WebCore::RetrieveRecordsOptions, ignoreMethod)
        , offsetof(WebCore::RetrieveRecordsOptions, ignoreVary)
        , offsetof(WebCore::RetrieveRecordsOptions, shouldProvideResponse)
    >::value);

    encoder << instance.request;
    encoder << instance.crossOriginEmbedderPolicy;
    encoder << instance.sourceOrigin;
    encoder << instance.ignoreSearch;
    encoder << instance.ignoreMethod;
    encoder << instance.ignoreVary;
    encoder << instance.shouldProvideResponse;
}

std::optional<WebCore::RetrieveRecordsOptions> ArgumentCoder<WebCore::RetrieveRecordsOptions>::decode(Decoder& decoder)
{
    auto request = decoder.decode<WebCore::ResourceRequest>();
    auto crossOriginEmbedderPolicy = decoder.decode<WebCore::CrossOriginEmbedderPolicy>();
    auto sourceOrigin = decoder.decode<Ref<WebCore::SecurityOrigin>>();
    auto ignoreSearch = decoder.decode<bool>();
    auto ignoreMethod = decoder.decode<bool>();
    auto ignoreVary = decoder.decode<bool>();
    auto shouldProvideResponse = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::RetrieveRecordsOptions {
            WTFMove(*request),
            WTFMove(*crossOriginEmbedderPolicy),
            WTFMove(*sourceOrigin),
            WTFMove(*ignoreSearch),
            WTFMove(*ignoreMethod),
            WTFMove(*ignoreVary),
            WTFMove(*shouldProvideResponse)
        }
    };
}

void ArgumentCoder<WebCore::ContactInfo>::encode(Encoder& encoder, const WebCore::ContactInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.email)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tel)>, Vector<String>>);
    struct ShouldBeSameSizeAsContactInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ContactInfo>, false> {
        Vector<String> name;
        Vector<String> email;
        Vector<String> tel;
    };
    static_assert(sizeof(ShouldBeSameSizeAsContactInfo) == sizeof(WebCore::ContactInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ContactInfo, name)
        , offsetof(WebCore::ContactInfo, email)
        , offsetof(WebCore::ContactInfo, tel)
    >::value);

    encoder << instance.name;
    encoder << instance.email;
    encoder << instance.tel;
}

std::optional<WebCore::ContactInfo> ArgumentCoder<WebCore::ContactInfo>::decode(Decoder& decoder)
{
    auto name = decoder.decode<Vector<String>>();
    auto email = decoder.decode<Vector<String>>();
    auto tel = decoder.decode<Vector<String>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ContactInfo {
            WTFMove(*name),
            WTFMove(*email),
            WTFMove(*tel)
        }
    };
}

void ArgumentCoder<WebCore::ContactsRequestData>::encode(Encoder& encoder, const WebCore::ContactsRequestData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.properties)>, Vector<WebCore::ContactProperty>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.multiple)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url)>, String>);
    struct ShouldBeSameSizeAsContactsRequestData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ContactsRequestData>, false> {
        Vector<WebCore::ContactProperty> properties;
        bool multiple;
        String url;
    };
    static_assert(sizeof(ShouldBeSameSizeAsContactsRequestData) == sizeof(WebCore::ContactsRequestData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ContactsRequestData, properties)
        , offsetof(WebCore::ContactsRequestData, multiple)
        , offsetof(WebCore::ContactsRequestData, url)
    >::value);

    encoder << instance.properties;
    encoder << instance.multiple;
    encoder << instance.url;
}

std::optional<WebCore::ContactsRequestData> ArgumentCoder<WebCore::ContactsRequestData>::decode(Decoder& decoder)
{
    auto properties = decoder.decode<Vector<WebCore::ContactProperty>>();
    auto multiple = decoder.decode<bool>();
    auto url = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ContactsRequestData {
            WTFMove(*properties),
            WTFMove(*multiple),
            WTFMove(*url)
        }
    };
}

#if ENABLE(MEDIA_SESSION)
void ArgumentCoder<WebCore::MediaPositionState>::encode(Encoder& encoder, const WebCore::MediaPositionState& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.duration)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.playbackRate)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.position)>, double>);
    struct ShouldBeSameSizeAsMediaPositionState : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MediaPositionState>, false> {
        double duration;
        double playbackRate;
        double position;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMediaPositionState) == sizeof(WebCore::MediaPositionState));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MediaPositionState, duration)
        , offsetof(WebCore::MediaPositionState, playbackRate)
        , offsetof(WebCore::MediaPositionState, position)
    >::value);

    encoder << instance.duration;
    encoder << instance.playbackRate;
    encoder << instance.position;
}

std::optional<WebCore::MediaPositionState> ArgumentCoder<WebCore::MediaPositionState>::decode(Decoder& decoder)
{
    auto duration = decoder.decode<double>();
    auto playbackRate = decoder.decode<double>();
    auto position = decoder.decode<double>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MediaPositionState {
            WTFMove(*duration),
            WTFMove(*playbackRate),
            WTFMove(*position)
        }
    };
}

#endif

#if ENABLE(WEB_RTC)
void ArgumentCoder<WebCore::DetachedRTCDataChannel>::encode(Encoder& encoder, const WebCore::DetachedRTCDataChannel& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, WebCore::RTCDataChannelIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.options)>, WebCore::RTCDataChannelInit>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.state)>, WebCore::RTCDataChannelState>);
    struct ShouldBeSameSizeAsDetachedRTCDataChannel : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::DetachedRTCDataChannel>, false> {
        WebCore::RTCDataChannelIdentifier identifier;
        String label;
        WebCore::RTCDataChannelInit options;
        WebCore::RTCDataChannelState state;
    };
    static_assert(sizeof(ShouldBeSameSizeAsDetachedRTCDataChannel) == sizeof(WebCore::DetachedRTCDataChannel));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::DetachedRTCDataChannel, identifier)
        , offsetof(WebCore::DetachedRTCDataChannel, label)
        , offsetof(WebCore::DetachedRTCDataChannel, options)
        , offsetof(WebCore::DetachedRTCDataChannel, state)
    >::value);

    encoder << instance.identifier;
    encoder << instance.label;
    encoder << instance.options;
    encoder << instance.state;
}

std::optional<WebCore::DetachedRTCDataChannel> ArgumentCoder<WebCore::DetachedRTCDataChannel>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<WebCore::RTCDataChannelIdentifier>();
    auto label = decoder.decode<String>();
    auto options = decoder.decode<WebCore::RTCDataChannelInit>();
    auto state = decoder.decode<WebCore::RTCDataChannelState>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DetachedRTCDataChannel {
            WTFMove(*identifier),
            WTFMove(*label),
            WTFMove(*options),
            WTFMove(*state)
        }
    };
}

#endif

#if ENABLE(WEB_CODECS)
void ArgumentCoder<WebCore::WebCodecsEncodedVideoChunkData>::encode(Encoder& encoder, const WebCore::WebCodecsEncodedVideoChunkData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::WebCodecsEncodedVideoChunkType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timestamp)>, int64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.duration)>, std::optional<uint64_t>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.buffer)>, Vector<uint8_t>>);
    struct ShouldBeSameSizeAsWebCodecsEncodedVideoChunkData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::WebCodecsEncodedVideoChunkData>, false> {
        WebCore::WebCodecsEncodedVideoChunkType type;
        int64_t timestamp;
        std::optional<uint64_t> duration;
        Vector<uint8_t> buffer;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebCodecsEncodedVideoChunkData) == sizeof(WebCore::WebCodecsEncodedVideoChunkData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::WebCodecsEncodedVideoChunkData, type)
        , offsetof(WebCore::WebCodecsEncodedVideoChunkData, timestamp)
        , offsetof(WebCore::WebCodecsEncodedVideoChunkData, duration)
        , offsetof(WebCore::WebCodecsEncodedVideoChunkData, buffer)
    >::value);

    encoder << instance.type;
    encoder << instance.timestamp;
    encoder << instance.duration;
    encoder << instance.buffer;
}

std::optional<WebCore::WebCodecsEncodedVideoChunkData> ArgumentCoder<WebCore::WebCodecsEncodedVideoChunkData>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::WebCodecsEncodedVideoChunkType>();
    auto timestamp = decoder.decode<int64_t>();
    auto duration = decoder.decode<std::optional<uint64_t>>();
    auto buffer = decoder.decode<Vector<uint8_t>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::WebCodecsEncodedVideoChunkData {
            WTFMove(*type),
            WTFMove(*timestamp),
            WTFMove(*duration),
            WTFMove(*buffer)
        }
    };
}

#endif

#if ENABLE(WEB_CODECS)
void ArgumentCoder<WebCore::WebCodecsEncodedAudioChunkData>::encode(Encoder& encoder, const WebCore::WebCodecsEncodedAudioChunkData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::WebCodecsEncodedAudioChunkType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timestamp)>, int64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.duration)>, std::optional<uint64_t>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.buffer)>, Vector<uint8_t>>);
    struct ShouldBeSameSizeAsWebCodecsEncodedAudioChunkData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::WebCodecsEncodedAudioChunkData>, false> {
        WebCore::WebCodecsEncodedAudioChunkType type;
        int64_t timestamp;
        std::optional<uint64_t> duration;
        Vector<uint8_t> buffer;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebCodecsEncodedAudioChunkData) == sizeof(WebCore::WebCodecsEncodedAudioChunkData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::WebCodecsEncodedAudioChunkData, type)
        , offsetof(WebCore::WebCodecsEncodedAudioChunkData, timestamp)
        , offsetof(WebCore::WebCodecsEncodedAudioChunkData, duration)
        , offsetof(WebCore::WebCodecsEncodedAudioChunkData, buffer)
    >::value);

    encoder << instance.type;
    encoder << instance.timestamp;
    encoder << instance.duration;
    encoder << instance.buffer;
}

std::optional<WebCore::WebCodecsEncodedAudioChunkData> ArgumentCoder<WebCore::WebCodecsEncodedAudioChunkData>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::WebCodecsEncodedAudioChunkType>();
    auto timestamp = decoder.decode<int64_t>();
    auto duration = decoder.decode<std::optional<uint64_t>>();
    auto buffer = decoder.decode<Vector<uint8_t>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::WebCodecsEncodedAudioChunkData {
            WTFMove(*type),
            WTFMove(*timestamp),
            WTFMove(*duration),
            WTFMove(*buffer)
        }
    };
}

#endif

void ArgumentCoder<WebCore::HTMLModelElementCamera>::encode(Encoder& encoder, const WebCore::HTMLModelElementCamera& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pitch)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.yaw)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scale)>, double>);
    struct ShouldBeSameSizeAsHTMLModelElementCamera : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::HTMLModelElementCamera>, false> {
        double pitch;
        double yaw;
        double scale;
    };
    static_assert(sizeof(ShouldBeSameSizeAsHTMLModelElementCamera) == sizeof(WebCore::HTMLModelElementCamera));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::HTMLModelElementCamera, pitch)
        , offsetof(WebCore::HTMLModelElementCamera, yaw)
        , offsetof(WebCore::HTMLModelElementCamera, scale)
    >::value);

    encoder << instance.pitch;
    encoder << instance.yaw;
    encoder << instance.scale;
}

std::optional<WebCore::HTMLModelElementCamera> ArgumentCoder<WebCore::HTMLModelElementCamera>::decode(Decoder& decoder)
{
    auto pitch = decoder.decode<double>();
    auto yaw = decoder.decode<double>();
    auto scale = decoder.decode<double>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::HTMLModelElementCamera {
            WTFMove(*pitch),
            WTFMove(*yaw),
            WTFMove(*scale)
        }
    };
}

void ArgumentCoder<WebCore::NotificationData>::encode(Encoder& encoder, const WebCore::NotificationData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.navigateURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.title)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.body)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.iconURL)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tag)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.language)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.direction)>, WebCore::NotificationDirection>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.originString)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.serviceWorkerRegistrationURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.notificationID)>, WTF::UUID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contextIdentifier)>, std::optional<WebCore::ScriptExecutionContextIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceSession)>, PAL::SessionID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.creationTime)>, MonotonicTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data)>, Vector<uint8_t>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.silent)>, std::optional<bool>>);
    struct ShouldBeSameSizeAsNotificationData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::NotificationData>, false> {
        URL navigateURL;
        String title;
        String body;
        String iconURL;
        String tag;
        String language;
        WebCore::NotificationDirection direction;
        String originString;
        URL serviceWorkerRegistrationURL;
        WTF::UUID notificationID;
        std::optional<WebCore::ScriptExecutionContextIdentifier> contextIdentifier;
        PAL::SessionID sourceSession;
        MonotonicTime creationTime;
        Vector<uint8_t> data;
        std::optional<bool> silent;
    };
    static_assert(sizeof(ShouldBeSameSizeAsNotificationData) == sizeof(WebCore::NotificationData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::NotificationData, navigateURL)
        , offsetof(WebCore::NotificationData, title)
        , offsetof(WebCore::NotificationData, body)
        , offsetof(WebCore::NotificationData, iconURL)
        , offsetof(WebCore::NotificationData, tag)
        , offsetof(WebCore::NotificationData, language)
        , offsetof(WebCore::NotificationData, direction)
        , offsetof(WebCore::NotificationData, originString)
        , offsetof(WebCore::NotificationData, serviceWorkerRegistrationURL)
        , offsetof(WebCore::NotificationData, notificationID)
        , offsetof(WebCore::NotificationData, contextIdentifier)
        , offsetof(WebCore::NotificationData, sourceSession)
        , offsetof(WebCore::NotificationData, creationTime)
        , offsetof(WebCore::NotificationData, data)
        , offsetof(WebCore::NotificationData, silent)
    >::value);

    encoder << instance.navigateURL;
    encoder << instance.title;
    encoder << instance.body;
    encoder << instance.iconURL;
    encoder << instance.tag;
    encoder << instance.language;
    encoder << instance.direction;
    encoder << instance.originString;
    encoder << instance.serviceWorkerRegistrationURL;
    encoder << instance.notificationID;
    encoder << instance.contextIdentifier;
    encoder << instance.sourceSession;
    encoder << instance.creationTime;
    encoder << instance.data;
    encoder << instance.silent;
}

std::optional<WebCore::NotificationData> ArgumentCoder<WebCore::NotificationData>::decode(Decoder& decoder)
{
    auto navigateURL = decoder.decode<URL>();
    auto title = decoder.decode<String>();
    auto body = decoder.decode<String>();
    auto iconURL = decoder.decode<String>();
    auto tag = decoder.decode<String>();
    auto language = decoder.decode<String>();
    auto direction = decoder.decode<WebCore::NotificationDirection>();
    auto originString = decoder.decode<String>();
    auto serviceWorkerRegistrationURL = decoder.decode<URL>();
    auto notificationID = decoder.decode<WTF::UUID>();
    auto contextIdentifier = decoder.decode<std::optional<WebCore::ScriptExecutionContextIdentifier>>();
    auto sourceSession = decoder.decode<PAL::SessionID>();
    auto creationTime = decoder.decode<MonotonicTime>();
    auto data = decoder.decode<Vector<uint8_t>>();
    auto silent = decoder.decode<std::optional<bool>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::NotificationData {
            WTFMove(*navigateURL),
            WTFMove(*title),
            WTFMove(*body),
            WTFMove(*iconURL),
            WTFMove(*tag),
            WTFMove(*language),
            WTFMove(*direction),
            WTFMove(*originString),
            WTFMove(*serviceWorkerRegistrationURL),
            WTFMove(*notificationID),
            WTFMove(*contextIdentifier),
            WTFMove(*sourceSession),
            WTFMove(*creationTime),
            WTFMove(*data),
            WTFMove(*silent)
        }
    };
}

void ArgumentCoder<WebCore::PermissionDescriptor>::encode(Encoder& encoder, const WebCore::PermissionDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, WebCore::PermissionName>);
    struct ShouldBeSameSizeAsPermissionDescriptor : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PermissionDescriptor>, false> {
        WebCore::PermissionName name;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPermissionDescriptor) == sizeof(WebCore::PermissionDescriptor));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PermissionDescriptor, name)
    >::value);

    encoder << instance.name;
}

std::optional<WebCore::PermissionDescriptor> ArgumentCoder<WebCore::PermissionDescriptor>::decode(Decoder& decoder)
{
    auto name = decoder.decode<WebCore::PermissionName>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PermissionDescriptor {
            WTFMove(*name)
        }
    };
}

void ArgumentCoder<WebCore::PushSubscriptionData>::encode(Encoder& encoder, const WebCore::PushSubscriptionData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, Markable<WebCore::PushSubscriptionIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.endpoint)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.expirationTime)>, std::optional<WebCore::EpochTimeStamp>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.serverVAPIDPublicKey)>, Vector<uint8_t>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.clientECDHPublicKey)>, Vector<uint8_t>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sharedAuthenticationSecret)>, Vector<uint8_t>>);
    struct ShouldBeSameSizeAsPushSubscriptionData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PushSubscriptionData>, false> {
        Markable<WebCore::PushSubscriptionIdentifier> identifier;
        String endpoint;
        std::optional<WebCore::EpochTimeStamp> expirationTime;
        Vector<uint8_t> serverVAPIDPublicKey;
        Vector<uint8_t> clientECDHPublicKey;
        Vector<uint8_t> sharedAuthenticationSecret;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPushSubscriptionData) == sizeof(WebCore::PushSubscriptionData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PushSubscriptionData, identifier)
        , offsetof(WebCore::PushSubscriptionData, endpoint)
        , offsetof(WebCore::PushSubscriptionData, expirationTime)
        , offsetof(WebCore::PushSubscriptionData, serverVAPIDPublicKey)
        , offsetof(WebCore::PushSubscriptionData, clientECDHPublicKey)
        , offsetof(WebCore::PushSubscriptionData, sharedAuthenticationSecret)
    >::value);

    encoder << instance.identifier;
    encoder << instance.endpoint;
    encoder << instance.expirationTime;
    encoder << instance.serverVAPIDPublicKey;
    encoder << instance.clientECDHPublicKey;
    encoder << instance.sharedAuthenticationSecret;
}

std::optional<WebCore::PushSubscriptionData> ArgumentCoder<WebCore::PushSubscriptionData>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<Markable<WebCore::PushSubscriptionIdentifier>>();
    auto endpoint = decoder.decode<String>();
    auto expirationTime = decoder.decode<std::optional<WebCore::EpochTimeStamp>>();
    auto serverVAPIDPublicKey = decoder.decode<Vector<uint8_t>>();
    auto clientECDHPublicKey = decoder.decode<Vector<uint8_t>>();
    auto sharedAuthenticationSecret = decoder.decode<Vector<uint8_t>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PushSubscriptionData {
            WTFMove(*identifier),
            WTFMove(*endpoint),
            WTFMove(*expirationTime),
            WTFMove(*serverVAPIDPublicKey),
            WTFMove(*clientECDHPublicKey),
            WTFMove(*sharedAuthenticationSecret)
        }
    };
}

void ArgumentCoder<WebCore::DeprecationReportBody>::encode(Encoder& encoder, const WebCore::DeprecationReportBody& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.id())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.anticipatedRemoval())>, WallTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.message())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceFile())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lineNumber())>, std::optional<unsigned>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.columnNumber())>, std::optional<unsigned>>);

    encoder << instance.id();
    encoder << instance.anticipatedRemoval();
    encoder << instance.message();
    encoder << instance.sourceFile();
    encoder << instance.lineNumber();
    encoder << instance.columnNumber();
}

std::optional<Ref<WebCore::DeprecationReportBody>> ArgumentCoder<WebCore::DeprecationReportBody>::decode(Decoder& decoder)
{
    auto id = decoder.decode<String>();
    auto anticipatedRemoval = decoder.decode<WallTime>();
    auto message = decoder.decode<String>();
    auto sourceFile = decoder.decode<String>();
    auto lineNumber = decoder.decode<std::optional<unsigned>>();
    auto columnNumber = decoder.decode<std::optional<unsigned>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DeprecationReportBody::create(
            WTFMove(*id),
            WTFMove(*anticipatedRemoval),
            WTFMove(*message),
            WTFMove(*sourceFile),
            WTFMove(*lineNumber),
            WTFMove(*columnNumber)
        )
    };
}

void ArgumentCoder<WebCore::Report>::encode(Encoder& encoder, const WebCore::Report& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.body())>, RefPtr<WebCore::ReportBody>>);

    encoder << instance.type();
    encoder << instance.url();
    encoder << instance.body();
}

std::optional<Ref<WebCore::Report>> ArgumentCoder<WebCore::Report>::decode(Decoder& decoder)
{
    auto type = decoder.decode<String>();
    auto url = decoder.decode<String>();
    auto body = decoder.decode<RefPtr<WebCore::ReportBody>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Report::create(
            WTFMove(*type),
            WTFMove(*url),
            WTFMove(*body)
        )
    };
}

void ArgumentCoder<WebCore::TestReportBody>::encode(Encoder& encoder, const WebCore::TestReportBody& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.message())>, String>);

    encoder << instance.message();
}

std::optional<Ref<WebCore::TestReportBody>> ArgumentCoder<WebCore::TestReportBody>::decode(Decoder& decoder)
{
    auto message = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TestReportBody::create(
            WTFMove(*message)
        )
    };
}

void ArgumentCoder<WebCore::SpeechRecognitionError>::encode(Encoder& encoder, const WebCore::SpeechRecognitionError& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::SpeechRecognitionErrorType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.message)>, String>);
    struct ShouldBeSameSizeAsSpeechRecognitionError : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SpeechRecognitionError>, false> {
        WebCore::SpeechRecognitionErrorType type;
        String message;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSpeechRecognitionError) == sizeof(WebCore::SpeechRecognitionError));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SpeechRecognitionError, type)
        , offsetof(WebCore::SpeechRecognitionError, message)
    >::value);

    encoder << instance.type;
    encoder << instance.message;
}

std::optional<WebCore::SpeechRecognitionError> ArgumentCoder<WebCore::SpeechRecognitionError>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::SpeechRecognitionErrorType>();
    auto message = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SpeechRecognitionError {
            WTFMove(*type),
            WTFMove(*message)
        }
    };
}

void ArgumentCoder<WebCore::SpeechRecognitionRequestInfo>::encode(Encoder& encoder, const WebCore::SpeechRecognitionRequestInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.clientIdentifier)>, WebCore::SpeechRecognitionConnectionClientIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lang)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.continuous)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.interimResults)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxAlternatives)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.clientOrigin)>, WebCore::ClientOrigin>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mainFrameIdentifier)>, WebCore::FrameIdentifier>);
    struct ShouldBeSameSizeAsSpeechRecognitionRequestInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SpeechRecognitionRequestInfo>, false> {
        WebCore::SpeechRecognitionConnectionClientIdentifier clientIdentifier;
        String lang;
        bool continuous;
        bool interimResults;
        uint64_t maxAlternatives;
        WebCore::ClientOrigin clientOrigin;
        WebCore::FrameIdentifier mainFrameIdentifier;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSpeechRecognitionRequestInfo) == sizeof(WebCore::SpeechRecognitionRequestInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SpeechRecognitionRequestInfo, clientIdentifier)
        , offsetof(WebCore::SpeechRecognitionRequestInfo, lang)
        , offsetof(WebCore::SpeechRecognitionRequestInfo, continuous)
        , offsetof(WebCore::SpeechRecognitionRequestInfo, interimResults)
        , offsetof(WebCore::SpeechRecognitionRequestInfo, maxAlternatives)
        , offsetof(WebCore::SpeechRecognitionRequestInfo, clientOrigin)
        , offsetof(WebCore::SpeechRecognitionRequestInfo, mainFrameIdentifier)
    >::value);

    encoder << instance.clientIdentifier;
    encoder << instance.lang;
    encoder << instance.continuous;
    encoder << instance.interimResults;
    encoder << instance.maxAlternatives;
    encoder << instance.clientOrigin;
    encoder << instance.mainFrameIdentifier;
}

std::optional<WebCore::SpeechRecognitionRequestInfo> ArgumentCoder<WebCore::SpeechRecognitionRequestInfo>::decode(Decoder& decoder)
{
    auto clientIdentifier = decoder.decode<WebCore::SpeechRecognitionConnectionClientIdentifier>();
    auto lang = decoder.decode<String>();
    auto continuous = decoder.decode<bool>();
    auto interimResults = decoder.decode<bool>();
    auto maxAlternatives = decoder.decode<uint64_t>();
    auto clientOrigin = decoder.decode<WebCore::ClientOrigin>();
    auto mainFrameIdentifier = decoder.decode<WebCore::FrameIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SpeechRecognitionRequestInfo {
            WTFMove(*clientIdentifier),
            WTFMove(*lang),
            WTFMove(*continuous),
            WTFMove(*interimResults),
            WTFMove(*maxAlternatives),
            WTFMove(*clientOrigin),
            WTFMove(*mainFrameIdentifier)
        }
    };
}

void ArgumentCoder<WebCore::SpeechRecognitionAlternativeData>::encode(Encoder& encoder, const WebCore::SpeechRecognitionAlternativeData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.transcript)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.confidence)>, double>);
    struct ShouldBeSameSizeAsSpeechRecognitionAlternativeData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SpeechRecognitionAlternativeData>, false> {
        String transcript;
        double confidence;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSpeechRecognitionAlternativeData) == sizeof(WebCore::SpeechRecognitionAlternativeData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SpeechRecognitionAlternativeData, transcript)
        , offsetof(WebCore::SpeechRecognitionAlternativeData, confidence)
    >::value);

    encoder << instance.transcript;
    encoder << instance.confidence;
}

std::optional<WebCore::SpeechRecognitionAlternativeData> ArgumentCoder<WebCore::SpeechRecognitionAlternativeData>::decode(Decoder& decoder)
{
    auto transcript = decoder.decode<String>();
    auto confidence = decoder.decode<double>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SpeechRecognitionAlternativeData {
            WTFMove(*transcript),
            WTFMove(*confidence)
        }
    };
}

void ArgumentCoder<WebCore::SpeechRecognitionResultData>::encode(Encoder& encoder, const WebCore::SpeechRecognitionResultData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.alternatives)>, Vector<WebCore::SpeechRecognitionAlternativeData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isFinal)>, bool>);
    struct ShouldBeSameSizeAsSpeechRecognitionResultData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SpeechRecognitionResultData>, false> {
        Vector<WebCore::SpeechRecognitionAlternativeData> alternatives;
        bool isFinal;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSpeechRecognitionResultData) == sizeof(WebCore::SpeechRecognitionResultData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SpeechRecognitionResultData, alternatives)
        , offsetof(WebCore::SpeechRecognitionResultData, isFinal)
    >::value);

    encoder << instance.alternatives;
    encoder << instance.isFinal;
}

std::optional<WebCore::SpeechRecognitionResultData> ArgumentCoder<WebCore::SpeechRecognitionResultData>::decode(Decoder& decoder)
{
    auto alternatives = decoder.decode<Vector<WebCore::SpeechRecognitionAlternativeData>>();
    auto isFinal = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SpeechRecognitionResultData {
            WTFMove(*alternatives),
            WTFMove(*isFinal)
        }
    };
}

void ArgumentCoder<WebCore::WebLockManagerSnapshot>::encode(Encoder& encoder, const WebCore::WebLockManagerSnapshot& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.held)>, Vector<WebCore::WebLockManagerSnapshot::Info>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pending)>, Vector<WebCore::WebLockManagerSnapshot::Info>>);
    struct ShouldBeSameSizeAsWebLockManagerSnapshot : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::WebLockManagerSnapshot>, false> {
        Vector<WebCore::WebLockManagerSnapshot::Info> held;
        Vector<WebCore::WebLockManagerSnapshot::Info> pending;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebLockManagerSnapshot) == sizeof(WebCore::WebLockManagerSnapshot));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::WebLockManagerSnapshot, held)
        , offsetof(WebCore::WebLockManagerSnapshot, pending)
    >::value);

    encoder << instance.held;
    encoder << instance.pending;
}

std::optional<WebCore::WebLockManagerSnapshot> ArgumentCoder<WebCore::WebLockManagerSnapshot>::decode(Decoder& decoder)
{
    auto held = decoder.decode<Vector<WebCore::WebLockManagerSnapshot::Info>>();
    auto pending = decoder.decode<Vector<WebCore::WebLockManagerSnapshot::Info>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::WebLockManagerSnapshot {
            WTFMove(*held),
            WTFMove(*pending)
        }
    };
}

void ArgumentCoder<WebCore::WebLockManagerSnapshot::Info>::encode(Encoder& encoder, const WebCore::WebLockManagerSnapshot::Info& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mode)>, WebCore::WebLockMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.clientId)>, String>);
    struct ShouldBeSameSizeAsInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::WebLockManagerSnapshot::Info>, false> {
        String name;
        WebCore::WebLockMode mode;
        String clientId;
    };
    static_assert(sizeof(ShouldBeSameSizeAsInfo) == sizeof(WebCore::WebLockManagerSnapshot::Info));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::WebLockManagerSnapshot::Info, name)
        , offsetof(WebCore::WebLockManagerSnapshot::Info, mode)
        , offsetof(WebCore::WebLockManagerSnapshot::Info, clientId)
    >::value);

    encoder << instance.name;
    encoder << instance.mode;
    encoder << instance.clientId;
}

std::optional<WebCore::WebLockManagerSnapshot::Info> ArgumentCoder<WebCore::WebLockManagerSnapshot::Info>::decode(Decoder& decoder)
{
    auto name = decoder.decode<String>();
    auto mode = decoder.decode<WebCore::WebLockMode>();
    auto clientId = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::WebLockManagerSnapshot::Info {
            WTFMove(*name),
            WTFMove(*mode),
            WTFMove(*clientId)
        }
    };
}

#if ENABLE(WEB_AUTHN)
void ArgumentCoder<WebCore::AuthenticatorResponseBaseData>::encode(Encoder& encoder, const WebCore::AuthenticatorResponseBaseData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rawId)>, RefPtr<JSC::ArrayBuffer>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.extensionOutputs)>, std::optional<WebCore::AuthenticationExtensionsClientOutputs>>);
    struct ShouldBeSameSizeAsAuthenticatorResponseBaseData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::AuthenticatorResponseBaseData>, false> {
        RefPtr<JSC::ArrayBuffer> rawId;
        std::optional<WebCore::AuthenticationExtensionsClientOutputs> extensionOutputs;
    };
    static_assert(sizeof(ShouldBeSameSizeAsAuthenticatorResponseBaseData) == sizeof(WebCore::AuthenticatorResponseBaseData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::AuthenticatorResponseBaseData, rawId)
        , offsetof(WebCore::AuthenticatorResponseBaseData, extensionOutputs)
    >::value);

    encoder << instance.rawId;
    encoder << instance.extensionOutputs;
}

std::optional<WebCore::AuthenticatorResponseBaseData> ArgumentCoder<WebCore::AuthenticatorResponseBaseData>::decode(Decoder& decoder)
{
    auto rawId = decoder.decode<RefPtr<JSC::ArrayBuffer>>();
    auto extensionOutputs = decoder.decode<std::optional<WebCore::AuthenticationExtensionsClientOutputs>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::AuthenticatorResponseBaseData {
            WTFMove(*rawId),
            WTFMove(*extensionOutputs)
        }
    };
}

#endif

#if ENABLE(WEB_AUTHN)
void ArgumentCoder<WebCore::AuthenticatorAttestationResponseData>::encode(Encoder& encoder, const WebCore::AuthenticatorAttestationResponseData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rawId)>, RefPtr<JSC::ArrayBuffer>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.extensionOutputs)>, std::optional<WebCore::AuthenticationExtensionsClientOutputs>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.clientDataJSON)>, RefPtr<JSC::ArrayBuffer>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.attestationObject)>, RefPtr<JSC::ArrayBuffer>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.transports)>, Vector<WebCore::AuthenticatorTransport>>);
    struct ShouldBeSameSizeAsAuthenticatorAttestationResponseData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::AuthenticatorAttestationResponseData>, false> {
        RefPtr<JSC::ArrayBuffer> rawId;
        std::optional<WebCore::AuthenticationExtensionsClientOutputs> extensionOutputs;
        RefPtr<JSC::ArrayBuffer> clientDataJSON;
        RefPtr<JSC::ArrayBuffer> attestationObject;
        Vector<WebCore::AuthenticatorTransport> transports;
    };
    static_assert(sizeof(ShouldBeSameSizeAsAuthenticatorAttestationResponseData) == sizeof(WebCore::AuthenticatorAttestationResponseData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::AuthenticatorAttestationResponseData, rawId)
        , offsetof(WebCore::AuthenticatorAttestationResponseData, extensionOutputs)
        , offsetof(WebCore::AuthenticatorAttestationResponseData, clientDataJSON)
        , offsetof(WebCore::AuthenticatorAttestationResponseData, attestationObject)
        , offsetof(WebCore::AuthenticatorAttestationResponseData, transports)
    >::value);

    encoder << instance.rawId;
    encoder << instance.extensionOutputs;
    encoder << instance.clientDataJSON;
    encoder << instance.attestationObject;
    encoder << instance.transports;
}

std::optional<WebCore::AuthenticatorAttestationResponseData> ArgumentCoder<WebCore::AuthenticatorAttestationResponseData>::decode(Decoder& decoder)
{
    auto rawId = decoder.decode<RefPtr<JSC::ArrayBuffer>>();
    auto extensionOutputs = decoder.decode<std::optional<WebCore::AuthenticationExtensionsClientOutputs>>();
    auto clientDataJSON = decoder.decode<RefPtr<JSC::ArrayBuffer>>();
    auto attestationObject = decoder.decode<RefPtr<JSC::ArrayBuffer>>();
    auto transports = decoder.decode<Vector<WebCore::AuthenticatorTransport>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::AuthenticatorAttestationResponseData {
            WTFMove(*rawId),
            WTFMove(*extensionOutputs),
            WTFMove(*clientDataJSON),
            WTFMove(*attestationObject),
            WTFMove(*transports)
        }
    };
}

#endif

#if ENABLE(WEB_AUTHN)
void ArgumentCoder<WebCore::AuthenticatorAssertionResponseData>::encode(Encoder& encoder, const WebCore::AuthenticatorAssertionResponseData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rawId)>, RefPtr<JSC::ArrayBuffer>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.extensionOutputs)>, std::optional<WebCore::AuthenticationExtensionsClientOutputs>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.clientDataJSON)>, RefPtr<JSC::ArrayBuffer>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.authenticatorData)>, RefPtr<JSC::ArrayBuffer>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.signature)>, RefPtr<JSC::ArrayBuffer>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.userHandle)>, RefPtr<JSC::ArrayBuffer>>);
    struct ShouldBeSameSizeAsAuthenticatorAssertionResponseData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::AuthenticatorAssertionResponseData>, false> {
        RefPtr<JSC::ArrayBuffer> rawId;
        std::optional<WebCore::AuthenticationExtensionsClientOutputs> extensionOutputs;
        RefPtr<JSC::ArrayBuffer> clientDataJSON;
        RefPtr<JSC::ArrayBuffer> authenticatorData;
        RefPtr<JSC::ArrayBuffer> signature;
        RefPtr<JSC::ArrayBuffer> userHandle;
    };
    static_assert(sizeof(ShouldBeSameSizeAsAuthenticatorAssertionResponseData) == sizeof(WebCore::AuthenticatorAssertionResponseData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::AuthenticatorAssertionResponseData, rawId)
        , offsetof(WebCore::AuthenticatorAssertionResponseData, extensionOutputs)
        , offsetof(WebCore::AuthenticatorAssertionResponseData, clientDataJSON)
        , offsetof(WebCore::AuthenticatorAssertionResponseData, authenticatorData)
        , offsetof(WebCore::AuthenticatorAssertionResponseData, signature)
        , offsetof(WebCore::AuthenticatorAssertionResponseData, userHandle)
    >::value);

    encoder << instance.rawId;
    encoder << instance.extensionOutputs;
    encoder << instance.clientDataJSON;
    encoder << instance.authenticatorData;
    encoder << instance.signature;
    encoder << instance.userHandle;
}

std::optional<WebCore::AuthenticatorAssertionResponseData> ArgumentCoder<WebCore::AuthenticatorAssertionResponseData>::decode(Decoder& decoder)
{
    auto rawId = decoder.decode<RefPtr<JSC::ArrayBuffer>>();
    auto extensionOutputs = decoder.decode<std::optional<WebCore::AuthenticationExtensionsClientOutputs>>();
    auto clientDataJSON = decoder.decode<RefPtr<JSC::ArrayBuffer>>();
    auto authenticatorData = decoder.decode<RefPtr<JSC::ArrayBuffer>>();
    auto signature = decoder.decode<RefPtr<JSC::ArrayBuffer>>();
    auto userHandle = decoder.decode<RefPtr<JSC::ArrayBuffer>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::AuthenticatorAssertionResponseData {
            WTFMove(*rawId),
            WTFMove(*extensionOutputs),
            WTFMove(*clientDataJSON),
            WTFMove(*authenticatorData),
            WTFMove(*signature),
            WTFMove(*userHandle)
        }
    };
}

#endif

#if ENABLE(WEB_AUTHN)
void ArgumentCoder<WebCore::AuthenticatorResponseData>::encode(Encoder& encoder, const WebCore::AuthenticatorResponseData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.getSerializableForm())>, WebCore::AuthenticatorResponseDataSerializableForm>);

    encoder << instance.getSerializableForm();
}

std::optional<WebCore::AuthenticatorResponseData> ArgumentCoder<WebCore::AuthenticatorResponseData>::decode(Decoder& decoder)
{
    auto getSerializableForm = decoder.decode<WebCore::AuthenticatorResponseDataSerializableForm>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::AuthenticatorResponseData {
            WTFMove(*getSerializableForm)
        }
    };
}

#endif

#if ENABLE(WEB_AUTHN)
void ArgumentCoder<WebCore::AuthenticationExtensionsClientInputs::LargeBlobInputs>::encode(Encoder& encoder, const WebCore::AuthenticationExtensionsClientInputs::LargeBlobInputs& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.support)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.read)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.write)>, std::optional<WebCore::BufferSource>>);
    struct ShouldBeSameSizeAsLargeBlobInputs : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::AuthenticationExtensionsClientInputs::LargeBlobInputs>, false> {
        String support;
        std::optional<bool> read;
        std::optional<WebCore::BufferSource> write;
    };
    static_assert(sizeof(ShouldBeSameSizeAsLargeBlobInputs) == sizeof(WebCore::AuthenticationExtensionsClientInputs::LargeBlobInputs));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::AuthenticationExtensionsClientInputs::LargeBlobInputs, support)
        , offsetof(WebCore::AuthenticationExtensionsClientInputs::LargeBlobInputs, read)
        , offsetof(WebCore::AuthenticationExtensionsClientInputs::LargeBlobInputs, write)
    >::value);

    encoder << instance.support;
    encoder << instance.read;
    encoder << instance.write;
}

std::optional<WebCore::AuthenticationExtensionsClientInputs::LargeBlobInputs> ArgumentCoder<WebCore::AuthenticationExtensionsClientInputs::LargeBlobInputs>::decode(Decoder& decoder)
{
    auto support = decoder.decode<String>();
    auto read = decoder.decode<std::optional<bool>>();
    auto write = decoder.decode<std::optional<WebCore::BufferSource>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::AuthenticationExtensionsClientInputs::LargeBlobInputs {
            WTFMove(*support),
            WTFMove(*read),
            WTFMove(*write)
        }
    };
}

#endif

#if ENABLE(WEB_AUTHN)
void ArgumentCoder<WebCore::AuthenticationExtensionsClientInputs::PRFValues>::encode(Encoder& encoder, const WebCore::AuthenticationExtensionsClientInputs::PRFValues& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.first)>, WebCore::BufferSource>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.second)>, std::optional<WebCore::BufferSource>>);
    struct ShouldBeSameSizeAsPRFValues : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::AuthenticationExtensionsClientInputs::PRFValues>, false> {
        WebCore::BufferSource first;
        std::optional<WebCore::BufferSource> second;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPRFValues) == sizeof(WebCore::AuthenticationExtensionsClientInputs::PRFValues));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::AuthenticationExtensionsClientInputs::PRFValues, first)
        , offsetof(WebCore::AuthenticationExtensionsClientInputs::PRFValues, second)
    >::value);

    encoder << instance.first;
    encoder << instance.second;
}

std::optional<WebCore::AuthenticationExtensionsClientInputs::PRFValues> ArgumentCoder<WebCore::AuthenticationExtensionsClientInputs::PRFValues>::decode(Decoder& decoder)
{
    auto first = decoder.decode<WebCore::BufferSource>();
    auto second = decoder.decode<std::optional<WebCore::BufferSource>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::AuthenticationExtensionsClientInputs::PRFValues {
            WTFMove(*first),
            WTFMove(*second)
        }
    };
}

#endif

#if ENABLE(WEB_AUTHN)
void ArgumentCoder<WebCore::AuthenticationExtensionsClientInputs::PRFInputs>::encode(Encoder& encoder, const WebCore::AuthenticationExtensionsClientInputs::PRFInputs& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.eval)>, std::optional<WebCore::AuthenticationExtensionsClientInputs::PRFValues>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.evalByCredential)>, std::optional<Vector<KeyValuePair<String, WebCore::AuthenticationExtensionsClientInputs::PRFValues>>>>);
    struct ShouldBeSameSizeAsPRFInputs : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::AuthenticationExtensionsClientInputs::PRFInputs>, false> {
        std::optional<WebCore::AuthenticationExtensionsClientInputs::PRFValues> eval;
        std::optional<Vector<KeyValuePair<String, WebCore::AuthenticationExtensionsClientInputs::PRFValues>>> evalByCredential;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPRFInputs) == sizeof(WebCore::AuthenticationExtensionsClientInputs::PRFInputs));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::AuthenticationExtensionsClientInputs::PRFInputs, eval)
        , offsetof(WebCore::AuthenticationExtensionsClientInputs::PRFInputs, evalByCredential)
    >::value);

    encoder << instance.eval;
    encoder << instance.evalByCredential;
}

std::optional<WebCore::AuthenticationExtensionsClientInputs::PRFInputs> ArgumentCoder<WebCore::AuthenticationExtensionsClientInputs::PRFInputs>::decode(Decoder& decoder)
{
    auto eval = decoder.decode<std::optional<WebCore::AuthenticationExtensionsClientInputs::PRFValues>>();
    auto evalByCredential = decoder.decode<std::optional<Vector<KeyValuePair<String, WebCore::AuthenticationExtensionsClientInputs::PRFValues>>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::AuthenticationExtensionsClientInputs::PRFInputs {
            WTFMove(*eval),
            WTFMove(*evalByCredential)
        }
    };
}

#endif

#if ENABLE(WEB_AUTHN)
void ArgumentCoder<WebCore::AuthenticationExtensionsClientInputs>::encode(Encoder& encoder, const WebCore::AuthenticationExtensionsClientInputs& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.appid)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.credProps)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.largeBlob)>, std::optional<WebCore::AuthenticationExtensionsClientInputs::LargeBlobInputs>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.prf)>, std::optional<WebCore::AuthenticationExtensionsClientInputs::PRFInputs>>);
    struct ShouldBeSameSizeAsAuthenticationExtensionsClientInputs : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::AuthenticationExtensionsClientInputs>, false> {
        String appid;
        std::optional<bool> credProps;
        std::optional<WebCore::AuthenticationExtensionsClientInputs::LargeBlobInputs> largeBlob;
        std::optional<WebCore::AuthenticationExtensionsClientInputs::PRFInputs> prf;
    };
    static_assert(sizeof(ShouldBeSameSizeAsAuthenticationExtensionsClientInputs) == sizeof(WebCore::AuthenticationExtensionsClientInputs));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::AuthenticationExtensionsClientInputs, appid)
        , offsetof(WebCore::AuthenticationExtensionsClientInputs, credProps)
        , offsetof(WebCore::AuthenticationExtensionsClientInputs, largeBlob)
        , offsetof(WebCore::AuthenticationExtensionsClientInputs, prf)
    >::value);

    encoder << instance.appid;
    encoder << instance.credProps;
    encoder << instance.largeBlob;
    encoder << instance.prf;
}

std::optional<WebCore::AuthenticationExtensionsClientInputs> ArgumentCoder<WebCore::AuthenticationExtensionsClientInputs>::decode(Decoder& decoder)
{
    auto appid = decoder.decode<String>();
    auto credProps = decoder.decode<std::optional<bool>>();
    auto largeBlob = decoder.decode<std::optional<WebCore::AuthenticationExtensionsClientInputs::LargeBlobInputs>>();
    auto prf = decoder.decode<std::optional<WebCore::AuthenticationExtensionsClientInputs::PRFInputs>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    WebCore::AuthenticationExtensionsClientInputs result;
    result.appid = WTFMove(*appid);
    result.credProps = WTFMove(*credProps);
    result.largeBlob = WTFMove(*largeBlob);
    result.prf = WTFMove(*prf);
    return { WTFMove(result) };
}

#endif

#if ENABLE(WEB_AUTHN)
void ArgumentCoder<WebCore::CredentialPropertiesOutput>::encode(Encoder& encoder, const WebCore::CredentialPropertiesOutput& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rk)>, bool>);
    struct ShouldBeSameSizeAsCredentialPropertiesOutput : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::CredentialPropertiesOutput>, false> {
        bool rk;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCredentialPropertiesOutput) == sizeof(WebCore::CredentialPropertiesOutput));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::CredentialPropertiesOutput, rk)
    >::value);

    encoder << instance.rk;
}

std::optional<WebCore::CredentialPropertiesOutput> ArgumentCoder<WebCore::CredentialPropertiesOutput>::decode(Decoder& decoder)
{
    auto rk = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CredentialPropertiesOutput {
            WTFMove(*rk)
        }
    };
}

#endif

#if ENABLE(WEB_AUTHN)
void ArgumentCoder<WebCore::AuthenticationExtensionsClientOutputs::LargeBlobOutputs>::encode(Encoder& encoder, const WebCore::AuthenticationExtensionsClientOutputs::LargeBlobOutputs& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supported)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.blob)>, RefPtr<JSC::ArrayBuffer>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.written)>, std::optional<bool>>);
    struct ShouldBeSameSizeAsLargeBlobOutputs : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::AuthenticationExtensionsClientOutputs::LargeBlobOutputs>, false> {
        std::optional<bool> supported;
        RefPtr<JSC::ArrayBuffer> blob;
        std::optional<bool> written;
    };
    static_assert(sizeof(ShouldBeSameSizeAsLargeBlobOutputs) == sizeof(WebCore::AuthenticationExtensionsClientOutputs::LargeBlobOutputs));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::AuthenticationExtensionsClientOutputs::LargeBlobOutputs, supported)
        , offsetof(WebCore::AuthenticationExtensionsClientOutputs::LargeBlobOutputs, blob)
        , offsetof(WebCore::AuthenticationExtensionsClientOutputs::LargeBlobOutputs, written)
    >::value);

    encoder << instance.supported;
    encoder << instance.blob;
    encoder << instance.written;
}

std::optional<WebCore::AuthenticationExtensionsClientOutputs::LargeBlobOutputs> ArgumentCoder<WebCore::AuthenticationExtensionsClientOutputs::LargeBlobOutputs>::decode(Decoder& decoder)
{
    auto supported = decoder.decode<std::optional<bool>>();
    auto blob = decoder.decode<RefPtr<JSC::ArrayBuffer>>();
    auto written = decoder.decode<std::optional<bool>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::AuthenticationExtensionsClientOutputs::LargeBlobOutputs {
            WTFMove(*supported),
            WTFMove(*blob),
            WTFMove(*written)
        }
    };
}

#endif

#if ENABLE(WEB_AUTHN)
void ArgumentCoder<WebCore::AuthenticationExtensionsClientOutputs::PRFValues>::encode(Encoder& encoder, const WebCore::AuthenticationExtensionsClientOutputs::PRFValues& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.first)>, RefPtr<JSC::ArrayBuffer>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.second)>, RefPtr<JSC::ArrayBuffer>>);
    struct ShouldBeSameSizeAsPRFValues : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::AuthenticationExtensionsClientOutputs::PRFValues>, false> {
        RefPtr<JSC::ArrayBuffer> first;
        RefPtr<JSC::ArrayBuffer> second;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPRFValues) == sizeof(WebCore::AuthenticationExtensionsClientOutputs::PRFValues));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::AuthenticationExtensionsClientOutputs::PRFValues, first)
        , offsetof(WebCore::AuthenticationExtensionsClientOutputs::PRFValues, second)
    >::value);

    encoder << instance.first;
    encoder << instance.second;
}

std::optional<WebCore::AuthenticationExtensionsClientOutputs::PRFValues> ArgumentCoder<WebCore::AuthenticationExtensionsClientOutputs::PRFValues>::decode(Decoder& decoder)
{
    auto first = decoder.decode<RefPtr<JSC::ArrayBuffer>>();
    auto second = decoder.decode<RefPtr<JSC::ArrayBuffer>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::AuthenticationExtensionsClientOutputs::PRFValues {
            WTFMove(*first),
            WTFMove(*second)
        }
    };
}

#endif

#if ENABLE(WEB_AUTHN)
void ArgumentCoder<WebCore::AuthenticationExtensionsClientOutputs::PRFOutputs>::encode(Encoder& encoder, const WebCore::AuthenticationExtensionsClientOutputs::PRFOutputs& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.enabled)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.results)>, std::optional<WebCore::AuthenticationExtensionsClientOutputs::PRFValues>>);
    struct ShouldBeSameSizeAsPRFOutputs : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::AuthenticationExtensionsClientOutputs::PRFOutputs>, false> {
        std::optional<bool> enabled;
        std::optional<WebCore::AuthenticationExtensionsClientOutputs::PRFValues> results;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPRFOutputs) == sizeof(WebCore::AuthenticationExtensionsClientOutputs::PRFOutputs));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::AuthenticationExtensionsClientOutputs::PRFOutputs, enabled)
        , offsetof(WebCore::AuthenticationExtensionsClientOutputs::PRFOutputs, results)
    >::value);

    encoder << instance.enabled;
    encoder << instance.results;
}

std::optional<WebCore::AuthenticationExtensionsClientOutputs::PRFOutputs> ArgumentCoder<WebCore::AuthenticationExtensionsClientOutputs::PRFOutputs>::decode(Decoder& decoder)
{
    auto enabled = decoder.decode<std::optional<bool>>();
    auto results = decoder.decode<std::optional<WebCore::AuthenticationExtensionsClientOutputs::PRFValues>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::AuthenticationExtensionsClientOutputs::PRFOutputs {
            WTFMove(*enabled),
            WTFMove(*results)
        }
    };
}

#endif

#if ENABLE(WEB_AUTHN)
void ArgumentCoder<WebCore::AuthenticationExtensionsClientOutputs>::encode(Encoder& encoder, const WebCore::AuthenticationExtensionsClientOutputs& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.appid)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.credProps)>, std::optional<WebCore::CredentialPropertiesOutput>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.largeBlob)>, std::optional<WebCore::AuthenticationExtensionsClientOutputs::LargeBlobOutputs>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.prf)>, std::optional<WebCore::AuthenticationExtensionsClientOutputs::PRFOutputs>>);
    struct ShouldBeSameSizeAsAuthenticationExtensionsClientOutputs : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::AuthenticationExtensionsClientOutputs>, false> {
        std::optional<bool> appid;
        std::optional<WebCore::CredentialPropertiesOutput> credProps;
        std::optional<WebCore::AuthenticationExtensionsClientOutputs::LargeBlobOutputs> largeBlob;
        std::optional<WebCore::AuthenticationExtensionsClientOutputs::PRFOutputs> prf;
    };
    static_assert(sizeof(ShouldBeSameSizeAsAuthenticationExtensionsClientOutputs) == sizeof(WebCore::AuthenticationExtensionsClientOutputs));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::AuthenticationExtensionsClientOutputs, appid)
        , offsetof(WebCore::AuthenticationExtensionsClientOutputs, credProps)
        , offsetof(WebCore::AuthenticationExtensionsClientOutputs, largeBlob)
        , offsetof(WebCore::AuthenticationExtensionsClientOutputs, prf)
    >::value);

    encoder << instance.appid;
    encoder << instance.credProps;
    encoder << instance.largeBlob;
    encoder << instance.prf;
}

std::optional<WebCore::AuthenticationExtensionsClientOutputs> ArgumentCoder<WebCore::AuthenticationExtensionsClientOutputs>::decode(Decoder& decoder)
{
    auto appid = decoder.decode<std::optional<bool>>();
    auto credProps = decoder.decode<std::optional<WebCore::CredentialPropertiesOutput>>();
    auto largeBlob = decoder.decode<std::optional<WebCore::AuthenticationExtensionsClientOutputs::LargeBlobOutputs>>();
    auto prf = decoder.decode<std::optional<WebCore::AuthenticationExtensionsClientOutputs::PRFOutputs>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::AuthenticationExtensionsClientOutputs {
            WTFMove(*appid),
            WTFMove(*credProps),
            WTFMove(*largeBlob),
            WTFMove(*prf)
        }
    };
}

#endif

#if ENABLE(WEB_AUTHN)
void ArgumentCoder<WebCore::PublicKeyCredentialParameters>::encode(Encoder& encoder, const WebCore::PublicKeyCredentialParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::PublicKeyCredentialType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.alg)>, int64_t>);
    struct ShouldBeSameSizeAsPublicKeyCredentialParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PublicKeyCredentialParameters>, false> {
        WebCore::PublicKeyCredentialType type;
        int64_t alg;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPublicKeyCredentialParameters) == sizeof(WebCore::PublicKeyCredentialParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PublicKeyCredentialParameters, type)
        , offsetof(WebCore::PublicKeyCredentialParameters, alg)
    >::value);

    encoder << instance.type;
    encoder << instance.alg;
}

std::optional<WebCore::PublicKeyCredentialParameters> ArgumentCoder<WebCore::PublicKeyCredentialParameters>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::PublicKeyCredentialType>();
    auto alg = decoder.decode<int64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PublicKeyCredentialParameters {
            WTFMove(*type),
            WTFMove(*alg)
        }
    };
}

#endif

#if ENABLE(WEB_AUTHN)
void ArgumentCoder<WebCore::UnknownCredentialOptions>::encode(Encoder& encoder, const WebCore::UnknownCredentialOptions& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rpId)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.credentialId)>, String>);
    struct ShouldBeSameSizeAsUnknownCredentialOptions : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::UnknownCredentialOptions>, false> {
        String rpId;
        String credentialId;
    };
    static_assert(sizeof(ShouldBeSameSizeAsUnknownCredentialOptions) == sizeof(WebCore::UnknownCredentialOptions));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::UnknownCredentialOptions, rpId)
        , offsetof(WebCore::UnknownCredentialOptions, credentialId)
    >::value);

    encoder << instance.rpId;
    encoder << instance.credentialId;
}

std::optional<WebCore::UnknownCredentialOptions> ArgumentCoder<WebCore::UnknownCredentialOptions>::decode(Decoder& decoder)
{
    auto rpId = decoder.decode<String>();
    auto credentialId = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::UnknownCredentialOptions {
            WTFMove(*rpId),
            WTFMove(*credentialId)
        }
    };
}

#endif

#if ENABLE(WEB_AUTHN)
void ArgumentCoder<WebCore::AllAcceptedCredentialsOptions>::encode(Encoder& encoder, const WebCore::AllAcceptedCredentialsOptions& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rpId)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.userId)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allAcceptedCredentialIds)>, Vector<String>>);
    struct ShouldBeSameSizeAsAllAcceptedCredentialsOptions : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::AllAcceptedCredentialsOptions>, false> {
        String rpId;
        String userId;
        Vector<String> allAcceptedCredentialIds;
    };
    static_assert(sizeof(ShouldBeSameSizeAsAllAcceptedCredentialsOptions) == sizeof(WebCore::AllAcceptedCredentialsOptions));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::AllAcceptedCredentialsOptions, rpId)
        , offsetof(WebCore::AllAcceptedCredentialsOptions, userId)
        , offsetof(WebCore::AllAcceptedCredentialsOptions, allAcceptedCredentialIds)
    >::value);

    encoder << instance.rpId;
    encoder << instance.userId;
    encoder << instance.allAcceptedCredentialIds;
}

std::optional<WebCore::AllAcceptedCredentialsOptions> ArgumentCoder<WebCore::AllAcceptedCredentialsOptions>::decode(Decoder& decoder)
{
    auto rpId = decoder.decode<String>();
    auto userId = decoder.decode<String>();
    auto allAcceptedCredentialIds = decoder.decode<Vector<String>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::AllAcceptedCredentialsOptions {
            WTFMove(*rpId),
            WTFMove(*userId),
            WTFMove(*allAcceptedCredentialIds)
        }
    };
}

#endif

#if ENABLE(WEB_AUTHN)
void ArgumentCoder<WebCore::CurrentUserDetailsOptions>::encode(Encoder& encoder, const WebCore::CurrentUserDetailsOptions& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rpId)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.userId)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.displayName)>, String>);
    struct ShouldBeSameSizeAsCurrentUserDetailsOptions : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::CurrentUserDetailsOptions>, false> {
        String rpId;
        String userId;
        String name;
        String displayName;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCurrentUserDetailsOptions) == sizeof(WebCore::CurrentUserDetailsOptions));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::CurrentUserDetailsOptions, rpId)
        , offsetof(WebCore::CurrentUserDetailsOptions, userId)
        , offsetof(WebCore::CurrentUserDetailsOptions, name)
        , offsetof(WebCore::CurrentUserDetailsOptions, displayName)
    >::value);

    encoder << instance.rpId;
    encoder << instance.userId;
    encoder << instance.name;
    encoder << instance.displayName;
}

std::optional<WebCore::CurrentUserDetailsOptions> ArgumentCoder<WebCore::CurrentUserDetailsOptions>::decode(Decoder& decoder)
{
    auto rpId = decoder.decode<String>();
    auto userId = decoder.decode<String>();
    auto name = decoder.decode<String>();
    auto displayName = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CurrentUserDetailsOptions {
            WTFMove(*rpId),
            WTFMove(*userId),
            WTFMove(*name),
            WTFMove(*displayName)
        }
    };
}

#endif

#if ENABLE(WEB_AUTHN)
void ArgumentCoder<WebCore::AuthenticatorSelectionCriteria>::encode(Encoder& encoder, const WebCore::AuthenticatorSelectionCriteria& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.authenticatorAttachment)>, std::optional<WebCore::AuthenticatorAttachment>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.residentKey)>, std::optional<WebCore::ResidentKeyRequirement>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requireResidentKey)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.userVerification)>, WebCore::UserVerificationRequirement>);
    struct ShouldBeSameSizeAsAuthenticatorSelectionCriteria : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::AuthenticatorSelectionCriteria>, false> {
        std::optional<WebCore::AuthenticatorAttachment> authenticatorAttachment;
        std::optional<WebCore::ResidentKeyRequirement> residentKey;
        bool requireResidentKey;
        WebCore::UserVerificationRequirement userVerification;
    };
    static_assert(sizeof(ShouldBeSameSizeAsAuthenticatorSelectionCriteria) == sizeof(WebCore::AuthenticatorSelectionCriteria));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::AuthenticatorSelectionCriteria, authenticatorAttachment)
        , offsetof(WebCore::AuthenticatorSelectionCriteria, residentKey)
        , offsetof(WebCore::AuthenticatorSelectionCriteria, requireResidentKey)
        , offsetof(WebCore::AuthenticatorSelectionCriteria, userVerification)
    >::value);

    encoder << instance.authenticatorAttachment;
    encoder << instance.residentKey;
    encoder << instance.requireResidentKey;
    encoder << instance.userVerification;
}

std::optional<WebCore::AuthenticatorSelectionCriteria> ArgumentCoder<WebCore::AuthenticatorSelectionCriteria>::decode(Decoder& decoder)
{
    auto authenticatorAttachment = decoder.decode<std::optional<WebCore::AuthenticatorAttachment>>();
    auto residentKey = decoder.decode<std::optional<WebCore::ResidentKeyRequirement>>();
    auto requireResidentKey = decoder.decode<bool>();
    auto userVerification = decoder.decode<WebCore::UserVerificationRequirement>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::AuthenticatorSelectionCriteria {
            WTFMove(*authenticatorAttachment),
            WTFMove(*residentKey),
            WTFMove(*requireResidentKey),
            WTFMove(*userVerification)
        }
    };
}

#endif

#if ENABLE(WEB_AUTHN)
void ArgumentCoder<WebCore::PublicKeyCredentialEntity>::encode(Encoder& encoder, const WebCore::PublicKeyCredentialEntity& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.icon)>, String>);
    struct ShouldBeSameSizeAsPublicKeyCredentialEntity : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PublicKeyCredentialEntity>, false> {
        String name;
        String icon;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPublicKeyCredentialEntity) == sizeof(WebCore::PublicKeyCredentialEntity));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PublicKeyCredentialEntity, name)
        , offsetof(WebCore::PublicKeyCredentialEntity, icon)
    >::value);

    encoder << instance.name;
    encoder << instance.icon;
}

std::optional<WebCore::PublicKeyCredentialEntity> ArgumentCoder<WebCore::PublicKeyCredentialEntity>::decode(Decoder& decoder)
{
    auto name = decoder.decode<String>();
    auto icon = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PublicKeyCredentialEntity {
            WTFMove(*name),
            WTFMove(*icon)
        }
    };
}

#endif

#if ENABLE(WEB_AUTHN)
void ArgumentCoder<WebCore::PublicKeyCredentialRpEntity>::encode(Encoder& encoder, const WebCore::PublicKeyCredentialRpEntity& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.icon)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PublicKeyCredentialEntity, name)
        , offsetof(WebCore::PublicKeyCredentialEntity, icon)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.id)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PublicKeyCredentialRpEntity, id)
    >::value);

    encoder << instance.name;
    encoder << instance.icon;
    encoder << instance.id;
}

std::optional<WebCore::PublicKeyCredentialRpEntity> ArgumentCoder<WebCore::PublicKeyCredentialRpEntity>::decode(Decoder& decoder)
{
    auto name = decoder.decode<String>();
    auto icon = decoder.decode<String>();
    auto id = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PublicKeyCredentialRpEntity {
            WebCore::PublicKeyCredentialEntity {
                WTFMove(*name),
                WTFMove(*icon)
            },
            WTFMove(*id)
        }
    };
}

#endif

#if ENABLE(WEB_AUTHN)
void ArgumentCoder<WebCore::PublicKeyCredentialUserEntity>::encode(Encoder& encoder, const WebCore::PublicKeyCredentialUserEntity& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.icon)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PublicKeyCredentialEntity, name)
        , offsetof(WebCore::PublicKeyCredentialEntity, icon)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.id)>, WebCore::BufferSource>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.displayName)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PublicKeyCredentialUserEntity, id)
        , offsetof(WebCore::PublicKeyCredentialUserEntity, displayName)
    >::value);

    encoder << instance.name;
    encoder << instance.icon;
    encoder << instance.id;
    encoder << instance.displayName;
}

std::optional<WebCore::PublicKeyCredentialUserEntity> ArgumentCoder<WebCore::PublicKeyCredentialUserEntity>::decode(Decoder& decoder)
{
    auto name = decoder.decode<String>();
    auto icon = decoder.decode<String>();
    auto id = decoder.decode<WebCore::BufferSource>();
    auto displayName = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PublicKeyCredentialUserEntity {
            WebCore::PublicKeyCredentialEntity {
                WTFMove(*name),
                WTFMove(*icon)
            },
            WTFMove(*id),
            WTFMove(*displayName)
        }
    };
}

#endif

#if ENABLE(WEB_AUTHN)
void ArgumentCoder<WebCore::PublicKeyCredentialDescriptor>::encode(Encoder& encoder, const WebCore::PublicKeyCredentialDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::PublicKeyCredentialType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.id)>, WebCore::BufferSource>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.transports)>, Vector<WebCore::AuthenticatorTransport>>);
    struct ShouldBeSameSizeAsPublicKeyCredentialDescriptor : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PublicKeyCredentialDescriptor>, false> {
        WebCore::PublicKeyCredentialType type;
        WebCore::BufferSource id;
        Vector<WebCore::AuthenticatorTransport> transports;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPublicKeyCredentialDescriptor) == sizeof(WebCore::PublicKeyCredentialDescriptor));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PublicKeyCredentialDescriptor, type)
        , offsetof(WebCore::PublicKeyCredentialDescriptor, id)
        , offsetof(WebCore::PublicKeyCredentialDescriptor, transports)
    >::value);

    encoder << instance.type;
    encoder << instance.id;
    encoder << instance.transports;
}

std::optional<WebCore::PublicKeyCredentialDescriptor> ArgumentCoder<WebCore::PublicKeyCredentialDescriptor>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::PublicKeyCredentialType>();
    auto id = decoder.decode<WebCore::BufferSource>();
    auto transports = decoder.decode<Vector<WebCore::AuthenticatorTransport>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PublicKeyCredentialDescriptor {
            WTFMove(*type),
            WTFMove(*id),
            WTFMove(*transports)
        }
    };
}

#endif

void ArgumentCoder<WebCore::PublicKeyCredentialCreationOptions>::encode(Encoder& encoder, const WebCore::PublicKeyCredentialCreationOptions& instance)
{
#if ENABLE(WEB_AUTHN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rp)>, WebCore::PublicKeyCredentialRpEntity>);
#endif
#if ENABLE(WEB_AUTHN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.user)>, WebCore::PublicKeyCredentialUserEntity>);
#endif
#if ENABLE(WEB_AUTHN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.challenge)>, WebCore::BufferSource>);
#endif
#if ENABLE(WEB_AUTHN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pubKeyCredParams)>, Vector<WebCore::PublicKeyCredentialParameters>>);
#endif
#if ENABLE(WEB_AUTHN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timeout)>, std::optional<unsigned>>);
#endif
#if ENABLE(WEB_AUTHN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.excludeCredentials)>, Vector<WebCore::PublicKeyCredentialDescriptor>>);
#endif
#if ENABLE(WEB_AUTHN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.authenticatorSelection)>, std::optional<WebCore::AuthenticatorSelectionCriteria>>);
#endif
#if ENABLE(WEB_AUTHN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.attestation)>, WebCore::AttestationConveyancePreference>);
#endif
#if ENABLE(WEB_AUTHN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.extensions)>, std::optional<WebCore::AuthenticationExtensionsClientInputs>>);
#endif
    struct ShouldBeSameSizeAsPublicKeyCredentialCreationOptions : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PublicKeyCredentialCreationOptions>, false> {
#if ENABLE(WEB_AUTHN)
        WebCore::PublicKeyCredentialRpEntity rp;
#endif
#if ENABLE(WEB_AUTHN)
        WebCore::PublicKeyCredentialUserEntity user;
#endif
#if ENABLE(WEB_AUTHN)
        WebCore::BufferSource challenge;
#endif
#if ENABLE(WEB_AUTHN)
        Vector<WebCore::PublicKeyCredentialParameters> pubKeyCredParams;
#endif
#if ENABLE(WEB_AUTHN)
        std::optional<unsigned> timeout;
#endif
#if ENABLE(WEB_AUTHN)
        Vector<WebCore::PublicKeyCredentialDescriptor> excludeCredentials;
#endif
#if ENABLE(WEB_AUTHN)
        std::optional<WebCore::AuthenticatorSelectionCriteria> authenticatorSelection;
#endif
#if ENABLE(WEB_AUTHN)
        WebCore::AttestationConveyancePreference attestation;
#endif
#if ENABLE(WEB_AUTHN)
        std::optional<WebCore::AuthenticationExtensionsClientInputs> extensions;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsPublicKeyCredentialCreationOptions) == sizeof(WebCore::PublicKeyCredentialCreationOptions));
    static_assert(MembersInCorrectOrder < 0
#if ENABLE(WEB_AUTHN)
        , offsetof(WebCore::PublicKeyCredentialCreationOptions, rp)
#endif
#if ENABLE(WEB_AUTHN)
        , offsetof(WebCore::PublicKeyCredentialCreationOptions, user)
#endif
#if ENABLE(WEB_AUTHN)
        , offsetof(WebCore::PublicKeyCredentialCreationOptions, challenge)
#endif
#if ENABLE(WEB_AUTHN)
        , offsetof(WebCore::PublicKeyCredentialCreationOptions, pubKeyCredParams)
#endif
#if ENABLE(WEB_AUTHN)
        , offsetof(WebCore::PublicKeyCredentialCreationOptions, timeout)
#endif
#if ENABLE(WEB_AUTHN)
        , offsetof(WebCore::PublicKeyCredentialCreationOptions, excludeCredentials)
#endif
#if ENABLE(WEB_AUTHN)
        , offsetof(WebCore::PublicKeyCredentialCreationOptions, authenticatorSelection)
#endif
#if ENABLE(WEB_AUTHN)
        , offsetof(WebCore::PublicKeyCredentialCreationOptions, attestation)
#endif
#if ENABLE(WEB_AUTHN)
        , offsetof(WebCore::PublicKeyCredentialCreationOptions, extensions)
#endif
    >::value);

#if ENABLE(WEB_AUTHN)
    encoder << instance.rp;
#endif
#if ENABLE(WEB_AUTHN)
    encoder << instance.user;
#endif
#if ENABLE(WEB_AUTHN)
    encoder << instance.challenge;
#endif
#if ENABLE(WEB_AUTHN)
    encoder << instance.pubKeyCredParams;
#endif
#if ENABLE(WEB_AUTHN)
    encoder << instance.timeout;
#endif
#if ENABLE(WEB_AUTHN)
    encoder << instance.excludeCredentials;
#endif
#if ENABLE(WEB_AUTHN)
    encoder << instance.authenticatorSelection;
#endif
#if ENABLE(WEB_AUTHN)
    encoder << instance.attestation;
#endif
#if ENABLE(WEB_AUTHN)
    encoder << instance.extensions;
#endif
}

std::optional<WebCore::PublicKeyCredentialCreationOptions> ArgumentCoder<WebCore::PublicKeyCredentialCreationOptions>::decode(Decoder& decoder)
{
#if ENABLE(WEB_AUTHN)
    auto rp = decoder.decode<WebCore::PublicKeyCredentialRpEntity>();
#endif
#if ENABLE(WEB_AUTHN)
    auto user = decoder.decode<WebCore::PublicKeyCredentialUserEntity>();
#endif
#if ENABLE(WEB_AUTHN)
    auto challenge = decoder.decode<WebCore::BufferSource>();
#endif
#if ENABLE(WEB_AUTHN)
    auto pubKeyCredParams = decoder.decode<Vector<WebCore::PublicKeyCredentialParameters>>();
#endif
#if ENABLE(WEB_AUTHN)
    auto timeout = decoder.decode<std::optional<unsigned>>();
#endif
#if ENABLE(WEB_AUTHN)
    auto excludeCredentials = decoder.decode<Vector<WebCore::PublicKeyCredentialDescriptor>>();
#endif
#if ENABLE(WEB_AUTHN)
    auto authenticatorSelection = decoder.decode<std::optional<WebCore::AuthenticatorSelectionCriteria>>();
#endif
#if ENABLE(WEB_AUTHN)
    auto attestation = decoder.decode<WebCore::AttestationConveyancePreference>();
#endif
#if ENABLE(WEB_AUTHN)
    auto extensions = decoder.decode<std::optional<WebCore::AuthenticationExtensionsClientInputs>>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PublicKeyCredentialCreationOptions {
#if ENABLE(WEB_AUTHN)
            WTFMove(*rp),
#endif
#if ENABLE(WEB_AUTHN)
            WTFMove(*user),
#endif
#if ENABLE(WEB_AUTHN)
            WTFMove(*challenge),
#endif
#if ENABLE(WEB_AUTHN)
            WTFMove(*pubKeyCredParams),
#endif
#if ENABLE(WEB_AUTHN)
            WTFMove(*timeout),
#endif
#if ENABLE(WEB_AUTHN)
            WTFMove(*excludeCredentials),
#endif
#if ENABLE(WEB_AUTHN)
            WTFMove(*authenticatorSelection),
#endif
#if ENABLE(WEB_AUTHN)
            WTFMove(*attestation),
#endif
#if ENABLE(WEB_AUTHN)
            WTFMove(*extensions)
#endif
        }
    };
}

void ArgumentCoder<WebCore::PublicKeyCredentialRequestOptions>::encode(Encoder& encoder, const WebCore::PublicKeyCredentialRequestOptions& instance)
{
#if ENABLE(WEB_AUTHN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.challenge)>, WebCore::BufferSource>);
#endif
#if ENABLE(WEB_AUTHN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timeout)>, std::optional<unsigned>>);
#endif
#if ENABLE(WEB_AUTHN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rpId)>, String>);
#endif
#if ENABLE(WEB_AUTHN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowCredentials)>, Vector<WebCore::PublicKeyCredentialDescriptor>>);
#endif
#if ENABLE(WEB_AUTHN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.userVerification)>, WebCore::UserVerificationRequirement>);
#endif
#if ENABLE(WEB_AUTHN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.extensions)>, std::optional<WebCore::AuthenticationExtensionsClientInputs>>);
#endif
#if ENABLE(WEB_AUTHN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.authenticatorAttachment)>, std::optional<WebCore::AuthenticatorAttachment>>);
#endif
    struct ShouldBeSameSizeAsPublicKeyCredentialRequestOptions : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PublicKeyCredentialRequestOptions>, false> {
#if ENABLE(WEB_AUTHN)
        WebCore::BufferSource challenge;
#endif
#if ENABLE(WEB_AUTHN)
        std::optional<unsigned> timeout;
#endif
#if ENABLE(WEB_AUTHN)
        String rpId;
#endif
#if ENABLE(WEB_AUTHN)
        Vector<WebCore::PublicKeyCredentialDescriptor> allowCredentials;
#endif
#if ENABLE(WEB_AUTHN)
        WebCore::UserVerificationRequirement userVerification;
#endif
#if ENABLE(WEB_AUTHN)
        std::optional<WebCore::AuthenticationExtensionsClientInputs> extensions;
#endif
#if ENABLE(WEB_AUTHN)
        std::optional<WebCore::AuthenticatorAttachment> authenticatorAttachment;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsPublicKeyCredentialRequestOptions) == sizeof(WebCore::PublicKeyCredentialRequestOptions));
    static_assert(MembersInCorrectOrder < 0
#if ENABLE(WEB_AUTHN)
        , offsetof(WebCore::PublicKeyCredentialRequestOptions, challenge)
#endif
#if ENABLE(WEB_AUTHN)
        , offsetof(WebCore::PublicKeyCredentialRequestOptions, timeout)
#endif
#if ENABLE(WEB_AUTHN)
        , offsetof(WebCore::PublicKeyCredentialRequestOptions, rpId)
#endif
#if ENABLE(WEB_AUTHN)
        , offsetof(WebCore::PublicKeyCredentialRequestOptions, allowCredentials)
#endif
#if ENABLE(WEB_AUTHN)
        , offsetof(WebCore::PublicKeyCredentialRequestOptions, userVerification)
#endif
#if ENABLE(WEB_AUTHN)
        , offsetof(WebCore::PublicKeyCredentialRequestOptions, extensions)
#endif
#if ENABLE(WEB_AUTHN)
        , offsetof(WebCore::PublicKeyCredentialRequestOptions, authenticatorAttachment)
#endif
    >::value);

#if ENABLE(WEB_AUTHN)
    encoder << instance.challenge;
#endif
#if ENABLE(WEB_AUTHN)
    encoder << instance.timeout;
#endif
#if ENABLE(WEB_AUTHN)
    encoder << instance.rpId;
#endif
#if ENABLE(WEB_AUTHN)
    encoder << instance.allowCredentials;
#endif
#if ENABLE(WEB_AUTHN)
    encoder << instance.userVerification;
#endif
#if ENABLE(WEB_AUTHN)
    encoder << instance.extensions;
#endif
}

std::optional<WebCore::PublicKeyCredentialRequestOptions> ArgumentCoder<WebCore::PublicKeyCredentialRequestOptions>::decode(Decoder& decoder)
{
#if ENABLE(WEB_AUTHN)
    auto challenge = decoder.decode<WebCore::BufferSource>();
#endif
#if ENABLE(WEB_AUTHN)
    auto timeout = decoder.decode<std::optional<unsigned>>();
#endif
#if ENABLE(WEB_AUTHN)
    auto rpId = decoder.decode<String>();
#endif
#if ENABLE(WEB_AUTHN)
    auto allowCredentials = decoder.decode<Vector<WebCore::PublicKeyCredentialDescriptor>>();
#endif
#if ENABLE(WEB_AUTHN)
    auto userVerification = decoder.decode<WebCore::UserVerificationRequirement>();
#endif
#if ENABLE(WEB_AUTHN)
    auto extensions = decoder.decode<std::optional<WebCore::AuthenticationExtensionsClientInputs>>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PublicKeyCredentialRequestOptions {
#if ENABLE(WEB_AUTHN)
            WTFMove(*challenge),
#endif
#if ENABLE(WEB_AUTHN)
            WTFMove(*timeout),
#endif
#if ENABLE(WEB_AUTHN)
            WTFMove(*rpId),
#endif
#if ENABLE(WEB_AUTHN)
            WTFMove(*allowCredentials),
#endif
#if ENABLE(WEB_AUTHN)
            WTFMove(*userVerification),
#endif
#if ENABLE(WEB_AUTHN)
            WTFMove(*extensions)
#endif
        }
    };
}

void ArgumentCoder<WebCore::RegistrableDomain>::encode(Encoder& encoder, const WebCore::RegistrableDomain& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.string())>, String>);

    encoder << instance.string();
}

std::optional<WebCore::RegistrableDomain> ArgumentCoder<WebCore::RegistrableDomain>::decode(Decoder& decoder)
{
    auto string = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::RegistrableDomain::fromRawString(
            WTFMove(*string)
        )
    };
}

void ArgumentCoder<WebCore::Site>::encode(Encoder& encoder, const WebCore::Site& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.protocol())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.domain())>, WebCore::RegistrableDomain>);

    encoder << instance.protocol();
    encoder << instance.domain();
}

std::optional<WebCore::Site> ArgumentCoder<WebCore::Site>::decode(Decoder& decoder)
{
    auto protocol = decoder.decode<String>();
    auto domain = decoder.decode<WebCore::RegistrableDomain>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Site {
            WTFMove(*protocol),
            WTFMove(*domain)
        }
    };
}

void ArgumentCoder<WebCore::AudioConfiguration>::encode(Encoder& encoder, const WebCore::AudioConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentType)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.channels)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bitrate)>, std::optional<uint64_t>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.samplerate)>, std::optional<uint32_t>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.spatialRendering)>, std::optional<bool>>);
    struct ShouldBeSameSizeAsAudioConfiguration : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::AudioConfiguration>, false> {
        String contentType;
        String channels;
        std::optional<uint64_t> bitrate;
        std::optional<uint32_t> samplerate;
        std::optional<bool> spatialRendering;
    };
    static_assert(sizeof(ShouldBeSameSizeAsAudioConfiguration) == sizeof(WebCore::AudioConfiguration));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::AudioConfiguration, contentType)
        , offsetof(WebCore::AudioConfiguration, channels)
        , offsetof(WebCore::AudioConfiguration, bitrate)
        , offsetof(WebCore::AudioConfiguration, samplerate)
        , offsetof(WebCore::AudioConfiguration, spatialRendering)
    >::value);

    encoder << instance.contentType;
    encoder << instance.channels;
    encoder << instance.bitrate;
    encoder << instance.samplerate;
    encoder << instance.spatialRendering;
}

std::optional<WebCore::AudioConfiguration> ArgumentCoder<WebCore::AudioConfiguration>::decode(Decoder& decoder)
{
    auto contentType = decoder.decode<String>();
    auto channels = decoder.decode<String>();
    auto bitrate = decoder.decode<std::optional<uint64_t>>();
    auto samplerate = decoder.decode<std::optional<uint32_t>>();
    auto spatialRendering = decoder.decode<std::optional<bool>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::AudioConfiguration {
            WTFMove(*contentType),
            WTFMove(*channels),
            WTFMove(*bitrate),
            WTFMove(*samplerate),
            WTFMove(*spatialRendering)
        }
    };
}

void ArgumentCoder<WebCore::Cookie>::encode(Encoder& encoder, const WebCore::Cookie& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.domain)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.path)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.partitionKey)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.created)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.expires)>, std::optional<double>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.httpOnly)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.secure)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.session)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.comment)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.commentURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ports)>, Vector<uint16_t>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sameSite)>, WebCore::Cookie::SameSitePolicy>);
    struct ShouldBeSameSizeAsCookie : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Cookie>, false> {
        String name;
        String value;
        String domain;
        String path;
        String partitionKey;
        double created;
        std::optional<double> expires;
        bool httpOnly;
        bool secure;
        bool session;
        String comment;
        URL commentURL;
        Vector<uint16_t> ports;
        WebCore::Cookie::SameSitePolicy sameSite;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCookie) == sizeof(WebCore::Cookie));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Cookie, name)
        , offsetof(WebCore::Cookie, value)
        , offsetof(WebCore::Cookie, domain)
        , offsetof(WebCore::Cookie, path)
        , offsetof(WebCore::Cookie, partitionKey)
        , offsetof(WebCore::Cookie, created)
        , offsetof(WebCore::Cookie, expires)
        , offsetof(WebCore::Cookie, httpOnly)
        , offsetof(WebCore::Cookie, secure)
        , offsetof(WebCore::Cookie, session)
        , offsetof(WebCore::Cookie, comment)
        , offsetof(WebCore::Cookie, commentURL)
        , offsetof(WebCore::Cookie, ports)
        , offsetof(WebCore::Cookie, sameSite)
    >::value);

    encoder << instance.name;
    encoder << instance.value;
    encoder << instance.domain;
    encoder << instance.path;
    encoder << instance.partitionKey;
    encoder << instance.created;
    encoder << instance.expires;
    encoder << instance.httpOnly;
    encoder << instance.secure;
    encoder << instance.session;
    encoder << instance.comment;
    encoder << instance.commentURL;
    encoder << instance.ports;
    encoder << instance.sameSite;
}

std::optional<WebCore::Cookie> ArgumentCoder<WebCore::Cookie>::decode(Decoder& decoder)
{
    auto name = decoder.decode<String>();
    auto value = decoder.decode<String>();
    auto domain = decoder.decode<String>();
    auto path = decoder.decode<String>();
    auto partitionKey = decoder.decode<String>();
    auto created = decoder.decode<double>();
    auto expires = decoder.decode<std::optional<double>>();
    auto httpOnly = decoder.decode<bool>();
    auto secure = decoder.decode<bool>();
    auto session = decoder.decode<bool>();
    auto comment = decoder.decode<String>();
    auto commentURL = decoder.decode<URL>();
    auto ports = decoder.decode<Vector<uint16_t>>();
    auto sameSite = decoder.decode<WebCore::Cookie::SameSitePolicy>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Cookie {
            WTFMove(*name),
            WTFMove(*value),
            WTFMove(*domain),
            WTFMove(*path),
            WTFMove(*partitionKey),
            WTFMove(*created),
            WTFMove(*expires),
            WTFMove(*httpOnly),
            WTFMove(*secure),
            WTFMove(*session),
            WTFMove(*comment),
            WTFMove(*commentURL),
            WTFMove(*ports),
            WTFMove(*sameSite)
        }
    };
}

#if ENABLE(VIDEO)
void ArgumentCoder<WebCore::VideoFrameMetadata>::encode(Encoder& encoder, const WebCore::VideoFrameMetadata& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.presentationTime)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.expectedDisplayTime)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.width)>, unsigned>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.height)>, unsigned>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaTime)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.presentedFrames)>, unsigned>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processingDuration)>, std::optional<double>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.captureTime)>, std::optional<double>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.receiveTime)>, std::optional<double>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rtpTimestamp)>, std::optional<unsigned>>);
    struct ShouldBeSameSizeAsVideoFrameMetadata : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::VideoFrameMetadata>, false> {
        double presentationTime;
        double expectedDisplayTime;
        unsigned width;
        unsigned height;
        double mediaTime;
        unsigned presentedFrames;
        std::optional<double> processingDuration;
        std::optional<double> captureTime;
        std::optional<double> receiveTime;
        std::optional<unsigned> rtpTimestamp;
    };
    static_assert(sizeof(ShouldBeSameSizeAsVideoFrameMetadata) == sizeof(WebCore::VideoFrameMetadata));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::VideoFrameMetadata, presentationTime)
        , offsetof(WebCore::VideoFrameMetadata, expectedDisplayTime)
        , offsetof(WebCore::VideoFrameMetadata, width)
        , offsetof(WebCore::VideoFrameMetadata, height)
        , offsetof(WebCore::VideoFrameMetadata, mediaTime)
        , offsetof(WebCore::VideoFrameMetadata, presentedFrames)
        , offsetof(WebCore::VideoFrameMetadata, processingDuration)
        , offsetof(WebCore::VideoFrameMetadata, captureTime)
        , offsetof(WebCore::VideoFrameMetadata, receiveTime)
        , offsetof(WebCore::VideoFrameMetadata, rtpTimestamp)
    >::value);

    encoder << instance.presentationTime;
    encoder << instance.expectedDisplayTime;
    encoder << instance.width;
    encoder << instance.height;
    encoder << instance.mediaTime;
    encoder << instance.presentedFrames;
    encoder << instance.processingDuration;
    encoder << instance.captureTime;
    encoder << instance.receiveTime;
    encoder << instance.rtpTimestamp;
}

std::optional<WebCore::VideoFrameMetadata> ArgumentCoder<WebCore::VideoFrameMetadata>::decode(Decoder& decoder)
{
    auto presentationTime = decoder.decode<double>();
    auto expectedDisplayTime = decoder.decode<double>();
    auto width = decoder.decode<unsigned>();
    auto height = decoder.decode<unsigned>();
    auto mediaTime = decoder.decode<double>();
    auto presentedFrames = decoder.decode<unsigned>();
    auto processingDuration = decoder.decode<std::optional<double>>();
    auto captureTime = decoder.decode<std::optional<double>>();
    auto receiveTime = decoder.decode<std::optional<double>>();
    auto rtpTimestamp = decoder.decode<std::optional<unsigned>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::VideoFrameMetadata {
            WTFMove(*presentationTime),
            WTFMove(*expectedDisplayTime),
            WTFMove(*width),
            WTFMove(*height),
            WTFMove(*mediaTime),
            WTFMove(*presentedFrames),
            WTFMove(*processingDuration),
            WTFMove(*captureTime),
            WTFMove(*receiveTime),
            WTFMove(*rtpTimestamp)
        }
    };
}

#endif

void ArgumentCoder<WebCore::NavigationPreloadState>::encode(Encoder& encoder, const WebCore::NavigationPreloadState& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.enabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.headerValue)>, String>);
    struct ShouldBeSameSizeAsNavigationPreloadState : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::NavigationPreloadState>, false> {
        bool enabled;
        String headerValue;
    };
    static_assert(sizeof(ShouldBeSameSizeAsNavigationPreloadState) == sizeof(WebCore::NavigationPreloadState));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::NavigationPreloadState, enabled)
        , offsetof(WebCore::NavigationPreloadState, headerValue)
    >::value);

    encoder << instance.enabled;
    encoder << instance.headerValue;
}

std::optional<WebCore::NavigationPreloadState> ArgumentCoder<WebCore::NavigationPreloadState>::decode(Decoder& decoder)
{
    auto enabled = decoder.decode<bool>();
    auto headerValue = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::NavigationPreloadState {
            WTFMove(*enabled),
            WTFMove(*headerValue)
        }
    };
}

void ArgumentCoder<WebCore::PlatformDynamicRangeLimit>::encode(Encoder& encoder, const WebCore::PlatformDynamicRangeLimit& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_value)>, float>);
    struct ShouldBeSameSizeAsPlatformDynamicRangeLimit : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PlatformDynamicRangeLimit>, false> {
        float m_value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPlatformDynamicRangeLimit) == sizeof(WebCore::PlatformDynamicRangeLimit));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PlatformDynamicRangeLimit, m_value)
    >::value);

    encoder << instance.m_value;
}

void ArgumentCoder<WebCore::PlatformDynamicRangeLimit>::encode(StreamConnectionEncoder& encoder, const WebCore::PlatformDynamicRangeLimit& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_value)>, float>);
    struct ShouldBeSameSizeAsPlatformDynamicRangeLimit : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PlatformDynamicRangeLimit>, false> {
        float m_value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPlatformDynamicRangeLimit) == sizeof(WebCore::PlatformDynamicRangeLimit));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PlatformDynamicRangeLimit, m_value)
    >::value);

    encoder << instance.m_value;
}

std::optional<WebCore::PlatformDynamicRangeLimit> ArgumentCoder<WebCore::PlatformDynamicRangeLimit>::decode(Decoder& decoder)
{
    auto m_value = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PlatformDynamicRangeLimit {
            WTFMove(*m_value)
        }
    };
}

#if ENABLE(CONTENT_FILTERING)
void ArgumentCoder<WebCore::MockContentFilterSettings>::encode(Encoder& encoder, const WebCore::MockContentFilterSettings& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_enabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_decisionPoint)>, WebCore::MockContentFilterSettings::DecisionPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_decision)>, WebCore::MockContentFilterSettings::Decision>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_unblockRequestDecision)>, WebCore::MockContentFilterSettings::Decision>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_blockedString)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_modifiedRequestURL)>, String>);
    struct ShouldBeSameSizeAsMockContentFilterSettings : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MockContentFilterSettings>, false> {
        bool m_enabled;
        WebCore::MockContentFilterSettings::DecisionPoint m_decisionPoint;
        WebCore::MockContentFilterSettings::Decision m_decision;
        WebCore::MockContentFilterSettings::Decision m_unblockRequestDecision;
        String m_blockedString;
        String m_modifiedRequestURL;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMockContentFilterSettings) == sizeof(WebCore::MockContentFilterSettings));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MockContentFilterSettings, m_enabled)
        , offsetof(WebCore::MockContentFilterSettings, m_decisionPoint)
        , offsetof(WebCore::MockContentFilterSettings, m_decision)
        , offsetof(WebCore::MockContentFilterSettings, m_unblockRequestDecision)
        , offsetof(WebCore::MockContentFilterSettings, m_blockedString)
        , offsetof(WebCore::MockContentFilterSettings, m_modifiedRequestURL)
    >::value);

    encoder << instance.m_enabled;
    encoder << instance.m_decisionPoint;
    encoder << instance.m_decision;
    encoder << instance.m_unblockRequestDecision;
    encoder << instance.m_blockedString;
    encoder << instance.m_modifiedRequestURL;
}

std::optional<WebCore::MockContentFilterSettings> ArgumentCoder<WebCore::MockContentFilterSettings>::decode(Decoder& decoder)
{
    auto m_enabled = decoder.decode<bool>();
    auto m_decisionPoint = decoder.decode<WebCore::MockContentFilterSettings::DecisionPoint>();
    auto m_decision = decoder.decode<WebCore::MockContentFilterSettings::Decision>();
    auto m_unblockRequestDecision = decoder.decode<WebCore::MockContentFilterSettings::Decision>();
    auto m_blockedString = decoder.decode<String>();
    auto m_modifiedRequestURL = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    WebCore::MockContentFilterSettings result;
    result.m_enabled = WTFMove(*m_enabled);
    result.m_decisionPoint = WTFMove(*m_decisionPoint);
    result.m_decision = WTFMove(*m_decision);
    result.m_unblockRequestDecision = WTFMove(*m_unblockRequestDecision);
    result.m_blockedString = WTFMove(*m_blockedString);
    result.m_modifiedRequestURL = WTFMove(*m_modifiedRequestURL);
    return { WTFMove(result) };
}

#endif

void ArgumentCoder<WebCore::LoginStatus>::encode(Encoder& encoder, const WebCore::LoginStatus& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.domain())>, WebCore::RegistrableDomain>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.username())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tokenType())>, WebCore::LoginStatus::CredentialTokenType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.authType())>, WebCore::LoginStatus::AuthenticationType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.loggedInTime())>, WallTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timeToLive())>, Seconds>);

    encoder << instance.domain();
    encoder << instance.username();
    encoder << instance.tokenType();
    encoder << instance.authType();
    encoder << instance.loggedInTime();
    encoder << instance.timeToLive();
}

std::optional<WebCore::LoginStatus> ArgumentCoder<WebCore::LoginStatus>::decode(Decoder& decoder)
{
    auto domain = decoder.decode<WebCore::RegistrableDomain>();
    auto username = decoder.decode<String>();
    auto tokenType = decoder.decode<WebCore::LoginStatus::CredentialTokenType>();
    auto authType = decoder.decode<WebCore::LoginStatus::AuthenticationType>();
    auto loggedInTime = decoder.decode<WallTime>();
    auto timeToLive = decoder.decode<Seconds>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::LoginStatus {
            WTFMove(*domain),
            WTFMove(*username),
            WTFMove(*tokenType),
            WTFMove(*authType),
            WTFMove(*loggedInTime),
            WTFMove(*timeToLive)
        }
    };
}

void ArgumentCoder<WebCore::ExceptionDetails>::encode(Encoder& encoder, const WebCore::ExceptionDetails& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.message)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lineNumber)>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.columnNumber)>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::ExceptionDetails::Type>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceURL)>, String>);
    struct ShouldBeSameSizeAsExceptionDetails : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ExceptionDetails>, false> {
        String message;
        int lineNumber;
        int columnNumber;
        WebCore::ExceptionDetails::Type type;
        String sourceURL;
    };
    static_assert(sizeof(ShouldBeSameSizeAsExceptionDetails) == sizeof(WebCore::ExceptionDetails));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ExceptionDetails, message)
        , offsetof(WebCore::ExceptionDetails, lineNumber)
        , offsetof(WebCore::ExceptionDetails, columnNumber)
        , offsetof(WebCore::ExceptionDetails, type)
        , offsetof(WebCore::ExceptionDetails, sourceURL)
    >::value);

    encoder << instance.message;
    encoder << instance.lineNumber;
    encoder << instance.columnNumber;
    encoder << instance.type;
    encoder << instance.sourceURL;
}

std::optional<WebCore::ExceptionDetails> ArgumentCoder<WebCore::ExceptionDetails>::decode(Decoder& decoder)
{
    auto message = decoder.decode<String>();
    auto lineNumber = decoder.decode<int>();
    auto columnNumber = decoder.decode<int>();
    auto type = decoder.decode<WebCore::ExceptionDetails::Type>();
    auto sourceURL = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ExceptionDetails {
            WTFMove(*message),
            WTFMove(*lineNumber),
            WTFMove(*columnNumber),
            WTFMove(*type),
            WTFMove(*sourceURL)
        }
    };
}

void ArgumentCoder<WebCore::FloatBoxExtent>::encode(Encoder& encoder, const WebCore::FloatBoxExtent& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.top())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.right())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bottom())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.left())>, float>);

    encoder << instance.top();
    encoder << instance.right();
    encoder << instance.bottom();
    encoder << instance.left();
}

void ArgumentCoder<WebCore::FloatBoxExtent>::encode(StreamConnectionEncoder& encoder, const WebCore::FloatBoxExtent& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.top())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.right())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bottom())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.left())>, float>);

    encoder << instance.top();
    encoder << instance.right();
    encoder << instance.bottom();
    encoder << instance.left();
}

std::optional<WebCore::FloatBoxExtent> ArgumentCoder<WebCore::FloatBoxExtent>::decode(Decoder& decoder)
{
    auto top = decoder.decode<float>();
    auto right = decoder.decode<float>();
    auto bottom = decoder.decode<float>();
    auto left = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FloatBoxExtent {
            WTFMove(*top),
            WTFMove(*right),
            WTFMove(*bottom),
            WTFMove(*left)
        }
    };
}

void ArgumentCoder<WebCore::RectEdges<bool>>::encode(Encoder& encoder, const WebCore::RectEdges<bool>& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.top())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.right())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bottom())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.left())>, bool>);

    encoder << instance.top();
    encoder << instance.right();
    encoder << instance.bottom();
    encoder << instance.left();
}

std::optional<WebCore::RectEdges<bool>> ArgumentCoder<WebCore::RectEdges<bool>>::decode(Decoder& decoder)
{
    auto top = decoder.decode<bool>();
    auto right = decoder.decode<bool>();
    auto bottom = decoder.decode<bool>();
    auto left = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::RectEdges<bool> {
            WTFMove(*top),
            WTFMove(*right),
            WTFMove(*bottom),
            WTFMove(*left)
        }
    };
}

void ArgumentCoder<WebCore::RectEdges<WebCore::Color>>::encode(Encoder& encoder, const WebCore::RectEdges<WebCore::Color>& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.top())>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.right())>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bottom())>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.left())>, WebCore::Color>);

    encoder << instance.top();
    encoder << instance.right();
    encoder << instance.bottom();
    encoder << instance.left();
}

std::optional<WebCore::RectEdges<WebCore::Color>> ArgumentCoder<WebCore::RectEdges<WebCore::Color>>::decode(Decoder& decoder)
{
    auto top = decoder.decode<WebCore::Color>();
    auto right = decoder.decode<WebCore::Color>();
    auto bottom = decoder.decode<WebCore::Color>();
    auto left = decoder.decode<WebCore::Color>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::RectEdges<WebCore::Color> {
            WTFMove(*top),
            WTFMove(*right),
            WTFMove(*bottom),
            WTFMove(*left)
        }
    };
}

void ArgumentCoder<WebCore::RectEdges<WebCore::RubberBandingBehavior>>::encode(Encoder& encoder, const WebCore::RectEdges<WebCore::RubberBandingBehavior>& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.top())>, WebCore::RubberBandingBehavior>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.right())>, WebCore::RubberBandingBehavior>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bottom())>, WebCore::RubberBandingBehavior>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.left())>, WebCore::RubberBandingBehavior>);

    encoder << instance.top();
    encoder << instance.right();
    encoder << instance.bottom();
    encoder << instance.left();
}

std::optional<WebCore::RectEdges<WebCore::RubberBandingBehavior>> ArgumentCoder<WebCore::RectEdges<WebCore::RubberBandingBehavior>>::decode(Decoder& decoder)
{
    auto top = decoder.decode<WebCore::RubberBandingBehavior>();
    auto right = decoder.decode<WebCore::RubberBandingBehavior>();
    auto bottom = decoder.decode<WebCore::RubberBandingBehavior>();
    auto left = decoder.decode<WebCore::RubberBandingBehavior>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::RectEdges<WebCore::RubberBandingBehavior> {
            WTFMove(*top),
            WTFMove(*right),
            WTFMove(*bottom),
            WTFMove(*left)
        }
    };
}

void ArgumentCoder<WebCore::Path>::encode(Encoder& encoder, const WebCore::Path& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.segments())>, Vector<WebCore::PathSegment>>);

    encoder << instance.segments();
}

void ArgumentCoder<WebCore::Path>::encode(StreamConnectionEncoder& encoder, const WebCore::Path& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.segments())>, Vector<WebCore::PathSegment>>);

    encoder << instance.segments();
}

std::optional<WebCore::Path> ArgumentCoder<WebCore::Path>::decode(Decoder& decoder)
{
    auto segments = decoder.decode<Vector<WebCore::PathSegment>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Path {
            WTFMove(*segments)
        }
    };
}

#if ENABLE(META_VIEWPORT)
void ArgumentCoder<WebCore::ViewportArguments>::encode(Encoder& encoder, const WebCore::ViewportArguments& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::ViewportArguments::Type>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.width)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.height)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.zoom)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.minZoom)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxZoom)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.userZoom)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.orientation)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shrinkToFit)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.viewportFit)>, WebCore::ViewportFit>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.widthWasExplicit)>, bool>);
    struct ShouldBeSameSizeAsViewportArguments : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ViewportArguments>, false> {
        WebCore::ViewportArguments::Type type;
        float width;
        float height;
        float zoom;
        float minZoom;
        float maxZoom;
        float userZoom;
        float orientation;
        float shrinkToFit;
        WebCore::ViewportFit viewportFit;
        bool widthWasExplicit;
    };
    static_assert(sizeof(ShouldBeSameSizeAsViewportArguments) == sizeof(WebCore::ViewportArguments));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ViewportArguments, type)
        , offsetof(WebCore::ViewportArguments, width)
        , offsetof(WebCore::ViewportArguments, height)
        , offsetof(WebCore::ViewportArguments, zoom)
        , offsetof(WebCore::ViewportArguments, minZoom)
        , offsetof(WebCore::ViewportArguments, maxZoom)
        , offsetof(WebCore::ViewportArguments, userZoom)
        , offsetof(WebCore::ViewportArguments, orientation)
        , offsetof(WebCore::ViewportArguments, shrinkToFit)
        , offsetof(WebCore::ViewportArguments, viewportFit)
        , offsetof(WebCore::ViewportArguments, widthWasExplicit)
    >::value);

    encoder << instance.type;
    encoder << instance.width;
    encoder << instance.height;
    encoder << instance.zoom;
    encoder << instance.minZoom;
    encoder << instance.maxZoom;
    encoder << instance.userZoom;
    encoder << instance.orientation;
    encoder << instance.shrinkToFit;
    encoder << instance.viewportFit;
    encoder << instance.widthWasExplicit;
}

std::optional<WebCore::ViewportArguments> ArgumentCoder<WebCore::ViewportArguments>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::ViewportArguments::Type>();
    auto width = decoder.decode<float>();
    auto height = decoder.decode<float>();
    auto zoom = decoder.decode<float>();
    auto minZoom = decoder.decode<float>();
    auto maxZoom = decoder.decode<float>();
    auto userZoom = decoder.decode<float>();
    auto orientation = decoder.decode<float>();
    auto shrinkToFit = decoder.decode<float>();
    auto viewportFit = decoder.decode<WebCore::ViewportFit>();
    auto widthWasExplicit = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ViewportArguments {
            WTFMove(*type),
            WTFMove(*width),
            WTFMove(*height),
            WTFMove(*zoom),
            WTFMove(*minZoom),
            WTFMove(*maxZoom),
            WTFMove(*userZoom),
            WTFMove(*orientation),
            WTFMove(*shrinkToFit),
            WTFMove(*viewportFit),
            WTFMove(*widthWasExplicit)
        }
    };
}

#endif

void ArgumentCoder<WebCore::HTTPHeaderMap::CommonHeader>::encode(Encoder& encoder, const WebCore::HTTPHeaderMap::CommonHeader& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.key)>, WebCore::HTTPHeaderName>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, String>);
    struct ShouldBeSameSizeAsCommonHeader : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::HTTPHeaderMap::CommonHeader>, false> {
        WebCore::HTTPHeaderName key;
        String value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCommonHeader) == sizeof(WebCore::HTTPHeaderMap::CommonHeader));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::HTTPHeaderMap::CommonHeader, key)
        , offsetof(WebCore::HTTPHeaderMap::CommonHeader, value)
    >::value);

    encoder << instance.key;
    encoder << instance.value;
}

std::optional<WebCore::HTTPHeaderMap::CommonHeader> ArgumentCoder<WebCore::HTTPHeaderMap::CommonHeader>::decode(Decoder& decoder)
{
    auto key = decoder.decode<WebCore::HTTPHeaderName>();
    auto value = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::HTTPHeaderMap::CommonHeader {
            WTFMove(*key),
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebCore::HTTPHeaderMap::UncommonHeader>::encode(Encoder& encoder, const WebCore::HTTPHeaderMap::UncommonHeader& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.key)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, String>);
    struct ShouldBeSameSizeAsUncommonHeader : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::HTTPHeaderMap::UncommonHeader>, false> {
        String key;
        String value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsUncommonHeader) == sizeof(WebCore::HTTPHeaderMap::UncommonHeader));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::HTTPHeaderMap::UncommonHeader, key)
        , offsetof(WebCore::HTTPHeaderMap::UncommonHeader, value)
    >::value);

    encoder << instance.key;
    encoder << instance.value;
}

std::optional<WebCore::HTTPHeaderMap::UncommonHeader> ArgumentCoder<WebCore::HTTPHeaderMap::UncommonHeader>::decode(Decoder& decoder)
{
    auto key = decoder.decode<String>();
    auto value = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::HTTPHeaderMap::UncommonHeader {
            WTFMove(*key),
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebCore::HTTPHeaderMap>::encode(Encoder& encoder, const WebCore::HTTPHeaderMap& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.commonHeaders())>, Vector<WebCore::HTTPHeaderMap::CommonHeader, 0, CrashOnOverflow, 6>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.uncommonHeaders())>, Vector<WebCore::HTTPHeaderMap::UncommonHeader, 0, CrashOnOverflow, 0>>);

    encoder << instance.commonHeaders();
    encoder << instance.uncommonHeaders();
}

std::optional<WebCore::HTTPHeaderMap> ArgumentCoder<WebCore::HTTPHeaderMap>::decode(Decoder& decoder)
{
    auto commonHeaders = decoder.decode<Vector<WebCore::HTTPHeaderMap::CommonHeader, 0, CrashOnOverflow, 6>>();
    auto uncommonHeaders = decoder.decode<Vector<WebCore::HTTPHeaderMap::UncommonHeader, 0, CrashOnOverflow, 0>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::HTTPHeaderMap {
            WTFMove(*commonHeaders),
            WTFMove(*uncommonHeaders)
        }
    };
}

void ArgumentCoder<WebCore::ElementContext>::encode(Encoder& encoder, const WebCore::ElementContext& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.boundingRect)>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webPageIdentifier)>, Markable<WebCore::PageIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.documentIdentifier)>, Markable<WebCore::ScriptExecutionContextIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.nodeIdentifier)>, Markable<WebCore::NodeIdentifier>>);
    struct ShouldBeSameSizeAsElementContext : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ElementContext>, false> {
        WebCore::FloatRect boundingRect;
        Markable<WebCore::PageIdentifier> webPageIdentifier;
        Markable<WebCore::ScriptExecutionContextIdentifier> documentIdentifier;
        Markable<WebCore::NodeIdentifier> nodeIdentifier;
    };
    static_assert(sizeof(ShouldBeSameSizeAsElementContext) == sizeof(WebCore::ElementContext));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ElementContext, boundingRect)
        , offsetof(WebCore::ElementContext, webPageIdentifier)
        , offsetof(WebCore::ElementContext, documentIdentifier)
        , offsetof(WebCore::ElementContext, nodeIdentifier)
    >::value);

    encoder << instance.boundingRect;
    encoder << instance.webPageIdentifier;
    encoder << instance.documentIdentifier;
    encoder << instance.nodeIdentifier;
}

std::optional<WebCore::ElementContext> ArgumentCoder<WebCore::ElementContext>::decode(Decoder& decoder)
{
    auto boundingRect = decoder.decode<WebCore::FloatRect>();
    auto webPageIdentifier = decoder.decode<Markable<WebCore::PageIdentifier>>();
    auto documentIdentifier = decoder.decode<Markable<WebCore::ScriptExecutionContextIdentifier>>();
    auto nodeIdentifier = decoder.decode<Markable<WebCore::NodeIdentifier>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ElementContext {
            WTFMove(*boundingRect),
            WTFMove(*webPageIdentifier),
            WTFMove(*documentIdentifier),
            WTFMove(*nodeIdentifier)
        }
    };
}

void ArgumentCoder<WebCore::ElementAnimationContext>::encode(Encoder& encoder, const WebCore::ElementAnimationContext& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.element)>, WebCore::ElementContext>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isAnimating)>, bool>);
    struct ShouldBeSameSizeAsElementAnimationContext : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ElementAnimationContext>, false> {
        WebCore::ElementContext element;
        bool isAnimating;
    };
    static_assert(sizeof(ShouldBeSameSizeAsElementAnimationContext) == sizeof(WebCore::ElementAnimationContext));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ElementAnimationContext, element)
        , offsetof(WebCore::ElementAnimationContext, isAnimating)
    >::value);

    encoder << instance.element;
    encoder << instance.isAnimating;
}

std::optional<WebCore::ElementAnimationContext> ArgumentCoder<WebCore::ElementAnimationContext>::decode(Decoder& decoder)
{
    auto element = decoder.decode<WebCore::ElementContext>();
    auto isAnimating = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ElementAnimationContext {
            WTFMove(*element),
            WTFMove(*isAnimating)
        }
    };
}

void ArgumentCoder<WebCore::SystemPreviewInfo>::encode(Encoder& encoder, const WebCore::SystemPreviewInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.element)>, WebCore::ElementContext>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.previewRect)>, WebCore::IntRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isPreview)>, bool>);
    struct ShouldBeSameSizeAsSystemPreviewInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SystemPreviewInfo>, false> {
        WebCore::ElementContext element;
        WebCore::IntRect previewRect;
        bool isPreview;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSystemPreviewInfo) == sizeof(WebCore::SystemPreviewInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SystemPreviewInfo, element)
        , offsetof(WebCore::SystemPreviewInfo, previewRect)
        , offsetof(WebCore::SystemPreviewInfo, isPreview)
    >::value);

    encoder << instance.element;
    encoder << instance.previewRect;
    encoder << instance.isPreview;
}

std::optional<WebCore::SystemPreviewInfo> ArgumentCoder<WebCore::SystemPreviewInfo>::decode(Decoder& decoder)
{
    auto element = decoder.decode<WebCore::ElementContext>();
    auto previewRect = decoder.decode<WebCore::IntRect>();
    auto isPreview = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SystemPreviewInfo {
            WTFMove(*element),
            WTFMove(*previewRect),
            WTFMove(*isPreview)
        }
    };
}

void ArgumentCoder<WebCore::ResourceRequest::RequestData>::encode(Encoder& encoder, const WebCore::ResourceRequest::RequestData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_url)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_firstPartyForCookies)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_timeoutInterval)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_httpMethod)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_httpHeaderFields)>, WebCore::HTTPHeaderMap>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_responseContentDispositionEncodingFallbackArray)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_cachePolicy)>, WebCore::ResourceRequestCachePolicy>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_sameSiteDisposition)>, WebCore::ResourceRequestBase::SameSiteDisposition>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_priority)>, WebCore::ResourceLoadPriority>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_requester)>, WebCore::ResourceRequestRequester>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_allowCookies)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_isTopSite)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_isAppInitiated)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_privacyProxyFailClosedForUnreachableNonMainHosts)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_useAdvancedPrivacyProtections)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_didFilterLinkDecoration)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_isPrivateTokenUsageByThirdPartyAllowed)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_wasSchemeOptimisticallyUpgraded)>, bool>);
    struct ShouldBeSameSizeAsRequestData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ResourceRequest::RequestData>, false> {
        URL m_url;
        URL m_firstPartyForCookies;
        double m_timeoutInterval;
        String m_httpMethod;
        WebCore::HTTPHeaderMap m_httpHeaderFields;
        Vector<String> m_responseContentDispositionEncodingFallbackArray;
        WebCore::ResourceRequestCachePolicy m_cachePolicy;
        WebCore::ResourceRequestBase::SameSiteDisposition m_sameSiteDisposition;
        WebCore::ResourceLoadPriority m_priority;
        WebCore::ResourceRequestRequester m_requester;
        bool m_allowCookies : 1;
        bool m_isTopSite : 1;
        bool m_isAppInitiated : 1;
        bool m_privacyProxyFailClosedForUnreachableNonMainHosts : 1;
        bool m_useAdvancedPrivacyProtections : 1;
        bool m_didFilterLinkDecoration : 1;
        bool m_isPrivateTokenUsageByThirdPartyAllowed : 1;
        bool m_wasSchemeOptimisticallyUpgraded : 1;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRequestData) == sizeof(WebCore::ResourceRequest::RequestData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ResourceRequest::RequestData, m_url)
        , offsetof(WebCore::ResourceRequest::RequestData, m_firstPartyForCookies)
        , offsetof(WebCore::ResourceRequest::RequestData, m_timeoutInterval)
        , offsetof(WebCore::ResourceRequest::RequestData, m_httpMethod)
        , offsetof(WebCore::ResourceRequest::RequestData, m_httpHeaderFields)
        , offsetof(WebCore::ResourceRequest::RequestData, m_responseContentDispositionEncodingFallbackArray)
        , offsetof(WebCore::ResourceRequest::RequestData, m_cachePolicy)
        , offsetof(WebCore::ResourceRequest::RequestData, m_sameSiteDisposition)
        , offsetof(WebCore::ResourceRequest::RequestData, m_priority)
        , offsetof(WebCore::ResourceRequest::RequestData, m_requester)
    >::value);

    encoder << instance.m_url;
    encoder << instance.m_firstPartyForCookies;
    encoder << instance.m_timeoutInterval;
    encoder << instance.m_httpMethod;
    encoder << instance.m_httpHeaderFields;
    encoder << instance.m_responseContentDispositionEncodingFallbackArray;
    encoder << instance.m_cachePolicy;
    encoder << instance.m_sameSiteDisposition;
    encoder << instance.m_priority;
    encoder << instance.m_requester;
    encoder << instance.m_allowCookies;
    encoder << instance.m_isTopSite;
    encoder << instance.m_isAppInitiated;
    encoder << instance.m_privacyProxyFailClosedForUnreachableNonMainHosts;
    encoder << instance.m_useAdvancedPrivacyProtections;
    encoder << instance.m_didFilterLinkDecoration;
    encoder << instance.m_isPrivateTokenUsageByThirdPartyAllowed;
    encoder << instance.m_wasSchemeOptimisticallyUpgraded;
}

std::optional<WebCore::ResourceRequest::RequestData> ArgumentCoder<WebCore::ResourceRequest::RequestData>::decode(Decoder& decoder)
{
    auto m_url = decoder.decode<URL>();
    auto m_firstPartyForCookies = decoder.decode<URL>();
    auto m_timeoutInterval = decoder.decode<double>();
    auto m_httpMethod = decoder.decode<String>();
    auto m_httpHeaderFields = decoder.decode<WebCore::HTTPHeaderMap>();
    auto m_responseContentDispositionEncodingFallbackArray = decoder.decode<Vector<String>>();
    auto m_cachePolicy = decoder.decode<WebCore::ResourceRequestCachePolicy>();
    auto m_sameSiteDisposition = decoder.decode<WebCore::ResourceRequestBase::SameSiteDisposition>();
    auto m_priority = decoder.decode<WebCore::ResourceLoadPriority>();
    auto m_requester = decoder.decode<WebCore::ResourceRequestRequester>();
    auto m_allowCookies = decoder.decode<bool>();
    auto m_isTopSite = decoder.decode<bool>();
    auto m_isAppInitiated = decoder.decode<bool>();
    auto m_privacyProxyFailClosedForUnreachableNonMainHosts = decoder.decode<bool>();
    auto m_useAdvancedPrivacyProtections = decoder.decode<bool>();
    auto m_didFilterLinkDecoration = decoder.decode<bool>();
    auto m_isPrivateTokenUsageByThirdPartyAllowed = decoder.decode<bool>();
    auto m_wasSchemeOptimisticallyUpgraded = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ResourceRequest::RequestData {
            WTFMove(*m_url),
            WTFMove(*m_firstPartyForCookies),
            WTFMove(*m_timeoutInterval),
            WTFMove(*m_httpMethod),
            WTFMove(*m_httpHeaderFields),
            WTFMove(*m_responseContentDispositionEncodingFallbackArray),
            WTFMove(*m_cachePolicy),
            WTFMove(*m_sameSiteDisposition),
            WTFMove(*m_priority),
            WTFMove(*m_requester),
            WTFMove(*m_allowCookies),
            WTFMove(*m_isTopSite),
            WTFMove(*m_isAppInitiated),
            WTFMove(*m_privacyProxyFailClosedForUnreachableNonMainHosts),
            WTFMove(*m_useAdvancedPrivacyProtections),
            WTFMove(*m_didFilterLinkDecoration),
            WTFMove(*m_isPrivateTokenUsageByThirdPartyAllowed),
            WTFMove(*m_wasSchemeOptimisticallyUpgraded)
        }
    };
}

#if USE(SOUP)
void ArgumentCoder<WebCore::ResourceRequestPlatformData>::encode(Encoder& encoder, const WebCore::ResourceRequestPlatformData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requestData)>, WebCore::ResourceRequest::RequestData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.acceptEncoding)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.redirectCount)>, uint16_t>);
    struct ShouldBeSameSizeAsResourceRequestPlatformData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ResourceRequestPlatformData>, false> {
        WebCore::ResourceRequest::RequestData requestData;
        bool acceptEncoding;
        uint16_t redirectCount;
    };
    static_assert(sizeof(ShouldBeSameSizeAsResourceRequestPlatformData) == sizeof(WebCore::ResourceRequestPlatformData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ResourceRequestPlatformData, requestData)
        , offsetof(WebCore::ResourceRequestPlatformData, acceptEncoding)
        , offsetof(WebCore::ResourceRequestPlatformData, redirectCount)
    >::value);

    encoder << instance.requestData;
    encoder << instance.acceptEncoding;
    encoder << instance.redirectCount;
}

std::optional<WebCore::ResourceRequestPlatformData> ArgumentCoder<WebCore::ResourceRequestPlatformData>::decode(Decoder& decoder)
{
    auto requestData = decoder.decode<WebCore::ResourceRequest::RequestData>();
    auto acceptEncoding = decoder.decode<bool>();
    auto redirectCount = decoder.decode<uint16_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ResourceRequestPlatformData {
            WTFMove(*requestData),
            WTFMove(*acceptEncoding),
            WTFMove(*redirectCount)
        }
    };
}

#endif

#if PLATFORM(COCOA)
void ArgumentCoder<WebCore::ResourceRequest>::encode(Encoder& encoder, const WebCore::ResourceRequest& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.getRequestDataToSerialize())>, Variant<WebCore::ResourceRequest::RequestData, WebCore::ResourceRequestPlatformData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cachePartition())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hiddenFromInspector())>, bool>);

    encoder << instance.getRequestDataToSerialize();
    encoder << instance.cachePartition();
    encoder << instance.hiddenFromInspector();
}

std::optional<WebCore::ResourceRequest> ArgumentCoder<WebCore::ResourceRequest>::decode(Decoder& decoder)
{
    auto getRequestDataToSerialize = decoder.decode<Variant<WebCore::ResourceRequest::RequestData, WebCore::ResourceRequestPlatformData>>();
    auto cachePartition = decoder.decode<String>();
    auto hiddenFromInspector = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ResourceRequest::fromResourceRequestData(
            WTFMove(*getRequestDataToSerialize),
            WTFMove(*cachePartition),
            WTFMove(*hiddenFromInspector)
        )
    };
}

#endif

#if USE(CURL)
void ArgumentCoder<WebCore::ResourceRequest>::encode(Encoder& encoder, const WebCore::ResourceRequest& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.getRequestDataToSerialize())>, WebCore::ResourceRequest::RequestData>);

    encoder << instance.getRequestDataToSerialize();
}

std::optional<WebCore::ResourceRequest> ArgumentCoder<WebCore::ResourceRequest>::decode(Decoder& decoder)
{
    auto getRequestDataToSerialize = decoder.decode<WebCore::ResourceRequest::RequestData>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ResourceRequest::fromResourceRequestData(
            WTFMove(*getRequestDataToSerialize)
        )
    };
}

#endif

#if !USE(CURL) && !PLATFORM(COCOA)
void ArgumentCoder<WebCore::ResourceRequest>::encode(Encoder& encoder, const WebCore::ResourceRequest& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.getRequestDataToSerialize())>, Variant<WebCore::ResourceRequest::RequestData, WebCore::ResourceRequestPlatformData>>);

    encoder << instance.getRequestDataToSerialize();
}

std::optional<WebCore::ResourceRequest> ArgumentCoder<WebCore::ResourceRequest>::decode(Decoder& decoder)
{
    auto getRequestDataToSerialize = decoder.decode<Variant<WebCore::ResourceRequest::RequestData, WebCore::ResourceRequestPlatformData>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ResourceRequest::fromResourceRequestData(
            WTFMove(*getRequestDataToSerialize)
        )
    };
}

#endif

void ArgumentCoder<WebCore::ResourceError::IPCData>::encode(Encoder& encoder, const WebCore::ResourceError::IPCData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::ResourceErrorBaseType>);
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.nsError)>, RetainPtr<NSError>>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isSanitized)>, bool>);
#endif
#if !PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.domain)>, String>);
#endif
#if !PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.errorCode)>, int>);
#endif
#if !PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.failingURL)>, URL>);
#endif
#if !PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.localizedDescription)>, String>);
#endif
#if !PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isSanitized)>, WebCore::ResourceError::IsSanitized>);
#endif
#if USE(SOUP)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.certificateInfo)>, WebCore::CertificateInfo>);
#endif
    struct ShouldBeSameSizeAsIPCData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ResourceError::IPCData>, false> {
        WebCore::ResourceErrorBaseType type;
#if PLATFORM(COCOA)
        RetainPtr<NSError> nsError;
#endif
#if PLATFORM(COCOA)
        bool isSanitized;
#endif
#if !PLATFORM(COCOA)
        String domain;
#endif
#if !PLATFORM(COCOA)
        int errorCode;
#endif
#if !PLATFORM(COCOA)
        URL failingURL;
#endif
#if !PLATFORM(COCOA)
        String localizedDescription;
#endif
#if !PLATFORM(COCOA)
        WebCore::ResourceError::IsSanitized isSanitized;
#endif
#if USE(SOUP)
        WebCore::CertificateInfo certificateInfo;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsIPCData) == sizeof(WebCore::ResourceError::IPCData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ResourceError::IPCData, type)
#if PLATFORM(COCOA)
        , offsetof(WebCore::ResourceError::IPCData, nsError)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebCore::ResourceError::IPCData, isSanitized)
#endif
#if !PLATFORM(COCOA)
        , offsetof(WebCore::ResourceError::IPCData, domain)
#endif
#if !PLATFORM(COCOA)
        , offsetof(WebCore::ResourceError::IPCData, errorCode)
#endif
#if !PLATFORM(COCOA)
        , offsetof(WebCore::ResourceError::IPCData, failingURL)
#endif
#if !PLATFORM(COCOA)
        , offsetof(WebCore::ResourceError::IPCData, localizedDescription)
#endif
#if !PLATFORM(COCOA)
        , offsetof(WebCore::ResourceError::IPCData, isSanitized)
#endif
#if USE(SOUP)
        , offsetof(WebCore::ResourceError::IPCData, certificateInfo)
#endif
    >::value);

    encoder << instance.type;
#if PLATFORM(COCOA)
    encoder << instance.nsError;
#endif
#if PLATFORM(COCOA)
    encoder << instance.isSanitized;
#endif
#if !PLATFORM(COCOA)
    encoder << instance.domain;
#endif
#if !PLATFORM(COCOA)
    encoder << instance.errorCode;
#endif
#if !PLATFORM(COCOA)
    encoder << instance.failingURL;
#endif
#if !PLATFORM(COCOA)
    encoder << instance.localizedDescription;
#endif
#if !PLATFORM(COCOA)
    encoder << instance.isSanitized;
#endif
#if USE(SOUP)
    encoder << instance.certificateInfo;
#endif
}

std::optional<WebCore::ResourceError::IPCData> ArgumentCoder<WebCore::ResourceError::IPCData>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::ResourceErrorBaseType>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(*type != WebCore::ResourceError::Type::Null))
        return std::nullopt;
#if PLATFORM(COCOA)
    auto nsError = decoder.decode<RetainPtr<NSError>>();
#endif
#if PLATFORM(COCOA)
    auto isSanitized = decoder.decode<bool>();
#endif
#if !PLATFORM(COCOA)
    auto domain = decoder.decode<String>();
#endif
#if !PLATFORM(COCOA)
    auto errorCode = decoder.decode<int>();
#endif
#if !PLATFORM(COCOA)
    auto failingURL = decoder.decode<URL>();
#endif
#if !PLATFORM(COCOA)
    auto localizedDescription = decoder.decode<String>();
#endif
#if !PLATFORM(COCOA)
    auto isSanitized = decoder.decode<WebCore::ResourceError::IsSanitized>();
#endif
#if USE(SOUP)
    auto certificateInfo = decoder.decode<WebCore::CertificateInfo>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ResourceError::IPCData {
            WTFMove(*type),
#if PLATFORM(COCOA)
            WTFMove(*nsError),
#endif
#if PLATFORM(COCOA)
            WTFMove(*isSanitized),
#endif
#if !PLATFORM(COCOA)
            WTFMove(*domain),
#endif
#if !PLATFORM(COCOA)
            WTFMove(*errorCode),
#endif
#if !PLATFORM(COCOA)
            WTFMove(*failingURL),
#endif
#if !PLATFORM(COCOA)
            WTFMove(*localizedDescription),
#endif
#if !PLATFORM(COCOA)
            WTFMove(*isSanitized),
#endif
#if USE(SOUP)
            WTFMove(*certificateInfo)
#endif
        }
    };
}

void ArgumentCoder<WebCore::ResourceError>::encode(Encoder& encoder, const WebCore::ResourceError& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ipcData())>, std::optional<WebCore::ResourceError::IPCData>>);

    encoder << instance.ipcData();
}

std::optional<WebCore::ResourceError> ArgumentCoder<WebCore::ResourceError>::decode(Decoder& decoder)
{
    auto ipcData = decoder.decode<std::optional<WebCore::ResourceError::IPCData>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ResourceError::fromIPCData(
            WTFMove(*ipcData)
        )
    };
}

#if (!(USE(CG))) && (!(USE(SKIA)))
void ArgumentCoder<WebCore::PlatformColorSpace>::encode(Encoder& encoder, const WebCore::PlatformColorSpace& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.get())>, WebCore::PlatformColorSpace::Name>);

    encoder << instance.get();
}

void ArgumentCoder<WebCore::PlatformColorSpace>::encode(StreamConnectionEncoder& encoder, const WebCore::PlatformColorSpace& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.get())>, WebCore::PlatformColorSpace::Name>);

    encoder << instance.get();
}

std::optional<WebCore::PlatformColorSpace> ArgumentCoder<WebCore::PlatformColorSpace>::decode(Decoder& decoder)
{
    auto get = decoder.decode<WebCore::PlatformColorSpace::Name>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PlatformColorSpace {
            WTFMove(*get)
        }
    };
}

#endif

void ArgumentCoder<WebCore::DestinationColorSpace>::encode(Encoder& encoder, const WebCore::DestinationColorSpace& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.serializableColorSpace())>, WebCore::PlatformColorSpace>);

    encoder << instance.serializableColorSpace();
}

void ArgumentCoder<WebCore::DestinationColorSpace>::encode(StreamConnectionEncoder& encoder, const WebCore::DestinationColorSpace& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.serializableColorSpace())>, WebCore::PlatformColorSpace>);

    encoder << instance.serializableColorSpace();
}

std::optional<WebCore::DestinationColorSpace> ArgumentCoder<WebCore::DestinationColorSpace>::decode(Decoder& decoder)
{
    auto serializableColorSpace = decoder.decode<WebCore::PlatformColorSpace>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DestinationColorSpace {
            WTFMove(*serializableColorSpace)
        }
    };
}

void ArgumentCoder<WebCore::WindowFeatures>::encode(Encoder& encoder, const WebCore::WindowFeatures& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasAdditionalFeatures)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.x)>, std::optional<float>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.y)>, std::optional<float>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.width)>, std::optional<float>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.height)>, std::optional<float>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.popup)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.menuBarVisible)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.statusBarVisible)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.toolBarVisible)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.locationBarVisible)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scrollbarsVisible)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.resizable)>, std::optional<bool>>);
#if PLATFORM(GTK)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.oldWindowRect)>, WebCore::FloatRect>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fullscreen)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dialog)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.noopener)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.noreferrer)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.additionalFeatures)>, Vector<String>>);
    struct ShouldBeSameSizeAsWindowFeatures : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::WindowFeatures>, false> {
        bool hasAdditionalFeatures;
        std::optional<float> x;
        std::optional<float> y;
        std::optional<float> width;
        std::optional<float> height;
        std::optional<bool> popup;
        std::optional<bool> menuBarVisible;
        std::optional<bool> statusBarVisible;
        std::optional<bool> toolBarVisible;
        std::optional<bool> locationBarVisible;
        std::optional<bool> scrollbarsVisible;
        std::optional<bool> resizable;
#if PLATFORM(GTK)
        WebCore::FloatRect oldWindowRect;
#endif
        std::optional<bool> fullscreen;
        std::optional<bool> dialog;
        std::optional<bool> noopener;
        std::optional<bool> noreferrer;
        Vector<String> additionalFeatures;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWindowFeatures) == sizeof(WebCore::WindowFeatures));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::WindowFeatures, hasAdditionalFeatures)
        , offsetof(WebCore::WindowFeatures, x)
        , offsetof(WebCore::WindowFeatures, y)
        , offsetof(WebCore::WindowFeatures, width)
        , offsetof(WebCore::WindowFeatures, height)
        , offsetof(WebCore::WindowFeatures, popup)
        , offsetof(WebCore::WindowFeatures, menuBarVisible)
        , offsetof(WebCore::WindowFeatures, statusBarVisible)
        , offsetof(WebCore::WindowFeatures, toolBarVisible)
        , offsetof(WebCore::WindowFeatures, locationBarVisible)
        , offsetof(WebCore::WindowFeatures, scrollbarsVisible)
        , offsetof(WebCore::WindowFeatures, resizable)
#if PLATFORM(GTK)
        , offsetof(WebCore::WindowFeatures, oldWindowRect)
#endif
        , offsetof(WebCore::WindowFeatures, fullscreen)
        , offsetof(WebCore::WindowFeatures, dialog)
        , offsetof(WebCore::WindowFeatures, noopener)
        , offsetof(WebCore::WindowFeatures, noreferrer)
        , offsetof(WebCore::WindowFeatures, additionalFeatures)
    >::value);

    encoder << instance.hasAdditionalFeatures;
    encoder << instance.x;
    encoder << instance.y;
    encoder << instance.width;
    encoder << instance.height;
    encoder << instance.popup;
    encoder << instance.menuBarVisible;
    encoder << instance.statusBarVisible;
    encoder << instance.toolBarVisible;
    encoder << instance.locationBarVisible;
    encoder << instance.scrollbarsVisible;
    encoder << instance.resizable;
#if PLATFORM(GTK)
    encoder << instance.oldWindowRect;
#endif
    encoder << instance.fullscreen;
    encoder << instance.dialog;
    encoder << instance.noopener;
}

std::optional<WebCore::WindowFeatures> ArgumentCoder<WebCore::WindowFeatures>::decode(Decoder& decoder)
{
    auto hasAdditionalFeatures = decoder.decode<bool>();
    auto x = decoder.decode<std::optional<float>>();
    auto y = decoder.decode<std::optional<float>>();
    auto width = decoder.decode<std::optional<float>>();
    auto height = decoder.decode<std::optional<float>>();
    auto popup = decoder.decode<std::optional<bool>>();
    auto menuBarVisible = decoder.decode<std::optional<bool>>();
    auto statusBarVisible = decoder.decode<std::optional<bool>>();
    auto toolBarVisible = decoder.decode<std::optional<bool>>();
    auto locationBarVisible = decoder.decode<std::optional<bool>>();
    auto scrollbarsVisible = decoder.decode<std::optional<bool>>();
    auto resizable = decoder.decode<std::optional<bool>>();
#if PLATFORM(GTK)
    auto oldWindowRect = decoder.decode<WebCore::FloatRect>();
#endif
    auto fullscreen = decoder.decode<std::optional<bool>>();
    auto dialog = decoder.decode<std::optional<bool>>();
    auto noopener = decoder.decode<std::optional<bool>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::WindowFeatures {
            WTFMove(*hasAdditionalFeatures),
            WTFMove(*x),
            WTFMove(*y),
            WTFMove(*width),
            WTFMove(*height),
            WTFMove(*popup),
            WTFMove(*menuBarVisible),
            WTFMove(*statusBarVisible),
            WTFMove(*toolBarVisible),
            WTFMove(*locationBarVisible),
            WTFMove(*scrollbarsVisible),
            WTFMove(*resizable),
#if PLATFORM(GTK)
            WTFMove(*oldWindowRect),
#endif
            WTFMove(*fullscreen),
            WTFMove(*dialog),
            WTFMove(*noopener)
        }
    };
}

void ArgumentCoder<WebCore::CompositionUnderline>::encode(Encoder& encoder, const WebCore::CompositionUnderline& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.startOffset)>, unsigned>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.endOffset)>, unsigned>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.compositionUnderlineColor)>, WebCore::CompositionUnderlineColor>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.color)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.thick)>, bool>);
    struct ShouldBeSameSizeAsCompositionUnderline : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::CompositionUnderline>, false> {
        unsigned startOffset;
        unsigned endOffset;
        WebCore::CompositionUnderlineColor compositionUnderlineColor;
        WebCore::Color color;
        bool thick;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCompositionUnderline) == sizeof(WebCore::CompositionUnderline));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::CompositionUnderline, startOffset)
        , offsetof(WebCore::CompositionUnderline, endOffset)
        , offsetof(WebCore::CompositionUnderline, compositionUnderlineColor)
        , offsetof(WebCore::CompositionUnderline, color)
        , offsetof(WebCore::CompositionUnderline, thick)
    >::value);

    encoder << instance.startOffset;
    encoder << instance.endOffset;
    encoder << instance.compositionUnderlineColor;
    encoder << instance.color;
    encoder << instance.thick;
}

std::optional<WebCore::CompositionUnderline> ArgumentCoder<WebCore::CompositionUnderline>::decode(Decoder& decoder)
{
    auto startOffset = decoder.decode<unsigned>();
    auto endOffset = decoder.decode<unsigned>();
    auto compositionUnderlineColor = decoder.decode<WebCore::CompositionUnderlineColor>();
    auto color = decoder.decode<WebCore::Color>();
    auto thick = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CompositionUnderline {
            WTFMove(*startOffset),
            WTFMove(*endOffset),
            WTFMove(*compositionUnderlineColor),
            WTFMove(*color),
            WTFMove(*thick)
        }
    };
}

#if PLATFORM(COCOA) && ENABLE(GPU_PROCESS) && ENABLE(WEBGL)
void ArgumentCoder<WebCore::GraphicsContextGLExternalImageSourceIOSurfaceHandle>::encode(Encoder& encoder, WebCore::GraphicsContextGLExternalImageSourceIOSurfaceHandle&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.handle)>, MachSendRight>);
    struct ShouldBeSameSizeAsGraphicsContextGLExternalImageSourceIOSurfaceHandle : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::GraphicsContextGLExternalImageSourceIOSurfaceHandle>, false> {
        MachSendRight handle;
    };
    static_assert(sizeof(ShouldBeSameSizeAsGraphicsContextGLExternalImageSourceIOSurfaceHandle) == sizeof(WebCore::GraphicsContextGLExternalImageSourceIOSurfaceHandle));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::GraphicsContextGLExternalImageSourceIOSurfaceHandle, handle)
    >::value);

    encoder << WTFMove(instance.handle);
}

std::optional<WebCore::GraphicsContextGLExternalImageSourceIOSurfaceHandle> ArgumentCoder<WebCore::GraphicsContextGLExternalImageSourceIOSurfaceHandle>::decode(Decoder& decoder)
{
    auto handle = decoder.decode<MachSendRight>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::GraphicsContextGLExternalImageSourceIOSurfaceHandle {
            WTFMove(*handle)
        }
    };
}

#endif

#if PLATFORM(COCOA) && ENABLE(GPU_PROCESS) && ENABLE(WEBGL)
void ArgumentCoder<WebCore::GraphicsContextGLExternalImageSourceMTLSharedTextureHandle>::encode(Encoder& encoder, WebCore::GraphicsContextGLExternalImageSourceMTLSharedTextureHandle&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.handle)>, MachSendRight>);
    struct ShouldBeSameSizeAsGraphicsContextGLExternalImageSourceMTLSharedTextureHandle : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::GraphicsContextGLExternalImageSourceMTLSharedTextureHandle>, false> {
        MachSendRight handle;
    };
    static_assert(sizeof(ShouldBeSameSizeAsGraphicsContextGLExternalImageSourceMTLSharedTextureHandle) == sizeof(WebCore::GraphicsContextGLExternalImageSourceMTLSharedTextureHandle));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::GraphicsContextGLExternalImageSourceMTLSharedTextureHandle, handle)
    >::value);

    encoder << WTFMove(instance.handle);
}

std::optional<WebCore::GraphicsContextGLExternalImageSourceMTLSharedTextureHandle> ArgumentCoder<WebCore::GraphicsContextGLExternalImageSourceMTLSharedTextureHandle>::decode(Decoder& decoder)
{
    auto handle = decoder.decode<MachSendRight>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::GraphicsContextGLExternalImageSourceMTLSharedTextureHandle {
            WTFMove(*handle)
        }
    };
}

#endif

#if ENABLE(ATTACHMENT_ELEMENT)
void ArgumentCoder<WebCore::SerializedAttachmentData>::encode(Encoder& encoder, const WebCore::SerializedAttachmentData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mimeType)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data)>, Ref<WebCore::SharedBuffer>>);
    struct ShouldBeSameSizeAsSerializedAttachmentData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SerializedAttachmentData>, false> {
        String identifier;
        String mimeType;
        Ref<WebCore::SharedBuffer> data;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSerializedAttachmentData) == sizeof(WebCore::SerializedAttachmentData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SerializedAttachmentData, identifier)
        , offsetof(WebCore::SerializedAttachmentData, mimeType)
        , offsetof(WebCore::SerializedAttachmentData, data)
    >::value);

    encoder << instance.identifier;
    encoder << instance.mimeType;
    encoder << instance.data;
}

std::optional<WebCore::SerializedAttachmentData> ArgumentCoder<WebCore::SerializedAttachmentData>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<String>();
    auto mimeType = decoder.decode<String>();
    auto data = decoder.decode<Ref<WebCore::SharedBuffer>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SerializedAttachmentData {
            WTFMove(*identifier),
            WTFMove(*mimeType),
            WTFMove(*data)
        }
    };
}

#endif

void ArgumentCoder<WebCore::FileChooserSettings>::encode(Encoder& encoder, const WebCore::FileChooserSettings& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowsDirectories)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowsMultipleFiles)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.acceptMIMETypes)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.acceptFileExtensions)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selectedFiles)>, Vector<String>>);
#if ENABLE(MEDIA_CAPTURE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaCaptureType)>, WebCore::MediaCaptureType>);
#endif
    struct ShouldBeSameSizeAsFileChooserSettings : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FileChooserSettings>, false> {
        bool allowsDirectories;
        bool allowsMultipleFiles;
        Vector<String> acceptMIMETypes;
        Vector<String> acceptFileExtensions;
        Vector<String> selectedFiles;
#if ENABLE(MEDIA_CAPTURE)
        WebCore::MediaCaptureType mediaCaptureType;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsFileChooserSettings) == sizeof(WebCore::FileChooserSettings));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FileChooserSettings, allowsDirectories)
        , offsetof(WebCore::FileChooserSettings, allowsMultipleFiles)
        , offsetof(WebCore::FileChooserSettings, acceptMIMETypes)
        , offsetof(WebCore::FileChooserSettings, acceptFileExtensions)
        , offsetof(WebCore::FileChooserSettings, selectedFiles)
#if ENABLE(MEDIA_CAPTURE)
        , offsetof(WebCore::FileChooserSettings, mediaCaptureType)
#endif
    >::value);

    encoder << instance.allowsDirectories;
    encoder << instance.allowsMultipleFiles;
    encoder << instance.acceptMIMETypes;
    encoder << instance.acceptFileExtensions;
    encoder << instance.selectedFiles;
#if ENABLE(MEDIA_CAPTURE)
    encoder << instance.mediaCaptureType;
#endif
}

std::optional<WebCore::FileChooserSettings> ArgumentCoder<WebCore::FileChooserSettings>::decode(Decoder& decoder)
{
    auto allowsDirectories = decoder.decode<bool>();
    auto allowsMultipleFiles = decoder.decode<bool>();
    auto acceptMIMETypes = decoder.decode<Vector<String>>();
    auto acceptFileExtensions = decoder.decode<Vector<String>>();
    auto selectedFiles = decoder.decode<Vector<String>>();
#if ENABLE(MEDIA_CAPTURE)
    auto mediaCaptureType = decoder.decode<WebCore::MediaCaptureType>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FileChooserSettings {
            WTFMove(*allowsDirectories),
            WTFMove(*allowsMultipleFiles),
            WTFMove(*acceptMIMETypes),
            WTFMove(*acceptFileExtensions),
            WTFMove(*selectedFiles),
#if ENABLE(MEDIA_CAPTURE)
            WTFMove(*mediaCaptureType)
#endif
        }
    };
}

void ArgumentCoder<WebCore::GrammarDetail>::encode(Encoder& encoder, const WebCore::GrammarDetail& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.range)>, WebCore::CharacterRange>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.guesses)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.userDescription)>, String>);
    struct ShouldBeSameSizeAsGrammarDetail : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::GrammarDetail>, false> {
        WebCore::CharacterRange range;
        Vector<String> guesses;
        String userDescription;
    };
    static_assert(sizeof(ShouldBeSameSizeAsGrammarDetail) == sizeof(WebCore::GrammarDetail));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::GrammarDetail, range)
        , offsetof(WebCore::GrammarDetail, guesses)
        , offsetof(WebCore::GrammarDetail, userDescription)
    >::value);

    encoder << instance.range;
    encoder << instance.guesses;
    encoder << instance.userDescription;
}

std::optional<WebCore::GrammarDetail> ArgumentCoder<WebCore::GrammarDetail>::decode(Decoder& decoder)
{
    auto range = decoder.decode<WebCore::CharacterRange>();
    auto guesses = decoder.decode<Vector<String>>();
    auto userDescription = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::GrammarDetail {
            WTFMove(*range),
            WTFMove(*guesses),
            WTFMove(*userDescription)
        }
    };
}

void ArgumentCoder<WebCore::TextCheckingResult>::encode(Encoder& encoder, const WebCore::TextCheckingResult& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, OptionSet<WebCore::TextCheckingType>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.range)>, WebCore::CharacterRange>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.details)>, Vector<WebCore::GrammarDetail>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.replacement)>, String>);
    struct ShouldBeSameSizeAsTextCheckingResult : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::TextCheckingResult>, false> {
        OptionSet<WebCore::TextCheckingType> type;
        WebCore::CharacterRange range;
        Vector<WebCore::GrammarDetail> details;
        String replacement;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTextCheckingResult) == sizeof(WebCore::TextCheckingResult));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::TextCheckingResult, type)
        , offsetof(WebCore::TextCheckingResult, range)
        , offsetof(WebCore::TextCheckingResult, details)
        , offsetof(WebCore::TextCheckingResult, replacement)
    >::value);

    encoder << instance.type;
    encoder << instance.range;
    encoder << instance.details;
    encoder << instance.replacement;
}

std::optional<WebCore::TextCheckingResult> ArgumentCoder<WebCore::TextCheckingResult>::decode(Decoder& decoder)
{
    auto type = decoder.decode<OptionSet<WebCore::TextCheckingType>>();
    auto range = decoder.decode<WebCore::CharacterRange>();
    auto details = decoder.decode<Vector<WebCore::GrammarDetail>>();
    auto replacement = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TextCheckingResult {
            WTFMove(*type),
            WTFMove(*range),
            WTFMove(*details),
            WTFMove(*replacement)
        }
    };
}

void ArgumentCoder<WebCore::TextCheckingRequestData>::encode(Encoder& encoder, const WebCore::TextCheckingRequestData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier())>, std::optional<WebCore::TextCheckingRequestIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.text())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.checkingTypes())>, OptionSet<WebCore::TextCheckingType>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processType())>, WebCore::TextCheckingProcessType>);

    encoder << instance.identifier();
    encoder << instance.text();
    encoder << instance.checkingTypes();
    encoder << instance.processType();
}

std::optional<WebCore::TextCheckingRequestData> ArgumentCoder<WebCore::TextCheckingRequestData>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<std::optional<WebCore::TextCheckingRequestIdentifier>>();
    auto text = decoder.decode<String>();
    auto checkingTypes = decoder.decode<OptionSet<WebCore::TextCheckingType>>();
    auto processType = decoder.decode<WebCore::TextCheckingProcessType>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TextCheckingRequestData {
            WTFMove(*identifier),
            WTFMove(*text),
            WTFMove(*checkingTypes),
            WTFMove(*processType)
        }
    };
}

void ArgumentCoder<WebCore::LayoutRect>::encode(Encoder& encoder, const WebCore::LayoutRect& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_location)>, WebCore::LayoutPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_size)>, WebCore::LayoutSize>);
    struct ShouldBeSameSizeAsLayoutRect : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::LayoutRect>, false> {
        WebCore::LayoutPoint m_location;
        WebCore::LayoutSize m_size;
    };
    static_assert(sizeof(ShouldBeSameSizeAsLayoutRect) == sizeof(WebCore::LayoutRect));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::LayoutRect, m_location)
        , offsetof(WebCore::LayoutRect, m_size)
    >::value);

    encoder << instance.m_location;
    encoder << instance.m_size;
}

std::optional<WebCore::LayoutRect> ArgumentCoder<WebCore::LayoutRect>::decode(Decoder& decoder)
{
    auto m_location = decoder.decode<WebCore::LayoutPoint>();
    auto m_size = decoder.decode<WebCore::LayoutSize>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::LayoutRect {
            WTFMove(*m_location),
            WTFMove(*m_size)
        }
    };
}

void ArgumentCoder<WebCore::ScreenDataOverrides>::encode(Encoder& encoder, const WebCore::ScreenDataOverrides& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.width)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.height)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scale)>, double>);
    struct ShouldBeSameSizeAsScreenDataOverrides : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ScreenDataOverrides>, false> {
        double width;
        double height;
        double scale;
    };
    static_assert(sizeof(ShouldBeSameSizeAsScreenDataOverrides) == sizeof(WebCore::ScreenDataOverrides));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ScreenDataOverrides, width)
        , offsetof(WebCore::ScreenDataOverrides, height)
        , offsetof(WebCore::ScreenDataOverrides, scale)
    >::value);

    encoder << instance.width;
    encoder << instance.height;
    encoder << instance.scale;
}

std::optional<WebCore::ScreenDataOverrides> ArgumentCoder<WebCore::ScreenDataOverrides>::decode(Decoder& decoder)
{
    auto width = decoder.decode<double>();
    auto height = decoder.decode<double>();
    auto scale = decoder.decode<double>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ScreenDataOverrides {
            WTFMove(*width),
            WTFMove(*height),
            WTFMove(*scale)
        }
    };
}

void ArgumentCoder<WebCore::BlobPart>::encode(Encoder& encoder, const WebCore::BlobPart& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_dataOrURL)>, Variant<Vector<uint8_t>, URL>>);
    struct ShouldBeSameSizeAsBlobPart : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::BlobPart>, false> {
        Variant<Vector<uint8_t>, URL> m_dataOrURL;
    };
    static_assert(sizeof(ShouldBeSameSizeAsBlobPart) == sizeof(WebCore::BlobPart));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::BlobPart, m_dataOrURL)
    >::value);

    encoder << instance.m_dataOrURL;
}

std::optional<WebCore::BlobPart> ArgumentCoder<WebCore::BlobPart>::decode(Decoder& decoder)
{
    auto m_dataOrURL = decoder.decode<Variant<Vector<uint8_t>, URL>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::BlobPart {
            WTFMove(*m_dataOrURL)
        }
    };
}

void ArgumentCoder<WebCore::MediaCapabilitiesInfo>::encode(Encoder& encoder, const WebCore::MediaCapabilitiesInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supported)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.smooth)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.powerEfficient)>, bool>);
    struct ShouldBeSameSizeAsMediaCapabilitiesInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MediaCapabilitiesInfo>, false> {
        bool supported;
        bool smooth;
        bool powerEfficient;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMediaCapabilitiesInfo) == sizeof(WebCore::MediaCapabilitiesInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MediaCapabilitiesInfo, supported)
        , offsetof(WebCore::MediaCapabilitiesInfo, smooth)
        , offsetof(WebCore::MediaCapabilitiesInfo, powerEfficient)
    >::value);

    encoder << instance.supported;
    encoder << instance.smooth;
    encoder << instance.powerEfficient;
}

std::optional<WebCore::MediaCapabilitiesInfo> ArgumentCoder<WebCore::MediaCapabilitiesInfo>::decode(Decoder& decoder)
{
    auto supported = decoder.decode<bool>();
    auto smooth = decoder.decode<bool>();
    auto powerEfficient = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MediaCapabilitiesInfo {
            WTFMove(*supported),
            WTFMove(*smooth),
            WTFMove(*powerEfficient)
        }
    };
}

#if ENABLE(MEDIA_STREAM)
void ArgumentCoder<WebCore::MediaStreamRequest>::encode(Encoder& encoder, const WebCore::MediaStreamRequest& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::MediaStreamRequest::Type>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.audioConstraints)>, WebCore::MediaConstraints>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.videoConstraints)>, WebCore::MediaConstraints>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isUserGesturePriviledged)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pageIdentifier)>, Markable<WebCore::PageIdentifier>>);
    struct ShouldBeSameSizeAsMediaStreamRequest : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MediaStreamRequest>, false> {
        WebCore::MediaStreamRequest::Type type;
        WebCore::MediaConstraints audioConstraints;
        WebCore::MediaConstraints videoConstraints;
        bool isUserGesturePriviledged;
        Markable<WebCore::PageIdentifier> pageIdentifier;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMediaStreamRequest) == sizeof(WebCore::MediaStreamRequest));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MediaStreamRequest, type)
        , offsetof(WebCore::MediaStreamRequest, audioConstraints)
        , offsetof(WebCore::MediaStreamRequest, videoConstraints)
        , offsetof(WebCore::MediaStreamRequest, isUserGesturePriviledged)
        , offsetof(WebCore::MediaStreamRequest, pageIdentifier)
    >::value);

    encoder << instance.type;
    encoder << instance.audioConstraints;
    encoder << instance.videoConstraints;
    encoder << instance.isUserGesturePriviledged;
    encoder << instance.pageIdentifier;
}

std::optional<WebCore::MediaStreamRequest> ArgumentCoder<WebCore::MediaStreamRequest>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::MediaStreamRequest::Type>();
    auto audioConstraints = decoder.decode<WebCore::MediaConstraints>();
    auto videoConstraints = decoder.decode<WebCore::MediaConstraints>();
    auto isUserGesturePriviledged = decoder.decode<bool>();
    auto pageIdentifier = decoder.decode<Markable<WebCore::PageIdentifier>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MediaStreamRequest {
            WTFMove(*type),
            WTFMove(*audioConstraints),
            WTFMove(*videoConstraints),
            WTFMove(*isUserGesturePriviledged),
            WTFMove(*pageIdentifier)
        }
    };
}

#endif

#if ENABLE(MEDIA_STREAM)
void ArgumentCoder<WebCore::MediaTrackConstraintSetMap>::encode(Encoder& encoder, const WebCore::MediaTrackConstraintSetMap& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_width)>, std::optional<WebCore::IntConstraint>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_height)>, std::optional<WebCore::IntConstraint>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_sampleRate)>, std::optional<WebCore::IntConstraint>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_sampleSize)>, std::optional<WebCore::IntConstraint>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_aspectRatio)>, std::optional<WebCore::DoubleConstraint>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_frameRate)>, std::optional<WebCore::DoubleConstraint>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_volume)>, std::optional<WebCore::DoubleConstraint>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_echoCancellation)>, std::optional<WebCore::BooleanConstraint>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_displaySurface)>, std::optional<WebCore::BooleanConstraint>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_logicalSurface)>, std::optional<WebCore::BooleanConstraint>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_facingMode)>, std::optional<WebCore::StringConstraint>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_deviceId)>, std::optional<WebCore::StringConstraint>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_groupId)>, std::optional<WebCore::StringConstraint>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_whiteBalanceMode)>, std::optional<WebCore::StringConstraint>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_zoom)>, std::optional<WebCore::DoubleConstraint>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_torch)>, std::optional<WebCore::BooleanConstraint>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_backgroundBlur)>, std::optional<WebCore::BooleanConstraint>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_powerEfficient)>, std::optional<WebCore::BooleanConstraint>>);
    struct ShouldBeSameSizeAsMediaTrackConstraintSetMap : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MediaTrackConstraintSetMap>, false> {
        std::optional<WebCore::IntConstraint> m_width;
        std::optional<WebCore::IntConstraint> m_height;
        std::optional<WebCore::IntConstraint> m_sampleRate;
        std::optional<WebCore::IntConstraint> m_sampleSize;
        std::optional<WebCore::DoubleConstraint> m_aspectRatio;
        std::optional<WebCore::DoubleConstraint> m_frameRate;
        std::optional<WebCore::DoubleConstraint> m_volume;
        std::optional<WebCore::BooleanConstraint> m_echoCancellation;
        std::optional<WebCore::BooleanConstraint> m_displaySurface;
        std::optional<WebCore::BooleanConstraint> m_logicalSurface;
        std::optional<WebCore::StringConstraint> m_facingMode;
        std::optional<WebCore::StringConstraint> m_deviceId;
        std::optional<WebCore::StringConstraint> m_groupId;
        std::optional<WebCore::StringConstraint> m_whiteBalanceMode;
        std::optional<WebCore::DoubleConstraint> m_zoom;
        std::optional<WebCore::BooleanConstraint> m_torch;
        std::optional<WebCore::BooleanConstraint> m_backgroundBlur;
        std::optional<WebCore::BooleanConstraint> m_powerEfficient;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMediaTrackConstraintSetMap) == sizeof(WebCore::MediaTrackConstraintSetMap));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MediaTrackConstraintSetMap, m_width)
        , offsetof(WebCore::MediaTrackConstraintSetMap, m_height)
        , offsetof(WebCore::MediaTrackConstraintSetMap, m_sampleRate)
        , offsetof(WebCore::MediaTrackConstraintSetMap, m_sampleSize)
        , offsetof(WebCore::MediaTrackConstraintSetMap, m_aspectRatio)
        , offsetof(WebCore::MediaTrackConstraintSetMap, m_frameRate)
        , offsetof(WebCore::MediaTrackConstraintSetMap, m_volume)
        , offsetof(WebCore::MediaTrackConstraintSetMap, m_echoCancellation)
        , offsetof(WebCore::MediaTrackConstraintSetMap, m_displaySurface)
        , offsetof(WebCore::MediaTrackConstraintSetMap, m_logicalSurface)
        , offsetof(WebCore::MediaTrackConstraintSetMap, m_facingMode)
        , offsetof(WebCore::MediaTrackConstraintSetMap, m_deviceId)
        , offsetof(WebCore::MediaTrackConstraintSetMap, m_groupId)
        , offsetof(WebCore::MediaTrackConstraintSetMap, m_whiteBalanceMode)
        , offsetof(WebCore::MediaTrackConstraintSetMap, m_zoom)
        , offsetof(WebCore::MediaTrackConstraintSetMap, m_torch)
        , offsetof(WebCore::MediaTrackConstraintSetMap, m_backgroundBlur)
        , offsetof(WebCore::MediaTrackConstraintSetMap, m_powerEfficient)
    >::value);

    encoder << instance.m_width;
    encoder << instance.m_height;
    encoder << instance.m_sampleRate;
    encoder << instance.m_sampleSize;
    encoder << instance.m_aspectRatio;
    encoder << instance.m_frameRate;
    encoder << instance.m_volume;
    encoder << instance.m_echoCancellation;
    encoder << instance.m_displaySurface;
    encoder << instance.m_logicalSurface;
    encoder << instance.m_facingMode;
    encoder << instance.m_deviceId;
    encoder << instance.m_groupId;
    encoder << instance.m_whiteBalanceMode;
    encoder << instance.m_zoom;
    encoder << instance.m_torch;
    encoder << instance.m_backgroundBlur;
    encoder << instance.m_powerEfficient;
}

std::optional<WebCore::MediaTrackConstraintSetMap> ArgumentCoder<WebCore::MediaTrackConstraintSetMap>::decode(Decoder& decoder)
{
    auto m_width = decoder.decode<std::optional<WebCore::IntConstraint>>();
    auto m_height = decoder.decode<std::optional<WebCore::IntConstraint>>();
    auto m_sampleRate = decoder.decode<std::optional<WebCore::IntConstraint>>();
    auto m_sampleSize = decoder.decode<std::optional<WebCore::IntConstraint>>();
    auto m_aspectRatio = decoder.decode<std::optional<WebCore::DoubleConstraint>>();
    auto m_frameRate = decoder.decode<std::optional<WebCore::DoubleConstraint>>();
    auto m_volume = decoder.decode<std::optional<WebCore::DoubleConstraint>>();
    auto m_echoCancellation = decoder.decode<std::optional<WebCore::BooleanConstraint>>();
    auto m_displaySurface = decoder.decode<std::optional<WebCore::BooleanConstraint>>();
    auto m_logicalSurface = decoder.decode<std::optional<WebCore::BooleanConstraint>>();
    auto m_facingMode = decoder.decode<std::optional<WebCore::StringConstraint>>();
    auto m_deviceId = decoder.decode<std::optional<WebCore::StringConstraint>>();
    auto m_groupId = decoder.decode<std::optional<WebCore::StringConstraint>>();
    auto m_whiteBalanceMode = decoder.decode<std::optional<WebCore::StringConstraint>>();
    auto m_zoom = decoder.decode<std::optional<WebCore::DoubleConstraint>>();
    auto m_torch = decoder.decode<std::optional<WebCore::BooleanConstraint>>();
    auto m_backgroundBlur = decoder.decode<std::optional<WebCore::BooleanConstraint>>();
    auto m_powerEfficient = decoder.decode<std::optional<WebCore::BooleanConstraint>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    WebCore::MediaTrackConstraintSetMap result;
    result.m_width = WTFMove(*m_width);
    result.m_height = WTFMove(*m_height);
    result.m_sampleRate = WTFMove(*m_sampleRate);
    result.m_sampleSize = WTFMove(*m_sampleSize);
    result.m_aspectRatio = WTFMove(*m_aspectRatio);
    result.m_frameRate = WTFMove(*m_frameRate);
    result.m_volume = WTFMove(*m_volume);
    result.m_echoCancellation = WTFMove(*m_echoCancellation);
    result.m_displaySurface = WTFMove(*m_displaySurface);
    result.m_logicalSurface = WTFMove(*m_logicalSurface);
    result.m_facingMode = WTFMove(*m_facingMode);
    result.m_deviceId = WTFMove(*m_deviceId);
    result.m_groupId = WTFMove(*m_groupId);
    result.m_whiteBalanceMode = WTFMove(*m_whiteBalanceMode);
    result.m_zoom = WTFMove(*m_zoom);
    result.m_torch = WTFMove(*m_torch);
    result.m_backgroundBlur = WTFMove(*m_backgroundBlur);
    result.m_powerEfficient = WTFMove(*m_powerEfficient);
    return { WTFMove(result) };
}

#endif

#if ! ENABLE(MEDIA_STREAM)
void ArgumentCoder<WebCore::MediaStreamRequest>::encode(Encoder& encoder, const WebCore::MediaStreamRequest& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::MediaStreamRequest::Type>);
    struct ShouldBeSameSizeAsMediaStreamRequest : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MediaStreamRequest>, false> {
        WebCore::MediaStreamRequest::Type type;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMediaStreamRequest) == sizeof(WebCore::MediaStreamRequest));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MediaStreamRequest, type)
    >::value);

    encoder << instance.type;
}

std::optional<WebCore::MediaStreamRequest> ArgumentCoder<WebCore::MediaStreamRequest>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::MediaStreamRequest::Type>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MediaStreamRequest {
            WTFMove(*type)
        }
    };
}

#endif

void ArgumentCoder<WebCore::MediaCapabilitiesDecodingInfo>::encode(Encoder& encoder, const WebCore::MediaCapabilitiesDecodingInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supported)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.smooth)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.powerEfficient)>, bool>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MediaCapabilitiesInfo, supported)
        , offsetof(WebCore::MediaCapabilitiesInfo, smooth)
        , offsetof(WebCore::MediaCapabilitiesInfo, powerEfficient)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.configuration)>, WebCore::MediaDecodingConfiguration>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MediaCapabilitiesDecodingInfo, configuration)
    >::value);

    encoder << instance.supported;
    encoder << instance.smooth;
    encoder << instance.powerEfficient;
    encoder << instance.configuration;
}

std::optional<WebCore::MediaCapabilitiesDecodingInfo> ArgumentCoder<WebCore::MediaCapabilitiesDecodingInfo>::decode(Decoder& decoder)
{
    auto supported = decoder.decode<bool>();
    auto smooth = decoder.decode<bool>();
    auto powerEfficient = decoder.decode<bool>();
    auto configuration = decoder.decode<WebCore::MediaDecodingConfiguration>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MediaCapabilitiesDecodingInfo {
            WebCore::MediaCapabilitiesInfo {
                WTFMove(*supported),
                WTFMove(*smooth),
                WTFMove(*powerEfficient)
            },
            WTFMove(*configuration)
        }
    };
}

void ArgumentCoder<WebCore::MediaCapabilitiesEncodingInfo>::encode(Encoder& encoder, const WebCore::MediaCapabilitiesEncodingInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supported)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.smooth)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.powerEfficient)>, bool>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MediaCapabilitiesInfo, supported)
        , offsetof(WebCore::MediaCapabilitiesInfo, smooth)
        , offsetof(WebCore::MediaCapabilitiesInfo, powerEfficient)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.configuration)>, WebCore::MediaEncodingConfiguration>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MediaCapabilitiesEncodingInfo, configuration)
    >::value);

    encoder << instance.supported;
    encoder << instance.smooth;
    encoder << instance.powerEfficient;
    encoder << instance.configuration;
}

std::optional<WebCore::MediaCapabilitiesEncodingInfo> ArgumentCoder<WebCore::MediaCapabilitiesEncodingInfo>::decode(Decoder& decoder)
{
    auto supported = decoder.decode<bool>();
    auto smooth = decoder.decode<bool>();
    auto powerEfficient = decoder.decode<bool>();
    auto configuration = decoder.decode<WebCore::MediaEncodingConfiguration>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MediaCapabilitiesEncodingInfo {
            WebCore::MediaCapabilitiesInfo {
                WTFMove(*supported),
                WTFMove(*smooth),
                WTFMove(*powerEfficient)
            },
            WTFMove(*configuration)
        }
    };
}

void ArgumentCoder<WebCore::FormDataElement>::encode(Encoder& encoder, const WebCore::FormDataElement& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data)>, Variant<Vector<uint8_t>, WebCore::FormDataElement::EncodedFileData, WebCore::FormDataElement::EncodedBlobData>>);
    struct ShouldBeSameSizeAsFormDataElement : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FormDataElement>, false> {
        Variant<Vector<uint8_t>, WebCore::FormDataElement::EncodedFileData, WebCore::FormDataElement::EncodedBlobData> data;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFormDataElement) == sizeof(WebCore::FormDataElement));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FormDataElement, data)
    >::value);

    encoder << instance.data;
}

std::optional<WebCore::FormDataElement> ArgumentCoder<WebCore::FormDataElement>::decode(Decoder& decoder)
{
    auto data = decoder.decode<Variant<Vector<uint8_t>, WebCore::FormDataElement::EncodedFileData, WebCore::FormDataElement::EncodedBlobData>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FormDataElement {
            WTFMove(*data)
        }
    };
}

void ArgumentCoder<WebCore::FormDataElement::EncodedFileData>::encode(Encoder& encoder, const WebCore::FormDataElement::EncodedFileData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.filename)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fileStart)>, int64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fileLength)>, int64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.expectedFileModificationTime)>, std::optional<WallTime>>);
    struct ShouldBeSameSizeAsEncodedFileData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FormDataElement::EncodedFileData>, false> {
        String filename;
        int64_t fileStart;
        int64_t fileLength;
        std::optional<WallTime> expectedFileModificationTime;
    };
    static_assert(sizeof(ShouldBeSameSizeAsEncodedFileData) == sizeof(WebCore::FormDataElement::EncodedFileData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FormDataElement::EncodedFileData, filename)
        , offsetof(WebCore::FormDataElement::EncodedFileData, fileStart)
        , offsetof(WebCore::FormDataElement::EncodedFileData, fileLength)
        , offsetof(WebCore::FormDataElement::EncodedFileData, expectedFileModificationTime)
    >::value);

    encoder << instance.filename;
    encoder << instance.fileStart;
    encoder << instance.fileLength;
    encoder << instance.expectedFileModificationTime;
}

std::optional<WebCore::FormDataElement::EncodedFileData> ArgumentCoder<WebCore::FormDataElement::EncodedFileData>::decode(Decoder& decoder)
{
    auto filename = decoder.decode<String>();
    auto fileStart = decoder.decode<int64_t>();
    auto fileLength = decoder.decode<int64_t>();
    auto expectedFileModificationTime = decoder.decode<std::optional<WallTime>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FormDataElement::EncodedFileData {
            WTFMove(*filename),
            WTFMove(*fileStart),
            WTFMove(*fileLength),
            WTFMove(*expectedFileModificationTime)
        }
    };
}

void ArgumentCoder<WebCore::FormDataElement::EncodedBlobData>::encode(Encoder& encoder, const WebCore::FormDataElement::EncodedBlobData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url)>, URL>);
    struct ShouldBeSameSizeAsEncodedBlobData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FormDataElement::EncodedBlobData>, false> {
        URL url;
    };
    static_assert(sizeof(ShouldBeSameSizeAsEncodedBlobData) == sizeof(WebCore::FormDataElement::EncodedBlobData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FormDataElement::EncodedBlobData, url)
    >::value);

    encoder << instance.url;
}

std::optional<WebCore::FormDataElement::EncodedBlobData> ArgumentCoder<WebCore::FormDataElement::EncodedBlobData>::decode(Decoder& decoder)
{
    auto url = decoder.decode<URL>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FormDataElement::EncodedBlobData {
            WTFMove(*url)
        }
    };
}

void ArgumentCoder<WebCore::NetworkTransactionInformation>::encode(Encoder& encoder, const WebCore::NetworkTransactionInformation& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::NetworkTransactionInformation::Type>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.request)>, WebCore::ResourceRequest>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.response)>, WebCore::ResourceResponse>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.metrics)>, WebCore::NetworkLoadMetrics>);
    struct ShouldBeSameSizeAsNetworkTransactionInformation : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::NetworkTransactionInformation>, false> {
        WebCore::NetworkTransactionInformation::Type type;
        WebCore::ResourceRequest request;
        WebCore::ResourceResponse response;
        WebCore::NetworkLoadMetrics metrics;
    };
    static_assert(sizeof(ShouldBeSameSizeAsNetworkTransactionInformation) == sizeof(WebCore::NetworkTransactionInformation));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::NetworkTransactionInformation, type)
        , offsetof(WebCore::NetworkTransactionInformation, request)
        , offsetof(WebCore::NetworkTransactionInformation, response)
        , offsetof(WebCore::NetworkTransactionInformation, metrics)
    >::value);

    encoder << instance.type;
    encoder << instance.request;
    encoder << instance.response;
    encoder << instance.metrics;
}

std::optional<WebCore::NetworkTransactionInformation> ArgumentCoder<WebCore::NetworkTransactionInformation>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::NetworkTransactionInformation::Type>();
    auto request = decoder.decode<WebCore::ResourceRequest>();
    auto response = decoder.decode<WebCore::ResourceResponse>();
    auto metrics = decoder.decode<WebCore::NetworkLoadMetrics>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::NetworkTransactionInformation {
            WTFMove(*type),
            WTFMove(*request),
            WTFMove(*response),
            WTFMove(*metrics)
        }
    };
}

void ArgumentCoder<WebCore::ContentType>::encode(Encoder& encoder, const WebCore::ContentType& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.raw())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.typeWasInferredFromExtension())>, bool>);

    encoder << instance.raw();
    encoder << instance.typeWasInferredFromExtension();
}

std::optional<WebCore::ContentType> ArgumentCoder<WebCore::ContentType>::decode(Decoder& decoder)
{
    auto raw = decoder.decode<String>();
    auto typeWasInferredFromExtension = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ContentType {
            WTFMove(*raw),
            WTFMove(*typeWasInferredFromExtension)
        }
    };
}

void ArgumentCoder<WebCore::DateTimeChooserParameters>::encode(Encoder& encoder, const WebCore::DateTimeChooserParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, AtomString>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.anchorRectInRootView)>, WebCore::IntRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.locale)>, AtomString>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.currentValue)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.suggestionValues)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.localizedSuggestionValues)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.suggestionLabels)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.minimum)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maximum)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.step)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stepBase)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.required)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isAnchorElementRTL)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.useDarkAppearance)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasSecondField)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasMillisecondField)>, bool>);
    struct ShouldBeSameSizeAsDateTimeChooserParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::DateTimeChooserParameters>, false> {
        AtomString type;
        WebCore::IntRect anchorRectInRootView;
        AtomString locale;
        String currentValue;
        Vector<String> suggestionValues;
        Vector<String> localizedSuggestionValues;
        Vector<String> suggestionLabels;
        double minimum;
        double maximum;
        double step;
        double stepBase;
        bool required;
        bool isAnchorElementRTL;
        bool useDarkAppearance;
        bool hasSecondField;
        bool hasMillisecondField;
    };
    static_assert(sizeof(ShouldBeSameSizeAsDateTimeChooserParameters) == sizeof(WebCore::DateTimeChooserParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::DateTimeChooserParameters, type)
        , offsetof(WebCore::DateTimeChooserParameters, anchorRectInRootView)
        , offsetof(WebCore::DateTimeChooserParameters, locale)
        , offsetof(WebCore::DateTimeChooserParameters, currentValue)
        , offsetof(WebCore::DateTimeChooserParameters, suggestionValues)
        , offsetof(WebCore::DateTimeChooserParameters, localizedSuggestionValues)
        , offsetof(WebCore::DateTimeChooserParameters, suggestionLabels)
        , offsetof(WebCore::DateTimeChooserParameters, minimum)
        , offsetof(WebCore::DateTimeChooserParameters, maximum)
        , offsetof(WebCore::DateTimeChooserParameters, step)
        , offsetof(WebCore::DateTimeChooserParameters, stepBase)
        , offsetof(WebCore::DateTimeChooserParameters, required)
        , offsetof(WebCore::DateTimeChooserParameters, isAnchorElementRTL)
        , offsetof(WebCore::DateTimeChooserParameters, useDarkAppearance)
        , offsetof(WebCore::DateTimeChooserParameters, hasSecondField)
        , offsetof(WebCore::DateTimeChooserParameters, hasMillisecondField)
    >::value);

    encoder << instance.type;
    encoder << instance.anchorRectInRootView;
    encoder << instance.locale;
    encoder << instance.currentValue;
    encoder << instance.suggestionValues;
    encoder << instance.localizedSuggestionValues;
    encoder << instance.suggestionLabels;
    encoder << instance.minimum;
    encoder << instance.maximum;
    encoder << instance.step;
    encoder << instance.stepBase;
    encoder << instance.required;
    encoder << instance.isAnchorElementRTL;
    encoder << instance.useDarkAppearance;
    encoder << instance.hasSecondField;
    encoder << instance.hasMillisecondField;
}

std::optional<WebCore::DateTimeChooserParameters> ArgumentCoder<WebCore::DateTimeChooserParameters>::decode(Decoder& decoder)
{
    auto type = decoder.decode<AtomString>();
    auto anchorRectInRootView = decoder.decode<WebCore::IntRect>();
    auto locale = decoder.decode<AtomString>();
    auto currentValue = decoder.decode<String>();
    auto suggestionValues = decoder.decode<Vector<String>>();
    auto localizedSuggestionValues = decoder.decode<Vector<String>>();
    auto suggestionLabels = decoder.decode<Vector<String>>();
    auto minimum = decoder.decode<double>();
    auto maximum = decoder.decode<double>();
    auto step = decoder.decode<double>();
    auto stepBase = decoder.decode<double>();
    auto required = decoder.decode<bool>();
    auto isAnchorElementRTL = decoder.decode<bool>();
    auto useDarkAppearance = decoder.decode<bool>();
    auto hasSecondField = decoder.decode<bool>();
    auto hasMillisecondField = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DateTimeChooserParameters {
            WTFMove(*type),
            WTFMove(*anchorRectInRootView),
            WTFMove(*locale),
            WTFMove(*currentValue),
            WTFMove(*suggestionValues),
            WTFMove(*localizedSuggestionValues),
            WTFMove(*suggestionLabels),
            WTFMove(*minimum),
            WTFMove(*maximum),
            WTFMove(*step),
            WTFMove(*stepBase),
            WTFMove(*required),
            WTFMove(*isAnchorElementRTL),
            WTFMove(*useDarkAppearance),
            WTFMove(*hasSecondField),
            WTFMove(*hasMillisecondField)
        }
    };
}

void ArgumentCoder<WebCore::ScreenData>::encode(Encoder& encoder, const WebCore::ScreenData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.screenAvailableRect)>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.screenRect)>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorSpace)>, WebCore::DestinationColorSpace>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.screenDepth)>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.screenDepthPerComponent)>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.screenSupportsExtendedColor)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.screenHasInvertedColors)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.screenSupportsHighDynamicRange)>, bool>);
#if HAVE(SUPPORT_HDR_DISPLAY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.suppressEDR)>, bool>);
#endif
#if HAVE(SUPPORT_HDR_DISPLAY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.currentEDRHeadroom)>, float>);
#endif
#if HAVE(SUPPORT_HDR_DISPLAY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxEDRHeadroom)>, float>);
#endif
#if PLATFORM(MAC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.screenSize)>, WebCore::FloatSize>);
#endif
#if PLATFORM(MAC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.screenIsMonochrome)>, bool>);
#endif
#if PLATFORM(MAC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.displayMask)>, uint32_t>);
#endif
#if PLATFORM(MAC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.gpuID)>, WebCore::PlatformGPUID>);
#endif
#if PLATFORM(MAC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.preferredDynamicRangeMode)>, WebCore::DynamicRangeMode>);
#endif
#if PLATFORM(GTK) || (PLATFORM(WPE) && ENABLE(WPE_PLATFORM))
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.screenSize)>, WebCore::IntSize>);
#endif
#if PLATFORM(GTK) || (PLATFORM(WPE) && ENABLE(WPE_PLATFORM))
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dpi)>, double>);
#endif
#if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scaleFactor)>, float>);
#endif
    struct ShouldBeSameSizeAsScreenData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ScreenData>, false> {
        WebCore::FloatRect screenAvailableRect;
        WebCore::FloatRect screenRect;
        WebCore::DestinationColorSpace colorSpace;
        int screenDepth;
        int screenDepthPerComponent;
        bool screenSupportsExtendedColor;
        bool screenHasInvertedColors;
        bool screenSupportsHighDynamicRange;
#if HAVE(SUPPORT_HDR_DISPLAY)
        bool suppressEDR;
#endif
#if HAVE(SUPPORT_HDR_DISPLAY)
        float currentEDRHeadroom;
#endif
#if HAVE(SUPPORT_HDR_DISPLAY)
        float maxEDRHeadroom;
#endif
#if PLATFORM(MAC)
        WebCore::FloatSize screenSize;
#endif
#if PLATFORM(MAC)
        bool screenIsMonochrome;
#endif
#if PLATFORM(MAC)
        uint32_t displayMask;
#endif
#if PLATFORM(MAC)
        WebCore::PlatformGPUID gpuID;
#endif
#if PLATFORM(MAC)
        WebCore::DynamicRangeMode preferredDynamicRangeMode;
#endif
#if PLATFORM(GTK) || (PLATFORM(WPE) && ENABLE(WPE_PLATFORM))
        WebCore::IntSize screenSize;
#endif
#if PLATFORM(GTK) || (PLATFORM(WPE) && ENABLE(WPE_PLATFORM))
        double dpi;
#endif
#if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)
        float scaleFactor;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsScreenData) == sizeof(WebCore::ScreenData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ScreenData, screenAvailableRect)
        , offsetof(WebCore::ScreenData, screenRect)
        , offsetof(WebCore::ScreenData, colorSpace)
        , offsetof(WebCore::ScreenData, screenDepth)
        , offsetof(WebCore::ScreenData, screenDepthPerComponent)
        , offsetof(WebCore::ScreenData, screenSupportsExtendedColor)
        , offsetof(WebCore::ScreenData, screenHasInvertedColors)
        , offsetof(WebCore::ScreenData, screenSupportsHighDynamicRange)
#if HAVE(SUPPORT_HDR_DISPLAY)
        , offsetof(WebCore::ScreenData, suppressEDR)
#endif
#if HAVE(SUPPORT_HDR_DISPLAY)
        , offsetof(WebCore::ScreenData, currentEDRHeadroom)
#endif
#if HAVE(SUPPORT_HDR_DISPLAY)
        , offsetof(WebCore::ScreenData, maxEDRHeadroom)
#endif
#if PLATFORM(MAC)
        , offsetof(WebCore::ScreenData, screenSize)
#endif
#if PLATFORM(MAC)
        , offsetof(WebCore::ScreenData, screenIsMonochrome)
#endif
#if PLATFORM(MAC)
        , offsetof(WebCore::ScreenData, displayMask)
#endif
#if PLATFORM(MAC)
        , offsetof(WebCore::ScreenData, gpuID)
#endif
#if PLATFORM(MAC)
        , offsetof(WebCore::ScreenData, preferredDynamicRangeMode)
#endif
#if PLATFORM(GTK) || (PLATFORM(WPE) && ENABLE(WPE_PLATFORM))
        , offsetof(WebCore::ScreenData, screenSize)
#endif
#if PLATFORM(GTK) || (PLATFORM(WPE) && ENABLE(WPE_PLATFORM))
        , offsetof(WebCore::ScreenData, dpi)
#endif
#if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)
        , offsetof(WebCore::ScreenData, scaleFactor)
#endif
    >::value);

    encoder << instance.screenAvailableRect;
    encoder << instance.screenRect;
    encoder << instance.colorSpace;
    encoder << instance.screenDepth;
    encoder << instance.screenDepthPerComponent;
    encoder << instance.screenSupportsExtendedColor;
    encoder << instance.screenHasInvertedColors;
    encoder << instance.screenSupportsHighDynamicRange;
#if HAVE(SUPPORT_HDR_DISPLAY)
    encoder << instance.suppressEDR;
#endif
#if HAVE(SUPPORT_HDR_DISPLAY)
    encoder << instance.currentEDRHeadroom;
#endif
#if HAVE(SUPPORT_HDR_DISPLAY)
    encoder << instance.maxEDRHeadroom;
#endif
#if PLATFORM(MAC)
    encoder << instance.screenSize;
#endif
#if PLATFORM(MAC)
    encoder << instance.screenIsMonochrome;
#endif
#if PLATFORM(MAC)
    encoder << instance.displayMask;
#endif
#if PLATFORM(MAC)
    encoder << instance.gpuID;
#endif
#if PLATFORM(MAC)
    encoder << instance.preferredDynamicRangeMode;
#endif
#if PLATFORM(GTK) || (PLATFORM(WPE) && ENABLE(WPE_PLATFORM))
    encoder << instance.screenSize;
#endif
#if PLATFORM(GTK) || (PLATFORM(WPE) && ENABLE(WPE_PLATFORM))
    encoder << instance.dpi;
#endif
#if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)
    encoder << instance.scaleFactor;
#endif
}

std::optional<WebCore::ScreenData> ArgumentCoder<WebCore::ScreenData>::decode(Decoder& decoder)
{
    auto screenAvailableRect = decoder.decode<WebCore::FloatRect>();
    auto screenRect = decoder.decode<WebCore::FloatRect>();
    auto colorSpace = decoder.decode<WebCore::DestinationColorSpace>();
    auto screenDepth = decoder.decode<int>();
    auto screenDepthPerComponent = decoder.decode<int>();
    auto screenSupportsExtendedColor = decoder.decode<bool>();
    auto screenHasInvertedColors = decoder.decode<bool>();
    auto screenSupportsHighDynamicRange = decoder.decode<bool>();
#if HAVE(SUPPORT_HDR_DISPLAY)
    auto suppressEDR = decoder.decode<bool>();
#endif
#if HAVE(SUPPORT_HDR_DISPLAY)
    auto currentEDRHeadroom = decoder.decode<float>();
#endif
#if HAVE(SUPPORT_HDR_DISPLAY)
    auto maxEDRHeadroom = decoder.decode<float>();
#endif
#if PLATFORM(MAC)
    auto screenSize = decoder.decode<WebCore::FloatSize>();
#endif
#if PLATFORM(MAC)
    auto screenIsMonochrome = decoder.decode<bool>();
#endif
#if PLATFORM(MAC)
    auto displayMask = decoder.decode<uint32_t>();
#endif
#if PLATFORM(MAC)
    auto gpuID = decoder.decode<WebCore::PlatformGPUID>();
#endif
#if PLATFORM(MAC)
    auto preferredDynamicRangeMode = decoder.decode<WebCore::DynamicRangeMode>();
#endif
#if PLATFORM(GTK) || (PLATFORM(WPE) && ENABLE(WPE_PLATFORM))
    auto screenSize = decoder.decode<WebCore::IntSize>();
#endif
#if PLATFORM(GTK) || (PLATFORM(WPE) && ENABLE(WPE_PLATFORM))
    auto dpi = decoder.decode<double>();
#endif
#if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)
    auto scaleFactor = decoder.decode<float>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ScreenData {
            WTFMove(*screenAvailableRect),
            WTFMove(*screenRect),
            WTFMove(*colorSpace),
            WTFMove(*screenDepth),
            WTFMove(*screenDepthPerComponent),
            WTFMove(*screenSupportsExtendedColor),
            WTFMove(*screenHasInvertedColors),
            WTFMove(*screenSupportsHighDynamicRange),
#if HAVE(SUPPORT_HDR_DISPLAY)
            WTFMove(*suppressEDR),
#endif
#if HAVE(SUPPORT_HDR_DISPLAY)
            WTFMove(*currentEDRHeadroom),
#endif
#if HAVE(SUPPORT_HDR_DISPLAY)
            WTFMove(*maxEDRHeadroom),
#endif
#if PLATFORM(MAC)
            WTFMove(*screenSize),
#endif
#if PLATFORM(MAC)
            WTFMove(*screenIsMonochrome),
#endif
#if PLATFORM(MAC)
            WTFMove(*displayMask),
#endif
#if PLATFORM(MAC)
            WTFMove(*gpuID),
#endif
#if PLATFORM(MAC)
            WTFMove(*preferredDynamicRangeMode),
#endif
#if PLATFORM(GTK) || (PLATFORM(WPE) && ENABLE(WPE_PLATFORM))
            WTFMove(*screenSize),
#endif
#if PLATFORM(GTK) || (PLATFORM(WPE) && ENABLE(WPE_PLATFORM))
            WTFMove(*dpi),
#endif
#if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)
            WTFMove(*scaleFactor)
#endif
        }
    };
}

void ArgumentCoder<WebCore::ScreenProperties>::encode(Encoder& encoder, const WebCore::ScreenProperties& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.primaryDisplayID)>, WebCore::PlatformDisplayID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.screenDataMap)>, HashMap<WebCore::PlatformDisplayID, WebCore::ScreenData>>);
#if HAVE(SUPPORT_HDR_DISPLAY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.screenContentsFormatsForTesting)>, OptionSet<WebCore::ContentsFormat>>);
#endif
#if ENABLE(TOUCH_EVENTS) && PLATFORM(GTK)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.screenHasTouchDevice)>, bool>);
#endif
    struct ShouldBeSameSizeAsScreenProperties : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ScreenProperties>, false> {
        WebCore::PlatformDisplayID primaryDisplayID;
        HashMap<WebCore::PlatformDisplayID, WebCore::ScreenData> screenDataMap;
#if HAVE(SUPPORT_HDR_DISPLAY)
        OptionSet<WebCore::ContentsFormat> screenContentsFormatsForTesting;
#endif
#if ENABLE(TOUCH_EVENTS) && PLATFORM(GTK)
        bool screenHasTouchDevice;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsScreenProperties) == sizeof(WebCore::ScreenProperties));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ScreenProperties, primaryDisplayID)
        , offsetof(WebCore::ScreenProperties, screenDataMap)
#if HAVE(SUPPORT_HDR_DISPLAY)
        , offsetof(WebCore::ScreenProperties, screenContentsFormatsForTesting)
#endif
#if ENABLE(TOUCH_EVENTS) && PLATFORM(GTK)
        , offsetof(WebCore::ScreenProperties, screenHasTouchDevice)
#endif
    >::value);

    encoder << instance.primaryDisplayID;
    encoder << instance.screenDataMap;
#if HAVE(SUPPORT_HDR_DISPLAY)
    encoder << instance.screenContentsFormatsForTesting;
#endif
#if ENABLE(TOUCH_EVENTS) && PLATFORM(GTK)
    encoder << instance.screenHasTouchDevice;
#endif
}

std::optional<WebCore::ScreenProperties> ArgumentCoder<WebCore::ScreenProperties>::decode(Decoder& decoder)
{
    auto primaryDisplayID = decoder.decode<WebCore::PlatformDisplayID>();
    auto screenDataMap = decoder.decode<HashMap<WebCore::PlatformDisplayID, WebCore::ScreenData>>();
#if HAVE(SUPPORT_HDR_DISPLAY)
    auto screenContentsFormatsForTesting = decoder.decode<OptionSet<WebCore::ContentsFormat>>();
#endif
#if ENABLE(TOUCH_EVENTS) && PLATFORM(GTK)
    auto screenHasTouchDevice = decoder.decode<bool>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ScreenProperties {
            WTFMove(*primaryDisplayID),
            WTFMove(*screenDataMap),
#if HAVE(SUPPORT_HDR_DISPLAY)
            WTFMove(*screenContentsFormatsForTesting),
#endif
#if ENABLE(TOUCH_EVENTS) && PLATFORM(GTK)
            WTFMove(*screenHasTouchDevice)
#endif
        }
    };
}

void ArgumentCoder<WebCore::PlatformTimeRanges>::encode(Encoder& encoder, const WebCore::PlatformTimeRanges& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_ranges)>, Vector<WebCore::PlatformTimeRanges::Range>>);
    struct ShouldBeSameSizeAsPlatformTimeRanges : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PlatformTimeRanges>, false> {
        Vector<WebCore::PlatformTimeRanges::Range> m_ranges;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPlatformTimeRanges) == sizeof(WebCore::PlatformTimeRanges));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PlatformTimeRanges, m_ranges)
    >::value);

    encoder << instance.m_ranges;
}

std::optional<WebCore::PlatformTimeRanges> ArgumentCoder<WebCore::PlatformTimeRanges>::decode(Decoder& decoder)
{
    auto m_ranges = decoder.decode<Vector<WebCore::PlatformTimeRanges::Range>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PlatformTimeRanges {
            WTFMove(*m_ranges)
        }
    };
}

void ArgumentCoder<WebCore::PlatformTimeRanges::Range>::encode(Encoder& encoder, const WebCore::PlatformTimeRanges::Range& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.start)>, MediaTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.end)>, MediaTime>);
    struct ShouldBeSameSizeAsRange : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PlatformTimeRanges::Range>, false> {
        MediaTime start;
        MediaTime end;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRange) == sizeof(WebCore::PlatformTimeRanges::Range));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PlatformTimeRanges::Range, start)
        , offsetof(WebCore::PlatformTimeRanges::Range, end)
    >::value);

    encoder << instance.start;
    encoder << instance.end;
}

std::optional<WebCore::PlatformTimeRanges::Range> ArgumentCoder<WebCore::PlatformTimeRanges::Range>::decode(Decoder& decoder)
{
    auto start = decoder.decode<MediaTime>();
    auto end = decoder.decode<MediaTime>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PlatformTimeRanges::Range {
            WTFMove(*start),
            WTFMove(*end)
        }
    };
}

#if ENABLE(VIDEO)
void ArgumentCoder<WebCore::VideoPlaybackQualityMetrics>::encode(Encoder& encoder, const WebCore::VideoPlaybackQualityMetrics& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.totalVideoFrames)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.droppedVideoFrames)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.corruptedVideoFrames)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.totalFrameDelay)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.displayCompositedVideoFrames)>, uint32_t>);
    struct ShouldBeSameSizeAsVideoPlaybackQualityMetrics : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::VideoPlaybackQualityMetrics>, false> {
        uint32_t totalVideoFrames;
        uint32_t droppedVideoFrames;
        uint32_t corruptedVideoFrames;
        double totalFrameDelay;
        uint32_t displayCompositedVideoFrames;
    };
    static_assert(sizeof(ShouldBeSameSizeAsVideoPlaybackQualityMetrics) == sizeof(WebCore::VideoPlaybackQualityMetrics));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::VideoPlaybackQualityMetrics, totalVideoFrames)
        , offsetof(WebCore::VideoPlaybackQualityMetrics, droppedVideoFrames)
        , offsetof(WebCore::VideoPlaybackQualityMetrics, corruptedVideoFrames)
        , offsetof(WebCore::VideoPlaybackQualityMetrics, totalFrameDelay)
        , offsetof(WebCore::VideoPlaybackQualityMetrics, displayCompositedVideoFrames)
    >::value);

    encoder << instance.totalVideoFrames;
    encoder << instance.droppedVideoFrames;
    encoder << instance.corruptedVideoFrames;
    encoder << instance.totalFrameDelay;
    encoder << instance.displayCompositedVideoFrames;
}

std::optional<WebCore::VideoPlaybackQualityMetrics> ArgumentCoder<WebCore::VideoPlaybackQualityMetrics>::decode(Decoder& decoder)
{
    auto totalVideoFrames = decoder.decode<uint32_t>();
    auto droppedVideoFrames = decoder.decode<uint32_t>();
    auto corruptedVideoFrames = decoder.decode<uint32_t>();
    auto totalFrameDelay = decoder.decode<double>();
    auto displayCompositedVideoFrames = decoder.decode<uint32_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::VideoPlaybackQualityMetrics {
            WTFMove(*totalVideoFrames),
            WTFMove(*droppedVideoFrames),
            WTFMove(*corruptedVideoFrames),
            WTFMove(*totalFrameDelay),
            WTFMove(*displayCompositedVideoFrames)
        }
    };
}

#endif

#if PLATFORM(IOS_FAMILY)
void ArgumentCoder<WebCore::SelectionGeometry>::encode(Encoder& encoder, const WebCore::SelectionGeometry& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.quad())>, WebCore::FloatQuad>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.behavior())>, WebCore::SelectionRenderingBehavior>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.direction())>, WebCore::TextDirection>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.minX())>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxX())>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxY())>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lineNumber())>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isLineBreak())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isFirstOnLine())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isLastOnLine())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.containsStart())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.containsEnd())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isHorizontal())>, bool>);

    encoder << instance.quad();
    encoder << instance.behavior();
    encoder << instance.direction();
    encoder << instance.minX();
    encoder << instance.maxX();
    encoder << instance.maxY();
    encoder << instance.lineNumber();
    encoder << instance.isLineBreak();
    encoder << instance.isFirstOnLine();
    encoder << instance.isLastOnLine();
    encoder << instance.containsStart();
    encoder << instance.containsEnd();
    encoder << instance.isHorizontal();
}

std::optional<WebCore::SelectionGeometry> ArgumentCoder<WebCore::SelectionGeometry>::decode(Decoder& decoder)
{
    auto quad = decoder.decode<WebCore::FloatQuad>();
    auto behavior = decoder.decode<WebCore::SelectionRenderingBehavior>();
    auto direction = decoder.decode<WebCore::TextDirection>();
    auto minX = decoder.decode<int>();
    auto maxX = decoder.decode<int>();
    auto maxY = decoder.decode<int>();
    auto lineNumber = decoder.decode<int>();
    auto isLineBreak = decoder.decode<bool>();
    auto isFirstOnLine = decoder.decode<bool>();
    auto isLastOnLine = decoder.decode<bool>();
    auto containsStart = decoder.decode<bool>();
    auto containsEnd = decoder.decode<bool>();
    auto isHorizontal = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SelectionGeometry {
            WTFMove(*quad),
            WTFMove(*behavior),
            WTFMove(*direction),
            WTFMove(*minX),
            WTFMove(*maxX),
            WTFMove(*maxY),
            WTFMove(*lineNumber),
            WTFMove(*isLineBreak),
            WTFMove(*isFirstOnLine),
            WTFMove(*isLastOnLine),
            WTFMove(*containsStart),
            WTFMove(*containsEnd),
            WTFMove(*isHorizontal)
        }
    };
}

#endif

void ArgumentCoder<WebCore::DataListSuggestion>::encode(Encoder& encoder, const WebCore::DataListSuggestion& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    struct ShouldBeSameSizeAsDataListSuggestion : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::DataListSuggestion>, false> {
        String value;
        String label;
    };
    static_assert(sizeof(ShouldBeSameSizeAsDataListSuggestion) == sizeof(WebCore::DataListSuggestion));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::DataListSuggestion, value)
        , offsetof(WebCore::DataListSuggestion, label)
    >::value);

    encoder << instance.value;
    encoder << instance.label;
}

std::optional<WebCore::DataListSuggestion> ArgumentCoder<WebCore::DataListSuggestion>::decode(Decoder& decoder)
{
    auto value = decoder.decode<String>();
    auto label = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DataListSuggestion {
            WTFMove(*value),
            WTFMove(*label)
        }
    };
}

void ArgumentCoder<WebCore::DataListSuggestionInformation>::encode(Encoder& encoder, const WebCore::DataListSuggestionInformation& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.activationType)>, WebCore::DataListSuggestionActivationType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.suggestions)>, Vector<WebCore::DataListSuggestion>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.elementRect)>, WebCore::IntRect>);
    struct ShouldBeSameSizeAsDataListSuggestionInformation : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::DataListSuggestionInformation>, false> {
        WebCore::DataListSuggestionActivationType activationType;
        Vector<WebCore::DataListSuggestion> suggestions;
        WebCore::IntRect elementRect;
    };
    static_assert(sizeof(ShouldBeSameSizeAsDataListSuggestionInformation) == sizeof(WebCore::DataListSuggestionInformation));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::DataListSuggestionInformation, activationType)
        , offsetof(WebCore::DataListSuggestionInformation, suggestions)
        , offsetof(WebCore::DataListSuggestionInformation, elementRect)
    >::value);

    encoder << instance.activationType;
    encoder << instance.suggestions;
    encoder << instance.elementRect;
}

std::optional<WebCore::DataListSuggestionInformation> ArgumentCoder<WebCore::DataListSuggestionInformation>::decode(Decoder& decoder)
{
    auto activationType = decoder.decode<WebCore::DataListSuggestionActivationType>();
    auto suggestions = decoder.decode<Vector<WebCore::DataListSuggestion>>();
    auto elementRect = decoder.decode<WebCore::IntRect>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DataListSuggestionInformation {
            WTFMove(*activationType),
            WTFMove(*suggestions),
            WTFMove(*elementRect)
        }
    };
}

void ArgumentCoder<WebCore::ClientOrigin>::encode(Encoder& encoder, const WebCore::ClientOrigin& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.topOrigin)>, WebCore::SecurityOriginData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.clientOrigin)>, WebCore::SecurityOriginData>);
    struct ShouldBeSameSizeAsClientOrigin : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ClientOrigin>, false> {
        WebCore::SecurityOriginData topOrigin;
        WebCore::SecurityOriginData clientOrigin;
    };
    static_assert(sizeof(ShouldBeSameSizeAsClientOrigin) == sizeof(WebCore::ClientOrigin));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ClientOrigin, topOrigin)
        , offsetof(WebCore::ClientOrigin, clientOrigin)
    >::value);

    encoder << instance.topOrigin;
    encoder << instance.clientOrigin;
}

std::optional<WebCore::ClientOrigin> ArgumentCoder<WebCore::ClientOrigin>::decode(Decoder& decoder)
{
    auto topOrigin = decoder.decode<WebCore::SecurityOriginData>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(!topOrigin->isNull()))
        return std::nullopt;
    auto clientOrigin = decoder.decode<WebCore::SecurityOriginData>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(!clientOrigin->isNull()))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ClientOrigin {
            WTFMove(*topOrigin),
            WTFMove(*clientOrigin)
        }
    };
}

void ArgumentCoder<WebCore::ImageBufferFormat>::encode(Encoder& encoder, const WebCore::ImageBufferFormat& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pixelFormat)>, WebCore::ImageBufferPixelFormat>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.useLosslessCompression)>, WebCore::UseLosslessCompression>);
    struct ShouldBeSameSizeAsImageBufferFormat : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ImageBufferFormat>, false> {
        WebCore::ImageBufferPixelFormat pixelFormat;
        WebCore::UseLosslessCompression useLosslessCompression;
    };
    static_assert(sizeof(ShouldBeSameSizeAsImageBufferFormat) == sizeof(WebCore::ImageBufferFormat));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ImageBufferFormat, pixelFormat)
        , offsetof(WebCore::ImageBufferFormat, useLosslessCompression)
    >::value);

    encoder << instance.pixelFormat;
    encoder << instance.useLosslessCompression;
}

void ArgumentCoder<WebCore::ImageBufferFormat>::encode(StreamConnectionEncoder& encoder, const WebCore::ImageBufferFormat& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pixelFormat)>, WebCore::ImageBufferPixelFormat>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.useLosslessCompression)>, WebCore::UseLosslessCompression>);
    struct ShouldBeSameSizeAsImageBufferFormat : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ImageBufferFormat>, false> {
        WebCore::ImageBufferPixelFormat pixelFormat;
        WebCore::UseLosslessCompression useLosslessCompression;
    };
    static_assert(sizeof(ShouldBeSameSizeAsImageBufferFormat) == sizeof(WebCore::ImageBufferFormat));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ImageBufferFormat, pixelFormat)
        , offsetof(WebCore::ImageBufferFormat, useLosslessCompression)
    >::value);

    encoder << instance.pixelFormat;
    encoder << instance.useLosslessCompression;
}

std::optional<WebCore::ImageBufferFormat> ArgumentCoder<WebCore::ImageBufferFormat>::decode(Decoder& decoder)
{
    auto pixelFormat = decoder.decode<WebCore::ImageBufferPixelFormat>();
    auto useLosslessCompression = decoder.decode<WebCore::UseLosslessCompression>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ImageBufferFormat {
            WTFMove(*pixelFormat),
            WTFMove(*useLosslessCompression)
        }
    };
}

void ArgumentCoder<WebCore::PixelBufferFormat>::encode(Encoder& encoder, const WebCore::PixelBufferFormat& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.alphaFormat)>, WebCore::AlphaPremultiplication>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pixelFormat)>, WebCore::PixelFormat>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorSpace)>, WebCore::DestinationColorSpace>);
    struct ShouldBeSameSizeAsPixelBufferFormat : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PixelBufferFormat>, false> {
        WebCore::AlphaPremultiplication alphaFormat;
        WebCore::PixelFormat pixelFormat;
        WebCore::DestinationColorSpace colorSpace;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPixelBufferFormat) == sizeof(WebCore::PixelBufferFormat));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PixelBufferFormat, alphaFormat)
        , offsetof(WebCore::PixelBufferFormat, pixelFormat)
        , offsetof(WebCore::PixelBufferFormat, colorSpace)
    >::value);

    encoder << instance.alphaFormat;
    encoder << instance.pixelFormat;
    encoder << instance.colorSpace;
}

void ArgumentCoder<WebCore::PixelBufferFormat>::encode(StreamConnectionEncoder& encoder, const WebCore::PixelBufferFormat& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.alphaFormat)>, WebCore::AlphaPremultiplication>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pixelFormat)>, WebCore::PixelFormat>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorSpace)>, WebCore::DestinationColorSpace>);
    struct ShouldBeSameSizeAsPixelBufferFormat : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PixelBufferFormat>, false> {
        WebCore::AlphaPremultiplication alphaFormat;
        WebCore::PixelFormat pixelFormat;
        WebCore::DestinationColorSpace colorSpace;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPixelBufferFormat) == sizeof(WebCore::PixelBufferFormat));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PixelBufferFormat, alphaFormat)
        , offsetof(WebCore::PixelBufferFormat, pixelFormat)
        , offsetof(WebCore::PixelBufferFormat, colorSpace)
    >::value);

    encoder << instance.alphaFormat;
    encoder << instance.pixelFormat;
    encoder << instance.colorSpace;
}

std::optional<WebCore::PixelBufferFormat> ArgumentCoder<WebCore::PixelBufferFormat>::decode(Decoder& decoder)
{
    auto alphaFormat = decoder.decode<WebCore::AlphaPremultiplication>();
    auto pixelFormat = decoder.decode<WebCore::PixelFormat>();
    auto colorSpace = decoder.decode<WebCore::DestinationColorSpace>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PixelBufferFormat {
            WTFMove(*alphaFormat),
            WTFMove(*pixelFormat),
            WTFMove(*colorSpace)
        }
    };
}

void ArgumentCoder<WebCore::TextIndicator>::encode(Encoder& encoder, const WebCore::TextIndicator& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data())>, WebCore::TextIndicatorData>);

    encoder << instance.data();
}

std::optional<Ref<WebCore::TextIndicator>> ArgumentCoder<WebCore::TextIndicator>::decode(Decoder& decoder)
{
    auto data = decoder.decode<WebCore::TextIndicatorData>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TextIndicator::create(
            WTFMove(*data)
        )
    };
}

void ArgumentCoder<WebCore::CertificateInfo>::encode(Encoder& encoder, const WebCore::CertificateInfo& instance)
{
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.trust())>, RetainPtr<SecTrustRef>>);
#endif
#if USE(CURL)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.verificationError())>, int>);
#endif
#if USE(CURL)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.certificateChain())>, Vector<Vector<uint8_t>>>);
#endif
#if USE(SOUP)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.certificate())>, GRefPtr<GTlsCertificate>>);
#endif
#if USE(SOUP)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tlsErrors())>, GTlsCertificateFlags>);
#endif

#if PLATFORM(COCOA)
    encoder << instance.trust();
#endif
#if USE(CURL)
    encoder << instance.verificationError();
#endif
#if USE(CURL)
    encoder << instance.certificateChain();
#endif
#if USE(SOUP)
    encoder << instance.certificate();
#endif
#if USE(SOUP)
    encoder << instance.tlsErrors();
#endif
}

std::optional<WebCore::CertificateInfo> ArgumentCoder<WebCore::CertificateInfo>::decode(Decoder& decoder)
{
#if PLATFORM(COCOA)
    auto trust = decoder.decode<RetainPtr<SecTrustRef>>();
#endif
#if USE(CURL)
    auto verificationError = decoder.decode<int>();
#endif
#if USE(CURL)
    auto certificateChain = decoder.decode<Vector<Vector<uint8_t>>>();
#endif
#if USE(SOUP)
    auto certificate = decoder.decode<GRefPtr<GTlsCertificate>>();
#endif
#if USE(SOUP)
    auto tlsErrors = decoder.decode<GTlsCertificateFlags>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CertificateInfo {
#if PLATFORM(COCOA)
            WTFMove(*trust),
#endif
#if USE(CURL)
            WTFMove(*verificationError),
#endif
#if USE(CURL)
            WTFMove(*certificateChain),
#endif
#if USE(SOUP)
            WTFMove(*certificate),
#endif
#if USE(SOUP)
            WTFMove(*tlsErrors)
#endif
        }
    };
}

void ArgumentCoder<WebCore::PasteboardCustomData::Entry>::encode(Encoder& encoder, const WebCore::PasteboardCustomData::Entry& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.customData)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.platformData)>, Variant<String, Ref<WebCore::SharedBuffer>>>);
    struct ShouldBeSameSizeAsEntry : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PasteboardCustomData::Entry>, false> {
        String type;
        String customData;
        Variant<String, Ref<WebCore::SharedBuffer>> platformData;
    };
    static_assert(sizeof(ShouldBeSameSizeAsEntry) == sizeof(WebCore::PasteboardCustomData::Entry));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PasteboardCustomData::Entry, type)
        , offsetof(WebCore::PasteboardCustomData::Entry, customData)
        , offsetof(WebCore::PasteboardCustomData::Entry, platformData)
    >::value);

    encoder << instance.type;
    encoder << instance.customData;
    encoder << instance.platformData;
}

std::optional<WebCore::PasteboardCustomData::Entry> ArgumentCoder<WebCore::PasteboardCustomData::Entry>::decode(Decoder& decoder)
{
    auto type = decoder.decode<String>();
    auto customData = decoder.decode<String>();
    auto platformData = decoder.decode<Variant<String, Ref<WebCore::SharedBuffer>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PasteboardCustomData::Entry {
            WTFMove(*type),
            WTFMove(*customData),
            WTFMove(*platformData)
        }
    };
}

void ArgumentCoder<WebCore::PasteboardCustomData>::encode(Encoder& encoder, const WebCore::PasteboardCustomData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.origin())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data())>, Vector<WebCore::PasteboardCustomData::Entry>>);

    encoder << instance.origin();
    encoder << instance.data();
}

std::optional<WebCore::PasteboardCustomData> ArgumentCoder<WebCore::PasteboardCustomData>::decode(Decoder& decoder)
{
    auto origin = decoder.decode<String>();
    auto data = decoder.decode<Vector<WebCore::PasteboardCustomData::Entry>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PasteboardCustomData {
            WTFMove(*origin),
            WTFMove(*data)
        }
    };
}

void ArgumentCoder<WebCore::SharedMemoryHandle>::encode(Encoder& encoder, WebCore::SharedMemoryHandle&& instance)
{
#if USE(UNIX_DOMAIN_SOCKETS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_handle)>, UnixFileDescriptor>);
#endif
#if OS(DARWIN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_handle)>, MachSendRight>);
#endif
#if OS(WINDOWS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_handle)>, Win32Handle>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_size)>, uint64_t>);
    struct ShouldBeSameSizeAsSharedMemoryHandle : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SharedMemoryHandle>, false> {
#if USE(UNIX_DOMAIN_SOCKETS)
        UnixFileDescriptor m_handle;
#endif
#if OS(DARWIN)
        MachSendRight m_handle;
#endif
#if OS(WINDOWS)
        Win32Handle m_handle;
#endif
        uint64_t m_size;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSharedMemoryHandle) == sizeof(WebCore::SharedMemoryHandle));
    static_assert(MembersInCorrectOrder < 0
#if USE(UNIX_DOMAIN_SOCKETS)
        , offsetof(WebCore::SharedMemoryHandle, m_handle)
#endif
#if OS(DARWIN)
        , offsetof(WebCore::SharedMemoryHandle, m_handle)
#endif
#if OS(WINDOWS)
        , offsetof(WebCore::SharedMemoryHandle, m_handle)
#endif
        , offsetof(WebCore::SharedMemoryHandle, m_size)
    >::value);

#if USE(UNIX_DOMAIN_SOCKETS)
    encoder << WTFMove(instance.m_handle);
#endif
#if OS(DARWIN)
    encoder << WTFMove(instance.m_handle);
#endif
#if OS(WINDOWS)
    encoder << WTFMove(instance.m_handle);
#endif
    encoder << WTFMove(instance.m_size);
}

std::optional<WebCore::SharedMemoryHandle> ArgumentCoder<WebCore::SharedMemoryHandle>::decode(Decoder& decoder)
{
#if USE(UNIX_DOMAIN_SOCKETS)
    auto m_handle = decoder.decode<UnixFileDescriptor>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(!!m_handle && *m_handle))
        return std::nullopt;
#endif
#if OS(DARWIN)
    auto m_handle = decoder.decode<MachSendRight>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(!!m_handle && *m_handle))
        return std::nullopt;
#endif
#if OS(WINDOWS)
    auto m_handle = decoder.decode<Win32Handle>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(!!m_handle && *m_handle))
        return std::nullopt;
#endif
    auto m_size = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SharedMemoryHandle {
#if USE(UNIX_DOMAIN_SOCKETS)
            WTFMove(*m_handle),
#endif
#if OS(DARWIN)
            WTFMove(*m_handle),
#endif
#if OS(WINDOWS)
            WTFMove(*m_handle),
#endif
            WTFMove(*m_size)
        }
    };
}

void ArgumentCoder<WebCore::DatabaseDetails>::encode(Encoder& encoder, const WebCore::DatabaseDetails& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.displayName())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.expectedUsage())>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.currentUsage())>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.creationTime())>, std::optional<WallTime>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.modificationTime())>, std::optional<WallTime>>);

    encoder << instance.name();
    encoder << instance.displayName();
    encoder << instance.expectedUsage();
    encoder << instance.currentUsage();
    encoder << instance.creationTime();
    encoder << instance.modificationTime();
}

std::optional<WebCore::DatabaseDetails> ArgumentCoder<WebCore::DatabaseDetails>::decode(Decoder& decoder)
{
    auto name = decoder.decode<String>();
    auto displayName = decoder.decode<String>();
    auto expectedUsage = decoder.decode<uint64_t>();
    auto currentUsage = decoder.decode<uint64_t>();
    auto creationTime = decoder.decode<std::optional<WallTime>>();
    auto modificationTime = decoder.decode<std::optional<WallTime>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DatabaseDetails {
            WTFMove(*name),
            WTFMove(*displayName),
            WTFMove(*expectedUsage),
            WTFMove(*currentUsage),
            WTFMove(*creationTime),
            WTFMove(*modificationTime)
        }
    };
}

void ArgumentCoder<WebCore::TextIndicatorData>::encode(Encoder& encoder, const WebCore::TextIndicatorData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selectionRectInRootViewCoordinates)>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.textBoundingRectInRootViewCoordinates)>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentImageWithoutSelectionRectInRootViewCoordinates)>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.textRectsInBoundingRectCoordinates)>, Vector<WebCore::FloatRect>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentImageScaleFactor)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentImageWithHighlight)>, RefPtr<WebCore::Image>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentImageWithoutSelection)>, RefPtr<WebCore::Image>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentImage)>, RefPtr<WebCore::Image>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.estimatedBackgroundColor)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.presentationTransition)>, WebCore::TextIndicatorPresentationTransition>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.options)>, OptionSet<WebCore::TextIndicatorOption>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.enclosingGraphicsLayerID)>, std::optional<WebCore::PlatformLayerIdentifier>>);
    struct ShouldBeSameSizeAsTextIndicatorData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::TextIndicatorData>, false> {
        WebCore::FloatRect selectionRectInRootViewCoordinates;
        WebCore::FloatRect textBoundingRectInRootViewCoordinates;
        WebCore::FloatRect contentImageWithoutSelectionRectInRootViewCoordinates;
        Vector<WebCore::FloatRect> textRectsInBoundingRectCoordinates;
        float contentImageScaleFactor;
        RefPtr<WebCore::Image> contentImageWithHighlight;
        RefPtr<WebCore::Image> contentImageWithoutSelection;
        RefPtr<WebCore::Image> contentImage;
        WebCore::Color estimatedBackgroundColor;
        WebCore::TextIndicatorPresentationTransition presentationTransition;
        OptionSet<WebCore::TextIndicatorOption> options;
        std::optional<WebCore::PlatformLayerIdentifier> enclosingGraphicsLayerID;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTextIndicatorData) == sizeof(WebCore::TextIndicatorData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::TextIndicatorData, selectionRectInRootViewCoordinates)
        , offsetof(WebCore::TextIndicatorData, textBoundingRectInRootViewCoordinates)
        , offsetof(WebCore::TextIndicatorData, contentImageWithoutSelectionRectInRootViewCoordinates)
        , offsetof(WebCore::TextIndicatorData, textRectsInBoundingRectCoordinates)
        , offsetof(WebCore::TextIndicatorData, contentImageScaleFactor)
        , offsetof(WebCore::TextIndicatorData, contentImageWithHighlight)
        , offsetof(WebCore::TextIndicatorData, contentImageWithoutSelection)
        , offsetof(WebCore::TextIndicatorData, contentImage)
        , offsetof(WebCore::TextIndicatorData, estimatedBackgroundColor)
        , offsetof(WebCore::TextIndicatorData, presentationTransition)
        , offsetof(WebCore::TextIndicatorData, options)
        , offsetof(WebCore::TextIndicatorData, enclosingGraphicsLayerID)
    >::value);

    encoder << instance.selectionRectInRootViewCoordinates;
    encoder << instance.textBoundingRectInRootViewCoordinates;
    encoder << instance.contentImageWithoutSelectionRectInRootViewCoordinates;
    encoder << instance.textRectsInBoundingRectCoordinates;
    encoder << instance.contentImageScaleFactor;
    encoder << instance.contentImageWithHighlight;
    encoder << instance.contentImageWithoutSelection;
    encoder << instance.contentImage;
    encoder << instance.estimatedBackgroundColor;
    encoder << instance.presentationTransition;
    encoder << instance.options;
    encoder << instance.enclosingGraphicsLayerID;
}

std::optional<WebCore::TextIndicatorData> ArgumentCoder<WebCore::TextIndicatorData>::decode(Decoder& decoder)
{
    auto selectionRectInRootViewCoordinates = decoder.decode<WebCore::FloatRect>();
    auto textBoundingRectInRootViewCoordinates = decoder.decode<WebCore::FloatRect>();
    auto contentImageWithoutSelectionRectInRootViewCoordinates = decoder.decode<WebCore::FloatRect>();
    auto textRectsInBoundingRectCoordinates = decoder.decode<Vector<WebCore::FloatRect>>();
    auto contentImageScaleFactor = decoder.decode<float>();
    auto contentImageWithHighlight = decoder.decode<RefPtr<WebCore::Image>>();
    auto contentImageWithoutSelection = decoder.decode<RefPtr<WebCore::Image>>();
    auto contentImage = decoder.decode<RefPtr<WebCore::Image>>();
    auto estimatedBackgroundColor = decoder.decode<WebCore::Color>();
    auto presentationTransition = decoder.decode<WebCore::TextIndicatorPresentationTransition>();
    auto options = decoder.decode<OptionSet<WebCore::TextIndicatorOption>>();
    auto enclosingGraphicsLayerID = decoder.decode<std::optional<WebCore::PlatformLayerIdentifier>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TextIndicatorData {
            WTFMove(*selectionRectInRootViewCoordinates),
            WTFMove(*textBoundingRectInRootViewCoordinates),
            WTFMove(*contentImageWithoutSelectionRectInRootViewCoordinates),
            WTFMove(*textRectsInBoundingRectCoordinates),
            WTFMove(*contentImageScaleFactor),
            WTFMove(*contentImageWithHighlight),
            WTFMove(*contentImageWithoutSelection),
            WTFMove(*contentImage),
            WTFMove(*estimatedBackgroundColor),
            WTFMove(*presentationTransition),
            WTFMove(*options),
            WTFMove(*enclosingGraphicsLayerID)
        }
    };
}

#if ENABLE(MEDIA_STREAM)
void ArgumentCoder<WebCore::MediaConstraints>::encode(Encoder& encoder, const WebCore::MediaConstraints& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mandatoryConstraints)>, WebCore::MediaTrackConstraintSetMap>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.advancedConstraints)>, Vector<WebCore::MediaTrackConstraintSetMap>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isValid)>, bool>);
    struct ShouldBeSameSizeAsMediaConstraints : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MediaConstraints>, false> {
        WebCore::MediaTrackConstraintSetMap mandatoryConstraints;
        Vector<WebCore::MediaTrackConstraintSetMap> advancedConstraints;
        bool isValid;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMediaConstraints) == sizeof(WebCore::MediaConstraints));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MediaConstraints, mandatoryConstraints)
        , offsetof(WebCore::MediaConstraints, advancedConstraints)
        , offsetof(WebCore::MediaConstraints, isValid)
    >::value);

    encoder << instance.mandatoryConstraints;
    encoder << instance.advancedConstraints;
    encoder << instance.isValid;
}

std::optional<WebCore::MediaConstraints> ArgumentCoder<WebCore::MediaConstraints>::decode(Decoder& decoder)
{
    auto mandatoryConstraints = decoder.decode<WebCore::MediaTrackConstraintSetMap>();
    auto advancedConstraints = decoder.decode<Vector<WebCore::MediaTrackConstraintSetMap>>();
    auto isValid = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MediaConstraints {
            WTFMove(*mandatoryConstraints),
            WTFMove(*advancedConstraints),
            WTFMove(*isValid)
        }
    };
}

#endif

void ArgumentCoder<WebCore::PromisedAttachmentInfo>::encode(Encoder& encoder, const WebCore::PromisedAttachmentInfo& instance)
{
#if ENABLE(ATTACHMENT_ELEMENT)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.attachmentIdentifier)>, String>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.additionalTypesAndData)>, Vector<std::pair<String, RefPtr<WebCore::SharedBuffer>>>>);
    struct ShouldBeSameSizeAsPromisedAttachmentInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PromisedAttachmentInfo>, false> {
#if ENABLE(ATTACHMENT_ELEMENT)
        String attachmentIdentifier;
#endif
        Vector<std::pair<String, RefPtr<WebCore::SharedBuffer>>> additionalTypesAndData;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPromisedAttachmentInfo) == sizeof(WebCore::PromisedAttachmentInfo));
    static_assert(MembersInCorrectOrder < 0
#if ENABLE(ATTACHMENT_ELEMENT)
        , offsetof(WebCore::PromisedAttachmentInfo, attachmentIdentifier)
#endif
        , offsetof(WebCore::PromisedAttachmentInfo, additionalTypesAndData)
    >::value);

#if ENABLE(ATTACHMENT_ELEMENT)
    encoder << instance.attachmentIdentifier;
#endif
    encoder << instance.additionalTypesAndData;
}

std::optional<WebCore::PromisedAttachmentInfo> ArgumentCoder<WebCore::PromisedAttachmentInfo>::decode(Decoder& decoder)
{
#if ENABLE(ATTACHMENT_ELEMENT)
    auto attachmentIdentifier = decoder.decode<String>();
#endif
    auto additionalTypesAndData = decoder.decode<Vector<std::pair<String, RefPtr<WebCore::SharedBuffer>>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PromisedAttachmentInfo {
#if ENABLE(ATTACHMENT_ELEMENT)
            WTFMove(*attachmentIdentifier),
#endif
            WTFMove(*additionalTypesAndData)
        }
    };
}

void ArgumentCoder<WebCore::RecentSearch>::encode(Encoder& encoder, const WebCore::RecentSearch& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.string)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.time)>, WallTime>);
    struct ShouldBeSameSizeAsRecentSearch : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::RecentSearch>, false> {
        String string;
        WallTime time;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRecentSearch) == sizeof(WebCore::RecentSearch));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::RecentSearch, string)
        , offsetof(WebCore::RecentSearch, time)
    >::value);

    encoder << instance.string;
    encoder << instance.time;
}

std::optional<WebCore::RecentSearch> ArgumentCoder<WebCore::RecentSearch>::decode(Decoder& decoder)
{
    auto string = decoder.decode<String>();
    auto time = decoder.decode<WallTime>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::RecentSearch {
            WTFMove(*string),
            WTFMove(*time)
        }
    };
}

void ArgumentCoder<WebCore::EventTrackingRegions>::encode(Encoder& encoder, const WebCore::EventTrackingRegions& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.asynchronousDispatchRegion)>, WebCore::Region>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.eventSpecificSynchronousDispatchRegions)>, HashMap<WebCore::EventTrackingRegions::EventType, WebCore::Region, WTF::IntHash<WebCore::EventTrackingRegions::EventType>, WTF::StrongEnumHashTraits<WebCore::EventTrackingRegions::EventType>>>);
    struct ShouldBeSameSizeAsEventTrackingRegions : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::EventTrackingRegions>, false> {
        WebCore::Region asynchronousDispatchRegion;
        HashMap<WebCore::EventTrackingRegions::EventType, WebCore::Region, WTF::IntHash<WebCore::EventTrackingRegions::EventType>, WTF::StrongEnumHashTraits<WebCore::EventTrackingRegions::EventType>> eventSpecificSynchronousDispatchRegions;
    };
    static_assert(sizeof(ShouldBeSameSizeAsEventTrackingRegions) == sizeof(WebCore::EventTrackingRegions));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::EventTrackingRegions, asynchronousDispatchRegion)
        , offsetof(WebCore::EventTrackingRegions, eventSpecificSynchronousDispatchRegions)
    >::value);

    encoder << instance.asynchronousDispatchRegion;
    encoder << instance.eventSpecificSynchronousDispatchRegions;
}

std::optional<WebCore::EventTrackingRegions> ArgumentCoder<WebCore::EventTrackingRegions>::decode(Decoder& decoder)
{
    auto asynchronousDispatchRegion = decoder.decode<WebCore::Region>();
    auto eventSpecificSynchronousDispatchRegions = decoder.decode<HashMap<WebCore::EventTrackingRegions::EventType, WebCore::Region, WTF::IntHash<WebCore::EventTrackingRegions::EventType>, WTF::StrongEnumHashTraits<WebCore::EventTrackingRegions::EventType>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::EventTrackingRegions {
            WTFMove(*asynchronousDispatchRegion),
            WTFMove(*eventSpecificSynchronousDispatchRegions)
        }
    };
}

void ArgumentCoder<WebCore::TextManipulationItem>::encode(Encoder& encoder, const WebCore::TextManipulationItem& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameID)>, Markable<WebCore::FrameIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isSubframe)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isCrossSiteSubframe)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, Markable<WebCore::TextManipulationItemIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tokens)>, Vector<WebCore::TextManipulationToken>>);
    struct ShouldBeSameSizeAsTextManipulationItem : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::TextManipulationItem>, false> {
        Markable<WebCore::FrameIdentifier> frameID;
        bool isSubframe;
        bool isCrossSiteSubframe;
        Markable<WebCore::TextManipulationItemIdentifier> identifier;
        Vector<WebCore::TextManipulationToken> tokens;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTextManipulationItem) == sizeof(WebCore::TextManipulationItem));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::TextManipulationItem, frameID)
        , offsetof(WebCore::TextManipulationItem, isSubframe)
        , offsetof(WebCore::TextManipulationItem, isCrossSiteSubframe)
        , offsetof(WebCore::TextManipulationItem, identifier)
        , offsetof(WebCore::TextManipulationItem, tokens)
    >::value);

    encoder << instance.frameID;
    encoder << instance.isSubframe;
    encoder << instance.isCrossSiteSubframe;
    encoder << instance.identifier;
    encoder << instance.tokens;
}

std::optional<WebCore::TextManipulationItem> ArgumentCoder<WebCore::TextManipulationItem>::decode(Decoder& decoder)
{
    auto frameID = decoder.decode<Markable<WebCore::FrameIdentifier>>();
    auto isSubframe = decoder.decode<bool>();
    auto isCrossSiteSubframe = decoder.decode<bool>();
    auto identifier = decoder.decode<Markable<WebCore::TextManipulationItemIdentifier>>();
    auto tokens = decoder.decode<Vector<WebCore::TextManipulationToken>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TextManipulationItem {
            WTFMove(*frameID),
            WTFMove(*isSubframe),
            WTFMove(*isCrossSiteSubframe),
            WTFMove(*identifier),
            WTFMove(*tokens)
        }
    };
}

void ArgumentCoder<WebCore::TextManipulationToken>::encode(Encoder& encoder, const WebCore::TextManipulationToken& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, WebCore::TextManipulationTokenIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.content)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.info)>, std::optional<WebCore::TextManipulationTokenInfo>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isExcluded)>, bool>);
    struct ShouldBeSameSizeAsTextManipulationToken : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::TextManipulationToken>, false> {
        WebCore::TextManipulationTokenIdentifier identifier;
        String content;
        std::optional<WebCore::TextManipulationTokenInfo> info;
        bool isExcluded;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTextManipulationToken) == sizeof(WebCore::TextManipulationToken));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::TextManipulationToken, identifier)
        , offsetof(WebCore::TextManipulationToken, content)
        , offsetof(WebCore::TextManipulationToken, info)
        , offsetof(WebCore::TextManipulationToken, isExcluded)
    >::value);

    encoder << instance.identifier;
    encoder << instance.content;
    encoder << instance.info;
    encoder << instance.isExcluded;
}

std::optional<WebCore::TextManipulationToken> ArgumentCoder<WebCore::TextManipulationToken>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<WebCore::TextManipulationTokenIdentifier>();
    auto content = decoder.decode<String>();
    auto info = decoder.decode<std::optional<WebCore::TextManipulationTokenInfo>>();
    auto isExcluded = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TextManipulationToken {
            WTFMove(*identifier),
            WTFMove(*content),
            WTFMove(*info),
            WTFMove(*isExcluded)
        }
    };
}

void ArgumentCoder<WebCore::TextManipulationTokenInfo>::encode(Encoder& encoder, const WebCore::TextManipulationTokenInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tagName)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.roleAttribute)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.documentURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isVisible)>, bool>);
    struct ShouldBeSameSizeAsTextManipulationTokenInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::TextManipulationTokenInfo>, false> {
        String tagName;
        String roleAttribute;
        URL documentURL;
        bool isVisible;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTextManipulationTokenInfo) == sizeof(WebCore::TextManipulationTokenInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::TextManipulationTokenInfo, tagName)
        , offsetof(WebCore::TextManipulationTokenInfo, roleAttribute)
        , offsetof(WebCore::TextManipulationTokenInfo, documentURL)
        , offsetof(WebCore::TextManipulationTokenInfo, isVisible)
    >::value);

    encoder << instance.tagName;
    encoder << instance.roleAttribute;
    encoder << instance.documentURL;
    encoder << instance.isVisible;
}

std::optional<WebCore::TextManipulationTokenInfo> ArgumentCoder<WebCore::TextManipulationTokenInfo>::decode(Decoder& decoder)
{
    auto tagName = decoder.decode<String>();
    auto roleAttribute = decoder.decode<String>();
    auto documentURL = decoder.decode<URL>();
    auto isVisible = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TextManipulationTokenInfo {
            WTFMove(*tagName),
            WTFMove(*roleAttribute),
            WTFMove(*documentURL),
            WTFMove(*isVisible)
        }
    };
}

void ArgumentCoder<WebCore::VelocityData>::encode(Encoder& encoder, const WebCore::VelocityData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.horizontalVelocity)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.verticalVelocity)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scaleChangeRate)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lastUpdateTime)>, MonotonicTime>);
    struct ShouldBeSameSizeAsVelocityData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::VelocityData>, false> {
        float horizontalVelocity;
        float verticalVelocity;
        float scaleChangeRate;
        MonotonicTime lastUpdateTime;
    };
    static_assert(sizeof(ShouldBeSameSizeAsVelocityData) == sizeof(WebCore::VelocityData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::VelocityData, horizontalVelocity)
        , offsetof(WebCore::VelocityData, verticalVelocity)
        , offsetof(WebCore::VelocityData, scaleChangeRate)
        , offsetof(WebCore::VelocityData, lastUpdateTime)
    >::value);

    encoder << instance.horizontalVelocity;
    encoder << instance.verticalVelocity;
    encoder << instance.scaleChangeRate;
    encoder << instance.lastUpdateTime;
}

std::optional<WebCore::VelocityData> ArgumentCoder<WebCore::VelocityData>::decode(Decoder& decoder)
{
    auto horizontalVelocity = decoder.decode<float>();
    auto verticalVelocity = decoder.decode<float>();
    auto scaleChangeRate = decoder.decode<float>();
    auto lastUpdateTime = decoder.decode<MonotonicTime>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::VelocityData {
            WTFMove(*horizontalVelocity),
            WTFMove(*verticalVelocity),
            WTFMove(*scaleChangeRate),
            WTFMove(*lastUpdateTime)
        }
    };
}

void ArgumentCoder<WebCore::MimeClassInfo>::encode(Encoder& encoder, const WebCore::MimeClassInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, AtomString>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.desc)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.extensions)>, Vector<String>>);
    struct ShouldBeSameSizeAsMimeClassInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MimeClassInfo>, false> {
        AtomString type;
        String desc;
        Vector<String> extensions;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMimeClassInfo) == sizeof(WebCore::MimeClassInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MimeClassInfo, type)
        , offsetof(WebCore::MimeClassInfo, desc)
        , offsetof(WebCore::MimeClassInfo, extensions)
    >::value);

    encoder << instance.type;
    encoder << instance.desc;
    encoder << instance.extensions;
}

std::optional<WebCore::MimeClassInfo> ArgumentCoder<WebCore::MimeClassInfo>::decode(Decoder& decoder)
{
    auto type = decoder.decode<AtomString>();
    auto desc = decoder.decode<String>();
    auto extensions = decoder.decode<Vector<String>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MimeClassInfo {
            WTFMove(*type),
            WTFMove(*desc),
            WTFMove(*extensions)
        }
    };
}

void ArgumentCoder<WebCore::AuthenticationChallenge>::encode(Encoder& encoder, const WebCore::AuthenticationChallenge& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.protectionSpace())>, WebCore::ProtectionSpace>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.proposedCredential())>, WebCore::Credential>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.previousFailureCount())>, unsigned>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.failureResponse())>, WebCore::ResourceResponse>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.error())>, WebCore::ResourceError>);
#if USE(SOUP)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tlsPasswordFlags())>, uint32_t>);
#endif

    encoder << instance.protectionSpace();
    encoder << instance.proposedCredential();
    encoder << instance.previousFailureCount();
    encoder << instance.failureResponse();
    encoder << instance.error();
#if USE(SOUP)
    encoder << instance.tlsPasswordFlags();
#endif
}

std::optional<WebCore::AuthenticationChallenge> ArgumentCoder<WebCore::AuthenticationChallenge>::decode(Decoder& decoder)
{
    auto protectionSpace = decoder.decode<WebCore::ProtectionSpace>();
    auto proposedCredential = decoder.decode<WebCore::Credential>();
    auto previousFailureCount = decoder.decode<unsigned>();
    auto failureResponse = decoder.decode<WebCore::ResourceResponse>();
    auto error = decoder.decode<WebCore::ResourceError>();
#if USE(SOUP)
    auto tlsPasswordFlags = decoder.decode<uint32_t>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::AuthenticationChallenge {
            WTFMove(*protectionSpace),
            WTFMove(*proposedCredential),
            WTFMove(*previousFailureCount),
            WTFMove(*failureResponse),
            WTFMove(*error),
#if USE(SOUP)
            WTFMove(*tlsPasswordFlags)
#endif
        }
    };
}

#if ENABLE(DRAG_SUPPORT)
void ArgumentCoder<WebCore::DragData>::encode(Encoder& encoder, const WebCore::DragData& instance)
{
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pasteboardName())>, String>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.clientPosition())>, WebCore::IntPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.globalPosition())>, WebCore::IntPoint>);
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fileNames())>, Vector<String>>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.draggingSourceOperationMask())>, OptionSet<WebCore::DragOperation>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.flags())>, OptionSet<WebCore::DragApplicationFlags>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dragDestinationActionMask())>, OptionSet<WebCore::DragDestinationAction>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pageID())>, std::optional<WebCore::PageIdentifier>>);

#if PLATFORM(COCOA)
    encoder << instance.pasteboardName();
#endif
    encoder << instance.clientPosition();
    encoder << instance.globalPosition();
#if PLATFORM(COCOA)
    encoder << instance.fileNames();
#endif
    encoder << instance.draggingSourceOperationMask();
    encoder << instance.flags();
    encoder << instance.dragDestinationActionMask();
    encoder << instance.pageID();
}

std::optional<WebCore::DragData> ArgumentCoder<WebCore::DragData>::decode(Decoder& decoder)
{
#if PLATFORM(COCOA)
    auto pasteboardName = decoder.decode<String>();
#endif
    auto clientPosition = decoder.decode<WebCore::IntPoint>();
    auto globalPosition = decoder.decode<WebCore::IntPoint>();
#if PLATFORM(COCOA)
    auto fileNames = decoder.decode<Vector<String>>();
#endif
    auto draggingSourceOperationMask = decoder.decode<OptionSet<WebCore::DragOperation>>();
    auto flags = decoder.decode<OptionSet<WebCore::DragApplicationFlags>>();
    auto dragDestinationActionMask = decoder.decode<OptionSet<WebCore::DragDestinationAction>>();
    auto pageID = decoder.decode<std::optional<WebCore::PageIdentifier>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DragData {
#if PLATFORM(COCOA)
            WTFMove(*pasteboardName),
#endif
            WTFMove(*clientPosition),
            WTFMove(*globalPosition),
#if PLATFORM(COCOA)
            WTFMove(*fileNames),
#endif
            WTFMove(*draggingSourceOperationMask),
            WTFMove(*flags),
            WTFMove(*dragDestinationActionMask),
            WTFMove(*pageID)
        }
    };
}

#endif

void ArgumentCoder<WebCore::DictationAlternative>::encode(Encoder& encoder, const WebCore::DictationAlternative& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.range)>, WebCore::CharacterRange>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.context)>, WebCore::DictationContext>);
    struct ShouldBeSameSizeAsDictationAlternative : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::DictationAlternative>, false> {
        WebCore::CharacterRange range;
        WebCore::DictationContext context;
    };
    static_assert(sizeof(ShouldBeSameSizeAsDictationAlternative) == sizeof(WebCore::DictationAlternative));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::DictationAlternative, range)
        , offsetof(WebCore::DictationAlternative, context)
    >::value);

    encoder << instance.range;
    encoder << instance.context;
}

std::optional<WebCore::DictationAlternative> ArgumentCoder<WebCore::DictationAlternative>::decode(Decoder& decoder)
{
    auto range = decoder.decode<WebCore::CharacterRange>();
    auto context = decoder.decode<WebCore::DictationContext>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DictationAlternative {
            WTFMove(*range),
            WTFMove(*context)
        }
    };
}

void ArgumentCoder<WebCore::UserStyleSheet>::encode(Encoder& encoder, const WebCore::UserStyleSheet& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.source())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url())>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowlist())>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.blocklist())>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.injectedFrames())>, WebCore::UserContentInjectedFrames>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.matchParentFrame())>, WebCore::UserContentMatchParentFrame>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.level())>, WebCore::UserStyleLevel>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pageID())>, std::optional<WebCore::PageIdentifier>>);

    encoder << instance.source();
    encoder << instance.url();
    encoder << instance.allowlist();
    encoder << instance.blocklist();
    encoder << instance.injectedFrames();
    encoder << instance.matchParentFrame();
    encoder << instance.level();
    encoder << instance.pageID();
}

std::optional<WebCore::UserStyleSheet> ArgumentCoder<WebCore::UserStyleSheet>::decode(Decoder& decoder)
{
    bool addedDecodingFailureIndex = false;
    auto source = decoder.decode<String>();
    if (!source && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(0);
        addedDecodingFailureIndex = true;
    }
    auto url = decoder.decode<URL>();
    if (!url && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(1);
        addedDecodingFailureIndex = true;
    }
    auto allowlist = decoder.decode<Vector<String>>();
    if (!allowlist && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(2);
        addedDecodingFailureIndex = true;
    }
    auto blocklist = decoder.decode<Vector<String>>();
    if (!blocklist && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(3);
        addedDecodingFailureIndex = true;
    }
    auto injectedFrames = decoder.decode<WebCore::UserContentInjectedFrames>();
    if (!injectedFrames && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(4);
        addedDecodingFailureIndex = true;
    }
    auto matchParentFrame = decoder.decode<WebCore::UserContentMatchParentFrame>();
    if (!matchParentFrame && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(5);
        addedDecodingFailureIndex = true;
    }
    auto level = decoder.decode<WebCore::UserStyleLevel>();
    if (!level && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(6);
        addedDecodingFailureIndex = true;
    }
    auto pageID = decoder.decode<std::optional<WebCore::PageIdentifier>>();
    if (!pageID && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(7);
        addedDecodingFailureIndex = true;
    }
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::UserStyleSheet {
            WTFMove(*source),
            WTFMove(*url),
            WTFMove(*allowlist),
            WTFMove(*blocklist),
            WTFMove(*injectedFrames),
            WTFMove(*matchParentFrame),
            WTFMove(*level),
            WTFMove(*pageID)
        }
    };
}

void ArgumentCoder<WebCore::ScrollableAreaParameters>::encode(Encoder& encoder, const WebCore::ScrollableAreaParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.horizontalScrollElasticity)>, WebCore::ScrollElasticity>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.verticalScrollElasticity)>, WebCore::ScrollElasticity>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.horizontalScrollbarMode)>, WebCore::ScrollbarMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.verticalScrollbarMode)>, WebCore::ScrollbarMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.horizontalOverscrollBehavior)>, WebCore::OverscrollBehavior>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.verticalOverscrollBehavior)>, WebCore::OverscrollBehavior>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowsHorizontalScrolling)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowsVerticalScrolling)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.horizontalNativeScrollbarVisibility)>, WebCore::NativeScrollbarVisibility>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.verticalNativeScrollbarVisibility)>, WebCore::NativeScrollbarVisibility>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scrollbarWidthStyle)>, WebCore::ScrollbarWidth>);
    struct ShouldBeSameSizeAsScrollableAreaParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ScrollableAreaParameters>, false> {
        WebCore::ScrollElasticity horizontalScrollElasticity;
        WebCore::ScrollElasticity verticalScrollElasticity;
        WebCore::ScrollbarMode horizontalScrollbarMode;
        WebCore::ScrollbarMode verticalScrollbarMode;
        WebCore::OverscrollBehavior horizontalOverscrollBehavior;
        WebCore::OverscrollBehavior verticalOverscrollBehavior;
        bool allowsHorizontalScrolling;
        bool allowsVerticalScrolling;
        WebCore::NativeScrollbarVisibility horizontalNativeScrollbarVisibility;
        WebCore::NativeScrollbarVisibility verticalNativeScrollbarVisibility;
        WebCore::ScrollbarWidth scrollbarWidthStyle;
    };
    static_assert(sizeof(ShouldBeSameSizeAsScrollableAreaParameters) == sizeof(WebCore::ScrollableAreaParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ScrollableAreaParameters, horizontalScrollElasticity)
        , offsetof(WebCore::ScrollableAreaParameters, verticalScrollElasticity)
        , offsetof(WebCore::ScrollableAreaParameters, horizontalScrollbarMode)
        , offsetof(WebCore::ScrollableAreaParameters, verticalScrollbarMode)
        , offsetof(WebCore::ScrollableAreaParameters, horizontalOverscrollBehavior)
        , offsetof(WebCore::ScrollableAreaParameters, verticalOverscrollBehavior)
        , offsetof(WebCore::ScrollableAreaParameters, allowsHorizontalScrolling)
        , offsetof(WebCore::ScrollableAreaParameters, allowsVerticalScrolling)
        , offsetof(WebCore::ScrollableAreaParameters, horizontalNativeScrollbarVisibility)
        , offsetof(WebCore::ScrollableAreaParameters, verticalNativeScrollbarVisibility)
        , offsetof(WebCore::ScrollableAreaParameters, scrollbarWidthStyle)
    >::value);

    encoder << instance.horizontalScrollElasticity;
    encoder << instance.verticalScrollElasticity;
    encoder << instance.horizontalScrollbarMode;
    encoder << instance.verticalScrollbarMode;
    encoder << instance.horizontalOverscrollBehavior;
    encoder << instance.verticalOverscrollBehavior;
    encoder << instance.allowsHorizontalScrolling;
    encoder << instance.allowsVerticalScrolling;
    encoder << instance.horizontalNativeScrollbarVisibility;
    encoder << instance.verticalNativeScrollbarVisibility;
    encoder << instance.scrollbarWidthStyle;
}

std::optional<WebCore::ScrollableAreaParameters> ArgumentCoder<WebCore::ScrollableAreaParameters>::decode(Decoder& decoder)
{
    auto horizontalScrollElasticity = decoder.decode<WebCore::ScrollElasticity>();
    auto verticalScrollElasticity = decoder.decode<WebCore::ScrollElasticity>();
    auto horizontalScrollbarMode = decoder.decode<WebCore::ScrollbarMode>();
    auto verticalScrollbarMode = decoder.decode<WebCore::ScrollbarMode>();
    auto horizontalOverscrollBehavior = decoder.decode<WebCore::OverscrollBehavior>();
    auto verticalOverscrollBehavior = decoder.decode<WebCore::OverscrollBehavior>();
    auto allowsHorizontalScrolling = decoder.decode<bool>();
    auto allowsVerticalScrolling = decoder.decode<bool>();
    auto horizontalNativeScrollbarVisibility = decoder.decode<WebCore::NativeScrollbarVisibility>();
    auto verticalNativeScrollbarVisibility = decoder.decode<WebCore::NativeScrollbarVisibility>();
    auto scrollbarWidthStyle = decoder.decode<WebCore::ScrollbarWidth>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ScrollableAreaParameters {
            WTFMove(*horizontalScrollElasticity),
            WTFMove(*verticalScrollElasticity),
            WTFMove(*horizontalScrollbarMode),
            WTFMove(*verticalScrollbarMode),
            WTFMove(*horizontalOverscrollBehavior),
            WTFMove(*verticalOverscrollBehavior),
            WTFMove(*allowsHorizontalScrolling),
            WTFMove(*allowsVerticalScrolling),
            WTFMove(*horizontalNativeScrollbarVisibility),
            WTFMove(*verticalNativeScrollbarVisibility),
            WTFMove(*scrollbarWidthStyle)
        }
    };
}

void ArgumentCoder<WebCore::RequestedKeyboardScrollData>::encode(Encoder& encoder, const WebCore::RequestedKeyboardScrollData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.action)>, WebCore::KeyboardScrollAction>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.keyboardScroll)>, std::optional<WebCore::KeyboardScroll>>);
    struct ShouldBeSameSizeAsRequestedKeyboardScrollData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::RequestedKeyboardScrollData>, false> {
        WebCore::KeyboardScrollAction action;
        std::optional<WebCore::KeyboardScroll> keyboardScroll;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRequestedKeyboardScrollData) == sizeof(WebCore::RequestedKeyboardScrollData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::RequestedKeyboardScrollData, action)
        , offsetof(WebCore::RequestedKeyboardScrollData, keyboardScroll)
    >::value);

    encoder << instance.action;
    encoder << instance.keyboardScroll;
}

std::optional<WebCore::RequestedKeyboardScrollData> ArgumentCoder<WebCore::RequestedKeyboardScrollData>::decode(Decoder& decoder)
{
    auto action = decoder.decode<WebCore::KeyboardScrollAction>();
    auto keyboardScroll = decoder.decode<std::optional<WebCore::KeyboardScroll>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::RequestedKeyboardScrollData {
            WTFMove(*action),
            WTFMove(*keyboardScroll)
        }
    };
}

void ArgumentCoder<WebCore::ScrollUpdate>::encode(Encoder& encoder, const WebCore::ScrollUpdate& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.nodeID)>, WebCore::ScrollingNodeID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scrollPosition)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.layoutViewportOrigin)>, std::optional<WebCore::FloatPoint>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.updateType)>, WebCore::ScrollUpdateType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.updateLayerPositionAction)>, WebCore::ScrollingLayerPositionAction>);
    struct ShouldBeSameSizeAsScrollUpdate : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ScrollUpdate>, false> {
        WebCore::ScrollingNodeID nodeID;
        WebCore::FloatPoint scrollPosition;
        std::optional<WebCore::FloatPoint> layoutViewportOrigin;
        WebCore::ScrollUpdateType updateType;
        WebCore::ScrollingLayerPositionAction updateLayerPositionAction;
    };
    static_assert(sizeof(ShouldBeSameSizeAsScrollUpdate) == sizeof(WebCore::ScrollUpdate));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ScrollUpdate, nodeID)
        , offsetof(WebCore::ScrollUpdate, scrollPosition)
        , offsetof(WebCore::ScrollUpdate, layoutViewportOrigin)
        , offsetof(WebCore::ScrollUpdate, updateType)
        , offsetof(WebCore::ScrollUpdate, updateLayerPositionAction)
    >::value);

    encoder << instance.nodeID;
    encoder << instance.scrollPosition;
    encoder << instance.layoutViewportOrigin;
    encoder << instance.updateType;
    encoder << instance.updateLayerPositionAction;
}

std::optional<WebCore::ScrollUpdate> ArgumentCoder<WebCore::ScrollUpdate>::decode(Decoder& decoder)
{
    auto nodeID = decoder.decode<WebCore::ScrollingNodeID>();
    auto scrollPosition = decoder.decode<WebCore::FloatPoint>();
    auto layoutViewportOrigin = decoder.decode<std::optional<WebCore::FloatPoint>>();
    auto updateType = decoder.decode<WebCore::ScrollUpdateType>();
    auto updateLayerPositionAction = decoder.decode<WebCore::ScrollingLayerPositionAction>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ScrollUpdate {
            WTFMove(*nodeID),
            WTFMove(*scrollPosition),
            WTFMove(*layoutViewportOrigin),
            WTFMove(*updateType),
            WTFMove(*updateLayerPositionAction)
        }
    };
}

void ArgumentCoder<WebCore::AbsolutePositionConstraints>::encode(Encoder& encoder, const WebCore::AbsolutePositionConstraints& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.alignmentOffset())>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.layerPositionAtLastLayout())>, WebCore::FloatPoint>);

    encoder << instance.alignmentOffset();
    encoder << instance.layerPositionAtLastLayout();
}

std::optional<WebCore::AbsolutePositionConstraints> ArgumentCoder<WebCore::AbsolutePositionConstraints>::decode(Decoder& decoder)
{
    auto alignmentOffset = decoder.decode<WebCore::FloatSize>();
    auto layerPositionAtLastLayout = decoder.decode<WebCore::FloatPoint>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::AbsolutePositionConstraints {
            WTFMove(*alignmentOffset),
            WTFMove(*layerPositionAtLastLayout)
        }
    };
}

void ArgumentCoder<WebCore::KeyboardScroll>::encode(Encoder& encoder, const WebCore::KeyboardScroll& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maximumVelocity)>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.force)>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.granularity)>, WebCore::ScrollGranularity>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.direction)>, WebCore::ScrollDirection>);
    struct ShouldBeSameSizeAsKeyboardScroll : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::KeyboardScroll>, false> {
        WebCore::FloatSize offset;
        WebCore::FloatSize maximumVelocity;
        WebCore::FloatSize force;
        WebCore::ScrollGranularity granularity;
        WebCore::ScrollDirection direction;
    };
    static_assert(sizeof(ShouldBeSameSizeAsKeyboardScroll) == sizeof(WebCore::KeyboardScroll));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::KeyboardScroll, offset)
        , offsetof(WebCore::KeyboardScroll, maximumVelocity)
        , offsetof(WebCore::KeyboardScroll, force)
        , offsetof(WebCore::KeyboardScroll, granularity)
        , offsetof(WebCore::KeyboardScroll, direction)
    >::value);

    encoder << instance.offset;
    encoder << instance.maximumVelocity;
    encoder << instance.force;
    encoder << instance.granularity;
    encoder << instance.direction;
}

std::optional<WebCore::KeyboardScroll> ArgumentCoder<WebCore::KeyboardScroll>::decode(Decoder& decoder)
{
    auto offset = decoder.decode<WebCore::FloatSize>();
    auto maximumVelocity = decoder.decode<WebCore::FloatSize>();
    auto force = decoder.decode<WebCore::FloatSize>();
    auto granularity = decoder.decode<WebCore::ScrollGranularity>();
    auto direction = decoder.decode<WebCore::ScrollDirection>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::KeyboardScroll {
            WTFMove(*offset),
            WTFMove(*maximumVelocity),
            WTFMove(*force),
            WTFMove(*granularity),
            WTFMove(*direction)
        }
    };
}

void ArgumentCoder<WebCore::NotificationResources>::encode(Encoder& encoder, const WebCore::NotificationResources& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.icon())>, RefPtr<WebCore::Image>>);

    encoder << instance.icon();
}

std::optional<Ref<WebCore::NotificationResources>> ArgumentCoder<WebCore::NotificationResources>::decode(Decoder& decoder)
{
    auto icon = decoder.decode<RefPtr<WebCore::Image>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::NotificationResources::create(
            WTFMove(*icon)
        )
    };
}

void ArgumentCoder<WebCore::IdentityTransformOperation>::encode(Encoder& encoder, const WebCore::IdentityTransformOperation& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebCore::TransformOperationType>);

}

std::optional<Ref<WebCore::IdentityTransformOperation>> ArgumentCoder<WebCore::IdentityTransformOperation>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::IdentityTransformOperation::create(
        )
    };
}

void ArgumentCoder<WebCore::TranslateTransformOperation>::encode(Encoder& encoder, const WebCore::TranslateTransformOperation& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.x())>, WebCore::Length>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.y())>, WebCore::Length>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.z())>, WebCore::Length>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebCore::TransformOperationType>);

    encoder << instance.x();
    encoder << instance.y();
    encoder << instance.z();
    encoder << instance.type();
}

std::optional<Ref<WebCore::TranslateTransformOperation>> ArgumentCoder<WebCore::TranslateTransformOperation>::decode(Decoder& decoder)
{
    auto x = decoder.decode<WebCore::Length>();
    auto y = decoder.decode<WebCore::Length>();
    auto z = decoder.decode<WebCore::Length>();
    auto type = decoder.decode<WebCore::TransformOperationType>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(WebCore::TransformOperation::isTranslateTransformOperationType(*type)))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TranslateTransformOperation::create(
            WTFMove(*x),
            WTFMove(*y),
            WTFMove(*z),
            WTFMove(*type)
        )
    };
}

void ArgumentCoder<WebCore::RotateTransformOperation>::encode(Encoder& encoder, const WebCore::RotateTransformOperation& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.x())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.y())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.z())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.angle())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebCore::TransformOperationType>);

    encoder << instance.x();
    encoder << instance.y();
    encoder << instance.z();
    encoder << instance.angle();
    encoder << instance.type();
}

std::optional<Ref<WebCore::RotateTransformOperation>> ArgumentCoder<WebCore::RotateTransformOperation>::decode(Decoder& decoder)
{
    auto x = decoder.decode<double>();
    auto y = decoder.decode<double>();
    auto z = decoder.decode<double>();
    auto angle = decoder.decode<double>();
    auto type = decoder.decode<WebCore::TransformOperationType>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(WebCore::TransformOperation::isRotateTransformOperationType(*type)))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::RotateTransformOperation::create(
            WTFMove(*x),
            WTFMove(*y),
            WTFMove(*z),
            WTFMove(*angle),
            WTFMove(*type)
        )
    };
}

void ArgumentCoder<WebCore::ScaleTransformOperation>::encode(Encoder& encoder, const WebCore::ScaleTransformOperation& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.x())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.y())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.z())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebCore::TransformOperationType>);

    encoder << instance.x();
    encoder << instance.y();
    encoder << instance.z();
    encoder << instance.type();
}

std::optional<Ref<WebCore::ScaleTransformOperation>> ArgumentCoder<WebCore::ScaleTransformOperation>::decode(Decoder& decoder)
{
    auto x = decoder.decode<double>();
    auto y = decoder.decode<double>();
    auto z = decoder.decode<double>();
    auto type = decoder.decode<WebCore::TransformOperationType>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(WebCore::TransformOperation::isScaleTransformOperationType(*type)))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ScaleTransformOperation::create(
            WTFMove(*x),
            WTFMove(*y),
            WTFMove(*z),
            WTFMove(*type)
        )
    };
}

void ArgumentCoder<WebCore::SkewTransformOperation>::encode(Encoder& encoder, const WebCore::SkewTransformOperation& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.angleX())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.angleY())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebCore::TransformOperationType>);

    encoder << instance.angleX();
    encoder << instance.angleY();
    encoder << instance.type();
}

std::optional<Ref<WebCore::SkewTransformOperation>> ArgumentCoder<WebCore::SkewTransformOperation>::decode(Decoder& decoder)
{
    auto angleX = decoder.decode<double>();
    auto angleY = decoder.decode<double>();
    auto type = decoder.decode<WebCore::TransformOperationType>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(WebCore::TransformOperation::isSkewTransformOperationType(*type)))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SkewTransformOperation::create(
            WTFMove(*angleX),
            WTFMove(*angleY),
            WTFMove(*type)
        )
    };
}

void ArgumentCoder<WebCore::PerspectiveTransformOperation>::encode(Encoder& encoder, const WebCore::PerspectiveTransformOperation& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.perspective())>, std::optional<WebCore::Length>>);

    encoder << instance.perspective();
}

std::optional<Ref<WebCore::PerspectiveTransformOperation>> ArgumentCoder<WebCore::PerspectiveTransformOperation>::decode(Decoder& decoder)
{
    auto perspective = decoder.decode<std::optional<WebCore::Length>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PerspectiveTransformOperation::create(
            WTFMove(*perspective)
        )
    };
}

void ArgumentCoder<WebCore::MatrixTransformOperation>::encode(Encoder& encoder, const WebCore::MatrixTransformOperation& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.matrix())>, WebCore::TransformationMatrix>);

    encoder << instance.matrix();
}

std::optional<Ref<WebCore::MatrixTransformOperation>> ArgumentCoder<WebCore::MatrixTransformOperation>::decode(Decoder& decoder)
{
    auto matrix = decoder.decode<WebCore::TransformationMatrix>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MatrixTransformOperation::create(
            WTFMove(*matrix)
        )
    };
}

void ArgumentCoder<WebCore::Matrix3DTransformOperation>::encode(Encoder& encoder, const WebCore::Matrix3DTransformOperation& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.matrix())>, WebCore::TransformationMatrix>);

    encoder << instance.matrix();
}

std::optional<Ref<WebCore::Matrix3DTransformOperation>> ArgumentCoder<WebCore::Matrix3DTransformOperation>::decode(Decoder& decoder)
{
    auto matrix = decoder.decode<WebCore::TransformationMatrix>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Matrix3DTransformOperation::create(
            WTFMove(*matrix)
        )
    };
}

#if PLATFORM(COCOA)
void ArgumentCoder<AudioStreamBasicDescription>::encode(Encoder& encoder, const AudioStreamBasicDescription& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mSampleRate)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mFormatID)>, UInt32>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mFormatFlags)>, UInt32>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mBytesPerPacket)>, UInt32>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mFramesPerPacket)>, UInt32>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mBytesPerFrame)>, UInt32>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mChannelsPerFrame)>, UInt32>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mBitsPerChannel)>, UInt32>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mReserved)>, UInt32>);
    struct ShouldBeSameSizeAsAudioStreamBasicDescription : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<AudioStreamBasicDescription>, false> {
        double mSampleRate;
        UInt32 mFormatID;
        UInt32 mFormatFlags;
        UInt32 mBytesPerPacket;
        UInt32 mFramesPerPacket;
        UInt32 mBytesPerFrame;
        UInt32 mChannelsPerFrame;
        UInt32 mBitsPerChannel;
        UInt32 mReserved;
    };
    static_assert(sizeof(ShouldBeSameSizeAsAudioStreamBasicDescription) == sizeof(AudioStreamBasicDescription));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(AudioStreamBasicDescription, mSampleRate)
        , offsetof(AudioStreamBasicDescription, mFormatID)
        , offsetof(AudioStreamBasicDescription, mFormatFlags)
        , offsetof(AudioStreamBasicDescription, mBytesPerPacket)
        , offsetof(AudioStreamBasicDescription, mFramesPerPacket)
        , offsetof(AudioStreamBasicDescription, mBytesPerFrame)
        , offsetof(AudioStreamBasicDescription, mChannelsPerFrame)
        , offsetof(AudioStreamBasicDescription, mBitsPerChannel)
        , offsetof(AudioStreamBasicDescription, mReserved)
    >::value);

    encoder << instance.mSampleRate;
    encoder << instance.mFormatID;
    encoder << instance.mFormatFlags;
    encoder << instance.mBytesPerPacket;
    encoder << instance.mFramesPerPacket;
    encoder << instance.mBytesPerFrame;
    encoder << instance.mChannelsPerFrame;
    encoder << instance.mBitsPerChannel;
    encoder << instance.mReserved;
}

std::optional<AudioStreamBasicDescription> ArgumentCoder<AudioStreamBasicDescription>::decode(Decoder& decoder)
{
    auto mSampleRate = decoder.decode<double>();
    auto mFormatID = decoder.decode<UInt32>();
    auto mFormatFlags = decoder.decode<UInt32>();
    auto mBytesPerPacket = decoder.decode<UInt32>();
    auto mFramesPerPacket = decoder.decode<UInt32>();
    auto mBytesPerFrame = decoder.decode<UInt32>();
    auto mChannelsPerFrame = decoder.decode<UInt32>();
    auto mBitsPerChannel = decoder.decode<UInt32>();
    auto mReserved = decoder.decode<UInt32>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        AudioStreamBasicDescription {
            WTFMove(*mSampleRate),
            WTFMove(*mFormatID),
            WTFMove(*mFormatFlags),
            WTFMove(*mBytesPerPacket),
            WTFMove(*mFramesPerPacket),
            WTFMove(*mBytesPerFrame),
            WTFMove(*mChannelsPerFrame),
            WTFMove(*mBitsPerChannel),
            WTFMove(*mReserved)
        }
    };
}

#endif

#if PLATFORM(COCOA)
void ArgumentCoder<WebCore::CAAudioStreamDescription>::encode(Encoder& encoder, const WebCore::CAAudioStreamDescription& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.streamDescription())>, AudioStreamBasicDescription>);

    encoder << instance.streamDescription();
}

std::optional<WebCore::CAAudioStreamDescription> ArgumentCoder<WebCore::CAAudioStreamDescription>::decode(Decoder& decoder)
{
    auto streamDescription = decoder.decode<AudioStreamBasicDescription>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CAAudioStreamDescription {
            WTFMove(*streamDescription)
        }
    };
}

#endif

void ArgumentCoder<WebCore::TransformOperations>::encode(Encoder& encoder, const WebCore::TransformOperations& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_operations)>, Vector<Ref<WebCore::TransformOperation>>>);
    struct ShouldBeSameSizeAsTransformOperations : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::TransformOperations>, false> {
        Vector<Ref<WebCore::TransformOperation>> m_operations;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTransformOperations) == sizeof(WebCore::TransformOperations));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::TransformOperations, m_operations)
    >::value);

    encoder << instance.m_operations;
}

std::optional<WebCore::TransformOperations> ArgumentCoder<WebCore::TransformOperations>::decode(Decoder& decoder)
{
    auto m_operations = decoder.decode<Vector<Ref<WebCore::TransformOperation>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TransformOperations {
            WTFMove(*m_operations)
        }
    };
}

void ArgumentCoder<WebCore::Gradient::LinearData>::encode(Encoder& encoder, const WebCore::Gradient::LinearData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.point0)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.point1)>, WebCore::FloatPoint>);
    struct ShouldBeSameSizeAsLinearData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Gradient::LinearData>, false> {
        WebCore::FloatPoint point0;
        WebCore::FloatPoint point1;
    };
    static_assert(sizeof(ShouldBeSameSizeAsLinearData) == sizeof(WebCore::Gradient::LinearData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Gradient::LinearData, point0)
        , offsetof(WebCore::Gradient::LinearData, point1)
    >::value);

    encoder << instance.point0;
    encoder << instance.point1;
}

void ArgumentCoder<WebCore::Gradient::LinearData>::encode(StreamConnectionEncoder& encoder, const WebCore::Gradient::LinearData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.point0)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.point1)>, WebCore::FloatPoint>);
    struct ShouldBeSameSizeAsLinearData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Gradient::LinearData>, false> {
        WebCore::FloatPoint point0;
        WebCore::FloatPoint point1;
    };
    static_assert(sizeof(ShouldBeSameSizeAsLinearData) == sizeof(WebCore::Gradient::LinearData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Gradient::LinearData, point0)
        , offsetof(WebCore::Gradient::LinearData, point1)
    >::value);

    encoder << instance.point0;
    encoder << instance.point1;
}

std::optional<WebCore::Gradient::LinearData> ArgumentCoder<WebCore::Gradient::LinearData>::decode(Decoder& decoder)
{
    auto point0 = decoder.decode<WebCore::FloatPoint>();
    auto point1 = decoder.decode<WebCore::FloatPoint>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Gradient::LinearData {
            WTFMove(*point0),
            WTFMove(*point1)
        }
    };
}

void ArgumentCoder<WebCore::Gradient::RadialData>::encode(Encoder& encoder, const WebCore::Gradient::RadialData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.point0)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.point1)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.startRadius)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.endRadius)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.aspectRatio)>, float>);
    struct ShouldBeSameSizeAsRadialData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Gradient::RadialData>, false> {
        WebCore::FloatPoint point0;
        WebCore::FloatPoint point1;
        float startRadius;
        float endRadius;
        float aspectRatio;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRadialData) == sizeof(WebCore::Gradient::RadialData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Gradient::RadialData, point0)
        , offsetof(WebCore::Gradient::RadialData, point1)
        , offsetof(WebCore::Gradient::RadialData, startRadius)
        , offsetof(WebCore::Gradient::RadialData, endRadius)
        , offsetof(WebCore::Gradient::RadialData, aspectRatio)
    >::value);

    encoder << instance.point0;
    encoder << instance.point1;
    encoder << instance.startRadius;
    encoder << instance.endRadius;
    encoder << instance.aspectRatio;
}

void ArgumentCoder<WebCore::Gradient::RadialData>::encode(StreamConnectionEncoder& encoder, const WebCore::Gradient::RadialData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.point0)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.point1)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.startRadius)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.endRadius)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.aspectRatio)>, float>);
    struct ShouldBeSameSizeAsRadialData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Gradient::RadialData>, false> {
        WebCore::FloatPoint point0;
        WebCore::FloatPoint point1;
        float startRadius;
        float endRadius;
        float aspectRatio;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRadialData) == sizeof(WebCore::Gradient::RadialData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Gradient::RadialData, point0)
        , offsetof(WebCore::Gradient::RadialData, point1)
        , offsetof(WebCore::Gradient::RadialData, startRadius)
        , offsetof(WebCore::Gradient::RadialData, endRadius)
        , offsetof(WebCore::Gradient::RadialData, aspectRatio)
    >::value);

    encoder << instance.point0;
    encoder << instance.point1;
    encoder << instance.startRadius;
    encoder << instance.endRadius;
    encoder << instance.aspectRatio;
}

std::optional<WebCore::Gradient::RadialData> ArgumentCoder<WebCore::Gradient::RadialData>::decode(Decoder& decoder)
{
    auto point0 = decoder.decode<WebCore::FloatPoint>();
    auto point1 = decoder.decode<WebCore::FloatPoint>();
    auto startRadius = decoder.decode<float>();
    auto endRadius = decoder.decode<float>();
    auto aspectRatio = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Gradient::RadialData {
            WTFMove(*point0),
            WTFMove(*point1),
            WTFMove(*startRadius),
            WTFMove(*endRadius),
            WTFMove(*aspectRatio)
        }
    };
}

void ArgumentCoder<WebCore::Gradient::ConicData>::encode(Encoder& encoder, const WebCore::Gradient::ConicData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.point0)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.angleRadians)>, float>);
    struct ShouldBeSameSizeAsConicData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Gradient::ConicData>, false> {
        WebCore::FloatPoint point0;
        float angleRadians;
    };
    static_assert(sizeof(ShouldBeSameSizeAsConicData) == sizeof(WebCore::Gradient::ConicData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Gradient::ConicData, point0)
        , offsetof(WebCore::Gradient::ConicData, angleRadians)
    >::value);

    encoder << instance.point0;
    encoder << instance.angleRadians;
}

void ArgumentCoder<WebCore::Gradient::ConicData>::encode(StreamConnectionEncoder& encoder, const WebCore::Gradient::ConicData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.point0)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.angleRadians)>, float>);
    struct ShouldBeSameSizeAsConicData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Gradient::ConicData>, false> {
        WebCore::FloatPoint point0;
        float angleRadians;
    };
    static_assert(sizeof(ShouldBeSameSizeAsConicData) == sizeof(WebCore::Gradient::ConicData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Gradient::ConicData, point0)
        , offsetof(WebCore::Gradient::ConicData, angleRadians)
    >::value);

    encoder << instance.point0;
    encoder << instance.angleRadians;
}

std::optional<WebCore::Gradient::ConicData> ArgumentCoder<WebCore::Gradient::ConicData>::decode(Decoder& decoder)
{
    auto point0 = decoder.decode<WebCore::FloatPoint>();
    auto angleRadians = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Gradient::ConicData {
            WTFMove(*point0),
            WTFMove(*angleRadians)
        }
    };
}

void ArgumentCoder<WebCore::Gradient>::encode(Encoder& encoder, const WebCore::Gradient& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data())>, Variant<WebCore::Gradient::LinearData, WebCore::Gradient::RadialData, WebCore::Gradient::ConicData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorInterpolationMethod())>, WebCore::ColorInterpolationMethod>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.spreadMethod())>, WebCore::GradientSpreadMethod>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stops())>, WebCore::GradientColorStops>);

    encoder << instance.data();
    encoder << instance.colorInterpolationMethod();
    encoder << instance.spreadMethod();
    encoder << instance.stops();
}

void ArgumentCoder<WebCore::Gradient>::encode(StreamConnectionEncoder& encoder, const WebCore::Gradient& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data())>, Variant<WebCore::Gradient::LinearData, WebCore::Gradient::RadialData, WebCore::Gradient::ConicData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorInterpolationMethod())>, WebCore::ColorInterpolationMethod>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.spreadMethod())>, WebCore::GradientSpreadMethod>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stops())>, WebCore::GradientColorStops>);

    encoder << instance.data();
    encoder << instance.colorInterpolationMethod();
    encoder << instance.spreadMethod();
    encoder << instance.stops();
}

std::optional<Ref<WebCore::Gradient>> ArgumentCoder<WebCore::Gradient>::decode(Decoder& decoder)
{
    auto data = decoder.decode<Variant<WebCore::Gradient::LinearData, WebCore::Gradient::RadialData, WebCore::Gradient::ConicData>>();
    auto colorInterpolationMethod = decoder.decode<WebCore::ColorInterpolationMethod>();
    auto spreadMethod = decoder.decode<WebCore::GradientSpreadMethod>();
    auto stops = decoder.decode<WebCore::GradientColorStops>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Gradient::create(
            WTFMove(*data),
            WTFMove(*colorInterpolationMethod),
            WTFMove(*spreadMethod),
            WTFMove(*stops)
        )
    };
}

void ArgumentCoder<WebCore::PatternParameters>::encode(Encoder& encoder, const WebCore::PatternParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.repeatX)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.repeatY)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.patternSpaceTransform)>, WebCore::AffineTransform>);
    struct ShouldBeSameSizeAsPatternParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PatternParameters>, false> {
        bool repeatX;
        bool repeatY;
        WebCore::AffineTransform patternSpaceTransform;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPatternParameters) == sizeof(WebCore::PatternParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PatternParameters, repeatX)
        , offsetof(WebCore::PatternParameters, repeatY)
        , offsetof(WebCore::PatternParameters, patternSpaceTransform)
    >::value);

    encoder << instance.repeatX;
    encoder << instance.repeatY;
    encoder << instance.patternSpaceTransform;
}

void ArgumentCoder<WebCore::PatternParameters>::encode(StreamConnectionEncoder& encoder, const WebCore::PatternParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.repeatX)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.repeatY)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.patternSpaceTransform)>, WebCore::AffineTransform>);
    struct ShouldBeSameSizeAsPatternParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PatternParameters>, false> {
        bool repeatX;
        bool repeatY;
        WebCore::AffineTransform patternSpaceTransform;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPatternParameters) == sizeof(WebCore::PatternParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PatternParameters, repeatX)
        , offsetof(WebCore::PatternParameters, repeatY)
        , offsetof(WebCore::PatternParameters, patternSpaceTransform)
    >::value);

    encoder << instance.repeatX;
    encoder << instance.repeatY;
    encoder << instance.patternSpaceTransform;
}

std::optional<WebCore::PatternParameters> ArgumentCoder<WebCore::PatternParameters>::decode(Decoder& decoder)
{
    auto repeatX = decoder.decode<bool>();
    auto repeatY = decoder.decode<bool>();
    auto patternSpaceTransform = decoder.decode<WebCore::AffineTransform>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PatternParameters {
            WTFMove(*repeatX),
            WTFMove(*repeatY),
            WTFMove(*patternSpaceTransform)
        }
    };
}

void ArgumentCoder<WebCore::ThreadSafeDataBufferImpl>::encode(Encoder& encoder, const WebCore::ThreadSafeDataBufferImpl& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_data)>, Vector<uint8_t>>);
    struct ShouldBeSameSizeAsThreadSafeDataBufferImpl : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ThreadSafeDataBufferImpl>, true> {
        Vector<uint8_t> m_data;
    };
    static_assert(sizeof(ShouldBeSameSizeAsThreadSafeDataBufferImpl) == sizeof(WebCore::ThreadSafeDataBufferImpl));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ThreadSafeDataBufferImpl, m_data)
    >::value);

    encoder << instance.m_data;
}

std::optional<Ref<WebCore::ThreadSafeDataBufferImpl>> ArgumentCoder<WebCore::ThreadSafeDataBufferImpl>::decode(Decoder& decoder)
{
    auto m_data = decoder.decode<Vector<uint8_t>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ThreadSafeDataBufferImpl::create(
            WTFMove(*m_data)
        )
    };
}

void ArgumentCoder<WebCore::ThreadSafeDataBuffer>::encode(Encoder& encoder, const WebCore::ThreadSafeDataBuffer& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_impl)>, RefPtr<WebCore::ThreadSafeDataBufferImpl>>);
    struct ShouldBeSameSizeAsThreadSafeDataBuffer : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ThreadSafeDataBuffer>, false> {
        RefPtr<WebCore::ThreadSafeDataBufferImpl> m_impl;
    };
    static_assert(sizeof(ShouldBeSameSizeAsThreadSafeDataBuffer) == sizeof(WebCore::ThreadSafeDataBuffer));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ThreadSafeDataBuffer, m_impl)
    >::value);

    encoder << instance.m_impl;
}

std::optional<WebCore::ThreadSafeDataBuffer> ArgumentCoder<WebCore::ThreadSafeDataBuffer>::decode(Decoder& decoder)
{
    auto m_impl = decoder.decode<RefPtr<WebCore::ThreadSafeDataBufferImpl>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ThreadSafeDataBuffer {
            WTFMove(*m_impl)
        }
    };
}

#if ENABLE(GPU_PROCESS) && ENABLE(WEBGL)
void ArgumentCoder<WebCore::GraphicsContextGLAttributes>::encode(Encoder& encoder, const WebCore::GraphicsContextGLAttributes& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.alpha)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depth)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stencil)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.antialias)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.premultipliedAlpha)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.preserveDrawingBuffer)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.powerPreference)>, WebCore::GraphicsContextGLPowerPreference>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isWebGL2)>, bool>);
#if PLATFORM(MAC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.windowGPUID)>, uint64_t>);
#endif
#if ENABLE(WEBXR)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.xrCompatible)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.failContextCreationForTesting)>, WebCore::GraphicsContextGLSimulatedCreationFailure>);
    struct ShouldBeSameSizeAsGraphicsContextGLAttributes : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::GraphicsContextGLAttributes>, false> {
        bool alpha;
        bool depth;
        bool stencil;
        bool antialias;
        bool premultipliedAlpha;
        bool preserveDrawingBuffer;
        WebCore::GraphicsContextGLPowerPreference powerPreference;
        bool isWebGL2;
#if PLATFORM(MAC)
        uint64_t windowGPUID;
#endif
#if ENABLE(WEBXR)
        bool xrCompatible;
#endif
        WebCore::GraphicsContextGLSimulatedCreationFailure failContextCreationForTesting;
    };
    static_assert(sizeof(ShouldBeSameSizeAsGraphicsContextGLAttributes) == sizeof(WebCore::GraphicsContextGLAttributes));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::GraphicsContextGLAttributes, alpha)
        , offsetof(WebCore::GraphicsContextGLAttributes, depth)
        , offsetof(WebCore::GraphicsContextGLAttributes, stencil)
        , offsetof(WebCore::GraphicsContextGLAttributes, antialias)
        , offsetof(WebCore::GraphicsContextGLAttributes, premultipliedAlpha)
        , offsetof(WebCore::GraphicsContextGLAttributes, preserveDrawingBuffer)
        , offsetof(WebCore::GraphicsContextGLAttributes, powerPreference)
        , offsetof(WebCore::GraphicsContextGLAttributes, isWebGL2)
#if PLATFORM(MAC)
        , offsetof(WebCore::GraphicsContextGLAttributes, windowGPUID)
#endif
#if ENABLE(WEBXR)
        , offsetof(WebCore::GraphicsContextGLAttributes, xrCompatible)
#endif
        , offsetof(WebCore::GraphicsContextGLAttributes, failContextCreationForTesting)
    >::value);

    encoder << instance.alpha;
    encoder << instance.depth;
    encoder << instance.stencil;
    encoder << instance.antialias;
    encoder << instance.premultipliedAlpha;
    encoder << instance.preserveDrawingBuffer;
    encoder << instance.powerPreference;
    encoder << instance.isWebGL2;
#if PLATFORM(MAC)
    encoder << instance.windowGPUID;
#endif
#if ENABLE(WEBXR)
    encoder << instance.xrCompatible;
#endif
    encoder << instance.failContextCreationForTesting;
}

std::optional<WebCore::GraphicsContextGLAttributes> ArgumentCoder<WebCore::GraphicsContextGLAttributes>::decode(Decoder& decoder)
{
    auto alpha = decoder.decode<bool>();
    auto depth = decoder.decode<bool>();
    auto stencil = decoder.decode<bool>();
    auto antialias = decoder.decode<bool>();
    auto premultipliedAlpha = decoder.decode<bool>();
    auto preserveDrawingBuffer = decoder.decode<bool>();
    auto powerPreference = decoder.decode<WebCore::GraphicsContextGLPowerPreference>();
    auto isWebGL2 = decoder.decode<bool>();
#if PLATFORM(MAC)
    auto windowGPUID = decoder.decode<uint64_t>();
#endif
#if ENABLE(WEBXR)
    auto xrCompatible = decoder.decode<bool>();
#endif
    auto failContextCreationForTesting = decoder.decode<WebCore::GraphicsContextGLSimulatedCreationFailure>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::GraphicsContextGLAttributes {
            WTFMove(*alpha),
            WTFMove(*depth),
            WTFMove(*stencil),
            WTFMove(*antialias),
            WTFMove(*premultipliedAlpha),
            WTFMove(*preserveDrawingBuffer),
            WTFMove(*powerPreference),
            WTFMove(*isWebGL2),
#if PLATFORM(MAC)
            WTFMove(*windowGPUID),
#endif
#if ENABLE(WEBXR)
            WTFMove(*xrCompatible),
#endif
            WTFMove(*failContextCreationForTesting)
        }
    };
}

#endif

enum class WebCore_TimingFunction_Subclass : IPC::EncodedVariantIndex {
    LinearTimingFunction
    , CubicBezierTimingFunction
    , StepsTimingFunction
    , SpringTimingFunction
};

IGNORE_WARNINGS_BEGIN("missing-noreturn")
void ArgumentCoder<WebCore::TimingFunction>::encode(Encoder& encoder, const WebCore::TimingFunction& instance)
{
    if (auto* subclass = dynamicDowncast<WebCore::LinearTimingFunction>(instance)) {
        encoder << WebCore_TimingFunction_Subclass::LinearTimingFunction;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::CubicBezierTimingFunction>(instance)) {
        encoder << WebCore_TimingFunction_Subclass::CubicBezierTimingFunction;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::StepsTimingFunction>(instance)) {
        encoder << WebCore_TimingFunction_Subclass::StepsTimingFunction;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::SpringTimingFunction>(instance)) {
        encoder << WebCore_TimingFunction_Subclass::SpringTimingFunction;
        encoder << *subclass;
        return;
    }
    ASSERT_NOT_REACHED();
}
IGNORE_WARNINGS_END

std::optional<Ref<WebCore::TimingFunction>> ArgumentCoder<WebCore::TimingFunction>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore_TimingFunction_Subclass>();
    UNUSED_PARAM(type);
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (type == WebCore_TimingFunction_Subclass::LinearTimingFunction) {
        auto result = decoder.decode<Ref<WebCore::LinearTimingFunction>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_TimingFunction_Subclass::CubicBezierTimingFunction) {
        auto result = decoder.decode<Ref<WebCore::CubicBezierTimingFunction>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_TimingFunction_Subclass::StepsTimingFunction) {
        auto result = decoder.decode<Ref<WebCore::StepsTimingFunction>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_TimingFunction_Subclass::SpringTimingFunction) {
        auto result = decoder.decode<Ref<WebCore::SpringTimingFunction>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    ASSERT_NOT_REACHED();
    return std::nullopt;
}

enum class WebCore_TransformOperation_Subclass : IPC::EncodedVariantIndex {
    TranslateTransformOperation
    , ScaleTransformOperation
    , RotateTransformOperation
    , SkewTransformOperation
    , MatrixTransformOperation
    , Matrix3DTransformOperation
    , PerspectiveTransformOperation
    , IdentityTransformOperation
};

IGNORE_WARNINGS_BEGIN("missing-noreturn")
void ArgumentCoder<WebCore::TransformOperation>::encode(Encoder& encoder, const WebCore::TransformOperation& instance)
{
    if (auto* subclass = dynamicDowncast<WebCore::TranslateTransformOperation>(instance)) {
        encoder << WebCore_TransformOperation_Subclass::TranslateTransformOperation;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::ScaleTransformOperation>(instance)) {
        encoder << WebCore_TransformOperation_Subclass::ScaleTransformOperation;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::RotateTransformOperation>(instance)) {
        encoder << WebCore_TransformOperation_Subclass::RotateTransformOperation;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::SkewTransformOperation>(instance)) {
        encoder << WebCore_TransformOperation_Subclass::SkewTransformOperation;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::MatrixTransformOperation>(instance)) {
        encoder << WebCore_TransformOperation_Subclass::MatrixTransformOperation;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::Matrix3DTransformOperation>(instance)) {
        encoder << WebCore_TransformOperation_Subclass::Matrix3DTransformOperation;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::PerspectiveTransformOperation>(instance)) {
        encoder << WebCore_TransformOperation_Subclass::PerspectiveTransformOperation;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::IdentityTransformOperation>(instance)) {
        encoder << WebCore_TransformOperation_Subclass::IdentityTransformOperation;
        encoder << *subclass;
        return;
    }
    ASSERT_NOT_REACHED();
}
IGNORE_WARNINGS_END

std::optional<Ref<WebCore::TransformOperation>> ArgumentCoder<WebCore::TransformOperation>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore_TransformOperation_Subclass>();
    UNUSED_PARAM(type);
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (type == WebCore_TransformOperation_Subclass::TranslateTransformOperation) {
        auto result = decoder.decode<Ref<WebCore::TranslateTransformOperation>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_TransformOperation_Subclass::ScaleTransformOperation) {
        auto result = decoder.decode<Ref<WebCore::ScaleTransformOperation>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_TransformOperation_Subclass::RotateTransformOperation) {
        auto result = decoder.decode<Ref<WebCore::RotateTransformOperation>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_TransformOperation_Subclass::SkewTransformOperation) {
        auto result = decoder.decode<Ref<WebCore::SkewTransformOperation>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_TransformOperation_Subclass::MatrixTransformOperation) {
        auto result = decoder.decode<Ref<WebCore::MatrixTransformOperation>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_TransformOperation_Subclass::Matrix3DTransformOperation) {
        auto result = decoder.decode<Ref<WebCore::Matrix3DTransformOperation>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_TransformOperation_Subclass::PerspectiveTransformOperation) {
        auto result = decoder.decode<Ref<WebCore::PerspectiveTransformOperation>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_TransformOperation_Subclass::IdentityTransformOperation) {
        auto result = decoder.decode<Ref<WebCore::IdentityTransformOperation>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    ASSERT_NOT_REACHED();
    return std::nullopt;
}

void ArgumentCoder<WebCore::LengthPoint>::encode(Encoder& encoder, const WebCore::LengthPoint& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.x)>, WebCore::Length>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.y)>, WebCore::Length>);
    struct ShouldBeSameSizeAsLengthPoint : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::LengthPoint>, false> {
        WebCore::Length x;
        WebCore::Length y;
    };
    static_assert(sizeof(ShouldBeSameSizeAsLengthPoint) == sizeof(WebCore::LengthPoint));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::LengthPoint, x)
        , offsetof(WebCore::LengthPoint, y)
    >::value);

    encoder << instance.x;
    encoder << instance.y;
}

std::optional<WebCore::LengthPoint> ArgumentCoder<WebCore::LengthPoint>::decode(Decoder& decoder)
{
    auto x = decoder.decode<WebCore::Length>();
    auto y = decoder.decode<WebCore::Length>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::LengthPoint {
            WTFMove(*x),
            WTFMove(*y)
        }
    };
}

void ArgumentCoder<WebCore::LengthSize>::encode(Encoder& encoder, const WebCore::LengthSize& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.width)>, WebCore::Length>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.height)>, WebCore::Length>);
    struct ShouldBeSameSizeAsLengthSize : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::LengthSize>, false> {
        WebCore::Length width;
        WebCore::Length height;
    };
    static_assert(sizeof(ShouldBeSameSizeAsLengthSize) == sizeof(WebCore::LengthSize));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::LengthSize, width)
        , offsetof(WebCore::LengthSize, height)
    >::value);

    encoder << instance.width;
    encoder << instance.height;
}

std::optional<WebCore::LengthSize> ArgumentCoder<WebCore::LengthSize>::decode(Decoder& decoder)
{
    auto width = decoder.decode<WebCore::Length>();
    auto height = decoder.decode<WebCore::Length>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::LengthSize {
            WTFMove(*width),
            WTFMove(*height)
        }
    };
}

void ArgumentCoder<WebCore::SVGPathByteStream>::encode(Encoder& encoder, const WebCore::SVGPathByteStream& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bytes())>, Vector<unsigned char>>);

    encoder << instance.bytes();
}

std::optional<WebCore::SVGPathByteStream> ArgumentCoder<WebCore::SVGPathByteStream>::decode(Decoder& decoder)
{
    auto bytes = decoder.decode<Vector<unsigned char>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SVGPathByteStream {
            WTFMove(*bytes)
        }
    };
}

void ArgumentCoder<WebCore::Style::Angle<WebCore::CSS::Nonnegative>>::encode(Encoder& encoder, const WebCore::Style::Angle<WebCore::CSS::Nonnegative>& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, double>);
    struct ShouldBeSameSizeAsAngle_WebCore_CSS_Nonnegative_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::Angle<WebCore::CSS::Nonnegative>>, false> {
        double value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsAngle_WebCore_CSS_Nonnegative_) == sizeof(WebCore::Style::Angle<WebCore::CSS::Nonnegative>));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::Angle<WebCore::CSS::Nonnegative>, value)
    >::value);

    encoder << instance.value;
}

std::optional<WebCore::Style::Angle<WebCore::CSS::Nonnegative>> ArgumentCoder<WebCore::Style::Angle<WebCore::CSS::Nonnegative>>::decode(Decoder& decoder)
{
    auto value = decoder.decode<double>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::Angle<WebCore::CSS::Nonnegative> {
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebCore::Style::Angle<WebCore::CSS::All>>::encode(Encoder& encoder, const WebCore::Style::Angle<WebCore::CSS::All>& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, double>);
    struct ShouldBeSameSizeAsAngle_WebCore_CSS_All_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::Angle<WebCore::CSS::All>>, false> {
        double value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsAngle_WebCore_CSS_All_) == sizeof(WebCore::Style::Angle<WebCore::CSS::All>));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::Angle<WebCore::CSS::All>, value)
    >::value);

    encoder << instance.value;
}

std::optional<WebCore::Style::Angle<WebCore::CSS::All>> ArgumentCoder<WebCore::Style::Angle<WebCore::CSS::All>>::decode(Decoder& decoder)
{
    auto value = decoder.decode<double>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::Angle<WebCore::CSS::All> {
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebCore::Style::AngleAllFloat>::encode(Encoder& encoder, const WebCore::Style::AngleAllFloat& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, float>);
    struct ShouldBeSameSizeAsAngleAllFloat : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::AngleAllFloat>, false> {
        float value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsAngleAllFloat) == sizeof(WebCore::Style::AngleAllFloat));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::AngleAllFloat, value)
    >::value);

    encoder << instance.value;
}

std::optional<WebCore::Style::AngleAllFloat> ArgumentCoder<WebCore::Style::AngleAllFloat>::decode(Decoder& decoder)
{
    auto value = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::AngleAllFloat {
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebCore::Style::PercentageNonnegativeFloat>::encode(Encoder& encoder, const WebCore::Style::PercentageNonnegativeFloat& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, float>);
    struct ShouldBeSameSizeAsPercentageNonnegativeFloat : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::PercentageNonnegativeFloat>, false> {
        float value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPercentageNonnegativeFloat) == sizeof(WebCore::Style::PercentageNonnegativeFloat));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::PercentageNonnegativeFloat, value)
    >::value);

    encoder << instance.value;
}

std::optional<WebCore::Style::PercentageNonnegativeFloat> ArgumentCoder<WebCore::Style::PercentageNonnegativeFloat>::decode(Decoder& decoder)
{
    auto value = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::PercentageNonnegativeFloat {
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebCore::Style::PercentageAllFloat>::encode(Encoder& encoder, const WebCore::Style::PercentageAllFloat& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, float>);
    struct ShouldBeSameSizeAsPercentageAllFloat : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::PercentageAllFloat>, false> {
        float value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPercentageAllFloat) == sizeof(WebCore::Style::PercentageAllFloat));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::PercentageAllFloat, value)
    >::value);

    encoder << instance.value;
}

std::optional<WebCore::Style::PercentageAllFloat> ArgumentCoder<WebCore::Style::PercentageAllFloat>::decode(Decoder& decoder)
{
    auto value = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::PercentageAllFloat {
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebCore::Style::LengthNonnegative>::encode(Encoder& encoder, const WebCore::Style::LengthNonnegative& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, float>);
    struct ShouldBeSameSizeAsLengthNonnegative : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::LengthNonnegative>, false> {
        float value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsLengthNonnegative) == sizeof(WebCore::Style::LengthNonnegative));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::LengthNonnegative, value)
    >::value);

    encoder << instance.value;
}

std::optional<WebCore::Style::LengthNonnegative> ArgumentCoder<WebCore::Style::LengthNonnegative>::decode(Decoder& decoder)
{
    auto value = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::LengthNonnegative {
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebCore::Style::Length<WebCore::CSS::All>>::encode(Encoder& encoder, const WebCore::Style::Length<WebCore::CSS::All>& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, float>);
    struct ShouldBeSameSizeAsLength_WebCore_CSS_All_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::Length<WebCore::CSS::All>>, false> {
        float value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsLength_WebCore_CSS_All_) == sizeof(WebCore::Style::Length<WebCore::CSS::All>));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::Length<WebCore::CSS::All>, value)
    >::value);

    encoder << instance.value;
}

std::optional<WebCore::Style::Length<WebCore::CSS::All>> ArgumentCoder<WebCore::Style::Length<WebCore::CSS::All>>::decode(Decoder& decoder)
{
    auto value = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::Length<WebCore::CSS::All> {
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebCore::Style::Percentage<WebCore::CSS::Nonnegative>>::encode(Encoder& encoder, const WebCore::Style::Percentage<WebCore::CSS::Nonnegative>& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, double>);
    struct ShouldBeSameSizeAsPercentage_WebCore_CSS_Nonnegative_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::Percentage<WebCore::CSS::Nonnegative>>, false> {
        double value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPercentage_WebCore_CSS_Nonnegative_) == sizeof(WebCore::Style::Percentage<WebCore::CSS::Nonnegative>));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::Percentage<WebCore::CSS::Nonnegative>, value)
    >::value);

    encoder << instance.value;
}

std::optional<WebCore::Style::Percentage<WebCore::CSS::Nonnegative>> ArgumentCoder<WebCore::Style::Percentage<WebCore::CSS::Nonnegative>>::decode(Decoder& decoder)
{
    auto value = decoder.decode<double>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::Percentage<WebCore::CSS::Nonnegative> {
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebCore::Style::Percentage<WebCore::CSS::All>>::encode(Encoder& encoder, const WebCore::Style::Percentage<WebCore::CSS::All>& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, double>);
    struct ShouldBeSameSizeAsPercentage_WebCore_CSS_All_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::Percentage<WebCore::CSS::All>>, false> {
        double value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPercentage_WebCore_CSS_All_) == sizeof(WebCore::Style::Percentage<WebCore::CSS::All>));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::Percentage<WebCore::CSS::All>, value)
    >::value);

    encoder << instance.value;
}

std::optional<WebCore::Style::Percentage<WebCore::CSS::All>> ArgumentCoder<WebCore::Style::Percentage<WebCore::CSS::All>>::decode(Decoder& decoder)
{
    auto value = decoder.decode<double>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::Percentage<WebCore::CSS::All> {
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebCore::Style::LengthPercentage<WebCore::CSS::All>>::encode(Encoder& encoder, const WebCore::Style::LengthPercentage<WebCore::CSS::All>& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ipcData())>, Variant<WebCore::Style::LengthAll, WebCore::Style::PercentageAllFloat>>);

    encoder << instance.ipcData();
}

std::optional<WebCore::Style::LengthPercentage<WebCore::CSS::All>> ArgumentCoder<WebCore::Style::LengthPercentage<WebCore::CSS::All>>::decode(Decoder& decoder)
{
    auto ipcData = decoder.decode<Variant<WebCore::Style::LengthAll, WebCore::Style::PercentageAllFloat>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::LengthPercentage<WebCore::CSS::All> {
            WTFMove(*ipcData)
        }
    };
}

void ArgumentCoder<WebCore::Style::LengthPercentage<WebCore::CSS::Nonnegative>>::encode(Encoder& encoder, const WebCore::Style::LengthPercentage<WebCore::CSS::Nonnegative>& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ipcData())>, Variant<WebCore::Style::LengthNonnegative, WebCore::Style::PercentageNonnegativeFloat>>);

    encoder << instance.ipcData();
}

std::optional<WebCore::Style::LengthPercentage<WebCore::CSS::Nonnegative>> ArgumentCoder<WebCore::Style::LengthPercentage<WebCore::CSS::Nonnegative>>::decode(Decoder& decoder)
{
    auto ipcData = decoder.decode<Variant<WebCore::Style::LengthNonnegative, WebCore::Style::PercentageNonnegativeFloat>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::LengthPercentage<WebCore::CSS::Nonnegative> {
            WTFMove(*ipcData)
        }
    };
}

void ArgumentCoder<WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageNonnegative>>::encode(Encoder& encoder, const WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageNonnegative>& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, std::array<WebCore::Style::LengthPercentageNonnegative, 2>>);
    struct ShouldBeSameSizeAsSpaceSeparatedPair_WebCore_Style_LengthPercentageNonnegative_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageNonnegative>>, false> {
        std::array<WebCore::Style::LengthPercentageNonnegative, 2> value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSpaceSeparatedPair_WebCore_Style_LengthPercentageNonnegative_) == sizeof(WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageNonnegative>));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageNonnegative>, value)
    >::value);

    encoder << instance.value;
}

std::optional<WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageNonnegative>> ArgumentCoder<WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageNonnegative>>::decode(Decoder& decoder)
{
    auto value = decoder.decode<std::array<WebCore::Style::LengthPercentageNonnegative, 2>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageNonnegative> {
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageAll>>::encode(Encoder& encoder, const WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageAll>& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, std::array<WebCore::Style::LengthPercentageAll, 2>>);
    struct ShouldBeSameSizeAsSpaceSeparatedPair_WebCore_Style_LengthPercentageAll_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageAll>>, false> {
        std::array<WebCore::Style::LengthPercentageAll, 2> value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSpaceSeparatedPair_WebCore_Style_LengthPercentageAll_) == sizeof(WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageAll>));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageAll>, value)
    >::value);

    encoder << instance.value;
}

std::optional<WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageAll>> ArgumentCoder<WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageAll>>::decode(Decoder& decoder)
{
    auto value = decoder.decode<std::array<WebCore::Style::LengthPercentageAll, 2>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageAll> {
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebCore::SpaceSeparatedPair<WebCore::Style::CoordinatePair>>::encode(Encoder& encoder, const WebCore::SpaceSeparatedPair<WebCore::Style::CoordinatePair>& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, std::array<WebCore::Style::CoordinatePair, 2>>);
    struct ShouldBeSameSizeAsSpaceSeparatedPair_WebCore_Style_CoordinatePair_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SpaceSeparatedPair<WebCore::Style::CoordinatePair>>, false> {
        std::array<WebCore::Style::CoordinatePair, 2> value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSpaceSeparatedPair_WebCore_Style_CoordinatePair_) == sizeof(WebCore::SpaceSeparatedPair<WebCore::Style::CoordinatePair>));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SpaceSeparatedPair<WebCore::Style::CoordinatePair>, value)
    >::value);

    encoder << instance.value;
}

std::optional<WebCore::SpaceSeparatedPair<WebCore::Style::CoordinatePair>> ArgumentCoder<WebCore::SpaceSeparatedPair<WebCore::Style::CoordinatePair>>::decode(Decoder& decoder)
{
    auto value = decoder.decode<std::array<WebCore::Style::CoordinatePair, 2>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SpaceSeparatedPair<WebCore::Style::CoordinatePair> {
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebCore::SpaceSeparatedSize<WebCore::Style::LengthPercentageNonnegative>>::encode(Encoder& encoder, const WebCore::SpaceSeparatedSize<WebCore::Style::LengthPercentageNonnegative>& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageNonnegative>>);
    struct ShouldBeSameSizeAsSpaceSeparatedSize_WebCore_Style_LengthPercentageNonnegative_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SpaceSeparatedSize<WebCore::Style::LengthPercentageNonnegative>>, false> {
        WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageNonnegative> value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSpaceSeparatedSize_WebCore_Style_LengthPercentageNonnegative_) == sizeof(WebCore::SpaceSeparatedSize<WebCore::Style::LengthPercentageNonnegative>));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SpaceSeparatedSize<WebCore::Style::LengthPercentageNonnegative>, value)
    >::value);

    encoder << instance.value;
}

std::optional<WebCore::SpaceSeparatedSize<WebCore::Style::LengthPercentageNonnegative>> ArgumentCoder<WebCore::SpaceSeparatedSize<WebCore::Style::LengthPercentageNonnegative>>::decode(Decoder& decoder)
{
    auto value = decoder.decode<WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageNonnegative>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SpaceSeparatedSize<WebCore::Style::LengthPercentageNonnegative> {
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebCore::SpaceSeparatedSize<WebCore::Style::LengthPercentageAll>>::encode(Encoder& encoder, const WebCore::SpaceSeparatedSize<WebCore::Style::LengthPercentageAll>& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageAll>>);
    struct ShouldBeSameSizeAsSpaceSeparatedSize_WebCore_Style_LengthPercentageAll_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SpaceSeparatedSize<WebCore::Style::LengthPercentageAll>>, false> {
        WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageAll> value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSpaceSeparatedSize_WebCore_Style_LengthPercentageAll_) == sizeof(WebCore::SpaceSeparatedSize<WebCore::Style::LengthPercentageAll>));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SpaceSeparatedSize<WebCore::Style::LengthPercentageAll>, value)
    >::value);

    encoder << instance.value;
}

std::optional<WebCore::SpaceSeparatedSize<WebCore::Style::LengthPercentageAll>> ArgumentCoder<WebCore::SpaceSeparatedSize<WebCore::Style::LengthPercentageAll>>::decode(Decoder& decoder)
{
    auto value = decoder.decode<WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageAll>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SpaceSeparatedSize<WebCore::Style::LengthPercentageAll> {
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebCore::SpaceSeparatedPoint<WebCore::Style::LengthPercentageNonnegative>>::encode(Encoder& encoder, const WebCore::SpaceSeparatedPoint<WebCore::Style::LengthPercentageNonnegative>& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageNonnegative>>);
    struct ShouldBeSameSizeAsSpaceSeparatedPoint_WebCore_Style_LengthPercentageNonnegative_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SpaceSeparatedPoint<WebCore::Style::LengthPercentageNonnegative>>, false> {
        WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageNonnegative> value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSpaceSeparatedPoint_WebCore_Style_LengthPercentageNonnegative_) == sizeof(WebCore::SpaceSeparatedPoint<WebCore::Style::LengthPercentageNonnegative>));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SpaceSeparatedPoint<WebCore::Style::LengthPercentageNonnegative>, value)
    >::value);

    encoder << instance.value;
}

std::optional<WebCore::SpaceSeparatedPoint<WebCore::Style::LengthPercentageNonnegative>> ArgumentCoder<WebCore::SpaceSeparatedPoint<WebCore::Style::LengthPercentageNonnegative>>::decode(Decoder& decoder)
{
    auto value = decoder.decode<WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageNonnegative>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SpaceSeparatedPoint<WebCore::Style::LengthPercentageNonnegative> {
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebCore::SpaceSeparatedPoint<WebCore::Style::LengthPercentageAll>>::encode(Encoder& encoder, const WebCore::SpaceSeparatedPoint<WebCore::Style::LengthPercentageAll>& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageAll>>);
    struct ShouldBeSameSizeAsSpaceSeparatedPoint_WebCore_Style_LengthPercentageAll_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SpaceSeparatedPoint<WebCore::Style::LengthPercentageAll>>, false> {
        WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageAll> value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSpaceSeparatedPoint_WebCore_Style_LengthPercentageAll_) == sizeof(WebCore::SpaceSeparatedPoint<WebCore::Style::LengthPercentageAll>));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SpaceSeparatedPoint<WebCore::Style::LengthPercentageAll>, value)
    >::value);

    encoder << instance.value;
}

std::optional<WebCore::SpaceSeparatedPoint<WebCore::Style::LengthPercentageAll>> ArgumentCoder<WebCore::SpaceSeparatedPoint<WebCore::Style::LengthPercentageAll>>::decode(Decoder& decoder)
{
    auto value = decoder.decode<WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageAll>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SpaceSeparatedPoint<WebCore::Style::LengthPercentageAll> {
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebCore::MinimallySerializingSpaceSeparatedSize<WebCore::Style::LengthPercentageNonnegative>>::encode(Encoder& encoder, const WebCore::MinimallySerializingSpaceSeparatedSize<WebCore::Style::LengthPercentageNonnegative>& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageNonnegative>>);
    struct ShouldBeSameSizeAsMinimallySerializingSpaceSeparatedSize_WebCore_Style_LengthPercentageNonnegative_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MinimallySerializingSpaceSeparatedSize<WebCore::Style::LengthPercentageNonnegative>>, false> {
        WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageNonnegative> value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMinimallySerializingSpaceSeparatedSize_WebCore_Style_LengthPercentageNonnegative_) == sizeof(WebCore::MinimallySerializingSpaceSeparatedSize<WebCore::Style::LengthPercentageNonnegative>));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MinimallySerializingSpaceSeparatedSize<WebCore::Style::LengthPercentageNonnegative>, value)
    >::value);

    encoder << instance.value;
}

std::optional<WebCore::MinimallySerializingSpaceSeparatedSize<WebCore::Style::LengthPercentageNonnegative>> ArgumentCoder<WebCore::MinimallySerializingSpaceSeparatedSize<WebCore::Style::LengthPercentageNonnegative>>::decode(Decoder& decoder)
{
    auto value = decoder.decode<WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageNonnegative>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MinimallySerializingSpaceSeparatedSize<WebCore::Style::LengthPercentageNonnegative> {
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebCore::MinimallySerializingSpaceSeparatedSize<WebCore::Style::LengthPercentageAll>>::encode(Encoder& encoder, const WebCore::MinimallySerializingSpaceSeparatedSize<WebCore::Style::LengthPercentageAll>& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageAll>>);
    struct ShouldBeSameSizeAsMinimallySerializingSpaceSeparatedSize_WebCore_Style_LengthPercentageAll_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MinimallySerializingSpaceSeparatedSize<WebCore::Style::LengthPercentageAll>>, false> {
        WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageAll> value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMinimallySerializingSpaceSeparatedSize_WebCore_Style_LengthPercentageAll_) == sizeof(WebCore::MinimallySerializingSpaceSeparatedSize<WebCore::Style::LengthPercentageAll>));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MinimallySerializingSpaceSeparatedSize<WebCore::Style::LengthPercentageAll>, value)
    >::value);

    encoder << instance.value;
}

std::optional<WebCore::MinimallySerializingSpaceSeparatedSize<WebCore::Style::LengthPercentageAll>> ArgumentCoder<WebCore::MinimallySerializingSpaceSeparatedSize<WebCore::Style::LengthPercentageAll>>::decode(Decoder& decoder)
{
    auto value = decoder.decode<WebCore::SpaceSeparatedPair<WebCore::Style::LengthPercentageAll>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MinimallySerializingSpaceSeparatedSize<WebCore::Style::LengthPercentageAll> {
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebCore::CommaSeparatedVector<WebCore::Style::LengthPercentageSpaceSeparatedPointAll>>::encode(Encoder& encoder, const WebCore::CommaSeparatedVector<WebCore::Style::LengthPercentageSpaceSeparatedPointAll>& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, Vector<WebCore::Style::LengthPercentageSpaceSeparatedPointAll>>);
    struct ShouldBeSameSizeAsCommaSeparatedVector_WebCore_Style_LengthPercentageSpaceSeparatedPointAll_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::CommaSeparatedVector<WebCore::Style::LengthPercentageSpaceSeparatedPointAll>>, false> {
        Vector<WebCore::Style::LengthPercentageSpaceSeparatedPointAll> value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCommaSeparatedVector_WebCore_Style_LengthPercentageSpaceSeparatedPointAll_) == sizeof(WebCore::CommaSeparatedVector<WebCore::Style::LengthPercentageSpaceSeparatedPointAll>));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::CommaSeparatedVector<WebCore::Style::LengthPercentageSpaceSeparatedPointAll>, value)
    >::value);

    encoder << instance.value;
}

std::optional<WebCore::CommaSeparatedVector<WebCore::Style::LengthPercentageSpaceSeparatedPointAll>> ArgumentCoder<WebCore::CommaSeparatedVector<WebCore::Style::LengthPercentageSpaceSeparatedPointAll>>::decode(Decoder& decoder)
{
    auto value = decoder.decode<Vector<WebCore::Style::LengthPercentageSpaceSeparatedPointAll>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CommaSeparatedVector<WebCore::Style::LengthPercentageSpaceSeparatedPointAll> {
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebCore::CommaSeparatedVector<WebCore::Style::LengthPercentageSpaceSeparatedPointNonnegative>>::encode(Encoder& encoder, const WebCore::CommaSeparatedVector<WebCore::Style::LengthPercentageSpaceSeparatedPointNonnegative>& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, Vector<WebCore::Style::LengthPercentageSpaceSeparatedPointNonnegative>>);
    struct ShouldBeSameSizeAsCommaSeparatedVector_WebCore_Style_LengthPercentageSpaceSeparatedPointNonnegative_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::CommaSeparatedVector<WebCore::Style::LengthPercentageSpaceSeparatedPointNonnegative>>, false> {
        Vector<WebCore::Style::LengthPercentageSpaceSeparatedPointNonnegative> value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCommaSeparatedVector_WebCore_Style_LengthPercentageSpaceSeparatedPointNonnegative_) == sizeof(WebCore::CommaSeparatedVector<WebCore::Style::LengthPercentageSpaceSeparatedPointNonnegative>));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::CommaSeparatedVector<WebCore::Style::LengthPercentageSpaceSeparatedPointNonnegative>, value)
    >::value);

    encoder << instance.value;
}

std::optional<WebCore::CommaSeparatedVector<WebCore::Style::LengthPercentageSpaceSeparatedPointNonnegative>> ArgumentCoder<WebCore::CommaSeparatedVector<WebCore::Style::LengthPercentageSpaceSeparatedPointNonnegative>>::decode(Decoder& decoder)
{
    auto value = decoder.decode<Vector<WebCore::Style::LengthPercentageSpaceSeparatedPointNonnegative>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CommaSeparatedVector<WebCore::Style::LengthPercentageSpaceSeparatedPointNonnegative> {
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebCore::MinimallySerializingSpaceSeparatedRectEdges<WebCore::Style::LengthPercentageAll>>::encode(Encoder& encoder, const WebCore::MinimallySerializingSpaceSeparatedRectEdges<WebCore::Style::LengthPercentageAll>& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.top())>, WebCore::Style::LengthPercentageAll>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.right())>, WebCore::Style::LengthPercentageAll>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bottom())>, WebCore::Style::LengthPercentageAll>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.left())>, WebCore::Style::LengthPercentageAll>);

    encoder << instance.top();
    encoder << instance.right();
    encoder << instance.bottom();
    encoder << instance.left();
}

std::optional<WebCore::MinimallySerializingSpaceSeparatedRectEdges<WebCore::Style::LengthPercentageAll>> ArgumentCoder<WebCore::MinimallySerializingSpaceSeparatedRectEdges<WebCore::Style::LengthPercentageAll>>::decode(Decoder& decoder)
{
    auto top = decoder.decode<WebCore::Style::LengthPercentageAll>();
    auto right = decoder.decode<WebCore::Style::LengthPercentageAll>();
    auto bottom = decoder.decode<WebCore::Style::LengthPercentageAll>();
    auto left = decoder.decode<WebCore::Style::LengthPercentageAll>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MinimallySerializingSpaceSeparatedRectEdges<WebCore::Style::LengthPercentageAll> {
            WTFMove(*top),
            WTFMove(*right),
            WTFMove(*bottom),
            WTFMove(*left)
        }
    };
}

void ArgumentCoder<WebCore::CommaSeparatedVector<WebCore::Style::ShapeCommand>>::encode(Encoder& encoder, const WebCore::CommaSeparatedVector<WebCore::Style::ShapeCommand>& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, Vector<WebCore::Style::ShapeCommand>>);
    struct ShouldBeSameSizeAsCommaSeparatedVector_WebCore_Style_ShapeCommand_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::CommaSeparatedVector<WebCore::Style::ShapeCommand>>, false> {
        Vector<WebCore::Style::ShapeCommand> value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCommaSeparatedVector_WebCore_Style_ShapeCommand_) == sizeof(WebCore::CommaSeparatedVector<WebCore::Style::ShapeCommand>));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::CommaSeparatedVector<WebCore::Style::ShapeCommand>, value)
    >::value);

    encoder << instance.value;
}

std::optional<WebCore::CommaSeparatedVector<WebCore::Style::ShapeCommand>> ArgumentCoder<WebCore::CommaSeparatedVector<WebCore::Style::ShapeCommand>>::decode(Decoder& decoder)
{
    auto value = decoder.decode<Vector<WebCore::Style::ShapeCommand>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CommaSeparatedVector<WebCore::Style::ShapeCommand> {
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebCore::Style::PositionX>::encode(Encoder& encoder, const WebCore::Style::PositionX& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ipcData())>, Variant<WebCore::Length::AutoData, WebCore::Length::NormalData, WebCore::Length::RelativeData, WebCore::Length::PercentData, WebCore::Length::FixedData, WebCore::Length::IntrinsicData, WebCore::Length::MinIntrinsicData, WebCore::Length::MinContentData, WebCore::Length::MaxContentData, WebCore::Length::FillAvailableData, WebCore::Length::FitContentData, WebCore::Length::ContentData, WebCore::Length::UndefinedData>>);

    encoder << instance.ipcData();
}

std::optional<WebCore::Style::PositionX> ArgumentCoder<WebCore::Style::PositionX>::decode(Decoder& decoder)
{
    auto ipcData = decoder.decode<Variant<WebCore::Length::AutoData, WebCore::Length::NormalData, WebCore::Length::RelativeData, WebCore::Length::PercentData, WebCore::Length::FixedData, WebCore::Length::IntrinsicData, WebCore::Length::MinIntrinsicData, WebCore::Length::MinContentData, WebCore::Length::MaxContentData, WebCore::Length::FillAvailableData, WebCore::Length::FitContentData, WebCore::Length::ContentData, WebCore::Length::UndefinedData>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::PositionX {
            WTFMove(*ipcData)
        }
    };
}

void ArgumentCoder<WebCore::Style::PositionY>::encode(Encoder& encoder, const WebCore::Style::PositionY& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ipcData())>, Variant<WebCore::Length::AutoData, WebCore::Length::NormalData, WebCore::Length::RelativeData, WebCore::Length::PercentData, WebCore::Length::FixedData, WebCore::Length::IntrinsicData, WebCore::Length::MinIntrinsicData, WebCore::Length::MinContentData, WebCore::Length::MaxContentData, WebCore::Length::FillAvailableData, WebCore::Length::FitContentData, WebCore::Length::ContentData, WebCore::Length::UndefinedData>>);

    encoder << instance.ipcData();
}

std::optional<WebCore::Style::PositionY> ArgumentCoder<WebCore::Style::PositionY>::decode(Decoder& decoder)
{
    auto ipcData = decoder.decode<Variant<WebCore::Length::AutoData, WebCore::Length::NormalData, WebCore::Length::RelativeData, WebCore::Length::PercentData, WebCore::Length::FixedData, WebCore::Length::IntrinsicData, WebCore::Length::MinIntrinsicData, WebCore::Length::MinContentData, WebCore::Length::MaxContentData, WebCore::Length::FillAvailableData, WebCore::Length::FitContentData, WebCore::Length::ContentData, WebCore::Length::UndefinedData>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::PositionY {
            WTFMove(*ipcData)
        }
    };
}

void ArgumentCoder<WebCore::Style::Position>::encode(Encoder& encoder, const WebCore::Style::Position& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.x)>, WebCore::Style::PositionX>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.y)>, WebCore::Style::PositionY>);
    struct ShouldBeSameSizeAsPosition : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::Position>, false> {
        WebCore::Style::PositionX x;
        WebCore::Style::PositionY y;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPosition) == sizeof(WebCore::Style::Position));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::Position, x)
        , offsetof(WebCore::Style::Position, y)
    >::value);

    encoder << instance.x;
    encoder << instance.y;
}

std::optional<WebCore::Style::Position> ArgumentCoder<WebCore::Style::Position>::decode(Decoder& decoder)
{
    auto x = decoder.decode<WebCore::Style::PositionX>();
    auto y = decoder.decode<WebCore::Style::PositionY>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::Position {
            WTFMove(*x),
            WTFMove(*y)
        }
    };
}

void ArgumentCoder<WebCore::Style::TwoComponentPositionHorizontal>::encode(Encoder& encoder, const WebCore::Style::TwoComponentPositionHorizontal& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, WebCore::Style::PositionX>);
    struct ShouldBeSameSizeAsTwoComponentPositionHorizontal : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::TwoComponentPositionHorizontal>, false> {
        WebCore::Style::PositionX offset;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTwoComponentPositionHorizontal) == sizeof(WebCore::Style::TwoComponentPositionHorizontal));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::TwoComponentPositionHorizontal, offset)
    >::value);

    encoder << instance.offset;
}

std::optional<WebCore::Style::TwoComponentPositionHorizontal> ArgumentCoder<WebCore::Style::TwoComponentPositionHorizontal>::decode(Decoder& decoder)
{
    auto offset = decoder.decode<WebCore::Style::PositionX>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::TwoComponentPositionHorizontal {
            WTFMove(*offset)
        }
    };
}

void ArgumentCoder<WebCore::Style::TwoComponentPositionVertical>::encode(Encoder& encoder, const WebCore::Style::TwoComponentPositionVertical& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, WebCore::Style::PositionY>);
    struct ShouldBeSameSizeAsTwoComponentPositionVertical : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::TwoComponentPositionVertical>, false> {
        WebCore::Style::PositionY offset;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTwoComponentPositionVertical) == sizeof(WebCore::Style::TwoComponentPositionVertical));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::TwoComponentPositionVertical, offset)
    >::value);

    encoder << instance.offset;
}

std::optional<WebCore::Style::TwoComponentPositionVertical> ArgumentCoder<WebCore::Style::TwoComponentPositionVertical>::decode(Decoder& decoder)
{
    auto offset = decoder.decode<WebCore::Style::PositionY>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::TwoComponentPositionVertical {
            WTFMove(*offset)
        }
    };
}

void ArgumentCoder<WebCore::Constant<WebCore::CSSValueClosestCorner>>::encode(Encoder& encoder, const WebCore::Constant<WebCore::CSSValueClosestCorner>& instance)
{
    struct ShouldBeSameSizeAsConstant_WebCore_CSSValueClosestCorner_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Constant<WebCore::CSSValueClosestCorner>>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsConstant_WebCore_CSSValueClosestCorner_) == sizeof(WebCore::Constant<WebCore::CSSValueClosestCorner>));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::Constant<WebCore::CSSValueClosestCorner>> ArgumentCoder<WebCore::Constant<WebCore::CSSValueClosestCorner>>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Constant<WebCore::CSSValueClosestCorner> {
        }
    };
}

void ArgumentCoder<WebCore::Constant<WebCore::CSSValueClosestSide>>::encode(Encoder& encoder, const WebCore::Constant<WebCore::CSSValueClosestSide>& instance)
{
    struct ShouldBeSameSizeAsConstant_WebCore_CSSValueClosestSide_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Constant<WebCore::CSSValueClosestSide>>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsConstant_WebCore_CSSValueClosestSide_) == sizeof(WebCore::Constant<WebCore::CSSValueClosestSide>));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::Constant<WebCore::CSSValueClosestSide>> ArgumentCoder<WebCore::Constant<WebCore::CSSValueClosestSide>>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Constant<WebCore::CSSValueClosestSide> {
        }
    };
}

void ArgumentCoder<WebCore::Constant<WebCore::CSSValueFarthestCorner>>::encode(Encoder& encoder, const WebCore::Constant<WebCore::CSSValueFarthestCorner>& instance)
{
    struct ShouldBeSameSizeAsConstant_WebCore_CSSValueFarthestCorner_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Constant<WebCore::CSSValueFarthestCorner>>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsConstant_WebCore_CSSValueFarthestCorner_) == sizeof(WebCore::Constant<WebCore::CSSValueFarthestCorner>));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::Constant<WebCore::CSSValueFarthestCorner>> ArgumentCoder<WebCore::Constant<WebCore::CSSValueFarthestCorner>>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Constant<WebCore::CSSValueFarthestCorner> {
        }
    };
}

void ArgumentCoder<WebCore::Constant<WebCore::CSSValueFarthestSide>>::encode(Encoder& encoder, const WebCore::Constant<WebCore::CSSValueFarthestSide>& instance)
{
    struct ShouldBeSameSizeAsConstant_WebCore_CSSValueFarthestSide_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Constant<WebCore::CSSValueFarthestSide>>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsConstant_WebCore_CSSValueFarthestSide_) == sizeof(WebCore::Constant<WebCore::CSSValueFarthestSide>));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::Constant<WebCore::CSSValueFarthestSide>> ArgumentCoder<WebCore::Constant<WebCore::CSSValueFarthestSide>>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Constant<WebCore::CSSValueFarthestSide> {
        }
    };
}

void ArgumentCoder<WebCore::Style::CircleFunction>::encode(Encoder& encoder, const WebCore::Style::CircleFunction& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.parameters)>, WebCore::Style::Circle>);
    struct ShouldBeSameSizeAsCircleFunction : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::CircleFunction>, false> {
        WebCore::Style::Circle parameters;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCircleFunction) == sizeof(WebCore::Style::CircleFunction));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::CircleFunction, parameters)
    >::value);

    encoder << instance.parameters;
}

std::optional<WebCore::Style::CircleFunction> ArgumentCoder<WebCore::Style::CircleFunction>::decode(Decoder& decoder)
{
    auto parameters = decoder.decode<WebCore::Style::Circle>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::CircleFunction {
            WTFMove(*parameters)
        }
    };
}

void ArgumentCoder<WebCore::Style::Circle>::encode(Encoder& encoder, const WebCore::Style::Circle& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radius)>, WebCore::Style::Circle::RadialSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.position)>, std::optional<WebCore::Style::Position>>);
    struct ShouldBeSameSizeAsCircle : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::Circle>, false> {
        WebCore::Style::Circle::RadialSize radius;
        std::optional<WebCore::Style::Position> position;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCircle) == sizeof(WebCore::Style::Circle));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::Circle, radius)
        , offsetof(WebCore::Style::Circle, position)
    >::value);

    encoder << instance.radius;
    encoder << instance.position;
}

std::optional<WebCore::Style::Circle> ArgumentCoder<WebCore::Style::Circle>::decode(Decoder& decoder)
{
    auto radius = decoder.decode<WebCore::Style::Circle::RadialSize>();
    auto position = decoder.decode<std::optional<WebCore::Style::Position>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::Circle {
            WTFMove(*radius),
            WTFMove(*position)
        }
    };
}

void ArgumentCoder<WebCore::SpaceSeparatedPair<WebCore::Style::Ellipse::RadialSize>>::encode(Encoder& encoder, const WebCore::SpaceSeparatedPair<WebCore::Style::Ellipse::RadialSize>& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, std::array<WebCore::Style::Ellipse::RadialSize, 2>>);
    struct ShouldBeSameSizeAsSpaceSeparatedPair_WebCore_Style_Ellipse_RadialSize_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SpaceSeparatedPair<WebCore::Style::Ellipse::RadialSize>>, false> {
        std::array<WebCore::Style::Ellipse::RadialSize, 2> value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSpaceSeparatedPair_WebCore_Style_Ellipse_RadialSize_) == sizeof(WebCore::SpaceSeparatedPair<WebCore::Style::Ellipse::RadialSize>));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SpaceSeparatedPair<WebCore::Style::Ellipse::RadialSize>, value)
    >::value);

    encoder << instance.value;
}

std::optional<WebCore::SpaceSeparatedPair<WebCore::Style::Ellipse::RadialSize>> ArgumentCoder<WebCore::SpaceSeparatedPair<WebCore::Style::Ellipse::RadialSize>>::decode(Decoder& decoder)
{
    auto value = decoder.decode<std::array<WebCore::Style::Ellipse::RadialSize, 2>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SpaceSeparatedPair<WebCore::Style::Ellipse::RadialSize> {
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebCore::Style::EllipseFunction>::encode(Encoder& encoder, const WebCore::Style::EllipseFunction& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.parameters)>, WebCore::Style::Ellipse>);
    struct ShouldBeSameSizeAsEllipseFunction : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::EllipseFunction>, false> {
        WebCore::Style::Ellipse parameters;
    };
    static_assert(sizeof(ShouldBeSameSizeAsEllipseFunction) == sizeof(WebCore::Style::EllipseFunction));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::EllipseFunction, parameters)
    >::value);

    encoder << instance.parameters;
}

std::optional<WebCore::Style::EllipseFunction> ArgumentCoder<WebCore::Style::EllipseFunction>::decode(Decoder& decoder)
{
    auto parameters = decoder.decode<WebCore::Style::Ellipse>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::EllipseFunction {
            WTFMove(*parameters)
        }
    };
}

void ArgumentCoder<WebCore::Style::Ellipse>::encode(Encoder& encoder, const WebCore::Style::Ellipse& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radii)>, WebCore::SpaceSeparatedPair<WebCore::Style::Ellipse::RadialSize>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.position)>, std::optional<WebCore::Style::Position>>);
    struct ShouldBeSameSizeAsEllipse : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::Ellipse>, false> {
        WebCore::SpaceSeparatedPair<WebCore::Style::Ellipse::RadialSize> radii;
        std::optional<WebCore::Style::Position> position;
    };
    static_assert(sizeof(ShouldBeSameSizeAsEllipse) == sizeof(WebCore::Style::Ellipse));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::Ellipse, radii)
        , offsetof(WebCore::Style::Ellipse, position)
    >::value);

    encoder << instance.radii;
    encoder << instance.position;
}

std::optional<WebCore::Style::Ellipse> ArgumentCoder<WebCore::Style::Ellipse>::decode(Decoder& decoder)
{
    auto radii = decoder.decode<WebCore::SpaceSeparatedPair<WebCore::Style::Ellipse::RadialSize>>();
    auto position = decoder.decode<std::optional<WebCore::Style::Position>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::Ellipse {
            WTFMove(*radii),
            WTFMove(*position)
        }
    };
}

void ArgumentCoder<WebCore::Style::InsetFunction>::encode(Encoder& encoder, const WebCore::Style::InsetFunction& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.parameters)>, WebCore::Style::Inset>);
    struct ShouldBeSameSizeAsInsetFunction : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::InsetFunction>, false> {
        WebCore::Style::Inset parameters;
    };
    static_assert(sizeof(ShouldBeSameSizeAsInsetFunction) == sizeof(WebCore::Style::InsetFunction));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::InsetFunction, parameters)
    >::value);

    encoder << instance.parameters;
}

std::optional<WebCore::Style::InsetFunction> ArgumentCoder<WebCore::Style::InsetFunction>::decode(Decoder& decoder)
{
    auto parameters = decoder.decode<WebCore::Style::Inset>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::InsetFunction {
            WTFMove(*parameters)
        }
    };
}

void ArgumentCoder<WebCore::Style::Inset>::encode(Encoder& encoder, const WebCore::Style::Inset& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.insets)>, WebCore::MinimallySerializingSpaceSeparatedRectEdges<WebCore::Style::LengthPercentageAll>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radii)>, WebCore::Style::BorderRadius>);
    struct ShouldBeSameSizeAsInset : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::Inset>, false> {
        WebCore::MinimallySerializingSpaceSeparatedRectEdges<WebCore::Style::LengthPercentageAll> insets;
        WebCore::Style::BorderRadius radii;
    };
    static_assert(sizeof(ShouldBeSameSizeAsInset) == sizeof(WebCore::Style::Inset));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::Inset, insets)
        , offsetof(WebCore::Style::Inset, radii)
    >::value);

    encoder << instance.insets;
    encoder << instance.radii;
}

std::optional<WebCore::Style::Inset> ArgumentCoder<WebCore::Style::Inset>::decode(Decoder& decoder)
{
    auto insets = decoder.decode<WebCore::MinimallySerializingSpaceSeparatedRectEdges<WebCore::Style::LengthPercentageAll>>();
    auto radii = decoder.decode<WebCore::Style::BorderRadius>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::Inset {
            WTFMove(*insets),
            WTFMove(*radii)
        }
    };
}

void ArgumentCoder<WebCore::Style::PathFunction>::encode(Encoder& encoder, const WebCore::Style::PathFunction& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.parameters)>, WebCore::Style::Path>);
    struct ShouldBeSameSizeAsPathFunction : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::PathFunction>, false> {
        WebCore::Style::Path parameters;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPathFunction) == sizeof(WebCore::Style::PathFunction));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::PathFunction, parameters)
    >::value);

    encoder << instance.parameters;
}

std::optional<WebCore::Style::PathFunction> ArgumentCoder<WebCore::Style::PathFunction>::decode(Decoder& decoder)
{
    auto parameters = decoder.decode<WebCore::Style::Path>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::PathFunction {
            WTFMove(*parameters)
        }
    };
}

void ArgumentCoder<WebCore::Style::Path::Data>::encode(Encoder& encoder, const WebCore::Style::Path::Data& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.byteStream)>, WebCore::SVGPathByteStream>);
    struct ShouldBeSameSizeAsData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::Path::Data>, false> {
        WebCore::SVGPathByteStream byteStream;
    };
    static_assert(sizeof(ShouldBeSameSizeAsData) == sizeof(WebCore::Style::Path::Data));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::Path::Data, byteStream)
    >::value);

    encoder << instance.byteStream;
}

std::optional<WebCore::Style::Path::Data> ArgumentCoder<WebCore::Style::Path::Data>::decode(Decoder& decoder)
{
    auto byteStream = decoder.decode<WebCore::SVGPathByteStream>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::Path::Data {
            WTFMove(*byteStream)
        }
    };
}

void ArgumentCoder<WebCore::Style::Path>::encode(Encoder& encoder, const WebCore::Style::Path& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fillRule)>, std::optional<WebCore::Style::FillRule>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data)>, WebCore::Style::Path::Data>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.zoom)>, float>);
    struct ShouldBeSameSizeAsPath : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::Path>, false> {
        std::optional<WebCore::Style::FillRule> fillRule;
        WebCore::Style::Path::Data data;
        float zoom;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPath) == sizeof(WebCore::Style::Path));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::Path, fillRule)
        , offsetof(WebCore::Style::Path, data)
        , offsetof(WebCore::Style::Path, zoom)
    >::value);

    encoder << instance.fillRule;
    encoder << instance.data;
    encoder << instance.zoom;
}

std::optional<WebCore::Style::Path> ArgumentCoder<WebCore::Style::Path>::decode(Decoder& decoder)
{
    auto fillRule = decoder.decode<std::optional<WebCore::Style::FillRule>>();
    auto data = decoder.decode<WebCore::Style::Path::Data>();
    auto zoom = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::Path {
            WTFMove(*fillRule),
            WTFMove(*data),
            WTFMove(*zoom)
        }
    };
}

void ArgumentCoder<WebCore::Style::PolygonFunction>::encode(Encoder& encoder, const WebCore::Style::PolygonFunction& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.parameters)>, WebCore::Style::Polygon>);
    struct ShouldBeSameSizeAsPolygonFunction : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::PolygonFunction>, false> {
        WebCore::Style::Polygon parameters;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPolygonFunction) == sizeof(WebCore::Style::PolygonFunction));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::PolygonFunction, parameters)
    >::value);

    encoder << instance.parameters;
}

std::optional<WebCore::Style::PolygonFunction> ArgumentCoder<WebCore::Style::PolygonFunction>::decode(Decoder& decoder)
{
    auto parameters = decoder.decode<WebCore::Style::Polygon>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::PolygonFunction {
            WTFMove(*parameters)
        }
    };
}

void ArgumentCoder<WebCore::Style::Polygon>::encode(Encoder& encoder, const WebCore::Style::Polygon& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fillRule)>, std::optional<WebCore::Style::FillRule>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.vertices)>, WebCore::CommaSeparatedVector<WebCore::Style::LengthPercentageSpaceSeparatedPointAll>>);
    struct ShouldBeSameSizeAsPolygon : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::Polygon>, false> {
        std::optional<WebCore::Style::FillRule> fillRule;
        WebCore::CommaSeparatedVector<WebCore::Style::LengthPercentageSpaceSeparatedPointAll> vertices;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPolygon) == sizeof(WebCore::Style::Polygon));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::Polygon, fillRule)
        , offsetof(WebCore::Style::Polygon, vertices)
    >::value);

    encoder << instance.fillRule;
    encoder << instance.vertices;
}

std::optional<WebCore::Style::Polygon> ArgumentCoder<WebCore::Style::Polygon>::decode(Decoder& decoder)
{
    auto fillRule = decoder.decode<std::optional<WebCore::Style::FillRule>>();
    auto vertices = decoder.decode<WebCore::CommaSeparatedVector<WebCore::Style::LengthPercentageSpaceSeparatedPointAll>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::Polygon {
            WTFMove(*fillRule),
            WTFMove(*vertices)
        }
    };
}

void ArgumentCoder<WebCore::Constant<WebCore::CSSValueNonzero>>::encode(Encoder& encoder, const WebCore::Constant<WebCore::CSSValueNonzero>& instance)
{
    struct ShouldBeSameSizeAsConstant_WebCore_CSSValueNonzero_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Constant<WebCore::CSSValueNonzero>>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsConstant_WebCore_CSSValueNonzero_) == sizeof(WebCore::Constant<WebCore::CSSValueNonzero>));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::Constant<WebCore::CSSValueNonzero>> ArgumentCoder<WebCore::Constant<WebCore::CSSValueNonzero>>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Constant<WebCore::CSSValueNonzero> {
        }
    };
}

void ArgumentCoder<WebCore::Constant<WebCore::CSSValueEvenodd>>::encode(Encoder& encoder, const WebCore::Constant<WebCore::CSSValueEvenodd>& instance)
{
    struct ShouldBeSameSizeAsConstant_WebCore_CSSValueEvenodd_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Constant<WebCore::CSSValueEvenodd>>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsConstant_WebCore_CSSValueEvenodd_) == sizeof(WebCore::Constant<WebCore::CSSValueEvenodd>));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::Constant<WebCore::CSSValueEvenodd>> ArgumentCoder<WebCore::Constant<WebCore::CSSValueEvenodd>>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Constant<WebCore::CSSValueEvenodd> {
        }
    };
}

void ArgumentCoder<WebCore::Constant<WebCore::CSSValueBy>>::encode(Encoder& encoder, const WebCore::Constant<WebCore::CSSValueBy>& instance)
{
    struct ShouldBeSameSizeAsConstant_WebCore_CSSValueBy_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Constant<WebCore::CSSValueBy>>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsConstant_WebCore_CSSValueBy_) == sizeof(WebCore::Constant<WebCore::CSSValueBy>));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::Constant<WebCore::CSSValueBy>> ArgumentCoder<WebCore::Constant<WebCore::CSSValueBy>>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Constant<WebCore::CSSValueBy> {
        }
    };
}

void ArgumentCoder<WebCore::Constant<WebCore::CSSValueTo>>::encode(Encoder& encoder, const WebCore::Constant<WebCore::CSSValueTo>& instance)
{
    struct ShouldBeSameSizeAsConstant_WebCore_CSSValueTo_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Constant<WebCore::CSSValueTo>>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsConstant_WebCore_CSSValueTo_) == sizeof(WebCore::Constant<WebCore::CSSValueTo>));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::Constant<WebCore::CSSValueTo>> ArgumentCoder<WebCore::Constant<WebCore::CSSValueTo>>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Constant<WebCore::CSSValueTo> {
        }
    };
}

void ArgumentCoder<WebCore::Constant<WebCore::CSSValueCcw>>::encode(Encoder& encoder, const WebCore::Constant<WebCore::CSSValueCcw>& instance)
{
    struct ShouldBeSameSizeAsConstant_WebCore_CSSValueCcw_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Constant<WebCore::CSSValueCcw>>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsConstant_WebCore_CSSValueCcw_) == sizeof(WebCore::Constant<WebCore::CSSValueCcw>));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::Constant<WebCore::CSSValueCcw>> ArgumentCoder<WebCore::Constant<WebCore::CSSValueCcw>>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Constant<WebCore::CSSValueCcw> {
        }
    };
}

void ArgumentCoder<WebCore::Constant<WebCore::CSSValueCw>>::encode(Encoder& encoder, const WebCore::Constant<WebCore::CSSValueCw>& instance)
{
    struct ShouldBeSameSizeAsConstant_WebCore_CSSValueCw_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Constant<WebCore::CSSValueCw>>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsConstant_WebCore_CSSValueCw_) == sizeof(WebCore::Constant<WebCore::CSSValueCw>));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::Constant<WebCore::CSSValueCw>> ArgumentCoder<WebCore::Constant<WebCore::CSSValueCw>>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Constant<WebCore::CSSValueCw> {
        }
    };
}

void ArgumentCoder<WebCore::Constant<WebCore::CSSValueLarge>>::encode(Encoder& encoder, const WebCore::Constant<WebCore::CSSValueLarge>& instance)
{
    struct ShouldBeSameSizeAsConstant_WebCore_CSSValueLarge_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Constant<WebCore::CSSValueLarge>>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsConstant_WebCore_CSSValueLarge_) == sizeof(WebCore::Constant<WebCore::CSSValueLarge>));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::Constant<WebCore::CSSValueLarge>> ArgumentCoder<WebCore::Constant<WebCore::CSSValueLarge>>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Constant<WebCore::CSSValueLarge> {
        }
    };
}

void ArgumentCoder<WebCore::Constant<WebCore::CSSValueSmall>>::encode(Encoder& encoder, const WebCore::Constant<WebCore::CSSValueSmall>& instance)
{
    struct ShouldBeSameSizeAsConstant_WebCore_CSSValueSmall_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Constant<WebCore::CSSValueSmall>>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsConstant_WebCore_CSSValueSmall_) == sizeof(WebCore::Constant<WebCore::CSSValueSmall>));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::Constant<WebCore::CSSValueSmall>> ArgumentCoder<WebCore::Constant<WebCore::CSSValueSmall>>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Constant<WebCore::CSSValueSmall> {
        }
    };
}

void ArgumentCoder<WebCore::Constant<WebCore::CSSValueStart>>::encode(Encoder& encoder, const WebCore::Constant<WebCore::CSSValueStart>& instance)
{
    struct ShouldBeSameSizeAsConstant_WebCore_CSSValueStart_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Constant<WebCore::CSSValueStart>>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsConstant_WebCore_CSSValueStart_) == sizeof(WebCore::Constant<WebCore::CSSValueStart>));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::Constant<WebCore::CSSValueStart>> ArgumentCoder<WebCore::Constant<WebCore::CSSValueStart>>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Constant<WebCore::CSSValueStart> {
        }
    };
}

void ArgumentCoder<WebCore::Constant<WebCore::CSSValueEnd>>::encode(Encoder& encoder, const WebCore::Constant<WebCore::CSSValueEnd>& instance)
{
    struct ShouldBeSameSizeAsConstant_WebCore_CSSValueEnd_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Constant<WebCore::CSSValueEnd>>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsConstant_WebCore_CSSValueEnd_) == sizeof(WebCore::Constant<WebCore::CSSValueEnd>));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::Constant<WebCore::CSSValueEnd>> ArgumentCoder<WebCore::Constant<WebCore::CSSValueEnd>>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Constant<WebCore::CSSValueEnd> {
        }
    };
}

void ArgumentCoder<WebCore::Constant<WebCore::CSSValueOrigin>>::encode(Encoder& encoder, const WebCore::Constant<WebCore::CSSValueOrigin>& instance)
{
    struct ShouldBeSameSizeAsConstant_WebCore_CSSValueOrigin_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Constant<WebCore::CSSValueOrigin>>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsConstant_WebCore_CSSValueOrigin_) == sizeof(WebCore::Constant<WebCore::CSSValueOrigin>));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::Constant<WebCore::CSSValueOrigin>> ArgumentCoder<WebCore::Constant<WebCore::CSSValueOrigin>>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Constant<WebCore::CSSValueOrigin> {
        }
    };
}

void ArgumentCoder<WebCore::Constant<WebCore::CSSValueClose>>::encode(Encoder& encoder, const WebCore::Constant<WebCore::CSSValueClose>& instance)
{
    struct ShouldBeSameSizeAsConstant_WebCore_CSSValueClose_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Constant<WebCore::CSSValueClose>>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsConstant_WebCore_CSSValueClose_) == sizeof(WebCore::Constant<WebCore::CSSValueClose>));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::Constant<WebCore::CSSValueClose>> ArgumentCoder<WebCore::Constant<WebCore::CSSValueClose>>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Constant<WebCore::CSSValueClose> {
        }
    };
}

void ArgumentCoder<WebCore::Style::ToPosition>::encode(Encoder& encoder, const WebCore::Style::ToPosition& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, WebCore::Style::Position>);
    struct ShouldBeSameSizeAsToPosition : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::ToPosition>, false> {
        WebCore::Style::Position offset;
    };
    static_assert(sizeof(ShouldBeSameSizeAsToPosition) == sizeof(WebCore::Style::ToPosition));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::ToPosition, offset)
    >::value);

    encoder << instance.offset;
}

std::optional<WebCore::Style::ToPosition> ArgumentCoder<WebCore::Style::ToPosition>::decode(Decoder& decoder)
{
    auto offset = decoder.decode<WebCore::Style::Position>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::ToPosition {
            WTFMove(*offset)
        }
    };
}

void ArgumentCoder<WebCore::Style::ByCoordinatePair>::encode(Encoder& encoder, const WebCore::Style::ByCoordinatePair& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, WebCore::Style::CoordinatePair>);
    struct ShouldBeSameSizeAsByCoordinatePair : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::ByCoordinatePair>, false> {
        WebCore::Style::CoordinatePair offset;
    };
    static_assert(sizeof(ShouldBeSameSizeAsByCoordinatePair) == sizeof(WebCore::Style::ByCoordinatePair));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::ByCoordinatePair, offset)
    >::value);

    encoder << instance.offset;
}

std::optional<WebCore::Style::ByCoordinatePair> ArgumentCoder<WebCore::Style::ByCoordinatePair>::decode(Decoder& decoder)
{
    auto offset = decoder.decode<WebCore::Style::CoordinatePair>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::ByCoordinatePair {
            WTFMove(*offset)
        }
    };
}

void ArgumentCoder<WebCore::Style::RelativeControlPoint>::encode(Encoder& encoder, const WebCore::Style::RelativeControlPoint& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, WebCore::Style::CoordinatePair>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.anchor)>, std::optional<WebCore::Style::ControlPointAnchor>>);
    struct ShouldBeSameSizeAsRelativeControlPoint : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::RelativeControlPoint>, false> {
        WebCore::Style::CoordinatePair offset;
        std::optional<WebCore::Style::ControlPointAnchor> anchor;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRelativeControlPoint) == sizeof(WebCore::Style::RelativeControlPoint));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::RelativeControlPoint, offset)
        , offsetof(WebCore::Style::RelativeControlPoint, anchor)
    >::value);

    encoder << instance.offset;
    encoder << instance.anchor;
}

std::optional<WebCore::Style::RelativeControlPoint> ArgumentCoder<WebCore::Style::RelativeControlPoint>::decode(Decoder& decoder)
{
    auto offset = decoder.decode<WebCore::Style::CoordinatePair>();
    auto anchor = decoder.decode<std::optional<WebCore::Style::ControlPointAnchor>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::RelativeControlPoint {
            WTFMove(*offset),
            WTFMove(*anchor)
        }
    };
}

void ArgumentCoder<WebCore::Style::AbsoluteControlPoint>::encode(Encoder& encoder, const WebCore::Style::AbsoluteControlPoint& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, WebCore::Style::Position>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.anchor)>, std::optional<WebCore::Style::ControlPointAnchor>>);
    struct ShouldBeSameSizeAsAbsoluteControlPoint : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::AbsoluteControlPoint>, false> {
        WebCore::Style::Position offset;
        std::optional<WebCore::Style::ControlPointAnchor> anchor;
    };
    static_assert(sizeof(ShouldBeSameSizeAsAbsoluteControlPoint) == sizeof(WebCore::Style::AbsoluteControlPoint));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::AbsoluteControlPoint, offset)
        , offsetof(WebCore::Style::AbsoluteControlPoint, anchor)
    >::value);

    encoder << instance.offset;
    encoder << instance.anchor;
}

std::optional<WebCore::Style::AbsoluteControlPoint> ArgumentCoder<WebCore::Style::AbsoluteControlPoint>::decode(Decoder& decoder)
{
    auto offset = decoder.decode<WebCore::Style::Position>();
    auto anchor = decoder.decode<std::optional<WebCore::Style::ControlPointAnchor>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::AbsoluteControlPoint {
            WTFMove(*offset),
            WTFMove(*anchor)
        }
    };
}

void ArgumentCoder<WebCore::Style::ShapeFunction>::encode(Encoder& encoder, const WebCore::Style::ShapeFunction& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.parameters)>, WebCore::Style::Shape>);
    struct ShouldBeSameSizeAsShapeFunction : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::ShapeFunction>, false> {
        WebCore::Style::Shape parameters;
    };
    static_assert(sizeof(ShouldBeSameSizeAsShapeFunction) == sizeof(WebCore::Style::ShapeFunction));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::ShapeFunction, parameters)
    >::value);

    encoder << instance.parameters;
}

std::optional<WebCore::Style::ShapeFunction> ArgumentCoder<WebCore::Style::ShapeFunction>::decode(Decoder& decoder)
{
    auto parameters = decoder.decode<WebCore::Style::Shape>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::ShapeFunction {
            WTFMove(*parameters)
        }
    };
}

void ArgumentCoder<WebCore::Style::Shape>::encode(Encoder& encoder, const WebCore::Style::Shape& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fillRule)>, std::optional<WebCore::Style::FillRule>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.startingPoint)>, WebCore::Style::Position>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.commands)>, WebCore::CommaSeparatedVector<WebCore::Style::ShapeCommand>>);
    struct ShouldBeSameSizeAsShape : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::Shape>, false> {
        std::optional<WebCore::Style::FillRule> fillRule;
        WebCore::Style::Position startingPoint;
        WebCore::CommaSeparatedVector<WebCore::Style::ShapeCommand> commands;
    };
    static_assert(sizeof(ShouldBeSameSizeAsShape) == sizeof(WebCore::Style::Shape));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::Shape, fillRule)
        , offsetof(WebCore::Style::Shape, startingPoint)
        , offsetof(WebCore::Style::Shape, commands)
    >::value);

    encoder << instance.fillRule;
    encoder << instance.startingPoint;
    encoder << instance.commands;
}

std::optional<WebCore::Style::Shape> ArgumentCoder<WebCore::Style::Shape>::decode(Decoder& decoder)
{
    auto fillRule = decoder.decode<std::optional<WebCore::Style::FillRule>>();
    auto startingPoint = decoder.decode<WebCore::Style::Position>();
    auto commands = decoder.decode<WebCore::CommaSeparatedVector<WebCore::Style::ShapeCommand>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::Shape {
            WTFMove(*fillRule),
            WTFMove(*startingPoint),
            WTFMove(*commands)
        }
    };
}

void ArgumentCoder<WebCore::Style::MoveCommand>::encode(Encoder& encoder, const WebCore::Style::MoveCommand& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.toBy)>, Variant<WebCore::Style::ToPosition, WebCore::Style::ByCoordinatePair>>);
    struct ShouldBeSameSizeAsMoveCommand : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::MoveCommand>, false> {
        Variant<WebCore::Style::ToPosition, WebCore::Style::ByCoordinatePair> toBy;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMoveCommand) == sizeof(WebCore::Style::MoveCommand));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::MoveCommand, toBy)
    >::value);

    encoder << instance.toBy;
}

std::optional<WebCore::Style::MoveCommand> ArgumentCoder<WebCore::Style::MoveCommand>::decode(Decoder& decoder)
{
    auto toBy = decoder.decode<Variant<WebCore::Style::ToPosition, WebCore::Style::ByCoordinatePair>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::MoveCommand {
            WTFMove(*toBy)
        }
    };
}

void ArgumentCoder<WebCore::Style::LineCommand>::encode(Encoder& encoder, const WebCore::Style::LineCommand& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.toBy)>, Variant<WebCore::Style::ToPosition, WebCore::Style::ByCoordinatePair>>);
    struct ShouldBeSameSizeAsLineCommand : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::LineCommand>, false> {
        Variant<WebCore::Style::ToPosition, WebCore::Style::ByCoordinatePair> toBy;
    };
    static_assert(sizeof(ShouldBeSameSizeAsLineCommand) == sizeof(WebCore::Style::LineCommand));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::LineCommand, toBy)
    >::value);

    encoder << instance.toBy;
}

std::optional<WebCore::Style::LineCommand> ArgumentCoder<WebCore::Style::LineCommand>::decode(Decoder& decoder)
{
    auto toBy = decoder.decode<Variant<WebCore::Style::ToPosition, WebCore::Style::ByCoordinatePair>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::LineCommand {
            WTFMove(*toBy)
        }
    };
}

void ArgumentCoder<WebCore::Style::HLineCommand::To>::encode(Encoder& encoder, const WebCore::Style::HLineCommand::To& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, WebCore::Style::TwoComponentPositionHorizontal>);
    struct ShouldBeSameSizeAsTo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::HLineCommand::To>, false> {
        WebCore::Style::TwoComponentPositionHorizontal offset;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTo) == sizeof(WebCore::Style::HLineCommand::To));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::HLineCommand::To, offset)
    >::value);

    encoder << instance.offset;
}

std::optional<WebCore::Style::HLineCommand::To> ArgumentCoder<WebCore::Style::HLineCommand::To>::decode(Decoder& decoder)
{
    auto offset = decoder.decode<WebCore::Style::TwoComponentPositionHorizontal>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::HLineCommand::To {
            WTFMove(*offset)
        }
    };
}

void ArgumentCoder<WebCore::Style::HLineCommand::By>::encode(Encoder& encoder, const WebCore::Style::HLineCommand::By& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, WebCore::Style::LengthPercentageAll>);
    struct ShouldBeSameSizeAsBy : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::HLineCommand::By>, false> {
        WebCore::Style::LengthPercentageAll offset;
    };
    static_assert(sizeof(ShouldBeSameSizeAsBy) == sizeof(WebCore::Style::HLineCommand::By));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::HLineCommand::By, offset)
    >::value);

    encoder << instance.offset;
}

std::optional<WebCore::Style::HLineCommand::By> ArgumentCoder<WebCore::Style::HLineCommand::By>::decode(Decoder& decoder)
{
    auto offset = decoder.decode<WebCore::Style::LengthPercentageAll>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::HLineCommand::By {
            WTFMove(*offset)
        }
    };
}

void ArgumentCoder<WebCore::Style::HLineCommand>::encode(Encoder& encoder, const WebCore::Style::HLineCommand& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.toBy)>, Variant<WebCore::Style::HLineCommand::To, WebCore::Style::HLineCommand::By>>);
    struct ShouldBeSameSizeAsHLineCommand : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::HLineCommand>, false> {
        Variant<WebCore::Style::HLineCommand::To, WebCore::Style::HLineCommand::By> toBy;
    };
    static_assert(sizeof(ShouldBeSameSizeAsHLineCommand) == sizeof(WebCore::Style::HLineCommand));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::HLineCommand, toBy)
    >::value);

    encoder << instance.toBy;
}

std::optional<WebCore::Style::HLineCommand> ArgumentCoder<WebCore::Style::HLineCommand>::decode(Decoder& decoder)
{
    auto toBy = decoder.decode<Variant<WebCore::Style::HLineCommand::To, WebCore::Style::HLineCommand::By>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::HLineCommand {
            WTFMove(*toBy)
        }
    };
}

void ArgumentCoder<WebCore::Style::VLineCommand::To>::encode(Encoder& encoder, const WebCore::Style::VLineCommand::To& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, WebCore::Style::TwoComponentPositionVertical>);
    struct ShouldBeSameSizeAsTo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::VLineCommand::To>, false> {
        WebCore::Style::TwoComponentPositionVertical offset;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTo) == sizeof(WebCore::Style::VLineCommand::To));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::VLineCommand::To, offset)
    >::value);

    encoder << instance.offset;
}

std::optional<WebCore::Style::VLineCommand::To> ArgumentCoder<WebCore::Style::VLineCommand::To>::decode(Decoder& decoder)
{
    auto offset = decoder.decode<WebCore::Style::TwoComponentPositionVertical>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::VLineCommand::To {
            WTFMove(*offset)
        }
    };
}

void ArgumentCoder<WebCore::Style::VLineCommand::By>::encode(Encoder& encoder, const WebCore::Style::VLineCommand::By& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, WebCore::Style::LengthPercentageAll>);
    struct ShouldBeSameSizeAsBy : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::VLineCommand::By>, false> {
        WebCore::Style::LengthPercentageAll offset;
    };
    static_assert(sizeof(ShouldBeSameSizeAsBy) == sizeof(WebCore::Style::VLineCommand::By));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::VLineCommand::By, offset)
    >::value);

    encoder << instance.offset;
}

std::optional<WebCore::Style::VLineCommand::By> ArgumentCoder<WebCore::Style::VLineCommand::By>::decode(Decoder& decoder)
{
    auto offset = decoder.decode<WebCore::Style::LengthPercentageAll>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::VLineCommand::By {
            WTFMove(*offset)
        }
    };
}

void ArgumentCoder<WebCore::Style::VLineCommand>::encode(Encoder& encoder, const WebCore::Style::VLineCommand& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.toBy)>, Variant<WebCore::Style::VLineCommand::To, WebCore::Style::VLineCommand::By>>);
    struct ShouldBeSameSizeAsVLineCommand : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::VLineCommand>, false> {
        Variant<WebCore::Style::VLineCommand::To, WebCore::Style::VLineCommand::By> toBy;
    };
    static_assert(sizeof(ShouldBeSameSizeAsVLineCommand) == sizeof(WebCore::Style::VLineCommand));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::VLineCommand, toBy)
    >::value);

    encoder << instance.toBy;
}

std::optional<WebCore::Style::VLineCommand> ArgumentCoder<WebCore::Style::VLineCommand>::decode(Decoder& decoder)
{
    auto toBy = decoder.decode<Variant<WebCore::Style::VLineCommand::To, WebCore::Style::VLineCommand::By>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::VLineCommand {
            WTFMove(*toBy)
        }
    };
}

void ArgumentCoder<WebCore::Style::CurveCommand::To>::encode(Encoder& encoder, const WebCore::Style::CurveCommand::To& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, WebCore::Style::Position>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlPoint1)>, WebCore::Style::AbsoluteControlPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlPoint2)>, std::optional<WebCore::Style::AbsoluteControlPoint>>);
    struct ShouldBeSameSizeAsTo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::CurveCommand::To>, false> {
        WebCore::Style::Position offset;
        WebCore::Style::AbsoluteControlPoint controlPoint1;
        std::optional<WebCore::Style::AbsoluteControlPoint> controlPoint2;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTo) == sizeof(WebCore::Style::CurveCommand::To));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::CurveCommand::To, offset)
        , offsetof(WebCore::Style::CurveCommand::To, controlPoint1)
        , offsetof(WebCore::Style::CurveCommand::To, controlPoint2)
    >::value);

    encoder << instance.offset;
    encoder << instance.controlPoint1;
    encoder << instance.controlPoint2;
}

std::optional<WebCore::Style::CurveCommand::To> ArgumentCoder<WebCore::Style::CurveCommand::To>::decode(Decoder& decoder)
{
    auto offset = decoder.decode<WebCore::Style::Position>();
    auto controlPoint1 = decoder.decode<WebCore::Style::AbsoluteControlPoint>();
    auto controlPoint2 = decoder.decode<std::optional<WebCore::Style::AbsoluteControlPoint>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::CurveCommand::To {
            WTFMove(*offset),
            WTFMove(*controlPoint1),
            WTFMove(*controlPoint2)
        }
    };
}

void ArgumentCoder<WebCore::Style::CurveCommand::By>::encode(Encoder& encoder, const WebCore::Style::CurveCommand::By& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, WebCore::Style::CoordinatePair>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlPoint1)>, WebCore::Style::RelativeControlPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlPoint2)>, std::optional<WebCore::Style::RelativeControlPoint>>);
    struct ShouldBeSameSizeAsBy : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::CurveCommand::By>, false> {
        WebCore::Style::CoordinatePair offset;
        WebCore::Style::RelativeControlPoint controlPoint1;
        std::optional<WebCore::Style::RelativeControlPoint> controlPoint2;
    };
    static_assert(sizeof(ShouldBeSameSizeAsBy) == sizeof(WebCore::Style::CurveCommand::By));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::CurveCommand::By, offset)
        , offsetof(WebCore::Style::CurveCommand::By, controlPoint1)
        , offsetof(WebCore::Style::CurveCommand::By, controlPoint2)
    >::value);

    encoder << instance.offset;
    encoder << instance.controlPoint1;
    encoder << instance.controlPoint2;
}

std::optional<WebCore::Style::CurveCommand::By> ArgumentCoder<WebCore::Style::CurveCommand::By>::decode(Decoder& decoder)
{
    auto offset = decoder.decode<WebCore::Style::CoordinatePair>();
    auto controlPoint1 = decoder.decode<WebCore::Style::RelativeControlPoint>();
    auto controlPoint2 = decoder.decode<std::optional<WebCore::Style::RelativeControlPoint>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::CurveCommand::By {
            WTFMove(*offset),
            WTFMove(*controlPoint1),
            WTFMove(*controlPoint2)
        }
    };
}

void ArgumentCoder<WebCore::Style::CurveCommand>::encode(Encoder& encoder, const WebCore::Style::CurveCommand& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.toBy)>, Variant<WebCore::Style::CurveCommand::To, WebCore::Style::CurveCommand::By>>);
    struct ShouldBeSameSizeAsCurveCommand : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::CurveCommand>, false> {
        Variant<WebCore::Style::CurveCommand::To, WebCore::Style::CurveCommand::By> toBy;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCurveCommand) == sizeof(WebCore::Style::CurveCommand));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::CurveCommand, toBy)
    >::value);

    encoder << instance.toBy;
}

std::optional<WebCore::Style::CurveCommand> ArgumentCoder<WebCore::Style::CurveCommand>::decode(Decoder& decoder)
{
    auto toBy = decoder.decode<Variant<WebCore::Style::CurveCommand::To, WebCore::Style::CurveCommand::By>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::CurveCommand {
            WTFMove(*toBy)
        }
    };
}

void ArgumentCoder<WebCore::Style::SmoothCommand::To>::encode(Encoder& encoder, const WebCore::Style::SmoothCommand::To& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, WebCore::Style::Position>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlPoint)>, std::optional<WebCore::Style::AbsoluteControlPoint>>);
    struct ShouldBeSameSizeAsTo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::SmoothCommand::To>, false> {
        WebCore::Style::Position offset;
        std::optional<WebCore::Style::AbsoluteControlPoint> controlPoint;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTo) == sizeof(WebCore::Style::SmoothCommand::To));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::SmoothCommand::To, offset)
        , offsetof(WebCore::Style::SmoothCommand::To, controlPoint)
    >::value);

    encoder << instance.offset;
    encoder << instance.controlPoint;
}

std::optional<WebCore::Style::SmoothCommand::To> ArgumentCoder<WebCore::Style::SmoothCommand::To>::decode(Decoder& decoder)
{
    auto offset = decoder.decode<WebCore::Style::Position>();
    auto controlPoint = decoder.decode<std::optional<WebCore::Style::AbsoluteControlPoint>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::SmoothCommand::To {
            WTFMove(*offset),
            WTFMove(*controlPoint)
        }
    };
}

void ArgumentCoder<WebCore::Style::SmoothCommand::By>::encode(Encoder& encoder, const WebCore::Style::SmoothCommand::By& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, WebCore::Style::CoordinatePair>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlPoint)>, std::optional<WebCore::Style::RelativeControlPoint>>);
    struct ShouldBeSameSizeAsBy : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::SmoothCommand::By>, false> {
        WebCore::Style::CoordinatePair offset;
        std::optional<WebCore::Style::RelativeControlPoint> controlPoint;
    };
    static_assert(sizeof(ShouldBeSameSizeAsBy) == sizeof(WebCore::Style::SmoothCommand::By));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::SmoothCommand::By, offset)
        , offsetof(WebCore::Style::SmoothCommand::By, controlPoint)
    >::value);

    encoder << instance.offset;
    encoder << instance.controlPoint;
}

std::optional<WebCore::Style::SmoothCommand::By> ArgumentCoder<WebCore::Style::SmoothCommand::By>::decode(Decoder& decoder)
{
    auto offset = decoder.decode<WebCore::Style::CoordinatePair>();
    auto controlPoint = decoder.decode<std::optional<WebCore::Style::RelativeControlPoint>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::SmoothCommand::By {
            WTFMove(*offset),
            WTFMove(*controlPoint)
        }
    };
}

void ArgumentCoder<WebCore::Style::SmoothCommand>::encode(Encoder& encoder, const WebCore::Style::SmoothCommand& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.toBy)>, Variant<WebCore::Style::SmoothCommand::To, WebCore::Style::SmoothCommand::By>>);
    struct ShouldBeSameSizeAsSmoothCommand : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::SmoothCommand>, false> {
        Variant<WebCore::Style::SmoothCommand::To, WebCore::Style::SmoothCommand::By> toBy;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSmoothCommand) == sizeof(WebCore::Style::SmoothCommand));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::SmoothCommand, toBy)
    >::value);

    encoder << instance.toBy;
}

std::optional<WebCore::Style::SmoothCommand> ArgumentCoder<WebCore::Style::SmoothCommand>::decode(Decoder& decoder)
{
    auto toBy = decoder.decode<Variant<WebCore::Style::SmoothCommand::To, WebCore::Style::SmoothCommand::By>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::SmoothCommand {
            WTFMove(*toBy)
        }
    };
}

void ArgumentCoder<WebCore::Style::ArcCommand>::encode(Encoder& encoder, const WebCore::Style::ArcCommand& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.toBy)>, Variant<WebCore::Style::ToPosition, WebCore::Style::ByCoordinatePair>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size)>, WebCore::Style::LengthPercentageMinimallySerializingSpaceSeparatedSizeAll>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.arcSweep)>, Variant<WebCore::CSS::Keyword::Cw, WebCore::CSS::Keyword::Ccw>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.arcSize)>, Variant<WebCore::CSS::Keyword::Large, WebCore::CSS::Keyword::Small>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rotation)>, WebCore::Style::Angle<WebCore::CSS::All>>);
    struct ShouldBeSameSizeAsArcCommand : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::ArcCommand>, false> {
        Variant<WebCore::Style::ToPosition, WebCore::Style::ByCoordinatePair> toBy;
        WebCore::Style::LengthPercentageMinimallySerializingSpaceSeparatedSizeAll size;
        Variant<WebCore::CSS::Keyword::Cw, WebCore::CSS::Keyword::Ccw> arcSweep;
        Variant<WebCore::CSS::Keyword::Large, WebCore::CSS::Keyword::Small> arcSize;
        WebCore::Style::Angle<WebCore::CSS::All> rotation;
    };
    static_assert(sizeof(ShouldBeSameSizeAsArcCommand) == sizeof(WebCore::Style::ArcCommand));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::ArcCommand, toBy)
        , offsetof(WebCore::Style::ArcCommand, size)
        , offsetof(WebCore::Style::ArcCommand, arcSweep)
        , offsetof(WebCore::Style::ArcCommand, arcSize)
        , offsetof(WebCore::Style::ArcCommand, rotation)
    >::value);

    encoder << instance.toBy;
    encoder << instance.size;
    encoder << instance.arcSweep;
    encoder << instance.arcSize;
    encoder << instance.rotation;
}

std::optional<WebCore::Style::ArcCommand> ArgumentCoder<WebCore::Style::ArcCommand>::decode(Decoder& decoder)
{
    auto toBy = decoder.decode<Variant<WebCore::Style::ToPosition, WebCore::Style::ByCoordinatePair>>();
    auto size = decoder.decode<WebCore::Style::LengthPercentageMinimallySerializingSpaceSeparatedSizeAll>();
    auto arcSweep = decoder.decode<Variant<WebCore::CSS::Keyword::Cw, WebCore::CSS::Keyword::Ccw>>();
    auto arcSize = decoder.decode<Variant<WebCore::CSS::Keyword::Large, WebCore::CSS::Keyword::Small>>();
    auto rotation = decoder.decode<WebCore::Style::Angle<WebCore::CSS::All>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::ArcCommand {
            WTFMove(*toBy),
            WTFMove(*size),
            WTFMove(*arcSweep),
            WTFMove(*arcSize),
            WTFMove(*rotation)
        }
    };
}

void ArgumentCoder<WebCore::Style::BorderRadius>::encode(Encoder& encoder, const WebCore::Style::BorderRadius& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.topLeft())>, WebCore::MinimallySerializingSpaceSeparatedSize<WebCore::Style::LengthPercentageNonnegative>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.topRight())>, WebCore::MinimallySerializingSpaceSeparatedSize<WebCore::Style::LengthPercentageNonnegative>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bottomRight())>, WebCore::MinimallySerializingSpaceSeparatedSize<WebCore::Style::LengthPercentageNonnegative>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bottomLeft())>, WebCore::MinimallySerializingSpaceSeparatedSize<WebCore::Style::LengthPercentageNonnegative>>);

    encoder << instance.topLeft();
    encoder << instance.topRight();
    encoder << instance.bottomRight();
    encoder << instance.bottomLeft();
}

std::optional<WebCore::Style::BorderRadius> ArgumentCoder<WebCore::Style::BorderRadius>::decode(Decoder& decoder)
{
    auto topLeft = decoder.decode<WebCore::MinimallySerializingSpaceSeparatedSize<WebCore::Style::LengthPercentageNonnegative>>();
    auto topRight = decoder.decode<WebCore::MinimallySerializingSpaceSeparatedSize<WebCore::Style::LengthPercentageNonnegative>>();
    auto bottomRight = decoder.decode<WebCore::MinimallySerializingSpaceSeparatedSize<WebCore::Style::LengthPercentageNonnegative>>();
    auto bottomLeft = decoder.decode<WebCore::MinimallySerializingSpaceSeparatedSize<WebCore::Style::LengthPercentageNonnegative>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::BorderRadius {
            WTFMove(*topLeft),
            WTFMove(*topRight),
            WTFMove(*bottomRight),
            WTFMove(*bottomLeft)
        }
    };
}

void ArgumentCoder<WebCore::Constant<WebCore::CSSValueSides>>::encode(Encoder& encoder, const WebCore::Constant<WebCore::CSSValueSides>& instance)
{
    struct ShouldBeSameSizeAsConstant_WebCore_CSSValueSides_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Constant<WebCore::CSSValueSides>>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsConstant_WebCore_CSSValueSides_) == sizeof(WebCore::Constant<WebCore::CSSValueSides>));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::Constant<WebCore::CSSValueSides>> ArgumentCoder<WebCore::Constant<WebCore::CSSValueSides>>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Constant<WebCore::CSSValueSides> {
        }
    };
}

void ArgumentCoder<WebCore::Constant<WebCore::CSSValueContain>>::encode(Encoder& encoder, const WebCore::Constant<WebCore::CSSValueContain>& instance)
{
    struct ShouldBeSameSizeAsConstant_WebCore_CSSValueContain_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Constant<WebCore::CSSValueContain>>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsConstant_WebCore_CSSValueContain_) == sizeof(WebCore::Constant<WebCore::CSSValueContain>));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::Constant<WebCore::CSSValueContain>> ArgumentCoder<WebCore::Constant<WebCore::CSSValueContain>>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Constant<WebCore::CSSValueContain> {
        }
    };
}

void ArgumentCoder<WebCore::Style::RayFunction>::encode(Encoder& encoder, const WebCore::Style::RayFunction& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.parameters)>, WebCore::Style::Ray>);
    struct ShouldBeSameSizeAsRayFunction : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::RayFunction>, false> {
        WebCore::Style::Ray parameters;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRayFunction) == sizeof(WebCore::Style::RayFunction));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::RayFunction, parameters)
    >::value);

    encoder << instance.parameters;
}

std::optional<WebCore::Style::RayFunction> ArgumentCoder<WebCore::Style::RayFunction>::decode(Decoder& decoder)
{
    auto parameters = decoder.decode<WebCore::Style::Ray>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::RayFunction {
            WTFMove(*parameters)
        }
    };
}

void ArgumentCoder<WebCore::Style::Ray>::encode(Encoder& encoder, const WebCore::Style::Ray& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.angle)>, WebCore::Style::Angle<WebCore::CSS::All>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size)>, WebCore::Style::RaySize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contain)>, std::optional<WebCore::CSS::Keyword::Contain>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.position)>, std::optional<WebCore::Style::Position>>);
    struct ShouldBeSameSizeAsRay : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Style::Ray>, false> {
        WebCore::Style::Angle<WebCore::CSS::All> angle;
        WebCore::Style::RaySize size;
        std::optional<WebCore::CSS::Keyword::Contain> contain;
        std::optional<WebCore::Style::Position> position;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRay) == sizeof(WebCore::Style::Ray));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Style::Ray, angle)
        , offsetof(WebCore::Style::Ray, size)
        , offsetof(WebCore::Style::Ray, contain)
        , offsetof(WebCore::Style::Ray, position)
    >::value);

    encoder << instance.angle;
    encoder << instance.size;
    encoder << instance.contain;
    encoder << instance.position;
}

std::optional<WebCore::Style::Ray> ArgumentCoder<WebCore::Style::Ray>::decode(Decoder& decoder)
{
    auto angle = decoder.decode<WebCore::Style::Angle<WebCore::CSS::All>>();
    auto size = decoder.decode<WebCore::Style::RaySize>();
    auto contain = decoder.decode<std::optional<WebCore::CSS::Keyword::Contain>>();
    auto position = decoder.decode<std::optional<WebCore::Style::Position>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::Ray {
            WTFMove(*angle),
            WTFMove(*size),
            WTFMove(*contain),
            WTFMove(*position)
        }
    };
}

enum class WebCore_PixelBuffer_Subclass : IPC::EncodedVariantIndex {
    ByteArrayPixelBuffer
};

IGNORE_WARNINGS_BEGIN("missing-noreturn")
void ArgumentCoder<WebCore::PixelBuffer>::encode(Encoder& encoder, const WebCore::PixelBuffer& instance)
{
    if (auto* subclass = dynamicDowncast<WebCore::ByteArrayPixelBuffer>(instance)) {
        encoder << WebCore_PixelBuffer_Subclass::ByteArrayPixelBuffer;
        encoder << *subclass;
        return;
    }
    ASSERT_NOT_REACHED();
}
IGNORE_WARNINGS_END

IGNORE_WARNINGS_BEGIN("missing-noreturn")
void ArgumentCoder<WebCore::PixelBuffer>::encode(StreamConnectionEncoder& encoder, const WebCore::PixelBuffer& instance)
{
    if (auto* subclass = dynamicDowncast<WebCore::ByteArrayPixelBuffer>(instance)) {
        encoder << WebCore_PixelBuffer_Subclass::ByteArrayPixelBuffer;
        encoder << *subclass;
        return;
    }
    ASSERT_NOT_REACHED();
}
IGNORE_WARNINGS_END

std::optional<Ref<WebCore::PixelBuffer>> ArgumentCoder<WebCore::PixelBuffer>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore_PixelBuffer_Subclass>();
    UNUSED_PARAM(type);
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (type == WebCore_PixelBuffer_Subclass::ByteArrayPixelBuffer) {
        auto result = decoder.decode<Ref<WebCore::ByteArrayPixelBuffer>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    ASSERT_NOT_REACHED();
    return std::nullopt;
}

void ArgumentCoder<WebCore::MotionPathData>::encode(Encoder& encoder, const WebCore::MotionPathData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.containingBlockBoundingRect)>, WebCore::FloatRoundedRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offsetFromContainingBlock)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.usedStartingPosition)>, WebCore::FloatPoint>);
    struct ShouldBeSameSizeAsMotionPathData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MotionPathData>, false> {
        WebCore::FloatRoundedRect containingBlockBoundingRect;
        WebCore::FloatPoint offsetFromContainingBlock;
        WebCore::FloatPoint usedStartingPosition;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMotionPathData) == sizeof(WebCore::MotionPathData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MotionPathData, containingBlockBoundingRect)
        , offsetof(WebCore::MotionPathData, offsetFromContainingBlock)
        , offsetof(WebCore::MotionPathData, usedStartingPosition)
    >::value);

    encoder << instance.containingBlockBoundingRect;
    encoder << instance.offsetFromContainingBlock;
    encoder << instance.usedStartingPosition;
}

std::optional<WebCore::MotionPathData> ArgumentCoder<WebCore::MotionPathData>::decode(Decoder& decoder)
{
    auto containingBlockBoundingRect = decoder.decode<WebCore::FloatRoundedRect>();
    auto offsetFromContainingBlock = decoder.decode<WebCore::FloatPoint>();
    auto usedStartingPosition = decoder.decode<WebCore::FloatPoint>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MotionPathData {
            WTFMove(*containingBlockBoundingRect),
            WTFMove(*offsetFromContainingBlock),
            WTFMove(*usedStartingPosition)
        }
    };
}

void ArgumentCoder<WebCore::TransformOperationData>::encode(Encoder& encoder, const WebCore::TransformOperationData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.boundingBox)>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.motionPathData)>, std::optional<WebCore::MotionPathData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isSVGRenderer)>, bool>);
    struct ShouldBeSameSizeAsTransformOperationData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::TransformOperationData>, false> {
        WebCore::FloatRect boundingBox;
        std::optional<WebCore::MotionPathData> motionPathData;
        bool isSVGRenderer;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTransformOperationData) == sizeof(WebCore::TransformOperationData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::TransformOperationData, boundingBox)
        , offsetof(WebCore::TransformOperationData, motionPathData)
        , offsetof(WebCore::TransformOperationData, isSVGRenderer)
    >::value);

    encoder << instance.boundingBox;
    encoder << instance.motionPathData;
    encoder << instance.isSVGRenderer;
}

std::optional<WebCore::TransformOperationData> ArgumentCoder<WebCore::TransformOperationData>::decode(Decoder& decoder)
{
    auto boundingBox = decoder.decode<WebCore::FloatRect>();
    auto motionPathData = decoder.decode<std::optional<WebCore::MotionPathData>>();
    auto isSVGRenderer = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TransformOperationData {
            WTFMove(*boundingBox),
            WTFMove(*motionPathData),
            WTFMove(*isSVGRenderer)
        }
    };
}

void ArgumentCoder<WebCore::ReferencePathOperation>::encode(Encoder& encoder, const WebCore::ReferencePathOperation& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.path())>, std::optional<WebCore::Path>>);

    encoder << instance.path();
}

std::optional<Ref<WebCore::ReferencePathOperation>> ArgumentCoder<WebCore::ReferencePathOperation>::decode(Decoder& decoder)
{
    auto path = decoder.decode<std::optional<WebCore::Path>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ReferencePathOperation::create(
            WTFMove(*path)
        )
    };
}

void ArgumentCoder<WebCore::ShapePathOperation>::encode(Encoder& encoder, const WebCore::ShapePathOperation& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shape())>, WebCore::Style::BasicShape>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.referenceBox())>, WebCore::CSSBoxType>);

    encoder << instance.shape();
    encoder << instance.referenceBox();
}

std::optional<Ref<WebCore::ShapePathOperation>> ArgumentCoder<WebCore::ShapePathOperation>::decode(Decoder& decoder)
{
    auto shape = decoder.decode<WebCore::Style::BasicShape>();
    auto referenceBox = decoder.decode<WebCore::CSSBoxType>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ShapePathOperation::create(
            WTFMove(*shape),
            WTFMove(*referenceBox)
        )
    };
}

void ArgumentCoder<WebCore::BoxPathOperation>::encode(Encoder& encoder, const WebCore::BoxPathOperation& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.referenceBox())>, WebCore::CSSBoxType>);

    encoder << instance.referenceBox();
}

std::optional<Ref<WebCore::BoxPathOperation>> ArgumentCoder<WebCore::BoxPathOperation>::decode(Decoder& decoder)
{
    auto referenceBox = decoder.decode<WebCore::CSSBoxType>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::BoxPathOperation::create(
            WTFMove(*referenceBox)
        )
    };
}

void ArgumentCoder<WebCore::RayPathOperation>::encode(Encoder& encoder, const WebCore::RayPathOperation& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ray())>, WebCore::Style::RayFunction>);

    encoder << instance.ray();
}

std::optional<Ref<WebCore::RayPathOperation>> ArgumentCoder<WebCore::RayPathOperation>::decode(Decoder& decoder)
{
    auto ray = decoder.decode<WebCore::Style::RayFunction>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::RayPathOperation::create(
            WTFMove(*ray)
        )
    };
}

enum class WebCore_PathOperation_Subclass : IPC::EncodedVariantIndex {
    ReferencePathOperation
    , ShapePathOperation
    , BoxPathOperation
    , RayPathOperation
};

IGNORE_WARNINGS_BEGIN("missing-noreturn")
void ArgumentCoder<WebCore::PathOperation>::encode(Encoder& encoder, const WebCore::PathOperation& instance)
{
    if (auto* subclass = dynamicDowncast<WebCore::ReferencePathOperation>(instance)) {
        encoder << WebCore_PathOperation_Subclass::ReferencePathOperation;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::ShapePathOperation>(instance)) {
        encoder << WebCore_PathOperation_Subclass::ShapePathOperation;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::BoxPathOperation>(instance)) {
        encoder << WebCore_PathOperation_Subclass::BoxPathOperation;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::RayPathOperation>(instance)) {
        encoder << WebCore_PathOperation_Subclass::RayPathOperation;
        encoder << *subclass;
        return;
    }
    ASSERT_NOT_REACHED();
}
IGNORE_WARNINGS_END

std::optional<Ref<WebCore::PathOperation>> ArgumentCoder<WebCore::PathOperation>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore_PathOperation_Subclass>();
    UNUSED_PARAM(type);
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (type == WebCore_PathOperation_Subclass::ReferencePathOperation) {
        auto result = decoder.decode<Ref<WebCore::ReferencePathOperation>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_PathOperation_Subclass::ShapePathOperation) {
        auto result = decoder.decode<Ref<WebCore::ShapePathOperation>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_PathOperation_Subclass::BoxPathOperation) {
        auto result = decoder.decode<Ref<WebCore::BoxPathOperation>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_PathOperation_Subclass::RayPathOperation) {
        auto result = decoder.decode<Ref<WebCore::RayPathOperation>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    ASSERT_NOT_REACHED();
    return std::nullopt;
}

#if ENABLE(ENCRYPTED_MEDIA)
void ArgumentCoder<WebCore::CDMKeySystemConfiguration>::encode(Encoder& encoder, const WebCore::CDMKeySystemConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.initDataTypes)>, Vector<AtomString>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.audioCapabilities)>, Vector<WebCore::CDMMediaCapability>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.videoCapabilities)>, Vector<WebCore::CDMMediaCapability>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.distinctiveIdentifier)>, WebCore::CDMRequirement>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.persistentState)>, WebCore::CDMRequirement>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sessionTypes)>, Vector<WebCore::CDMSessionType>>);
    struct ShouldBeSameSizeAsCDMKeySystemConfiguration : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::CDMKeySystemConfiguration>, false> {
        String label;
        Vector<AtomString> initDataTypes;
        Vector<WebCore::CDMMediaCapability> audioCapabilities;
        Vector<WebCore::CDMMediaCapability> videoCapabilities;
        WebCore::CDMRequirement distinctiveIdentifier;
        WebCore::CDMRequirement persistentState;
        Vector<WebCore::CDMSessionType> sessionTypes;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCDMKeySystemConfiguration) == sizeof(WebCore::CDMKeySystemConfiguration));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::CDMKeySystemConfiguration, label)
        , offsetof(WebCore::CDMKeySystemConfiguration, initDataTypes)
        , offsetof(WebCore::CDMKeySystemConfiguration, audioCapabilities)
        , offsetof(WebCore::CDMKeySystemConfiguration, videoCapabilities)
        , offsetof(WebCore::CDMKeySystemConfiguration, distinctiveIdentifier)
        , offsetof(WebCore::CDMKeySystemConfiguration, persistentState)
        , offsetof(WebCore::CDMKeySystemConfiguration, sessionTypes)
    >::value);

    encoder << instance.label;
    encoder << instance.initDataTypes;
    encoder << instance.audioCapabilities;
    encoder << instance.videoCapabilities;
    encoder << instance.distinctiveIdentifier;
    encoder << instance.persistentState;
    encoder << instance.sessionTypes;
}

std::optional<WebCore::CDMKeySystemConfiguration> ArgumentCoder<WebCore::CDMKeySystemConfiguration>::decode(Decoder& decoder)
{
    auto label = decoder.decode<String>();
    auto initDataTypes = decoder.decode<Vector<AtomString>>();
    auto audioCapabilities = decoder.decode<Vector<WebCore::CDMMediaCapability>>();
    auto videoCapabilities = decoder.decode<Vector<WebCore::CDMMediaCapability>>();
    auto distinctiveIdentifier = decoder.decode<WebCore::CDMRequirement>();
    auto persistentState = decoder.decode<WebCore::CDMRequirement>();
    auto sessionTypes = decoder.decode<Vector<WebCore::CDMSessionType>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CDMKeySystemConfiguration {
            WTFMove(*label),
            WTFMove(*initDataTypes),
            WTFMove(*audioCapabilities),
            WTFMove(*videoCapabilities),
            WTFMove(*distinctiveIdentifier),
            WTFMove(*persistentState),
            WTFMove(*sessionTypes)
        }
    };
}

#endif

void ArgumentCoder<WebCore::MediaConfiguration>::encode(Encoder& encoder, const WebCore::MediaConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.video)>, std::optional<WebCore::VideoConfiguration>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.audio)>, std::optional<WebCore::AudioConfiguration>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowedMediaContainerTypes)>, std::optional<Vector<String>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowedMediaCodecTypes)>, std::optional<Vector<String>>>);
    struct ShouldBeSameSizeAsMediaConfiguration : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MediaConfiguration>, false> {
        std::optional<WebCore::VideoConfiguration> video;
        std::optional<WebCore::AudioConfiguration> audio;
        std::optional<Vector<String>> allowedMediaContainerTypes;
        std::optional<Vector<String>> allowedMediaCodecTypes;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMediaConfiguration) == sizeof(WebCore::MediaConfiguration));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MediaConfiguration, video)
        , offsetof(WebCore::MediaConfiguration, audio)
        , offsetof(WebCore::MediaConfiguration, allowedMediaContainerTypes)
        , offsetof(WebCore::MediaConfiguration, allowedMediaCodecTypes)
    >::value);

    encoder << instance.video;
    encoder << instance.audio;
    encoder << instance.allowedMediaContainerTypes;
    encoder << instance.allowedMediaCodecTypes;
}

std::optional<WebCore::MediaConfiguration> ArgumentCoder<WebCore::MediaConfiguration>::decode(Decoder& decoder)
{
    auto video = decoder.decode<std::optional<WebCore::VideoConfiguration>>();
    auto audio = decoder.decode<std::optional<WebCore::AudioConfiguration>>();
    auto allowedMediaContainerTypes = decoder.decode<std::optional<Vector<String>>>();
    auto allowedMediaCodecTypes = decoder.decode<std::optional<Vector<String>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MediaConfiguration {
            WTFMove(*video),
            WTFMove(*audio),
            WTFMove(*allowedMediaContainerTypes),
            WTFMove(*allowedMediaCodecTypes)
        }
    };
}

void ArgumentCoder<WebCore::MediaEncodingConfiguration>::encode(Encoder& encoder, const WebCore::MediaEncodingConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.video)>, std::optional<WebCore::VideoConfiguration>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.audio)>, std::optional<WebCore::AudioConfiguration>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowedMediaContainerTypes)>, std::optional<Vector<String>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowedMediaCodecTypes)>, std::optional<Vector<String>>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MediaConfiguration, video)
        , offsetof(WebCore::MediaConfiguration, audio)
        , offsetof(WebCore::MediaConfiguration, allowedMediaContainerTypes)
        , offsetof(WebCore::MediaConfiguration, allowedMediaCodecTypes)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::MediaEncodingType>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MediaEncodingConfiguration, type)
    >::value);

    encoder << instance.video;
    encoder << instance.audio;
    encoder << instance.allowedMediaContainerTypes;
    encoder << instance.allowedMediaCodecTypes;
    encoder << instance.type;
}

std::optional<WebCore::MediaEncodingConfiguration> ArgumentCoder<WebCore::MediaEncodingConfiguration>::decode(Decoder& decoder)
{
    auto video = decoder.decode<std::optional<WebCore::VideoConfiguration>>();
    auto audio = decoder.decode<std::optional<WebCore::AudioConfiguration>>();
    auto allowedMediaContainerTypes = decoder.decode<std::optional<Vector<String>>>();
    auto allowedMediaCodecTypes = decoder.decode<std::optional<Vector<String>>>();
    auto type = decoder.decode<WebCore::MediaEncodingType>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MediaEncodingConfiguration {
            WebCore::MediaConfiguration {
                WTFMove(*video),
                WTFMove(*audio),
                WTFMove(*allowedMediaContainerTypes),
                WTFMove(*allowedMediaCodecTypes)
            },
            WTFMove(*type)
        }
    };
}

void ArgumentCoder<WebCore::MediaDecodingConfiguration>::encode(Encoder& encoder, const WebCore::MediaDecodingConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.video)>, std::optional<WebCore::VideoConfiguration>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.audio)>, std::optional<WebCore::AudioConfiguration>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowedMediaContainerTypes)>, std::optional<Vector<String>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowedMediaCodecTypes)>, std::optional<Vector<String>>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MediaConfiguration, video)
        , offsetof(WebCore::MediaConfiguration, audio)
        , offsetof(WebCore::MediaConfiguration, allowedMediaContainerTypes)
        , offsetof(WebCore::MediaConfiguration, allowedMediaCodecTypes)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::MediaDecodingType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pageIdentifier)>, std::optional<WebCore::PageIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.canExposeVP9)>, bool>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MediaDecodingConfiguration, type)
        , offsetof(WebCore::MediaDecodingConfiguration, pageIdentifier)
        , offsetof(WebCore::MediaDecodingConfiguration, canExposeVP9)
    >::value);

    encoder << instance.video;
    encoder << instance.audio;
    encoder << instance.allowedMediaContainerTypes;
    encoder << instance.allowedMediaCodecTypes;
    encoder << instance.type;
    encoder << instance.pageIdentifier;
    encoder << instance.canExposeVP9;
}

std::optional<WebCore::MediaDecodingConfiguration> ArgumentCoder<WebCore::MediaDecodingConfiguration>::decode(Decoder& decoder)
{
    auto video = decoder.decode<std::optional<WebCore::VideoConfiguration>>();
    auto audio = decoder.decode<std::optional<WebCore::AudioConfiguration>>();
    auto allowedMediaContainerTypes = decoder.decode<std::optional<Vector<String>>>();
    auto allowedMediaCodecTypes = decoder.decode<std::optional<Vector<String>>>();
    auto type = decoder.decode<WebCore::MediaDecodingType>();
    auto pageIdentifier = decoder.decode<std::optional<WebCore::PageIdentifier>>();
    auto canExposeVP9 = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MediaDecodingConfiguration {
            WebCore::MediaConfiguration {
                WTFMove(*video),
                WTFMove(*audio),
                WTFMove(*allowedMediaContainerTypes),
                WTFMove(*allowedMediaCodecTypes)
            },
            WTFMove(*type),
            WTFMove(*pageIdentifier),
            WTFMove(*canExposeVP9)
        }
    };
}

void ArgumentCoder<WebCore::ResourceResponseBase>::encode(Encoder& encoder, const WebCore::ResourceResponseBase& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.getResponseData())>, std::optional<WebCore::ResourceResponseData>>);

    encoder << instance.getResponseData();
}

std::optional<WebCore::ResourceResponseBase> ArgumentCoder<WebCore::ResourceResponseBase>::decode(Decoder& decoder)
{
    auto getResponseData = decoder.decode<std::optional<WebCore::ResourceResponseData>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ResourceResponseBase {
            WTFMove(*getResponseData)
        }
    };
}

void ArgumentCoder<WebCore::ResourceResponse>::encode(Encoder& encoder, const WebCore::ResourceResponse& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.getResponseData())>, std::optional<WebCore::ResourceResponseData>>);

    static_assert(MembersInCorrectOrder < 0
    >::value);

    encoder << instance.getResponseData();
}

std::optional<WebCore::ResourceResponse> ArgumentCoder<WebCore::ResourceResponse>::decode(Decoder& decoder)
{
    auto getResponseData = decoder.decode<std::optional<WebCore::ResourceResponseData>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ResourceResponse {
            WebCore::ResourceResponseBase {
                WTFMove(*getResponseData)
            }
        }
    };
}

void ArgumentCoder<WebCore::ResourceResponseData>::encode(Encoder& encoder, const WebCore::ResourceResponseData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mimeType)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.expectedContentLength)>, long long>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.textEncodingName)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.httpStatusCode)>, short>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.httpStatusText)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.httpVersion)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.httpHeaderFields)>, WebCore::HTTPHeaderMap>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.networkLoadMetrics)>, std::optional<WebCore::NetworkLoadMetrics>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.source)>, WebCore::ResourceResponseBase::Source>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::ResourceResponseBase::Type>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tainting)>, WebCore::ResourceResponseBase::Tainting>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isRedirected)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.usedLegacyTLS)>, WebCore::UsedLegacyTLS>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.wasPrivateRelayed)>, WebCore::WasPrivateRelayed>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.proxyName)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isRangeRequested)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.certificateInfo)>, std::optional<WebCore::CertificateInfo>>);
    struct ShouldBeSameSizeAsResourceResponseData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ResourceResponseData>, false> {
        URL url;
        String mimeType;
        long long expectedContentLength;
        String textEncodingName;
        short httpStatusCode;
        String httpStatusText;
        String httpVersion;
        WebCore::HTTPHeaderMap httpHeaderFields;
        std::optional<WebCore::NetworkLoadMetrics> networkLoadMetrics;
        WebCore::ResourceResponseBase::Source source;
        WebCore::ResourceResponseBase::Type type;
        WebCore::ResourceResponseBase::Tainting tainting;
        bool isRedirected;
        WebCore::UsedLegacyTLS usedLegacyTLS;
        WebCore::WasPrivateRelayed wasPrivateRelayed;
        String proxyName;
        bool isRangeRequested;
        std::optional<WebCore::CertificateInfo> certificateInfo;
    };
    static_assert(sizeof(ShouldBeSameSizeAsResourceResponseData) == sizeof(WebCore::ResourceResponseData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ResourceResponseData, url)
        , offsetof(WebCore::ResourceResponseData, mimeType)
        , offsetof(WebCore::ResourceResponseData, expectedContentLength)
        , offsetof(WebCore::ResourceResponseData, textEncodingName)
        , offsetof(WebCore::ResourceResponseData, httpStatusCode)
        , offsetof(WebCore::ResourceResponseData, httpStatusText)
        , offsetof(WebCore::ResourceResponseData, httpVersion)
        , offsetof(WebCore::ResourceResponseData, httpHeaderFields)
        , offsetof(WebCore::ResourceResponseData, networkLoadMetrics)
        , offsetof(WebCore::ResourceResponseData, source)
        , offsetof(WebCore::ResourceResponseData, type)
        , offsetof(WebCore::ResourceResponseData, tainting)
        , offsetof(WebCore::ResourceResponseData, isRedirected)
        , offsetof(WebCore::ResourceResponseData, usedLegacyTLS)
        , offsetof(WebCore::ResourceResponseData, wasPrivateRelayed)
        , offsetof(WebCore::ResourceResponseData, proxyName)
        , offsetof(WebCore::ResourceResponseData, isRangeRequested)
        , offsetof(WebCore::ResourceResponseData, certificateInfo)
    >::value);

    encoder << instance.url;
    encoder << instance.mimeType;
    encoder << instance.expectedContentLength;
    encoder << instance.textEncodingName;
    encoder << instance.httpStatusCode;
    encoder << instance.httpStatusText;
    encoder << instance.httpVersion;
    encoder << instance.httpHeaderFields;
    encoder << instance.networkLoadMetrics;
    encoder << instance.source;
    encoder << instance.type;
    encoder << instance.tainting;
    encoder << instance.isRedirected;
    encoder << instance.usedLegacyTLS;
    encoder << instance.wasPrivateRelayed;
    encoder << instance.proxyName;
    encoder << instance.isRangeRequested;
    encoder << instance.certificateInfo;
}

std::optional<WebCore::ResourceResponseData> ArgumentCoder<WebCore::ResourceResponseData>::decode(Decoder& decoder)
{
    auto url = decoder.decode<URL>();
    auto mimeType = decoder.decode<String>();
    auto expectedContentLength = decoder.decode<long long>();
    auto textEncodingName = decoder.decode<String>();
    auto httpStatusCode = decoder.decode<short>();
    auto httpStatusText = decoder.decode<String>();
    auto httpVersion = decoder.decode<String>();
    auto httpHeaderFields = decoder.decode<WebCore::HTTPHeaderMap>();
    auto networkLoadMetrics = decoder.decode<std::optional<WebCore::NetworkLoadMetrics>>();
    auto source = decoder.decode<WebCore::ResourceResponseBase::Source>();
    auto type = decoder.decode<WebCore::ResourceResponseBase::Type>();
    auto tainting = decoder.decode<WebCore::ResourceResponseBase::Tainting>();
    auto isRedirected = decoder.decode<bool>();
    auto usedLegacyTLS = decoder.decode<WebCore::UsedLegacyTLS>();
    auto wasPrivateRelayed = decoder.decode<WebCore::WasPrivateRelayed>();
    auto proxyName = decoder.decode<String>();
    auto isRangeRequested = decoder.decode<bool>();
    auto certificateInfo = decoder.decode<std::optional<WebCore::CertificateInfo>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ResourceResponseData {
            WTFMove(*url),
            WTFMove(*mimeType),
            WTFMove(*expectedContentLength),
            WTFMove(*textEncodingName),
            WTFMove(*httpStatusCode),
            WTFMove(*httpStatusText),
            WTFMove(*httpVersion),
            WTFMove(*httpHeaderFields),
            WTFMove(*networkLoadMetrics),
            WTFMove(*source),
            WTFMove(*type),
            WTFMove(*tainting),
            WTFMove(*isRedirected),
            WTFMove(*usedLegacyTLS),
            WTFMove(*wasPrivateRelayed),
            WTFMove(*proxyName),
            WTFMove(*isRangeRequested),
            WTFMove(*certificateInfo)
        }
    };
}

#if PLATFORM(COCOA)
void ArgumentCoder<WebCore::ArchiveResource>::encode(Encoder& encoder, const WebCore::ArchiveResource& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.protectedData())>, Ref<WebCore::FragmentedSharedBuffer>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url())>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mimeType())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.textEncoding())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameName())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.response())>, WebCore::ResourceResponse>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.relativeFilePath())>, String>);

    encoder << instance.protectedData();
    encoder << instance.url();
    encoder << instance.mimeType();
    encoder << instance.textEncoding();
    encoder << instance.frameName();
    encoder << instance.response();
    encoder << instance.relativeFilePath();
}

std::optional<Ref<WebCore::ArchiveResource>> ArgumentCoder<WebCore::ArchiveResource>::decode(Decoder& decoder)
{
    auto protectedData = decoder.decode<Ref<WebCore::FragmentedSharedBuffer>>();
    auto url = decoder.decode<URL>();
    auto mimeType = decoder.decode<String>();
    auto textEncoding = decoder.decode<String>();
    auto frameName = decoder.decode<String>();
    auto response = decoder.decode<WebCore::ResourceResponse>();
    auto relativeFilePath = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ArchiveResource::createWithData(
            WTFMove(*protectedData),
            WTFMove(*url),
            WTFMove(*mimeType),
            WTFMove(*textEncoding),
            WTFMove(*frameName),
            WTFMove(*response),
            WTFMove(*relativeFilePath)
        )
    };
}

#endif

#if PLATFORM(COCOA)
void ArgumentCoder<WebCore::LegacyWebArchive>::encode(Encoder& encoder, const WebCore::LegacyWebArchive& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.protectedMainResource())>, Ref<WebCore::ArchiveResource>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.subresources())>, Vector<Ref<WebCore::ArchiveResource>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.subframeIdentifiers())>, Vector<WebCore::FrameIdentifier>>);

    encoder << instance.protectedMainResource();
    encoder << instance.subresources();
    encoder << instance.subframeIdentifiers();
}

std::optional<Ref<WebCore::LegacyWebArchive>> ArgumentCoder<WebCore::LegacyWebArchive>::decode(Decoder& decoder)
{
    auto protectedMainResource = decoder.decode<Ref<WebCore::ArchiveResource>>();
    auto subresources = decoder.decode<Vector<Ref<WebCore::ArchiveResource>>>();
    auto subframeIdentifiers = decoder.decode<Vector<WebCore::FrameIdentifier>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::LegacyWebArchive::create(
            WTFMove(*protectedMainResource),
            WTFMove(*subresources),
            WTFMove(*subframeIdentifiers)
        )
    };
}

#endif

void ArgumentCoder<WebCore::FetchOptions>::encode(Encoder& encoder, const WebCore::FetchOptions& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.destination)>, WebCore::FetchOptionsDestination>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mode)>, WebCore::FetchOptionsMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.credentials)>, WebCore::FetchOptionsCredentials>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cache)>, WebCore::FetchOptionsCache>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.redirect)>, WebCore::FetchOptionsRedirect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.referrerPolicy)>, WebCore::ReferrerPolicy>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.keepAlive)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.integrity)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.clientIdentifier)>, Markable<WTF::UUID>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.resultingClientIdentifier)>, Markable<WTF::UUID>>);
    struct ShouldBeSameSizeAsFetchOptions : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FetchOptions>, false> {
        WebCore::FetchOptionsDestination destination;
        WebCore::FetchOptionsMode mode;
        WebCore::FetchOptionsCredentials credentials;
        WebCore::FetchOptionsCache cache;
        WebCore::FetchOptionsRedirect redirect;
        WebCore::ReferrerPolicy referrerPolicy;
        bool keepAlive;
        String integrity;
        Markable<WTF::UUID> clientIdentifier;
        Markable<WTF::UUID> resultingClientIdentifier;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFetchOptions) == sizeof(WebCore::FetchOptions));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FetchOptions, destination)
        , offsetof(WebCore::FetchOptions, mode)
        , offsetof(WebCore::FetchOptions, credentials)
        , offsetof(WebCore::FetchOptions, cache)
        , offsetof(WebCore::FetchOptions, redirect)
        , offsetof(WebCore::FetchOptions, referrerPolicy)
        , offsetof(WebCore::FetchOptions, keepAlive)
        , offsetof(WebCore::FetchOptions, integrity)
        , offsetof(WebCore::FetchOptions, clientIdentifier)
        , offsetof(WebCore::FetchOptions, resultingClientIdentifier)
    >::value);

    encoder << instance.destination;
    encoder << instance.mode;
    encoder << instance.credentials;
    encoder << instance.cache;
    encoder << instance.redirect;
    encoder << instance.referrerPolicy;
    encoder << instance.keepAlive;
    encoder << instance.integrity;
    encoder << instance.clientIdentifier;
    encoder << instance.resultingClientIdentifier;
}

std::optional<WebCore::FetchOptions> ArgumentCoder<WebCore::FetchOptions>::decode(Decoder& decoder)
{
    auto destination = decoder.decode<WebCore::FetchOptionsDestination>();
    auto mode = decoder.decode<WebCore::FetchOptionsMode>();
    auto credentials = decoder.decode<WebCore::FetchOptionsCredentials>();
    auto cache = decoder.decode<WebCore::FetchOptionsCache>();
    auto redirect = decoder.decode<WebCore::FetchOptionsRedirect>();
    auto referrerPolicy = decoder.decode<WebCore::ReferrerPolicy>();
    auto keepAlive = decoder.decode<bool>();
    auto integrity = decoder.decode<String>();
    auto clientIdentifier = decoder.decode<Markable<WTF::UUID>>();
    auto resultingClientIdentifier = decoder.decode<Markable<WTF::UUID>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FetchOptions {
            WTFMove(*destination),
            WTFMove(*mode),
            WTFMove(*credentials),
            WTFMove(*cache),
            WTFMove(*redirect),
            WTFMove(*referrerPolicy),
            WTFMove(*keepAlive),
            WTFMove(*integrity),
            WTFMove(*clientIdentifier),
            WTFMove(*resultingClientIdentifier)
        }
    };
}

void ArgumentCoder<WebCore::ControlStyle>::encode(Encoder& encoder, const WebCore::ControlStyle& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.states)>, OptionSet<WebCore::ControlStyle::State>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fontSize)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.zoomFactor)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.accentColor)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.textColor)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.borderWidth)>, WebCore::FloatBoxExtent>);
    struct ShouldBeSameSizeAsControlStyle : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ControlStyle>, false> {
        OptionSet<WebCore::ControlStyle::State> states;
        float fontSize;
        float zoomFactor;
        WebCore::Color accentColor;
        WebCore::Color textColor;
        WebCore::FloatBoxExtent borderWidth;
    };
    static_assert(sizeof(ShouldBeSameSizeAsControlStyle) == sizeof(WebCore::ControlStyle));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ControlStyle, states)
        , offsetof(WebCore::ControlStyle, fontSize)
        , offsetof(WebCore::ControlStyle, zoomFactor)
        , offsetof(WebCore::ControlStyle, accentColor)
        , offsetof(WebCore::ControlStyle, textColor)
        , offsetof(WebCore::ControlStyle, borderWidth)
    >::value);

    encoder << instance.states;
    encoder << instance.fontSize;
    encoder << instance.zoomFactor;
    encoder << instance.accentColor;
    encoder << instance.textColor;
    encoder << instance.borderWidth;
}

void ArgumentCoder<WebCore::ControlStyle>::encode(StreamConnectionEncoder& encoder, const WebCore::ControlStyle& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.states)>, OptionSet<WebCore::ControlStyle::State>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fontSize)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.zoomFactor)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.accentColor)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.textColor)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.borderWidth)>, WebCore::FloatBoxExtent>);
    struct ShouldBeSameSizeAsControlStyle : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ControlStyle>, false> {
        OptionSet<WebCore::ControlStyle::State> states;
        float fontSize;
        float zoomFactor;
        WebCore::Color accentColor;
        WebCore::Color textColor;
        WebCore::FloatBoxExtent borderWidth;
    };
    static_assert(sizeof(ShouldBeSameSizeAsControlStyle) == sizeof(WebCore::ControlStyle));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ControlStyle, states)
        , offsetof(WebCore::ControlStyle, fontSize)
        , offsetof(WebCore::ControlStyle, zoomFactor)
        , offsetof(WebCore::ControlStyle, accentColor)
        , offsetof(WebCore::ControlStyle, textColor)
        , offsetof(WebCore::ControlStyle, borderWidth)
    >::value);

    encoder << instance.states;
    encoder << instance.fontSize;
    encoder << instance.zoomFactor;
    encoder << instance.accentColor;
    encoder << instance.textColor;
    encoder << instance.borderWidth;
}

std::optional<WebCore::ControlStyle> ArgumentCoder<WebCore::ControlStyle>::decode(Decoder& decoder)
{
    auto states = decoder.decode<OptionSet<WebCore::ControlStyle::State>>();
    auto fontSize = decoder.decode<float>();
    auto zoomFactor = decoder.decode<float>();
    auto accentColor = decoder.decode<WebCore::Color>();
    auto textColor = decoder.decode<WebCore::Color>();
    auto borderWidth = decoder.decode<WebCore::FloatBoxExtent>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ControlStyle {
            WTFMove(*states),
            WTFMove(*fontSize),
            WTFMove(*zoomFactor),
            WTFMove(*accentColor),
            WTFMove(*textColor),
            WTFMove(*borderWidth)
        }
    };
}

enum class WebCore_ControlPart_Subclass : IPC::EncodedVariantIndex {
    ButtonPart
    , ColorWellPart
    , InnerSpinButtonPart
    , MenuListButtonPart
    , MenuListPart
    , MeterPart
    , ProgressBarPart
    , SearchFieldPart
    , SearchFieldResultsPart
    , SearchFieldCancelButtonPart
    , SliderThumbPart
    , SliderTrackPart
    , SwitchThumbPart
    , SwitchTrackPart
    , TextAreaPart
    , TextFieldPart
    , ToggleButtonPart
#if ENABLE(APPLE_PAY)
    , ApplePayButtonPart
#endif
#if ENABLE(SERVICE_CONTROLS)
    , ImageControlsButtonPart
#endif
};

IGNORE_WARNINGS_BEGIN("missing-noreturn")
void ArgumentCoder<WebCore::ControlPart>::encode(Encoder& encoder, const WebCore::ControlPart& instance)
{
    if (auto* subclass = dynamicDowncast<WebCore::ButtonPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::ButtonPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::ColorWellPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::ColorWellPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::InnerSpinButtonPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::InnerSpinButtonPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::MenuListButtonPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::MenuListButtonPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::MenuListPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::MenuListPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::MeterPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::MeterPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::ProgressBarPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::ProgressBarPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::SearchFieldPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::SearchFieldPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::SearchFieldResultsPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::SearchFieldResultsPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::SearchFieldCancelButtonPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::SearchFieldCancelButtonPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::SliderThumbPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::SliderThumbPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::SliderTrackPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::SliderTrackPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::SwitchThumbPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::SwitchThumbPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::SwitchTrackPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::SwitchTrackPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::TextAreaPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::TextAreaPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::TextFieldPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::TextFieldPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::ToggleButtonPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::ToggleButtonPart;
        encoder << *subclass;
        return;
    }
#if ENABLE(APPLE_PAY)
    if (auto* subclass = dynamicDowncast<WebCore::ApplePayButtonPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::ApplePayButtonPart;
        encoder << *subclass;
        return;
    }
#endif
#if ENABLE(SERVICE_CONTROLS)
    if (auto* subclass = dynamicDowncast<WebCore::ImageControlsButtonPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::ImageControlsButtonPart;
        encoder << *subclass;
        return;
    }
#endif
    ASSERT_NOT_REACHED();
}
IGNORE_WARNINGS_END

IGNORE_WARNINGS_BEGIN("missing-noreturn")
void ArgumentCoder<WebCore::ControlPart>::encode(StreamConnectionEncoder& encoder, const WebCore::ControlPart& instance)
{
    if (auto* subclass = dynamicDowncast<WebCore::ButtonPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::ButtonPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::ColorWellPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::ColorWellPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::InnerSpinButtonPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::InnerSpinButtonPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::MenuListButtonPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::MenuListButtonPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::MenuListPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::MenuListPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::MeterPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::MeterPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::ProgressBarPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::ProgressBarPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::SearchFieldPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::SearchFieldPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::SearchFieldResultsPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::SearchFieldResultsPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::SearchFieldCancelButtonPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::SearchFieldCancelButtonPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::SliderThumbPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::SliderThumbPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::SliderTrackPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::SliderTrackPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::SwitchThumbPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::SwitchThumbPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::SwitchTrackPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::SwitchTrackPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::TextAreaPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::TextAreaPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::TextFieldPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::TextFieldPart;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::ToggleButtonPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::ToggleButtonPart;
        encoder << *subclass;
        return;
    }
#if ENABLE(APPLE_PAY)
    if (auto* subclass = dynamicDowncast<WebCore::ApplePayButtonPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::ApplePayButtonPart;
        encoder << *subclass;
        return;
    }
#endif
#if ENABLE(SERVICE_CONTROLS)
    if (auto* subclass = dynamicDowncast<WebCore::ImageControlsButtonPart>(instance)) {
        encoder << WebCore_ControlPart_Subclass::ImageControlsButtonPart;
        encoder << *subclass;
        return;
    }
#endif
    ASSERT_NOT_REACHED();
}
IGNORE_WARNINGS_END

std::optional<Ref<WebCore::ControlPart>> ArgumentCoder<WebCore::ControlPart>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore_ControlPart_Subclass>();
    UNUSED_PARAM(type);
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (type == WebCore_ControlPart_Subclass::ButtonPart) {
        auto result = decoder.decode<Ref<WebCore::ButtonPart>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_ControlPart_Subclass::ColorWellPart) {
        auto result = decoder.decode<Ref<WebCore::ColorWellPart>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_ControlPart_Subclass::InnerSpinButtonPart) {
        auto result = decoder.decode<Ref<WebCore::InnerSpinButtonPart>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_ControlPart_Subclass::MenuListButtonPart) {
        auto result = decoder.decode<Ref<WebCore::MenuListButtonPart>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_ControlPart_Subclass::MenuListPart) {
        auto result = decoder.decode<Ref<WebCore::MenuListPart>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_ControlPart_Subclass::MeterPart) {
        auto result = decoder.decode<Ref<WebCore::MeterPart>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_ControlPart_Subclass::ProgressBarPart) {
        auto result = decoder.decode<Ref<WebCore::ProgressBarPart>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_ControlPart_Subclass::SearchFieldPart) {
        auto result = decoder.decode<Ref<WebCore::SearchFieldPart>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_ControlPart_Subclass::SearchFieldResultsPart) {
        auto result = decoder.decode<Ref<WebCore::SearchFieldResultsPart>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_ControlPart_Subclass::SearchFieldCancelButtonPart) {
        auto result = decoder.decode<Ref<WebCore::SearchFieldCancelButtonPart>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_ControlPart_Subclass::SliderThumbPart) {
        auto result = decoder.decode<Ref<WebCore::SliderThumbPart>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_ControlPart_Subclass::SliderTrackPart) {
        auto result = decoder.decode<Ref<WebCore::SliderTrackPart>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_ControlPart_Subclass::SwitchThumbPart) {
        auto result = decoder.decode<Ref<WebCore::SwitchThumbPart>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_ControlPart_Subclass::SwitchTrackPart) {
        auto result = decoder.decode<Ref<WebCore::SwitchTrackPart>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_ControlPart_Subclass::TextAreaPart) {
        auto result = decoder.decode<Ref<WebCore::TextAreaPart>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_ControlPart_Subclass::TextFieldPart) {
        auto result = decoder.decode<Ref<WebCore::TextFieldPart>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_ControlPart_Subclass::ToggleButtonPart) {
        auto result = decoder.decode<Ref<WebCore::ToggleButtonPart>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
#if ENABLE(APPLE_PAY)
    if (type == WebCore_ControlPart_Subclass::ApplePayButtonPart) {
        auto result = decoder.decode<Ref<WebCore::ApplePayButtonPart>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
#endif
#if ENABLE(SERVICE_CONTROLS)
    if (type == WebCore_ControlPart_Subclass::ImageControlsButtonPart) {
        auto result = decoder.decode<Ref<WebCore::ImageControlsButtonPart>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
#endif
    ASSERT_NOT_REACHED();
    return std::nullopt;
}

void ArgumentCoder<WebCore::ButtonPart>::encode(Encoder& encoder, const WebCore::ButtonPart& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebCore::StyleAppearance>);

    encoder << instance.type();
}

void ArgumentCoder<WebCore::ButtonPart>::encode(StreamConnectionEncoder& encoder, const WebCore::ButtonPart& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebCore::StyleAppearance>);

    encoder << instance.type();
}

std::optional<Ref<WebCore::ButtonPart>> ArgumentCoder<WebCore::ButtonPart>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::StyleAppearance>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(type == WebCore::StyleAppearance::Button || type == WebCore::StyleAppearance::DefaultButton || type == WebCore::StyleAppearance::PushButton || type == WebCore::StyleAppearance::SquareButton))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ButtonPart::create(
            WTFMove(*type)
        )
    };
}

void ArgumentCoder<WebCore::InnerSpinButtonPart>::encode(Encoder& encoder, const WebCore::InnerSpinButtonPart& instance)
{

}

void ArgumentCoder<WebCore::InnerSpinButtonPart>::encode(StreamConnectionEncoder& encoder, const WebCore::InnerSpinButtonPart& instance)
{

}

std::optional<Ref<WebCore::InnerSpinButtonPart>> ArgumentCoder<WebCore::InnerSpinButtonPart>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::InnerSpinButtonPart::create(
        )
    };
}

void ArgumentCoder<WebCore::MenuListButtonPart>::encode(Encoder& encoder, const WebCore::MenuListButtonPart& instance)
{

}

void ArgumentCoder<WebCore::MenuListButtonPart>::encode(StreamConnectionEncoder& encoder, const WebCore::MenuListButtonPart& instance)
{

}

std::optional<Ref<WebCore::MenuListButtonPart>> ArgumentCoder<WebCore::MenuListButtonPart>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MenuListButtonPart::create(
        )
    };
}

void ArgumentCoder<WebCore::MenuListPart>::encode(Encoder& encoder, const WebCore::MenuListPart& instance)
{

}

void ArgumentCoder<WebCore::MenuListPart>::encode(StreamConnectionEncoder& encoder, const WebCore::MenuListPart& instance)
{

}

std::optional<Ref<WebCore::MenuListPart>> ArgumentCoder<WebCore::MenuListPart>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MenuListPart::create(
        )
    };
}

void ArgumentCoder<WebCore::SearchFieldPart>::encode(Encoder& encoder, const WebCore::SearchFieldPart& instance)
{

}

void ArgumentCoder<WebCore::SearchFieldPart>::encode(StreamConnectionEncoder& encoder, const WebCore::SearchFieldPart& instance)
{

}

std::optional<Ref<WebCore::SearchFieldPart>> ArgumentCoder<WebCore::SearchFieldPart>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SearchFieldPart::create(
        )
    };
}

void ArgumentCoder<WebCore::SliderThumbPart>::encode(Encoder& encoder, const WebCore::SliderThumbPart& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebCore::StyleAppearance>);

    encoder << instance.type();
}

void ArgumentCoder<WebCore::SliderThumbPart>::encode(StreamConnectionEncoder& encoder, const WebCore::SliderThumbPart& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebCore::StyleAppearance>);

    encoder << instance.type();
}

std::optional<Ref<WebCore::SliderThumbPart>> ArgumentCoder<WebCore::SliderThumbPart>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::StyleAppearance>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(type == WebCore::StyleAppearance::SliderThumbHorizontal || type == WebCore::StyleAppearance::SliderThumbVertical))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SliderThumbPart::create(
            WTFMove(*type)
        )
    };
}

void ArgumentCoder<WebCore::SearchFieldResultsPart>::encode(Encoder& encoder, const WebCore::SearchFieldResultsPart& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebCore::StyleAppearance>);

    encoder << instance.type();
}

void ArgumentCoder<WebCore::SearchFieldResultsPart>::encode(StreamConnectionEncoder& encoder, const WebCore::SearchFieldResultsPart& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebCore::StyleAppearance>);

    encoder << instance.type();
}

std::optional<Ref<WebCore::SearchFieldResultsPart>> ArgumentCoder<WebCore::SearchFieldResultsPart>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::StyleAppearance>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(type == WebCore::StyleAppearance::SearchFieldResultsButton || type == WebCore::StyleAppearance::SearchFieldResultsDecoration))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SearchFieldResultsPart::create(
            WTFMove(*type)
        )
    };
}

void ArgumentCoder<WebCore::SearchFieldCancelButtonPart>::encode(Encoder& encoder, const WebCore::SearchFieldCancelButtonPart& instance)
{

}

void ArgumentCoder<WebCore::SearchFieldCancelButtonPart>::encode(StreamConnectionEncoder& encoder, const WebCore::SearchFieldCancelButtonPart& instance)
{

}

std::optional<Ref<WebCore::SearchFieldCancelButtonPart>> ArgumentCoder<WebCore::SearchFieldCancelButtonPart>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SearchFieldCancelButtonPart::create(
        )
    };
}

void ArgumentCoder<WebCore::TextAreaPart>::encode(Encoder& encoder, const WebCore::TextAreaPart& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebCore::StyleAppearance>);

    encoder << instance.type();
}

void ArgumentCoder<WebCore::TextAreaPart>::encode(StreamConnectionEncoder& encoder, const WebCore::TextAreaPart& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebCore::StyleAppearance>);

    encoder << instance.type();
}

std::optional<Ref<WebCore::TextAreaPart>> ArgumentCoder<WebCore::TextAreaPart>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::StyleAppearance>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(type == WebCore::StyleAppearance::Listbox || type == WebCore::StyleAppearance::TextArea))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TextAreaPart::create(
            WTFMove(*type)
        )
    };
}

void ArgumentCoder<WebCore::TextFieldPart>::encode(Encoder& encoder, const WebCore::TextFieldPart& instance)
{

}

void ArgumentCoder<WebCore::TextFieldPart>::encode(StreamConnectionEncoder& encoder, const WebCore::TextFieldPart& instance)
{

}

std::optional<Ref<WebCore::TextFieldPart>> ArgumentCoder<WebCore::TextFieldPart>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TextFieldPart::create(
        )
    };
}

void ArgumentCoder<WebCore::ToggleButtonPart>::encode(Encoder& encoder, const WebCore::ToggleButtonPart& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebCore::StyleAppearance>);

    encoder << instance.type();
}

void ArgumentCoder<WebCore::ToggleButtonPart>::encode(StreamConnectionEncoder& encoder, const WebCore::ToggleButtonPart& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebCore::StyleAppearance>);

    encoder << instance.type();
}

std::optional<Ref<WebCore::ToggleButtonPart>> ArgumentCoder<WebCore::ToggleButtonPart>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::StyleAppearance>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(type == WebCore::StyleAppearance::Checkbox || type == WebCore::StyleAppearance::Radio))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ToggleButtonPart::create(
            WTFMove(*type)
        )
    };
}

#if ENABLE(SERVICE_CONTROLS)
void ArgumentCoder<WebCore::ImageControlsButtonPart>::encode(Encoder& encoder, const WebCore::ImageControlsButtonPart& instance)
{

}

void ArgumentCoder<WebCore::ImageControlsButtonPart>::encode(StreamConnectionEncoder& encoder, const WebCore::ImageControlsButtonPart& instance)
{

}

std::optional<Ref<WebCore::ImageControlsButtonPart>> ArgumentCoder<WebCore::ImageControlsButtonPart>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ImageControlsButtonPart::create(
        )
    };
}

#endif

void ArgumentCoder<WebCore::ColorWellPart>::encode(Encoder& encoder, const WebCore::ColorWellPart& instance)
{

}

void ArgumentCoder<WebCore::ColorWellPart>::encode(StreamConnectionEncoder& encoder, const WebCore::ColorWellPart& instance)
{

}

std::optional<Ref<WebCore::ColorWellPart>> ArgumentCoder<WebCore::ColorWellPart>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ColorWellPart::create(
        )
    };
}

#if ENABLE(APPLE_PAY)
void ArgumentCoder<WebCore::ApplePayButtonPart>::encode(Encoder& encoder, const WebCore::ApplePayButtonPart& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.buttonType())>, WebCore::ApplePayButtonType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.buttonStyle())>, WebCore::ApplePayButtonStyle>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.locale())>, String>);

    encoder << instance.buttonType();
    encoder << instance.buttonStyle();
    encoder << instance.locale();
}

void ArgumentCoder<WebCore::ApplePayButtonPart>::encode(StreamConnectionEncoder& encoder, const WebCore::ApplePayButtonPart& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.buttonType())>, WebCore::ApplePayButtonType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.buttonStyle())>, WebCore::ApplePayButtonStyle>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.locale())>, String>);

    encoder << instance.buttonType();
    encoder << instance.buttonStyle();
    encoder << instance.locale();
}

std::optional<Ref<WebCore::ApplePayButtonPart>> ArgumentCoder<WebCore::ApplePayButtonPart>::decode(Decoder& decoder)
{
    auto buttonType = decoder.decode<WebCore::ApplePayButtonType>();
    auto buttonStyle = decoder.decode<WebCore::ApplePayButtonStyle>();
    auto locale = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ApplePayButtonPart::create(
            WTFMove(*buttonType),
            WTFMove(*buttonStyle),
            WTFMove(*locale)
        )
    };
}

#endif

void ArgumentCoder<WebCore::MeterPart>::encode(Encoder& encoder, const WebCore::MeterPart& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.gaugeRegion())>, WebCore::MeterPart::GaugeRegion>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.minimum())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maximum())>, double>);

    encoder << instance.gaugeRegion();
    encoder << instance.value();
    encoder << instance.minimum();
    encoder << instance.maximum();
}

void ArgumentCoder<WebCore::MeterPart>::encode(StreamConnectionEncoder& encoder, const WebCore::MeterPart& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.gaugeRegion())>, WebCore::MeterPart::GaugeRegion>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.minimum())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maximum())>, double>);

    encoder << instance.gaugeRegion();
    encoder << instance.value();
    encoder << instance.minimum();
    encoder << instance.maximum();
}

std::optional<Ref<WebCore::MeterPart>> ArgumentCoder<WebCore::MeterPart>::decode(Decoder& decoder)
{
    auto gaugeRegion = decoder.decode<WebCore::MeterPart::GaugeRegion>();
    auto value = decoder.decode<double>();
    auto minimum = decoder.decode<double>();
    auto maximum = decoder.decode<double>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MeterPart::create(
            WTFMove(*gaugeRegion),
            WTFMove(*value),
            WTFMove(*minimum),
            WTFMove(*maximum)
        )
    };
}

void ArgumentCoder<WebCore::ProgressBarPart>::encode(Encoder& encoder, const WebCore::ProgressBarPart& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.position())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.animationStartTime())>, Seconds>);

    encoder << instance.position();
    encoder << instance.animationStartTime();
}

void ArgumentCoder<WebCore::ProgressBarPart>::encode(StreamConnectionEncoder& encoder, const WebCore::ProgressBarPart& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.position())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.animationStartTime())>, Seconds>);

    encoder << instance.position();
    encoder << instance.animationStartTime();
}

std::optional<Ref<WebCore::ProgressBarPart>> ArgumentCoder<WebCore::ProgressBarPart>::decode(Decoder& decoder)
{
    auto position = decoder.decode<double>();
    auto animationStartTime = decoder.decode<Seconds>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ProgressBarPart::create(
            WTFMove(*position),
            WTFMove(*animationStartTime)
        )
    };
}

void ArgumentCoder<WebCore::SliderTrackPart>::encode(Encoder& encoder, const WebCore::SliderTrackPart& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebCore::StyleAppearance>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.thumbSize())>, WebCore::IntSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.trackBounds())>, WebCore::IntRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tickRatios())>, Vector<double>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.thumbPosition())>, double>);

    encoder << instance.type();
    encoder << instance.thumbSize();
    encoder << instance.trackBounds();
    encoder << instance.tickRatios();
    encoder << instance.thumbPosition();
}

void ArgumentCoder<WebCore::SliderTrackPart>::encode(StreamConnectionEncoder& encoder, const WebCore::SliderTrackPart& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebCore::StyleAppearance>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.thumbSize())>, WebCore::IntSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.trackBounds())>, WebCore::IntRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tickRatios())>, Vector<double>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.thumbPosition())>, double>);

    encoder << instance.type();
    encoder << instance.thumbSize();
    encoder << instance.trackBounds();
    encoder << instance.tickRatios();
    encoder << instance.thumbPosition();
}

std::optional<Ref<WebCore::SliderTrackPart>> ArgumentCoder<WebCore::SliderTrackPart>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::StyleAppearance>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(type == WebCore::StyleAppearance::SliderHorizontal || type == WebCore::StyleAppearance::SliderVertical))
        return std::nullopt;
    auto thumbSize = decoder.decode<WebCore::IntSize>();
    auto trackBounds = decoder.decode<WebCore::IntRect>();
    auto tickRatios = decoder.decode<Vector<double>>();
    auto thumbPosition = decoder.decode<double>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SliderTrackPart::create(
            WTFMove(*type),
            WTFMove(*thumbSize),
            WTFMove(*trackBounds),
            WTFMove(*tickRatios),
            WTFMove(*thumbPosition)
        )
    };
}

void ArgumentCoder<WebCore::SwitchThumbPart>::encode(Encoder& encoder, const WebCore::SwitchThumbPart& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isOn())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.progress())>, float>);

    encoder << instance.isOn();
    encoder << instance.progress();
}

void ArgumentCoder<WebCore::SwitchThumbPart>::encode(StreamConnectionEncoder& encoder, const WebCore::SwitchThumbPart& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isOn())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.progress())>, float>);

    encoder << instance.isOn();
    encoder << instance.progress();
}

std::optional<Ref<WebCore::SwitchThumbPart>> ArgumentCoder<WebCore::SwitchThumbPart>::decode(Decoder& decoder)
{
    auto isOn = decoder.decode<bool>();
    auto progress = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(progress >= 0.0f && progress <= 1.0f))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SwitchThumbPart::create(
            WTFMove(*isOn),
            WTFMove(*progress)
        )
    };
}

void ArgumentCoder<WebCore::SwitchTrackPart>::encode(Encoder& encoder, const WebCore::SwitchTrackPart& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isOn())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.progress())>, float>);

    encoder << instance.isOn();
    encoder << instance.progress();
}

void ArgumentCoder<WebCore::SwitchTrackPart>::encode(StreamConnectionEncoder& encoder, const WebCore::SwitchTrackPart& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isOn())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.progress())>, float>);

    encoder << instance.isOn();
    encoder << instance.progress();
}

std::optional<Ref<WebCore::SwitchTrackPart>> ArgumentCoder<WebCore::SwitchTrackPart>::decode(Decoder& decoder)
{
    auto isOn = decoder.decode<bool>();
    auto progress = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(progress >= 0.0f && progress <= 1.0f))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SwitchTrackPart::create(
            WTFMove(*isOn),
            WTFMove(*progress)
        )
    };
}

void ArgumentCoder<WebCore::DistantLightSource>::encode(Encoder& encoder, const WebCore::DistantLightSource& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.azimuth())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.elevation())>, float>);

    encoder << instance.azimuth();
    encoder << instance.elevation();
}

void ArgumentCoder<WebCore::DistantLightSource>::encode(StreamConnectionEncoder& encoder, const WebCore::DistantLightSource& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.azimuth())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.elevation())>, float>);

    encoder << instance.azimuth();
    encoder << instance.elevation();
}

std::optional<Ref<WebCore::DistantLightSource>> ArgumentCoder<WebCore::DistantLightSource>::decode(Decoder& decoder)
{
    auto azimuth = decoder.decode<float>();
    auto elevation = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DistantLightSource::create(
            WTFMove(*azimuth),
            WTFMove(*elevation)
        )
    };
}

void ArgumentCoder<WebCore::PointLightSource>::encode(Encoder& encoder, const WebCore::PointLightSource& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.position())>, WebCore::FloatPoint3D>);

    encoder << instance.position();
}

void ArgumentCoder<WebCore::PointLightSource>::encode(StreamConnectionEncoder& encoder, const WebCore::PointLightSource& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.position())>, WebCore::FloatPoint3D>);

    encoder << instance.position();
}

std::optional<Ref<WebCore::PointLightSource>> ArgumentCoder<WebCore::PointLightSource>::decode(Decoder& decoder)
{
    auto position = decoder.decode<WebCore::FloatPoint3D>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PointLightSource::create(
            WTFMove(*position)
        )
    };
}

void ArgumentCoder<WebCore::SpotLightSource>::encode(Encoder& encoder, const WebCore::SpotLightSource& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.position())>, WebCore::FloatPoint3D>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.direction())>, WebCore::FloatPoint3D>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.specularExponent())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.limitingConeAngle())>, float>);

    encoder << instance.position();
    encoder << instance.direction();
    encoder << instance.specularExponent();
    encoder << instance.limitingConeAngle();
}

void ArgumentCoder<WebCore::SpotLightSource>::encode(StreamConnectionEncoder& encoder, const WebCore::SpotLightSource& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.position())>, WebCore::FloatPoint3D>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.direction())>, WebCore::FloatPoint3D>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.specularExponent())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.limitingConeAngle())>, float>);

    encoder << instance.position();
    encoder << instance.direction();
    encoder << instance.specularExponent();
    encoder << instance.limitingConeAngle();
}

std::optional<Ref<WebCore::SpotLightSource>> ArgumentCoder<WebCore::SpotLightSource>::decode(Decoder& decoder)
{
    auto position = decoder.decode<WebCore::FloatPoint3D>();
    auto direction = decoder.decode<WebCore::FloatPoint3D>();
    auto specularExponent = decoder.decode<float>();
    auto limitingConeAngle = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SpotLightSource::create(
            WTFMove(*position),
            WTFMove(*direction),
            WTFMove(*specularExponent),
            WTFMove(*limitingConeAngle)
        )
    };
}

void ArgumentCoder<WebCore::FEBlend>::encode(Encoder& encoder, const WebCore::FEBlend& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.blendMode())>, WebCore::BlendMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.blendMode();
    encoder << instance.operatingColorSpace();
}

void ArgumentCoder<WebCore::FEBlend>::encode(StreamConnectionEncoder& encoder, const WebCore::FEBlend& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.blendMode())>, WebCore::BlendMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.blendMode();
    encoder << instance.operatingColorSpace();
}

std::optional<Ref<WebCore::FEBlend>> ArgumentCoder<WebCore::FEBlend>::decode(Decoder& decoder)
{
    auto blendMode = decoder.decode<WebCore::BlendMode>();
    auto operatingColorSpace = decoder.decode<WebCore::DestinationColorSpace>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FEBlend::create(
            WTFMove(*blendMode),
            WTFMove(*operatingColorSpace)
        )
    };
}

void ArgumentCoder<WebCore::FEColorMatrix>::encode(Encoder& encoder, const WebCore::FEColorMatrix& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebCore::ColorMatrixType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.values())>, Vector<float>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.type();
    encoder << instance.values();
    encoder << instance.operatingColorSpace();
}

void ArgumentCoder<WebCore::FEColorMatrix>::encode(StreamConnectionEncoder& encoder, const WebCore::FEColorMatrix& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebCore::ColorMatrixType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.values())>, Vector<float>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.type();
    encoder << instance.values();
    encoder << instance.operatingColorSpace();
}

std::optional<Ref<WebCore::FEColorMatrix>> ArgumentCoder<WebCore::FEColorMatrix>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::ColorMatrixType>();
    auto values = decoder.decode<Vector<float>>();
    auto operatingColorSpace = decoder.decode<WebCore::DestinationColorSpace>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FEColorMatrix::create(
            WTFMove(*type),
            WTFMove(*values),
            WTFMove(*operatingColorSpace)
        )
    };
}

void ArgumentCoder<WebCore::ComponentTransferFunction>::encode(Encoder& encoder, const WebCore::ComponentTransferFunction& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::ComponentTransferType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.slope)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.intercept)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.amplitude)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.exponent)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tableValues)>, Vector<float>>);
    struct ShouldBeSameSizeAsComponentTransferFunction : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ComponentTransferFunction>, false> {
        WebCore::ComponentTransferType type;
        float slope;
        float intercept;
        float amplitude;
        float exponent;
        float offset;
        Vector<float> tableValues;
    };
    static_assert(sizeof(ShouldBeSameSizeAsComponentTransferFunction) == sizeof(WebCore::ComponentTransferFunction));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ComponentTransferFunction, type)
        , offsetof(WebCore::ComponentTransferFunction, slope)
        , offsetof(WebCore::ComponentTransferFunction, intercept)
        , offsetof(WebCore::ComponentTransferFunction, amplitude)
        , offsetof(WebCore::ComponentTransferFunction, exponent)
        , offsetof(WebCore::ComponentTransferFunction, offset)
        , offsetof(WebCore::ComponentTransferFunction, tableValues)
    >::value);

    encoder << instance.type;
    encoder << instance.slope;
    encoder << instance.intercept;
    encoder << instance.amplitude;
    encoder << instance.exponent;
    encoder << instance.offset;
    encoder << instance.tableValues;
}

void ArgumentCoder<WebCore::ComponentTransferFunction>::encode(StreamConnectionEncoder& encoder, const WebCore::ComponentTransferFunction& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::ComponentTransferType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.slope)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.intercept)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.amplitude)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.exponent)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tableValues)>, Vector<float>>);
    struct ShouldBeSameSizeAsComponentTransferFunction : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ComponentTransferFunction>, false> {
        WebCore::ComponentTransferType type;
        float slope;
        float intercept;
        float amplitude;
        float exponent;
        float offset;
        Vector<float> tableValues;
    };
    static_assert(sizeof(ShouldBeSameSizeAsComponentTransferFunction) == sizeof(WebCore::ComponentTransferFunction));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ComponentTransferFunction, type)
        , offsetof(WebCore::ComponentTransferFunction, slope)
        , offsetof(WebCore::ComponentTransferFunction, intercept)
        , offsetof(WebCore::ComponentTransferFunction, amplitude)
        , offsetof(WebCore::ComponentTransferFunction, exponent)
        , offsetof(WebCore::ComponentTransferFunction, offset)
        , offsetof(WebCore::ComponentTransferFunction, tableValues)
    >::value);

    encoder << instance.type;
    encoder << instance.slope;
    encoder << instance.intercept;
    encoder << instance.amplitude;
    encoder << instance.exponent;
    encoder << instance.offset;
    encoder << instance.tableValues;
}

std::optional<WebCore::ComponentTransferFunction> ArgumentCoder<WebCore::ComponentTransferFunction>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::ComponentTransferType>();
    auto slope = decoder.decode<float>();
    auto intercept = decoder.decode<float>();
    auto amplitude = decoder.decode<float>();
    auto exponent = decoder.decode<float>();
    auto offset = decoder.decode<float>();
    auto tableValues = decoder.decode<Vector<float>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ComponentTransferFunction {
            WTFMove(*type),
            WTFMove(*slope),
            WTFMove(*intercept),
            WTFMove(*amplitude),
            WTFMove(*exponent),
            WTFMove(*offset),
            WTFMove(*tableValues)
        }
    };
}

void ArgumentCoder<WebCore::FEComponentTransfer>::encode(Encoder& encoder, const WebCore::FEComponentTransfer& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.redFunction())>, WebCore::ComponentTransferFunction>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.greenFunction())>, WebCore::ComponentTransferFunction>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.blueFunction())>, WebCore::ComponentTransferFunction>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.alphaFunction())>, WebCore::ComponentTransferFunction>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.redFunction();
    encoder << instance.greenFunction();
    encoder << instance.blueFunction();
    encoder << instance.alphaFunction();
    encoder << instance.operatingColorSpace();
}

void ArgumentCoder<WebCore::FEComponentTransfer>::encode(StreamConnectionEncoder& encoder, const WebCore::FEComponentTransfer& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.redFunction())>, WebCore::ComponentTransferFunction>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.greenFunction())>, WebCore::ComponentTransferFunction>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.blueFunction())>, WebCore::ComponentTransferFunction>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.alphaFunction())>, WebCore::ComponentTransferFunction>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.redFunction();
    encoder << instance.greenFunction();
    encoder << instance.blueFunction();
    encoder << instance.alphaFunction();
    encoder << instance.operatingColorSpace();
}

std::optional<Ref<WebCore::FEComponentTransfer>> ArgumentCoder<WebCore::FEComponentTransfer>::decode(Decoder& decoder)
{
    auto redFunction = decoder.decode<WebCore::ComponentTransferFunction>();
    auto greenFunction = decoder.decode<WebCore::ComponentTransferFunction>();
    auto blueFunction = decoder.decode<WebCore::ComponentTransferFunction>();
    auto alphaFunction = decoder.decode<WebCore::ComponentTransferFunction>();
    auto operatingColorSpace = decoder.decode<WebCore::DestinationColorSpace>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FEComponentTransfer::create(
            WTFMove(*redFunction),
            WTFMove(*greenFunction),
            WTFMove(*blueFunction),
            WTFMove(*alphaFunction),
            WTFMove(*operatingColorSpace)
        )
    };
}

void ArgumentCoder<WebCore::FEComposite>::encode(Encoder& encoder, const WebCore::FEComposite& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operation())>, WebCore::CompositeOperationType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.k1())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.k2())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.k3())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.k4())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.operation();
    encoder << instance.k1();
    encoder << instance.k2();
    encoder << instance.k3();
    encoder << instance.k4();
    encoder << instance.operatingColorSpace();
}

void ArgumentCoder<WebCore::FEComposite>::encode(StreamConnectionEncoder& encoder, const WebCore::FEComposite& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operation())>, WebCore::CompositeOperationType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.k1())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.k2())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.k3())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.k4())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.operation();
    encoder << instance.k1();
    encoder << instance.k2();
    encoder << instance.k3();
    encoder << instance.k4();
    encoder << instance.operatingColorSpace();
}

std::optional<Ref<WebCore::FEComposite>> ArgumentCoder<WebCore::FEComposite>::decode(Decoder& decoder)
{
    auto operation = decoder.decode<WebCore::CompositeOperationType>();
    auto k1 = decoder.decode<float>();
    auto k2 = decoder.decode<float>();
    auto k3 = decoder.decode<float>();
    auto k4 = decoder.decode<float>();
    auto operatingColorSpace = decoder.decode<WebCore::DestinationColorSpace>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FEComposite::create(
            WTFMove(*operation),
            WTFMove(*k1),
            WTFMove(*k2),
            WTFMove(*k3),
            WTFMove(*k4),
            WTFMove(*operatingColorSpace)
        )
    };
}

void ArgumentCoder<WebCore::FEConvolveMatrix>::encode(Encoder& encoder, const WebCore::FEConvolveMatrix& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.kernelSize())>, WebCore::IntSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.divisor())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bias())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.targetOffset())>, WebCore::IntPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.edgeMode())>, WebCore::EdgeModeType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.kernelUnitLength())>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.preserveAlpha())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.kernel())>, Vector<float>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.kernelSize();
    encoder << instance.divisor();
    encoder << instance.bias();
    encoder << instance.targetOffset();
    encoder << instance.edgeMode();
    encoder << instance.kernelUnitLength();
    encoder << instance.preserveAlpha();
    encoder << instance.kernel();
    encoder << instance.operatingColorSpace();
}

void ArgumentCoder<WebCore::FEConvolveMatrix>::encode(StreamConnectionEncoder& encoder, const WebCore::FEConvolveMatrix& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.kernelSize())>, WebCore::IntSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.divisor())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bias())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.targetOffset())>, WebCore::IntPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.edgeMode())>, WebCore::EdgeModeType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.kernelUnitLength())>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.preserveAlpha())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.kernel())>, Vector<float>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.kernelSize();
    encoder << instance.divisor();
    encoder << instance.bias();
    encoder << instance.targetOffset();
    encoder << instance.edgeMode();
    encoder << instance.kernelUnitLength();
    encoder << instance.preserveAlpha();
    encoder << instance.kernel();
    encoder << instance.operatingColorSpace();
}

std::optional<Ref<WebCore::FEConvolveMatrix>> ArgumentCoder<WebCore::FEConvolveMatrix>::decode(Decoder& decoder)
{
    auto kernelSize = decoder.decode<WebCore::IntSize>();
    auto divisor = decoder.decode<float>();
    auto bias = decoder.decode<float>();
    auto targetOffset = decoder.decode<WebCore::IntPoint>();
    auto edgeMode = decoder.decode<WebCore::EdgeModeType>();
    auto kernelUnitLength = decoder.decode<WebCore::FloatPoint>();
    auto preserveAlpha = decoder.decode<bool>();
    auto kernel = decoder.decode<Vector<float>>();
    auto operatingColorSpace = decoder.decode<WebCore::DestinationColorSpace>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FEConvolveMatrix::create(
            WTFMove(*kernelSize),
            WTFMove(*divisor),
            WTFMove(*bias),
            WTFMove(*targetOffset),
            WTFMove(*edgeMode),
            WTFMove(*kernelUnitLength),
            WTFMove(*preserveAlpha),
            WTFMove(*kernel),
            WTFMove(*operatingColorSpace)
        )
    };
}

void ArgumentCoder<WebCore::FEDiffuseLighting>::encode(Encoder& encoder, const WebCore::FEDiffuseLighting& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lightingColor())>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.surfaceScale())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.diffuseConstant())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.kernelUnitLengthX())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.kernelUnitLengthY())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lightSource())>, WebCore::LightSource>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.lightingColor();
    encoder << instance.surfaceScale();
    encoder << instance.diffuseConstant();
    encoder << instance.kernelUnitLengthX();
    encoder << instance.kernelUnitLengthY();
    encoder << instance.lightSource();
    encoder << instance.operatingColorSpace();
}

void ArgumentCoder<WebCore::FEDiffuseLighting>::encode(StreamConnectionEncoder& encoder, const WebCore::FEDiffuseLighting& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lightingColor())>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.surfaceScale())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.diffuseConstant())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.kernelUnitLengthX())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.kernelUnitLengthY())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lightSource())>, WebCore::LightSource>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.lightingColor();
    encoder << instance.surfaceScale();
    encoder << instance.diffuseConstant();
    encoder << instance.kernelUnitLengthX();
    encoder << instance.kernelUnitLengthY();
    encoder << instance.lightSource();
    encoder << instance.operatingColorSpace();
}

std::optional<Ref<WebCore::FEDiffuseLighting>> ArgumentCoder<WebCore::FEDiffuseLighting>::decode(Decoder& decoder)
{
    auto lightingColor = decoder.decode<WebCore::Color>();
    auto surfaceScale = decoder.decode<float>();
    auto diffuseConstant = decoder.decode<float>();
    auto kernelUnitLengthX = decoder.decode<float>();
    auto kernelUnitLengthY = decoder.decode<float>();
    auto lightSource = decoder.decode<Ref<WebCore::LightSource>>();
    auto operatingColorSpace = decoder.decode<WebCore::DestinationColorSpace>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FEDiffuseLighting::create(
            WTFMove(*lightingColor),
            WTFMove(*surfaceScale),
            WTFMove(*diffuseConstant),
            WTFMove(*kernelUnitLengthX),
            WTFMove(*kernelUnitLengthY),
            WTFMove(*lightSource),
            WTFMove(*operatingColorSpace)
        )
    };
}

void ArgumentCoder<WebCore::FEDisplacementMap>::encode(Encoder& encoder, const WebCore::FEDisplacementMap& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.xChannelSelector())>, WebCore::ChannelSelectorType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.yChannelSelector())>, WebCore::ChannelSelectorType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scale())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.xChannelSelector();
    encoder << instance.yChannelSelector();
    encoder << instance.scale();
    encoder << instance.operatingColorSpace();
}

void ArgumentCoder<WebCore::FEDisplacementMap>::encode(StreamConnectionEncoder& encoder, const WebCore::FEDisplacementMap& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.xChannelSelector())>, WebCore::ChannelSelectorType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.yChannelSelector())>, WebCore::ChannelSelectorType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scale())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.xChannelSelector();
    encoder << instance.yChannelSelector();
    encoder << instance.scale();
    encoder << instance.operatingColorSpace();
}

std::optional<Ref<WebCore::FEDisplacementMap>> ArgumentCoder<WebCore::FEDisplacementMap>::decode(Decoder& decoder)
{
    auto xChannelSelector = decoder.decode<WebCore::ChannelSelectorType>();
    auto yChannelSelector = decoder.decode<WebCore::ChannelSelectorType>();
    auto scale = decoder.decode<float>();
    auto operatingColorSpace = decoder.decode<WebCore::DestinationColorSpace>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FEDisplacementMap::create(
            WTFMove(*xChannelSelector),
            WTFMove(*yChannelSelector),
            WTFMove(*scale),
            WTFMove(*operatingColorSpace)
        )
    };
}

void ArgumentCoder<WebCore::FEDropShadow>::encode(Encoder& encoder, const WebCore::FEDropShadow& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stdDeviationX())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stdDeviationY())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dx())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dy())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shadowColor())>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shadowOpacity())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.stdDeviationX();
    encoder << instance.stdDeviationY();
    encoder << instance.dx();
    encoder << instance.dy();
    encoder << instance.shadowColor();
    encoder << instance.shadowOpacity();
    encoder << instance.operatingColorSpace();
}

void ArgumentCoder<WebCore::FEDropShadow>::encode(StreamConnectionEncoder& encoder, const WebCore::FEDropShadow& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stdDeviationX())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stdDeviationY())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dx())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dy())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shadowColor())>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shadowOpacity())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.stdDeviationX();
    encoder << instance.stdDeviationY();
    encoder << instance.dx();
    encoder << instance.dy();
    encoder << instance.shadowColor();
    encoder << instance.shadowOpacity();
    encoder << instance.operatingColorSpace();
}

std::optional<Ref<WebCore::FEDropShadow>> ArgumentCoder<WebCore::FEDropShadow>::decode(Decoder& decoder)
{
    auto stdDeviationX = decoder.decode<float>();
    auto stdDeviationY = decoder.decode<float>();
    auto dx = decoder.decode<float>();
    auto dy = decoder.decode<float>();
    auto shadowColor = decoder.decode<WebCore::Color>();
    auto shadowOpacity = decoder.decode<float>();
    auto operatingColorSpace = decoder.decode<WebCore::DestinationColorSpace>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FEDropShadow::create(
            WTFMove(*stdDeviationX),
            WTFMove(*stdDeviationY),
            WTFMove(*dx),
            WTFMove(*dy),
            WTFMove(*shadowColor),
            WTFMove(*shadowOpacity),
            WTFMove(*operatingColorSpace)
        )
    };
}

void ArgumentCoder<WebCore::FEFlood>::encode(Encoder& encoder, const WebCore::FEFlood& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.floodColor())>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.floodOpacity())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.floodColor();
    encoder << instance.floodOpacity();
    encoder << instance.operatingColorSpace();
}

void ArgumentCoder<WebCore::FEFlood>::encode(StreamConnectionEncoder& encoder, const WebCore::FEFlood& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.floodColor())>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.floodOpacity())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.floodColor();
    encoder << instance.floodOpacity();
    encoder << instance.operatingColorSpace();
}

std::optional<Ref<WebCore::FEFlood>> ArgumentCoder<WebCore::FEFlood>::decode(Decoder& decoder)
{
    auto floodColor = decoder.decode<WebCore::Color>();
    auto floodOpacity = decoder.decode<float>();
    auto operatingColorSpace = decoder.decode<WebCore::DestinationColorSpace>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FEFlood::create(
            WTFMove(*floodColor),
            WTFMove(*floodOpacity),
            WTFMove(*operatingColorSpace)
        )
    };
}

void ArgumentCoder<WebCore::FEGaussianBlur>::encode(Encoder& encoder, const WebCore::FEGaussianBlur& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stdDeviationX())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stdDeviationY())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.edgeMode())>, WebCore::EdgeModeType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.stdDeviationX();
    encoder << instance.stdDeviationY();
    encoder << instance.edgeMode();
    encoder << instance.operatingColorSpace();
}

void ArgumentCoder<WebCore::FEGaussianBlur>::encode(StreamConnectionEncoder& encoder, const WebCore::FEGaussianBlur& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stdDeviationX())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stdDeviationY())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.edgeMode())>, WebCore::EdgeModeType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.stdDeviationX();
    encoder << instance.stdDeviationY();
    encoder << instance.edgeMode();
    encoder << instance.operatingColorSpace();
}

std::optional<Ref<WebCore::FEGaussianBlur>> ArgumentCoder<WebCore::FEGaussianBlur>::decode(Decoder& decoder)
{
    auto stdDeviationX = decoder.decode<float>();
    auto stdDeviationY = decoder.decode<float>();
    auto edgeMode = decoder.decode<WebCore::EdgeModeType>();
    auto operatingColorSpace = decoder.decode<WebCore::DestinationColorSpace>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FEGaussianBlur::create(
            WTFMove(*stdDeviationX),
            WTFMove(*stdDeviationY),
            WTFMove(*edgeMode),
            WTFMove(*operatingColorSpace)
        )
    };
}

void ArgumentCoder<WebCore::FEImage>::encode(Encoder& encoder, const WebCore::FEImage& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceImage())>, WebCore::SourceImage>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceImageRect())>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.preserveAspectRatio())>, WebCore::SVGPreserveAspectRatioValue>);

    encoder << instance.sourceImage();
    encoder << instance.sourceImageRect();
    encoder << instance.preserveAspectRatio();
}

void ArgumentCoder<WebCore::FEImage>::encode(StreamConnectionEncoder& encoder, const WebCore::FEImage& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceImage())>, WebCore::SourceImage>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceImageRect())>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.preserveAspectRatio())>, WebCore::SVGPreserveAspectRatioValue>);

    encoder << instance.sourceImage();
    encoder << instance.sourceImageRect();
    encoder << instance.preserveAspectRatio();
}

std::optional<Ref<WebCore::FEImage>> ArgumentCoder<WebCore::FEImage>::decode(Decoder& decoder)
{
    auto sourceImage = decoder.decode<WebCore::SourceImage>();
    auto sourceImageRect = decoder.decode<WebCore::FloatRect>();
    auto preserveAspectRatio = decoder.decode<WebCore::SVGPreserveAspectRatioValue>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FEImage::create(
            WTFMove(*sourceImage),
            WTFMove(*sourceImageRect),
            WTFMove(*preserveAspectRatio)
        )
    };
}

void ArgumentCoder<WebCore::FEMerge>::encode(Encoder& encoder, const WebCore::FEMerge& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.numberOfEffectInputs())>, unsigned>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.numberOfEffectInputs();
    encoder << instance.operatingColorSpace();
}

void ArgumentCoder<WebCore::FEMerge>::encode(StreamConnectionEncoder& encoder, const WebCore::FEMerge& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.numberOfEffectInputs())>, unsigned>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.numberOfEffectInputs();
    encoder << instance.operatingColorSpace();
}

std::optional<Ref<WebCore::FEMerge>> ArgumentCoder<WebCore::FEMerge>::decode(Decoder& decoder)
{
    auto numberOfEffectInputs = decoder.decode<unsigned>();
    auto operatingColorSpace = decoder.decode<WebCore::DestinationColorSpace>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FEMerge::create(
            WTFMove(*numberOfEffectInputs),
            WTFMove(*operatingColorSpace)
        )
    };
}

void ArgumentCoder<WebCore::FEMorphology>::encode(Encoder& encoder, const WebCore::FEMorphology& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.morphologyOperator())>, WebCore::MorphologyOperatorType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radiusX())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radiusY())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.morphologyOperator();
    encoder << instance.radiusX();
    encoder << instance.radiusY();
    encoder << instance.operatingColorSpace();
}

void ArgumentCoder<WebCore::FEMorphology>::encode(StreamConnectionEncoder& encoder, const WebCore::FEMorphology& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.morphologyOperator())>, WebCore::MorphologyOperatorType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radiusX())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radiusY())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.morphologyOperator();
    encoder << instance.radiusX();
    encoder << instance.radiusY();
    encoder << instance.operatingColorSpace();
}

std::optional<Ref<WebCore::FEMorphology>> ArgumentCoder<WebCore::FEMorphology>::decode(Decoder& decoder)
{
    auto morphologyOperator = decoder.decode<WebCore::MorphologyOperatorType>();
    auto radiusX = decoder.decode<float>();
    auto radiusY = decoder.decode<float>();
    auto operatingColorSpace = decoder.decode<WebCore::DestinationColorSpace>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FEMorphology::create(
            WTFMove(*morphologyOperator),
            WTFMove(*radiusX),
            WTFMove(*radiusY),
            WTFMove(*operatingColorSpace)
        )
    };
}

void ArgumentCoder<WebCore::FEOffset>::encode(Encoder& encoder, const WebCore::FEOffset& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dx())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dy())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.dx();
    encoder << instance.dy();
    encoder << instance.operatingColorSpace();
}

void ArgumentCoder<WebCore::FEOffset>::encode(StreamConnectionEncoder& encoder, const WebCore::FEOffset& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dx())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dy())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.dx();
    encoder << instance.dy();
    encoder << instance.operatingColorSpace();
}

std::optional<Ref<WebCore::FEOffset>> ArgumentCoder<WebCore::FEOffset>::decode(Decoder& decoder)
{
    auto dx = decoder.decode<float>();
    auto dy = decoder.decode<float>();
    auto operatingColorSpace = decoder.decode<WebCore::DestinationColorSpace>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FEOffset::create(
            WTFMove(*dx),
            WTFMove(*dy),
            WTFMove(*operatingColorSpace)
        )
    };
}

void ArgumentCoder<WebCore::FETile>::encode(Encoder& encoder, const WebCore::FETile& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.operatingColorSpace();
}

void ArgumentCoder<WebCore::FETile>::encode(StreamConnectionEncoder& encoder, const WebCore::FETile& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.operatingColorSpace();
}

std::optional<Ref<WebCore::FETile>> ArgumentCoder<WebCore::FETile>::decode(Decoder& decoder)
{
    auto operatingColorSpace = decoder.decode<WebCore::DestinationColorSpace>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FETile::create(
            WTFMove(*operatingColorSpace)
        )
    };
}

void ArgumentCoder<WebCore::FESpecularLighting>::encode(Encoder& encoder, const WebCore::FESpecularLighting& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lightingColor())>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.surfaceScale())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.specularConstant())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.specularExponent())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.kernelUnitLengthX())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.kernelUnitLengthY())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lightSource())>, WebCore::LightSource>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.lightingColor();
    encoder << instance.surfaceScale();
    encoder << instance.specularConstant();
    encoder << instance.specularExponent();
    encoder << instance.kernelUnitLengthX();
    encoder << instance.kernelUnitLengthY();
    encoder << instance.lightSource();
    encoder << instance.operatingColorSpace();
}

void ArgumentCoder<WebCore::FESpecularLighting>::encode(StreamConnectionEncoder& encoder, const WebCore::FESpecularLighting& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lightingColor())>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.surfaceScale())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.specularConstant())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.specularExponent())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.kernelUnitLengthX())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.kernelUnitLengthY())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lightSource())>, WebCore::LightSource>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.lightingColor();
    encoder << instance.surfaceScale();
    encoder << instance.specularConstant();
    encoder << instance.specularExponent();
    encoder << instance.kernelUnitLengthX();
    encoder << instance.kernelUnitLengthY();
    encoder << instance.lightSource();
    encoder << instance.operatingColorSpace();
}

std::optional<Ref<WebCore::FESpecularLighting>> ArgumentCoder<WebCore::FESpecularLighting>::decode(Decoder& decoder)
{
    auto lightingColor = decoder.decode<WebCore::Color>();
    auto surfaceScale = decoder.decode<float>();
    auto specularConstant = decoder.decode<float>();
    auto specularExponent = decoder.decode<float>();
    auto kernelUnitLengthX = decoder.decode<float>();
    auto kernelUnitLengthY = decoder.decode<float>();
    auto lightSource = decoder.decode<Ref<WebCore::LightSource>>();
    auto operatingColorSpace = decoder.decode<WebCore::DestinationColorSpace>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FESpecularLighting::create(
            WTFMove(*lightingColor),
            WTFMove(*surfaceScale),
            WTFMove(*specularConstant),
            WTFMove(*specularExponent),
            WTFMove(*kernelUnitLengthX),
            WTFMove(*kernelUnitLengthY),
            WTFMove(*lightSource),
            WTFMove(*operatingColorSpace)
        )
    };
}

void ArgumentCoder<WebCore::FETurbulence>::encode(Encoder& encoder, const WebCore::FETurbulence& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebCore::TurbulenceType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.baseFrequencyX())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.baseFrequencyY())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.numOctaves())>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.seed())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stitchTiles())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.type();
    encoder << instance.baseFrequencyX();
    encoder << instance.baseFrequencyY();
    encoder << instance.numOctaves();
    encoder << instance.seed();
    encoder << instance.stitchTiles();
    encoder << instance.operatingColorSpace();
}

void ArgumentCoder<WebCore::FETurbulence>::encode(StreamConnectionEncoder& encoder, const WebCore::FETurbulence& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebCore::TurbulenceType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.baseFrequencyX())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.baseFrequencyY())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.numOctaves())>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.seed())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stitchTiles())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.type();
    encoder << instance.baseFrequencyX();
    encoder << instance.baseFrequencyY();
    encoder << instance.numOctaves();
    encoder << instance.seed();
    encoder << instance.stitchTiles();
    encoder << instance.operatingColorSpace();
}

std::optional<Ref<WebCore::FETurbulence>> ArgumentCoder<WebCore::FETurbulence>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::TurbulenceType>();
    auto baseFrequencyX = decoder.decode<float>();
    auto baseFrequencyY = decoder.decode<float>();
    auto numOctaves = decoder.decode<int>();
    auto seed = decoder.decode<float>();
    auto stitchTiles = decoder.decode<bool>();
    auto operatingColorSpace = decoder.decode<WebCore::DestinationColorSpace>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FETurbulence::create(
            WTFMove(*type),
            WTFMove(*baseFrequencyX),
            WTFMove(*baseFrequencyY),
            WTFMove(*numOctaves),
            WTFMove(*seed),
            WTFMove(*stitchTiles),
            WTFMove(*operatingColorSpace)
        )
    };
}

void ArgumentCoder<WebCore::SourceAlpha>::encode(Encoder& encoder, const WebCore::SourceAlpha& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.operatingColorSpace();
}

void ArgumentCoder<WebCore::SourceAlpha>::encode(StreamConnectionEncoder& encoder, const WebCore::SourceAlpha& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.operatingColorSpace();
}

std::optional<Ref<WebCore::SourceAlpha>> ArgumentCoder<WebCore::SourceAlpha>::decode(Decoder& decoder)
{
    auto operatingColorSpace = decoder.decode<WebCore::DestinationColorSpace>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SourceAlpha::create(
            WTFMove(*operatingColorSpace)
        )
    };
}

void ArgumentCoder<WebCore::SourceGraphic>::encode(Encoder& encoder, const WebCore::SourceGraphic& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.operatingColorSpace();
}

void ArgumentCoder<WebCore::SourceGraphic>::encode(StreamConnectionEncoder& encoder, const WebCore::SourceGraphic& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operatingColorSpace())>, WebCore::DestinationColorSpace>);

    encoder << instance.operatingColorSpace();
}

std::optional<Ref<WebCore::SourceGraphic>> ArgumentCoder<WebCore::SourceGraphic>::decode(Decoder& decoder)
{
    auto operatingColorSpace = decoder.decode<WebCore::DestinationColorSpace>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SourceGraphic::create(
            WTFMove(*operatingColorSpace)
        )
    };
}

void ArgumentCoder<WebCore::FilterEffectGeometry>::encode(Encoder& encoder, const WebCore::FilterEffectGeometry& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_boundaries)>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_flags)>, OptionSet<WebCore::FilterEffectGeometry::Flags>>);
    struct ShouldBeSameSizeAsFilterEffectGeometry : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FilterEffectGeometry>, false> {
        WebCore::FloatRect m_boundaries;
        OptionSet<WebCore::FilterEffectGeometry::Flags> m_flags;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFilterEffectGeometry) == sizeof(WebCore::FilterEffectGeometry));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FilterEffectGeometry, m_boundaries)
        , offsetof(WebCore::FilterEffectGeometry, m_flags)
    >::value);

    encoder << instance.m_boundaries;
    encoder << instance.m_flags;
}

void ArgumentCoder<WebCore::FilterEffectGeometry>::encode(StreamConnectionEncoder& encoder, const WebCore::FilterEffectGeometry& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_boundaries)>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_flags)>, OptionSet<WebCore::FilterEffectGeometry::Flags>>);
    struct ShouldBeSameSizeAsFilterEffectGeometry : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FilterEffectGeometry>, false> {
        WebCore::FloatRect m_boundaries;
        OptionSet<WebCore::FilterEffectGeometry::Flags> m_flags;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFilterEffectGeometry) == sizeof(WebCore::FilterEffectGeometry));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FilterEffectGeometry, m_boundaries)
        , offsetof(WebCore::FilterEffectGeometry, m_flags)
    >::value);

    encoder << instance.m_boundaries;
    encoder << instance.m_flags;
}

std::optional<WebCore::FilterEffectGeometry> ArgumentCoder<WebCore::FilterEffectGeometry>::decode(Decoder& decoder)
{
    auto m_boundaries = decoder.decode<WebCore::FloatRect>();
    auto m_flags = decoder.decode<OptionSet<WebCore::FilterEffectGeometry::Flags>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FilterEffectGeometry {
            WTFMove(*m_boundaries),
            WTFMove(*m_flags)
        }
    };
}

void ArgumentCoder<WebCore::SVGFilterExpressionTerm>::encode(Encoder& encoder, const WebCore::SVGFilterExpressionTerm& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.index)>, unsigned>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.level)>, unsigned>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.geometry)>, std::optional<WebCore::FilterEffectGeometry>>);
    struct ShouldBeSameSizeAsSVGFilterExpressionTerm : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SVGFilterExpressionTerm>, false> {
        unsigned index;
        unsigned level;
        std::optional<WebCore::FilterEffectGeometry> geometry;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSVGFilterExpressionTerm) == sizeof(WebCore::SVGFilterExpressionTerm));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SVGFilterExpressionTerm, index)
        , offsetof(WebCore::SVGFilterExpressionTerm, level)
        , offsetof(WebCore::SVGFilterExpressionTerm, geometry)
    >::value);

    encoder << instance.index;
    encoder << instance.level;
    encoder << instance.geometry;
}

void ArgumentCoder<WebCore::SVGFilterExpressionTerm>::encode(StreamConnectionEncoder& encoder, const WebCore::SVGFilterExpressionTerm& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.index)>, unsigned>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.level)>, unsigned>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.geometry)>, std::optional<WebCore::FilterEffectGeometry>>);
    struct ShouldBeSameSizeAsSVGFilterExpressionTerm : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SVGFilterExpressionTerm>, false> {
        unsigned index;
        unsigned level;
        std::optional<WebCore::FilterEffectGeometry> geometry;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSVGFilterExpressionTerm) == sizeof(WebCore::SVGFilterExpressionTerm));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SVGFilterExpressionTerm, index)
        , offsetof(WebCore::SVGFilterExpressionTerm, level)
        , offsetof(WebCore::SVGFilterExpressionTerm, geometry)
    >::value);

    encoder << instance.index;
    encoder << instance.level;
    encoder << instance.geometry;
}

std::optional<WebCore::SVGFilterExpressionTerm> ArgumentCoder<WebCore::SVGFilterExpressionTerm>::decode(Decoder& decoder)
{
    auto index = decoder.decode<unsigned>();
    auto level = decoder.decode<unsigned>();
    auto geometry = decoder.decode<std::optional<WebCore::FilterEffectGeometry>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SVGFilterExpressionTerm {
            WTFMove(*index),
            WTFMove(*level),
            WTFMove(*geometry)
        }
    };
}

void ArgumentCoder<WebCore::SVGPreserveAspectRatioValue>::encode(Encoder& encoder, const WebCore::SVGPreserveAspectRatioValue& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_align)>, WebCore::SVGPreserveAspectRatioValue::SVGPreserveAspectRatioType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_meetOrSlice)>, WebCore::SVGPreserveAspectRatioValue::SVGMeetOrSliceType>);
    struct ShouldBeSameSizeAsSVGPreserveAspectRatioValue : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SVGPreserveAspectRatioValue>, false> {
        WebCore::SVGPreserveAspectRatioValue::SVGPreserveAspectRatioType m_align;
        WebCore::SVGPreserveAspectRatioValue::SVGMeetOrSliceType m_meetOrSlice;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSVGPreserveAspectRatioValue) == sizeof(WebCore::SVGPreserveAspectRatioValue));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SVGPreserveAspectRatioValue, m_align)
        , offsetof(WebCore::SVGPreserveAspectRatioValue, m_meetOrSlice)
    >::value);

    encoder << instance.m_align;
    encoder << instance.m_meetOrSlice;
}

void ArgumentCoder<WebCore::SVGPreserveAspectRatioValue>::encode(StreamConnectionEncoder& encoder, const WebCore::SVGPreserveAspectRatioValue& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_align)>, WebCore::SVGPreserveAspectRatioValue::SVGPreserveAspectRatioType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_meetOrSlice)>, WebCore::SVGPreserveAspectRatioValue::SVGMeetOrSliceType>);
    struct ShouldBeSameSizeAsSVGPreserveAspectRatioValue : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SVGPreserveAspectRatioValue>, false> {
        WebCore::SVGPreserveAspectRatioValue::SVGPreserveAspectRatioType m_align;
        WebCore::SVGPreserveAspectRatioValue::SVGMeetOrSliceType m_meetOrSlice;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSVGPreserveAspectRatioValue) == sizeof(WebCore::SVGPreserveAspectRatioValue));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SVGPreserveAspectRatioValue, m_align)
        , offsetof(WebCore::SVGPreserveAspectRatioValue, m_meetOrSlice)
    >::value);

    encoder << instance.m_align;
    encoder << instance.m_meetOrSlice;
}

std::optional<WebCore::SVGPreserveAspectRatioValue> ArgumentCoder<WebCore::SVGPreserveAspectRatioValue>::decode(Decoder& decoder)
{
    auto m_align = decoder.decode<WebCore::SVGPreserveAspectRatioValue::SVGPreserveAspectRatioType>();
    auto m_meetOrSlice = decoder.decode<WebCore::SVGPreserveAspectRatioValue::SVGMeetOrSliceType>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SVGPreserveAspectRatioValue {
            WTFMove(*m_align),
            WTFMove(*m_meetOrSlice)
        }
    };
}

#if ENABLE(GAMEPAD)
void ArgumentCoder<WebCore::GamepadEffectParameters>::encode(Encoder& encoder, const WebCore::GamepadEffectParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.duration)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.startDelay)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.strongMagnitude)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.weakMagnitude)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.leftTrigger)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rightTrigger)>, double>);
    struct ShouldBeSameSizeAsGamepadEffectParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::GamepadEffectParameters>, false> {
        double duration;
        double startDelay;
        double strongMagnitude;
        double weakMagnitude;
        double leftTrigger;
        double rightTrigger;
    };
    static_assert(sizeof(ShouldBeSameSizeAsGamepadEffectParameters) == sizeof(WebCore::GamepadEffectParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::GamepadEffectParameters, duration)
        , offsetof(WebCore::GamepadEffectParameters, startDelay)
        , offsetof(WebCore::GamepadEffectParameters, strongMagnitude)
        , offsetof(WebCore::GamepadEffectParameters, weakMagnitude)
        , offsetof(WebCore::GamepadEffectParameters, leftTrigger)
        , offsetof(WebCore::GamepadEffectParameters, rightTrigger)
    >::value);

    encoder << instance.duration;
    encoder << instance.startDelay;
    encoder << instance.strongMagnitude;
    encoder << instance.weakMagnitude;
    encoder << instance.leftTrigger;
    encoder << instance.rightTrigger;
}

std::optional<WebCore::GamepadEffectParameters> ArgumentCoder<WebCore::GamepadEffectParameters>::decode(Decoder& decoder)
{
    auto duration = decoder.decode<double>();
    auto startDelay = decoder.decode<double>();
    auto strongMagnitude = decoder.decode<double>();
    auto weakMagnitude = decoder.decode<double>();
    auto leftTrigger = decoder.decode<double>();
    auto rightTrigger = decoder.decode<double>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::GamepadEffectParameters {
            WTFMove(*duration),
            WTFMove(*startDelay),
            WTFMove(*strongMagnitude),
            WTFMove(*weakMagnitude),
            WTFMove(*leftTrigger),
            WTFMove(*rightTrigger)
        }
    };
}

#endif

void ArgumentCoder<WebCore::StorageEstimate>::encode(Encoder& encoder, const WebCore::StorageEstimate& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.usage)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.quota)>, uint64_t>);
    struct ShouldBeSameSizeAsStorageEstimate : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::StorageEstimate>, false> {
        uint64_t usage;
        uint64_t quota;
    };
    static_assert(sizeof(ShouldBeSameSizeAsStorageEstimate) == sizeof(WebCore::StorageEstimate));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::StorageEstimate, usage)
        , offsetof(WebCore::StorageEstimate, quota)
    >::value);

    encoder << instance.usage;
    encoder << instance.quota;
}

std::optional<WebCore::StorageEstimate> ArgumentCoder<WebCore::StorageEstimate>::decode(Decoder& decoder)
{
    auto usage = decoder.decode<uint64_t>();
    auto quota = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::StorageEstimate {
            WTFMove(*usage),
            WTFMove(*quota)
        }
    };
}

void ArgumentCoder<PAL::SessionID>::encode(Encoder& encoder, const PAL::SessionID& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.toUInt64())>, uint64_t>);

    encoder << instance.toUInt64();
}

std::optional<PAL::SessionID> ArgumentCoder<PAL::SessionID>::decode(Decoder& decoder)
{
    auto toUInt64 = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(PAL::SessionID::isValidSessionIDValue(*toUInt64)))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        PAL::SessionID {
            WTFMove(*toUInt64)
        }
    };
}

void ArgumentCoder<WebKit::RunJavaScriptParameters>::encode(Encoder& encoder, const WebKit::RunJavaScriptParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.source)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.taintedness)>, JSC::SourceTaintedOrigin>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.runAsAsyncFunction)>, WebCore::RunAsAsyncFunction>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.arguments)>, std::optional<Vector<std::pair<String, WebKit::JavaScriptEvaluationResult>>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.forceUserGesture)>, WebCore::ForceUserGesture>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.removeTransientActivation)>, WebCore::RemoveTransientActivation>);
    struct ShouldBeSameSizeAsRunJavaScriptParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::RunJavaScriptParameters>, false> {
        String source;
        JSC::SourceTaintedOrigin taintedness;
        URL sourceURL;
        WebCore::RunAsAsyncFunction runAsAsyncFunction;
        std::optional<Vector<std::pair<String, WebKit::JavaScriptEvaluationResult>>> arguments;
        WebCore::ForceUserGesture forceUserGesture;
        WebCore::RemoveTransientActivation removeTransientActivation;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRunJavaScriptParameters) == sizeof(WebKit::RunJavaScriptParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::RunJavaScriptParameters, source)
        , offsetof(WebKit::RunJavaScriptParameters, taintedness)
        , offsetof(WebKit::RunJavaScriptParameters, sourceURL)
        , offsetof(WebKit::RunJavaScriptParameters, runAsAsyncFunction)
        , offsetof(WebKit::RunJavaScriptParameters, arguments)
        , offsetof(WebKit::RunJavaScriptParameters, forceUserGesture)
        , offsetof(WebKit::RunJavaScriptParameters, removeTransientActivation)
    >::value);

    encoder << instance.source;
    encoder << instance.taintedness;
    encoder << instance.sourceURL;
    encoder << instance.runAsAsyncFunction;
    encoder << instance.arguments;
    encoder << instance.forceUserGesture;
    encoder << instance.removeTransientActivation;
}

std::optional<WebKit::RunJavaScriptParameters> ArgumentCoder<WebKit::RunJavaScriptParameters>::decode(Decoder& decoder)
{
    auto source = decoder.decode<String>();
    auto taintedness = decoder.decode<JSC::SourceTaintedOrigin>();
    auto sourceURL = decoder.decode<URL>();
    auto runAsAsyncFunction = decoder.decode<WebCore::RunAsAsyncFunction>();
    auto arguments = decoder.decode<std::optional<Vector<std::pair<String, WebKit::JavaScriptEvaluationResult>>>>();
    auto forceUserGesture = decoder.decode<WebCore::ForceUserGesture>();
    auto removeTransientActivation = decoder.decode<WebCore::RemoveTransientActivation>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::RunJavaScriptParameters {
            WTFMove(*source),
            WTFMove(*taintedness),
            WTFMove(*sourceURL),
            WTFMove(*runAsAsyncFunction),
            WTFMove(*arguments),
            WTFMove(*forceUserGesture),
            WTFMove(*removeTransientActivation)
        }
    };
}

void ArgumentCoder<WebCore::TextList>::encode(Encoder& encoder, const WebCore::TextList& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.styleType)>, WebCore::Style::ListStyleType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.startingItemNumber)>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ordered)>, bool>);
    struct ShouldBeSameSizeAsTextList : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::TextList>, false> {
        WebCore::Style::ListStyleType styleType;
        int startingItemNumber;
        bool ordered;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTextList) == sizeof(WebCore::TextList));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::TextList, styleType)
        , offsetof(WebCore::TextList, startingItemNumber)
        , offsetof(WebCore::TextList, ordered)
    >::value);

    encoder << instance.styleType;
    encoder << instance.startingItemNumber;
    encoder << instance.ordered;
}

std::optional<WebCore::TextList> ArgumentCoder<WebCore::TextList>::decode(Decoder& decoder)
{
    auto styleType = decoder.decode<WebCore::Style::ListStyleType>();
    auto startingItemNumber = decoder.decode<int>();
    auto ordered = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TextList {
            WTFMove(*styleType),
            WTFMove(*startingItemNumber),
            WTFMove(*ordered)
        }
    };
}

void ArgumentCoder<WebCore::FontAttributes>::encode(Encoder& encoder, const WebCore::FontAttributes& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.font)>, RefPtr<WebCore::Font>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.backgroundColor)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.foregroundColor)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fontShadow)>, WebCore::FontShadow>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.subscriptOrSuperscript)>, WebCore::FontAttributes::SubscriptOrSuperscript>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.horizontalAlignment)>, WebCore::FontAttributes::HorizontalAlignment>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.textLists)>, Vector<WebCore::TextList>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasUnderline)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasStrikeThrough)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasMultipleFonts)>, bool>);
    struct ShouldBeSameSizeAsFontAttributes : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FontAttributes>, false> {
        RefPtr<WebCore::Font> font;
        WebCore::Color backgroundColor;
        WebCore::Color foregroundColor;
        WebCore::FontShadow fontShadow;
        WebCore::FontAttributes::SubscriptOrSuperscript subscriptOrSuperscript;
        WebCore::FontAttributes::HorizontalAlignment horizontalAlignment;
        Vector<WebCore::TextList> textLists;
        bool hasUnderline;
        bool hasStrikeThrough;
        bool hasMultipleFonts;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFontAttributes) == sizeof(WebCore::FontAttributes));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FontAttributes, font)
        , offsetof(WebCore::FontAttributes, backgroundColor)
        , offsetof(WebCore::FontAttributes, foregroundColor)
        , offsetof(WebCore::FontAttributes, fontShadow)
        , offsetof(WebCore::FontAttributes, subscriptOrSuperscript)
        , offsetof(WebCore::FontAttributes, horizontalAlignment)
        , offsetof(WebCore::FontAttributes, textLists)
        , offsetof(WebCore::FontAttributes, hasUnderline)
        , offsetof(WebCore::FontAttributes, hasStrikeThrough)
        , offsetof(WebCore::FontAttributes, hasMultipleFonts)
    >::value);

    encoder << instance.font;
    encoder << instance.backgroundColor;
    encoder << instance.foregroundColor;
    encoder << instance.fontShadow;
    encoder << instance.subscriptOrSuperscript;
    encoder << instance.horizontalAlignment;
    encoder << instance.textLists;
    encoder << instance.hasUnderline;
    encoder << instance.hasStrikeThrough;
    encoder << instance.hasMultipleFonts;
}

std::optional<WebCore::FontAttributes> ArgumentCoder<WebCore::FontAttributes>::decode(Decoder& decoder)
{
    auto font = decoder.decode<RefPtr<WebCore::Font>>();
    auto backgroundColor = decoder.decode<WebCore::Color>();
    auto foregroundColor = decoder.decode<WebCore::Color>();
    auto fontShadow = decoder.decode<WebCore::FontShadow>();
    auto subscriptOrSuperscript = decoder.decode<WebCore::FontAttributes::SubscriptOrSuperscript>();
    auto horizontalAlignment = decoder.decode<WebCore::FontAttributes::HorizontalAlignment>();
    auto textLists = decoder.decode<Vector<WebCore::TextList>>();
    auto hasUnderline = decoder.decode<bool>();
    auto hasStrikeThrough = decoder.decode<bool>();
    auto hasMultipleFonts = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FontAttributes {
            WTFMove(*font),
            WTFMove(*backgroundColor),
            WTFMove(*foregroundColor),
            WTFMove(*fontShadow),
            WTFMove(*subscriptOrSuperscript),
            WTFMove(*horizontalAlignment),
            WTFMove(*textLists),
            WTFMove(*hasUnderline),
            WTFMove(*hasStrikeThrough),
            WTFMove(*hasMultipleFonts)
        }
    };
}

void ArgumentCoder<WebCore::CrossOriginEmbedderPolicy>::encode(Encoder& encoder, const WebCore::CrossOriginEmbedderPolicy& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, WebCore::CrossOriginEmbedderPolicyValue>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.reportOnlyValue)>, WebCore::CrossOriginEmbedderPolicyValue>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.reportingEndpoint)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.reportOnlyReportingEndpoint)>, String>);
    struct ShouldBeSameSizeAsCrossOriginEmbedderPolicy : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::CrossOriginEmbedderPolicy>, false> {
        WebCore::CrossOriginEmbedderPolicyValue value;
        WebCore::CrossOriginEmbedderPolicyValue reportOnlyValue;
        String reportingEndpoint;
        String reportOnlyReportingEndpoint;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCrossOriginEmbedderPolicy) == sizeof(WebCore::CrossOriginEmbedderPolicy));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::CrossOriginEmbedderPolicy, value)
        , offsetof(WebCore::CrossOriginEmbedderPolicy, reportOnlyValue)
        , offsetof(WebCore::CrossOriginEmbedderPolicy, reportingEndpoint)
        , offsetof(WebCore::CrossOriginEmbedderPolicy, reportOnlyReportingEndpoint)
    >::value);

    encoder << instance.value;
    encoder << instance.reportOnlyValue;
    encoder << instance.reportingEndpoint;
    encoder << instance.reportOnlyReportingEndpoint;
}

std::optional<WebCore::CrossOriginEmbedderPolicy> ArgumentCoder<WebCore::CrossOriginEmbedderPolicy>::decode(Decoder& decoder)
{
    auto value = decoder.decode<WebCore::CrossOriginEmbedderPolicyValue>();
    auto reportOnlyValue = decoder.decode<WebCore::CrossOriginEmbedderPolicyValue>();
    auto reportingEndpoint = decoder.decode<String>();
    auto reportOnlyReportingEndpoint = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CrossOriginEmbedderPolicy {
            WTFMove(*value),
            WTFMove(*reportOnlyValue),
            WTFMove(*reportingEndpoint),
            WTFMove(*reportOnlyReportingEndpoint)
        }
    };
}

void ArgumentCoder<WebCore::SameSiteInfo>::encode(Encoder& encoder, const WebCore::SameSiteInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isSameSite)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isTopSite)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isSafeHTTPMethod)>, bool>);
    struct ShouldBeSameSizeAsSameSiteInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SameSiteInfo>, false> {
        bool isSameSite;
        bool isTopSite;
        bool isSafeHTTPMethod;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSameSiteInfo) == sizeof(WebCore::SameSiteInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SameSiteInfo, isSameSite)
        , offsetof(WebCore::SameSiteInfo, isTopSite)
        , offsetof(WebCore::SameSiteInfo, isSafeHTTPMethod)
    >::value);

    encoder << instance.isSameSite;
    encoder << instance.isTopSite;
    encoder << instance.isSafeHTTPMethod;
}

std::optional<WebCore::SameSiteInfo> ArgumentCoder<WebCore::SameSiteInfo>::decode(Decoder& decoder)
{
    auto isSameSite = decoder.decode<bool>();
    auto isTopSite = decoder.decode<bool>();
    auto isSafeHTTPMethod = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SameSiteInfo {
            WTFMove(*isSameSite),
            WTFMove(*isTopSite),
            WTFMove(*isSafeHTTPMethod)
        }
    };
}

void ArgumentCoder<WebCore::SecurityOrigin>::encode(Encoder& encoder, const WebCore::SecurityOrigin& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_data)>, WebCore::SecurityOriginData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_domain)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_filePath)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_universalAccess)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_domainWasSetInDOM)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_canLoadLocalResources)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_enforcesFilePathSeparation)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_needsStorageAccessFromFileURLsQuirk)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_isPotentiallyTrustworthy)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_isLocal)>, bool>);
    struct ShouldBeSameSizeAsSecurityOrigin : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SecurityOrigin>, true> {
        WebCore::SecurityOriginData m_data;
        String m_domain;
        String m_filePath;
        bool m_universalAccess;
        bool m_domainWasSetInDOM;
        bool m_canLoadLocalResources;
        bool m_enforcesFilePathSeparation;
        bool m_needsStorageAccessFromFileURLsQuirk;
        std::optional<bool> m_isPotentiallyTrustworthy;
        bool m_isLocal;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSecurityOrigin) == sizeof(WebCore::SecurityOrigin));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SecurityOrigin, m_data)
        , offsetof(WebCore::SecurityOrigin, m_domain)
        , offsetof(WebCore::SecurityOrigin, m_filePath)
        , offsetof(WebCore::SecurityOrigin, m_universalAccess)
        , offsetof(WebCore::SecurityOrigin, m_domainWasSetInDOM)
        , offsetof(WebCore::SecurityOrigin, m_canLoadLocalResources)
        , offsetof(WebCore::SecurityOrigin, m_enforcesFilePathSeparation)
        , offsetof(WebCore::SecurityOrigin, m_needsStorageAccessFromFileURLsQuirk)
        , offsetof(WebCore::SecurityOrigin, m_isPotentiallyTrustworthy)
        , offsetof(WebCore::SecurityOrigin, m_isLocal)
    >::value);

    encoder << instance.m_data;
    encoder << instance.m_domain;
    encoder << instance.m_filePath;
    encoder << instance.m_universalAccess;
    encoder << instance.m_domainWasSetInDOM;
    encoder << instance.m_canLoadLocalResources;
    encoder << instance.m_enforcesFilePathSeparation;
    encoder << instance.m_needsStorageAccessFromFileURLsQuirk;
    encoder << instance.m_isPotentiallyTrustworthy;
    encoder << instance.m_isLocal;
}

std::optional<Ref<WebCore::SecurityOrigin>> ArgumentCoder<WebCore::SecurityOrigin>::decode(Decoder& decoder)
{
    auto m_data = decoder.decode<WebCore::SecurityOriginData>();
    auto m_domain = decoder.decode<String>();
    auto m_filePath = decoder.decode<String>();
    auto m_universalAccess = decoder.decode<bool>();
    auto m_domainWasSetInDOM = decoder.decode<bool>();
    auto m_canLoadLocalResources = decoder.decode<bool>();
    auto m_enforcesFilePathSeparation = decoder.decode<bool>();
    auto m_needsStorageAccessFromFileURLsQuirk = decoder.decode<bool>();
    auto m_isPotentiallyTrustworthy = decoder.decode<std::optional<bool>>();
    auto m_isLocal = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SecurityOrigin::create(
            WTFMove(*m_data),
            WTFMove(*m_domain),
            WTFMove(*m_filePath),
            WTFMove(*m_universalAccess),
            WTFMove(*m_domainWasSetInDOM),
            WTFMove(*m_canLoadLocalResources),
            WTFMove(*m_enforcesFilePathSeparation),
            WTFMove(*m_needsStorageAccessFromFileURLsQuirk),
            WTFMove(*m_isPotentiallyTrustworthy),
            WTFMove(*m_isLocal)
        )
    };
}

void ArgumentCoder<WebCore::CookieRequestHeaderFieldProxy>::encode(Encoder& encoder, const WebCore::CookieRequestHeaderFieldProxy& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.firstParty)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sameSiteInfo)>, WebCore::SameSiteInfo>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameID)>, std::optional<WebCore::FrameIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pageID)>, std::optional<WebCore::PageIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.includeSecureCookies)>, WebCore::IncludeSecureCookies>);
    struct ShouldBeSameSizeAsCookieRequestHeaderFieldProxy : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::CookieRequestHeaderFieldProxy>, false> {
        URL firstParty;
        WebCore::SameSiteInfo sameSiteInfo;
        URL url;
        std::optional<WebCore::FrameIdentifier> frameID;
        std::optional<WebCore::PageIdentifier> pageID;
        WebCore::IncludeSecureCookies includeSecureCookies;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCookieRequestHeaderFieldProxy) == sizeof(WebCore::CookieRequestHeaderFieldProxy));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::CookieRequestHeaderFieldProxy, firstParty)
        , offsetof(WebCore::CookieRequestHeaderFieldProxy, sameSiteInfo)
        , offsetof(WebCore::CookieRequestHeaderFieldProxy, url)
        , offsetof(WebCore::CookieRequestHeaderFieldProxy, frameID)
        , offsetof(WebCore::CookieRequestHeaderFieldProxy, pageID)
        , offsetof(WebCore::CookieRequestHeaderFieldProxy, includeSecureCookies)
    >::value);

    encoder << instance.firstParty;
    encoder << instance.sameSiteInfo;
    encoder << instance.url;
    encoder << instance.frameID;
    encoder << instance.pageID;
    encoder << instance.includeSecureCookies;
}

std::optional<WebCore::CookieRequestHeaderFieldProxy> ArgumentCoder<WebCore::CookieRequestHeaderFieldProxy>::decode(Decoder& decoder)
{
    auto firstParty = decoder.decode<URL>();
    auto sameSiteInfo = decoder.decode<WebCore::SameSiteInfo>();
    auto url = decoder.decode<URL>();
    auto frameID = decoder.decode<std::optional<WebCore::FrameIdentifier>>();
    auto pageID = decoder.decode<std::optional<WebCore::PageIdentifier>>();
    auto includeSecureCookies = decoder.decode<WebCore::IncludeSecureCookies>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CookieRequestHeaderFieldProxy {
            WTFMove(*firstParty),
            WTFMove(*sameSiteInfo),
            WTFMove(*url),
            WTFMove(*frameID),
            WTFMove(*pageID),
            WTFMove(*includeSecureCookies)
        }
    };
}

void ArgumentCoder<WebCore::FormData>::encode(Encoder& encoder, const WebCore::FormData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_elements)>, Vector<WebCore::FormDataElement>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_identifier)>, int64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_alwaysStream)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_boundary)>, Vector<uint8_t>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_lengthInBytes)>, std::optional<uint64_t>>);
    struct ShouldBeSameSizeAsFormData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FormData>, true> {
        Vector<WebCore::FormDataElement> m_elements;
        int64_t m_identifier;
        bool m_alwaysStream;
        Vector<uint8_t> m_boundary;
        std::optional<uint64_t> m_lengthInBytes;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFormData) == sizeof(WebCore::FormData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FormData, m_elements)
        , offsetof(WebCore::FormData, m_identifier)
        , offsetof(WebCore::FormData, m_alwaysStream)
        , offsetof(WebCore::FormData, m_boundary)
        , offsetof(WebCore::FormData, m_lengthInBytes)
    >::value);

    encoder << instance.m_elements;
    encoder << instance.m_identifier;
    encoder << instance.m_alwaysStream;
    encoder << instance.m_boundary;
}

std::optional<Ref<WebCore::FormData>> ArgumentCoder<WebCore::FormData>::decode(Decoder& decoder)
{
    auto m_elements = decoder.decode<Vector<WebCore::FormDataElement>>();
    auto m_identifier = decoder.decode<int64_t>();
    auto m_alwaysStream = decoder.decode<bool>();
    auto m_boundary = decoder.decode<Vector<uint8_t>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FormData::create(
            WTFMove(*m_elements),
            WTFMove(*m_identifier),
            WTFMove(*m_alwaysStream),
            WTFMove(*m_boundary)
        )
    };
}

void ArgumentCoder<WebCore::RequestedScrollData>::encode(Encoder& encoder, const WebCore::RequestedScrollData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requestType)>, WebCore::ScrollRequestType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scrollPositionOrDelta)>, Variant<WebCore::FloatPoint, WebCore::FloatSize>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scrollType)>, WebCore::ScrollType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.clamping)>, WebCore::ScrollClamping>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.animated)>, WebCore::ScrollIsAnimated>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requestedDataBeforeAnimatedScroll)>, std::optional<std::tuple<WebCore::ScrollRequestType, Variant<WebCore::FloatPoint, WebCore::FloatSize>, WebCore::ScrollType, WebCore::ScrollClamping>>>);
    struct ShouldBeSameSizeAsRequestedScrollData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::RequestedScrollData>, false> {
        WebCore::ScrollRequestType requestType;
        Variant<WebCore::FloatPoint, WebCore::FloatSize> scrollPositionOrDelta;
        WebCore::ScrollType scrollType;
        WebCore::ScrollClamping clamping;
        WebCore::ScrollIsAnimated animated;
        std::optional<std::tuple<WebCore::ScrollRequestType, Variant<WebCore::FloatPoint, WebCore::FloatSize>, WebCore::ScrollType, WebCore::ScrollClamping>> requestedDataBeforeAnimatedScroll;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRequestedScrollData) == sizeof(WebCore::RequestedScrollData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::RequestedScrollData, requestType)
        , offsetof(WebCore::RequestedScrollData, scrollPositionOrDelta)
        , offsetof(WebCore::RequestedScrollData, scrollType)
        , offsetof(WebCore::RequestedScrollData, clamping)
        , offsetof(WebCore::RequestedScrollData, animated)
        , offsetof(WebCore::RequestedScrollData, requestedDataBeforeAnimatedScroll)
    >::value);

    encoder << instance.requestType;
    encoder << instance.scrollPositionOrDelta;
    encoder << instance.scrollType;
    encoder << instance.clamping;
    encoder << instance.animated;
    encoder << instance.requestedDataBeforeAnimatedScroll;
}

std::optional<WebCore::RequestedScrollData> ArgumentCoder<WebCore::RequestedScrollData>::decode(Decoder& decoder)
{
    auto requestType = decoder.decode<WebCore::ScrollRequestType>();
    auto scrollPositionOrDelta = decoder.decode<Variant<WebCore::FloatPoint, WebCore::FloatSize>>();
    auto scrollType = decoder.decode<WebCore::ScrollType>();
    auto clamping = decoder.decode<WebCore::ScrollClamping>();
    auto animated = decoder.decode<WebCore::ScrollIsAnimated>();
    auto requestedDataBeforeAnimatedScroll = decoder.decode<std::optional<std::tuple<WebCore::ScrollRequestType, Variant<WebCore::FloatPoint, WebCore::FloatSize>, WebCore::ScrollType, WebCore::ScrollClamping>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::RequestedScrollData {
            WTFMove(*requestType),
            WTFMove(*scrollPositionOrDelta),
            WTFMove(*scrollType),
            WTFMove(*clamping),
            WTFMove(*animated),
            WTFMove(*requestedDataBeforeAnimatedScroll)
        }
    };
}

void ArgumentCoder<WebCore::FloatScrollSnapOffsetsInfo>::encode(Encoder& encoder, const WebCore::FloatScrollSnapOffsetsInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.strictness)>, WebCore::ScrollSnapStrictness>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.horizontalSnapOffsets)>, Vector<WebCore::FloatSnapOffset>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.verticalSnapOffsets)>, Vector<WebCore::FloatSnapOffset>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.snapAreas)>, Vector<WebCore::FloatRect>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.snapAreasIDs)>, Vector<WebCore::NodeIdentifier>>);
    struct ShouldBeSameSizeAsFloatScrollSnapOffsetsInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FloatScrollSnapOffsetsInfo>, false> {
        WebCore::ScrollSnapStrictness strictness;
        Vector<WebCore::FloatSnapOffset> horizontalSnapOffsets;
        Vector<WebCore::FloatSnapOffset> verticalSnapOffsets;
        Vector<WebCore::FloatRect> snapAreas;
        Vector<WebCore::NodeIdentifier> snapAreasIDs;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFloatScrollSnapOffsetsInfo) == sizeof(WebCore::FloatScrollSnapOffsetsInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FloatScrollSnapOffsetsInfo, strictness)
        , offsetof(WebCore::FloatScrollSnapOffsetsInfo, horizontalSnapOffsets)
        , offsetof(WebCore::FloatScrollSnapOffsetsInfo, verticalSnapOffsets)
        , offsetof(WebCore::FloatScrollSnapOffsetsInfo, snapAreas)
        , offsetof(WebCore::FloatScrollSnapOffsetsInfo, snapAreasIDs)
    >::value);

    encoder << instance.strictness;
    encoder << instance.horizontalSnapOffsets;
    encoder << instance.verticalSnapOffsets;
    encoder << instance.snapAreas;
    encoder << instance.snapAreasIDs;
}

std::optional<WebCore::FloatScrollSnapOffsetsInfo> ArgumentCoder<WebCore::FloatScrollSnapOffsetsInfo>::decode(Decoder& decoder)
{
    auto strictness = decoder.decode<WebCore::ScrollSnapStrictness>();
    auto horizontalSnapOffsets = decoder.decode<Vector<WebCore::FloatSnapOffset>>();
    auto verticalSnapOffsets = decoder.decode<Vector<WebCore::FloatSnapOffset>>();
    auto snapAreas = decoder.decode<Vector<WebCore::FloatRect>>();
    auto snapAreasIDs = decoder.decode<Vector<WebCore::NodeIdentifier>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FloatScrollSnapOffsetsInfo {
            WTFMove(*strictness),
            WTFMove(*horizontalSnapOffsets),
            WTFMove(*verticalSnapOffsets),
            WTFMove(*snapAreas),
            WTFMove(*snapAreasIDs)
        }
    };
}

void ArgumentCoder<WebCore::FloatSnapOffset>::encode(Encoder& encoder, const WebCore::FloatSnapOffset& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stop)>, WebCore::ScrollSnapStop>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasSnapAreaLargerThanViewport)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.snapTargetID)>, Markable<WebCore::NodeIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isFocused)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.snapAreaIndices)>, Vector<uint64_t>>);
    struct ShouldBeSameSizeAsFloatSnapOffset : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FloatSnapOffset>, false> {
        float offset;
        WebCore::ScrollSnapStop stop;
        bool hasSnapAreaLargerThanViewport;
        Markable<WebCore::NodeIdentifier> snapTargetID;
        bool isFocused;
        Vector<uint64_t> snapAreaIndices;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFloatSnapOffset) == sizeof(WebCore::FloatSnapOffset));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FloatSnapOffset, offset)
        , offsetof(WebCore::FloatSnapOffset, stop)
        , offsetof(WebCore::FloatSnapOffset, hasSnapAreaLargerThanViewport)
        , offsetof(WebCore::FloatSnapOffset, snapTargetID)
        , offsetof(WebCore::FloatSnapOffset, isFocused)
        , offsetof(WebCore::FloatSnapOffset, snapAreaIndices)
    >::value);

    encoder << instance.offset;
    encoder << instance.stop;
    encoder << instance.hasSnapAreaLargerThanViewport;
    encoder << instance.snapTargetID;
    encoder << instance.isFocused;
    encoder << instance.snapAreaIndices;
}

std::optional<WebCore::FloatSnapOffset> ArgumentCoder<WebCore::FloatSnapOffset>::decode(Decoder& decoder)
{
    auto offset = decoder.decode<float>();
    auto stop = decoder.decode<WebCore::ScrollSnapStop>();
    auto hasSnapAreaLargerThanViewport = decoder.decode<bool>();
    auto snapTargetID = decoder.decode<Markable<WebCore::NodeIdentifier>>();
    auto isFocused = decoder.decode<bool>();
    auto snapAreaIndices = decoder.decode<Vector<uint64_t>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FloatSnapOffset {
            WTFMove(*offset),
            WTFMove(*stop),
            WTFMove(*hasSnapAreaLargerThanViewport),
            WTFMove(*snapTargetID),
            WTFMove(*isFocused),
            WTFMove(*snapAreaIndices)
        }
    };
}

#if ENABLE(ENCRYPTED_MEDIA)
void ArgumentCoder<WebCore::CDMMediaCapability>::encode(Encoder& encoder, const WebCore::CDMMediaCapability& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentType)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.robustness)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.encryptionScheme)>, std::optional<WebCore::CDMEncryptionScheme>>);
    struct ShouldBeSameSizeAsCDMMediaCapability : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::CDMMediaCapability>, false> {
        String contentType;
        String robustness;
        std::optional<WebCore::CDMEncryptionScheme> encryptionScheme;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCDMMediaCapability) == sizeof(WebCore::CDMMediaCapability));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::CDMMediaCapability, contentType)
        , offsetof(WebCore::CDMMediaCapability, robustness)
        , offsetof(WebCore::CDMMediaCapability, encryptionScheme)
    >::value);

    encoder << instance.contentType;
    encoder << instance.robustness;
    encoder << instance.encryptionScheme;
}

std::optional<WebCore::CDMMediaCapability> ArgumentCoder<WebCore::CDMMediaCapability>::decode(Decoder& decoder)
{
    auto contentType = decoder.decode<String>();
    auto robustness = decoder.decode<String>();
    auto encryptionScheme = decoder.decode<std::optional<WebCore::CDMEncryptionScheme>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CDMMediaCapability {
            WTFMove(*contentType),
            WTFMove(*robustness),
            WTFMove(*encryptionScheme)
        }
    };
}

#endif

#if ENABLE(ENCRYPTED_MEDIA)
void ArgumentCoder<WebCore::CDMRestrictions>::encode(Encoder& encoder, const WebCore::CDMRestrictions& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.distinctiveIdentifierDenied)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.persistentStateDenied)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.deniedSessionTypes)>, HashSet<WebCore::CDMSessionType, IntHash<WebCore::CDMSessionType>, WTF::StrongEnumHashTraits<WebCore::CDMSessionType>>>);
    struct ShouldBeSameSizeAsCDMRestrictions : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::CDMRestrictions>, false> {
        bool distinctiveIdentifierDenied;
        bool persistentStateDenied;
        HashSet<WebCore::CDMSessionType, IntHash<WebCore::CDMSessionType>, WTF::StrongEnumHashTraits<WebCore::CDMSessionType>> deniedSessionTypes;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCDMRestrictions) == sizeof(WebCore::CDMRestrictions));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::CDMRestrictions, distinctiveIdentifierDenied)
        , offsetof(WebCore::CDMRestrictions, persistentStateDenied)
        , offsetof(WebCore::CDMRestrictions, deniedSessionTypes)
    >::value);

    encoder << instance.distinctiveIdentifierDenied;
    encoder << instance.persistentStateDenied;
    encoder << instance.deniedSessionTypes;
}

std::optional<WebCore::CDMRestrictions> ArgumentCoder<WebCore::CDMRestrictions>::decode(Decoder& decoder)
{
    auto distinctiveIdentifierDenied = decoder.decode<bool>();
    auto persistentStateDenied = decoder.decode<bool>();
    auto deniedSessionTypes = decoder.decode<HashSet<WebCore::CDMSessionType, IntHash<WebCore::CDMSessionType>, WTF::StrongEnumHashTraits<WebCore::CDMSessionType>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CDMRestrictions {
            WTFMove(*distinctiveIdentifierDenied),
            WTFMove(*persistentStateDenied),
            WTFMove(*deniedSessionTypes)
        }
    };
}

#endif

void ArgumentCoder<WebCore::MediaSelectionOption>::encode(Encoder& encoder, const WebCore::MediaSelectionOption& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaType)>, WebCore::MediaSelectionOption::MediaType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.displayName)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.legibleType)>, WebCore::MediaSelectionOption::LegibleType>);
    struct ShouldBeSameSizeAsMediaSelectionOption : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MediaSelectionOption>, false> {
        WebCore::MediaSelectionOption::MediaType mediaType;
        String displayName;
        WebCore::MediaSelectionOption::LegibleType legibleType;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMediaSelectionOption) == sizeof(WebCore::MediaSelectionOption));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MediaSelectionOption, mediaType)
        , offsetof(WebCore::MediaSelectionOption, displayName)
        , offsetof(WebCore::MediaSelectionOption, legibleType)
    >::value);

    encoder << instance.mediaType;
    encoder << instance.displayName;
    encoder << instance.legibleType;
}

std::optional<WebCore::MediaSelectionOption> ArgumentCoder<WebCore::MediaSelectionOption>::decode(Decoder& decoder)
{
    auto mediaType = decoder.decode<WebCore::MediaSelectionOption::MediaType>();
    auto displayName = decoder.decode<String>();
    auto legibleType = decoder.decode<WebCore::MediaSelectionOption::LegibleType>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MediaSelectionOption {
            WTFMove(*mediaType),
            WTFMove(*displayName),
            WTFMove(*legibleType)
        }
    };
}

void ArgumentCoder<WebCore::BufferSource>::encode(Encoder& encoder, const WebCore::BufferSource& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.span())>, std::span<const uint8_t>>);

    encoder << instance.span();
}

std::optional<WebCore::BufferSource> ArgumentCoder<WebCore::BufferSource>::decode(Decoder& decoder)
{
    auto span = decoder.decode<std::span<const uint8_t>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::BufferSource {
            WTFMove(*span)
        }
    };
}

void ArgumentCoder<WebCore::FontShadow>::encode(Encoder& encoder, const WebCore::FontShadow& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.color)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.blurRadius)>, double>);
    struct ShouldBeSameSizeAsFontShadow : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FontShadow>, false> {
        WebCore::Color color;
        WebCore::FloatSize offset;
        double blurRadius;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFontShadow) == sizeof(WebCore::FontShadow));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FontShadow, color)
        , offsetof(WebCore::FontShadow, offset)
        , offsetof(WebCore::FontShadow, blurRadius)
    >::value);

    encoder << instance.color;
    encoder << instance.offset;
    encoder << instance.blurRadius;
}

std::optional<WebCore::FontShadow> ArgumentCoder<WebCore::FontShadow>::decode(Decoder& decoder)
{
    auto color = decoder.decode<WebCore::Color>();
    auto offset = decoder.decode<WebCore::FloatSize>();
    auto blurRadius = decoder.decode<double>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FontShadow {
            WTFMove(*color),
            WTFMove(*offset),
            WTFMove(*blurRadius)
        }
    };
}

void ArgumentCoder<WebCore::CompositionHighlight>::encode(Encoder& encoder, const WebCore::CompositionHighlight& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.startOffset)>, unsigned>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.endOffset)>, unsigned>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.backgroundColor)>, std::optional<WebCore::Color>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.foregroundColor)>, std::optional<WebCore::Color>>);
    struct ShouldBeSameSizeAsCompositionHighlight : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::CompositionHighlight>, false> {
        unsigned startOffset;
        unsigned endOffset;
        std::optional<WebCore::Color> backgroundColor;
        std::optional<WebCore::Color> foregroundColor;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCompositionHighlight) == sizeof(WebCore::CompositionHighlight));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::CompositionHighlight, startOffset)
        , offsetof(WebCore::CompositionHighlight, endOffset)
        , offsetof(WebCore::CompositionHighlight, backgroundColor)
        , offsetof(WebCore::CompositionHighlight, foregroundColor)
    >::value);

    encoder << instance.startOffset;
    encoder << instance.endOffset;
    encoder << instance.backgroundColor;
    encoder << instance.foregroundColor;
}

std::optional<WebCore::CompositionHighlight> ArgumentCoder<WebCore::CompositionHighlight>::decode(Decoder& decoder)
{
    auto startOffset = decoder.decode<unsigned>();
    auto endOffset = decoder.decode<unsigned>();
    auto backgroundColor = decoder.decode<std::optional<WebCore::Color>>();
    auto foregroundColor = decoder.decode<std::optional<WebCore::Color>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CompositionHighlight {
            WTFMove(*startOffset),
            WTFMove(*endOffset),
            WTFMove(*backgroundColor),
            WTFMove(*foregroundColor)
        }
    };
}

void ArgumentCoder<WebCore::FontChanges>::encode(Encoder& encoder, const WebCore::FontChanges& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_fontName)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_fontFamily)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_fontSize)>, std::optional<double>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_fontSizeDelta)>, std::optional<double>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_bold)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_italic)>, std::optional<bool>>);
    struct ShouldBeSameSizeAsFontChanges : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FontChanges>, false> {
        String m_fontName;
        String m_fontFamily;
        std::optional<double> m_fontSize;
        std::optional<double> m_fontSizeDelta;
        std::optional<bool> m_bold;
        std::optional<bool> m_italic;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFontChanges) == sizeof(WebCore::FontChanges));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FontChanges, m_fontName)
        , offsetof(WebCore::FontChanges, m_fontFamily)
        , offsetof(WebCore::FontChanges, m_fontSize)
        , offsetof(WebCore::FontChanges, m_fontSizeDelta)
        , offsetof(WebCore::FontChanges, m_bold)
        , offsetof(WebCore::FontChanges, m_italic)
    >::value);

    encoder << instance.m_fontName;
    encoder << instance.m_fontFamily;
    encoder << instance.m_fontSize;
    encoder << instance.m_fontSizeDelta;
    encoder << instance.m_bold;
    encoder << instance.m_italic;
}

std::optional<WebCore::FontChanges> ArgumentCoder<WebCore::FontChanges>::decode(Decoder& decoder)
{
    auto m_fontName = decoder.decode<String>();
    auto m_fontFamily = decoder.decode<String>();
    auto m_fontSize = decoder.decode<std::optional<double>>();
    auto m_fontSizeDelta = decoder.decode<std::optional<double>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(!*m_fontSize || !*m_fontSizeDelta))
        return std::nullopt;
    auto m_bold = decoder.decode<std::optional<bool>>();
    auto m_italic = decoder.decode<std::optional<bool>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FontChanges {
            WTFMove(*m_fontName),
            WTFMove(*m_fontFamily),
            WTFMove(*m_fontSize),
            WTFMove(*m_fontSizeDelta),
            WTFMove(*m_bold),
            WTFMove(*m_italic)
        }
    };
}

void ArgumentCoder<WebCore::FontAttributeChanges>::encode(Encoder& encoder, const WebCore::FontAttributeChanges& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_verticalAlign)>, std::optional<WebCore::VerticalAlignChange>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_backgroundColor)>, std::optional<WebCore::Color>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_foregroundColor)>, std::optional<WebCore::Color>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_shadow)>, std::optional<WebCore::FontShadow>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_strikeThrough)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_underline)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_fontChanges)>, WebCore::FontChanges>);
    struct ShouldBeSameSizeAsFontAttributeChanges : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FontAttributeChanges>, false> {
        std::optional<WebCore::VerticalAlignChange> m_verticalAlign;
        std::optional<WebCore::Color> m_backgroundColor;
        std::optional<WebCore::Color> m_foregroundColor;
        std::optional<WebCore::FontShadow> m_shadow;
        std::optional<bool> m_strikeThrough;
        std::optional<bool> m_underline;
        WebCore::FontChanges m_fontChanges;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFontAttributeChanges) == sizeof(WebCore::FontAttributeChanges));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FontAttributeChanges, m_verticalAlign)
        , offsetof(WebCore::FontAttributeChanges, m_backgroundColor)
        , offsetof(WebCore::FontAttributeChanges, m_foregroundColor)
        , offsetof(WebCore::FontAttributeChanges, m_shadow)
        , offsetof(WebCore::FontAttributeChanges, m_strikeThrough)
        , offsetof(WebCore::FontAttributeChanges, m_underline)
        , offsetof(WebCore::FontAttributeChanges, m_fontChanges)
    >::value);

    encoder << instance.m_verticalAlign;
    encoder << instance.m_backgroundColor;
    encoder << instance.m_foregroundColor;
    encoder << instance.m_shadow;
    encoder << instance.m_strikeThrough;
    encoder << instance.m_underline;
    encoder << instance.m_fontChanges;
}

std::optional<WebCore::FontAttributeChanges> ArgumentCoder<WebCore::FontAttributeChanges>::decode(Decoder& decoder)
{
    auto m_verticalAlign = decoder.decode<std::optional<WebCore::VerticalAlignChange>>();
    auto m_backgroundColor = decoder.decode<std::optional<WebCore::Color>>();
    auto m_foregroundColor = decoder.decode<std::optional<WebCore::Color>>();
    auto m_shadow = decoder.decode<std::optional<WebCore::FontShadow>>();
    auto m_strikeThrough = decoder.decode<std::optional<bool>>();
    auto m_underline = decoder.decode<std::optional<bool>>();
    auto m_fontChanges = decoder.decode<WebCore::FontChanges>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FontAttributeChanges {
            WTFMove(*m_verticalAlign),
            WTFMove(*m_backgroundColor),
            WTFMove(*m_foregroundColor),
            WTFMove(*m_shadow),
            WTFMove(*m_strikeThrough),
            WTFMove(*m_underline),
            WTFMove(*m_fontChanges)
        }
    };
}

void ArgumentCoder<WebCore::TextManipulationControllerExclusionRule::ElementRule>::encode(Encoder& encoder, const WebCore::TextManipulationControllerExclusionRule::ElementRule& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.localName)>, AtomString>);
    struct ShouldBeSameSizeAsElementRule : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::TextManipulationControllerExclusionRule::ElementRule>, false> {
        AtomString localName;
    };
    static_assert(sizeof(ShouldBeSameSizeAsElementRule) == sizeof(WebCore::TextManipulationControllerExclusionRule::ElementRule));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::TextManipulationControllerExclusionRule::ElementRule, localName)
    >::value);

    encoder << instance.localName;
}

std::optional<WebCore::TextManipulationControllerExclusionRule::ElementRule> ArgumentCoder<WebCore::TextManipulationControllerExclusionRule::ElementRule>::decode(Decoder& decoder)
{
    auto localName = decoder.decode<AtomString>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TextManipulationControllerExclusionRule::ElementRule {
            WTFMove(*localName)
        }
    };
}

void ArgumentCoder<WebCore::TextManipulationControllerExclusionRule::AttributeRule>::encode(Encoder& encoder, const WebCore::TextManipulationControllerExclusionRule::AttributeRule& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, AtomString>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, String>);
    struct ShouldBeSameSizeAsAttributeRule : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::TextManipulationControllerExclusionRule::AttributeRule>, false> {
        AtomString name;
        String value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsAttributeRule) == sizeof(WebCore::TextManipulationControllerExclusionRule::AttributeRule));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::TextManipulationControllerExclusionRule::AttributeRule, name)
        , offsetof(WebCore::TextManipulationControllerExclusionRule::AttributeRule, value)
    >::value);

    encoder << instance.name;
    encoder << instance.value;
}

std::optional<WebCore::TextManipulationControllerExclusionRule::AttributeRule> ArgumentCoder<WebCore::TextManipulationControllerExclusionRule::AttributeRule>::decode(Decoder& decoder)
{
    auto name = decoder.decode<AtomString>();
    auto value = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TextManipulationControllerExclusionRule::AttributeRule {
            WTFMove(*name),
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebCore::TextManipulationControllerExclusionRule::ClassRule>::encode(Encoder& encoder, const WebCore::TextManipulationControllerExclusionRule::ClassRule& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.className)>, AtomString>);
    struct ShouldBeSameSizeAsClassRule : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::TextManipulationControllerExclusionRule::ClassRule>, false> {
        AtomString className;
    };
    static_assert(sizeof(ShouldBeSameSizeAsClassRule) == sizeof(WebCore::TextManipulationControllerExclusionRule::ClassRule));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::TextManipulationControllerExclusionRule::ClassRule, className)
    >::value);

    encoder << instance.className;
}

std::optional<WebCore::TextManipulationControllerExclusionRule::ClassRule> ArgumentCoder<WebCore::TextManipulationControllerExclusionRule::ClassRule>::decode(Decoder& decoder)
{
    auto className = decoder.decode<AtomString>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TextManipulationControllerExclusionRule::ClassRule {
            WTFMove(*className)
        }
    };
}

void ArgumentCoder<WebCore::TextManipulationControllerExclusionRule>::encode(Encoder& encoder, const WebCore::TextManipulationControllerExclusionRule& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::TextManipulationControllerExclusionRule::Type>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rule)>, Variant<WebCore::TextManipulationControllerExclusionRule::ElementRule, WebCore::TextManipulationControllerExclusionRule::AttributeRule, WebCore::TextManipulationControllerExclusionRule::ClassRule>>);
    struct ShouldBeSameSizeAsTextManipulationControllerExclusionRule : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::TextManipulationControllerExclusionRule>, false> {
        WebCore::TextManipulationControllerExclusionRule::Type type;
        Variant<WebCore::TextManipulationControllerExclusionRule::ElementRule, WebCore::TextManipulationControllerExclusionRule::AttributeRule, WebCore::TextManipulationControllerExclusionRule::ClassRule> rule;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTextManipulationControllerExclusionRule) == sizeof(WebCore::TextManipulationControllerExclusionRule));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::TextManipulationControllerExclusionRule, type)
        , offsetof(WebCore::TextManipulationControllerExclusionRule, rule)
    >::value);

    encoder << instance.type;
    encoder << instance.rule;
}

std::optional<WebCore::TextManipulationControllerExclusionRule> ArgumentCoder<WebCore::TextManipulationControllerExclusionRule>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::TextManipulationControllerExclusionRule::Type>();
    auto rule = decoder.decode<Variant<WebCore::TextManipulationControllerExclusionRule::ElementRule, WebCore::TextManipulationControllerExclusionRule::AttributeRule, WebCore::TextManipulationControllerExclusionRule::ClassRule>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TextManipulationControllerExclusionRule {
            WTFMove(*type),
            WTFMove(*rule)
        }
    };
}

void ArgumentCoder<WebCore::TextManipulationControllerManipulationFailure>::encode(Encoder& encoder, const WebCore::TextManipulationControllerManipulationFailure& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameID)>, WebCore::FrameIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, Markable<WebCore::TextManipulationItemIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.index)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::TextManipulationControllerManipulationFailure::Type>);
    struct ShouldBeSameSizeAsTextManipulationControllerManipulationFailure : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::TextManipulationControllerManipulationFailure>, false> {
        WebCore::FrameIdentifier frameID;
        Markable<WebCore::TextManipulationItemIdentifier> identifier;
        uint64_t index;
        WebCore::TextManipulationControllerManipulationFailure::Type type;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTextManipulationControllerManipulationFailure) == sizeof(WebCore::TextManipulationControllerManipulationFailure));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::TextManipulationControllerManipulationFailure, frameID)
        , offsetof(WebCore::TextManipulationControllerManipulationFailure, identifier)
        , offsetof(WebCore::TextManipulationControllerManipulationFailure, index)
        , offsetof(WebCore::TextManipulationControllerManipulationFailure, type)
    >::value);

    encoder << instance.frameID;
    encoder << instance.identifier;
    encoder << instance.index;
    encoder << instance.type;
}

std::optional<WebCore::TextManipulationControllerManipulationFailure> ArgumentCoder<WebCore::TextManipulationControllerManipulationFailure>::decode(Decoder& decoder)
{
    auto frameID = decoder.decode<WebCore::FrameIdentifier>();
    auto identifier = decoder.decode<Markable<WebCore::TextManipulationItemIdentifier>>();
    auto index = decoder.decode<uint64_t>();
    auto type = decoder.decode<WebCore::TextManipulationControllerManipulationFailure::Type>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TextManipulationControllerManipulationFailure {
            WTFMove(*frameID),
            WTFMove(*identifier),
            WTFMove(*index),
            WTFMove(*type)
        }
    };
}

void ArgumentCoder<WebCore::TextManipulationControllerManipulationResult>::encode(Encoder& encoder, const WebCore::TextManipulationControllerManipulationResult& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.failures)>, Vector<WebCore::TextManipulationControllerManipulationFailure>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.succeededIndexes)>, Vector<uint64_t>>);
    struct ShouldBeSameSizeAsTextManipulationControllerManipulationResult : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::TextManipulationControllerManipulationResult>, false> {
        Vector<WebCore::TextManipulationControllerManipulationFailure> failures;
        Vector<uint64_t> succeededIndexes;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTextManipulationControllerManipulationResult) == sizeof(WebCore::TextManipulationControllerManipulationResult));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::TextManipulationControllerManipulationResult, failures)
        , offsetof(WebCore::TextManipulationControllerManipulationResult, succeededIndexes)
    >::value);

    encoder << instance.failures;
    encoder << instance.succeededIndexes;
}

std::optional<WebCore::TextManipulationControllerManipulationResult> ArgumentCoder<WebCore::TextManipulationControllerManipulationResult>::decode(Decoder& decoder)
{
    auto failures = decoder.decode<Vector<WebCore::TextManipulationControllerManipulationFailure>>();
    auto succeededIndexes = decoder.decode<Vector<uint64_t>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TextManipulationControllerManipulationResult {
            WTFMove(*failures),
            WTFMove(*succeededIndexes)
        }
    };
}

void ArgumentCoder<WebCore::BackgroundFetchInformation>::encode(Encoder& encoder, const WebCore::BackgroundFetchInformation& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.registrationIdentifier)>, WebCore::ServiceWorkerRegistrationIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.uploadTotal)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.uploaded)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.downloadTotal)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.downloaded)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.result)>, WebCore::BackgroundFetchResult>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.failureReason)>, WebCore::BackgroundFetchFailureReason>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.recordsAvailable)>, bool>);
    struct ShouldBeSameSizeAsBackgroundFetchInformation : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::BackgroundFetchInformation>, false> {
        WebCore::ServiceWorkerRegistrationIdentifier registrationIdentifier;
        String identifier;
        uint64_t uploadTotal;
        uint64_t uploaded;
        uint64_t downloadTotal;
        uint64_t downloaded;
        WebCore::BackgroundFetchResult result;
        WebCore::BackgroundFetchFailureReason failureReason;
        bool recordsAvailable;
    };
    static_assert(sizeof(ShouldBeSameSizeAsBackgroundFetchInformation) == sizeof(WebCore::BackgroundFetchInformation));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::BackgroundFetchInformation, registrationIdentifier)
        , offsetof(WebCore::BackgroundFetchInformation, identifier)
        , offsetof(WebCore::BackgroundFetchInformation, uploadTotal)
        , offsetof(WebCore::BackgroundFetchInformation, uploaded)
        , offsetof(WebCore::BackgroundFetchInformation, downloadTotal)
        , offsetof(WebCore::BackgroundFetchInformation, downloaded)
        , offsetof(WebCore::BackgroundFetchInformation, result)
        , offsetof(WebCore::BackgroundFetchInformation, failureReason)
        , offsetof(WebCore::BackgroundFetchInformation, recordsAvailable)
    >::value);

    encoder << instance.registrationIdentifier;
    encoder << instance.identifier;
    encoder << instance.uploadTotal;
    encoder << instance.uploaded;
    encoder << instance.downloadTotal;
    encoder << instance.downloaded;
    encoder << instance.result;
    encoder << instance.failureReason;
    encoder << instance.recordsAvailable;
}

std::optional<WebCore::BackgroundFetchInformation> ArgumentCoder<WebCore::BackgroundFetchInformation>::decode(Decoder& decoder)
{
    auto registrationIdentifier = decoder.decode<WebCore::ServiceWorkerRegistrationIdentifier>();
    auto identifier = decoder.decode<String>();
    auto uploadTotal = decoder.decode<uint64_t>();
    auto uploaded = decoder.decode<uint64_t>();
    auto downloadTotal = decoder.decode<uint64_t>();
    auto downloaded = decoder.decode<uint64_t>();
    auto result = decoder.decode<WebCore::BackgroundFetchResult>();
    auto failureReason = decoder.decode<WebCore::BackgroundFetchFailureReason>();
    auto recordsAvailable = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::BackgroundFetchInformation {
            WTFMove(*registrationIdentifier),
            WTFMove(*identifier),
            WTFMove(*uploadTotal),
            WTFMove(*uploaded),
            WTFMove(*downloadTotal),
            WTFMove(*downloaded),
            WTFMove(*result),
            WTFMove(*failureReason),
            WTFMove(*recordsAvailable)
        }
    };
}

void ArgumentCoder<WebCore::BackgroundFetchRequest>::encode(Encoder& encoder, const WebCore::BackgroundFetchRequest& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.internalRequest)>, WebCore::ResourceRequest>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.options)>, WebCore::FetchOptions>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.guard)>, WebCore::FetchHeadersGuard>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.httpHeaders)>, WebCore::HTTPHeaderMap>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.referrer)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cspResponseHeaders)>, Markable<WebCore::ContentSecurityPolicyResponseHeaders>>);
    struct ShouldBeSameSizeAsBackgroundFetchRequest : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::BackgroundFetchRequest>, false> {
        WebCore::ResourceRequest internalRequest;
        WebCore::FetchOptions options;
        WebCore::FetchHeadersGuard guard;
        WebCore::HTTPHeaderMap httpHeaders;
        String referrer;
        Markable<WebCore::ContentSecurityPolicyResponseHeaders> cspResponseHeaders;
    };
    static_assert(sizeof(ShouldBeSameSizeAsBackgroundFetchRequest) == sizeof(WebCore::BackgroundFetchRequest));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::BackgroundFetchRequest, internalRequest)
        , offsetof(WebCore::BackgroundFetchRequest, options)
        , offsetof(WebCore::BackgroundFetchRequest, guard)
        , offsetof(WebCore::BackgroundFetchRequest, httpHeaders)
        , offsetof(WebCore::BackgroundFetchRequest, referrer)
        , offsetof(WebCore::BackgroundFetchRequest, cspResponseHeaders)
    >::value);

    encoder << instance.internalRequest;
    encoder << instance.options;
    encoder << instance.guard;
    encoder << instance.httpHeaders;
    encoder << instance.referrer;
    encoder << instance.cspResponseHeaders;
}

std::optional<WebCore::BackgroundFetchRequest> ArgumentCoder<WebCore::BackgroundFetchRequest>::decode(Decoder& decoder)
{
    auto internalRequest = decoder.decode<WebCore::ResourceRequest>();
    auto options = decoder.decode<WebCore::FetchOptions>();
    auto guard = decoder.decode<WebCore::FetchHeadersGuard>();
    auto httpHeaders = decoder.decode<WebCore::HTTPHeaderMap>();
    auto referrer = decoder.decode<String>();
    auto cspResponseHeaders = decoder.decode<Markable<WebCore::ContentSecurityPolicyResponseHeaders>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::BackgroundFetchRequest {
            WTFMove(*internalRequest),
            WTFMove(*options),
            WTFMove(*guard),
            WTFMove(*httpHeaders),
            WTFMove(*referrer),
            WTFMove(*cspResponseHeaders)
        }
    };
}

void ArgumentCoder<WebCore::BackgroundFetchRecordInformation>::encode(Encoder& encoder, const WebCore::BackgroundFetchRecordInformation& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, WebCore::BackgroundFetchRecordIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.internalRequest)>, WebCore::ResourceRequest>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.options)>, WebCore::FetchOptions>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.guard)>, WebCore::FetchHeadersGuard>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.httpHeaders)>, WebCore::HTTPHeaderMap>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.referrer)>, String>);
    struct ShouldBeSameSizeAsBackgroundFetchRecordInformation : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::BackgroundFetchRecordInformation>, false> {
        WebCore::BackgroundFetchRecordIdentifier identifier;
        WebCore::ResourceRequest internalRequest;
        WebCore::FetchOptions options;
        WebCore::FetchHeadersGuard guard;
        WebCore::HTTPHeaderMap httpHeaders;
        String referrer;
    };
    static_assert(sizeof(ShouldBeSameSizeAsBackgroundFetchRecordInformation) == sizeof(WebCore::BackgroundFetchRecordInformation));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::BackgroundFetchRecordInformation, identifier)
        , offsetof(WebCore::BackgroundFetchRecordInformation, internalRequest)
        , offsetof(WebCore::BackgroundFetchRecordInformation, options)
        , offsetof(WebCore::BackgroundFetchRecordInformation, guard)
        , offsetof(WebCore::BackgroundFetchRecordInformation, httpHeaders)
        , offsetof(WebCore::BackgroundFetchRecordInformation, referrer)
    >::value);

    encoder << instance.identifier;
    encoder << instance.internalRequest;
    encoder << instance.options;
    encoder << instance.guard;
    encoder << instance.httpHeaders;
    encoder << instance.referrer;
}

std::optional<WebCore::BackgroundFetchRecordInformation> ArgumentCoder<WebCore::BackgroundFetchRecordInformation>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<WebCore::BackgroundFetchRecordIdentifier>();
    auto internalRequest = decoder.decode<WebCore::ResourceRequest>();
    auto options = decoder.decode<WebCore::FetchOptions>();
    auto guard = decoder.decode<WebCore::FetchHeadersGuard>();
    auto httpHeaders = decoder.decode<WebCore::HTTPHeaderMap>();
    auto referrer = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::BackgroundFetchRecordInformation {
            WTFMove(*identifier),
            WTFMove(*internalRequest),
            WTFMove(*options),
            WTFMove(*guard),
            WTFMove(*httpHeaders),
            WTFMove(*referrer)
        }
    };
}

void ArgumentCoder<WebCore::BackgroundFetchOptions>::encode(Encoder& encoder, const WebCore::BackgroundFetchOptions& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.icons)>, Vector<WebCore::ImageResource>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.title)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.downloadTotal)>, uint64_t>);
    struct ShouldBeSameSizeAsBackgroundFetchOptions : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::BackgroundFetchOptions>, false> {
        Vector<WebCore::ImageResource> icons;
        String title;
        uint64_t downloadTotal;
    };
    static_assert(sizeof(ShouldBeSameSizeAsBackgroundFetchOptions) == sizeof(WebCore::BackgroundFetchOptions));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::BackgroundFetchOptions, icons)
        , offsetof(WebCore::BackgroundFetchOptions, title)
        , offsetof(WebCore::BackgroundFetchOptions, downloadTotal)
    >::value);

    encoder << instance.icons;
    encoder << instance.title;
    encoder << instance.downloadTotal;
}

std::optional<WebCore::BackgroundFetchOptions> ArgumentCoder<WebCore::BackgroundFetchOptions>::decode(Decoder& decoder)
{
    auto icons = decoder.decode<Vector<WebCore::ImageResource>>();
    auto title = decoder.decode<String>();
    auto downloadTotal = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::BackgroundFetchOptions {
            WTFMove(*icons),
            WTFMove(*title),
            WTFMove(*downloadTotal)
        }
    };
}

void ArgumentCoder<WebCore::ImageResource>::encode(Encoder& encoder, const WebCore::ImageResource& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.src)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sizes)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    struct ShouldBeSameSizeAsImageResource : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ImageResource>, false> {
        String src;
        String sizes;
        String type;
        String label;
    };
    static_assert(sizeof(ShouldBeSameSizeAsImageResource) == sizeof(WebCore::ImageResource));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ImageResource, src)
        , offsetof(WebCore::ImageResource, sizes)
        , offsetof(WebCore::ImageResource, type)
        , offsetof(WebCore::ImageResource, label)
    >::value);

    encoder << instance.src;
    encoder << instance.sizes;
    encoder << instance.type;
    encoder << instance.label;
}

std::optional<WebCore::ImageResource> ArgumentCoder<WebCore::ImageResource>::decode(Decoder& decoder)
{
    auto src = decoder.decode<String>();
    auto sizes = decoder.decode<String>();
    auto type = decoder.decode<String>();
    auto label = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ImageResource {
            WTFMove(*src),
            WTFMove(*sizes),
            WTFMove(*type),
            WTFMove(*label)
        }
    };
}

void ArgumentCoder<WebCore::FourCC>::encode(Encoder& encoder, const WebCore::FourCC& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, uint32_t>);
    struct ShouldBeSameSizeAsFourCC : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FourCC>, false> {
        uint32_t value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFourCC) == sizeof(WebCore::FourCC));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FourCC, value)
    >::value);

    encoder << instance.value;
}

std::optional<WebCore::FourCC> ArgumentCoder<WebCore::FourCC>::decode(Decoder& decoder)
{
    auto value = decoder.decode<uint32_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FourCC {
            WTFMove(*value)
        }
    };
}

#if ENABLE(VIDEO)
void ArgumentCoder<WebCore::MediaEngineSupportParameters>::encode(Encoder& encoder, const WebCore::MediaEngineSupportParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::ContentType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isMediaSource)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isMediaStream)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requiresRemotePlayback)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsLimitedMatroska)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentTypesRequiringHardwareSupport)>, Vector<WebCore::ContentType>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowedMediaContainerTypes)>, std::optional<Vector<String>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowedMediaCodecTypes)>, std::optional<Vector<String>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowedMediaVideoCodecIDs)>, std::optional<Vector<WebCore::FourCC>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowedMediaAudioCodecIDs)>, std::optional<Vector<WebCore::FourCC>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowedMediaCaptionFormatTypes)>, std::optional<Vector<WebCore::FourCC>>>);
    struct ShouldBeSameSizeAsMediaEngineSupportParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MediaEngineSupportParameters>, false> {
        WebCore::ContentType type;
        URL url;
        bool isMediaSource;
        bool isMediaStream;
        bool requiresRemotePlayback;
        bool supportsLimitedMatroska;
        Vector<WebCore::ContentType> contentTypesRequiringHardwareSupport;
        std::optional<Vector<String>> allowedMediaContainerTypes;
        std::optional<Vector<String>> allowedMediaCodecTypes;
        std::optional<Vector<WebCore::FourCC>> allowedMediaVideoCodecIDs;
        std::optional<Vector<WebCore::FourCC>> allowedMediaAudioCodecIDs;
        std::optional<Vector<WebCore::FourCC>> allowedMediaCaptionFormatTypes;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMediaEngineSupportParameters) == sizeof(WebCore::MediaEngineSupportParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MediaEngineSupportParameters, type)
        , offsetof(WebCore::MediaEngineSupportParameters, url)
        , offsetof(WebCore::MediaEngineSupportParameters, isMediaSource)
        , offsetof(WebCore::MediaEngineSupportParameters, isMediaStream)
        , offsetof(WebCore::MediaEngineSupportParameters, requiresRemotePlayback)
        , offsetof(WebCore::MediaEngineSupportParameters, supportsLimitedMatroska)
        , offsetof(WebCore::MediaEngineSupportParameters, contentTypesRequiringHardwareSupport)
        , offsetof(WebCore::MediaEngineSupportParameters, allowedMediaContainerTypes)
        , offsetof(WebCore::MediaEngineSupportParameters, allowedMediaCodecTypes)
        , offsetof(WebCore::MediaEngineSupportParameters, allowedMediaVideoCodecIDs)
        , offsetof(WebCore::MediaEngineSupportParameters, allowedMediaAudioCodecIDs)
        , offsetof(WebCore::MediaEngineSupportParameters, allowedMediaCaptionFormatTypes)
    >::value);

    encoder << instance.type;
    encoder << instance.url;
    encoder << instance.isMediaSource;
    encoder << instance.isMediaStream;
    encoder << instance.requiresRemotePlayback;
    encoder << instance.supportsLimitedMatroska;
    encoder << instance.contentTypesRequiringHardwareSupport;
    encoder << instance.allowedMediaContainerTypes;
    encoder << instance.allowedMediaCodecTypes;
    encoder << instance.allowedMediaVideoCodecIDs;
    encoder << instance.allowedMediaAudioCodecIDs;
    encoder << instance.allowedMediaCaptionFormatTypes;
}

std::optional<WebCore::MediaEngineSupportParameters> ArgumentCoder<WebCore::MediaEngineSupportParameters>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::ContentType>();
    auto url = decoder.decode<URL>();
    auto isMediaSource = decoder.decode<bool>();
    auto isMediaStream = decoder.decode<bool>();
    auto requiresRemotePlayback = decoder.decode<bool>();
    auto supportsLimitedMatroska = decoder.decode<bool>();
    auto contentTypesRequiringHardwareSupport = decoder.decode<Vector<WebCore::ContentType>>();
    auto allowedMediaContainerTypes = decoder.decode<std::optional<Vector<String>>>();
    auto allowedMediaCodecTypes = decoder.decode<std::optional<Vector<String>>>();
    auto allowedMediaVideoCodecIDs = decoder.decode<std::optional<Vector<WebCore::FourCC>>>();
    auto allowedMediaAudioCodecIDs = decoder.decode<std::optional<Vector<WebCore::FourCC>>>();
    auto allowedMediaCaptionFormatTypes = decoder.decode<std::optional<Vector<WebCore::FourCC>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MediaEngineSupportParameters {
            WTFMove(*type),
            WTFMove(*url),
            WTFMove(*isMediaSource),
            WTFMove(*isMediaStream),
            WTFMove(*requiresRemotePlayback),
            WTFMove(*supportsLimitedMatroska),
            WTFMove(*contentTypesRequiringHardwareSupport),
            WTFMove(*allowedMediaContainerTypes),
            WTFMove(*allowedMediaCodecTypes),
            WTFMove(*allowedMediaVideoCodecIDs),
            WTFMove(*allowedMediaAudioCodecIDs),
            WTFMove(*allowedMediaCaptionFormatTypes)
        }
    };
}

#endif

#if ENABLE(VIDEO)
void ArgumentCoder<WebCore::SeekTarget>::encode(Encoder& encoder, const WebCore::SeekTarget& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.time)>, MediaTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.negativeThreshold)>, MediaTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.positiveThreshold)>, MediaTime>);
    struct ShouldBeSameSizeAsSeekTarget : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SeekTarget>, false> {
        MediaTime time;
        MediaTime negativeThreshold;
        MediaTime positiveThreshold;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSeekTarget) == sizeof(WebCore::SeekTarget));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SeekTarget, time)
        , offsetof(WebCore::SeekTarget, negativeThreshold)
        , offsetof(WebCore::SeekTarget, positiveThreshold)
    >::value);

    encoder << instance.time;
    encoder << instance.negativeThreshold;
    encoder << instance.positiveThreshold;
}

std::optional<WebCore::SeekTarget> ArgumentCoder<WebCore::SeekTarget>::decode(Decoder& decoder)
{
    auto time = decoder.decode<MediaTime>();
    auto negativeThreshold = decoder.decode<MediaTime>();
    auto positiveThreshold = decoder.decode<MediaTime>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SeekTarget {
            WTFMove(*time),
            WTFMove(*negativeThreshold),
            WTFMove(*positiveThreshold)
        }
    };
}

#endif

#if ENABLE(VIDEO)
void ArgumentCoder<WebCore::MediaPlayerLoadOptions>::encode(Encoder& encoder, const WebCore::MediaPlayerLoadOptions& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentType)>, WebCore::ContentType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requiresRemotePlayback)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsLimitedMatroska)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.videoMediaSampleRendererPreferences)>, OptionSet<WebCore::VideoMediaSampleRendererPreference>>);
    struct ShouldBeSameSizeAsMediaPlayerLoadOptions : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MediaPlayerLoadOptions>, false> {
        WebCore::ContentType contentType;
        bool requiresRemotePlayback;
        bool supportsLimitedMatroska;
        OptionSet<WebCore::VideoMediaSampleRendererPreference> videoMediaSampleRendererPreferences;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMediaPlayerLoadOptions) == sizeof(WebCore::MediaPlayerLoadOptions));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MediaPlayerLoadOptions, contentType)
        , offsetof(WebCore::MediaPlayerLoadOptions, requiresRemotePlayback)
        , offsetof(WebCore::MediaPlayerLoadOptions, supportsLimitedMatroska)
        , offsetof(WebCore::MediaPlayerLoadOptions, videoMediaSampleRendererPreferences)
    >::value);

    encoder << instance.contentType;
    encoder << instance.requiresRemotePlayback;
    encoder << instance.supportsLimitedMatroska;
    encoder << instance.videoMediaSampleRendererPreferences;
}

std::optional<WebCore::MediaPlayerLoadOptions> ArgumentCoder<WebCore::MediaPlayerLoadOptions>::decode(Decoder& decoder)
{
    auto contentType = decoder.decode<WebCore::ContentType>();
    auto requiresRemotePlayback = decoder.decode<bool>();
    auto supportsLimitedMatroska = decoder.decode<bool>();
    auto videoMediaSampleRendererPreferences = decoder.decode<OptionSet<WebCore::VideoMediaSampleRendererPreference>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MediaPlayerLoadOptions {
            WTFMove(*contentType),
            WTFMove(*requiresRemotePlayback),
            WTFMove(*supportsLimitedMatroska),
            WTFMove(*videoMediaSampleRendererPreferences)
        }
    };
}

#endif

void ArgumentCoder<WebCore::GeolocationPositionData>::encode(Encoder& encoder, const WebCore::GeolocationPositionData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timestamp)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.latitude)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.longitude)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.accuracy)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.altitude)>, std::optional<double>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.altitudeAccuracy)>, std::optional<double>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.heading)>, std::optional<double>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.speed)>, std::optional<double>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.floorLevel)>, std::optional<double>>);
    struct ShouldBeSameSizeAsGeolocationPositionData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::GeolocationPositionData>, false> {
        double timestamp;
        double latitude;
        double longitude;
        double accuracy;
        std::optional<double> altitude;
        std::optional<double> altitudeAccuracy;
        std::optional<double> heading;
        std::optional<double> speed;
        std::optional<double> floorLevel;
    };
    static_assert(sizeof(ShouldBeSameSizeAsGeolocationPositionData) == sizeof(WebCore::GeolocationPositionData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::GeolocationPositionData, timestamp)
        , offsetof(WebCore::GeolocationPositionData, latitude)
        , offsetof(WebCore::GeolocationPositionData, longitude)
        , offsetof(WebCore::GeolocationPositionData, accuracy)
        , offsetof(WebCore::GeolocationPositionData, altitude)
        , offsetof(WebCore::GeolocationPositionData, altitudeAccuracy)
        , offsetof(WebCore::GeolocationPositionData, heading)
        , offsetof(WebCore::GeolocationPositionData, speed)
        , offsetof(WebCore::GeolocationPositionData, floorLevel)
    >::value);

    encoder << instance.timestamp;
    encoder << instance.latitude;
    encoder << instance.longitude;
    encoder << instance.accuracy;
    encoder << instance.altitude;
    encoder << instance.altitudeAccuracy;
    encoder << instance.heading;
    encoder << instance.speed;
    encoder << instance.floorLevel;
}

std::optional<WebCore::GeolocationPositionData> ArgumentCoder<WebCore::GeolocationPositionData>::decode(Decoder& decoder)
{
    auto timestamp = decoder.decode<double>();
    auto latitude = decoder.decode<double>();
    auto longitude = decoder.decode<double>();
    auto accuracy = decoder.decode<double>();
    auto altitude = decoder.decode<std::optional<double>>();
    auto altitudeAccuracy = decoder.decode<std::optional<double>>();
    auto heading = decoder.decode<std::optional<double>>();
    auto speed = decoder.decode<std::optional<double>>();
    auto floorLevel = decoder.decode<std::optional<double>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::GeolocationPositionData {
            WTFMove(*timestamp),
            WTFMove(*latitude),
            WTFMove(*longitude),
            WTFMove(*accuracy),
            WTFMove(*altitude),
            WTFMove(*altitudeAccuracy),
            WTFMove(*heading),
            WTFMove(*speed),
            WTFMove(*floorLevel)
        }
    };
}

#if ENABLE(APP_HIGHLIGHTS)
void ArgumentCoder<WebCore::AppHighlight>::encode(Encoder& encoder, const WebCore::AppHighlight& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.highlight)>, Ref<WebCore::FragmentedSharedBuffer>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.text)>, std::optional<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isNewGroup)>, WebCore::CreateNewGroupForHighlight>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requestOriginatedInApp)>, WebCore::HighlightRequestOriginatedInApp>);
    struct ShouldBeSameSizeAsAppHighlight : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::AppHighlight>, false> {
        Ref<WebCore::FragmentedSharedBuffer> highlight;
        std::optional<String> text;
        WebCore::CreateNewGroupForHighlight isNewGroup;
        WebCore::HighlightRequestOriginatedInApp requestOriginatedInApp;
    };
    static_assert(sizeof(ShouldBeSameSizeAsAppHighlight) == sizeof(WebCore::AppHighlight));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::AppHighlight, highlight)
        , offsetof(WebCore::AppHighlight, text)
        , offsetof(WebCore::AppHighlight, isNewGroup)
        , offsetof(WebCore::AppHighlight, requestOriginatedInApp)
    >::value);

    encoder << instance.highlight;
    encoder << instance.text;
    encoder << instance.isNewGroup;
    encoder << instance.requestOriginatedInApp;
}

std::optional<WebCore::AppHighlight> ArgumentCoder<WebCore::AppHighlight>::decode(Decoder& decoder)
{
    auto highlight = decoder.decode<Ref<WebCore::FragmentedSharedBuffer>>();
    auto text = decoder.decode<std::optional<String>>();
    auto isNewGroup = decoder.decode<WebCore::CreateNewGroupForHighlight>();
    auto requestOriginatedInApp = decoder.decode<WebCore::HighlightRequestOriginatedInApp>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::AppHighlight {
            WTFMove(*highlight),
            WTFMove(*text),
            WTFMove(*isNewGroup),
            WTFMove(*requestOriginatedInApp)
        }
    };
}

#endif

void ArgumentCoder<WebCore::MediaDeviceHashSalts>::encode(Encoder& encoder, const WebCore::MediaDeviceHashSalts& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.persistentDeviceSalt)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ephemeralDeviceSalt)>, String>);
    struct ShouldBeSameSizeAsMediaDeviceHashSalts : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MediaDeviceHashSalts>, false> {
        String persistentDeviceSalt;
        String ephemeralDeviceSalt;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMediaDeviceHashSalts) == sizeof(WebCore::MediaDeviceHashSalts));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MediaDeviceHashSalts, persistentDeviceSalt)
        , offsetof(WebCore::MediaDeviceHashSalts, ephemeralDeviceSalt)
    >::value);

    encoder << instance.persistentDeviceSalt;
    encoder << instance.ephemeralDeviceSalt;
}

std::optional<WebCore::MediaDeviceHashSalts> ArgumentCoder<WebCore::MediaDeviceHashSalts>::decode(Decoder& decoder)
{
    auto persistentDeviceSalt = decoder.decode<String>();
    auto ephemeralDeviceSalt = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MediaDeviceHashSalts {
            WTFMove(*persistentDeviceSalt),
            WTFMove(*ephemeralDeviceSalt)
        }
    };
}

void ArgumentCoder<WebCore::SpeechRecognitionUpdate>::encode(Encoder& encoder, const WebCore::SpeechRecognitionUpdate& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_clientIdentifier)>, WebCore::SpeechRecognitionConnectionClientIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_type)>, WebCore::SpeechRecognitionUpdateType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_content)>, Variant<std::monostate, WebCore::SpeechRecognitionError, Vector<WebCore::SpeechRecognitionResultData>>>);
    struct ShouldBeSameSizeAsSpeechRecognitionUpdate : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SpeechRecognitionUpdate>, false> {
        WebCore::SpeechRecognitionConnectionClientIdentifier m_clientIdentifier;
        WebCore::SpeechRecognitionUpdateType m_type;
        Variant<std::monostate, WebCore::SpeechRecognitionError, Vector<WebCore::SpeechRecognitionResultData>> m_content;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSpeechRecognitionUpdate) == sizeof(WebCore::SpeechRecognitionUpdate));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SpeechRecognitionUpdate, m_clientIdentifier)
        , offsetof(WebCore::SpeechRecognitionUpdate, m_type)
        , offsetof(WebCore::SpeechRecognitionUpdate, m_content)
    >::value);

    encoder << instance.m_clientIdentifier;
    encoder << instance.m_type;
    encoder << instance.m_content;
}

std::optional<WebCore::SpeechRecognitionUpdate> ArgumentCoder<WebCore::SpeechRecognitionUpdate>::decode(Decoder& decoder)
{
    auto m_clientIdentifier = decoder.decode<WebCore::SpeechRecognitionConnectionClientIdentifier>();
    auto m_type = decoder.decode<WebCore::SpeechRecognitionUpdateType>();
    auto m_content = decoder.decode<Variant<std::monostate, WebCore::SpeechRecognitionError, Vector<WebCore::SpeechRecognitionResultData>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SpeechRecognitionUpdate {
            WTFMove(*m_clientIdentifier),
            WTFMove(*m_type),
            WTFMove(*m_content)
        }
    };
}

#if USE(SYSTEM_PREVIEW)
void ArgumentCoder<WebCore::ARKitBadgeSystemImage>::encode(Encoder& encoder, const WebCore::ARKitBadgeSystemImage& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.imageIdentifier())>, WebCore::RenderingResourceIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_imageSize)>, WebCore::FloatSize>);

    encoder << instance.imageIdentifier();
    encoder << instance.m_imageSize;
}

void ArgumentCoder<WebCore::ARKitBadgeSystemImage>::encode(StreamConnectionEncoder& encoder, const WebCore::ARKitBadgeSystemImage& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.imageIdentifier())>, WebCore::RenderingResourceIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_imageSize)>, WebCore::FloatSize>);

    encoder << instance.imageIdentifier();
    encoder << instance.m_imageSize;
}

std::optional<Ref<WebCore::ARKitBadgeSystemImage>> ArgumentCoder<WebCore::ARKitBadgeSystemImage>::decode(Decoder& decoder)
{
    auto imageIdentifier = decoder.decode<WebCore::RenderingResourceIdentifier>();
    auto m_imageSize = decoder.decode<WebCore::FloatSize>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ARKitBadgeSystemImage::create(
            WTFMove(*imageIdentifier),
            WTFMove(*m_imageSize)
        )
    };
}

#endif

void ArgumentCoder<WebCore::AudioIOPosition>::encode(Encoder& encoder, const WebCore::AudioIOPosition& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.position)>, Seconds>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timestamp)>, MonotonicTime>);
    struct ShouldBeSameSizeAsAudioIOPosition : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::AudioIOPosition>, false> {
        Seconds position;
        MonotonicTime timestamp;
    };
    static_assert(sizeof(ShouldBeSameSizeAsAudioIOPosition) == sizeof(WebCore::AudioIOPosition));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::AudioIOPosition, position)
        , offsetof(WebCore::AudioIOPosition, timestamp)
    >::value);

    encoder << instance.position;
    encoder << instance.timestamp;
}

std::optional<WebCore::AudioIOPosition> ArgumentCoder<WebCore::AudioIOPosition>::decode(Decoder& decoder)
{
    auto position = decoder.decode<Seconds>();
    auto timestamp = decoder.decode<MonotonicTime>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::AudioIOPosition {
            WTFMove(*position),
            WTFMove(*timestamp)
        }
    };
}

#if ENABLE(VIDEO) && USE(AVFOUNDATION)
void ArgumentCoder<WebCore::VideoFrameCV>::encode(Encoder& encoder, const WebCore::VideoFrameCV& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.presentationTime())>, MediaTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isMirrored())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rotation())>, WebCore::VideoFrameRotation>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_pixelBuffer)>, RetainPtr<CVPixelBufferRef>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorSpace())>, WebCore::PlatformVideoColorSpace>);

    encoder << instance.presentationTime();
    encoder << instance.isMirrored();
    encoder << instance.rotation();
    encoder << instance.m_pixelBuffer;
    encoder << instance.colorSpace();
}

std::optional<Ref<WebCore::VideoFrameCV>> ArgumentCoder<WebCore::VideoFrameCV>::decode(Decoder& decoder)
{
    auto presentationTime = decoder.decode<MediaTime>();
    auto isMirrored = decoder.decode<bool>();
    auto rotation = decoder.decode<WebCore::VideoFrameRotation>();
    auto m_pixelBuffer = decoder.decode<RetainPtr<CVPixelBufferRef>>();
    auto colorSpace = decoder.decode<WebCore::PlatformVideoColorSpace>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::VideoFrameCV::create(
            WTFMove(*presentationTime),
            WTFMove(*isMirrored),
            WTFMove(*rotation),
            WTFMove(*m_pixelBuffer),
            WTFMove(*colorSpace)
        )
    };
}

#endif

void ArgumentCoder<WebCore::GradientColorStop>::encode(Encoder& encoder, const WebCore::GradientColorStop& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.color)>, WebCore::Color>);
    struct ShouldBeSameSizeAsGradientColorStop : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::GradientColorStop>, false> {
        float offset;
        WebCore::Color color;
    };
    static_assert(sizeof(ShouldBeSameSizeAsGradientColorStop) == sizeof(WebCore::GradientColorStop));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::GradientColorStop, offset)
        , offsetof(WebCore::GradientColorStop, color)
    >::value);

    encoder << instance.offset;
    encoder << instance.color;
}

void ArgumentCoder<WebCore::GradientColorStop>::encode(StreamConnectionEncoder& encoder, const WebCore::GradientColorStop& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.color)>, WebCore::Color>);
    struct ShouldBeSameSizeAsGradientColorStop : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::GradientColorStop>, false> {
        float offset;
        WebCore::Color color;
    };
    static_assert(sizeof(ShouldBeSameSizeAsGradientColorStop) == sizeof(WebCore::GradientColorStop));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::GradientColorStop, offset)
        , offsetof(WebCore::GradientColorStop, color)
    >::value);

    encoder << instance.offset;
    encoder << instance.color;
}

std::optional<WebCore::GradientColorStop> ArgumentCoder<WebCore::GradientColorStop>::decode(Decoder& decoder)
{
    auto offset = decoder.decode<float>();
    auto color = decoder.decode<WebCore::Color>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::GradientColorStop {
            WTFMove(*offset),
            WTFMove(*color)
        }
    };
}

void ArgumentCoder<WebCore::GradientColorStops>::encode(Encoder& encoder, const WebCore::GradientColorStops& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stops())>, Vector<WebCore::GradientColorStop, 2>>);

    encoder << instance.stops();
}

void ArgumentCoder<WebCore::GradientColorStops>::encode(StreamConnectionEncoder& encoder, const WebCore::GradientColorStops& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stops())>, Vector<WebCore::GradientColorStop, 2>>);

    encoder << instance.stops();
}

std::optional<WebCore::GradientColorStops> ArgumentCoder<WebCore::GradientColorStops>::decode(Decoder& decoder)
{
    auto stops = decoder.decode<Vector<WebCore::GradientColorStop, 2>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::GradientColorStops {
            WTFMove(*stops)
        }
    };
}

void ArgumentCoder<WebCore::ImageBufferParameters>::encode(Encoder& encoder, const WebCore::ImageBufferParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.logicalSize)>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.resolutionScale)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorSpace)>, WebCore::DestinationColorSpace>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bufferFormat)>, WebCore::ImageBufferFormat>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.purpose)>, WebCore::RenderingPurpose>);
    struct ShouldBeSameSizeAsImageBufferParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ImageBufferParameters>, false> {
        WebCore::FloatSize logicalSize;
        float resolutionScale;
        WebCore::DestinationColorSpace colorSpace;
        WebCore::ImageBufferFormat bufferFormat;
        WebCore::RenderingPurpose purpose;
    };
    static_assert(sizeof(ShouldBeSameSizeAsImageBufferParameters) == sizeof(WebCore::ImageBufferParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ImageBufferParameters, logicalSize)
        , offsetof(WebCore::ImageBufferParameters, resolutionScale)
        , offsetof(WebCore::ImageBufferParameters, colorSpace)
        , offsetof(WebCore::ImageBufferParameters, bufferFormat)
        , offsetof(WebCore::ImageBufferParameters, purpose)
    >::value);

    encoder << instance.logicalSize;
    encoder << instance.resolutionScale;
    encoder << instance.colorSpace;
    encoder << instance.bufferFormat;
    encoder << instance.purpose;
}

std::optional<WebCore::ImageBufferParameters> ArgumentCoder<WebCore::ImageBufferParameters>::decode(Decoder& decoder)
{
    auto logicalSize = decoder.decode<WebCore::FloatSize>();
    auto resolutionScale = decoder.decode<float>();
    auto colorSpace = decoder.decode<WebCore::DestinationColorSpace>();
    auto bufferFormat = decoder.decode<WebCore::ImageBufferFormat>();
    auto purpose = decoder.decode<WebCore::RenderingPurpose>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ImageBufferParameters {
            WTFMove(*logicalSize),
            WTFMove(*resolutionScale),
            WTFMove(*colorSpace),
            WTFMove(*bufferFormat),
            WTFMove(*purpose)
        }
    };
}

void ArgumentCoder<WebCore::ProcessIdentity>::encode(Encoder& encoder, WebCore::ProcessIdentity&& instance)
{
#if HAVE(TASK_IDENTITY_TOKEN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_taskIdToken)>, MachSendRight>);
#endif
    struct ShouldBeSameSizeAsProcessIdentity : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ProcessIdentity>, false> {
#if HAVE(TASK_IDENTITY_TOKEN)
        MachSendRight m_taskIdToken;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsProcessIdentity) == sizeof(WebCore::ProcessIdentity));
    static_assert(MembersInCorrectOrder < 0
#if HAVE(TASK_IDENTITY_TOKEN)
        , offsetof(WebCore::ProcessIdentity, m_taskIdToken)
#endif
    >::value);

#if HAVE(TASK_IDENTITY_TOKEN)
    encoder << WTFMove(instance.m_taskIdToken);
#endif
}

std::optional<WebCore::ProcessIdentity> ArgumentCoder<WebCore::ProcessIdentity>::decode(Decoder& decoder)
{
#if HAVE(TASK_IDENTITY_TOKEN)
    auto m_taskIdToken = decoder.decode<MachSendRight>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ProcessIdentity {
#if HAVE(TASK_IDENTITY_TOKEN)
            WTFMove(*m_taskIdToken)
#endif
        }
    };
}

void ArgumentCoder<WebCore::ColorInterpolationMethod::HSL>::encode(Encoder& encoder, const WebCore::ColorInterpolationMethod::HSL& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hueInterpolationMethod)>, WebCore::HueInterpolationMethod>);
    struct ShouldBeSameSizeAsHSL : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ColorInterpolationMethod::HSL>, false> {
        WebCore::HueInterpolationMethod hueInterpolationMethod;
    };
    static_assert(sizeof(ShouldBeSameSizeAsHSL) == sizeof(WebCore::ColorInterpolationMethod::HSL));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ColorInterpolationMethod::HSL, hueInterpolationMethod)
    >::value);

    encoder << instance.hueInterpolationMethod;
}

void ArgumentCoder<WebCore::ColorInterpolationMethod::HSL>::encode(StreamConnectionEncoder& encoder, const WebCore::ColorInterpolationMethod::HSL& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hueInterpolationMethod)>, WebCore::HueInterpolationMethod>);
    struct ShouldBeSameSizeAsHSL : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ColorInterpolationMethod::HSL>, false> {
        WebCore::HueInterpolationMethod hueInterpolationMethod;
    };
    static_assert(sizeof(ShouldBeSameSizeAsHSL) == sizeof(WebCore::ColorInterpolationMethod::HSL));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ColorInterpolationMethod::HSL, hueInterpolationMethod)
    >::value);

    encoder << instance.hueInterpolationMethod;
}

std::optional<WebCore::ColorInterpolationMethod::HSL> ArgumentCoder<WebCore::ColorInterpolationMethod::HSL>::decode(Decoder& decoder)
{
    auto hueInterpolationMethod = decoder.decode<WebCore::HueInterpolationMethod>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ColorInterpolationMethod::HSL {
            WTFMove(*hueInterpolationMethod)
        }
    };
}

void ArgumentCoder<WebCore::ColorInterpolationMethod::HWB>::encode(Encoder& encoder, const WebCore::ColorInterpolationMethod::HWB& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hueInterpolationMethod)>, WebCore::HueInterpolationMethod>);
    struct ShouldBeSameSizeAsHWB : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ColorInterpolationMethod::HWB>, false> {
        WebCore::HueInterpolationMethod hueInterpolationMethod;
    };
    static_assert(sizeof(ShouldBeSameSizeAsHWB) == sizeof(WebCore::ColorInterpolationMethod::HWB));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ColorInterpolationMethod::HWB, hueInterpolationMethod)
    >::value);

    encoder << instance.hueInterpolationMethod;
}

void ArgumentCoder<WebCore::ColorInterpolationMethod::HWB>::encode(StreamConnectionEncoder& encoder, const WebCore::ColorInterpolationMethod::HWB& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hueInterpolationMethod)>, WebCore::HueInterpolationMethod>);
    struct ShouldBeSameSizeAsHWB : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ColorInterpolationMethod::HWB>, false> {
        WebCore::HueInterpolationMethod hueInterpolationMethod;
    };
    static_assert(sizeof(ShouldBeSameSizeAsHWB) == sizeof(WebCore::ColorInterpolationMethod::HWB));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ColorInterpolationMethod::HWB, hueInterpolationMethod)
    >::value);

    encoder << instance.hueInterpolationMethod;
}

std::optional<WebCore::ColorInterpolationMethod::HWB> ArgumentCoder<WebCore::ColorInterpolationMethod::HWB>::decode(Decoder& decoder)
{
    auto hueInterpolationMethod = decoder.decode<WebCore::HueInterpolationMethod>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ColorInterpolationMethod::HWB {
            WTFMove(*hueInterpolationMethod)
        }
    };
}

void ArgumentCoder<WebCore::ColorInterpolationMethod::LCH>::encode(Encoder& encoder, const WebCore::ColorInterpolationMethod::LCH& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hueInterpolationMethod)>, WebCore::HueInterpolationMethod>);
    struct ShouldBeSameSizeAsLCH : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ColorInterpolationMethod::LCH>, false> {
        WebCore::HueInterpolationMethod hueInterpolationMethod;
    };
    static_assert(sizeof(ShouldBeSameSizeAsLCH) == sizeof(WebCore::ColorInterpolationMethod::LCH));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ColorInterpolationMethod::LCH, hueInterpolationMethod)
    >::value);

    encoder << instance.hueInterpolationMethod;
}

void ArgumentCoder<WebCore::ColorInterpolationMethod::LCH>::encode(StreamConnectionEncoder& encoder, const WebCore::ColorInterpolationMethod::LCH& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hueInterpolationMethod)>, WebCore::HueInterpolationMethod>);
    struct ShouldBeSameSizeAsLCH : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ColorInterpolationMethod::LCH>, false> {
        WebCore::HueInterpolationMethod hueInterpolationMethod;
    };
    static_assert(sizeof(ShouldBeSameSizeAsLCH) == sizeof(WebCore::ColorInterpolationMethod::LCH));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ColorInterpolationMethod::LCH, hueInterpolationMethod)
    >::value);

    encoder << instance.hueInterpolationMethod;
}

std::optional<WebCore::ColorInterpolationMethod::LCH> ArgumentCoder<WebCore::ColorInterpolationMethod::LCH>::decode(Decoder& decoder)
{
    auto hueInterpolationMethod = decoder.decode<WebCore::HueInterpolationMethod>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ColorInterpolationMethod::LCH {
            WTFMove(*hueInterpolationMethod)
        }
    };
}

void ArgumentCoder<WebCore::ColorInterpolationMethod::Lab>::encode(Encoder& encoder, const WebCore::ColorInterpolationMethod::Lab& instance)
{
    struct ShouldBeSameSizeAsLab : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ColorInterpolationMethod::Lab>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsLab) == sizeof(WebCore::ColorInterpolationMethod::Lab));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

void ArgumentCoder<WebCore::ColorInterpolationMethod::Lab>::encode(StreamConnectionEncoder& encoder, const WebCore::ColorInterpolationMethod::Lab& instance)
{
    struct ShouldBeSameSizeAsLab : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ColorInterpolationMethod::Lab>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsLab) == sizeof(WebCore::ColorInterpolationMethod::Lab));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::ColorInterpolationMethod::Lab> ArgumentCoder<WebCore::ColorInterpolationMethod::Lab>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ColorInterpolationMethod::Lab {
        }
    };
}

void ArgumentCoder<WebCore::ColorInterpolationMethod::OKLCH>::encode(Encoder& encoder, const WebCore::ColorInterpolationMethod::OKLCH& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hueInterpolationMethod)>, WebCore::HueInterpolationMethod>);
    struct ShouldBeSameSizeAsOKLCH : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ColorInterpolationMethod::OKLCH>, false> {
        WebCore::HueInterpolationMethod hueInterpolationMethod;
    };
    static_assert(sizeof(ShouldBeSameSizeAsOKLCH) == sizeof(WebCore::ColorInterpolationMethod::OKLCH));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ColorInterpolationMethod::OKLCH, hueInterpolationMethod)
    >::value);

    encoder << instance.hueInterpolationMethod;
}

void ArgumentCoder<WebCore::ColorInterpolationMethod::OKLCH>::encode(StreamConnectionEncoder& encoder, const WebCore::ColorInterpolationMethod::OKLCH& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hueInterpolationMethod)>, WebCore::HueInterpolationMethod>);
    struct ShouldBeSameSizeAsOKLCH : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ColorInterpolationMethod::OKLCH>, false> {
        WebCore::HueInterpolationMethod hueInterpolationMethod;
    };
    static_assert(sizeof(ShouldBeSameSizeAsOKLCH) == sizeof(WebCore::ColorInterpolationMethod::OKLCH));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ColorInterpolationMethod::OKLCH, hueInterpolationMethod)
    >::value);

    encoder << instance.hueInterpolationMethod;
}

std::optional<WebCore::ColorInterpolationMethod::OKLCH> ArgumentCoder<WebCore::ColorInterpolationMethod::OKLCH>::decode(Decoder& decoder)
{
    auto hueInterpolationMethod = decoder.decode<WebCore::HueInterpolationMethod>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ColorInterpolationMethod::OKLCH {
            WTFMove(*hueInterpolationMethod)
        }
    };
}

void ArgumentCoder<WebCore::ColorInterpolationMethod::OKLab>::encode(Encoder& encoder, const WebCore::ColorInterpolationMethod::OKLab& instance)
{
    struct ShouldBeSameSizeAsOKLab : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ColorInterpolationMethod::OKLab>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsOKLab) == sizeof(WebCore::ColorInterpolationMethod::OKLab));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

void ArgumentCoder<WebCore::ColorInterpolationMethod::OKLab>::encode(StreamConnectionEncoder& encoder, const WebCore::ColorInterpolationMethod::OKLab& instance)
{
    struct ShouldBeSameSizeAsOKLab : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ColorInterpolationMethod::OKLab>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsOKLab) == sizeof(WebCore::ColorInterpolationMethod::OKLab));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::ColorInterpolationMethod::OKLab> ArgumentCoder<WebCore::ColorInterpolationMethod::OKLab>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ColorInterpolationMethod::OKLab {
        }
    };
}

void ArgumentCoder<WebCore::ColorInterpolationMethod::SRGB>::encode(Encoder& encoder, const WebCore::ColorInterpolationMethod::SRGB& instance)
{
    struct ShouldBeSameSizeAsSRGB : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ColorInterpolationMethod::SRGB>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsSRGB) == sizeof(WebCore::ColorInterpolationMethod::SRGB));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

void ArgumentCoder<WebCore::ColorInterpolationMethod::SRGB>::encode(StreamConnectionEncoder& encoder, const WebCore::ColorInterpolationMethod::SRGB& instance)
{
    struct ShouldBeSameSizeAsSRGB : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ColorInterpolationMethod::SRGB>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsSRGB) == sizeof(WebCore::ColorInterpolationMethod::SRGB));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::ColorInterpolationMethod::SRGB> ArgumentCoder<WebCore::ColorInterpolationMethod::SRGB>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ColorInterpolationMethod::SRGB {
        }
    };
}

void ArgumentCoder<WebCore::ColorInterpolationMethod::SRGBLinear>::encode(Encoder& encoder, const WebCore::ColorInterpolationMethod::SRGBLinear& instance)
{
    struct ShouldBeSameSizeAsSRGBLinear : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ColorInterpolationMethod::SRGBLinear>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsSRGBLinear) == sizeof(WebCore::ColorInterpolationMethod::SRGBLinear));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

void ArgumentCoder<WebCore::ColorInterpolationMethod::SRGBLinear>::encode(StreamConnectionEncoder& encoder, const WebCore::ColorInterpolationMethod::SRGBLinear& instance)
{
    struct ShouldBeSameSizeAsSRGBLinear : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ColorInterpolationMethod::SRGBLinear>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsSRGBLinear) == sizeof(WebCore::ColorInterpolationMethod::SRGBLinear));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::ColorInterpolationMethod::SRGBLinear> ArgumentCoder<WebCore::ColorInterpolationMethod::SRGBLinear>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ColorInterpolationMethod::SRGBLinear {
        }
    };
}

void ArgumentCoder<WebCore::ColorInterpolationMethod::DisplayP3>::encode(Encoder& encoder, const WebCore::ColorInterpolationMethod::DisplayP3& instance)
{
    struct ShouldBeSameSizeAsDisplayP3 : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ColorInterpolationMethod::DisplayP3>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsDisplayP3) == sizeof(WebCore::ColorInterpolationMethod::DisplayP3));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

void ArgumentCoder<WebCore::ColorInterpolationMethod::DisplayP3>::encode(StreamConnectionEncoder& encoder, const WebCore::ColorInterpolationMethod::DisplayP3& instance)
{
    struct ShouldBeSameSizeAsDisplayP3 : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ColorInterpolationMethod::DisplayP3>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsDisplayP3) == sizeof(WebCore::ColorInterpolationMethod::DisplayP3));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::ColorInterpolationMethod::DisplayP3> ArgumentCoder<WebCore::ColorInterpolationMethod::DisplayP3>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ColorInterpolationMethod::DisplayP3 {
        }
    };
}

void ArgumentCoder<WebCore::ColorInterpolationMethod::A98RGB>::encode(Encoder& encoder, const WebCore::ColorInterpolationMethod::A98RGB& instance)
{
    struct ShouldBeSameSizeAsA98RGB : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ColorInterpolationMethod::A98RGB>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsA98RGB) == sizeof(WebCore::ColorInterpolationMethod::A98RGB));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

void ArgumentCoder<WebCore::ColorInterpolationMethod::A98RGB>::encode(StreamConnectionEncoder& encoder, const WebCore::ColorInterpolationMethod::A98RGB& instance)
{
    struct ShouldBeSameSizeAsA98RGB : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ColorInterpolationMethod::A98RGB>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsA98RGB) == sizeof(WebCore::ColorInterpolationMethod::A98RGB));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::ColorInterpolationMethod::A98RGB> ArgumentCoder<WebCore::ColorInterpolationMethod::A98RGB>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ColorInterpolationMethod::A98RGB {
        }
    };
}

void ArgumentCoder<WebCore::ColorInterpolationMethod::ProPhotoRGB>::encode(Encoder& encoder, const WebCore::ColorInterpolationMethod::ProPhotoRGB& instance)
{
    struct ShouldBeSameSizeAsProPhotoRGB : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ColorInterpolationMethod::ProPhotoRGB>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsProPhotoRGB) == sizeof(WebCore::ColorInterpolationMethod::ProPhotoRGB));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

void ArgumentCoder<WebCore::ColorInterpolationMethod::ProPhotoRGB>::encode(StreamConnectionEncoder& encoder, const WebCore::ColorInterpolationMethod::ProPhotoRGB& instance)
{
    struct ShouldBeSameSizeAsProPhotoRGB : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ColorInterpolationMethod::ProPhotoRGB>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsProPhotoRGB) == sizeof(WebCore::ColorInterpolationMethod::ProPhotoRGB));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::ColorInterpolationMethod::ProPhotoRGB> ArgumentCoder<WebCore::ColorInterpolationMethod::ProPhotoRGB>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ColorInterpolationMethod::ProPhotoRGB {
        }
    };
}

void ArgumentCoder<WebCore::ColorInterpolationMethod::Rec2020>::encode(Encoder& encoder, const WebCore::ColorInterpolationMethod::Rec2020& instance)
{
    struct ShouldBeSameSizeAsRec2020 : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ColorInterpolationMethod::Rec2020>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsRec2020) == sizeof(WebCore::ColorInterpolationMethod::Rec2020));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

void ArgumentCoder<WebCore::ColorInterpolationMethod::Rec2020>::encode(StreamConnectionEncoder& encoder, const WebCore::ColorInterpolationMethod::Rec2020& instance)
{
    struct ShouldBeSameSizeAsRec2020 : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ColorInterpolationMethod::Rec2020>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsRec2020) == sizeof(WebCore::ColorInterpolationMethod::Rec2020));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::ColorInterpolationMethod::Rec2020> ArgumentCoder<WebCore::ColorInterpolationMethod::Rec2020>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ColorInterpolationMethod::Rec2020 {
        }
    };
}

void ArgumentCoder<WebCore::ColorInterpolationMethod::XYZD50>::encode(Encoder& encoder, const WebCore::ColorInterpolationMethod::XYZD50& instance)
{
    struct ShouldBeSameSizeAsXYZD50 : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ColorInterpolationMethod::XYZD50>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsXYZD50) == sizeof(WebCore::ColorInterpolationMethod::XYZD50));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

void ArgumentCoder<WebCore::ColorInterpolationMethod::XYZD50>::encode(StreamConnectionEncoder& encoder, const WebCore::ColorInterpolationMethod::XYZD50& instance)
{
    struct ShouldBeSameSizeAsXYZD50 : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ColorInterpolationMethod::XYZD50>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsXYZD50) == sizeof(WebCore::ColorInterpolationMethod::XYZD50));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::ColorInterpolationMethod::XYZD50> ArgumentCoder<WebCore::ColorInterpolationMethod::XYZD50>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ColorInterpolationMethod::XYZD50 {
        }
    };
}

void ArgumentCoder<WebCore::ColorInterpolationMethod::XYZD65>::encode(Encoder& encoder, const WebCore::ColorInterpolationMethod::XYZD65& instance)
{
    struct ShouldBeSameSizeAsXYZD65 : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ColorInterpolationMethod::XYZD65>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsXYZD65) == sizeof(WebCore::ColorInterpolationMethod::XYZD65));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

void ArgumentCoder<WebCore::ColorInterpolationMethod::XYZD65>::encode(StreamConnectionEncoder& encoder, const WebCore::ColorInterpolationMethod::XYZD65& instance)
{
    struct ShouldBeSameSizeAsXYZD65 : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ColorInterpolationMethod::XYZD65>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsXYZD65) == sizeof(WebCore::ColorInterpolationMethod::XYZD65));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::ColorInterpolationMethod::XYZD65> ArgumentCoder<WebCore::ColorInterpolationMethod::XYZD65>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ColorInterpolationMethod::XYZD65 {
        }
    };
}

void ArgumentCoder<WebCore::ColorInterpolationMethod>::encode(Encoder& encoder, const WebCore::ColorInterpolationMethod& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorSpace)>, Variant<WebCore::ColorInterpolationMethod::HSL, WebCore::ColorInterpolationMethod::HWB, WebCore::ColorInterpolationMethod::LCH, WebCore::ColorInterpolationMethod::Lab, WebCore::ColorInterpolationMethod::OKLCH, WebCore::ColorInterpolationMethod::OKLab, WebCore::ColorInterpolationMethod::SRGB, WebCore::ColorInterpolationMethod::SRGBLinear, WebCore::ColorInterpolationMethod::DisplayP3, WebCore::ColorInterpolationMethod::A98RGB, WebCore::ColorInterpolationMethod::ProPhotoRGB, WebCore::ColorInterpolationMethod::Rec2020, WebCore::ColorInterpolationMethod::XYZD50, WebCore::ColorInterpolationMethod::XYZD65>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.alphaPremultiplication)>, WebCore::AlphaPremultiplication>);
    struct ShouldBeSameSizeAsColorInterpolationMethod : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ColorInterpolationMethod>, false> {
        Variant<WebCore::ColorInterpolationMethod::HSL, WebCore::ColorInterpolationMethod::HWB, WebCore::ColorInterpolationMethod::LCH, WebCore::ColorInterpolationMethod::Lab, WebCore::ColorInterpolationMethod::OKLCH, WebCore::ColorInterpolationMethod::OKLab, WebCore::ColorInterpolationMethod::SRGB, WebCore::ColorInterpolationMethod::SRGBLinear, WebCore::ColorInterpolationMethod::DisplayP3, WebCore::ColorInterpolationMethod::A98RGB, WebCore::ColorInterpolationMethod::ProPhotoRGB, WebCore::ColorInterpolationMethod::Rec2020, WebCore::ColorInterpolationMethod::XYZD50, WebCore::ColorInterpolationMethod::XYZD65> colorSpace;
        WebCore::AlphaPremultiplication alphaPremultiplication;
    };
    static_assert(sizeof(ShouldBeSameSizeAsColorInterpolationMethod) == sizeof(WebCore::ColorInterpolationMethod));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ColorInterpolationMethod, colorSpace)
        , offsetof(WebCore::ColorInterpolationMethod, alphaPremultiplication)
    >::value);

    encoder << instance.colorSpace;
    encoder << instance.alphaPremultiplication;
}

void ArgumentCoder<WebCore::ColorInterpolationMethod>::encode(StreamConnectionEncoder& encoder, const WebCore::ColorInterpolationMethod& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorSpace)>, Variant<WebCore::ColorInterpolationMethod::HSL, WebCore::ColorInterpolationMethod::HWB, WebCore::ColorInterpolationMethod::LCH, WebCore::ColorInterpolationMethod::Lab, WebCore::ColorInterpolationMethod::OKLCH, WebCore::ColorInterpolationMethod::OKLab, WebCore::ColorInterpolationMethod::SRGB, WebCore::ColorInterpolationMethod::SRGBLinear, WebCore::ColorInterpolationMethod::DisplayP3, WebCore::ColorInterpolationMethod::A98RGB, WebCore::ColorInterpolationMethod::ProPhotoRGB, WebCore::ColorInterpolationMethod::Rec2020, WebCore::ColorInterpolationMethod::XYZD50, WebCore::ColorInterpolationMethod::XYZD65>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.alphaPremultiplication)>, WebCore::AlphaPremultiplication>);
    struct ShouldBeSameSizeAsColorInterpolationMethod : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ColorInterpolationMethod>, false> {
        Variant<WebCore::ColorInterpolationMethod::HSL, WebCore::ColorInterpolationMethod::HWB, WebCore::ColorInterpolationMethod::LCH, WebCore::ColorInterpolationMethod::Lab, WebCore::ColorInterpolationMethod::OKLCH, WebCore::ColorInterpolationMethod::OKLab, WebCore::ColorInterpolationMethod::SRGB, WebCore::ColorInterpolationMethod::SRGBLinear, WebCore::ColorInterpolationMethod::DisplayP3, WebCore::ColorInterpolationMethod::A98RGB, WebCore::ColorInterpolationMethod::ProPhotoRGB, WebCore::ColorInterpolationMethod::Rec2020, WebCore::ColorInterpolationMethod::XYZD50, WebCore::ColorInterpolationMethod::XYZD65> colorSpace;
        WebCore::AlphaPremultiplication alphaPremultiplication;
    };
    static_assert(sizeof(ShouldBeSameSizeAsColorInterpolationMethod) == sizeof(WebCore::ColorInterpolationMethod));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ColorInterpolationMethod, colorSpace)
        , offsetof(WebCore::ColorInterpolationMethod, alphaPremultiplication)
    >::value);

    encoder << instance.colorSpace;
    encoder << instance.alphaPremultiplication;
}

std::optional<WebCore::ColorInterpolationMethod> ArgumentCoder<WebCore::ColorInterpolationMethod>::decode(Decoder& decoder)
{
    auto colorSpace = decoder.decode<Variant<WebCore::ColorInterpolationMethod::HSL, WebCore::ColorInterpolationMethod::HWB, WebCore::ColorInterpolationMethod::LCH, WebCore::ColorInterpolationMethod::Lab, WebCore::ColorInterpolationMethod::OKLCH, WebCore::ColorInterpolationMethod::OKLab, WebCore::ColorInterpolationMethod::SRGB, WebCore::ColorInterpolationMethod::SRGBLinear, WebCore::ColorInterpolationMethod::DisplayP3, WebCore::ColorInterpolationMethod::A98RGB, WebCore::ColorInterpolationMethod::ProPhotoRGB, WebCore::ColorInterpolationMethod::Rec2020, WebCore::ColorInterpolationMethod::XYZD50, WebCore::ColorInterpolationMethod::XYZD65>>();
    auto alphaPremultiplication = decoder.decode<WebCore::AlphaPremultiplication>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ColorInterpolationMethod {
            WTFMove(*colorSpace),
            WTFMove(*alphaPremultiplication)
        }
    };
}

void ArgumentCoder<WebCore::CompositeMode>::encode(Encoder& encoder, const WebCore::CompositeMode& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operation)>, WebCore::CompositeOperator>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.blendMode)>, WebCore::BlendMode>);
    struct ShouldBeSameSizeAsCompositeMode : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::CompositeMode>, false> {
        WebCore::CompositeOperator operation;
        WebCore::BlendMode blendMode;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCompositeMode) == sizeof(WebCore::CompositeMode));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::CompositeMode, operation)
        , offsetof(WebCore::CompositeMode, blendMode)
    >::value);

    encoder << instance.operation;
    encoder << instance.blendMode;
}

void ArgumentCoder<WebCore::CompositeMode>::encode(StreamConnectionEncoder& encoder, const WebCore::CompositeMode& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operation)>, WebCore::CompositeOperator>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.blendMode)>, WebCore::BlendMode>);
    struct ShouldBeSameSizeAsCompositeMode : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::CompositeMode>, false> {
        WebCore::CompositeOperator operation;
        WebCore::BlendMode blendMode;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCompositeMode) == sizeof(WebCore::CompositeMode));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::CompositeMode, operation)
        , offsetof(WebCore::CompositeMode, blendMode)
    >::value);

    encoder << instance.operation;
    encoder << instance.blendMode;
}

std::optional<WebCore::CompositeMode> ArgumentCoder<WebCore::CompositeMode>::decode(Decoder& decoder)
{
    auto operation = decoder.decode<WebCore::CompositeOperator>();
    auto blendMode = decoder.decode<WebCore::BlendMode>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CompositeMode {
            WTFMove(*operation),
            WTFMove(*blendMode)
        }
    };
}

void ArgumentCoder<WebCore::DocumentMarkerLineStyle>::encode(Encoder& encoder, const WebCore::DocumentMarkerLineStyle& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mode)>, WebCore::DocumentMarkerLineStyleMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.color)>, WebCore::Color>);
    struct ShouldBeSameSizeAsDocumentMarkerLineStyle : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::DocumentMarkerLineStyle>, false> {
        WebCore::DocumentMarkerLineStyleMode mode;
        WebCore::Color color;
    };
    static_assert(sizeof(ShouldBeSameSizeAsDocumentMarkerLineStyle) == sizeof(WebCore::DocumentMarkerLineStyle));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::DocumentMarkerLineStyle, mode)
        , offsetof(WebCore::DocumentMarkerLineStyle, color)
    >::value);

    encoder << instance.mode;
    encoder << instance.color;
}

void ArgumentCoder<WebCore::DocumentMarkerLineStyle>::encode(StreamConnectionEncoder& encoder, const WebCore::DocumentMarkerLineStyle& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mode)>, WebCore::DocumentMarkerLineStyleMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.color)>, WebCore::Color>);
    struct ShouldBeSameSizeAsDocumentMarkerLineStyle : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::DocumentMarkerLineStyle>, false> {
        WebCore::DocumentMarkerLineStyleMode mode;
        WebCore::Color color;
    };
    static_assert(sizeof(ShouldBeSameSizeAsDocumentMarkerLineStyle) == sizeof(WebCore::DocumentMarkerLineStyle));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::DocumentMarkerLineStyle, mode)
        , offsetof(WebCore::DocumentMarkerLineStyle, color)
    >::value);

    encoder << instance.mode;
    encoder << instance.color;
}

std::optional<WebCore::DocumentMarkerLineStyle> ArgumentCoder<WebCore::DocumentMarkerLineStyle>::decode(Decoder& decoder)
{
    auto mode = decoder.decode<WebCore::DocumentMarkerLineStyleMode>();
    auto color = decoder.decode<WebCore::Color>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DocumentMarkerLineStyle {
            WTFMove(*mode),
            WTFMove(*color)
        }
    };
}

void ArgumentCoder<WebCore::GraphicsDropShadow>::encode(Encoder& encoder, const WebCore::GraphicsDropShadow& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radius)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.color)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radiusMode)>, WebCore::ShadowRadiusMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.opacity)>, float>);
    struct ShouldBeSameSizeAsGraphicsDropShadow : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::GraphicsDropShadow>, false> {
        WebCore::FloatSize offset;
        float radius;
        WebCore::Color color;
        WebCore::ShadowRadiusMode radiusMode;
        float opacity;
    };
    static_assert(sizeof(ShouldBeSameSizeAsGraphicsDropShadow) == sizeof(WebCore::GraphicsDropShadow));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::GraphicsDropShadow, offset)
        , offsetof(WebCore::GraphicsDropShadow, radius)
        , offsetof(WebCore::GraphicsDropShadow, color)
        , offsetof(WebCore::GraphicsDropShadow, radiusMode)
        , offsetof(WebCore::GraphicsDropShadow, opacity)
    >::value);

    encoder << instance.offset;
    encoder << instance.radius;
    encoder << instance.color;
    encoder << instance.radiusMode;
    encoder << instance.opacity;
}

void ArgumentCoder<WebCore::GraphicsDropShadow>::encode(StreamConnectionEncoder& encoder, const WebCore::GraphicsDropShadow& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radius)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.color)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radiusMode)>, WebCore::ShadowRadiusMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.opacity)>, float>);
    struct ShouldBeSameSizeAsGraphicsDropShadow : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::GraphicsDropShadow>, false> {
        WebCore::FloatSize offset;
        float radius;
        WebCore::Color color;
        WebCore::ShadowRadiusMode radiusMode;
        float opacity;
    };
    static_assert(sizeof(ShouldBeSameSizeAsGraphicsDropShadow) == sizeof(WebCore::GraphicsDropShadow));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::GraphicsDropShadow, offset)
        , offsetof(WebCore::GraphicsDropShadow, radius)
        , offsetof(WebCore::GraphicsDropShadow, color)
        , offsetof(WebCore::GraphicsDropShadow, radiusMode)
        , offsetof(WebCore::GraphicsDropShadow, opacity)
    >::value);

    encoder << instance.offset;
    encoder << instance.radius;
    encoder << instance.color;
    encoder << instance.radiusMode;
    encoder << instance.opacity;
}

std::optional<WebCore::GraphicsDropShadow> ArgumentCoder<WebCore::GraphicsDropShadow>::decode(Decoder& decoder)
{
    auto offset = decoder.decode<WebCore::FloatSize>();
    auto radius = decoder.decode<float>();
    auto color = decoder.decode<WebCore::Color>();
    auto radiusMode = decoder.decode<WebCore::ShadowRadiusMode>();
    auto opacity = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::GraphicsDropShadow {
            WTFMove(*offset),
            WTFMove(*radius),
            WTFMove(*color),
            WTFMove(*radiusMode),
            WTFMove(*opacity)
        }
    };
}

void ArgumentCoder<WebCore::GraphicsGaussianBlur>::encode(Encoder& encoder, const WebCore::GraphicsGaussianBlur& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radius)>, WebCore::FloatSize>);
    struct ShouldBeSameSizeAsGraphicsGaussianBlur : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::GraphicsGaussianBlur>, false> {
        WebCore::FloatSize radius;
    };
    static_assert(sizeof(ShouldBeSameSizeAsGraphicsGaussianBlur) == sizeof(WebCore::GraphicsGaussianBlur));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::GraphicsGaussianBlur, radius)
    >::value);

    encoder << instance.radius;
}

void ArgumentCoder<WebCore::GraphicsGaussianBlur>::encode(StreamConnectionEncoder& encoder, const WebCore::GraphicsGaussianBlur& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radius)>, WebCore::FloatSize>);
    struct ShouldBeSameSizeAsGraphicsGaussianBlur : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::GraphicsGaussianBlur>, false> {
        WebCore::FloatSize radius;
    };
    static_assert(sizeof(ShouldBeSameSizeAsGraphicsGaussianBlur) == sizeof(WebCore::GraphicsGaussianBlur));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::GraphicsGaussianBlur, radius)
    >::value);

    encoder << instance.radius;
}

std::optional<WebCore::GraphicsGaussianBlur> ArgumentCoder<WebCore::GraphicsGaussianBlur>::decode(Decoder& decoder)
{
    auto radius = decoder.decode<WebCore::FloatSize>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::GraphicsGaussianBlur {
            WTFMove(*radius)
        }
    };
}

void ArgumentCoder<WebCore::GraphicsColorMatrix>::encode(Encoder& encoder, const WebCore::GraphicsColorMatrix& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.values)>, std::array<float, 20>>);
    struct ShouldBeSameSizeAsGraphicsColorMatrix : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::GraphicsColorMatrix>, false> {
        std::array<float, 20> values;
    };
    static_assert(sizeof(ShouldBeSameSizeAsGraphicsColorMatrix) == sizeof(WebCore::GraphicsColorMatrix));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::GraphicsColorMatrix, values)
    >::value);

    encoder << instance.values;
}

void ArgumentCoder<WebCore::GraphicsColorMatrix>::encode(StreamConnectionEncoder& encoder, const WebCore::GraphicsColorMatrix& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.values)>, std::array<float, 20>>);
    struct ShouldBeSameSizeAsGraphicsColorMatrix : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::GraphicsColorMatrix>, false> {
        std::array<float, 20> values;
    };
    static_assert(sizeof(ShouldBeSameSizeAsGraphicsColorMatrix) == sizeof(WebCore::GraphicsColorMatrix));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::GraphicsColorMatrix, values)
    >::value);

    encoder << instance.values;
}

std::optional<WebCore::GraphicsColorMatrix> ArgumentCoder<WebCore::GraphicsColorMatrix>::decode(Decoder& decoder)
{
    auto values = decoder.decode<std::array<float, 20>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::GraphicsColorMatrix {
            WTFMove(*values)
        }
    };
}

void ArgumentCoder<WebCore::PlatformMediaSessionRemoteCommandArgument>::encode(Encoder& encoder, const WebCore::PlatformMediaSessionRemoteCommandArgument& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.time)>, std::optional<double>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fastSeek)>, std::optional<bool>>);
    struct ShouldBeSameSizeAsPlatformMediaSessionRemoteCommandArgument : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PlatformMediaSessionRemoteCommandArgument>, false> {
        std::optional<double> time;
        std::optional<bool> fastSeek;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPlatformMediaSessionRemoteCommandArgument) == sizeof(WebCore::PlatformMediaSessionRemoteCommandArgument));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PlatformMediaSessionRemoteCommandArgument, time)
        , offsetof(WebCore::PlatformMediaSessionRemoteCommandArgument, fastSeek)
    >::value);

    encoder << instance.time;
    encoder << instance.fastSeek;
}

std::optional<WebCore::PlatformMediaSessionRemoteCommandArgument> ArgumentCoder<WebCore::PlatformMediaSessionRemoteCommandArgument>::decode(Decoder& decoder)
{
    auto time = decoder.decode<std::optional<double>>();
    auto fastSeek = decoder.decode<std::optional<bool>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PlatformMediaSessionRemoteCommandArgument {
            WTFMove(*time),
            WTFMove(*fastSeek)
        }
    };
}

void ArgumentCoder<WebCore::SocketStreamError>::encode(Encoder& encoder, const WebCore::SocketStreamError& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_errorCode)>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_failingURL)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_localizedDescription)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_isNull)>, bool>);
    struct ShouldBeSameSizeAsSocketStreamError : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SocketStreamError>, false> {
        int m_errorCode;
        String m_failingURL;
        String m_localizedDescription;
        bool m_isNull;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSocketStreamError) == sizeof(WebCore::SocketStreamError));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SocketStreamError, m_errorCode)
        , offsetof(WebCore::SocketStreamError, m_failingURL)
        , offsetof(WebCore::SocketStreamError, m_localizedDescription)
        , offsetof(WebCore::SocketStreamError, m_isNull)
    >::value);

    encoder << instance.m_errorCode;
    encoder << instance.m_failingURL;
    encoder << instance.m_localizedDescription;
    encoder << instance.m_isNull;
}

std::optional<WebCore::SocketStreamError> ArgumentCoder<WebCore::SocketStreamError>::decode(Decoder& decoder)
{
    auto m_errorCode = decoder.decode<int>();
    auto m_failingURL = decoder.decode<String>();
    auto m_localizedDescription = decoder.decode<String>();
    auto m_isNull = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SocketStreamError {
            WTFMove(*m_errorCode),
            WTFMove(*m_failingURL),
            WTFMove(*m_localizedDescription),
            WTFMove(*m_isNull)
        }
    };
}

#if ENABLE(VIDEO)
void ArgumentCoder<WebCore::GenericCueData>::encode(Encoder& encoder, const WebCore::GenericCueData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_uniqueId)>, Markable<WebCore::InbandGenericCueIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_startTime)>, MediaTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_endTime)>, MediaTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_id)>, AtomString>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_content)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_fontName)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_line)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_position)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_size)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_baseFontSize)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_relativeFontSize)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_foregroundColor)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_backgroundColor)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_highlightColor)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_positionAlign)>, WebCore::GenericCueData::Alignment>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_align)>, WebCore::GenericCueData::Alignment>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_status)>, WebCore::GenericCueData::Status>);
    struct ShouldBeSameSizeAsGenericCueData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::GenericCueData>, false> {
        Markable<WebCore::InbandGenericCueIdentifier> m_uniqueId;
        MediaTime m_startTime;
        MediaTime m_endTime;
        AtomString m_id;
        String m_content;
        String m_fontName;
        double m_line;
        double m_position;
        double m_size;
        double m_baseFontSize;
        double m_relativeFontSize;
        WebCore::Color m_foregroundColor;
        WebCore::Color m_backgroundColor;
        WebCore::Color m_highlightColor;
        WebCore::GenericCueData::Alignment m_positionAlign;
        WebCore::GenericCueData::Alignment m_align;
        WebCore::GenericCueData::Status m_status;
    };
    static_assert(sizeof(ShouldBeSameSizeAsGenericCueData) == sizeof(WebCore::GenericCueData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::GenericCueData, m_uniqueId)
        , offsetof(WebCore::GenericCueData, m_startTime)
        , offsetof(WebCore::GenericCueData, m_endTime)
        , offsetof(WebCore::GenericCueData, m_id)
        , offsetof(WebCore::GenericCueData, m_content)
        , offsetof(WebCore::GenericCueData, m_fontName)
        , offsetof(WebCore::GenericCueData, m_line)
        , offsetof(WebCore::GenericCueData, m_position)
        , offsetof(WebCore::GenericCueData, m_size)
        , offsetof(WebCore::GenericCueData, m_baseFontSize)
        , offsetof(WebCore::GenericCueData, m_relativeFontSize)
        , offsetof(WebCore::GenericCueData, m_foregroundColor)
        , offsetof(WebCore::GenericCueData, m_backgroundColor)
        , offsetof(WebCore::GenericCueData, m_highlightColor)
        , offsetof(WebCore::GenericCueData, m_positionAlign)
        , offsetof(WebCore::GenericCueData, m_align)
        , offsetof(WebCore::GenericCueData, m_status)
    >::value);

    encoder << instance.m_uniqueId;
    encoder << instance.m_startTime;
    encoder << instance.m_endTime;
    encoder << instance.m_id;
    encoder << instance.m_content;
    encoder << instance.m_fontName;
    encoder << instance.m_line;
    encoder << instance.m_position;
    encoder << instance.m_size;
    encoder << instance.m_baseFontSize;
    encoder << instance.m_relativeFontSize;
    encoder << instance.m_foregroundColor;
    encoder << instance.m_backgroundColor;
    encoder << instance.m_highlightColor;
    encoder << instance.m_positionAlign;
    encoder << instance.m_align;
    encoder << instance.m_status;
}

void ArgumentCoder<WebCore::GenericCueData>::encode(StreamConnectionEncoder& encoder, const WebCore::GenericCueData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_uniqueId)>, Markable<WebCore::InbandGenericCueIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_startTime)>, MediaTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_endTime)>, MediaTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_id)>, AtomString>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_content)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_fontName)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_line)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_position)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_size)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_baseFontSize)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_relativeFontSize)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_foregroundColor)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_backgroundColor)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_highlightColor)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_positionAlign)>, WebCore::GenericCueData::Alignment>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_align)>, WebCore::GenericCueData::Alignment>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_status)>, WebCore::GenericCueData::Status>);
    struct ShouldBeSameSizeAsGenericCueData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::GenericCueData>, false> {
        Markable<WebCore::InbandGenericCueIdentifier> m_uniqueId;
        MediaTime m_startTime;
        MediaTime m_endTime;
        AtomString m_id;
        String m_content;
        String m_fontName;
        double m_line;
        double m_position;
        double m_size;
        double m_baseFontSize;
        double m_relativeFontSize;
        WebCore::Color m_foregroundColor;
        WebCore::Color m_backgroundColor;
        WebCore::Color m_highlightColor;
        WebCore::GenericCueData::Alignment m_positionAlign;
        WebCore::GenericCueData::Alignment m_align;
        WebCore::GenericCueData::Status m_status;
    };
    static_assert(sizeof(ShouldBeSameSizeAsGenericCueData) == sizeof(WebCore::GenericCueData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::GenericCueData, m_uniqueId)
        , offsetof(WebCore::GenericCueData, m_startTime)
        , offsetof(WebCore::GenericCueData, m_endTime)
        , offsetof(WebCore::GenericCueData, m_id)
        , offsetof(WebCore::GenericCueData, m_content)
        , offsetof(WebCore::GenericCueData, m_fontName)
        , offsetof(WebCore::GenericCueData, m_line)
        , offsetof(WebCore::GenericCueData, m_position)
        , offsetof(WebCore::GenericCueData, m_size)
        , offsetof(WebCore::GenericCueData, m_baseFontSize)
        , offsetof(WebCore::GenericCueData, m_relativeFontSize)
        , offsetof(WebCore::GenericCueData, m_foregroundColor)
        , offsetof(WebCore::GenericCueData, m_backgroundColor)
        , offsetof(WebCore::GenericCueData, m_highlightColor)
        , offsetof(WebCore::GenericCueData, m_positionAlign)
        , offsetof(WebCore::GenericCueData, m_align)
        , offsetof(WebCore::GenericCueData, m_status)
    >::value);

    encoder << instance.m_uniqueId;
    encoder << instance.m_startTime;
    encoder << instance.m_endTime;
    encoder << instance.m_id;
    encoder << instance.m_content;
    encoder << instance.m_fontName;
    encoder << instance.m_line;
    encoder << instance.m_position;
    encoder << instance.m_size;
    encoder << instance.m_baseFontSize;
    encoder << instance.m_relativeFontSize;
    encoder << instance.m_foregroundColor;
    encoder << instance.m_backgroundColor;
    encoder << instance.m_highlightColor;
    encoder << instance.m_positionAlign;
    encoder << instance.m_align;
    encoder << instance.m_status;
}

std::optional<WebCore::GenericCueData> ArgumentCoder<WebCore::GenericCueData>::decode(Decoder& decoder)
{
    auto m_uniqueId = decoder.decode<Markable<WebCore::InbandGenericCueIdentifier>>();
    auto m_startTime = decoder.decode<MediaTime>();
    auto m_endTime = decoder.decode<MediaTime>();
    auto m_id = decoder.decode<AtomString>();
    auto m_content = decoder.decode<String>();
    auto m_fontName = decoder.decode<String>();
    auto m_line = decoder.decode<double>();
    auto m_position = decoder.decode<double>();
    auto m_size = decoder.decode<double>();
    auto m_baseFontSize = decoder.decode<double>();
    auto m_relativeFontSize = decoder.decode<double>();
    auto m_foregroundColor = decoder.decode<WebCore::Color>();
    auto m_backgroundColor = decoder.decode<WebCore::Color>();
    auto m_highlightColor = decoder.decode<WebCore::Color>();
    auto m_positionAlign = decoder.decode<WebCore::GenericCueData::Alignment>();
    auto m_align = decoder.decode<WebCore::GenericCueData::Alignment>();
    auto m_status = decoder.decode<WebCore::GenericCueData::Status>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::GenericCueData {
            WTFMove(*m_uniqueId),
            WTFMove(*m_startTime),
            WTFMove(*m_endTime),
            WTFMove(*m_id),
            WTFMove(*m_content),
            WTFMove(*m_fontName),
            WTFMove(*m_line),
            WTFMove(*m_position),
            WTFMove(*m_size),
            WTFMove(*m_baseFontSize),
            WTFMove(*m_relativeFontSize),
            WTFMove(*m_foregroundColor),
            WTFMove(*m_backgroundColor),
            WTFMove(*m_highlightColor),
            WTFMove(*m_positionAlign),
            WTFMove(*m_align),
            WTFMove(*m_status)
        }
    };
}

#endif

void ArgumentCoder<WebCore::ImageDecoderFrameInfo>::encode(Encoder& encoder, const WebCore::ImageDecoderFrameInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasAlpha)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.duration)>, Seconds>);
    struct ShouldBeSameSizeAsImageDecoderFrameInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ImageDecoderFrameInfo>, false> {
        bool hasAlpha;
        Seconds duration;
    };
    static_assert(sizeof(ShouldBeSameSizeAsImageDecoderFrameInfo) == sizeof(WebCore::ImageDecoderFrameInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ImageDecoderFrameInfo, hasAlpha)
        , offsetof(WebCore::ImageDecoderFrameInfo, duration)
    >::value);

    encoder << instance.hasAlpha;
    encoder << instance.duration;
}

void ArgumentCoder<WebCore::ImageDecoderFrameInfo>::encode(StreamConnectionEncoder& encoder, const WebCore::ImageDecoderFrameInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasAlpha)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.duration)>, Seconds>);
    struct ShouldBeSameSizeAsImageDecoderFrameInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ImageDecoderFrameInfo>, false> {
        bool hasAlpha;
        Seconds duration;
    };
    static_assert(sizeof(ShouldBeSameSizeAsImageDecoderFrameInfo) == sizeof(WebCore::ImageDecoderFrameInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ImageDecoderFrameInfo, hasAlpha)
        , offsetof(WebCore::ImageDecoderFrameInfo, duration)
    >::value);

    encoder << instance.hasAlpha;
    encoder << instance.duration;
}

std::optional<WebCore::ImageDecoderFrameInfo> ArgumentCoder<WebCore::ImageDecoderFrameInfo>::decode(Decoder& decoder)
{
    auto hasAlpha = decoder.decode<bool>();
    auto duration = decoder.decode<Seconds>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ImageDecoderFrameInfo {
            WTFMove(*hasAlpha),
            WTFMove(*duration)
        }
    };
}

void ArgumentCoder<WebCore::DisplayList::DrawDotsForDocumentMarker>::encode(Encoder& encoder, const WebCore::DisplayList::DrawDotsForDocumentMarker& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rect())>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.style())>, WebCore::DocumentMarkerLineStyle>);

    encoder << instance.rect();
    encoder << instance.style();
}

void ArgumentCoder<WebCore::DisplayList::DrawDotsForDocumentMarker>::encode(StreamConnectionEncoder& encoder, const WebCore::DisplayList::DrawDotsForDocumentMarker& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rect())>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.style())>, WebCore::DocumentMarkerLineStyle>);

    encoder << instance.rect();
    encoder << instance.style();
}

std::optional<WebCore::DisplayList::DrawDotsForDocumentMarker> ArgumentCoder<WebCore::DisplayList::DrawDotsForDocumentMarker>::decode(Decoder& decoder)
{
    auto rect = decoder.decode<WebCore::FloatRect>();
    auto style = decoder.decode<WebCore::DocumentMarkerLineStyle>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DisplayList::DrawDotsForDocumentMarker {
            WTFMove(*rect),
            WTFMove(*style)
        }
    };
}

void ArgumentCoder<WebCore::ImageOrientation>::encode(Encoder& encoder, const WebCore::ImageOrientation& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.orientation())>, WebCore::ImageOrientation::Orientation>);

    encoder << instance.orientation();
}

void ArgumentCoder<WebCore::ImageOrientation>::encode(StreamConnectionEncoder& encoder, const WebCore::ImageOrientation& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.orientation())>, WebCore::ImageOrientation::Orientation>);

    encoder << instance.orientation();
}

std::optional<WebCore::ImageOrientation> ArgumentCoder<WebCore::ImageOrientation>::decode(Decoder& decoder)
{
    auto orientation = decoder.decode<WebCore::ImageOrientation::Orientation>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ImageOrientation {
            WTFMove(*orientation)
        }
    };
}

void ArgumentCoder<WebCore::Headroom>::encode(Encoder& encoder, const WebCore::Headroom& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.headroom)>, float>);
    struct ShouldBeSameSizeAsHeadroom : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Headroom>, false> {
        float headroom;
    };
    static_assert(sizeof(ShouldBeSameSizeAsHeadroom) == sizeof(WebCore::Headroom));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Headroom, headroom)
    >::value);

    encoder << instance.headroom;
}

void ArgumentCoder<WebCore::Headroom>::encode(StreamConnectionEncoder& encoder, const WebCore::Headroom& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.headroom)>, float>);
    struct ShouldBeSameSizeAsHeadroom : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Headroom>, false> {
        float headroom;
    };
    static_assert(sizeof(ShouldBeSameSizeAsHeadroom) == sizeof(WebCore::Headroom));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Headroom, headroom)
    >::value);

    encoder << instance.headroom;
}

std::optional<WebCore::Headroom> ArgumentCoder<WebCore::Headroom>::decode(Decoder& decoder)
{
    auto headroom = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Headroom {
            WTFMove(*headroom)
        }
    };
}

void ArgumentCoder<WebCore::ImagePaintingOptions>::encode(Encoder& encoder, const WebCore::ImagePaintingOptions& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.compositeOperator())>, WebCore::CompositeOperator>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.blendMode())>, WebCore::BlendMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.decodingMode())>, WebCore::DecodingMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.orientation().orientation())>, WebCore::ImageOrientation::Orientation>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.interpolationQuality())>, WebCore::InterpolationQuality>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.drawsHDRContent())>, WebCore::DrawsHDRContent>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.headroom())>, WebCore::Headroom>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dynamicRangeLimit())>, WebCore::PlatformDynamicRangeLimit>);

    encoder << instance.compositeOperator();
    encoder << instance.blendMode();
    encoder << instance.decodingMode();
    encoder << instance.orientation().orientation();
    encoder << instance.interpolationQuality();
    encoder << instance.drawsHDRContent();
    encoder << instance.headroom();
    encoder << instance.dynamicRangeLimit();
}

void ArgumentCoder<WebCore::ImagePaintingOptions>::encode(StreamConnectionEncoder& encoder, const WebCore::ImagePaintingOptions& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.compositeOperator())>, WebCore::CompositeOperator>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.blendMode())>, WebCore::BlendMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.decodingMode())>, WebCore::DecodingMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.orientation().orientation())>, WebCore::ImageOrientation::Orientation>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.interpolationQuality())>, WebCore::InterpolationQuality>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.drawsHDRContent())>, WebCore::DrawsHDRContent>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.headroom())>, WebCore::Headroom>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dynamicRangeLimit())>, WebCore::PlatformDynamicRangeLimit>);

    encoder << instance.compositeOperator();
    encoder << instance.blendMode();
    encoder << instance.decodingMode();
    encoder << instance.orientation().orientation();
    encoder << instance.interpolationQuality();
    encoder << instance.drawsHDRContent();
    encoder << instance.headroom();
    encoder << instance.dynamicRangeLimit();
}

std::optional<WebCore::ImagePaintingOptions> ArgumentCoder<WebCore::ImagePaintingOptions>::decode(Decoder& decoder)
{
    auto compositeOperator = decoder.decode<WebCore::CompositeOperator>();
    auto blendMode = decoder.decode<WebCore::BlendMode>();
    auto decodingMode = decoder.decode<WebCore::DecodingMode>();
    auto orientationorientation = decoder.decode<WebCore::ImageOrientation::Orientation>();
    auto interpolationQuality = decoder.decode<WebCore::InterpolationQuality>();
    auto drawsHDRContent = decoder.decode<WebCore::DrawsHDRContent>();
    auto headroom = decoder.decode<WebCore::Headroom>();
    auto dynamicRangeLimit = decoder.decode<WebCore::PlatformDynamicRangeLimit>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ImagePaintingOptions {
            WTFMove(*compositeOperator),
            WTFMove(*blendMode),
            WTFMove(*decodingMode),
            WTFMove(*orientationorientation),
            WTFMove(*interpolationQuality),
            WTFMove(*drawsHDRContent),
            WTFMove(*headroom),
            WTFMove(*dynamicRangeLimit)
        }
    };
}

void ArgumentCoder<WebCore::FloatSegment>::encode(Encoder& encoder, const WebCore::FloatSegment& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.begin)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.end)>, float>);
    struct ShouldBeSameSizeAsFloatSegment : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FloatSegment>, false> {
        float begin;
        float end;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFloatSegment) == sizeof(WebCore::FloatSegment));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FloatSegment, begin)
        , offsetof(WebCore::FloatSegment, end)
    >::value);

    encoder << instance.begin;
    encoder << instance.end;
}

void ArgumentCoder<WebCore::FloatSegment>::encode(StreamConnectionEncoder& encoder, const WebCore::FloatSegment& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.begin)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.end)>, float>);
    struct ShouldBeSameSizeAsFloatSegment : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FloatSegment>, false> {
        float begin;
        float end;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFloatSegment) == sizeof(WebCore::FloatSegment));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FloatSegment, begin)
        , offsetof(WebCore::FloatSegment, end)
    >::value);

    encoder << instance.begin;
    encoder << instance.end;
}

std::optional<WebCore::FloatSegment> ArgumentCoder<WebCore::FloatSegment>::decode(Decoder& decoder)
{
    auto begin = decoder.decode<float>();
    auto end = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FloatSegment {
            WTFMove(*begin),
            WTFMove(*end)
        }
    };
}

void ArgumentCoder<WebCore::CanvasActivityRecord>::encode(Encoder& encoder, const WebCore::CanvasActivityRecord& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.textWritten)>, HashSet<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.wasDataRead)>, bool>);
    struct ShouldBeSameSizeAsCanvasActivityRecord : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::CanvasActivityRecord>, false> {
        HashSet<String> textWritten;
        bool wasDataRead;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCanvasActivityRecord) == sizeof(WebCore::CanvasActivityRecord));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::CanvasActivityRecord, textWritten)
        , offsetof(WebCore::CanvasActivityRecord, wasDataRead)
    >::value);

    encoder << instance.textWritten;
    encoder << instance.wasDataRead;
}

std::optional<WebCore::CanvasActivityRecord> ArgumentCoder<WebCore::CanvasActivityRecord>::decode(Decoder& decoder)
{
    auto textWritten = decoder.decode<HashSet<String>>();
    auto wasDataRead = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CanvasActivityRecord {
            WTFMove(*textWritten),
            WTFMove(*wasDataRead)
        }
    };
}

void ArgumentCoder<WebCore::PCM::AttributionSecondsUntilSendData>::encode(Encoder& encoder, const WebCore::PCM::AttributionSecondsUntilSendData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceSeconds)>, std::optional<Seconds>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.destinationSeconds)>, std::optional<Seconds>>);
    struct ShouldBeSameSizeAsAttributionSecondsUntilSendData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PCM::AttributionSecondsUntilSendData>, false> {
        std::optional<Seconds> sourceSeconds;
        std::optional<Seconds> destinationSeconds;
    };
    static_assert(sizeof(ShouldBeSameSizeAsAttributionSecondsUntilSendData) == sizeof(WebCore::PCM::AttributionSecondsUntilSendData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PCM::AttributionSecondsUntilSendData, sourceSeconds)
        , offsetof(WebCore::PCM::AttributionSecondsUntilSendData, destinationSeconds)
    >::value);

    encoder << instance.sourceSeconds;
    encoder << instance.destinationSeconds;
}

std::optional<WebCore::PCM::AttributionSecondsUntilSendData> ArgumentCoder<WebCore::PCM::AttributionSecondsUntilSendData>::decode(Decoder& decoder)
{
    auto sourceSeconds = decoder.decode<std::optional<Seconds>>();
    auto destinationSeconds = decoder.decode<std::optional<Seconds>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PCM::AttributionSecondsUntilSendData {
            WTFMove(*sourceSeconds),
            WTFMove(*destinationSeconds)
        }
    };
}

void ArgumentCoder<WebCore::CrossOriginOpenerPolicy>::encode(Encoder& encoder, const WebCore::CrossOriginOpenerPolicy& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, WebCore::CrossOriginOpenerPolicyValue>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.reportOnlyValue)>, WebCore::CrossOriginOpenerPolicyValue>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.reportingEndpoint)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.reportOnlyReportingEndpoint)>, String>);
    struct ShouldBeSameSizeAsCrossOriginOpenerPolicy : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::CrossOriginOpenerPolicy>, false> {
        WebCore::CrossOriginOpenerPolicyValue value;
        WebCore::CrossOriginOpenerPolicyValue reportOnlyValue;
        String reportingEndpoint;
        String reportOnlyReportingEndpoint;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCrossOriginOpenerPolicy) == sizeof(WebCore::CrossOriginOpenerPolicy));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::CrossOriginOpenerPolicy, value)
        , offsetof(WebCore::CrossOriginOpenerPolicy, reportOnlyValue)
        , offsetof(WebCore::CrossOriginOpenerPolicy, reportingEndpoint)
        , offsetof(WebCore::CrossOriginOpenerPolicy, reportOnlyReportingEndpoint)
    >::value);

    encoder << instance.value;
    encoder << instance.reportOnlyValue;
    encoder << instance.reportingEndpoint;
    encoder << instance.reportOnlyReportingEndpoint;
}

std::optional<WebCore::CrossOriginOpenerPolicy> ArgumentCoder<WebCore::CrossOriginOpenerPolicy>::decode(Decoder& decoder)
{
    auto value = decoder.decode<WebCore::CrossOriginOpenerPolicyValue>();
    auto reportOnlyValue = decoder.decode<WebCore::CrossOriginOpenerPolicyValue>();
    auto reportingEndpoint = decoder.decode<String>();
    auto reportOnlyReportingEndpoint = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CrossOriginOpenerPolicy {
            WTFMove(*value),
            WTFMove(*reportOnlyValue),
            WTFMove(*reportingEndpoint),
            WTFMove(*reportOnlyReportingEndpoint)
        }
    };
}

void ArgumentCoder<WebCore::CustomHeaderFields>::encode(Encoder& encoder, const WebCore::CustomHeaderFields& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fields)>, Vector<WebCore::HTTPHeaderField>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.thirdPartyDomains)>, Vector<String>>);
    struct ShouldBeSameSizeAsCustomHeaderFields : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::CustomHeaderFields>, false> {
        Vector<WebCore::HTTPHeaderField> fields;
        Vector<String> thirdPartyDomains;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCustomHeaderFields) == sizeof(WebCore::CustomHeaderFields));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::CustomHeaderFields, fields)
        , offsetof(WebCore::CustomHeaderFields, thirdPartyDomains)
    >::value);

    encoder << instance.fields;
    encoder << instance.thirdPartyDomains;
}

std::optional<WebCore::CustomHeaderFields> ArgumentCoder<WebCore::CustomHeaderFields>::decode(Decoder& decoder)
{
    auto fields = decoder.decode<Vector<WebCore::HTTPHeaderField>>();
    auto thirdPartyDomains = decoder.decode<Vector<String>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CustomHeaderFields {
            WTFMove(*fields),
            WTFMove(*thirdPartyDomains)
        }
    };
}

void ArgumentCoder<WebCore::HTTPHeaderField>::encode(Encoder& encoder, const WebCore::HTTPHeaderField& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value())>, String>);

    encoder << instance.name();
    encoder << instance.value();
}

std::optional<WebCore::HTTPHeaderField> ArgumentCoder<WebCore::HTTPHeaderField>::decode(Decoder& decoder)
{
    auto name = decoder.decode<String>();
    auto value = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::HTTPHeaderField::create(
            WTFMove(*name),
            WTFMove(*value)
        )
    };
}

void ArgumentCoder<WebCore::NavigationRequester>::encode(Encoder& encoder, const WebCore::NavigationRequester& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.securityOrigin)>, Ref<WebCore::SecurityOrigin>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.topOrigin)>, Ref<WebCore::SecurityOrigin>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.policyContainer)>, WebCore::PolicyContainer>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameID)>, std::optional<WebCore::FrameIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pageID)>, std::optional<WebCore::PageIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.documentIdentifier)>, WebCore::ScriptExecutionContextIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sandboxFlags)>, WebCore::SandboxFlags>);
    struct ShouldBeSameSizeAsNavigationRequester : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::NavigationRequester>, false> {
        URL url;
        Ref<WebCore::SecurityOrigin> securityOrigin;
        Ref<WebCore::SecurityOrigin> topOrigin;
        WebCore::PolicyContainer policyContainer;
        std::optional<WebCore::FrameIdentifier> frameID;
        std::optional<WebCore::PageIdentifier> pageID;
        WebCore::ScriptExecutionContextIdentifier documentIdentifier;
        WebCore::SandboxFlags sandboxFlags;
    };
    static_assert(sizeof(ShouldBeSameSizeAsNavigationRequester) == sizeof(WebCore::NavigationRequester));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::NavigationRequester, url)
        , offsetof(WebCore::NavigationRequester, securityOrigin)
        , offsetof(WebCore::NavigationRequester, topOrigin)
        , offsetof(WebCore::NavigationRequester, policyContainer)
        , offsetof(WebCore::NavigationRequester, frameID)
        , offsetof(WebCore::NavigationRequester, pageID)
        , offsetof(WebCore::NavigationRequester, documentIdentifier)
        , offsetof(WebCore::NavigationRequester, sandboxFlags)
    >::value);

    encoder << instance.url;
    encoder << instance.securityOrigin;
    encoder << instance.topOrigin;
    encoder << instance.policyContainer;
    encoder << instance.frameID;
    encoder << instance.pageID;
    encoder << instance.documentIdentifier;
    encoder << instance.sandboxFlags;
}

std::optional<WebCore::NavigationRequester> ArgumentCoder<WebCore::NavigationRequester>::decode(Decoder& decoder)
{
    auto url = decoder.decode<URL>();
    auto securityOrigin = decoder.decode<Ref<WebCore::SecurityOrigin>>();
    auto topOrigin = decoder.decode<Ref<WebCore::SecurityOrigin>>();
    auto policyContainer = decoder.decode<WebCore::PolicyContainer>();
    auto frameID = decoder.decode<std::optional<WebCore::FrameIdentifier>>();
    auto pageID = decoder.decode<std::optional<WebCore::PageIdentifier>>();
    auto documentIdentifier = decoder.decode<WebCore::ScriptExecutionContextIdentifier>();
    auto sandboxFlags = decoder.decode<WebCore::SandboxFlags>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::NavigationRequester {
            WTFMove(*url),
            WTFMove(*securityOrigin),
            WTFMove(*topOrigin),
            WTFMove(*policyContainer),
            WTFMove(*frameID),
            WTFMove(*pageID),
            WTFMove(*documentIdentifier),
            WTFMove(*sandboxFlags)
        }
    };
}

void ArgumentCoder<WebCore::PolicyContainer>::encode(Encoder& encoder, const WebCore::PolicyContainer& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentSecurityPolicyResponseHeaders)>, WebCore::ContentSecurityPolicyResponseHeaders>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.crossOriginEmbedderPolicy)>, WebCore::CrossOriginEmbedderPolicy>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.crossOriginOpenerPolicy)>, WebCore::CrossOriginOpenerPolicy>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.referrerPolicy)>, WebCore::ReferrerPolicy>);
    struct ShouldBeSameSizeAsPolicyContainer : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PolicyContainer>, false> {
        WebCore::ContentSecurityPolicyResponseHeaders contentSecurityPolicyResponseHeaders;
        WebCore::CrossOriginEmbedderPolicy crossOriginEmbedderPolicy;
        WebCore::CrossOriginOpenerPolicy crossOriginOpenerPolicy;
        WebCore::ReferrerPolicy referrerPolicy;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPolicyContainer) == sizeof(WebCore::PolicyContainer));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PolicyContainer, contentSecurityPolicyResponseHeaders)
        , offsetof(WebCore::PolicyContainer, crossOriginEmbedderPolicy)
        , offsetof(WebCore::PolicyContainer, crossOriginOpenerPolicy)
        , offsetof(WebCore::PolicyContainer, referrerPolicy)
    >::value);

    encoder << instance.contentSecurityPolicyResponseHeaders;
    encoder << instance.crossOriginEmbedderPolicy;
    encoder << instance.crossOriginOpenerPolicy;
    encoder << instance.referrerPolicy;
}

std::optional<WebCore::PolicyContainer> ArgumentCoder<WebCore::PolicyContainer>::decode(Decoder& decoder)
{
    auto contentSecurityPolicyResponseHeaders = decoder.decode<WebCore::ContentSecurityPolicyResponseHeaders>();
    auto crossOriginEmbedderPolicy = decoder.decode<WebCore::CrossOriginEmbedderPolicy>();
    auto crossOriginOpenerPolicy = decoder.decode<WebCore::CrossOriginOpenerPolicy>();
    auto referrerPolicy = decoder.decode<WebCore::ReferrerPolicy>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PolicyContainer {
            WTFMove(*contentSecurityPolicyResponseHeaders),
            WTFMove(*crossOriginEmbedderPolicy),
            WTFMove(*crossOriginOpenerPolicy),
            WTFMove(*referrerPolicy)
        }
    };
}

void ArgumentCoder<WebCore::SubstituteData>::encode(Encoder& encoder, const WebCore::SubstituteData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.protectedContent())>, RefPtr<WebCore::FragmentedSharedBuffer>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.failingURL())>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.response())>, WebCore::ResourceResponse>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldRevealToSessionHistory())>, WebCore::SubstituteData::SessionHistoryVisibility>);

    encoder << instance.protectedContent();
    encoder << instance.failingURL();
    encoder << instance.response();
    encoder << instance.shouldRevealToSessionHistory();
}

std::optional<WebCore::SubstituteData> ArgumentCoder<WebCore::SubstituteData>::decode(Decoder& decoder)
{
    auto protectedContent = decoder.decode<RefPtr<WebCore::FragmentedSharedBuffer>>();
    auto failingURL = decoder.decode<URL>();
    auto response = decoder.decode<WebCore::ResourceResponse>();
    auto shouldRevealToSessionHistory = decoder.decode<WebCore::SubstituteData::SessionHistoryVisibility>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SubstituteData {
            WTFMove(*protectedContent),
            WTFMove(*failingURL),
            WTFMove(*response),
            WTFMove(*shouldRevealToSessionHistory)
        }
    };
}

void ArgumentCoder<WebCore::ServiceWorkerClientData>::encode(Encoder& encoder, const WebCore::ServiceWorkerClientData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, WebCore::ScriptExecutionContextIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::ServiceWorkerClientType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameType)>, WebCore::ServiceWorkerClientFrameType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ownerURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pageIdentifier)>, std::optional<WebCore::PageIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameIdentifier)>, std::optional<WebCore::FrameIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lastNavigationWasAppInitiated)>, WebCore::LastNavigationWasAppInitiated>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.advancedPrivacyProtections)>, OptionSet<WebCore::AdvancedPrivacyProtections>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isVisible)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isFocused)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.focusOrder)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ancestorOrigins)>, Vector<String>>);
    struct ShouldBeSameSizeAsServiceWorkerClientData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ServiceWorkerClientData>, false> {
        WebCore::ScriptExecutionContextIdentifier identifier;
        WebCore::ServiceWorkerClientType type;
        WebCore::ServiceWorkerClientFrameType frameType;
        URL url;
        URL ownerURL;
        std::optional<WebCore::PageIdentifier> pageIdentifier;
        std::optional<WebCore::FrameIdentifier> frameIdentifier;
        WebCore::LastNavigationWasAppInitiated lastNavigationWasAppInitiated;
        OptionSet<WebCore::AdvancedPrivacyProtections> advancedPrivacyProtections;
        bool isVisible;
        bool isFocused;
        uint64_t focusOrder;
        Vector<String> ancestorOrigins;
    };
    static_assert(sizeof(ShouldBeSameSizeAsServiceWorkerClientData) == sizeof(WebCore::ServiceWorkerClientData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ServiceWorkerClientData, identifier)
        , offsetof(WebCore::ServiceWorkerClientData, type)
        , offsetof(WebCore::ServiceWorkerClientData, frameType)
        , offsetof(WebCore::ServiceWorkerClientData, url)
        , offsetof(WebCore::ServiceWorkerClientData, ownerURL)
        , offsetof(WebCore::ServiceWorkerClientData, pageIdentifier)
        , offsetof(WebCore::ServiceWorkerClientData, frameIdentifier)
        , offsetof(WebCore::ServiceWorkerClientData, lastNavigationWasAppInitiated)
        , offsetof(WebCore::ServiceWorkerClientData, advancedPrivacyProtections)
        , offsetof(WebCore::ServiceWorkerClientData, isVisible)
        , offsetof(WebCore::ServiceWorkerClientData, isFocused)
        , offsetof(WebCore::ServiceWorkerClientData, focusOrder)
        , offsetof(WebCore::ServiceWorkerClientData, ancestorOrigins)
    >::value);

    encoder << instance.identifier;
    encoder << instance.type;
    encoder << instance.frameType;
    encoder << instance.url;
    encoder << instance.ownerURL;
    encoder << instance.pageIdentifier;
    encoder << instance.frameIdentifier;
    encoder << instance.lastNavigationWasAppInitiated;
    encoder << instance.advancedPrivacyProtections;
    encoder << instance.isVisible;
    encoder << instance.isFocused;
    encoder << instance.focusOrder;
    encoder << instance.ancestorOrigins;
}

std::optional<WebCore::ServiceWorkerClientData> ArgumentCoder<WebCore::ServiceWorkerClientData>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<WebCore::ScriptExecutionContextIdentifier>();
    auto type = decoder.decode<WebCore::ServiceWorkerClientType>();
    auto frameType = decoder.decode<WebCore::ServiceWorkerClientFrameType>();
    auto url = decoder.decode<URL>();
    auto ownerURL = decoder.decode<URL>();
    auto pageIdentifier = decoder.decode<std::optional<WebCore::PageIdentifier>>();
    auto frameIdentifier = decoder.decode<std::optional<WebCore::FrameIdentifier>>();
    auto lastNavigationWasAppInitiated = decoder.decode<WebCore::LastNavigationWasAppInitiated>();
    auto advancedPrivacyProtections = decoder.decode<OptionSet<WebCore::AdvancedPrivacyProtections>>();
    auto isVisible = decoder.decode<bool>();
    auto isFocused = decoder.decode<bool>();
    auto focusOrder = decoder.decode<uint64_t>();
    auto ancestorOrigins = decoder.decode<Vector<String>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ServiceWorkerClientData {
            WTFMove(*identifier),
            WTFMove(*type),
            WTFMove(*frameType),
            WTFMove(*url),
            WTFMove(*ownerURL),
            WTFMove(*pageIdentifier),
            WTFMove(*frameIdentifier),
            WTFMove(*lastNavigationWasAppInitiated),
            WTFMove(*advancedPrivacyProtections),
            WTFMove(*isVisible),
            WTFMove(*isFocused),
            WTFMove(*focusOrder),
            WTFMove(*ancestorOrigins)
        }
    };
}

void ArgumentCoder<WebCore::ServiceWorkerClientPendingMessage>::encode(Encoder& encoder, const WebCore::ServiceWorkerClientPendingMessage& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.message)>, WebCore::MessageWithMessagePorts>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceData)>, WebCore::ServiceWorkerData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceOrigin)>, String>);
    struct ShouldBeSameSizeAsServiceWorkerClientPendingMessage : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ServiceWorkerClientPendingMessage>, false> {
        WebCore::MessageWithMessagePorts message;
        WebCore::ServiceWorkerData sourceData;
        String sourceOrigin;
    };
    static_assert(sizeof(ShouldBeSameSizeAsServiceWorkerClientPendingMessage) == sizeof(WebCore::ServiceWorkerClientPendingMessage));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ServiceWorkerClientPendingMessage, message)
        , offsetof(WebCore::ServiceWorkerClientPendingMessage, sourceData)
        , offsetof(WebCore::ServiceWorkerClientPendingMessage, sourceOrigin)
    >::value);

    encoder << instance.message;
    encoder << instance.sourceData;
    encoder << instance.sourceOrigin;
}

std::optional<WebCore::ServiceWorkerClientPendingMessage> ArgumentCoder<WebCore::ServiceWorkerClientPendingMessage>::decode(Decoder& decoder)
{
    auto message = decoder.decode<WebCore::MessageWithMessagePorts>();
    auto sourceData = decoder.decode<WebCore::ServiceWorkerData>();
    auto sourceOrigin = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ServiceWorkerClientPendingMessage {
            WTFMove(*message),
            WTFMove(*sourceData),
            WTFMove(*sourceOrigin)
        }
    };
}

void ArgumentCoder<WebCore::ServiceWorkerClientQueryOptions>::encode(Encoder& encoder, const WebCore::ServiceWorkerClientQueryOptions& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.includeUncontrolled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::ServiceWorkerClientType>);
    struct ShouldBeSameSizeAsServiceWorkerClientQueryOptions : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ServiceWorkerClientQueryOptions>, false> {
        bool includeUncontrolled;
        WebCore::ServiceWorkerClientType type;
    };
    static_assert(sizeof(ShouldBeSameSizeAsServiceWorkerClientQueryOptions) == sizeof(WebCore::ServiceWorkerClientQueryOptions));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ServiceWorkerClientQueryOptions, includeUncontrolled)
        , offsetof(WebCore::ServiceWorkerClientQueryOptions, type)
    >::value);

    encoder << instance.includeUncontrolled;
    encoder << instance.type;
}

std::optional<WebCore::ServiceWorkerClientQueryOptions> ArgumentCoder<WebCore::ServiceWorkerClientQueryOptions>::decode(Decoder& decoder)
{
    auto includeUncontrolled = decoder.decode<bool>();
    auto type = decoder.decode<WebCore::ServiceWorkerClientType>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ServiceWorkerClientQueryOptions {
            WTFMove(*includeUncontrolled),
            WTFMove(*type)
        }
    };
}

void ArgumentCoder<WebCore::ServiceWorkerData>::encode(Encoder& encoder, const WebCore::ServiceWorkerData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, WebCore::ServiceWorkerIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.registrationIdentifier)>, WebCore::ServiceWorkerRegistrationIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scriptURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.state)>, WebCore::ServiceWorkerState>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::WorkerType>);
    struct ShouldBeSameSizeAsServiceWorkerData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ServiceWorkerData>, false> {
        WebCore::ServiceWorkerIdentifier identifier;
        WebCore::ServiceWorkerRegistrationIdentifier registrationIdentifier;
        URL scriptURL;
        WebCore::ServiceWorkerState state;
        WebCore::WorkerType type;
    };
    static_assert(sizeof(ShouldBeSameSizeAsServiceWorkerData) == sizeof(WebCore::ServiceWorkerData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ServiceWorkerData, identifier)
        , offsetof(WebCore::ServiceWorkerData, registrationIdentifier)
        , offsetof(WebCore::ServiceWorkerData, scriptURL)
        , offsetof(WebCore::ServiceWorkerData, state)
        , offsetof(WebCore::ServiceWorkerData, type)
    >::value);

    encoder << instance.identifier;
    encoder << instance.registrationIdentifier;
    encoder << instance.scriptURL;
    encoder << instance.state;
    encoder << instance.type;
}

std::optional<WebCore::ServiceWorkerData> ArgumentCoder<WebCore::ServiceWorkerData>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<WebCore::ServiceWorkerIdentifier>();
    auto registrationIdentifier = decoder.decode<WebCore::ServiceWorkerRegistrationIdentifier>();
    auto scriptURL = decoder.decode<URL>();
    auto state = decoder.decode<WebCore::ServiceWorkerState>();
    auto type = decoder.decode<WebCore::WorkerType>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ServiceWorkerData {
            WTFMove(*identifier),
            WTFMove(*registrationIdentifier),
            WTFMove(*scriptURL),
            WTFMove(*state),
            WTFMove(*type)
        }
    };
}

void ArgumentCoder<WebCore::ServiceWorkerJobData>::encode(Encoder& encoder, const WebCore::ServiceWorkerJobData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier())>, WebCore::ServiceWorkerJobDataIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scriptURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.clientCreationURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.topOrigin)>, WebCore::SecurityOriginData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scopeURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceContext)>, WebCore::ServiceWorkerOrClientIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.workerType)>, WebCore::WorkerType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::ServiceWorkerJobType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.domainForCachePartition)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isFromServiceWorkerPage)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.registrationOptions)>, std::optional<WebCore::ServiceWorkerRegistrationOptions>>);

    encoder << instance.identifier();
    encoder << instance.scriptURL;
    encoder << instance.clientCreationURL;
    encoder << instance.topOrigin;
    encoder << instance.scopeURL;
    encoder << instance.sourceContext;
    encoder << instance.workerType;
    encoder << instance.type;
    encoder << instance.domainForCachePartition;
    encoder << instance.isFromServiceWorkerPage;
    encoder << instance.registrationOptions;
}

std::optional<WebCore::ServiceWorkerJobData> ArgumentCoder<WebCore::ServiceWorkerJobData>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<WebCore::ServiceWorkerJobDataIdentifier>();
    auto scriptURL = decoder.decode<URL>();
    auto clientCreationURL = decoder.decode<URL>();
    auto topOrigin = decoder.decode<WebCore::SecurityOriginData>();
    auto scopeURL = decoder.decode<URL>();
    auto sourceContext = decoder.decode<WebCore::ServiceWorkerOrClientIdentifier>();
    auto workerType = decoder.decode<WebCore::WorkerType>();
    auto type = decoder.decode<WebCore::ServiceWorkerJobType>();
    auto domainForCachePartition = decoder.decode<String>();
    auto isFromServiceWorkerPage = decoder.decode<bool>();
    auto registrationOptions = decoder.decode<std::optional<WebCore::ServiceWorkerRegistrationOptions>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(( type == WebCore::ServiceWorkerJobType::Register && registrationOptions->has_value()) || (type != WebCore::ServiceWorkerJobType::Register && !registrationOptions->has_value() )))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ServiceWorkerJobData {
            WTFMove(*identifier),
            WTFMove(*scriptURL),
            WTFMove(*clientCreationURL),
            WTFMove(*topOrigin),
            WTFMove(*scopeURL),
            WTFMove(*sourceContext),
            WTFMove(*workerType),
            WTFMove(*type),
            WTFMove(*domainForCachePartition),
            WTFMove(*isFromServiceWorkerPage),
            WTFMove(*registrationOptions)
        }
    };
}

void ArgumentCoder<WebCore::RouterSourceDict>::encode(Encoder& encoder, const WebCore::RouterSourceDict& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cacheName)>, String>);
    struct ShouldBeSameSizeAsRouterSourceDict : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::RouterSourceDict>, false> {
        String cacheName;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRouterSourceDict) == sizeof(WebCore::RouterSourceDict));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::RouterSourceDict, cacheName)
    >::value);

    encoder << instance.cacheName;
}

std::optional<WebCore::RouterSourceDict> ArgumentCoder<WebCore::RouterSourceDict>::decode(Decoder& decoder)
{
    auto cacheName = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::RouterSourceDict {
            WTFMove(*cacheName)
        }
    };
}

void ArgumentCoder<WebCore::ServiceWorkerRoutePattern>::encode(Encoder& encoder, const WebCore::ServiceWorkerRoutePattern& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.protocol)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.username)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.password)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hostname)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.port)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pathname)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.search)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hash)>, String>);
    struct ShouldBeSameSizeAsServiceWorkerRoutePattern : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ServiceWorkerRoutePattern>, false> {
        String protocol;
        String username;
        String password;
        String hostname;
        String port;
        String pathname;
        String search;
        String hash;
    };
    static_assert(sizeof(ShouldBeSameSizeAsServiceWorkerRoutePattern) == sizeof(WebCore::ServiceWorkerRoutePattern));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ServiceWorkerRoutePattern, protocol)
        , offsetof(WebCore::ServiceWorkerRoutePattern, username)
        , offsetof(WebCore::ServiceWorkerRoutePattern, password)
        , offsetof(WebCore::ServiceWorkerRoutePattern, hostname)
        , offsetof(WebCore::ServiceWorkerRoutePattern, port)
        , offsetof(WebCore::ServiceWorkerRoutePattern, pathname)
        , offsetof(WebCore::ServiceWorkerRoutePattern, search)
        , offsetof(WebCore::ServiceWorkerRoutePattern, hash)
    >::value);

    encoder << instance.protocol;
    encoder << instance.username;
    encoder << instance.password;
    encoder << instance.hostname;
    encoder << instance.port;
    encoder << instance.pathname;
    encoder << instance.search;
    encoder << instance.hash;
}

std::optional<WebCore::ServiceWorkerRoutePattern> ArgumentCoder<WebCore::ServiceWorkerRoutePattern>::decode(Decoder& decoder)
{
    auto protocol = decoder.decode<String>();
    auto username = decoder.decode<String>();
    auto password = decoder.decode<String>();
    auto hostname = decoder.decode<String>();
    auto port = decoder.decode<String>();
    auto pathname = decoder.decode<String>();
    auto search = decoder.decode<String>();
    auto hash = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ServiceWorkerRoutePattern {
            WTFMove(*protocol),
            WTFMove(*username),
            WTFMove(*password),
            WTFMove(*hostname),
            WTFMove(*port),
            WTFMove(*pathname),
            WTFMove(*search),
            WTFMove(*hash)
        }
    };
}

void ArgumentCoder<WebCore::ServiceWorkerRouteCondition>::encode(Encoder& encoder, const WebCore::ServiceWorkerRouteCondition& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.urlPattern)>, std::optional<WebCore::ServiceWorkerRoutePattern>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requestMethod)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requestMode)>, std::optional<WebCore::FetchOptionsMode>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requestDestination)>, std::optional<WebCore::FetchOptionsDestination>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.runningStatus)>, std::optional<WebCore::RunningStatus>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.orConditions)>, Vector<WebCore::ServiceWorkerRouteCondition>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.notCondition)>, std::unique_ptr<WebCore::ServiceWorkerRouteCondition>>);
    struct ShouldBeSameSizeAsServiceWorkerRouteCondition : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ServiceWorkerRouteCondition>, false> {
        std::optional<WebCore::ServiceWorkerRoutePattern> urlPattern;
        String requestMethod;
        std::optional<WebCore::FetchOptionsMode> requestMode;
        std::optional<WebCore::FetchOptionsDestination> requestDestination;
        std::optional<WebCore::RunningStatus> runningStatus;
        Vector<WebCore::ServiceWorkerRouteCondition> orConditions;
        std::unique_ptr<WebCore::ServiceWorkerRouteCondition> notCondition;
    };
    static_assert(sizeof(ShouldBeSameSizeAsServiceWorkerRouteCondition) == sizeof(WebCore::ServiceWorkerRouteCondition));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ServiceWorkerRouteCondition, urlPattern)
        , offsetof(WebCore::ServiceWorkerRouteCondition, requestMethod)
        , offsetof(WebCore::ServiceWorkerRouteCondition, requestMode)
        , offsetof(WebCore::ServiceWorkerRouteCondition, requestDestination)
        , offsetof(WebCore::ServiceWorkerRouteCondition, runningStatus)
        , offsetof(WebCore::ServiceWorkerRouteCondition, orConditions)
        , offsetof(WebCore::ServiceWorkerRouteCondition, notCondition)
    >::value);

    encoder << instance.urlPattern;
    encoder << instance.requestMethod;
    encoder << instance.requestMode;
    encoder << instance.requestDestination;
    encoder << instance.runningStatus;
    encoder << instance.orConditions;
    encoder << instance.notCondition;
}

std::optional<WebCore::ServiceWorkerRouteCondition> ArgumentCoder<WebCore::ServiceWorkerRouteCondition>::decode(Decoder& decoder)
{
    auto urlPattern = decoder.decode<std::optional<WebCore::ServiceWorkerRoutePattern>>();
    auto requestMethod = decoder.decode<String>();
    auto requestMode = decoder.decode<std::optional<WebCore::FetchOptionsMode>>();
    auto requestDestination = decoder.decode<std::optional<WebCore::FetchOptionsDestination>>();
    auto runningStatus = decoder.decode<std::optional<WebCore::RunningStatus>>();
    auto orConditions = decoder.decode<Vector<WebCore::ServiceWorkerRouteCondition>>();
    auto notCondition = decoder.decode<std::unique_ptr<WebCore::ServiceWorkerRouteCondition>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ServiceWorkerRouteCondition {
            WTFMove(*urlPattern),
            WTFMove(*requestMethod),
            WTFMove(*requestMode),
            WTFMove(*requestDestination),
            WTFMove(*runningStatus),
            WTFMove(*orConditions),
            WTFMove(*notCondition)
        }
    };
}

void ArgumentCoder<WebCore::ServiceWorkerRoute>::encode(Encoder& encoder, const WebCore::ServiceWorkerRoute& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.condition)>, WebCore::ServiceWorkerRouteCondition>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.source)>, Variant<WebCore::RouterSourceDict, WebCore::RouterSourceEnum>>);
    struct ShouldBeSameSizeAsServiceWorkerRoute : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ServiceWorkerRoute>, false> {
        WebCore::ServiceWorkerRouteCondition condition;
        Variant<WebCore::RouterSourceDict, WebCore::RouterSourceEnum> source;
    };
    static_assert(sizeof(ShouldBeSameSizeAsServiceWorkerRoute) == sizeof(WebCore::ServiceWorkerRoute));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ServiceWorkerRoute, condition)
        , offsetof(WebCore::ServiceWorkerRoute, source)
    >::value);

    encoder << instance.condition;
    encoder << instance.source;
}

std::optional<WebCore::ServiceWorkerRoute> ArgumentCoder<WebCore::ServiceWorkerRoute>::decode(Decoder& decoder)
{
    auto condition = decoder.decode<WebCore::ServiceWorkerRouteCondition>();
    auto source = decoder.decode<Variant<WebCore::RouterSourceDict, WebCore::RouterSourceEnum>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ServiceWorkerRoute {
            WTFMove(*condition),
            WTFMove(*source)
        }
    };
}

void ArgumentCoder<WebCore::EventInit>::encode(Encoder& encoder, const WebCore::EventInit& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bubbles)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cancelable)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.composed)>, bool>);
    struct ShouldBeSameSizeAsEventInit : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::EventInit>, false> {
        bool bubbles;
        bool cancelable;
        bool composed;
    };
    static_assert(sizeof(ShouldBeSameSizeAsEventInit) == sizeof(WebCore::EventInit));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::EventInit, bubbles)
        , offsetof(WebCore::EventInit, cancelable)
        , offsetof(WebCore::EventInit, composed)
    >::value);

    encoder << instance.bubbles;
    encoder << instance.cancelable;
    encoder << instance.composed;
}

std::optional<WebCore::EventInit> ArgumentCoder<WebCore::EventInit>::decode(Decoder& decoder)
{
    auto bubbles = decoder.decode<bool>();
    auto cancelable = decoder.decode<bool>();
    auto composed = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::EventInit {
            WTFMove(*bubbles),
            WTFMove(*cancelable),
            WTFMove(*composed)
        }
    };
}

void ArgumentCoder<WebCore::MessageWithMessagePorts>::encode(Encoder& encoder, const WebCore::MessageWithMessagePorts& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.message)>, RefPtr<WebCore::SerializedScriptValue>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.transferredPorts)>, Vector<WebCore::TransferredMessagePort>>);
    struct ShouldBeSameSizeAsMessageWithMessagePorts : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MessageWithMessagePorts>, false> {
        RefPtr<WebCore::SerializedScriptValue> message;
        Vector<WebCore::TransferredMessagePort> transferredPorts;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMessageWithMessagePorts) == sizeof(WebCore::MessageWithMessagePorts));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MessageWithMessagePorts, message)
        , offsetof(WebCore::MessageWithMessagePorts, transferredPorts)
    >::value);

    encoder << instance.message;
    encoder << instance.transferredPorts;
}

std::optional<WebCore::MessageWithMessagePorts> ArgumentCoder<WebCore::MessageWithMessagePorts>::decode(Decoder& decoder)
{
    auto message = decoder.decode<RefPtr<WebCore::SerializedScriptValue>>();
    auto transferredPorts = decoder.decode<Vector<WebCore::TransferredMessagePort>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MessageWithMessagePorts {
            WTFMove(*message),
            WTFMove(*transferredPorts)
        }
    };
}

void ArgumentCoder<WebCore::RequestStorageAccessResult>::encode(Encoder& encoder, const WebCore::RequestStorageAccessResult& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.wasGranted)>, WebCore::StorageAccessWasGranted>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.promptWasShown)>, WebCore::StorageAccessPromptWasShown>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scope)>, WebCore::StorageAccessScope>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.topFrameDomain)>, WebCore::RegistrableDomain>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.subFrameDomain)>, WebCore::RegistrableDomain>);
    struct ShouldBeSameSizeAsRequestStorageAccessResult : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::RequestStorageAccessResult>, false> {
        WebCore::StorageAccessWasGranted wasGranted;
        WebCore::StorageAccessPromptWasShown promptWasShown;
        WebCore::StorageAccessScope scope;
        WebCore::RegistrableDomain topFrameDomain;
        WebCore::RegistrableDomain subFrameDomain;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRequestStorageAccessResult) == sizeof(WebCore::RequestStorageAccessResult));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::RequestStorageAccessResult, wasGranted)
        , offsetof(WebCore::RequestStorageAccessResult, promptWasShown)
        , offsetof(WebCore::RequestStorageAccessResult, scope)
        , offsetof(WebCore::RequestStorageAccessResult, topFrameDomain)
        , offsetof(WebCore::RequestStorageAccessResult, subFrameDomain)
    >::value);

    encoder << instance.wasGranted;
    encoder << instance.promptWasShown;
    encoder << instance.scope;
    encoder << instance.topFrameDomain;
    encoder << instance.subFrameDomain;
}

std::optional<WebCore::RequestStorageAccessResult> ArgumentCoder<WebCore::RequestStorageAccessResult>::decode(Decoder& decoder)
{
    auto wasGranted = decoder.decode<WebCore::StorageAccessWasGranted>();
    auto promptWasShown = decoder.decode<WebCore::StorageAccessPromptWasShown>();
    auto scope = decoder.decode<WebCore::StorageAccessScope>();
    auto topFrameDomain = decoder.decode<WebCore::RegistrableDomain>();
    auto subFrameDomain = decoder.decode<WebCore::RegistrableDomain>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::RequestStorageAccessResult {
            WTFMove(*wasGranted),
            WTFMove(*promptWasShown),
            WTFMove(*scope),
            WTFMove(*topFrameDomain),
            WTFMove(*subFrameDomain)
        }
    };
}

void ArgumentCoder<WebCore::Exception>::encode(Encoder& encoder, const WebCore::Exception& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.code())>, WebCore::ExceptionCode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.message())>, String>);

    encoder << instance.code();
    encoder << instance.message();
}

std::optional<WebCore::Exception> ArgumentCoder<WebCore::Exception>::decode(Decoder& decoder)
{
    auto code = decoder.decode<WebCore::ExceptionCode>();
    auto message = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Exception {
            WTFMove(*code),
            WTFMove(*message)
        }
    };
}

void ArgumentCoder<WebCore::ExceptionData>::encode(Encoder& encoder, const WebCore::ExceptionData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.code)>, WebCore::ExceptionCode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.message)>, String>);
    struct ShouldBeSameSizeAsExceptionData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ExceptionData>, false> {
        WebCore::ExceptionCode code;
        String message;
    };
    static_assert(sizeof(ShouldBeSameSizeAsExceptionData) == sizeof(WebCore::ExceptionData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ExceptionData, code)
        , offsetof(WebCore::ExceptionData, message)
    >::value);

    encoder << instance.code;
    encoder << instance.message;
}

std::optional<WebCore::ExceptionData> ArgumentCoder<WebCore::ExceptionData>::decode(Decoder& decoder)
{
    auto code = decoder.decode<WebCore::ExceptionCode>();
    auto message = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ExceptionData {
            WTFMove(*code),
            WTFMove(*message)
        }
    };
}

void ArgumentCoder<WebCore::MessagePortIdentifier>::encode(Encoder& encoder, const WebCore::MessagePortIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processIdentifier)>, WebCore::ProcessIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.portIdentifier)>, WebCore::PortIdentifier>);
    struct ShouldBeSameSizeAsMessagePortIdentifier : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MessagePortIdentifier>, false> {
        WebCore::ProcessIdentifier processIdentifier;
        WebCore::PortIdentifier portIdentifier;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMessagePortIdentifier) == sizeof(WebCore::MessagePortIdentifier));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MessagePortIdentifier, processIdentifier)
        , offsetof(WebCore::MessagePortIdentifier, portIdentifier)
    >::value);

    encoder << instance.processIdentifier;
    encoder << instance.portIdentifier;
}

std::optional<WebCore::MessagePortIdentifier> ArgumentCoder<WebCore::MessagePortIdentifier>::decode(Decoder& decoder)
{
    auto processIdentifier = decoder.decode<WebCore::ProcessIdentifier>();
    auto portIdentifier = decoder.decode<WebCore::PortIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MessagePortIdentifier {
            WTFMove(*processIdentifier),
            WTFMove(*portIdentifier)
        }
    };
}

void ArgumentCoder<WebCore::SecurityPolicyViolationEventInit>::encode(Encoder& encoder, const WebCore::SecurityPolicyViolationEventInit& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bubbles)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cancelable)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.composed)>, bool>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::EventInit, bubbles)
        , offsetof(WebCore::EventInit, cancelable)
        , offsetof(WebCore::EventInit, composed)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.documentURI)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.referrer)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.blockedURI)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.violatedDirective)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.effectiveDirective)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.originalPolicy)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceFile)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sample)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.disposition)>, WebCore::SecurityPolicyViolationEventDisposition>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.statusCode)>, unsigned short>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lineNumber)>, unsigned>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.columnNumber)>, unsigned>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SecurityPolicyViolationEventInit, documentURI)
        , offsetof(WebCore::SecurityPolicyViolationEventInit, referrer)
        , offsetof(WebCore::SecurityPolicyViolationEventInit, blockedURI)
        , offsetof(WebCore::SecurityPolicyViolationEventInit, violatedDirective)
        , offsetof(WebCore::SecurityPolicyViolationEventInit, effectiveDirective)
        , offsetof(WebCore::SecurityPolicyViolationEventInit, originalPolicy)
        , offsetof(WebCore::SecurityPolicyViolationEventInit, sourceFile)
        , offsetof(WebCore::SecurityPolicyViolationEventInit, sample)
        , offsetof(WebCore::SecurityPolicyViolationEventInit, disposition)
        , offsetof(WebCore::SecurityPolicyViolationEventInit, statusCode)
        , offsetof(WebCore::SecurityPolicyViolationEventInit, lineNumber)
        , offsetof(WebCore::SecurityPolicyViolationEventInit, columnNumber)
    >::value);

    encoder << instance.bubbles;
    encoder << instance.cancelable;
    encoder << instance.composed;
    encoder << instance.documentURI;
    encoder << instance.referrer;
    encoder << instance.blockedURI;
    encoder << instance.violatedDirective;
    encoder << instance.effectiveDirective;
    encoder << instance.originalPolicy;
    encoder << instance.sourceFile;
    encoder << instance.sample;
    encoder << instance.disposition;
    encoder << instance.statusCode;
    encoder << instance.lineNumber;
    encoder << instance.columnNumber;
}

std::optional<WebCore::SecurityPolicyViolationEventInit> ArgumentCoder<WebCore::SecurityPolicyViolationEventInit>::decode(Decoder& decoder)
{
    auto bubbles = decoder.decode<bool>();
    auto cancelable = decoder.decode<bool>();
    auto composed = decoder.decode<bool>();
    auto documentURI = decoder.decode<String>();
    auto referrer = decoder.decode<String>();
    auto blockedURI = decoder.decode<String>();
    auto violatedDirective = decoder.decode<String>();
    auto effectiveDirective = decoder.decode<String>();
    auto originalPolicy = decoder.decode<String>();
    auto sourceFile = decoder.decode<String>();
    auto sample = decoder.decode<String>();
    auto disposition = decoder.decode<WebCore::SecurityPolicyViolationEventDisposition>();
    auto statusCode = decoder.decode<unsigned short>();
    auto lineNumber = decoder.decode<unsigned>();
    auto columnNumber = decoder.decode<unsigned>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SecurityPolicyViolationEventInit {
            WebCore::EventInit {
                WTFMove(*bubbles),
                WTFMove(*cancelable),
                WTFMove(*composed)
            },
            WTFMove(*documentURI),
            WTFMove(*referrer),
            WTFMove(*blockedURI),
            WTFMove(*violatedDirective),
            WTFMove(*effectiveDirective),
            WTFMove(*originalPolicy),
            WTFMove(*sourceFile),
            WTFMove(*sample),
            WTFMove(*disposition),
            WTFMove(*statusCode),
            WTFMove(*lineNumber),
            WTFMove(*columnNumber)
        }
    };
}

void ArgumentCoder<WebCore::CSPViolationReportBody>::encode(Encoder& encoder, const WebCore::CSPViolationReportBody& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.documentURL())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.referrer())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.blockedURL())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.effectiveDirective())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.originalPolicy())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceFile())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sample())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.disposition())>, WebCore::SecurityPolicyViolationEventDisposition>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.statusCode())>, unsigned short>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lineNumber())>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.columnNumber())>, uint64_t>);

    encoder << instance.documentURL();
    encoder << instance.referrer();
    encoder << instance.blockedURL();
    encoder << instance.effectiveDirective();
    encoder << instance.originalPolicy();
    encoder << instance.sourceFile();
    encoder << instance.sample();
    encoder << instance.disposition();
    encoder << instance.statusCode();
    encoder << instance.lineNumber();
    encoder << instance.columnNumber();
}

std::optional<Ref<WebCore::CSPViolationReportBody>> ArgumentCoder<WebCore::CSPViolationReportBody>::decode(Decoder& decoder)
{
    auto documentURL = decoder.decode<String>();
    auto referrer = decoder.decode<String>();
    auto blockedURL = decoder.decode<String>();
    auto effectiveDirective = decoder.decode<String>();
    auto originalPolicy = decoder.decode<String>();
    auto sourceFile = decoder.decode<String>();
    auto sample = decoder.decode<String>();
    auto disposition = decoder.decode<WebCore::SecurityPolicyViolationEventDisposition>();
    auto statusCode = decoder.decode<unsigned short>();
    auto lineNumber = decoder.decode<uint64_t>();
    auto columnNumber = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CSPViolationReportBody::create(
            WTFMove(*documentURL),
            WTFMove(*referrer),
            WTFMove(*blockedURL),
            WTFMove(*effectiveDirective),
            WTFMove(*originalPolicy),
            WTFMove(*sourceFile),
            WTFMove(*sample),
            WTFMove(*disposition),
            WTFMove(*statusCode),
            WTFMove(*lineNumber),
            WTFMove(*columnNumber)
        )
    };
}

void ArgumentCoder<WebCore::SecurityOriginData>::encode(Encoder& encoder, const WebCore::SecurityOriginData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data())>, Variant<WebCore::SecurityOriginData::Tuple, WebCore::OpaqueOriginIdentifierProcessQualified>>);

    encoder << instance.data();
}

std::optional<WebCore::SecurityOriginData> ArgumentCoder<WebCore::SecurityOriginData>::decode(Decoder& decoder)
{
    auto data = decoder.decode<Variant<WebCore::SecurityOriginData::Tuple, WebCore::OpaqueOriginIdentifierProcessQualified>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SecurityOriginData {
            WTFMove(*data)
        }
    };
}

void ArgumentCoder<WebCore::SecurityOriginData::Tuple>::encode(Encoder& encoder, const WebCore::SecurityOriginData::Tuple& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.protocol)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.host)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.port)>, std::optional<uint16_t>>);
    struct ShouldBeSameSizeAsTuple : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SecurityOriginData::Tuple>, false> {
        String protocol;
        String host;
        std::optional<uint16_t> port;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTuple) == sizeof(WebCore::SecurityOriginData::Tuple));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SecurityOriginData::Tuple, protocol)
        , offsetof(WebCore::SecurityOriginData::Tuple, host)
        , offsetof(WebCore::SecurityOriginData::Tuple, port)
    >::value);

    encoder << instance.protocol;
    encoder << instance.host;
    encoder << instance.port;
}

std::optional<WebCore::SecurityOriginData::Tuple> ArgumentCoder<WebCore::SecurityOriginData::Tuple>::decode(Decoder& decoder)
{
    auto protocol = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(!protocol->isHashTableDeletedValue()))
        return std::nullopt;
    auto host = decoder.decode<String>();
    auto port = decoder.decode<std::optional<uint16_t>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SecurityOriginData::Tuple {
            WTFMove(*protocol),
            WTFMove(*host),
            WTFMove(*port)
        }
    };
}

#if ENABLE(MEDIA_STREAM)
void ArgumentCoder<WebCore::MediaConstraint>::encode(Encoder& encoder, const WebCore::MediaConstraint& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dataType())>, WebCore::MediaConstraint::DataType>);

    encoder << instance.dataType();
}

std::optional<WebCore::MediaConstraint> ArgumentCoder<WebCore::MediaConstraint>::decode(Decoder& decoder)
{
    auto dataType = decoder.decode<WebCore::MediaConstraint::DataType>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MediaConstraint {
            WTFMove(*dataType)
        }
    };
}

#endif

#if ENABLE(MEDIA_STREAM)
void ArgumentCoder<WebCore::IntConstraint>::encode(Encoder& encoder, const WebCore::IntConstraint& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dataType())>, WebCore::MediaConstraint::DataType>);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_min)>, std::optional<int>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_max)>, std::optional<int>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_exact)>, std::optional<int>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_ideal)>, std::optional<int>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::IntConstraint, m_min)
        , offsetof(WebCore::IntConstraint, m_max)
        , offsetof(WebCore::IntConstraint, m_exact)
        , offsetof(WebCore::IntConstraint, m_ideal)
    >::value);

    encoder << instance.dataType();
    encoder << instance.m_min;
    encoder << instance.m_max;
    encoder << instance.m_exact;
    encoder << instance.m_ideal;
}

std::optional<WebCore::IntConstraint> ArgumentCoder<WebCore::IntConstraint>::decode(Decoder& decoder)
{
    auto dataType = decoder.decode<WebCore::MediaConstraint::DataType>();
    auto m_min = decoder.decode<std::optional<int>>();
    auto m_max = decoder.decode<std::optional<int>>();
    auto m_exact = decoder.decode<std::optional<int>>();
    auto m_ideal = decoder.decode<std::optional<int>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(*dataType == WebCore::MediaConstraint::DataType::Integer))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::IntConstraint {
            WebCore::MediaConstraint {
                WTFMove(*dataType)
            },
            WTFMove(*m_min),
            WTFMove(*m_max),
            WTFMove(*m_exact),
            WTFMove(*m_ideal)
        }
    };
}

#endif

#if ENABLE(MEDIA_STREAM)
void ArgumentCoder<WebCore::DoubleConstraint>::encode(Encoder& encoder, const WebCore::DoubleConstraint& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dataType())>, WebCore::MediaConstraint::DataType>);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_min)>, std::optional<double>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_max)>, std::optional<double>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_exact)>, std::optional<double>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_ideal)>, std::optional<double>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::DoubleConstraint, m_min)
        , offsetof(WebCore::DoubleConstraint, m_max)
        , offsetof(WebCore::DoubleConstraint, m_exact)
        , offsetof(WebCore::DoubleConstraint, m_ideal)
    >::value);

    encoder << instance.dataType();
    encoder << instance.m_min;
    encoder << instance.m_max;
    encoder << instance.m_exact;
    encoder << instance.m_ideal;
}

std::optional<WebCore::DoubleConstraint> ArgumentCoder<WebCore::DoubleConstraint>::decode(Decoder& decoder)
{
    auto dataType = decoder.decode<WebCore::MediaConstraint::DataType>();
    auto m_min = decoder.decode<std::optional<double>>();
    auto m_max = decoder.decode<std::optional<double>>();
    auto m_exact = decoder.decode<std::optional<double>>();
    auto m_ideal = decoder.decode<std::optional<double>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(*dataType == WebCore::MediaConstraint::DataType::Double))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DoubleConstraint {
            WebCore::MediaConstraint {
                WTFMove(*dataType)
            },
            WTFMove(*m_min),
            WTFMove(*m_max),
            WTFMove(*m_exact),
            WTFMove(*m_ideal)
        }
    };
}

#endif

#if ENABLE(MEDIA_STREAM)
void ArgumentCoder<WebCore::BooleanConstraint>::encode(Encoder& encoder, const WebCore::BooleanConstraint& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dataType())>, WebCore::MediaConstraint::DataType>);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_exact)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_ideal)>, std::optional<bool>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::BooleanConstraint, m_exact)
        , offsetof(WebCore::BooleanConstraint, m_ideal)
    >::value);

    encoder << instance.dataType();
    encoder << instance.m_exact;
    encoder << instance.m_ideal;
}

std::optional<WebCore::BooleanConstraint> ArgumentCoder<WebCore::BooleanConstraint>::decode(Decoder& decoder)
{
    auto dataType = decoder.decode<WebCore::MediaConstraint::DataType>();
    auto m_exact = decoder.decode<std::optional<bool>>();
    auto m_ideal = decoder.decode<std::optional<bool>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(*dataType == WebCore::MediaConstraint::DataType::Boolean))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::BooleanConstraint {
            WebCore::MediaConstraint {
                WTFMove(*dataType)
            },
            WTFMove(*m_exact),
            WTFMove(*m_ideal)
        }
    };
}

#endif

#if ENABLE(MEDIA_STREAM)
void ArgumentCoder<WebCore::StringConstraint>::encode(Encoder& encoder, const WebCore::StringConstraint& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dataType())>, WebCore::MediaConstraint::DataType>);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_exact)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_ideal)>, Vector<String>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::StringConstraint, m_exact)
        , offsetof(WebCore::StringConstraint, m_ideal)
    >::value);

    encoder << instance.dataType();
    encoder << instance.m_exact;
    encoder << instance.m_ideal;
}

std::optional<WebCore::StringConstraint> ArgumentCoder<WebCore::StringConstraint>::decode(Decoder& decoder)
{
    auto dataType = decoder.decode<WebCore::MediaConstraint::DataType>();
    auto m_exact = decoder.decode<Vector<String>>();
    auto m_ideal = decoder.decode<Vector<String>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(*dataType == WebCore::MediaConstraint::DataType::String))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::StringConstraint {
            WebCore::MediaConstraint {
                WTFMove(*dataType)
            },
            WTFMove(*m_exact),
            WTFMove(*m_ideal)
        }
    };
}

#endif

#if ENABLE(MEDIA_STREAM)
void ArgumentCoder<WebCore::FrameRateRange>::encode(Encoder& encoder, const WebCore::FrameRateRange& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.minimum)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maximum)>, double>);
    struct ShouldBeSameSizeAsFrameRateRange : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FrameRateRange>, false> {
        double minimum;
        double maximum;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFrameRateRange) == sizeof(WebCore::FrameRateRange));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FrameRateRange, minimum)
        , offsetof(WebCore::FrameRateRange, maximum)
    >::value);

    encoder << instance.minimum;
    encoder << instance.maximum;
}

std::optional<WebCore::FrameRateRange> ArgumentCoder<WebCore::FrameRateRange>::decode(Decoder& decoder)
{
    auto minimum = decoder.decode<double>();
    auto maximum = decoder.decode<double>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FrameRateRange {
            WTFMove(*minimum),
            WTFMove(*maximum)
        }
    };
}

#endif

#if ENABLE(MEDIA_STREAM)
void ArgumentCoder<WebCore::VideoPresetData>::encode(Encoder& encoder, const WebCore::VideoPresetData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size)>, WebCore::IntSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameRateRanges)>, Vector<WebCore::FrameRateRange>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.minZoom)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxZoom)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isEfficient)>, bool>);
    struct ShouldBeSameSizeAsVideoPresetData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::VideoPresetData>, false> {
        WebCore::IntSize size;
        Vector<WebCore::FrameRateRange> frameRateRanges;
        double minZoom;
        double maxZoom;
        bool isEfficient;
    };
    static_assert(sizeof(ShouldBeSameSizeAsVideoPresetData) == sizeof(WebCore::VideoPresetData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::VideoPresetData, size)
        , offsetof(WebCore::VideoPresetData, frameRateRanges)
        , offsetof(WebCore::VideoPresetData, minZoom)
        , offsetof(WebCore::VideoPresetData, maxZoom)
        , offsetof(WebCore::VideoPresetData, isEfficient)
    >::value);

    encoder << instance.size;
    encoder << instance.frameRateRanges;
    encoder << instance.minZoom;
    encoder << instance.maxZoom;
    encoder << instance.isEfficient;
}

std::optional<WebCore::VideoPresetData> ArgumentCoder<WebCore::VideoPresetData>::decode(Decoder& decoder)
{
    auto size = decoder.decode<WebCore::IntSize>();
    auto frameRateRanges = decoder.decode<Vector<WebCore::FrameRateRange>>();
    auto minZoom = decoder.decode<double>();
    auto maxZoom = decoder.decode<double>();
    auto isEfficient = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::VideoPresetData {
            WTFMove(*size),
            WTFMove(*frameRateRanges),
            WTFMove(*minZoom),
            WTFMove(*maxZoom),
            WTFMove(*isEfficient)
        }
    };
}

#endif

#if ENABLE(MEDIA_STREAM)
void ArgumentCoder<WebCore::RealtimeMediaSourceSupportedConstraints>::encode(Encoder& encoder, const WebCore::RealtimeMediaSourceSupportedConstraints& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsWidth())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsHeight())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsAspectRatio())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsFrameRate())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsFacingMode())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsVolume())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsSampleRate())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsSampleSize())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsEchoCancellation())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsDeviceId())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsGroupId())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsDisplaySurface())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsLogicalSurface())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsFocusDistance())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsWhiteBalanceMode())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsZoom())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsTorch())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsBackgroundBlur())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsPowerEfficient())>, bool>);

    encoder << instance.supportsWidth();
    encoder << instance.supportsHeight();
    encoder << instance.supportsAspectRatio();
    encoder << instance.supportsFrameRate();
    encoder << instance.supportsFacingMode();
    encoder << instance.supportsVolume();
    encoder << instance.supportsSampleRate();
    encoder << instance.supportsSampleSize();
    encoder << instance.supportsEchoCancellation();
    encoder << instance.supportsDeviceId();
    encoder << instance.supportsGroupId();
    encoder << instance.supportsDisplaySurface();
    encoder << instance.supportsLogicalSurface();
    encoder << instance.supportsFocusDistance();
    encoder << instance.supportsWhiteBalanceMode();
    encoder << instance.supportsZoom();
    encoder << instance.supportsTorch();
    encoder << instance.supportsBackgroundBlur();
    encoder << instance.supportsPowerEfficient();
}

std::optional<WebCore::RealtimeMediaSourceSupportedConstraints> ArgumentCoder<WebCore::RealtimeMediaSourceSupportedConstraints>::decode(Decoder& decoder)
{
    auto supportsWidth = decoder.decode<bool>();
    auto supportsHeight = decoder.decode<bool>();
    auto supportsAspectRatio = decoder.decode<bool>();
    auto supportsFrameRate = decoder.decode<bool>();
    auto supportsFacingMode = decoder.decode<bool>();
    auto supportsVolume = decoder.decode<bool>();
    auto supportsSampleRate = decoder.decode<bool>();
    auto supportsSampleSize = decoder.decode<bool>();
    auto supportsEchoCancellation = decoder.decode<bool>();
    auto supportsDeviceId = decoder.decode<bool>();
    auto supportsGroupId = decoder.decode<bool>();
    auto supportsDisplaySurface = decoder.decode<bool>();
    auto supportsLogicalSurface = decoder.decode<bool>();
    auto supportsFocusDistance = decoder.decode<bool>();
    auto supportsWhiteBalanceMode = decoder.decode<bool>();
    auto supportsZoom = decoder.decode<bool>();
    auto supportsTorch = decoder.decode<bool>();
    auto supportsBackgroundBlur = decoder.decode<bool>();
    auto supportsPowerEfficient = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::RealtimeMediaSourceSupportedConstraints {
            WTFMove(*supportsWidth),
            WTFMove(*supportsHeight),
            WTFMove(*supportsAspectRatio),
            WTFMove(*supportsFrameRate),
            WTFMove(*supportsFacingMode),
            WTFMove(*supportsVolume),
            WTFMove(*supportsSampleRate),
            WTFMove(*supportsSampleSize),
            WTFMove(*supportsEchoCancellation),
            WTFMove(*supportsDeviceId),
            WTFMove(*supportsGroupId),
            WTFMove(*supportsDisplaySurface),
            WTFMove(*supportsLogicalSurface),
            WTFMove(*supportsFocusDistance),
            WTFMove(*supportsWhiteBalanceMode),
            WTFMove(*supportsZoom),
            WTFMove(*supportsTorch),
            WTFMove(*supportsBackgroundBlur),
            WTFMove(*supportsPowerEfficient)
        }
    };
}

#endif

#if ENABLE(MEDIA_STREAM)
void ArgumentCoder<WebCore::RealtimeMediaSourceSettings>::encode(Encoder& encoder, const WebCore::RealtimeMediaSourceSettings& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.width())>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.height())>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameRate())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.facingMode())>, WebCore::VideoFacingMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.volume())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sampleRate())>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sampleSize())>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.echoCancellation())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.deviceId())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.groupId())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.displaySurface())>, WebCore::DisplaySurfaceType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.logicalSurface())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.whiteBalanceMode())>, WebCore::MeteringMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.zoom())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.torch())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.backgroundBlur())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.powerEfficient())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportedConstraints())>, WebCore::RealtimeMediaSourceSupportedConstraints>);

    encoder << instance.width();
    encoder << instance.height();
    encoder << instance.frameRate();
    encoder << instance.facingMode();
    encoder << instance.volume();
    encoder << instance.sampleRate();
    encoder << instance.sampleSize();
    encoder << instance.echoCancellation();
    encoder << instance.deviceId();
    encoder << instance.groupId();
    encoder << instance.label();
    encoder << instance.displaySurface();
    encoder << instance.logicalSurface();
    encoder << instance.whiteBalanceMode();
    encoder << instance.zoom();
    encoder << instance.torch();
    encoder << instance.backgroundBlur();
    encoder << instance.powerEfficient();
    encoder << instance.supportedConstraints();
}

std::optional<WebCore::RealtimeMediaSourceSettings> ArgumentCoder<WebCore::RealtimeMediaSourceSettings>::decode(Decoder& decoder)
{
    auto width = decoder.decode<uint32_t>();
    auto height = decoder.decode<uint32_t>();
    auto frameRate = decoder.decode<float>();
    auto facingMode = decoder.decode<WebCore::VideoFacingMode>();
    auto volume = decoder.decode<double>();
    auto sampleRate = decoder.decode<uint32_t>();
    auto sampleSize = decoder.decode<uint32_t>();
    auto echoCancellation = decoder.decode<bool>();
    auto deviceId = decoder.decode<String>();
    auto groupId = decoder.decode<String>();
    auto label = decoder.decode<String>();
    auto displaySurface = decoder.decode<WebCore::DisplaySurfaceType>();
    auto logicalSurface = decoder.decode<bool>();
    auto whiteBalanceMode = decoder.decode<WebCore::MeteringMode>();
    auto zoom = decoder.decode<double>();
    auto torch = decoder.decode<bool>();
    auto backgroundBlur = decoder.decode<bool>();
    auto powerEfficient = decoder.decode<bool>();
    auto supportedConstraints = decoder.decode<WebCore::RealtimeMediaSourceSupportedConstraints>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::RealtimeMediaSourceSettings {
            WTFMove(*width),
            WTFMove(*height),
            WTFMove(*frameRate),
            WTFMove(*facingMode),
            WTFMove(*volume),
            WTFMove(*sampleRate),
            WTFMove(*sampleSize),
            WTFMove(*echoCancellation),
            WTFMove(*deviceId),
            WTFMove(*groupId),
            WTFMove(*label),
            WTFMove(*displaySurface),
            WTFMove(*logicalSurface),
            WTFMove(*whiteBalanceMode),
            WTFMove(*zoom),
            WTFMove(*torch),
            WTFMove(*backgroundBlur),
            WTFMove(*powerEfficient),
            WTFMove(*supportedConstraints)
        }
    };
}

#endif

#if ENABLE(MEDIA_STREAM)
void ArgumentCoder<WebCore::CaptureDevice>::encode(Encoder& encoder, const WebCore::CaptureDevice& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.persistentId())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebCore::CaptureDevice::DeviceType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.groupId())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.enabled())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isDefault())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isMockDevice())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isEphemeral())>, bool>);

    encoder << instance.persistentId();
    encoder << instance.type();
    encoder << instance.label();
    encoder << instance.groupId();
    encoder << instance.enabled();
    encoder << instance.isDefault();
    encoder << instance.isMockDevice();
    encoder << instance.isEphemeral();
}

std::optional<WebCore::CaptureDevice> ArgumentCoder<WebCore::CaptureDevice>::decode(Decoder& decoder)
{
    auto persistentId = decoder.decode<String>();
    auto type = decoder.decode<WebCore::CaptureDevice::DeviceType>();
    auto label = decoder.decode<String>();
    auto groupId = decoder.decode<String>();
    auto enabled = decoder.decode<bool>();
    auto isDefault = decoder.decode<bool>();
    auto isMockDevice = decoder.decode<bool>();
    auto isEphemeral = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CaptureDevice {
            WTFMove(*persistentId),
            WTFMove(*type),
            WTFMove(*label),
            WTFMove(*groupId),
            WTFMove(*enabled),
            WTFMove(*isDefault),
            WTFMove(*isMockDevice),
            WTFMove(*isEphemeral)
        }
    };
}

#endif

#if ENABLE(MEDIA_STREAM)
void ArgumentCoder<WebCore::CaptureDeviceWithCapabilities>::encode(Encoder& encoder, const WebCore::CaptureDeviceWithCapabilities& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.device)>, WebCore::CaptureDevice>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.capabilities)>, WebCore::RealtimeMediaSourceCapabilities>);
    struct ShouldBeSameSizeAsCaptureDeviceWithCapabilities : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::CaptureDeviceWithCapabilities>, false> {
        WebCore::CaptureDevice device;
        WebCore::RealtimeMediaSourceCapabilities capabilities;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCaptureDeviceWithCapabilities) == sizeof(WebCore::CaptureDeviceWithCapabilities));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::CaptureDeviceWithCapabilities, device)
        , offsetof(WebCore::CaptureDeviceWithCapabilities, capabilities)
    >::value);

    encoder << instance.device;
    encoder << instance.capabilities;
}

std::optional<WebCore::CaptureDeviceWithCapabilities> ArgumentCoder<WebCore::CaptureDeviceWithCapabilities>::decode(Decoder& decoder)
{
    auto device = decoder.decode<WebCore::CaptureDevice>();
    auto capabilities = decoder.decode<WebCore::RealtimeMediaSourceCapabilities>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CaptureDeviceWithCapabilities {
            WTFMove(*device),
            WTFMove(*capabilities)
        }
    };
}

#endif

#if ENABLE(MEDIA_STREAM)
void ArgumentCoder<WebCore::DoubleCapabilityRange>::encode(Encoder& encoder, const WebCore::DoubleCapabilityRange& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.min())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.max())>, double>);

    encoder << instance.min();
    encoder << instance.max();
}

std::optional<WebCore::DoubleCapabilityRange> ArgumentCoder<WebCore::DoubleCapabilityRange>::decode(Decoder& decoder)
{
    auto min = decoder.decode<double>();
    auto max = decoder.decode<double>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(min <= max))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DoubleCapabilityRange {
            WTFMove(*min),
            WTFMove(*max)
        }
    };
}

#endif

#if ENABLE(MEDIA_STREAM)
void ArgumentCoder<WebCore::LongCapabilityRange>::encode(Encoder& encoder, const WebCore::LongCapabilityRange& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.min())>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.max())>, int>);

    encoder << instance.min();
    encoder << instance.max();
}

std::optional<WebCore::LongCapabilityRange> ArgumentCoder<WebCore::LongCapabilityRange>::decode(Decoder& decoder)
{
    auto min = decoder.decode<int>();
    auto max = decoder.decode<int>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(min <= max))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::LongCapabilityRange {
            WTFMove(*min),
            WTFMove(*max)
        }
    };
}

#endif

#if ENABLE(MEDIA_STREAM)
void ArgumentCoder<WebCore::RealtimeMediaSourceCapabilities>::encode(Encoder& encoder, const WebCore::RealtimeMediaSourceCapabilities& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.width())>, WebCore::LongCapabilityRange>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.height())>, WebCore::LongCapabilityRange>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.aspectRatio())>, WebCore::DoubleCapabilityRange>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameRate())>, WebCore::DoubleCapabilityRange>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.facingMode())>, Vector<WebCore::VideoFacingMode>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.volume())>, WebCore::DoubleCapabilityRange>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sampleRate())>, WebCore::LongCapabilityRange>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sampleSize())>, WebCore::LongCapabilityRange>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.echoCancellation())>, WebCore::RealtimeMediaSourceCapabilities::EchoCancellation>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.deviceId())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.groupId())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.focusDistance())>, WebCore::DoubleCapabilityRange>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.whiteBalanceModes())>, Vector<WebCore::MeteringMode>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.zoom())>, WebCore::DoubleCapabilityRange>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.torch())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.backgroundBlur())>, WebCore::RealtimeMediaSourceCapabilities::BackgroundBlur>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.powerEfficient())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportedConstraints())>, WebCore::RealtimeMediaSourceSupportedConstraints>);

    encoder << instance.width();
    encoder << instance.height();
    encoder << instance.aspectRatio();
    encoder << instance.frameRate();
    encoder << instance.facingMode();
    encoder << instance.volume();
    encoder << instance.sampleRate();
    encoder << instance.sampleSize();
    encoder << instance.echoCancellation();
    encoder << instance.deviceId();
    encoder << instance.groupId();
    encoder << instance.focusDistance();
    encoder << instance.whiteBalanceModes();
    encoder << instance.zoom();
    encoder << instance.torch();
    encoder << instance.backgroundBlur();
    encoder << instance.powerEfficient();
    encoder << instance.supportedConstraints();
}

std::optional<WebCore::RealtimeMediaSourceCapabilities> ArgumentCoder<WebCore::RealtimeMediaSourceCapabilities>::decode(Decoder& decoder)
{
    auto width = decoder.decode<WebCore::LongCapabilityRange>();
    auto height = decoder.decode<WebCore::LongCapabilityRange>();
    auto aspectRatio = decoder.decode<WebCore::DoubleCapabilityRange>();
    auto frameRate = decoder.decode<WebCore::DoubleCapabilityRange>();
    auto facingMode = decoder.decode<Vector<WebCore::VideoFacingMode>>();
    auto volume = decoder.decode<WebCore::DoubleCapabilityRange>();
    auto sampleRate = decoder.decode<WebCore::LongCapabilityRange>();
    auto sampleSize = decoder.decode<WebCore::LongCapabilityRange>();
    auto echoCancellation = decoder.decode<WebCore::RealtimeMediaSourceCapabilities::EchoCancellation>();
    auto deviceId = decoder.decode<String>();
    auto groupId = decoder.decode<String>();
    auto focusDistance = decoder.decode<WebCore::DoubleCapabilityRange>();
    auto whiteBalanceModes = decoder.decode<Vector<WebCore::MeteringMode>>();
    auto zoom = decoder.decode<WebCore::DoubleCapabilityRange>();
    auto torch = decoder.decode<bool>();
    auto backgroundBlur = decoder.decode<WebCore::RealtimeMediaSourceCapabilities::BackgroundBlur>();
    auto powerEfficient = decoder.decode<bool>();
    auto supportedConstraints = decoder.decode<WebCore::RealtimeMediaSourceSupportedConstraints>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::RealtimeMediaSourceCapabilities {
            WTFMove(*width),
            WTFMove(*height),
            WTFMove(*aspectRatio),
            WTFMove(*frameRate),
            WTFMove(*facingMode),
            WTFMove(*volume),
            WTFMove(*sampleRate),
            WTFMove(*sampleSize),
            WTFMove(*echoCancellation),
            WTFMove(*deviceId),
            WTFMove(*groupId),
            WTFMove(*focusDistance),
            WTFMove(*whiteBalanceModes),
            WTFMove(*zoom),
            WTFMove(*torch),
            WTFMove(*backgroundBlur),
            WTFMove(*powerEfficient),
            WTFMove(*supportedConstraints)
        }
    };
}

#endif

#if ENABLE(MEDIA_STREAM)
void ArgumentCoder<WebCore::RealtimeMediaSourceCenter::ValidDevices>::encode(Encoder& encoder, const WebCore::RealtimeMediaSourceCenter::ValidDevices& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.audioDevices)>, Vector<WebCore::CaptureDevice>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.videoDevices)>, Vector<WebCore::CaptureDevice>>);
    struct ShouldBeSameSizeAsValidDevices : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::RealtimeMediaSourceCenter::ValidDevices>, false> {
        Vector<WebCore::CaptureDevice> audioDevices;
        Vector<WebCore::CaptureDevice> videoDevices;
    };
    static_assert(sizeof(ShouldBeSameSizeAsValidDevices) == sizeof(WebCore::RealtimeMediaSourceCenter::ValidDevices));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::RealtimeMediaSourceCenter::ValidDevices, audioDevices)
        , offsetof(WebCore::RealtimeMediaSourceCenter::ValidDevices, videoDevices)
    >::value);

    encoder << instance.audioDevices;
    encoder << instance.videoDevices;
}

std::optional<WebCore::RealtimeMediaSourceCenter::ValidDevices> ArgumentCoder<WebCore::RealtimeMediaSourceCenter::ValidDevices>::decode(Decoder& decoder)
{
    auto audioDevices = decoder.decode<Vector<WebCore::CaptureDevice>>();
    auto videoDevices = decoder.decode<Vector<WebCore::CaptureDevice>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::RealtimeMediaSourceCenter::ValidDevices {
            WTFMove(*audioDevices),
            WTFMove(*videoDevices)
        }
    };
}

#endif

void ArgumentCoder<WebCore::PlatformVideoColorSpace>::encode(Encoder& encoder, const WebCore::PlatformVideoColorSpace& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.primaries)>, std::optional<WebCore::PlatformVideoColorPrimaries>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.transfer)>, std::optional<WebCore::PlatformVideoTransferCharacteristics>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.matrix)>, std::optional<WebCore::PlatformVideoMatrixCoefficients>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fullRange)>, std::optional<bool>>);
    struct ShouldBeSameSizeAsPlatformVideoColorSpace : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PlatformVideoColorSpace>, false> {
        std::optional<WebCore::PlatformVideoColorPrimaries> primaries;
        std::optional<WebCore::PlatformVideoTransferCharacteristics> transfer;
        std::optional<WebCore::PlatformVideoMatrixCoefficients> matrix;
        std::optional<bool> fullRange;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPlatformVideoColorSpace) == sizeof(WebCore::PlatformVideoColorSpace));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PlatformVideoColorSpace, primaries)
        , offsetof(WebCore::PlatformVideoColorSpace, transfer)
        , offsetof(WebCore::PlatformVideoColorSpace, matrix)
        , offsetof(WebCore::PlatformVideoColorSpace, fullRange)
    >::value);

    encoder << instance.primaries;
    encoder << instance.transfer;
    encoder << instance.matrix;
    encoder << instance.fullRange;
}

void ArgumentCoder<WebCore::PlatformVideoColorSpace>::encode(StreamConnectionEncoder& encoder, const WebCore::PlatformVideoColorSpace& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.primaries)>, std::optional<WebCore::PlatformVideoColorPrimaries>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.transfer)>, std::optional<WebCore::PlatformVideoTransferCharacteristics>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.matrix)>, std::optional<WebCore::PlatformVideoMatrixCoefficients>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fullRange)>, std::optional<bool>>);
    struct ShouldBeSameSizeAsPlatformVideoColorSpace : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PlatformVideoColorSpace>, false> {
        std::optional<WebCore::PlatformVideoColorPrimaries> primaries;
        std::optional<WebCore::PlatformVideoTransferCharacteristics> transfer;
        std::optional<WebCore::PlatformVideoMatrixCoefficients> matrix;
        std::optional<bool> fullRange;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPlatformVideoColorSpace) == sizeof(WebCore::PlatformVideoColorSpace));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PlatformVideoColorSpace, primaries)
        , offsetof(WebCore::PlatformVideoColorSpace, transfer)
        , offsetof(WebCore::PlatformVideoColorSpace, matrix)
        , offsetof(WebCore::PlatformVideoColorSpace, fullRange)
    >::value);

    encoder << instance.primaries;
    encoder << instance.transfer;
    encoder << instance.matrix;
    encoder << instance.fullRange;
}

std::optional<WebCore::PlatformVideoColorSpace> ArgumentCoder<WebCore::PlatformVideoColorSpace>::decode(Decoder& decoder)
{
    auto primaries = decoder.decode<std::optional<WebCore::PlatformVideoColorPrimaries>>();
    auto transfer = decoder.decode<std::optional<WebCore::PlatformVideoTransferCharacteristics>>();
    auto matrix = decoder.decode<std::optional<WebCore::PlatformVideoMatrixCoefficients>>();
    auto fullRange = decoder.decode<std::optional<bool>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PlatformVideoColorSpace {
            WTFMove(*primaries),
            WTFMove(*transfer),
            WTFMove(*matrix),
            WTFMove(*fullRange)
        }
    };
}

#if ENABLE(VIDEO)
void ArgumentCoder<WebCore::SpatialVideoMetadata>::encode(Encoder& encoder, const WebCore::SpatialVideoMetadata& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size)>, WebCore::IntSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.horizontalFOVDegrees)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.baseline)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.disparityAdjustment)>, float>);
    struct ShouldBeSameSizeAsSpatialVideoMetadata : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SpatialVideoMetadata>, false> {
        WebCore::IntSize size;
        float horizontalFOVDegrees;
        float baseline;
        float disparityAdjustment;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSpatialVideoMetadata) == sizeof(WebCore::SpatialVideoMetadata));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SpatialVideoMetadata, size)
        , offsetof(WebCore::SpatialVideoMetadata, horizontalFOVDegrees)
        , offsetof(WebCore::SpatialVideoMetadata, baseline)
        , offsetof(WebCore::SpatialVideoMetadata, disparityAdjustment)
    >::value);

    encoder << instance.size;
    encoder << instance.horizontalFOVDegrees;
    encoder << instance.baseline;
    encoder << instance.disparityAdjustment;
}

std::optional<WebCore::SpatialVideoMetadata> ArgumentCoder<WebCore::SpatialVideoMetadata>::decode(Decoder& decoder)
{
    auto size = decoder.decode<WebCore::IntSize>();
    auto horizontalFOVDegrees = decoder.decode<float>();
    auto baseline = decoder.decode<float>();
    auto disparityAdjustment = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SpatialVideoMetadata {
            WTFMove(*size),
            WTFMove(*horizontalFOVDegrees),
            WTFMove(*baseline),
            WTFMove(*disparityAdjustment)
        }
    };
}

#endif

#if ENABLE(VIDEO)
void ArgumentCoder<WebCore::VideoProjectionMetadata>::encode(Encoder& encoder, const WebCore::VideoProjectionMetadata& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.kind)>, WebCore::VideoProjectionMetadataKind>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.parameters)>, RefPtr<WTF::JSONImpl::Value>>);
    struct ShouldBeSameSizeAsVideoProjectionMetadata : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::VideoProjectionMetadata>, false> {
        WebCore::VideoProjectionMetadataKind kind;
        RefPtr<WTF::JSONImpl::Value> parameters;
    };
    static_assert(sizeof(ShouldBeSameSizeAsVideoProjectionMetadata) == sizeof(WebCore::VideoProjectionMetadata));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::VideoProjectionMetadata, kind)
        , offsetof(WebCore::VideoProjectionMetadata, parameters)
    >::value);

    encoder << instance.kind;
    encoder << instance.parameters;
}

std::optional<WebCore::VideoProjectionMetadata> ArgumentCoder<WebCore::VideoProjectionMetadata>::decode(Decoder& decoder)
{
    auto kind = decoder.decode<WebCore::VideoProjectionMetadataKind>();
    auto parameters = decoder.decode<RefPtr<WTF::JSONImpl::Value>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::VideoProjectionMetadata {
            WTFMove(*kind),
            WTFMove(*parameters)
        }
    };
}

#endif

#if ENABLE(VIDEO)
void ArgumentCoder<WebCore::PlatformTrackConfiguration>::encode(Encoder& encoder, const WebCore::PlatformTrackConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.codec)>, String>);
    struct ShouldBeSameSizeAsPlatformTrackConfiguration : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PlatformTrackConfiguration>, false> {
        String codec;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPlatformTrackConfiguration) == sizeof(WebCore::PlatformTrackConfiguration));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PlatformTrackConfiguration, codec)
    >::value);

    encoder << instance.codec;
}

std::optional<WebCore::PlatformTrackConfiguration> ArgumentCoder<WebCore::PlatformTrackConfiguration>::decode(Decoder& decoder)
{
    auto codec = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PlatformTrackConfiguration {
            WTFMove(*codec)
        }
    };
}

#endif

#if ENABLE(VIDEO)
void ArgumentCoder<WebCore::PlatformAudioTrackConfiguration>::encode(Encoder& encoder, const WebCore::PlatformAudioTrackConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.codec)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PlatformTrackConfiguration, codec)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sampleRate)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.numberOfChannels)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bitrate)>, uint64_t>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PlatformAudioTrackConfiguration, sampleRate)
        , offsetof(WebCore::PlatformAudioTrackConfiguration, numberOfChannels)
        , offsetof(WebCore::PlatformAudioTrackConfiguration, bitrate)
    >::value);

    encoder << instance.codec;
    encoder << instance.sampleRate;
    encoder << instance.numberOfChannels;
    encoder << instance.bitrate;
}

std::optional<WebCore::PlatformAudioTrackConfiguration> ArgumentCoder<WebCore::PlatformAudioTrackConfiguration>::decode(Decoder& decoder)
{
    auto codec = decoder.decode<String>();
    auto sampleRate = decoder.decode<uint32_t>();
    auto numberOfChannels = decoder.decode<uint32_t>();
    auto bitrate = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PlatformAudioTrackConfiguration {
            WebCore::PlatformTrackConfiguration {
                WTFMove(*codec)
            },
            WTFMove(*sampleRate),
            WTFMove(*numberOfChannels),
            WTFMove(*bitrate)
        }
    };
}

#endif

#if ENABLE(VIDEO)
void ArgumentCoder<WebCore::PlatformVideoTrackConfiguration>::encode(Encoder& encoder, const WebCore::PlatformVideoTrackConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.codec)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PlatformTrackConfiguration, codec)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.width)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.height)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorSpace)>, WebCore::PlatformVideoColorSpace>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.framerate)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bitrate)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.spatialVideoMetadata)>, std::optional<WebCore::SpatialVideoMetadata>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.videoProjectionMetadata)>, std::optional<WebCore::VideoProjectionMetadata>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PlatformVideoTrackConfiguration, width)
        , offsetof(WebCore::PlatformVideoTrackConfiguration, height)
        , offsetof(WebCore::PlatformVideoTrackConfiguration, colorSpace)
        , offsetof(WebCore::PlatformVideoTrackConfiguration, framerate)
        , offsetof(WebCore::PlatformVideoTrackConfiguration, bitrate)
        , offsetof(WebCore::PlatformVideoTrackConfiguration, spatialVideoMetadata)
        , offsetof(WebCore::PlatformVideoTrackConfiguration, videoProjectionMetadata)
    >::value);

    encoder << instance.codec;
    encoder << instance.width;
    encoder << instance.height;
    encoder << instance.colorSpace;
    encoder << instance.framerate;
    encoder << instance.bitrate;
    encoder << instance.spatialVideoMetadata;
    encoder << instance.videoProjectionMetadata;
}

std::optional<WebCore::PlatformVideoTrackConfiguration> ArgumentCoder<WebCore::PlatformVideoTrackConfiguration>::decode(Decoder& decoder)
{
    auto codec = decoder.decode<String>();
    auto width = decoder.decode<uint32_t>();
    auto height = decoder.decode<uint32_t>();
    auto colorSpace = decoder.decode<WebCore::PlatformVideoColorSpace>();
    auto framerate = decoder.decode<double>();
    auto bitrate = decoder.decode<uint64_t>();
    auto spatialVideoMetadata = decoder.decode<std::optional<WebCore::SpatialVideoMetadata>>();
    auto videoProjectionMetadata = decoder.decode<std::optional<WebCore::VideoProjectionMetadata>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PlatformVideoTrackConfiguration {
            WebCore::PlatformTrackConfiguration {
                WTFMove(*codec)
            },
            WTFMove(*width),
            WTFMove(*height),
            WTFMove(*colorSpace),
            WTFMove(*framerate),
            WTFMove(*bitrate),
            WTFMove(*spatialVideoMetadata),
            WTFMove(*videoProjectionMetadata)
        }
    };
}

#endif

#if ENABLE(WEB_RTC)
void ArgumentCoder<WebCore::RTCDataChannelInit>::encode(Encoder& encoder, const WebCore::RTCDataChannelInit& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ordered)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxPacketLifeTime)>, std::optional<unsigned short>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxRetransmits)>, std::optional<unsigned short>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.protocol)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.negotiated)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.id)>, std::optional<unsigned short>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.priority)>, WebCore::RTCPriorityType>);
    struct ShouldBeSameSizeAsRTCDataChannelInit : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::RTCDataChannelInit>, false> {
        std::optional<bool> ordered;
        std::optional<unsigned short> maxPacketLifeTime;
        std::optional<unsigned short> maxRetransmits;
        String protocol;
        std::optional<bool> negotiated;
        std::optional<unsigned short> id;
        WebCore::RTCPriorityType priority;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRTCDataChannelInit) == sizeof(WebCore::RTCDataChannelInit));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::RTCDataChannelInit, ordered)
        , offsetof(WebCore::RTCDataChannelInit, maxPacketLifeTime)
        , offsetof(WebCore::RTCDataChannelInit, maxRetransmits)
        , offsetof(WebCore::RTCDataChannelInit, protocol)
        , offsetof(WebCore::RTCDataChannelInit, negotiated)
        , offsetof(WebCore::RTCDataChannelInit, id)
        , offsetof(WebCore::RTCDataChannelInit, priority)
    >::value);

    encoder << instance.ordered;
    encoder << instance.maxPacketLifeTime;
    encoder << instance.maxRetransmits;
    encoder << instance.protocol;
    encoder << instance.negotiated;
    encoder << instance.id;
    encoder << instance.priority;
}

std::optional<WebCore::RTCDataChannelInit> ArgumentCoder<WebCore::RTCDataChannelInit>::decode(Decoder& decoder)
{
    auto ordered = decoder.decode<std::optional<bool>>();
    auto maxPacketLifeTime = decoder.decode<std::optional<unsigned short>>();
    auto maxRetransmits = decoder.decode<std::optional<unsigned short>>();
    auto protocol = decoder.decode<String>();
    auto negotiated = decoder.decode<std::optional<bool>>();
    auto id = decoder.decode<std::optional<unsigned short>>();
    auto priority = decoder.decode<WebCore::RTCPriorityType>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::RTCDataChannelInit {
            WTFMove(*ordered),
            WTFMove(*maxPacketLifeTime),
            WTFMove(*maxRetransmits),
            WTFMove(*protocol),
            WTFMove(*negotiated),
            WTFMove(*id),
            WTFMove(*priority)
        }
    };
}

#endif

#if ENABLE(CONTENT_EXTENSIONS)
void ArgumentCoder<WebCore::ContentRuleListResults::Result>::encode(Encoder& encoder, const WebCore::ContentRuleListResults::Result& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.blockedLoad)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.madeHTTPS)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.blockedCookies)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.modifiedHeaders)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.redirected)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.notifications)>, Vector<String>>);
    struct ShouldBeSameSizeAsResult : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ContentRuleListResults::Result>, false> {
        bool blockedLoad;
        bool madeHTTPS;
        bool blockedCookies;
        bool modifiedHeaders;
        bool redirected;
        Vector<String> notifications;
    };
    static_assert(sizeof(ShouldBeSameSizeAsResult) == sizeof(WebCore::ContentRuleListResults::Result));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ContentRuleListResults::Result, blockedLoad)
        , offsetof(WebCore::ContentRuleListResults::Result, madeHTTPS)
        , offsetof(WebCore::ContentRuleListResults::Result, blockedCookies)
        , offsetof(WebCore::ContentRuleListResults::Result, modifiedHeaders)
        , offsetof(WebCore::ContentRuleListResults::Result, redirected)
        , offsetof(WebCore::ContentRuleListResults::Result, notifications)
    >::value);

    encoder << instance.blockedLoad;
    encoder << instance.madeHTTPS;
    encoder << instance.blockedCookies;
    encoder << instance.modifiedHeaders;
    encoder << instance.redirected;
    encoder << instance.notifications;
}

std::optional<WebCore::ContentRuleListResults::Result> ArgumentCoder<WebCore::ContentRuleListResults::Result>::decode(Decoder& decoder)
{
    auto blockedLoad = decoder.decode<bool>();
    auto madeHTTPS = decoder.decode<bool>();
    auto blockedCookies = decoder.decode<bool>();
    auto modifiedHeaders = decoder.decode<bool>();
    auto redirected = decoder.decode<bool>();
    auto notifications = decoder.decode<Vector<String>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ContentRuleListResults::Result {
            WTFMove(*blockedLoad),
            WTFMove(*madeHTTPS),
            WTFMove(*blockedCookies),
            WTFMove(*modifiedHeaders),
            WTFMove(*redirected),
            WTFMove(*notifications)
        }
    };
}

#endif

#if ENABLE(CONTENT_EXTENSIONS)
void ArgumentCoder<WebCore::ContentRuleListResults::Summary>::encode(Encoder& encoder, const WebCore::ContentRuleListResults::Summary& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.blockedLoad)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.madeHTTPS)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.blockedCookies)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasNotifications)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.redirectedPriorToBlock)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.modifyHeadersActions)>, Vector<WebCore::ContentExtensions::ModifyHeadersAction>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.redirectActions)>, Vector<std::pair<WebCore::ContentExtensions::RedirectAction, URL>>>);
    struct ShouldBeSameSizeAsSummary : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ContentRuleListResults::Summary>, false> {
        bool blockedLoad;
        bool madeHTTPS;
        bool blockedCookies;
        bool hasNotifications;
        bool redirectedPriorToBlock;
        Vector<WebCore::ContentExtensions::ModifyHeadersAction> modifyHeadersActions;
        Vector<std::pair<WebCore::ContentExtensions::RedirectAction, URL>> redirectActions;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSummary) == sizeof(WebCore::ContentRuleListResults::Summary));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ContentRuleListResults::Summary, blockedLoad)
        , offsetof(WebCore::ContentRuleListResults::Summary, madeHTTPS)
        , offsetof(WebCore::ContentRuleListResults::Summary, blockedCookies)
        , offsetof(WebCore::ContentRuleListResults::Summary, hasNotifications)
        , offsetof(WebCore::ContentRuleListResults::Summary, redirectedPriorToBlock)
        , offsetof(WebCore::ContentRuleListResults::Summary, modifyHeadersActions)
        , offsetof(WebCore::ContentRuleListResults::Summary, redirectActions)
    >::value);

    encoder << instance.blockedLoad;
    encoder << instance.madeHTTPS;
    encoder << instance.blockedCookies;
    encoder << instance.hasNotifications;
    encoder << instance.redirectedPriorToBlock;
}

std::optional<WebCore::ContentRuleListResults::Summary> ArgumentCoder<WebCore::ContentRuleListResults::Summary>::decode(Decoder& decoder)
{
    auto blockedLoad = decoder.decode<bool>();
    auto madeHTTPS = decoder.decode<bool>();
    auto blockedCookies = decoder.decode<bool>();
    auto hasNotifications = decoder.decode<bool>();
    auto redirectedPriorToBlock = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ContentRuleListResults::Summary {
            WTFMove(*blockedLoad),
            WTFMove(*madeHTTPS),
            WTFMove(*blockedCookies),
            WTFMove(*hasNotifications),
            WTFMove(*redirectedPriorToBlock)
        }
    };
}

#endif

#if ENABLE(CONTENT_EXTENSIONS)
void ArgumentCoder<WebCore::ContentRuleListResults>::encode(Encoder& encoder, const WebCore::ContentRuleListResults& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.summary)>, WebCore::ContentRuleListResults::Summary>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.results)>, Vector<std::pair<String, WebCore::ContentRuleListResults::Result>>>);
    struct ShouldBeSameSizeAsContentRuleListResults : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ContentRuleListResults>, false> {
        WebCore::ContentRuleListResults::Summary summary;
        Vector<std::pair<String, WebCore::ContentRuleListResults::Result>> results;
    };
    static_assert(sizeof(ShouldBeSameSizeAsContentRuleListResults) == sizeof(WebCore::ContentRuleListResults));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ContentRuleListResults, summary)
        , offsetof(WebCore::ContentRuleListResults, results)
    >::value);

    encoder << instance.summary;
    encoder << instance.results;
}

std::optional<WebCore::ContentRuleListResults> ArgumentCoder<WebCore::ContentRuleListResults>::decode(Decoder& decoder)
{
    auto summary = decoder.decode<WebCore::ContentRuleListResults::Summary>();
    auto results = decoder.decode<Vector<std::pair<String, WebCore::ContentRuleListResults::Result>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ContentRuleListResults {
            WTFMove(*summary),
            WTFMove(*results)
        }
    };
}

#endif

void ArgumentCoder<WebCore::COEPInheritenceViolationReportBody>::encode(Encoder& encoder, const WebCore::COEPInheritenceViolationReportBody& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_disposition)>, WebCore::COEPDisposition>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_blockedURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_type)>, String>);
    struct ShouldBeSameSizeAsCOEPInheritenceViolationReportBody : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::COEPInheritenceViolationReportBody>, true> {
        WebCore::COEPDisposition m_disposition;
        URL m_blockedURL;
        String m_type;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCOEPInheritenceViolationReportBody) == sizeof(WebCore::COEPInheritenceViolationReportBody));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::COEPInheritenceViolationReportBody, m_disposition)
        , offsetof(WebCore::COEPInheritenceViolationReportBody, m_blockedURL)
        , offsetof(WebCore::COEPInheritenceViolationReportBody, m_type)
    >::value);

    encoder << instance.m_disposition;
    encoder << instance.m_blockedURL;
    encoder << instance.m_type;
}

std::optional<Ref<WebCore::COEPInheritenceViolationReportBody>> ArgumentCoder<WebCore::COEPInheritenceViolationReportBody>::decode(Decoder& decoder)
{
    auto m_disposition = decoder.decode<WebCore::COEPDisposition>();
    auto m_blockedURL = decoder.decode<URL>();
    auto m_type = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::COEPInheritenceViolationReportBody::create(
            WTFMove(*m_disposition),
            WTFMove(*m_blockedURL),
            WTFMove(*m_type)
        )
    };
}

void ArgumentCoder<WebCore::CORPViolationReportBody>::encode(Encoder& encoder, const WebCore::CORPViolationReportBody& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_disposition)>, WebCore::COEPDisposition>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_blockedURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_destination)>, WebCore::FetchOptionsDestination>);
    struct ShouldBeSameSizeAsCORPViolationReportBody : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::CORPViolationReportBody>, true> {
        WebCore::COEPDisposition m_disposition;
        URL m_blockedURL;
        WebCore::FetchOptionsDestination m_destination;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCORPViolationReportBody) == sizeof(WebCore::CORPViolationReportBody));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::CORPViolationReportBody, m_disposition)
        , offsetof(WebCore::CORPViolationReportBody, m_blockedURL)
        , offsetof(WebCore::CORPViolationReportBody, m_destination)
    >::value);

    encoder << instance.m_disposition;
    encoder << instance.m_blockedURL;
    encoder << instance.m_destination;
}

std::optional<Ref<WebCore::CORPViolationReportBody>> ArgumentCoder<WebCore::CORPViolationReportBody>::decode(Decoder& decoder)
{
    auto m_disposition = decoder.decode<WebCore::COEPDisposition>();
    auto m_blockedURL = decoder.decode<URL>();
    auto m_destination = decoder.decode<WebCore::FetchOptionsDestination>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CORPViolationReportBody::create(
            WTFMove(*m_disposition),
            WTFMove(*m_blockedURL),
            WTFMove(*m_destination)
        )
    };
}

enum class WebCore_ReportBody_Subclass : IPC::EncodedVariantIndex {
    CSPViolationReportBody
    , COEPInheritenceViolationReportBody
    , CORPViolationReportBody
    , DeprecationReportBody
    , TestReportBody
};

IGNORE_WARNINGS_BEGIN("missing-noreturn")
void ArgumentCoder<WebCore::ReportBody>::encode(Encoder& encoder, const WebCore::ReportBody& instance)
{
    if (auto* subclass = dynamicDowncast<WebCore::CSPViolationReportBody>(instance)) {
        encoder << WebCore_ReportBody_Subclass::CSPViolationReportBody;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::COEPInheritenceViolationReportBody>(instance)) {
        encoder << WebCore_ReportBody_Subclass::COEPInheritenceViolationReportBody;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::CORPViolationReportBody>(instance)) {
        encoder << WebCore_ReportBody_Subclass::CORPViolationReportBody;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::DeprecationReportBody>(instance)) {
        encoder << WebCore_ReportBody_Subclass::DeprecationReportBody;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::TestReportBody>(instance)) {
        encoder << WebCore_ReportBody_Subclass::TestReportBody;
        encoder << *subclass;
        return;
    }
    ASSERT_NOT_REACHED();
}
IGNORE_WARNINGS_END

std::optional<Ref<WebCore::ReportBody>> ArgumentCoder<WebCore::ReportBody>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore_ReportBody_Subclass>();
    UNUSED_PARAM(type);
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (type == WebCore_ReportBody_Subclass::CSPViolationReportBody) {
        auto result = decoder.decode<Ref<WebCore::CSPViolationReportBody>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_ReportBody_Subclass::COEPInheritenceViolationReportBody) {
        auto result = decoder.decode<Ref<WebCore::COEPInheritenceViolationReportBody>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_ReportBody_Subclass::CORPViolationReportBody) {
        auto result = decoder.decode<Ref<WebCore::CORPViolationReportBody>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_ReportBody_Subclass::DeprecationReportBody) {
        auto result = decoder.decode<Ref<WebCore::DeprecationReportBody>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_ReportBody_Subclass::TestReportBody) {
        auto result = decoder.decode<Ref<WebCore::TestReportBody>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    ASSERT_NOT_REACHED();
    return std::nullopt;
}

void ArgumentCoder<WebCore::SourceImage>::encode(Encoder& encoder, const WebCore::SourceImage& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.imageIdentifier())>, WebCore::RenderingResourceIdentifier>);

    encoder << instance.imageIdentifier();
}

void ArgumentCoder<WebCore::SourceImage>::encode(StreamConnectionEncoder& encoder, const WebCore::SourceImage& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.imageIdentifier())>, WebCore::RenderingResourceIdentifier>);

    encoder << instance.imageIdentifier();
}

std::optional<WebCore::SourceImage> ArgumentCoder<WebCore::SourceImage>::decode(Decoder& decoder)
{
    auto imageIdentifier = decoder.decode<WebCore::RenderingResourceIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SourceImage {
            WTFMove(*imageIdentifier)
        }
    };
}

void ArgumentCoder<WebCore::LinkIcon>::encode(Encoder& encoder, const WebCore::LinkIcon& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::LinkIconType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mimeType)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size)>, std::optional<unsigned>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.attributes)>, Vector<std::pair<String, String>>>);
    struct ShouldBeSameSizeAsLinkIcon : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::LinkIcon>, false> {
        URL url;
        WebCore::LinkIconType type;
        String mimeType;
        std::optional<unsigned> size;
        Vector<std::pair<String, String>> attributes;
    };
    static_assert(sizeof(ShouldBeSameSizeAsLinkIcon) == sizeof(WebCore::LinkIcon));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::LinkIcon, url)
        , offsetof(WebCore::LinkIcon, type)
        , offsetof(WebCore::LinkIcon, mimeType)
        , offsetof(WebCore::LinkIcon, size)
        , offsetof(WebCore::LinkIcon, attributes)
    >::value);

    encoder << instance.url;
    encoder << instance.type;
    encoder << instance.mimeType;
    encoder << instance.size;
    encoder << instance.attributes;
}

std::optional<WebCore::LinkIcon> ArgumentCoder<WebCore::LinkIcon>::decode(Decoder& decoder)
{
    auto url = decoder.decode<URL>();
    auto type = decoder.decode<WebCore::LinkIconType>();
    auto mimeType = decoder.decode<String>();
    auto size = decoder.decode<std::optional<unsigned>>();
    auto attributes = decoder.decode<Vector<std::pair<String, String>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::LinkIcon {
            WTFMove(*url),
            WTFMove(*type),
            WTFMove(*mimeType),
            WTFMove(*size),
            WTFMove(*attributes)
        }
    };
}

void ArgumentCoder<WebCore::SupportedPluginIdentifier>::encode(Encoder& encoder, const WebCore::SupportedPluginIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.matchingDomain)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pluginIdentifier)>, String>);
    struct ShouldBeSameSizeAsSupportedPluginIdentifier : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SupportedPluginIdentifier>, false> {
        String matchingDomain;
        String pluginIdentifier;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSupportedPluginIdentifier) == sizeof(WebCore::SupportedPluginIdentifier));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SupportedPluginIdentifier, matchingDomain)
        , offsetof(WebCore::SupportedPluginIdentifier, pluginIdentifier)
    >::value);

    encoder << instance.matchingDomain;
    encoder << instance.pluginIdentifier;
}

std::optional<WebCore::SupportedPluginIdentifier> ArgumentCoder<WebCore::SupportedPluginIdentifier>::decode(Decoder& decoder)
{
    auto matchingDomain = decoder.decode<String>();
    auto pluginIdentifier = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SupportedPluginIdentifier {
            WTFMove(*matchingDomain),
            WTFMove(*pluginIdentifier)
        }
    };
}

void ArgumentCoder<WebCore::CSSValueKey>::encode(Encoder& encoder, const WebCore::CSSValueKey& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cssValueID)>, unsigned>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.useDarkAppearance)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.useElevatedUserInterfaceLevel)>, bool>);
    struct ShouldBeSameSizeAsCSSValueKey : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::CSSValueKey>, false> {
        unsigned cssValueID;
        bool useDarkAppearance;
        bool useElevatedUserInterfaceLevel;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCSSValueKey) == sizeof(WebCore::CSSValueKey));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::CSSValueKey, cssValueID)
        , offsetof(WebCore::CSSValueKey, useDarkAppearance)
        , offsetof(WebCore::CSSValueKey, useElevatedUserInterfaceLevel)
    >::value);

    encoder << instance.cssValueID;
    encoder << instance.useDarkAppearance;
    encoder << instance.useElevatedUserInterfaceLevel;
}

std::optional<WebCore::CSSValueKey> ArgumentCoder<WebCore::CSSValueKey>::decode(Decoder& decoder)
{
    auto cssValueID = decoder.decode<unsigned>();
    auto useDarkAppearance = decoder.decode<bool>();
    auto useElevatedUserInterfaceLevel = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CSSValueKey {
            WTFMove(*cssValueID),
            WTFMove(*useDarkAppearance),
            WTFMove(*useElevatedUserInterfaceLevel)
        }
    };
}

void ArgumentCoder<WebCore::VideoFrameTimeMetadata>::encode(Encoder& encoder, const WebCore::VideoFrameTimeMetadata& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processingDuration)>, std::optional<double>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.captureTime)>, std::optional<Seconds>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.receiveTime)>, std::optional<Seconds>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rtpTimestamp)>, std::optional<unsigned>>);
    struct ShouldBeSameSizeAsVideoFrameTimeMetadata : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::VideoFrameTimeMetadata>, false> {
        std::optional<double> processingDuration;
        std::optional<Seconds> captureTime;
        std::optional<Seconds> receiveTime;
        std::optional<unsigned> rtpTimestamp;
    };
    static_assert(sizeof(ShouldBeSameSizeAsVideoFrameTimeMetadata) == sizeof(WebCore::VideoFrameTimeMetadata));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::VideoFrameTimeMetadata, processingDuration)
        , offsetof(WebCore::VideoFrameTimeMetadata, captureTime)
        , offsetof(WebCore::VideoFrameTimeMetadata, receiveTime)
        , offsetof(WebCore::VideoFrameTimeMetadata, rtpTimestamp)
    >::value);

    encoder << instance.processingDuration;
    encoder << instance.captureTime;
    encoder << instance.receiveTime;
    encoder << instance.rtpTimestamp;
}

std::optional<WebCore::VideoFrameTimeMetadata> ArgumentCoder<WebCore::VideoFrameTimeMetadata>::decode(Decoder& decoder)
{
    auto processingDuration = decoder.decode<std::optional<double>>();
    auto captureTime = decoder.decode<std::optional<Seconds>>();
    auto receiveTime = decoder.decode<std::optional<Seconds>>();
    auto rtpTimestamp = decoder.decode<std::optional<unsigned>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::VideoFrameTimeMetadata {
            WTFMove(*processingDuration),
            WTFMove(*captureTime),
            WTFMove(*receiveTime),
            WTFMove(*rtpTimestamp)
        }
    };
}

void ArgumentCoder<WebCore::EventRegion>::encode(Encoder& encoder, const WebCore::EventRegion& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_region)>, WebCore::Region>);
#if ENABLE(TOUCH_ACTION_REGIONS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_touchActionRegions)>, Vector<WebCore::Region>>);
#endif
#if ENABLE(WHEEL_EVENT_REGIONS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_wheelEventListenerRegion)>, WebCore::Region>);
#endif
#if ENABLE(WHEEL_EVENT_REGIONS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_nonPassiveWheelEventListenerRegion)>, WebCore::Region>);
#endif
#if ENABLE(TOUCH_EVENT_REGIONS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_touchEventListenerRegion)>, WebCore::EventTrackingRegions>);
#endif
#if ENABLE(EDITABLE_REGION)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_editableRegion)>, std::optional<WebCore::Region>>);
#endif
#if ENABLE(INTERACTION_REGIONS_IN_EVENT_REGION)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_interactionRegions)>, Vector<WebCore::InteractionRegion>>);
#endif
    struct ShouldBeSameSizeAsEventRegion : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::EventRegion>, false> {
        WebCore::Region m_region;
#if ENABLE(TOUCH_ACTION_REGIONS)
        Vector<WebCore::Region> m_touchActionRegions;
#endif
#if ENABLE(WHEEL_EVENT_REGIONS)
        WebCore::Region m_wheelEventListenerRegion;
#endif
#if ENABLE(WHEEL_EVENT_REGIONS)
        WebCore::Region m_nonPassiveWheelEventListenerRegion;
#endif
#if ENABLE(TOUCH_EVENT_REGIONS)
        WebCore::EventTrackingRegions m_touchEventListenerRegion;
#endif
#if ENABLE(EDITABLE_REGION)
        std::optional<WebCore::Region> m_editableRegion;
#endif
#if ENABLE(INTERACTION_REGIONS_IN_EVENT_REGION)
        Vector<WebCore::InteractionRegion> m_interactionRegions;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsEventRegion) == sizeof(WebCore::EventRegion));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::EventRegion, m_region)
#if ENABLE(TOUCH_ACTION_REGIONS)
        , offsetof(WebCore::EventRegion, m_touchActionRegions)
#endif
#if ENABLE(WHEEL_EVENT_REGIONS)
        , offsetof(WebCore::EventRegion, m_wheelEventListenerRegion)
#endif
#if ENABLE(WHEEL_EVENT_REGIONS)
        , offsetof(WebCore::EventRegion, m_nonPassiveWheelEventListenerRegion)
#endif
#if ENABLE(TOUCH_EVENT_REGIONS)
        , offsetof(WebCore::EventRegion, m_touchEventListenerRegion)
#endif
#if ENABLE(EDITABLE_REGION)
        , offsetof(WebCore::EventRegion, m_editableRegion)
#endif
#if ENABLE(INTERACTION_REGIONS_IN_EVENT_REGION)
        , offsetof(WebCore::EventRegion, m_interactionRegions)
#endif
    >::value);

    encoder << instance.m_region;
#if ENABLE(TOUCH_ACTION_REGIONS)
    encoder << instance.m_touchActionRegions;
#endif
#if ENABLE(WHEEL_EVENT_REGIONS)
    encoder << instance.m_wheelEventListenerRegion;
#endif
#if ENABLE(WHEEL_EVENT_REGIONS)
    encoder << instance.m_nonPassiveWheelEventListenerRegion;
#endif
#if ENABLE(TOUCH_EVENT_REGIONS)
    encoder << instance.m_touchEventListenerRegion;
#endif
#if ENABLE(EDITABLE_REGION)
    encoder << instance.m_editableRegion;
#endif
#if ENABLE(INTERACTION_REGIONS_IN_EVENT_REGION)
    encoder << instance.m_interactionRegions;
#endif
}

std::optional<WebCore::EventRegion> ArgumentCoder<WebCore::EventRegion>::decode(Decoder& decoder)
{
    auto m_region = decoder.decode<WebCore::Region>();
#if ENABLE(TOUCH_ACTION_REGIONS)
    auto m_touchActionRegions = decoder.decode<Vector<WebCore::Region>>();
#endif
#if ENABLE(WHEEL_EVENT_REGIONS)
    auto m_wheelEventListenerRegion = decoder.decode<WebCore::Region>();
#endif
#if ENABLE(WHEEL_EVENT_REGIONS)
    auto m_nonPassiveWheelEventListenerRegion = decoder.decode<WebCore::Region>();
#endif
#if ENABLE(TOUCH_EVENT_REGIONS)
    auto m_touchEventListenerRegion = decoder.decode<WebCore::EventTrackingRegions>();
#endif
#if ENABLE(EDITABLE_REGION)
    auto m_editableRegion = decoder.decode<std::optional<WebCore::Region>>();
#endif
#if ENABLE(INTERACTION_REGIONS_IN_EVENT_REGION)
    auto m_interactionRegions = decoder.decode<Vector<WebCore::InteractionRegion>>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::EventRegion {
            WTFMove(*m_region),
#if ENABLE(TOUCH_ACTION_REGIONS)
            WTFMove(*m_touchActionRegions),
#endif
#if ENABLE(WHEEL_EVENT_REGIONS)
            WTFMove(*m_wheelEventListenerRegion),
#endif
#if ENABLE(WHEEL_EVENT_REGIONS)
            WTFMove(*m_nonPassiveWheelEventListenerRegion),
#endif
#if ENABLE(TOUCH_EVENT_REGIONS)
            WTFMove(*m_touchEventListenerRegion),
#endif
#if ENABLE(EDITABLE_REGION)
            WTFMove(*m_editableRegion),
#endif
#if ENABLE(INTERACTION_REGIONS_IN_EVENT_REGION)
            WTFMove(*m_interactionRegions)
#endif
        }
    };
}

void ArgumentCoder<WebCore::PresentationSize>::encode(Encoder& encoder, const WebCore::PresentationSize& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.width)>, std::optional<double>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.height)>, std::optional<double>>);
    struct ShouldBeSameSizeAsPresentationSize : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PresentationSize>, false> {
        std::optional<double> width;
        std::optional<double> height;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPresentationSize) == sizeof(WebCore::PresentationSize));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PresentationSize, width)
        , offsetof(WebCore::PresentationSize, height)
    >::value);

    encoder << instance.width;
    encoder << instance.height;
}

std::optional<WebCore::PresentationSize> ArgumentCoder<WebCore::PresentationSize>::decode(Decoder& decoder)
{
    auto width = decoder.decode<std::optional<double>>();
    auto height = decoder.decode<std::optional<double>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PresentationSize {
            WTFMove(*width),
            WTFMove(*height)
        }
    };
}

void ArgumentCoder<WebCore::PasteboardItemInfo>::encode(Encoder& encoder, const WebCore::PasteboardItemInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pathsForFileUpload)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.platformTypesForFileUpload)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.platformTypesByFidelity)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.suggestedFileName)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.preferredPresentationSize)>, WebCore::PresentationSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isNonTextType)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.containsFileURLAndFileUploadContent)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webSafeTypesByFidelity)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.preferredPresentationStyle)>, WebCore::PasteboardItemPresentationStyle>);
    struct ShouldBeSameSizeAsPasteboardItemInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PasteboardItemInfo>, false> {
        Vector<String> pathsForFileUpload;
        Vector<String> platformTypesForFileUpload;
        Vector<String> platformTypesByFidelity;
        String suggestedFileName;
        WebCore::PresentationSize preferredPresentationSize;
        bool isNonTextType;
        bool containsFileURLAndFileUploadContent;
        Vector<String> webSafeTypesByFidelity;
        WebCore::PasteboardItemPresentationStyle preferredPresentationStyle;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPasteboardItemInfo) == sizeof(WebCore::PasteboardItemInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PasteboardItemInfo, pathsForFileUpload)
        , offsetof(WebCore::PasteboardItemInfo, platformTypesForFileUpload)
        , offsetof(WebCore::PasteboardItemInfo, platformTypesByFidelity)
        , offsetof(WebCore::PasteboardItemInfo, suggestedFileName)
        , offsetof(WebCore::PasteboardItemInfo, preferredPresentationSize)
        , offsetof(WebCore::PasteboardItemInfo, isNonTextType)
        , offsetof(WebCore::PasteboardItemInfo, containsFileURLAndFileUploadContent)
        , offsetof(WebCore::PasteboardItemInfo, webSafeTypesByFidelity)
        , offsetof(WebCore::PasteboardItemInfo, preferredPresentationStyle)
    >::value);

    encoder << instance.pathsForFileUpload;
    encoder << instance.platformTypesForFileUpload;
    encoder << instance.platformTypesByFidelity;
    encoder << instance.suggestedFileName;
    encoder << instance.preferredPresentationSize;
    encoder << instance.isNonTextType;
    encoder << instance.containsFileURLAndFileUploadContent;
    encoder << instance.webSafeTypesByFidelity;
    encoder << instance.preferredPresentationStyle;
}

std::optional<WebCore::PasteboardItemInfo> ArgumentCoder<WebCore::PasteboardItemInfo>::decode(Decoder& decoder)
{
    auto pathsForFileUpload = decoder.decode<Vector<String>>();
    auto platformTypesForFileUpload = decoder.decode<Vector<String>>();
    auto platformTypesByFidelity = decoder.decode<Vector<String>>();
    auto suggestedFileName = decoder.decode<String>();
    auto preferredPresentationSize = decoder.decode<WebCore::PresentationSize>();
    auto isNonTextType = decoder.decode<bool>();
    auto containsFileURLAndFileUploadContent = decoder.decode<bool>();
    auto webSafeTypesByFidelity = decoder.decode<Vector<String>>();
    auto preferredPresentationStyle = decoder.decode<WebCore::PasteboardItemPresentationStyle>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PasteboardItemInfo {
            WTFMove(*pathsForFileUpload),
            WTFMove(*platformTypesForFileUpload),
            WTFMove(*platformTypesByFidelity),
            WTFMove(*suggestedFileName),
            WTFMove(*preferredPresentationSize),
            WTFMove(*isNonTextType),
            WTFMove(*containsFileURLAndFileUploadContent),
            WTFMove(*webSafeTypesByFidelity),
            WTFMove(*preferredPresentationStyle)
        }
    };
}

#if ENABLE(MEDIA_CONTROLS_CONTEXT_MENUS) && USE(UICONTEXTMENU)
void ArgumentCoder<WebCore::MediaControlsContextMenuItem>::encode(Encoder& encoder, const WebCore::MediaControlsContextMenuItem& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.id)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.title)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.icon)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.checked)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.children)>, Vector<WebCore::MediaControlsContextMenuItem>>);
    struct ShouldBeSameSizeAsMediaControlsContextMenuItem : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MediaControlsContextMenuItem>, false> {
        uint64_t id;
        String title;
        String icon;
        bool checked;
        Vector<WebCore::MediaControlsContextMenuItem> children;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMediaControlsContextMenuItem) == sizeof(WebCore::MediaControlsContextMenuItem));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MediaControlsContextMenuItem, id)
        , offsetof(WebCore::MediaControlsContextMenuItem, title)
        , offsetof(WebCore::MediaControlsContextMenuItem, icon)
        , offsetof(WebCore::MediaControlsContextMenuItem, checked)
        , offsetof(WebCore::MediaControlsContextMenuItem, children)
    >::value);

    encoder << instance.id;
    encoder << instance.title;
    encoder << instance.icon;
    encoder << instance.checked;
    encoder << instance.children;
}

std::optional<WebCore::MediaControlsContextMenuItem> ArgumentCoder<WebCore::MediaControlsContextMenuItem>::decode(Decoder& decoder)
{
    auto id = decoder.decode<uint64_t>();
    auto title = decoder.decode<String>();
    auto icon = decoder.decode<String>();
    auto checked = decoder.decode<bool>();
    auto children = decoder.decode<Vector<WebCore::MediaControlsContextMenuItem>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MediaControlsContextMenuItem {
            WTFMove(*id),
            WTFMove(*title),
            WTFMove(*icon),
            WTFMove(*checked),
            WTFMove(*children)
        }
    };
}

#endif

void ArgumentCoder<WebCore::WorkerOptions>::encode(Encoder& encoder, const WebCore::WorkerOptions& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::WorkerType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.credentials)>, WebCore::FetchOptionsCredentials>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, String>);
    struct ShouldBeSameSizeAsWorkerOptions : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::WorkerOptions>, false> {
        WebCore::WorkerType type;
        WebCore::FetchOptionsCredentials credentials;
        String name;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWorkerOptions) == sizeof(WebCore::WorkerOptions));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::WorkerOptions, type)
        , offsetof(WebCore::WorkerOptions, credentials)
        , offsetof(WebCore::WorkerOptions, name)
    >::value);

    encoder << instance.type;
    encoder << instance.credentials;
    encoder << instance.name;
}

std::optional<WebCore::WorkerOptions> ArgumentCoder<WebCore::WorkerOptions>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::WorkerType>();
    auto credentials = decoder.decode<WebCore::FetchOptionsCredentials>();
    auto name = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::WorkerOptions {
            WTFMove(*type),
            WTFMove(*credentials),
            WTFMove(*name)
        }
    };
}

void ArgumentCoder<WebCore::WorkerInitializationData>::encode(Encoder& encoder, const WebCore::WorkerInitializationData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.serviceWorkerData)>, std::optional<WebCore::ServiceWorkerData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.clientIdentifier)>, std::optional<WebCore::ScriptExecutionContextIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.advancedPrivacyProtections)>, OptionSet<WebCore::AdvancedPrivacyProtections>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.userAgent)>, String>);
    struct ShouldBeSameSizeAsWorkerInitializationData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::WorkerInitializationData>, false> {
        std::optional<WebCore::ServiceWorkerData> serviceWorkerData;
        std::optional<WebCore::ScriptExecutionContextIdentifier> clientIdentifier;
        OptionSet<WebCore::AdvancedPrivacyProtections> advancedPrivacyProtections;
        String userAgent;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWorkerInitializationData) == sizeof(WebCore::WorkerInitializationData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::WorkerInitializationData, serviceWorkerData)
        , offsetof(WebCore::WorkerInitializationData, clientIdentifier)
        , offsetof(WebCore::WorkerInitializationData, advancedPrivacyProtections)
        , offsetof(WebCore::WorkerInitializationData, userAgent)
    >::value);

    encoder << instance.serviceWorkerData;
    encoder << instance.clientIdentifier;
    encoder << instance.advancedPrivacyProtections;
    encoder << instance.userAgent;
}

std::optional<WebCore::WorkerInitializationData> ArgumentCoder<WebCore::WorkerInitializationData>::decode(Decoder& decoder)
{
    auto serviceWorkerData = decoder.decode<std::optional<WebCore::ServiceWorkerData>>();
    auto clientIdentifier = decoder.decode<std::optional<WebCore::ScriptExecutionContextIdentifier>>();
    auto advancedPrivacyProtections = decoder.decode<OptionSet<WebCore::AdvancedPrivacyProtections>>();
    auto userAgent = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::WorkerInitializationData {
            WTFMove(*serviceWorkerData),
            WTFMove(*clientIdentifier),
            WTFMove(*advancedPrivacyProtections),
            WTFMove(*userAgent)
        }
    };
}

void ArgumentCoder<WebCore::WorkerFetchResult>::encode(Encoder& encoder, const WebCore::WorkerFetchResult& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.script)>, WebCore::ScriptBuffer>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.responseURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.certificateInfo)>, WebCore::CertificateInfo>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentSecurityPolicy)>, WebCore::ContentSecurityPolicyResponseHeaders>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.crossOriginEmbedderPolicy)>, WebCore::CrossOriginEmbedderPolicy>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.referrerPolicy)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.error)>, WebCore::ResourceError>);
    struct ShouldBeSameSizeAsWorkerFetchResult : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::WorkerFetchResult>, false> {
        WebCore::ScriptBuffer script;
        URL responseURL;
        WebCore::CertificateInfo certificateInfo;
        WebCore::ContentSecurityPolicyResponseHeaders contentSecurityPolicy;
        WebCore::CrossOriginEmbedderPolicy crossOriginEmbedderPolicy;
        String referrerPolicy;
        WebCore::ResourceError error;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWorkerFetchResult) == sizeof(WebCore::WorkerFetchResult));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::WorkerFetchResult, script)
        , offsetof(WebCore::WorkerFetchResult, responseURL)
        , offsetof(WebCore::WorkerFetchResult, certificateInfo)
        , offsetof(WebCore::WorkerFetchResult, contentSecurityPolicy)
        , offsetof(WebCore::WorkerFetchResult, crossOriginEmbedderPolicy)
        , offsetof(WebCore::WorkerFetchResult, referrerPolicy)
        , offsetof(WebCore::WorkerFetchResult, error)
    >::value);

    encoder << instance.script;
    encoder << instance.responseURL;
    encoder << instance.certificateInfo;
    encoder << instance.contentSecurityPolicy;
    encoder << instance.crossOriginEmbedderPolicy;
    encoder << instance.referrerPolicy;
    encoder << instance.error;
}

std::optional<WebCore::WorkerFetchResult> ArgumentCoder<WebCore::WorkerFetchResult>::decode(Decoder& decoder)
{
    auto script = decoder.decode<WebCore::ScriptBuffer>();
    auto responseURL = decoder.decode<URL>();
    auto certificateInfo = decoder.decode<WebCore::CertificateInfo>();
    auto contentSecurityPolicy = decoder.decode<WebCore::ContentSecurityPolicyResponseHeaders>();
    auto crossOriginEmbedderPolicy = decoder.decode<WebCore::CrossOriginEmbedderPolicy>();
    auto referrerPolicy = decoder.decode<String>();
    auto error = decoder.decode<WebCore::ResourceError>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::WorkerFetchResult {
            WTFMove(*script),
            WTFMove(*responseURL),
            WTFMove(*certificateInfo),
            WTFMove(*contentSecurityPolicy),
            WTFMove(*crossOriginEmbedderPolicy),
            WTFMove(*referrerPolicy),
            WTFMove(*error)
        }
    };
}

void ArgumentCoder<WebCore::SharedWorkerKey>::encode(Encoder& encoder, const WebCore::SharedWorkerKey& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.origin)>, WebCore::ClientOrigin>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, String>);
    struct ShouldBeSameSizeAsSharedWorkerKey : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SharedWorkerKey>, false> {
        WebCore::ClientOrigin origin;
        URL url;
        String name;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSharedWorkerKey) == sizeof(WebCore::SharedWorkerKey));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SharedWorkerKey, origin)
        , offsetof(WebCore::SharedWorkerKey, url)
        , offsetof(WebCore::SharedWorkerKey, name)
    >::value);

    encoder << instance.origin;
    encoder << instance.url;
    encoder << instance.name;
}

std::optional<WebCore::SharedWorkerKey> ArgumentCoder<WebCore::SharedWorkerKey>::decode(Decoder& decoder)
{
    auto origin = decoder.decode<WebCore::ClientOrigin>();
    auto url = decoder.decode<URL>();
    auto name = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SharedWorkerKey {
            WTFMove(*origin),
            WTFMove(*url),
            WTFMove(*name)
        }
    };
}

void ArgumentCoder<WebCore::ServiceWorkerRegistrationOptions>::encode(Encoder& encoder, const WebCore::ServiceWorkerRegistrationOptions& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scope)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::WorkerType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.updateViaCache)>, WebCore::ServiceWorkerUpdateViaCache>);
    struct ShouldBeSameSizeAsServiceWorkerRegistrationOptions : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ServiceWorkerRegistrationOptions>, false> {
        String scope;
        WebCore::WorkerType type;
        WebCore::ServiceWorkerUpdateViaCache updateViaCache;
    };
    static_assert(sizeof(ShouldBeSameSizeAsServiceWorkerRegistrationOptions) == sizeof(WebCore::ServiceWorkerRegistrationOptions));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ServiceWorkerRegistrationOptions, scope)
        , offsetof(WebCore::ServiceWorkerRegistrationOptions, type)
        , offsetof(WebCore::ServiceWorkerRegistrationOptions, updateViaCache)
    >::value);

    encoder << instance.scope;
    encoder << instance.type;
    encoder << instance.updateViaCache;
}

std::optional<WebCore::ServiceWorkerRegistrationOptions> ArgumentCoder<WebCore::ServiceWorkerRegistrationOptions>::decode(Decoder& decoder)
{
    auto scope = decoder.decode<String>();
    auto type = decoder.decode<WebCore::WorkerType>();
    auto updateViaCache = decoder.decode<WebCore::ServiceWorkerUpdateViaCache>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ServiceWorkerRegistrationOptions {
            WTFMove(*scope),
            WTFMove(*type),
            WTFMove(*updateViaCache)
        }
    };
}

void ArgumentCoder<WebCore::ServiceWorkerRegistrationKey>::encode(Encoder& encoder, const WebCore::ServiceWorkerRegistrationKey& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.topOrigin())>, WebCore::SecurityOriginData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scope())>, URL>);

    encoder << instance.topOrigin();
    encoder << instance.scope();
}

std::optional<WebCore::ServiceWorkerRegistrationKey> ArgumentCoder<WebCore::ServiceWorkerRegistrationKey>::decode(Decoder& decoder)
{
    auto topOrigin = decoder.decode<WebCore::SecurityOriginData>();
    auto scope = decoder.decode<URL>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ServiceWorkerRegistrationKey {
            WTFMove(*topOrigin),
            WTFMove(*scope)
        }
    };
}

void ArgumentCoder<WebCore::ServiceWorkerRegistrationData>::encode(Encoder& encoder, const WebCore::ServiceWorkerRegistrationData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.key)>, WebCore::ServiceWorkerRegistrationKey>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, WebCore::ServiceWorkerRegistrationIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scopeURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.updateViaCache)>, WebCore::ServiceWorkerUpdateViaCache>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lastUpdateTime)>, WallTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.installingWorker)>, std::optional<WebCore::ServiceWorkerData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.waitingWorker)>, std::optional<WebCore::ServiceWorkerData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.activeWorker)>, std::optional<WebCore::ServiceWorkerData>>);
    struct ShouldBeSameSizeAsServiceWorkerRegistrationData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ServiceWorkerRegistrationData>, false> {
        WebCore::ServiceWorkerRegistrationKey key;
        WebCore::ServiceWorkerRegistrationIdentifier identifier;
        URL scopeURL;
        WebCore::ServiceWorkerUpdateViaCache updateViaCache;
        WallTime lastUpdateTime;
        std::optional<WebCore::ServiceWorkerData> installingWorker;
        std::optional<WebCore::ServiceWorkerData> waitingWorker;
        std::optional<WebCore::ServiceWorkerData> activeWorker;
    };
    static_assert(sizeof(ShouldBeSameSizeAsServiceWorkerRegistrationData) == sizeof(WebCore::ServiceWorkerRegistrationData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ServiceWorkerRegistrationData, key)
        , offsetof(WebCore::ServiceWorkerRegistrationData, identifier)
        , offsetof(WebCore::ServiceWorkerRegistrationData, scopeURL)
        , offsetof(WebCore::ServiceWorkerRegistrationData, updateViaCache)
        , offsetof(WebCore::ServiceWorkerRegistrationData, lastUpdateTime)
        , offsetof(WebCore::ServiceWorkerRegistrationData, installingWorker)
        , offsetof(WebCore::ServiceWorkerRegistrationData, waitingWorker)
        , offsetof(WebCore::ServiceWorkerRegistrationData, activeWorker)
    >::value);

    encoder << instance.key;
    encoder << instance.identifier;
    encoder << instance.scopeURL;
    encoder << instance.updateViaCache;
    encoder << instance.lastUpdateTime;
    encoder << instance.installingWorker;
    encoder << instance.waitingWorker;
    encoder << instance.activeWorker;
}

std::optional<WebCore::ServiceWorkerRegistrationData> ArgumentCoder<WebCore::ServiceWorkerRegistrationData>::decode(Decoder& decoder)
{
    auto key = decoder.decode<WebCore::ServiceWorkerRegistrationKey>();
    auto identifier = decoder.decode<WebCore::ServiceWorkerRegistrationIdentifier>();
    auto scopeURL = decoder.decode<URL>();
    auto updateViaCache = decoder.decode<WebCore::ServiceWorkerUpdateViaCache>();
    auto lastUpdateTime = decoder.decode<WallTime>();
    auto installingWorker = decoder.decode<std::optional<WebCore::ServiceWorkerData>>();
    auto waitingWorker = decoder.decode<std::optional<WebCore::ServiceWorkerData>>();
    auto activeWorker = decoder.decode<std::optional<WebCore::ServiceWorkerData>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ServiceWorkerRegistrationData {
            WTFMove(*key),
            WTFMove(*identifier),
            WTFMove(*scopeURL),
            WTFMove(*updateViaCache),
            WTFMove(*lastUpdateTime),
            WTFMove(*installingWorker),
            WTFMove(*waitingWorker),
            WTFMove(*activeWorker)
        }
    };
}

void ArgumentCoder<WebCore::ServiceWorkerJobDataIdentifier>::encode(Encoder& encoder, const WebCore::ServiceWorkerJobDataIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.connectionIdentifier)>, WebCore::SWServerConnectionIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.jobIdentifier)>, WebCore::ServiceWorkerJobIdentifier>);
    struct ShouldBeSameSizeAsServiceWorkerJobDataIdentifier : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ServiceWorkerJobDataIdentifier>, false> {
        WebCore::SWServerConnectionIdentifier connectionIdentifier;
        WebCore::ServiceWorkerJobIdentifier jobIdentifier;
    };
    static_assert(sizeof(ShouldBeSameSizeAsServiceWorkerJobDataIdentifier) == sizeof(WebCore::ServiceWorkerJobDataIdentifier));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ServiceWorkerJobDataIdentifier, connectionIdentifier)
        , offsetof(WebCore::ServiceWorkerJobDataIdentifier, jobIdentifier)
    >::value);

    encoder << instance.connectionIdentifier;
    encoder << instance.jobIdentifier;
}

std::optional<WebCore::ServiceWorkerJobDataIdentifier> ArgumentCoder<WebCore::ServiceWorkerJobDataIdentifier>::decode(Decoder& decoder)
{
    auto connectionIdentifier = decoder.decode<WebCore::SWServerConnectionIdentifier>();
    auto jobIdentifier = decoder.decode<WebCore::ServiceWorkerJobIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ServiceWorkerJobDataIdentifier {
            WTFMove(*connectionIdentifier),
            WTFMove(*jobIdentifier)
        }
    };
}

void ArgumentCoder<WebCore::ServiceWorkerImportedScript>::encode(Encoder& encoder, const WebCore::ServiceWorkerImportedScript& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.script)>, WebCore::ScriptBuffer>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.responseURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mimeType)>, String>);
    struct ShouldBeSameSizeAsServiceWorkerImportedScript : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ServiceWorkerImportedScript>, false> {
        WebCore::ScriptBuffer script;
        URL responseURL;
        String mimeType;
    };
    static_assert(sizeof(ShouldBeSameSizeAsServiceWorkerImportedScript) == sizeof(WebCore::ServiceWorkerImportedScript));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ServiceWorkerImportedScript, script)
        , offsetof(WebCore::ServiceWorkerImportedScript, responseURL)
        , offsetof(WebCore::ServiceWorkerImportedScript, mimeType)
    >::value);

    encoder << instance.script;
    encoder << instance.responseURL;
    encoder << instance.mimeType;
}

std::optional<WebCore::ServiceWorkerImportedScript> ArgumentCoder<WebCore::ServiceWorkerImportedScript>::decode(Decoder& decoder)
{
    auto script = decoder.decode<WebCore::ScriptBuffer>();
    auto responseURL = decoder.decode<URL>();
    auto mimeType = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ServiceWorkerImportedScript {
            WTFMove(*script),
            WTFMove(*responseURL),
            WTFMove(*mimeType)
        }
    };
}

#if ENABLE(SHAREABLE_RESOURCE) && PLATFORM(COCOA)
void ArgumentCoder<WebCore::ScriptBuffer>::encode(Encoder& encoder, const WebCore::ScriptBuffer& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ipcData())>, Variant<WebCore::ShareableResourceHandle, RefPtr<WebCore::FragmentedSharedBuffer>>>);

    encoder << instance.ipcData();
}

std::optional<WebCore::ScriptBuffer> ArgumentCoder<WebCore::ScriptBuffer>::decode(Decoder& decoder)
{
    auto ipcData = decoder.decode<Variant<WebCore::ShareableResourceHandle, RefPtr<WebCore::FragmentedSharedBuffer>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ScriptBuffer::fromIPCData(
            WTFMove(*ipcData)
        )
    };
}

#endif

#if !ENABLE(SHAREABLE_RESOURCE) || !PLATFORM(COCOA)
void ArgumentCoder<WebCore::ScriptBuffer>::encode(Encoder& encoder, const WebCore::ScriptBuffer& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ipcData())>, RefPtr<WebCore::FragmentedSharedBuffer>>);

    encoder << instance.ipcData();
}

std::optional<WebCore::ScriptBuffer> ArgumentCoder<WebCore::ScriptBuffer>::decode(Decoder& decoder)
{
    auto ipcData = decoder.decode<RefPtr<WebCore::FragmentedSharedBuffer>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ScriptBuffer::fromIPCData(
            WTFMove(*ipcData)
        )
    };
}

#endif

void ArgumentCoder<WebCore::ServiceWorkerContextData>::encode(Encoder& encoder, const WebCore::ServiceWorkerContextData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.jobDataIdentifier)>, std::optional<WebCore::ServiceWorkerJobDataIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.registration)>, WebCore::ServiceWorkerRegistrationData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.serviceWorkerIdentifier)>, WebCore::ServiceWorkerIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.script)>, WebCore::ScriptBuffer>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.certificateInfo)>, WebCore::CertificateInfo>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentSecurityPolicy)>, WebCore::ContentSecurityPolicyResponseHeaders>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.crossOriginEmbedderPolicy)>, WebCore::CrossOriginEmbedderPolicy>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.referrerPolicy)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scriptURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.workerType)>, WebCore::WorkerType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.loadedFromDisk)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lastNavigationWasAppInitiated)>, std::optional<WebCore::LastNavigationWasAppInitiated>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scriptResourceMap)>, MemoryCompactRobinHoodHashMap<URL, WebCore::ServiceWorkerImportedScript>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.serviceWorkerPageIdentifier)>, std::optional<WebCore::ScriptExecutionContextIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.navigationPreloadState)>, WebCore::NavigationPreloadState>);
    struct ShouldBeSameSizeAsServiceWorkerContextData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ServiceWorkerContextData>, false> {
        std::optional<WebCore::ServiceWorkerJobDataIdentifier> jobDataIdentifier;
        WebCore::ServiceWorkerRegistrationData registration;
        WebCore::ServiceWorkerIdentifier serviceWorkerIdentifier;
        WebCore::ScriptBuffer script;
        WebCore::CertificateInfo certificateInfo;
        WebCore::ContentSecurityPolicyResponseHeaders contentSecurityPolicy;
        WebCore::CrossOriginEmbedderPolicy crossOriginEmbedderPolicy;
        String referrerPolicy;
        URL scriptURL;
        WebCore::WorkerType workerType;
        bool loadedFromDisk;
        std::optional<WebCore::LastNavigationWasAppInitiated> lastNavigationWasAppInitiated;
        MemoryCompactRobinHoodHashMap<URL, WebCore::ServiceWorkerImportedScript> scriptResourceMap;
        std::optional<WebCore::ScriptExecutionContextIdentifier> serviceWorkerPageIdentifier;
        WebCore::NavigationPreloadState navigationPreloadState;
    };
    static_assert(sizeof(ShouldBeSameSizeAsServiceWorkerContextData) == sizeof(WebCore::ServiceWorkerContextData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ServiceWorkerContextData, jobDataIdentifier)
        , offsetof(WebCore::ServiceWorkerContextData, registration)
        , offsetof(WebCore::ServiceWorkerContextData, serviceWorkerIdentifier)
        , offsetof(WebCore::ServiceWorkerContextData, script)
        , offsetof(WebCore::ServiceWorkerContextData, certificateInfo)
        , offsetof(WebCore::ServiceWorkerContextData, contentSecurityPolicy)
        , offsetof(WebCore::ServiceWorkerContextData, crossOriginEmbedderPolicy)
        , offsetof(WebCore::ServiceWorkerContextData, referrerPolicy)
        , offsetof(WebCore::ServiceWorkerContextData, scriptURL)
        , offsetof(WebCore::ServiceWorkerContextData, workerType)
        , offsetof(WebCore::ServiceWorkerContextData, loadedFromDisk)
        , offsetof(WebCore::ServiceWorkerContextData, lastNavigationWasAppInitiated)
        , offsetof(WebCore::ServiceWorkerContextData, scriptResourceMap)
        , offsetof(WebCore::ServiceWorkerContextData, serviceWorkerPageIdentifier)
        , offsetof(WebCore::ServiceWorkerContextData, navigationPreloadState)
    >::value);

    encoder << instance.jobDataIdentifier;
    encoder << instance.registration;
    encoder << instance.serviceWorkerIdentifier;
    encoder << instance.script;
    encoder << instance.certificateInfo;
    encoder << instance.contentSecurityPolicy;
    encoder << instance.crossOriginEmbedderPolicy;
    encoder << instance.referrerPolicy;
    encoder << instance.scriptURL;
    encoder << instance.workerType;
    encoder << instance.loadedFromDisk;
    encoder << instance.lastNavigationWasAppInitiated;
    encoder << instance.scriptResourceMap;
    encoder << instance.serviceWorkerPageIdentifier;
    encoder << instance.navigationPreloadState;
}

std::optional<WebCore::ServiceWorkerContextData> ArgumentCoder<WebCore::ServiceWorkerContextData>::decode(Decoder& decoder)
{
    auto jobDataIdentifier = decoder.decode<std::optional<WebCore::ServiceWorkerJobDataIdentifier>>();
    auto registration = decoder.decode<WebCore::ServiceWorkerRegistrationData>();
    auto serviceWorkerIdentifier = decoder.decode<WebCore::ServiceWorkerIdentifier>();
    auto script = decoder.decode<WebCore::ScriptBuffer>();
    auto certificateInfo = decoder.decode<WebCore::CertificateInfo>();
    auto contentSecurityPolicy = decoder.decode<WebCore::ContentSecurityPolicyResponseHeaders>();
    auto crossOriginEmbedderPolicy = decoder.decode<WebCore::CrossOriginEmbedderPolicy>();
    auto referrerPolicy = decoder.decode<String>();
    auto scriptURL = decoder.decode<URL>();
    auto workerType = decoder.decode<WebCore::WorkerType>();
    auto loadedFromDisk = decoder.decode<bool>();
    auto lastNavigationWasAppInitiated = decoder.decode<std::optional<WebCore::LastNavigationWasAppInitiated>>();
    auto scriptResourceMap = decoder.decode<MemoryCompactRobinHoodHashMap<URL, WebCore::ServiceWorkerImportedScript>>();
    auto serviceWorkerPageIdentifier = decoder.decode<std::optional<WebCore::ScriptExecutionContextIdentifier>>();
    auto navigationPreloadState = decoder.decode<WebCore::NavigationPreloadState>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ServiceWorkerContextData {
            WTFMove(*jobDataIdentifier),
            WTFMove(*registration),
            WTFMove(*serviceWorkerIdentifier),
            WTFMove(*script),
            WTFMove(*certificateInfo),
            WTFMove(*contentSecurityPolicy),
            WTFMove(*crossOriginEmbedderPolicy),
            WTFMove(*referrerPolicy),
            WTFMove(*scriptURL),
            WTFMove(*workerType),
            WTFMove(*loadedFromDisk),
            WTFMove(*lastNavigationWasAppInitiated),
            WTFMove(*scriptResourceMap),
            WTFMove(*serviceWorkerPageIdentifier),
            WTFMove(*navigationPreloadState)
        }
    };
}

void ArgumentCoder<JSC::ArrayBuffer>::encode(Encoder& encoder, const JSC::ArrayBuffer& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.toVector())>, Vector<uint8_t>>);

    encoder << instance.toVector();
}

std::optional<Ref<JSC::ArrayBuffer>> ArgumentCoder<JSC::ArrayBuffer>::decode(Decoder& decoder)
{
    auto toVector = decoder.decode<Vector<uint8_t>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        JSC::ArrayBuffer::create(
            WTFMove(*toVector)
        )
    };
}

void ArgumentCoder<JSC::ArrayBufferContents>::encode(Encoder& encoder, const JSC::ArrayBufferContents& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.span())>, std::span<const uint8_t>>);

    encoder << instance.span();
}

std::optional<JSC::ArrayBufferContents> ArgumentCoder<JSC::ArrayBufferContents>::decode(Decoder& decoder)
{
    auto span = decoder.decode<std::span<const uint8_t>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        JSC::ArrayBufferContents::fromSpan(
            WTFMove(*span)
        )
    };
}

void ArgumentCoder<WebCore::GlobalFrameIdentifier>::encode(Encoder& encoder, const WebCore::GlobalFrameIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pageID)>, WebCore::PageIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameID)>, WebCore::FrameIdentifier>);
    struct ShouldBeSameSizeAsGlobalFrameIdentifier : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::GlobalFrameIdentifier>, false> {
        WebCore::PageIdentifier pageID;
        WebCore::FrameIdentifier frameID;
    };
    static_assert(sizeof(ShouldBeSameSizeAsGlobalFrameIdentifier) == sizeof(WebCore::GlobalFrameIdentifier));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::GlobalFrameIdentifier, pageID)
        , offsetof(WebCore::GlobalFrameIdentifier, frameID)
    >::value);

    encoder << instance.pageID;
    encoder << instance.frameID;
}

std::optional<WebCore::GlobalFrameIdentifier> ArgumentCoder<WebCore::GlobalFrameIdentifier>::decode(Decoder& decoder)
{
    auto pageID = decoder.decode<WebCore::PageIdentifier>();
    auto frameID = decoder.decode<WebCore::FrameIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::GlobalFrameIdentifier {
            WTFMove(*pageID),
            WTFMove(*frameID)
        }
    };
}

void ArgumentCoder<WebCore::GlobalWindowIdentifier>::encode(Encoder& encoder, const WebCore::GlobalWindowIdentifier& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processIdentifier)>, WebCore::ProcessIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.windowIdentifier)>, WebCore::WindowIdentifier>);
    struct ShouldBeSameSizeAsGlobalWindowIdentifier : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::GlobalWindowIdentifier>, false> {
        WebCore::ProcessIdentifier processIdentifier;
        WebCore::WindowIdentifier windowIdentifier;
    };
    static_assert(sizeof(ShouldBeSameSizeAsGlobalWindowIdentifier) == sizeof(WebCore::GlobalWindowIdentifier));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::GlobalWindowIdentifier, processIdentifier)
        , offsetof(WebCore::GlobalWindowIdentifier, windowIdentifier)
    >::value);

    encoder << instance.processIdentifier;
    encoder << instance.windowIdentifier;
}

std::optional<WebCore::GlobalWindowIdentifier> ArgumentCoder<WebCore::GlobalWindowIdentifier>::decode(Decoder& decoder)
{
    auto processIdentifier = decoder.decode<WebCore::ProcessIdentifier>();
    auto windowIdentifier = decoder.decode<WebCore::WindowIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::GlobalWindowIdentifier {
            WTFMove(*processIdentifier),
            WTFMove(*windowIdentifier)
        }
    };
}

void ArgumentCoder<WebCore::InteractionRegion>::encode(Encoder& encoder, const WebCore::InteractionRegion& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::InteractionRegion::Type>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.nodeIdentifier)>, WebCore::NodeIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rectInLayerCoordinates)>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cornerRadius)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maskedCorners)>, OptionSet<WebCore::InteractionRegion::CornerMask>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentHint)>, WebCore::InteractionRegion::ContentHint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.clipPath)>, std::optional<WebCore::Path>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.useContinuousCorners)>, bool>);
#if ENABLE(INTERACTION_REGION_TEXT_CONTENT)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.text)>, String>);
#endif
    struct ShouldBeSameSizeAsInteractionRegion : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::InteractionRegion>, false> {
        WebCore::InteractionRegion::Type type;
        WebCore::NodeIdentifier nodeIdentifier;
        WebCore::FloatRect rectInLayerCoordinates;
        float cornerRadius;
        OptionSet<WebCore::InteractionRegion::CornerMask> maskedCorners;
        WebCore::InteractionRegion::ContentHint contentHint;
        std::optional<WebCore::Path> clipPath;
        bool useContinuousCorners;
#if ENABLE(INTERACTION_REGION_TEXT_CONTENT)
        String text;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsInteractionRegion) == sizeof(WebCore::InteractionRegion));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::InteractionRegion, type)
        , offsetof(WebCore::InteractionRegion, nodeIdentifier)
        , offsetof(WebCore::InteractionRegion, rectInLayerCoordinates)
        , offsetof(WebCore::InteractionRegion, cornerRadius)
        , offsetof(WebCore::InteractionRegion, maskedCorners)
        , offsetof(WebCore::InteractionRegion, contentHint)
        , offsetof(WebCore::InteractionRegion, clipPath)
        , offsetof(WebCore::InteractionRegion, useContinuousCorners)
#if ENABLE(INTERACTION_REGION_TEXT_CONTENT)
        , offsetof(WebCore::InteractionRegion, text)
#endif
    >::value);

    encoder << instance.type;
    encoder << instance.nodeIdentifier;
    encoder << instance.rectInLayerCoordinates;
    encoder << instance.cornerRadius;
    encoder << instance.maskedCorners;
    encoder << instance.contentHint;
    encoder << instance.clipPath;
    encoder << instance.useContinuousCorners;
#if ENABLE(INTERACTION_REGION_TEXT_CONTENT)
    encoder << instance.text;
#endif
}

std::optional<WebCore::InteractionRegion> ArgumentCoder<WebCore::InteractionRegion>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::InteractionRegion::Type>();
    auto nodeIdentifier = decoder.decode<WebCore::NodeIdentifier>();
    auto rectInLayerCoordinates = decoder.decode<WebCore::FloatRect>();
    auto cornerRadius = decoder.decode<float>();
    auto maskedCorners = decoder.decode<OptionSet<WebCore::InteractionRegion::CornerMask>>();
    auto contentHint = decoder.decode<WebCore::InteractionRegion::ContentHint>();
    auto clipPath = decoder.decode<std::optional<WebCore::Path>>();
    auto useContinuousCorners = decoder.decode<bool>();
#if ENABLE(INTERACTION_REGION_TEXT_CONTENT)
    auto text = decoder.decode<String>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::InteractionRegion {
            WTFMove(*type),
            WTFMove(*nodeIdentifier),
            WTFMove(*rectInLayerCoordinates),
            WTFMove(*cornerRadius),
            WTFMove(*maskedCorners),
            WTFMove(*contentHint),
            WTFMove(*clipPath),
            WTFMove(*useContinuousCorners),
#if ENABLE(INTERACTION_REGION_TEXT_CONTENT)
            WTFMove(*text)
#endif
        }
    };
}

void ArgumentCoder<WebCore::Region::Span>::encode(Encoder& encoder, const WebCore::Region::Span& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.y)>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.segmentIndex)>, uint64_t>);
    struct ShouldBeSameSizeAsSpan : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Region::Span>, false> {
        int y;
        uint64_t segmentIndex;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSpan) == sizeof(WebCore::Region::Span));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Region::Span, y)
        , offsetof(WebCore::Region::Span, segmentIndex)
    >::value);

    encoder << instance.y;
    encoder << instance.segmentIndex;
}

void ArgumentCoder<WebCore::Region::Span>::encode(StreamConnectionEncoder& encoder, const WebCore::Region::Span& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.y)>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.segmentIndex)>, uint64_t>);
    struct ShouldBeSameSizeAsSpan : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Region::Span>, false> {
        int y;
        uint64_t segmentIndex;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSpan) == sizeof(WebCore::Region::Span));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Region::Span, y)
        , offsetof(WebCore::Region::Span, segmentIndex)
    >::value);

    encoder << instance.y;
    encoder << instance.segmentIndex;
}

std::optional<WebCore::Region::Span> ArgumentCoder<WebCore::Region::Span>::decode(Decoder& decoder)
{
    auto y = decoder.decode<int>();
    auto segmentIndex = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Region::Span {
            WTFMove(*y),
            WTFMove(*segmentIndex)
        }
    };
}

void ArgumentCoder<WebCore::Region::Shape>::encode(Encoder& encoder, const WebCore::Region::Shape& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_segments)>, Vector<int, 32>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_spans)>, Vector<WebCore::Region::Span, 16>>);
    struct ShouldBeSameSizeAsShape : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Region::Shape>, false> {
        Vector<int, 32> m_segments;
        Vector<WebCore::Region::Span, 16> m_spans;
    };
    static_assert(sizeof(ShouldBeSameSizeAsShape) == sizeof(WebCore::Region::Shape));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Region::Shape, m_segments)
        , offsetof(WebCore::Region::Shape, m_spans)
    >::value);

    encoder << instance.m_segments;
    encoder << instance.m_spans;
}

void ArgumentCoder<WebCore::Region::Shape>::encode(StreamConnectionEncoder& encoder, const WebCore::Region::Shape& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_segments)>, Vector<int, 32>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_spans)>, Vector<WebCore::Region::Span, 16>>);
    struct ShouldBeSameSizeAsShape : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Region::Shape>, false> {
        Vector<int, 32> m_segments;
        Vector<WebCore::Region::Span, 16> m_spans;
    };
    static_assert(sizeof(ShouldBeSameSizeAsShape) == sizeof(WebCore::Region::Shape));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Region::Shape, m_segments)
        , offsetof(WebCore::Region::Shape, m_spans)
    >::value);

    encoder << instance.m_segments;
    encoder << instance.m_spans;
}

std::optional<WebCore::Region::Shape> ArgumentCoder<WebCore::Region::Shape>::decode(Decoder& decoder)
{
    auto m_segments = decoder.decode<Vector<int, 32>>();
    auto m_spans = decoder.decode<Vector<WebCore::Region::Span, 16>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(WebCore::Region::Shape::isValidShape(m_segments->span(), m_spans->span())))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Region::Shape {
            WTFMove(*m_segments),
            WTFMove(*m_spans)
        }
    };
}

void ArgumentCoder<WebCore::Region>::encode(Encoder& encoder, const WebCore::Region& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data())>, WebCore::Region::Shape>);

    encoder << instance.data();
}

void ArgumentCoder<WebCore::Region>::encode(StreamConnectionEncoder& encoder, const WebCore::Region& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data())>, WebCore::Region::Shape>);

    encoder << instance.data();
}

std::optional<WebCore::Region> ArgumentCoder<WebCore::Region>::decode(Decoder& decoder)
{
    auto data = decoder.decode<WebCore::Region::Shape>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Region {
            WTFMove(*data)
        }
    };
}

void ArgumentCoder<WebCore::ISOWebVTTCue>::encode(Encoder& encoder, const WebCore::ISOWebVTTCue& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.presentationTime())>, MediaTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.duration())>, MediaTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.id())>, AtomString>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cueText())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.settings())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceID())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.originalStartTime())>, String>);

    encoder << instance.presentationTime();
    encoder << instance.duration();
    encoder << instance.id();
    encoder << instance.cueText();
    encoder << instance.settings();
    encoder << instance.sourceID();
    encoder << instance.originalStartTime();
}

std::optional<WebCore::ISOWebVTTCue> ArgumentCoder<WebCore::ISOWebVTTCue>::decode(Decoder& decoder)
{
    auto presentationTime = decoder.decode<MediaTime>();
    auto duration = decoder.decode<MediaTime>();
    auto id = decoder.decode<AtomString>();
    auto cueText = decoder.decode<String>();
    auto settings = decoder.decode<String>();
    auto sourceID = decoder.decode<String>();
    auto originalStartTime = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ISOWebVTTCue {
            WTFMove(*presentationTime),
            WTFMove(*duration),
            WTFMove(*id),
            WTFMove(*cueText),
            WTFMove(*settings),
            WTFMove(*sourceID),
            WTFMove(*originalStartTime)
        }
    };
}

#if ENABLE(WEB_AUTHN)
void ArgumentCoder<WebCore::MockWebAuthenticationConfiguration::LocalConfiguration>::encode(Encoder& encoder, const WebCore::MockWebAuthenticationConfiguration::LocalConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.userVerification)>, WebCore::MockWebAuthenticationConfiguration::UserVerification>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.acceptAttestation)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.privateKeyBase64)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.userCertificateBase64)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.intermediateCACertificateBase64)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.preferredCredentialIdBase64)>, String>);
    struct ShouldBeSameSizeAsLocalConfiguration : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MockWebAuthenticationConfiguration::LocalConfiguration>, false> {
        WebCore::MockWebAuthenticationConfiguration::UserVerification userVerification;
        bool acceptAttestation;
        String privateKeyBase64;
        String userCertificateBase64;
        String intermediateCACertificateBase64;
        String preferredCredentialIdBase64;
    };
    static_assert(sizeof(ShouldBeSameSizeAsLocalConfiguration) == sizeof(WebCore::MockWebAuthenticationConfiguration::LocalConfiguration));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MockWebAuthenticationConfiguration::LocalConfiguration, userVerification)
        , offsetof(WebCore::MockWebAuthenticationConfiguration::LocalConfiguration, acceptAttestation)
        , offsetof(WebCore::MockWebAuthenticationConfiguration::LocalConfiguration, privateKeyBase64)
        , offsetof(WebCore::MockWebAuthenticationConfiguration::LocalConfiguration, userCertificateBase64)
        , offsetof(WebCore::MockWebAuthenticationConfiguration::LocalConfiguration, intermediateCACertificateBase64)
        , offsetof(WebCore::MockWebAuthenticationConfiguration::LocalConfiguration, preferredCredentialIdBase64)
    >::value);

    encoder << instance.userVerification;
    encoder << instance.acceptAttestation;
    encoder << instance.privateKeyBase64;
    encoder << instance.userCertificateBase64;
    encoder << instance.intermediateCACertificateBase64;
    encoder << instance.preferredCredentialIdBase64;
}

std::optional<WebCore::MockWebAuthenticationConfiguration::LocalConfiguration> ArgumentCoder<WebCore::MockWebAuthenticationConfiguration::LocalConfiguration>::decode(Decoder& decoder)
{
    auto userVerification = decoder.decode<WebCore::MockWebAuthenticationConfiguration::UserVerification>();
    auto acceptAttestation = decoder.decode<bool>();
    auto privateKeyBase64 = decoder.decode<String>();
    auto userCertificateBase64 = decoder.decode<String>();
    auto intermediateCACertificateBase64 = decoder.decode<String>();
    auto preferredCredentialIdBase64 = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MockWebAuthenticationConfiguration::LocalConfiguration {
            WTFMove(*userVerification),
            WTFMove(*acceptAttestation),
            WTFMove(*privateKeyBase64),
            WTFMove(*userCertificateBase64),
            WTFMove(*intermediateCACertificateBase64),
            WTFMove(*preferredCredentialIdBase64)
        }
    };
}

#endif

#if ENABLE(WEB_AUTHN)
void ArgumentCoder<WebCore::MockWebAuthenticationConfiguration::HidConfiguration>::encode(Encoder& encoder, const WebCore::MockWebAuthenticationConfiguration::HidConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.payloadBase64)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stage)>, WebCore::MockWebAuthenticationConfiguration::HidStage>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.subStage)>, WebCore::MockWebAuthenticationConfiguration::HidSubStage>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.error)>, WebCore::MockWebAuthenticationConfiguration::HidError>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isU2f)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.keepAlive)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fastDataArrival)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.continueAfterErrorData)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.canDowngrade)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.expectCancel)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportClientPin)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportInternalUV)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxCredentialCountInList)>, int64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxCredentialIdLength)>, int64_t>);
    struct ShouldBeSameSizeAsHidConfiguration : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MockWebAuthenticationConfiguration::HidConfiguration>, false> {
        Vector<String> payloadBase64;
        WebCore::MockWebAuthenticationConfiguration::HidStage stage;
        WebCore::MockWebAuthenticationConfiguration::HidSubStage subStage;
        WebCore::MockWebAuthenticationConfiguration::HidError error;
        bool isU2f;
        bool keepAlive;
        bool fastDataArrival;
        bool continueAfterErrorData;
        bool canDowngrade;
        bool expectCancel;
        bool supportClientPin;
        bool supportInternalUV;
        int64_t maxCredentialCountInList;
        int64_t maxCredentialIdLength;
    };
    static_assert(sizeof(ShouldBeSameSizeAsHidConfiguration) == sizeof(WebCore::MockWebAuthenticationConfiguration::HidConfiguration));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MockWebAuthenticationConfiguration::HidConfiguration, payloadBase64)
        , offsetof(WebCore::MockWebAuthenticationConfiguration::HidConfiguration, stage)
        , offsetof(WebCore::MockWebAuthenticationConfiguration::HidConfiguration, subStage)
        , offsetof(WebCore::MockWebAuthenticationConfiguration::HidConfiguration, error)
        , offsetof(WebCore::MockWebAuthenticationConfiguration::HidConfiguration, isU2f)
        , offsetof(WebCore::MockWebAuthenticationConfiguration::HidConfiguration, keepAlive)
        , offsetof(WebCore::MockWebAuthenticationConfiguration::HidConfiguration, fastDataArrival)
        , offsetof(WebCore::MockWebAuthenticationConfiguration::HidConfiguration, continueAfterErrorData)
        , offsetof(WebCore::MockWebAuthenticationConfiguration::HidConfiguration, canDowngrade)
        , offsetof(WebCore::MockWebAuthenticationConfiguration::HidConfiguration, expectCancel)
        , offsetof(WebCore::MockWebAuthenticationConfiguration::HidConfiguration, supportClientPin)
        , offsetof(WebCore::MockWebAuthenticationConfiguration::HidConfiguration, supportInternalUV)
        , offsetof(WebCore::MockWebAuthenticationConfiguration::HidConfiguration, maxCredentialCountInList)
        , offsetof(WebCore::MockWebAuthenticationConfiguration::HidConfiguration, maxCredentialIdLength)
    >::value);

    encoder << instance.payloadBase64;
    encoder << instance.stage;
    encoder << instance.subStage;
    encoder << instance.error;
    encoder << instance.isU2f;
    encoder << instance.keepAlive;
    encoder << instance.fastDataArrival;
    encoder << instance.continueAfterErrorData;
    encoder << instance.canDowngrade;
    encoder << instance.expectCancel;
    encoder << instance.supportClientPin;
    encoder << instance.supportInternalUV;
    encoder << instance.maxCredentialCountInList;
    encoder << instance.maxCredentialIdLength;
}

std::optional<WebCore::MockWebAuthenticationConfiguration::HidConfiguration> ArgumentCoder<WebCore::MockWebAuthenticationConfiguration::HidConfiguration>::decode(Decoder& decoder)
{
    auto payloadBase64 = decoder.decode<Vector<String>>();
    auto stage = decoder.decode<WebCore::MockWebAuthenticationConfiguration::HidStage>();
    auto subStage = decoder.decode<WebCore::MockWebAuthenticationConfiguration::HidSubStage>();
    auto error = decoder.decode<WebCore::MockWebAuthenticationConfiguration::HidError>();
    auto isU2f = decoder.decode<bool>();
    auto keepAlive = decoder.decode<bool>();
    auto fastDataArrival = decoder.decode<bool>();
    auto continueAfterErrorData = decoder.decode<bool>();
    auto canDowngrade = decoder.decode<bool>();
    auto expectCancel = decoder.decode<bool>();
    auto supportClientPin = decoder.decode<bool>();
    auto supportInternalUV = decoder.decode<bool>();
    auto maxCredentialCountInList = decoder.decode<int64_t>();
    auto maxCredentialIdLength = decoder.decode<int64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MockWebAuthenticationConfiguration::HidConfiguration {
            WTFMove(*payloadBase64),
            WTFMove(*stage),
            WTFMove(*subStage),
            WTFMove(*error),
            WTFMove(*isU2f),
            WTFMove(*keepAlive),
            WTFMove(*fastDataArrival),
            WTFMove(*continueAfterErrorData),
            WTFMove(*canDowngrade),
            WTFMove(*expectCancel),
            WTFMove(*supportClientPin),
            WTFMove(*supportInternalUV),
            WTFMove(*maxCredentialCountInList),
            WTFMove(*maxCredentialIdLength)
        }
    };
}

#endif

#if ENABLE(WEB_AUTHN)
void ArgumentCoder<WebCore::MockWebAuthenticationConfiguration::NfcConfiguration>::encode(Encoder& encoder, const WebCore::MockWebAuthenticationConfiguration::NfcConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.error)>, WebCore::MockWebAuthenticationConfiguration::NfcError>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.payloadBase64)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.multipleTags)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.multiplePhysicalTags)>, bool>);
    struct ShouldBeSameSizeAsNfcConfiguration : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MockWebAuthenticationConfiguration::NfcConfiguration>, false> {
        WebCore::MockWebAuthenticationConfiguration::NfcError error;
        Vector<String> payloadBase64;
        bool multipleTags;
        bool multiplePhysicalTags;
    };
    static_assert(sizeof(ShouldBeSameSizeAsNfcConfiguration) == sizeof(WebCore::MockWebAuthenticationConfiguration::NfcConfiguration));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MockWebAuthenticationConfiguration::NfcConfiguration, error)
        , offsetof(WebCore::MockWebAuthenticationConfiguration::NfcConfiguration, payloadBase64)
        , offsetof(WebCore::MockWebAuthenticationConfiguration::NfcConfiguration, multipleTags)
        , offsetof(WebCore::MockWebAuthenticationConfiguration::NfcConfiguration, multiplePhysicalTags)
    >::value);

    encoder << instance.error;
    encoder << instance.payloadBase64;
    encoder << instance.multipleTags;
    encoder << instance.multiplePhysicalTags;
}

std::optional<WebCore::MockWebAuthenticationConfiguration::NfcConfiguration> ArgumentCoder<WebCore::MockWebAuthenticationConfiguration::NfcConfiguration>::decode(Decoder& decoder)
{
    auto error = decoder.decode<WebCore::MockWebAuthenticationConfiguration::NfcError>();
    auto payloadBase64 = decoder.decode<Vector<String>>();
    auto multipleTags = decoder.decode<bool>();
    auto multiplePhysicalTags = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MockWebAuthenticationConfiguration::NfcConfiguration {
            WTFMove(*error),
            WTFMove(*payloadBase64),
            WTFMove(*multipleTags),
            WTFMove(*multiplePhysicalTags)
        }
    };
}

#endif

#if ENABLE(WEB_AUTHN)
void ArgumentCoder<WebCore::MockWebAuthenticationConfiguration::CcidConfiguration>::encode(Encoder& encoder, const WebCore::MockWebAuthenticationConfiguration::CcidConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.payloadBase64)>, Vector<String>>);
    struct ShouldBeSameSizeAsCcidConfiguration : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MockWebAuthenticationConfiguration::CcidConfiguration>, false> {
        Vector<String> payloadBase64;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCcidConfiguration) == sizeof(WebCore::MockWebAuthenticationConfiguration::CcidConfiguration));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MockWebAuthenticationConfiguration::CcidConfiguration, payloadBase64)
    >::value);

    encoder << instance.payloadBase64;
}

std::optional<WebCore::MockWebAuthenticationConfiguration::CcidConfiguration> ArgumentCoder<WebCore::MockWebAuthenticationConfiguration::CcidConfiguration>::decode(Decoder& decoder)
{
    auto payloadBase64 = decoder.decode<Vector<String>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MockWebAuthenticationConfiguration::CcidConfiguration {
            WTFMove(*payloadBase64)
        }
    };
}

#endif

#if ENABLE(WEB_AUTHN)
void ArgumentCoder<WebCore::MockWebAuthenticationConfiguration>::encode(Encoder& encoder, const WebCore::MockWebAuthenticationConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.silentFailure)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.local)>, std::optional<WebCore::MockWebAuthenticationConfiguration::LocalConfiguration>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hid)>, std::optional<WebCore::MockWebAuthenticationConfiguration::HidConfiguration>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.nfc)>, std::optional<WebCore::MockWebAuthenticationConfiguration::NfcConfiguration>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ccid)>, std::optional<WebCore::MockWebAuthenticationConfiguration::CcidConfiguration>>);
    struct ShouldBeSameSizeAsMockWebAuthenticationConfiguration : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MockWebAuthenticationConfiguration>, false> {
        bool silentFailure;
        std::optional<WebCore::MockWebAuthenticationConfiguration::LocalConfiguration> local;
        std::optional<WebCore::MockWebAuthenticationConfiguration::HidConfiguration> hid;
        std::optional<WebCore::MockWebAuthenticationConfiguration::NfcConfiguration> nfc;
        std::optional<WebCore::MockWebAuthenticationConfiguration::CcidConfiguration> ccid;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMockWebAuthenticationConfiguration) == sizeof(WebCore::MockWebAuthenticationConfiguration));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MockWebAuthenticationConfiguration, silentFailure)
        , offsetof(WebCore::MockWebAuthenticationConfiguration, local)
        , offsetof(WebCore::MockWebAuthenticationConfiguration, hid)
        , offsetof(WebCore::MockWebAuthenticationConfiguration, nfc)
        , offsetof(WebCore::MockWebAuthenticationConfiguration, ccid)
    >::value);

    encoder << instance.silentFailure;
    encoder << instance.local;
    encoder << instance.hid;
    encoder << instance.nfc;
    encoder << instance.ccid;
}

std::optional<WebCore::MockWebAuthenticationConfiguration> ArgumentCoder<WebCore::MockWebAuthenticationConfiguration>::decode(Decoder& decoder)
{
    auto silentFailure = decoder.decode<bool>();
    auto local = decoder.decode<std::optional<WebCore::MockWebAuthenticationConfiguration::LocalConfiguration>>();
    auto hid = decoder.decode<std::optional<WebCore::MockWebAuthenticationConfiguration::HidConfiguration>>();
    auto nfc = decoder.decode<std::optional<WebCore::MockWebAuthenticationConfiguration::NfcConfiguration>>();
    auto ccid = decoder.decode<std::optional<WebCore::MockWebAuthenticationConfiguration::CcidConfiguration>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MockWebAuthenticationConfiguration {
            WTFMove(*silentFailure),
            WTFMove(*local),
            WTFMove(*hid),
            WTFMove(*nfc),
            WTFMove(*ccid)
        }
    };
}

#endif

#if (ENABLE(WEB_AUTHN)) && (HAVE(DIGITAL_CREDENTIALS_UI))
void ArgumentCoder<WebCore::OpenID4VPRequest>::encode(Encoder& encoder, const WebCore::OpenID4VPRequest& instance)
{
    struct ShouldBeSameSizeAsOpenID4VPRequest : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::OpenID4VPRequest>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsOpenID4VPRequest) == sizeof(WebCore::OpenID4VPRequest));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::OpenID4VPRequest> ArgumentCoder<WebCore::OpenID4VPRequest>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::OpenID4VPRequest {
        }
    };
}

#endif

#if (ENABLE(WEB_AUTHN)) && (HAVE(DIGITAL_CREDENTIALS_UI))
void ArgumentCoder<WebCore::ISO18013ElementInfo>::encode(Encoder& encoder, const WebCore::ISO18013ElementInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isRetaining)>, bool>);
    struct ShouldBeSameSizeAsISO18013ElementInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ISO18013ElementInfo>, false> {
        bool isRetaining;
    };
    static_assert(sizeof(ShouldBeSameSizeAsISO18013ElementInfo) == sizeof(WebCore::ISO18013ElementInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ISO18013ElementInfo, isRetaining)
    >::value);

    encoder << instance.isRetaining;
}

std::optional<WebCore::ISO18013ElementInfo> ArgumentCoder<WebCore::ISO18013ElementInfo>::decode(Decoder& decoder)
{
    auto isRetaining = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ISO18013ElementInfo {
            WTFMove(*isRetaining)
        }
    };
}

#endif

#if (ENABLE(WEB_AUTHN)) && (HAVE(DIGITAL_CREDENTIALS_UI))
void ArgumentCoder<WebCore::ISO18013DocumentRequest>::encode(Encoder& encoder, const WebCore::ISO18013DocumentRequest& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.documentType)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.namespaces)>, Vector<std::pair<String, Vector<std::pair<String, WebCore::ISO18013ElementInfo>>>>>);
    struct ShouldBeSameSizeAsISO18013DocumentRequest : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ISO18013DocumentRequest>, false> {
        String documentType;
        Vector<std::pair<String, Vector<std::pair<String, WebCore::ISO18013ElementInfo>>>> namespaces;
    };
    static_assert(sizeof(ShouldBeSameSizeAsISO18013DocumentRequest) == sizeof(WebCore::ISO18013DocumentRequest));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ISO18013DocumentRequest, documentType)
        , offsetof(WebCore::ISO18013DocumentRequest, namespaces)
    >::value);

    encoder << instance.documentType;
    encoder << instance.namespaces;
}

std::optional<WebCore::ISO18013DocumentRequest> ArgumentCoder<WebCore::ISO18013DocumentRequest>::decode(Decoder& decoder)
{
    auto documentType = decoder.decode<String>();
    auto namespaces = decoder.decode<Vector<std::pair<String, Vector<std::pair<String, WebCore::ISO18013ElementInfo>>>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ISO18013DocumentRequest {
            WTFMove(*documentType),
            WTFMove(*namespaces)
        }
    };
}

#endif

#if (ENABLE(WEB_AUTHN)) && (HAVE(DIGITAL_CREDENTIALS_UI))
void ArgumentCoder<WebCore::ISO18013DocumentRequestSet>::encode(Encoder& encoder, const WebCore::ISO18013DocumentRequestSet& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requests)>, Vector<WebCore::ISO18013DocumentRequest>>);
    struct ShouldBeSameSizeAsISO18013DocumentRequestSet : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ISO18013DocumentRequestSet>, false> {
        Vector<WebCore::ISO18013DocumentRequest> requests;
    };
    static_assert(sizeof(ShouldBeSameSizeAsISO18013DocumentRequestSet) == sizeof(WebCore::ISO18013DocumentRequestSet));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ISO18013DocumentRequestSet, requests)
    >::value);

    encoder << instance.requests;
}

std::optional<WebCore::ISO18013DocumentRequestSet> ArgumentCoder<WebCore::ISO18013DocumentRequestSet>::decode(Decoder& decoder)
{
    auto requests = decoder.decode<Vector<WebCore::ISO18013DocumentRequest>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ISO18013DocumentRequestSet {
            WTFMove(*requests)
        }
    };
}

#endif

#if (ENABLE(WEB_AUTHN)) && (HAVE(DIGITAL_CREDENTIALS_UI))
void ArgumentCoder<WebCore::ISO18013PresentmentRequest>::encode(Encoder& encoder, const WebCore::ISO18013PresentmentRequest& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isMandatory)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.documentRequestSets)>, Vector<WebCore::ISO18013DocumentRequestSet>>);
    struct ShouldBeSameSizeAsISO18013PresentmentRequest : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ISO18013PresentmentRequest>, false> {
        bool isMandatory;
        Vector<WebCore::ISO18013DocumentRequestSet> documentRequestSets;
    };
    static_assert(sizeof(ShouldBeSameSizeAsISO18013PresentmentRequest) == sizeof(WebCore::ISO18013PresentmentRequest));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ISO18013PresentmentRequest, isMandatory)
        , offsetof(WebCore::ISO18013PresentmentRequest, documentRequestSets)
    >::value);

    encoder << instance.isMandatory;
    encoder << instance.documentRequestSets;
}

std::optional<WebCore::ISO18013PresentmentRequest> ArgumentCoder<WebCore::ISO18013PresentmentRequest>::decode(Decoder& decoder)
{
    auto isMandatory = decoder.decode<bool>();
    auto documentRequestSets = decoder.decode<Vector<WebCore::ISO18013DocumentRequestSet>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ISO18013PresentmentRequest {
            WTFMove(*isMandatory),
            WTFMove(*documentRequestSets)
        }
    };
}

#endif

#if (ENABLE(WEB_AUTHN)) && (HAVE(DIGITAL_CREDENTIALS_UI))
void ArgumentCoder<WebCore::MobileDocumentRequest>::encode(Encoder& encoder, const WebCore::MobileDocumentRequest& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.deviceRequest)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.encryptionInfo)>, String>);
    struct ShouldBeSameSizeAsMobileDocumentRequest : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MobileDocumentRequest>, false> {
        String deviceRequest;
        String encryptionInfo;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMobileDocumentRequest) == sizeof(WebCore::MobileDocumentRequest));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MobileDocumentRequest, deviceRequest)
        , offsetof(WebCore::MobileDocumentRequest, encryptionInfo)
    >::value);

    encoder << instance.deviceRequest;
    encoder << instance.encryptionInfo;
}

std::optional<WebCore::MobileDocumentRequest> ArgumentCoder<WebCore::MobileDocumentRequest>::decode(Decoder& decoder)
{
    auto deviceRequest = decoder.decode<String>();
    auto encryptionInfo = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MobileDocumentRequest {
            WTFMove(*deviceRequest),
            WTFMove(*encryptionInfo)
        }
    };
}

#endif

#if (ENABLE(WEB_AUTHN)) && (HAVE(DIGITAL_CREDENTIALS_UI))
void ArgumentCoder<WebCore::ValidatedMobileDocumentRequest>::encode(Encoder& encoder, const WebCore::ValidatedMobileDocumentRequest& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requestAuthentications)>, Vector<WebCore::CertificateInfo>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.presentmentRequests)>, Vector<WebCore::ISO18013PresentmentRequest>>);
    struct ShouldBeSameSizeAsValidatedMobileDocumentRequest : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ValidatedMobileDocumentRequest>, false> {
        Vector<WebCore::CertificateInfo> requestAuthentications;
        Vector<WebCore::ISO18013PresentmentRequest> presentmentRequests;
    };
    static_assert(sizeof(ShouldBeSameSizeAsValidatedMobileDocumentRequest) == sizeof(WebCore::ValidatedMobileDocumentRequest));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ValidatedMobileDocumentRequest, requestAuthentications)
        , offsetof(WebCore::ValidatedMobileDocumentRequest, presentmentRequests)
    >::value);

    encoder << instance.requestAuthentications;
    encoder << instance.presentmentRequests;
}

std::optional<WebCore::ValidatedMobileDocumentRequest> ArgumentCoder<WebCore::ValidatedMobileDocumentRequest>::decode(Decoder& decoder)
{
    auto requestAuthentications = decoder.decode<Vector<WebCore::CertificateInfo>>();
    auto presentmentRequests = decoder.decode<Vector<WebCore::ISO18013PresentmentRequest>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ValidatedMobileDocumentRequest {
            WTFMove(*requestAuthentications),
            WTFMove(*presentmentRequests)
        }
    };
}

#endif

#if (ENABLE(WEB_AUTHN)) && (HAVE(DIGITAL_CREDENTIALS_UI))
void ArgumentCoder<WebCore::DigitalCredentialsRequestData>::encode(Encoder& encoder, const WebCore::DigitalCredentialsRequestData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requests)>, Vector<Variant<WebCore::ValidatedMobileDocumentRequest, WebCore::OpenID4VPRequest>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.topOrigin)>, WebCore::SecurityOriginData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.documentOrigin)>, WebCore::SecurityOriginData>);
    struct ShouldBeSameSizeAsDigitalCredentialsRequestData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::DigitalCredentialsRequestData>, false> {
        Vector<Variant<WebCore::ValidatedMobileDocumentRequest, WebCore::OpenID4VPRequest>> requests;
        WebCore::SecurityOriginData topOrigin;
        WebCore::SecurityOriginData documentOrigin;
    };
    static_assert(sizeof(ShouldBeSameSizeAsDigitalCredentialsRequestData) == sizeof(WebCore::DigitalCredentialsRequestData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::DigitalCredentialsRequestData, requests)
        , offsetof(WebCore::DigitalCredentialsRequestData, topOrigin)
        , offsetof(WebCore::DigitalCredentialsRequestData, documentOrigin)
    >::value);

    encoder << instance.requests;
    encoder << instance.topOrigin;
    encoder << instance.documentOrigin;
}

std::optional<WebCore::DigitalCredentialsRequestData> ArgumentCoder<WebCore::DigitalCredentialsRequestData>::decode(Decoder& decoder)
{
    auto requests = decoder.decode<Vector<Variant<WebCore::ValidatedMobileDocumentRequest, WebCore::OpenID4VPRequest>>>();
    auto topOrigin = decoder.decode<WebCore::SecurityOriginData>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(!topOrigin->isNull()))
        return std::nullopt;
    auto documentOrigin = decoder.decode<WebCore::SecurityOriginData>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(!documentOrigin->isNull()))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DigitalCredentialsRequestData {
            WTFMove(*requests),
            WTFMove(*topOrigin),
            WTFMove(*documentOrigin)
        }
    };
}

#endif

#if (ENABLE(WEB_AUTHN)) && (HAVE(DIGITAL_CREDENTIALS_UI))
void ArgumentCoder<WebCore::DigitalCredentialsResponseData>::encode(Encoder& encoder, const WebCore::DigitalCredentialsResponseData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.protocol)>, WebCore::IdentityCredentialProtocol>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.responseDataJSON)>, String>);
    struct ShouldBeSameSizeAsDigitalCredentialsResponseData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::DigitalCredentialsResponseData>, false> {
        WebCore::IdentityCredentialProtocol protocol;
        String responseDataJSON;
    };
    static_assert(sizeof(ShouldBeSameSizeAsDigitalCredentialsResponseData) == sizeof(WebCore::DigitalCredentialsResponseData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::DigitalCredentialsResponseData, protocol)
        , offsetof(WebCore::DigitalCredentialsResponseData, responseDataJSON)
    >::value);

    encoder << instance.protocol;
    encoder << instance.responseDataJSON;
}

std::optional<WebCore::DigitalCredentialsResponseData> ArgumentCoder<WebCore::DigitalCredentialsResponseData>::decode(Decoder& decoder)
{
    auto protocol = decoder.decode<WebCore::IdentityCredentialProtocol>();
    auto responseDataJSON = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DigitalCredentialsResponseData {
            WTFMove(*protocol),
            WTFMove(*responseDataJSON)
        }
    };
}

#endif

#if ENABLE(MEDIA_STREAM)
void ArgumentCoder<WebCore::MockMicrophoneProperties>::encode(Encoder& encoder, const WebCore::MockMicrophoneProperties& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.defaultSampleRate)>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.echoCancellation)>, std::optional<bool>>);
    struct ShouldBeSameSizeAsMockMicrophoneProperties : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MockMicrophoneProperties>, false> {
        int defaultSampleRate;
        std::optional<bool> echoCancellation;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMockMicrophoneProperties) == sizeof(WebCore::MockMicrophoneProperties));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MockMicrophoneProperties, defaultSampleRate)
        , offsetof(WebCore::MockMicrophoneProperties, echoCancellation)
    >::value);

    encoder << instance.defaultSampleRate;
    encoder << instance.echoCancellation;
}

std::optional<WebCore::MockMicrophoneProperties> ArgumentCoder<WebCore::MockMicrophoneProperties>::decode(Decoder& decoder)
{
    auto defaultSampleRate = decoder.decode<int>();
    auto echoCancellation = decoder.decode<std::optional<bool>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MockMicrophoneProperties {
            WTFMove(*defaultSampleRate),
            WTFMove(*echoCancellation)
        }
    };
}

#endif

#if ENABLE(MEDIA_STREAM)
void ArgumentCoder<WebCore::MockSpeakerProperties>::encode(Encoder& encoder, const WebCore::MockSpeakerProperties& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.relatedMicrophoneId)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.defaultSampleRate)>, int>);
    struct ShouldBeSameSizeAsMockSpeakerProperties : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MockSpeakerProperties>, false> {
        String relatedMicrophoneId;
        int defaultSampleRate;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMockSpeakerProperties) == sizeof(WebCore::MockSpeakerProperties));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MockSpeakerProperties, relatedMicrophoneId)
        , offsetof(WebCore::MockSpeakerProperties, defaultSampleRate)
    >::value);

    encoder << instance.relatedMicrophoneId;
    encoder << instance.defaultSampleRate;
}

std::optional<WebCore::MockSpeakerProperties> ArgumentCoder<WebCore::MockSpeakerProperties>::decode(Decoder& decoder)
{
    auto relatedMicrophoneId = decoder.decode<String>();
    auto defaultSampleRate = decoder.decode<int>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MockSpeakerProperties {
            WTFMove(*relatedMicrophoneId),
            WTFMove(*defaultSampleRate)
        }
    };
}

#endif

#if ENABLE(MEDIA_STREAM)
void ArgumentCoder<WebCore::MockCameraProperties>::encode(Encoder& encoder, const WebCore::MockCameraProperties& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.defaultFrameRate)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.facingMode)>, WebCore::VideoFacingMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.presets)>, Vector<WebCore::VideoPresetData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fillColor)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.whiteBalanceMode)>, Vector<WebCore::MeteringMode>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasTorch)>, bool>);
    struct ShouldBeSameSizeAsMockCameraProperties : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MockCameraProperties>, false> {
        double defaultFrameRate;
        WebCore::VideoFacingMode facingMode;
        Vector<WebCore::VideoPresetData> presets;
        WebCore::Color fillColor;
        Vector<WebCore::MeteringMode> whiteBalanceMode;
        bool hasTorch;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMockCameraProperties) == sizeof(WebCore::MockCameraProperties));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MockCameraProperties, defaultFrameRate)
        , offsetof(WebCore::MockCameraProperties, facingMode)
        , offsetof(WebCore::MockCameraProperties, presets)
        , offsetof(WebCore::MockCameraProperties, fillColor)
        , offsetof(WebCore::MockCameraProperties, whiteBalanceMode)
        , offsetof(WebCore::MockCameraProperties, hasTorch)
    >::value);

    encoder << instance.defaultFrameRate;
    encoder << instance.facingMode;
    encoder << instance.presets;
    encoder << instance.fillColor;
    encoder << instance.whiteBalanceMode;
    encoder << instance.hasTorch;
}

std::optional<WebCore::MockCameraProperties> ArgumentCoder<WebCore::MockCameraProperties>::decode(Decoder& decoder)
{
    auto defaultFrameRate = decoder.decode<double>();
    auto facingMode = decoder.decode<WebCore::VideoFacingMode>();
    auto presets = decoder.decode<Vector<WebCore::VideoPresetData>>();
    auto fillColor = decoder.decode<WebCore::Color>();
    auto whiteBalanceMode = decoder.decode<Vector<WebCore::MeteringMode>>();
    auto hasTorch = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MockCameraProperties {
            WTFMove(*defaultFrameRate),
            WTFMove(*facingMode),
            WTFMove(*presets),
            WTFMove(*fillColor),
            WTFMove(*whiteBalanceMode),
            WTFMove(*hasTorch)
        }
    };
}

#endif

#if ENABLE(MEDIA_STREAM)
void ArgumentCoder<WebCore::MockDisplayProperties>::encode(Encoder& encoder, const WebCore::MockDisplayProperties& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::CaptureDevice::DeviceType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fillColor)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.defaultSize)>, WebCore::IntSize>);
    struct ShouldBeSameSizeAsMockDisplayProperties : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MockDisplayProperties>, false> {
        WebCore::CaptureDevice::DeviceType type;
        WebCore::Color fillColor;
        WebCore::IntSize defaultSize;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMockDisplayProperties) == sizeof(WebCore::MockDisplayProperties));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MockDisplayProperties, type)
        , offsetof(WebCore::MockDisplayProperties, fillColor)
        , offsetof(WebCore::MockDisplayProperties, defaultSize)
    >::value);

    encoder << instance.type;
    encoder << instance.fillColor;
    encoder << instance.defaultSize;
}

std::optional<WebCore::MockDisplayProperties> ArgumentCoder<WebCore::MockDisplayProperties>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::CaptureDevice::DeviceType>();
    auto fillColor = decoder.decode<WebCore::Color>();
    auto defaultSize = decoder.decode<WebCore::IntSize>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MockDisplayProperties {
            WTFMove(*type),
            WTFMove(*fillColor),
            WTFMove(*defaultSize)
        }
    };
}

#endif

#if ENABLE(MEDIA_STREAM)
void ArgumentCoder<WebCore::MockMediaDevice>::encode(Encoder& encoder, const WebCore::MockMediaDevice& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.persistentId)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.flags)>, OptionSet<WebCore::MockMediaDevice::Flag>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isDefault)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.properties)>, Variant<WebCore::MockMicrophoneProperties, WebCore::MockSpeakerProperties, WebCore::MockCameraProperties, WebCore::MockDisplayProperties>>);
    struct ShouldBeSameSizeAsMockMediaDevice : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MockMediaDevice>, false> {
        String persistentId;
        String label;
        OptionSet<WebCore::MockMediaDevice::Flag> flags;
        bool isDefault;
        Variant<WebCore::MockMicrophoneProperties, WebCore::MockSpeakerProperties, WebCore::MockCameraProperties, WebCore::MockDisplayProperties> properties;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMockMediaDevice) == sizeof(WebCore::MockMediaDevice));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MockMediaDevice, persistentId)
        , offsetof(WebCore::MockMediaDevice, label)
        , offsetof(WebCore::MockMediaDevice, flags)
        , offsetof(WebCore::MockMediaDevice, isDefault)
        , offsetof(WebCore::MockMediaDevice, properties)
    >::value);

    encoder << instance.persistentId;
    encoder << instance.label;
    encoder << instance.flags;
    encoder << instance.isDefault;
    encoder << instance.properties;
}

std::optional<WebCore::MockMediaDevice> ArgumentCoder<WebCore::MockMediaDevice>::decode(Decoder& decoder)
{
    auto persistentId = decoder.decode<String>();
    auto label = decoder.decode<String>();
    auto flags = decoder.decode<OptionSet<WebCore::MockMediaDevice::Flag>>();
    auto isDefault = decoder.decode<bool>();
    auto properties = decoder.decode<Variant<WebCore::MockMicrophoneProperties, WebCore::MockSpeakerProperties, WebCore::MockCameraProperties, WebCore::MockDisplayProperties>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MockMediaDevice {
            WTFMove(*persistentId),
            WTFMove(*label),
            WTFMove(*flags),
            WTFMove(*isDefault),
            WTFMove(*properties)
        }
    };
}

#endif

#if ENABLE(THREADED_ANIMATION_RESOLUTION)
void ArgumentCoder<WebCore::Constant<WebCore::CSSValueAuto>>::encode(Encoder& encoder, const WebCore::Constant<WebCore::CSSValueAuto>& instance)
{
    struct ShouldBeSameSizeAsConstant_WebCore_CSSValueAuto_ : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Constant<WebCore::CSSValueAuto>>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsConstant_WebCore_CSSValueAuto_) == sizeof(WebCore::Constant<WebCore::CSSValueAuto>));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::Constant<WebCore::CSSValueAuto>> ArgumentCoder<WebCore::Constant<WebCore::CSSValueAuto>>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Constant<WebCore::CSSValueAuto> {
        }
    };
}

#endif

#if ENABLE(THREADED_ANIMATION_RESOLUTION)
void ArgumentCoder<WebCore::Style::OffsetRotate>::encode(Encoder& encoder, const WebCore::Style::OffsetRotate& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.autoKeyword())>, std::optional<WebCore::CSS::Keyword::Auto>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.angle())>, WebCore::Style::AngleAllFloat>);

    encoder << instance.autoKeyword();
    encoder << instance.angle();
}

std::optional<WebCore::Style::OffsetRotate> ArgumentCoder<WebCore::Style::OffsetRotate>::decode(Decoder& decoder)
{
    auto autoKeyword = decoder.decode<std::optional<WebCore::CSS::Keyword::Auto>>();
    auto angle = decoder.decode<WebCore::Style::AngleAllFloat>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Style::OffsetRotate {
            WTFMove(*autoKeyword),
            WTFMove(*angle)
        }
    };
}

#endif

#if ENABLE(THREADED_ANIMATION_RESOLUTION)
void ArgumentCoder<WebCore::AcceleratedEffectValues>::encode(Encoder& encoder, const WebCore::AcceleratedEffectValues& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.opacity)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.transformOperationData)>, std::optional<WebCore::TransformOperationData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.transformOrigin)>, WebCore::LengthPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.transformBox)>, WebCore::TransformBox>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.transform)>, WebCore::TransformOperations>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.translate)>, RefPtr<WebCore::TransformOperation>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scale)>, RefPtr<WebCore::TransformOperation>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rotate)>, RefPtr<WebCore::TransformOperation>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offsetPath)>, RefPtr<WebCore::PathOperation>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offsetDistance)>, WebCore::Length>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offsetPosition)>, WebCore::LengthPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offsetAnchor)>, WebCore::LengthPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offsetRotate)>, WebCore::Style::OffsetRotate>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.filter)>, WebCore::FilterOperations>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.backdropFilter)>, WebCore::FilterOperations>);
    struct ShouldBeSameSizeAsAcceleratedEffectValues : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::AcceleratedEffectValues>, false> {
        float opacity;
        std::optional<WebCore::TransformOperationData> transformOperationData;
        WebCore::LengthPoint transformOrigin;
        WebCore::TransformBox transformBox;
        WebCore::TransformOperations transform;
        RefPtr<WebCore::TransformOperation> translate;
        RefPtr<WebCore::TransformOperation> scale;
        RefPtr<WebCore::TransformOperation> rotate;
        RefPtr<WebCore::PathOperation> offsetPath;
        WebCore::Length offsetDistance;
        WebCore::LengthPoint offsetPosition;
        WebCore::LengthPoint offsetAnchor;
        WebCore::Style::OffsetRotate offsetRotate;
        WebCore::FilterOperations filter;
        WebCore::FilterOperations backdropFilter;
    };
    static_assert(sizeof(ShouldBeSameSizeAsAcceleratedEffectValues) == sizeof(WebCore::AcceleratedEffectValues));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::AcceleratedEffectValues, opacity)
        , offsetof(WebCore::AcceleratedEffectValues, transformOperationData)
        , offsetof(WebCore::AcceleratedEffectValues, transformOrigin)
        , offsetof(WebCore::AcceleratedEffectValues, transformBox)
        , offsetof(WebCore::AcceleratedEffectValues, transform)
        , offsetof(WebCore::AcceleratedEffectValues, translate)
        , offsetof(WebCore::AcceleratedEffectValues, scale)
        , offsetof(WebCore::AcceleratedEffectValues, rotate)
        , offsetof(WebCore::AcceleratedEffectValues, offsetPath)
        , offsetof(WebCore::AcceleratedEffectValues, offsetDistance)
        , offsetof(WebCore::AcceleratedEffectValues, offsetPosition)
        , offsetof(WebCore::AcceleratedEffectValues, offsetAnchor)
        , offsetof(WebCore::AcceleratedEffectValues, offsetRotate)
        , offsetof(WebCore::AcceleratedEffectValues, filter)
        , offsetof(WebCore::AcceleratedEffectValues, backdropFilter)
    >::value);

    encoder << instance.opacity;
    encoder << instance.transformOperationData;
    encoder << instance.transformOrigin;
    encoder << instance.transformBox;
    encoder << instance.transform;
    encoder << instance.translate;
    encoder << instance.scale;
    encoder << instance.rotate;
    encoder << instance.offsetPath;
    encoder << instance.offsetDistance;
    encoder << instance.offsetPosition;
    encoder << instance.offsetAnchor;
    encoder << instance.offsetRotate;
    encoder << instance.filter;
    encoder << instance.backdropFilter;
}

std::optional<WebCore::AcceleratedEffectValues> ArgumentCoder<WebCore::AcceleratedEffectValues>::decode(Decoder& decoder)
{
    auto opacity = decoder.decode<float>();
    auto transformOperationData = decoder.decode<std::optional<WebCore::TransformOperationData>>();
    auto transformOrigin = decoder.decode<WebCore::LengthPoint>();
    auto transformBox = decoder.decode<WebCore::TransformBox>();
    auto transform = decoder.decode<WebCore::TransformOperations>();
    auto translate = decoder.decode<RefPtr<WebCore::TransformOperation>>();
    auto scale = decoder.decode<RefPtr<WebCore::TransformOperation>>();
    auto rotate = decoder.decode<RefPtr<WebCore::TransformOperation>>();
    auto offsetPath = decoder.decode<RefPtr<WebCore::PathOperation>>();
    auto offsetDistance = decoder.decode<WebCore::Length>();
    auto offsetPosition = decoder.decode<WebCore::LengthPoint>();
    auto offsetAnchor = decoder.decode<WebCore::LengthPoint>();
    auto offsetRotate = decoder.decode<WebCore::Style::OffsetRotate>();
    auto filter = decoder.decode<WebCore::FilterOperations>();
    auto backdropFilter = decoder.decode<WebCore::FilterOperations>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::AcceleratedEffectValues {
            WTFMove(*opacity),
            WTFMove(*transformOperationData),
            WTFMove(*transformOrigin),
            WTFMove(*transformBox),
            WTFMove(*transform),
            WTFMove(*translate),
            WTFMove(*scale),
            WTFMove(*rotate),
            WTFMove(*offsetPath),
            WTFMove(*offsetDistance),
            WTFMove(*offsetPosition),
            WTFMove(*offsetAnchor),
            WTFMove(*offsetRotate),
            WTFMove(*filter),
            WTFMove(*backdropFilter)
        }
    };
}

#endif

#if ENABLE(THREADED_ANIMATION_RESOLUTION)
void ArgumentCoder<WebCore::WebAnimationTime>::encode(Encoder& encoder, const WebCore::WebAnimationTime& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.time())>, std::optional<Seconds>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.percentage())>, std::optional<double>>);

    encoder << instance.time();
    encoder << instance.percentage();
}

std::optional<WebCore::WebAnimationTime> ArgumentCoder<WebCore::WebAnimationTime>::decode(Decoder& decoder)
{
    auto time = decoder.decode<std::optional<Seconds>>();
    auto percentage = decoder.decode<std::optional<double>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::WebAnimationTime {
            WTFMove(*time),
            WTFMove(*percentage)
        }
    };
}

#endif

#if ENABLE(THREADED_ANIMATION_RESOLUTION)
void ArgumentCoder<WebCore::AnimationEffectTiming>::encode(Encoder& encoder, const WebCore::AnimationEffectTiming& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timingFunction)>, RefPtr<WebCore::TimingFunction>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fill)>, WebCore::FillMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.direction)>, WebCore::PlaybackDirection>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.iterationStart)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.iterations)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.specifiedStartDelay)>, Seconds>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.specifiedEndDelay)>, Seconds>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.specifiedIterationDuration)>, std::optional<Seconds>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.startDelay)>, WebCore::WebAnimationTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.endDelay)>, WebCore::WebAnimationTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.iterationDuration)>, WebCore::WebAnimationTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.intrinsicIterationDuration)>, WebCore::WebAnimationTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.activeDuration)>, WebCore::WebAnimationTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.endTime)>, WebCore::WebAnimationTime>);
    struct ShouldBeSameSizeAsAnimationEffectTiming : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::AnimationEffectTiming>, false> {
        RefPtr<WebCore::TimingFunction> timingFunction;
        WebCore::FillMode fill;
        WebCore::PlaybackDirection direction;
        double iterationStart;
        double iterations;
        Seconds specifiedStartDelay;
        Seconds specifiedEndDelay;
        std::optional<Seconds> specifiedIterationDuration;
        WebCore::WebAnimationTime startDelay;
        WebCore::WebAnimationTime endDelay;
        WebCore::WebAnimationTime iterationDuration;
        WebCore::WebAnimationTime intrinsicIterationDuration;
        WebCore::WebAnimationTime activeDuration;
        WebCore::WebAnimationTime endTime;
    };
    static_assert(sizeof(ShouldBeSameSizeAsAnimationEffectTiming) == sizeof(WebCore::AnimationEffectTiming));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::AnimationEffectTiming, timingFunction)
        , offsetof(WebCore::AnimationEffectTiming, fill)
        , offsetof(WebCore::AnimationEffectTiming, direction)
        , offsetof(WebCore::AnimationEffectTiming, iterationStart)
        , offsetof(WebCore::AnimationEffectTiming, iterations)
        , offsetof(WebCore::AnimationEffectTiming, specifiedStartDelay)
        , offsetof(WebCore::AnimationEffectTiming, specifiedEndDelay)
        , offsetof(WebCore::AnimationEffectTiming, specifiedIterationDuration)
        , offsetof(WebCore::AnimationEffectTiming, startDelay)
        , offsetof(WebCore::AnimationEffectTiming, endDelay)
        , offsetof(WebCore::AnimationEffectTiming, iterationDuration)
        , offsetof(WebCore::AnimationEffectTiming, intrinsicIterationDuration)
        , offsetof(WebCore::AnimationEffectTiming, activeDuration)
        , offsetof(WebCore::AnimationEffectTiming, endTime)
    >::value);

    encoder << instance.timingFunction;
    encoder << instance.fill;
    encoder << instance.direction;
    encoder << instance.iterationStart;
    encoder << instance.iterations;
    encoder << instance.startDelay;
    encoder << instance.endDelay;
    encoder << instance.iterationDuration;
    encoder << instance.intrinsicIterationDuration;
    encoder << instance.activeDuration;
    encoder << instance.endTime;
}

std::optional<WebCore::AnimationEffectTiming> ArgumentCoder<WebCore::AnimationEffectTiming>::decode(Decoder& decoder)
{
    auto timingFunction = decoder.decode<RefPtr<WebCore::TimingFunction>>();
    auto fill = decoder.decode<WebCore::FillMode>();
    auto direction = decoder.decode<WebCore::PlaybackDirection>();
    auto iterationStart = decoder.decode<double>();
    auto iterations = decoder.decode<double>();
    auto startDelay = decoder.decode<WebCore::WebAnimationTime>();
    auto endDelay = decoder.decode<WebCore::WebAnimationTime>();
    auto iterationDuration = decoder.decode<WebCore::WebAnimationTime>();
    auto intrinsicIterationDuration = decoder.decode<WebCore::WebAnimationTime>();
    auto activeDuration = decoder.decode<WebCore::WebAnimationTime>();
    auto endTime = decoder.decode<WebCore::WebAnimationTime>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::AnimationEffectTiming {
            WTFMove(*timingFunction),
            WTFMove(*fill),
            WTFMove(*direction),
            WTFMove(*iterationStart),
            WTFMove(*iterations),
            WTFMove(*startDelay),
            WTFMove(*endDelay),
            WTFMove(*iterationDuration),
            WTFMove(*intrinsicIterationDuration),
            WTFMove(*activeDuration),
            WTFMove(*endTime)
        }
    };
}

#endif

#if ENABLE(THREADED_ANIMATION_RESOLUTION)
void ArgumentCoder<WebCore::AcceleratedEffect::Keyframe>::encode(Encoder& encoder, const WebCore::AcceleratedEffect::Keyframe& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.values())>, WebCore::AcceleratedEffectValues>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timingFunction())>, RefPtr<WebCore::TimingFunction>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.compositeOperation())>, std::optional<WebCore::CompositeOperation>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.animatedProperties())>, OptionSet<WebCore::AcceleratedEffectProperty>>);

    encoder << instance.offset();
    encoder << instance.values();
    encoder << instance.timingFunction();
    encoder << instance.compositeOperation();
    encoder << instance.animatedProperties();
}

std::optional<WebCore::AcceleratedEffect::Keyframe> ArgumentCoder<WebCore::AcceleratedEffect::Keyframe>::decode(Decoder& decoder)
{
    auto offset = decoder.decode<double>();
    auto values = decoder.decode<WebCore::AcceleratedEffectValues>();
    auto timingFunction = decoder.decode<RefPtr<WebCore::TimingFunction>>();
    auto compositeOperation = decoder.decode<std::optional<WebCore::CompositeOperation>>();
    auto animatedProperties = decoder.decode<OptionSet<WebCore::AcceleratedEffectProperty>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::AcceleratedEffect::Keyframe {
            WTFMove(*offset),
            WTFMove(*values),
            WTFMove(*timingFunction),
            WTFMove(*compositeOperation),
            WTFMove(*animatedProperties)
        }
    };
}

#endif

#if ENABLE(THREADED_ANIMATION_RESOLUTION)
void ArgumentCoder<WebCore::AcceleratedEffect>::encode(Encoder& encoder, const WebCore::AcceleratedEffect& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timing())>, WebCore::AnimationEffectTiming>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.keyframes())>, Vector<WebCore::AcceleratedEffect::Keyframe>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.animationType())>, WebCore::WebAnimationType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.compositeOperation())>, WebCore::CompositeOperation>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.defaultKeyframeTimingFunction())>, RefPtr<WebCore::TimingFunction>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.animatedProperties())>, OptionSet<WebCore::AcceleratedEffectProperty>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.paused())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.playbackRate())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.startTime())>, std::optional<WebCore::WebAnimationTime>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.holdTime())>, std::optional<WebCore::WebAnimationTime>>);

    encoder << instance.timing();
    encoder << instance.keyframes();
    encoder << instance.animationType();
    encoder << instance.compositeOperation();
    encoder << instance.defaultKeyframeTimingFunction();
    encoder << instance.animatedProperties();
    encoder << instance.paused();
    encoder << instance.playbackRate();
    encoder << instance.startTime();
    encoder << instance.holdTime();
}

std::optional<Ref<WebCore::AcceleratedEffect>> ArgumentCoder<WebCore::AcceleratedEffect>::decode(Decoder& decoder)
{
    auto timing = decoder.decode<WebCore::AnimationEffectTiming>();
    auto keyframes = decoder.decode<Vector<WebCore::AcceleratedEffect::Keyframe>>();
    auto animationType = decoder.decode<WebCore::WebAnimationType>();
    auto compositeOperation = decoder.decode<WebCore::CompositeOperation>();
    auto defaultKeyframeTimingFunction = decoder.decode<RefPtr<WebCore::TimingFunction>>();
    auto animatedProperties = decoder.decode<OptionSet<WebCore::AcceleratedEffectProperty>>();
    auto paused = decoder.decode<bool>();
    auto playbackRate = decoder.decode<double>();
    auto startTime = decoder.decode<std::optional<WebCore::WebAnimationTime>>();
    auto holdTime = decoder.decode<std::optional<WebCore::WebAnimationTime>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::AcceleratedEffect::create(
            WTFMove(*timing),
            WTFMove(*keyframes),
            WTFMove(*animationType),
            WTFMove(*compositeOperation),
            WTFMove(*defaultKeyframeTimingFunction),
            WTFMove(*animatedProperties),
            WTFMove(*paused),
            WTFMove(*playbackRate),
            WTFMove(*startTime),
            WTFMove(*holdTime)
        )
    };
}

#endif

void ArgumentCoder<WebCore::ProtectionSpace>::encode(Encoder& encoder, const WebCore::ProtectionSpace& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.host())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.port())>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.serverType())>, WebCore::ProtectionSpace::ServerType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.realm())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.authenticationScheme())>, WebCore::ProtectionSpace::AuthenticationScheme>);
#if USE(CURL)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.certificateInfo())>, WebCore::CertificateInfo>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.getPlatformDataToSerialize())>, std::optional<WebCore::ProtectionSpace::PlatformData>>);
#endif

    encoder << instance.host();
    encoder << instance.port();
    encoder << instance.serverType();
    encoder << instance.realm();
    encoder << instance.authenticationScheme();
#if USE(CURL)
    encoder << instance.certificateInfo();
#endif
#if PLATFORM(COCOA)
    encoder << instance.getPlatformDataToSerialize();
#endif
}

std::optional<WebCore::ProtectionSpace> ArgumentCoder<WebCore::ProtectionSpace>::decode(Decoder& decoder)
{
    auto host = decoder.decode<String>();
    auto port = decoder.decode<int>();
    auto serverType = decoder.decode<WebCore::ProtectionSpace::ServerType>();
    auto realm = decoder.decode<String>();
    auto authenticationScheme = decoder.decode<WebCore::ProtectionSpace::AuthenticationScheme>();
#if USE(CURL)
    auto certificateInfo = decoder.decode<WebCore::CertificateInfo>();
#endif
#if PLATFORM(COCOA)
    auto getPlatformDataToSerialize = decoder.decode<std::optional<WebCore::ProtectionSpace::PlatformData>>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ProtectionSpace {
            WTFMove(*host),
            WTFMove(*port),
            WTFMove(*serverType),
            WTFMove(*realm),
            WTFMove(*authenticationScheme),
#if USE(CURL)
            WTFMove(*certificateInfo),
#endif
#if PLATFORM(COCOA)
            WTFMove(*getPlatformDataToSerialize)
#endif
        }
    };
}

void ArgumentCoder<WebCore::Credential::NonPlatformData>::encode(Encoder& encoder, const WebCore::Credential::NonPlatformData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.user)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.password)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.persistence)>, WebCore::CredentialPersistence>);
    struct ShouldBeSameSizeAsNonPlatformData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Credential::NonPlatformData>, false> {
        String user;
        String password;
        WebCore::CredentialPersistence persistence;
    };
    static_assert(sizeof(ShouldBeSameSizeAsNonPlatformData) == sizeof(WebCore::Credential::NonPlatformData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Credential::NonPlatformData, user)
        , offsetof(WebCore::Credential::NonPlatformData, password)
        , offsetof(WebCore::Credential::NonPlatformData, persistence)
    >::value);

    encoder << instance.user;
    encoder << instance.password;
    encoder << instance.persistence;
}

std::optional<WebCore::Credential::NonPlatformData> ArgumentCoder<WebCore::Credential::NonPlatformData>::decode(Decoder& decoder)
{
    auto user = decoder.decode<String>();
    auto password = decoder.decode<String>();
    auto persistence = decoder.decode<WebCore::CredentialPersistence>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Credential::NonPlatformData {
            WTFMove(*user),
            WTFMove(*password),
            WTFMove(*persistence)
        }
    };
}

#if PLATFORM(COCOA)
void ArgumentCoder<WebCore::Credential>::encode(Encoder& encoder, const WebCore::Credential& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ipcData())>, Variant<WebCore::Credential::NonPlatformData, RetainPtr<NSURLCredential>>>);

    encoder << instance.ipcData();
}

std::optional<WebCore::Credential> ArgumentCoder<WebCore::Credential>::decode(Decoder& decoder)
{
    auto ipcData = decoder.decode<Variant<WebCore::Credential::NonPlatformData, RetainPtr<NSURLCredential>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Credential::fromIPCData(
            WTFMove(*ipcData)
        )
    };
}

#endif

#if USE(SOUP)
void ArgumentCoder<WebCore::Credential::PlatformData>::encode(Encoder& encoder, const WebCore::Credential::PlatformData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.certificate)>, GRefPtr<GTlsCertificate>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.persistence)>, WebCore::CredentialPersistence>);
    struct ShouldBeSameSizeAsPlatformData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Credential::PlatformData>, false> {
        GRefPtr<GTlsCertificate> certificate;
        WebCore::CredentialPersistence persistence;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPlatformData) == sizeof(WebCore::Credential::PlatformData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Credential::PlatformData, certificate)
        , offsetof(WebCore::Credential::PlatformData, persistence)
    >::value);

    encoder << instance.certificate;
    encoder << instance.persistence;
}

std::optional<WebCore::Credential::PlatformData> ArgumentCoder<WebCore::Credential::PlatformData>::decode(Decoder& decoder)
{
    auto certificate = decoder.decode<GRefPtr<GTlsCertificate>>();
    auto persistence = decoder.decode<WebCore::CredentialPersistence>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Credential::PlatformData {
            WTFMove(*certificate),
            WTFMove(*persistence)
        }
    };
}

#endif

#if USE(SOUP)
void ArgumentCoder<WebCore::Credential>::encode(Encoder& encoder, const WebCore::Credential& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ipcData())>, Variant<WebCore::Credential::NonPlatformData, WebCore::Credential::PlatformData>>);

    encoder << instance.ipcData();
}

std::optional<WebCore::Credential> ArgumentCoder<WebCore::Credential>::decode(Decoder& decoder)
{
    auto ipcData = decoder.decode<Variant<WebCore::Credential::NonPlatformData, WebCore::Credential::PlatformData>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Credential::fromIPCData(
            WTFMove(*ipcData)
        )
    };
}

#endif

#if USE(CURL)
void ArgumentCoder<WebCore::Credential>::encode(Encoder& encoder, const WebCore::Credential& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.nonPlatformData())>, WebCore::Credential::NonPlatformData>);

    encoder << instance.nonPlatformData();
}

std::optional<WebCore::Credential> ArgumentCoder<WebCore::Credential>::decode(Decoder& decoder)
{
    auto nonPlatformData = decoder.decode<WebCore::Credential::NonPlatformData>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Credential {
            WTFMove(*nonPlatformData)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebCore::ShapeDetection::BarcodeDetectorOptions>::encode(Encoder& encoder, const WebCore::ShapeDetection::BarcodeDetectorOptions& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.formats)>, Vector<WebCore::ShapeDetection::BarcodeFormat>>);
    struct ShouldBeSameSizeAsBarcodeDetectorOptions : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ShapeDetection::BarcodeDetectorOptions>, false> {
        Vector<WebCore::ShapeDetection::BarcodeFormat> formats;
    };
    static_assert(sizeof(ShouldBeSameSizeAsBarcodeDetectorOptions) == sizeof(WebCore::ShapeDetection::BarcodeDetectorOptions));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ShapeDetection::BarcodeDetectorOptions, formats)
    >::value);

    encoder << instance.formats;
}

void ArgumentCoder<WebCore::ShapeDetection::BarcodeDetectorOptions>::encode(StreamConnectionEncoder& encoder, const WebCore::ShapeDetection::BarcodeDetectorOptions& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.formats)>, Vector<WebCore::ShapeDetection::BarcodeFormat>>);
    struct ShouldBeSameSizeAsBarcodeDetectorOptions : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ShapeDetection::BarcodeDetectorOptions>, false> {
        Vector<WebCore::ShapeDetection::BarcodeFormat> formats;
    };
    static_assert(sizeof(ShouldBeSameSizeAsBarcodeDetectorOptions) == sizeof(WebCore::ShapeDetection::BarcodeDetectorOptions));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ShapeDetection::BarcodeDetectorOptions, formats)
    >::value);

    encoder << instance.formats;
}

std::optional<WebCore::ShapeDetection::BarcodeDetectorOptions> ArgumentCoder<WebCore::ShapeDetection::BarcodeDetectorOptions>::decode(Decoder& decoder)
{
    auto formats = decoder.decode<Vector<WebCore::ShapeDetection::BarcodeFormat>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ShapeDetection::BarcodeDetectorOptions {
            WTFMove(*formats)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebCore::ShapeDetection::DetectedBarcode>::encode(Encoder& encoder, const WebCore::ShapeDetection::DetectedBarcode& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.boundingBox)>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rawValue)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.format)>, WebCore::ShapeDetection::BarcodeFormat>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cornerPoints)>, Vector<WebCore::FloatPoint>>);
    struct ShouldBeSameSizeAsDetectedBarcode : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ShapeDetection::DetectedBarcode>, false> {
        WebCore::FloatRect boundingBox;
        String rawValue;
        WebCore::ShapeDetection::BarcodeFormat format;
        Vector<WebCore::FloatPoint> cornerPoints;
    };
    static_assert(sizeof(ShouldBeSameSizeAsDetectedBarcode) == sizeof(WebCore::ShapeDetection::DetectedBarcode));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ShapeDetection::DetectedBarcode, boundingBox)
        , offsetof(WebCore::ShapeDetection::DetectedBarcode, rawValue)
        , offsetof(WebCore::ShapeDetection::DetectedBarcode, format)
        , offsetof(WebCore::ShapeDetection::DetectedBarcode, cornerPoints)
    >::value);

    encoder << instance.boundingBox;
    encoder << instance.rawValue;
    encoder << instance.format;
    encoder << instance.cornerPoints;
}

void ArgumentCoder<WebCore::ShapeDetection::DetectedBarcode>::encode(StreamConnectionEncoder& encoder, const WebCore::ShapeDetection::DetectedBarcode& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.boundingBox)>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rawValue)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.format)>, WebCore::ShapeDetection::BarcodeFormat>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cornerPoints)>, Vector<WebCore::FloatPoint>>);
    struct ShouldBeSameSizeAsDetectedBarcode : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ShapeDetection::DetectedBarcode>, false> {
        WebCore::FloatRect boundingBox;
        String rawValue;
        WebCore::ShapeDetection::BarcodeFormat format;
        Vector<WebCore::FloatPoint> cornerPoints;
    };
    static_assert(sizeof(ShouldBeSameSizeAsDetectedBarcode) == sizeof(WebCore::ShapeDetection::DetectedBarcode));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ShapeDetection::DetectedBarcode, boundingBox)
        , offsetof(WebCore::ShapeDetection::DetectedBarcode, rawValue)
        , offsetof(WebCore::ShapeDetection::DetectedBarcode, format)
        , offsetof(WebCore::ShapeDetection::DetectedBarcode, cornerPoints)
    >::value);

    encoder << instance.boundingBox;
    encoder << instance.rawValue;
    encoder << instance.format;
    encoder << instance.cornerPoints;
}

std::optional<WebCore::ShapeDetection::DetectedBarcode> ArgumentCoder<WebCore::ShapeDetection::DetectedBarcode>::decode(Decoder& decoder)
{
    auto boundingBox = decoder.decode<WebCore::FloatRect>();
    auto rawValue = decoder.decode<String>();
    auto format = decoder.decode<WebCore::ShapeDetection::BarcodeFormat>();
    auto cornerPoints = decoder.decode<Vector<WebCore::FloatPoint>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ShapeDetection::DetectedBarcode {
            WTFMove(*boundingBox),
            WTFMove(*rawValue),
            WTFMove(*format),
            WTFMove(*cornerPoints)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebCore::ShapeDetection::DetectedFace>::encode(Encoder& encoder, const WebCore::ShapeDetection::DetectedFace& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.boundingBox)>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.landmarks)>, std::optional<Vector<WebCore::ShapeDetection::Landmark>>>);
    struct ShouldBeSameSizeAsDetectedFace : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ShapeDetection::DetectedFace>, false> {
        WebCore::FloatRect boundingBox;
        std::optional<Vector<WebCore::ShapeDetection::Landmark>> landmarks;
    };
    static_assert(sizeof(ShouldBeSameSizeAsDetectedFace) == sizeof(WebCore::ShapeDetection::DetectedFace));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ShapeDetection::DetectedFace, boundingBox)
        , offsetof(WebCore::ShapeDetection::DetectedFace, landmarks)
    >::value);

    encoder << instance.boundingBox;
    encoder << instance.landmarks;
}

void ArgumentCoder<WebCore::ShapeDetection::DetectedFace>::encode(StreamConnectionEncoder& encoder, const WebCore::ShapeDetection::DetectedFace& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.boundingBox)>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.landmarks)>, std::optional<Vector<WebCore::ShapeDetection::Landmark>>>);
    struct ShouldBeSameSizeAsDetectedFace : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ShapeDetection::DetectedFace>, false> {
        WebCore::FloatRect boundingBox;
        std::optional<Vector<WebCore::ShapeDetection::Landmark>> landmarks;
    };
    static_assert(sizeof(ShouldBeSameSizeAsDetectedFace) == sizeof(WebCore::ShapeDetection::DetectedFace));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ShapeDetection::DetectedFace, boundingBox)
        , offsetof(WebCore::ShapeDetection::DetectedFace, landmarks)
    >::value);

    encoder << instance.boundingBox;
    encoder << instance.landmarks;
}

std::optional<WebCore::ShapeDetection::DetectedFace> ArgumentCoder<WebCore::ShapeDetection::DetectedFace>::decode(Decoder& decoder)
{
    auto boundingBox = decoder.decode<WebCore::FloatRect>();
    auto landmarks = decoder.decode<std::optional<Vector<WebCore::ShapeDetection::Landmark>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ShapeDetection::DetectedFace {
            WTFMove(*boundingBox),
            WTFMove(*landmarks)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebCore::ShapeDetection::DetectedText>::encode(Encoder& encoder, const WebCore::ShapeDetection::DetectedText& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.boundingBox)>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rawValue)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cornerPoints)>, Vector<WebCore::FloatPoint>>);
    struct ShouldBeSameSizeAsDetectedText : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ShapeDetection::DetectedText>, false> {
        WebCore::FloatRect boundingBox;
        String rawValue;
        Vector<WebCore::FloatPoint> cornerPoints;
    };
    static_assert(sizeof(ShouldBeSameSizeAsDetectedText) == sizeof(WebCore::ShapeDetection::DetectedText));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ShapeDetection::DetectedText, boundingBox)
        , offsetof(WebCore::ShapeDetection::DetectedText, rawValue)
        , offsetof(WebCore::ShapeDetection::DetectedText, cornerPoints)
    >::value);

    encoder << instance.boundingBox;
    encoder << instance.rawValue;
    encoder << instance.cornerPoints;
}

void ArgumentCoder<WebCore::ShapeDetection::DetectedText>::encode(StreamConnectionEncoder& encoder, const WebCore::ShapeDetection::DetectedText& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.boundingBox)>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rawValue)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cornerPoints)>, Vector<WebCore::FloatPoint>>);
    struct ShouldBeSameSizeAsDetectedText : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ShapeDetection::DetectedText>, false> {
        WebCore::FloatRect boundingBox;
        String rawValue;
        Vector<WebCore::FloatPoint> cornerPoints;
    };
    static_assert(sizeof(ShouldBeSameSizeAsDetectedText) == sizeof(WebCore::ShapeDetection::DetectedText));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ShapeDetection::DetectedText, boundingBox)
        , offsetof(WebCore::ShapeDetection::DetectedText, rawValue)
        , offsetof(WebCore::ShapeDetection::DetectedText, cornerPoints)
    >::value);

    encoder << instance.boundingBox;
    encoder << instance.rawValue;
    encoder << instance.cornerPoints;
}

std::optional<WebCore::ShapeDetection::DetectedText> ArgumentCoder<WebCore::ShapeDetection::DetectedText>::decode(Decoder& decoder)
{
    auto boundingBox = decoder.decode<WebCore::FloatRect>();
    auto rawValue = decoder.decode<String>();
    auto cornerPoints = decoder.decode<Vector<WebCore::FloatPoint>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ShapeDetection::DetectedText {
            WTFMove(*boundingBox),
            WTFMove(*rawValue),
            WTFMove(*cornerPoints)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebCore::ShapeDetection::FaceDetectorOptions>::encode(Encoder& encoder, const WebCore::ShapeDetection::FaceDetectorOptions& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxDetectedFaces)>, uint16_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fastMode)>, bool>);
    struct ShouldBeSameSizeAsFaceDetectorOptions : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ShapeDetection::FaceDetectorOptions>, false> {
        uint16_t maxDetectedFaces;
        bool fastMode;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFaceDetectorOptions) == sizeof(WebCore::ShapeDetection::FaceDetectorOptions));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ShapeDetection::FaceDetectorOptions, maxDetectedFaces)
        , offsetof(WebCore::ShapeDetection::FaceDetectorOptions, fastMode)
    >::value);

    encoder << instance.maxDetectedFaces;
    encoder << instance.fastMode;
}

void ArgumentCoder<WebCore::ShapeDetection::FaceDetectorOptions>::encode(StreamConnectionEncoder& encoder, const WebCore::ShapeDetection::FaceDetectorOptions& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxDetectedFaces)>, uint16_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fastMode)>, bool>);
    struct ShouldBeSameSizeAsFaceDetectorOptions : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ShapeDetection::FaceDetectorOptions>, false> {
        uint16_t maxDetectedFaces;
        bool fastMode;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFaceDetectorOptions) == sizeof(WebCore::ShapeDetection::FaceDetectorOptions));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ShapeDetection::FaceDetectorOptions, maxDetectedFaces)
        , offsetof(WebCore::ShapeDetection::FaceDetectorOptions, fastMode)
    >::value);

    encoder << instance.maxDetectedFaces;
    encoder << instance.fastMode;
}

std::optional<WebCore::ShapeDetection::FaceDetectorOptions> ArgumentCoder<WebCore::ShapeDetection::FaceDetectorOptions>::decode(Decoder& decoder)
{
    auto maxDetectedFaces = decoder.decode<uint16_t>();
    auto fastMode = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ShapeDetection::FaceDetectorOptions {
            WTFMove(*maxDetectedFaces),
            WTFMove(*fastMode)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebCore::ShapeDetection::Landmark>::encode(Encoder& encoder, const WebCore::ShapeDetection::Landmark& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.locations)>, Vector<WebCore::FloatPoint>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::ShapeDetection::LandmarkType>);
    struct ShouldBeSameSizeAsLandmark : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ShapeDetection::Landmark>, false> {
        Vector<WebCore::FloatPoint> locations;
        WebCore::ShapeDetection::LandmarkType type;
    };
    static_assert(sizeof(ShouldBeSameSizeAsLandmark) == sizeof(WebCore::ShapeDetection::Landmark));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ShapeDetection::Landmark, locations)
        , offsetof(WebCore::ShapeDetection::Landmark, type)
    >::value);

    encoder << instance.locations;
    encoder << instance.type;
}

void ArgumentCoder<WebCore::ShapeDetection::Landmark>::encode(StreamConnectionEncoder& encoder, const WebCore::ShapeDetection::Landmark& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.locations)>, Vector<WebCore::FloatPoint>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::ShapeDetection::LandmarkType>);
    struct ShouldBeSameSizeAsLandmark : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ShapeDetection::Landmark>, false> {
        Vector<WebCore::FloatPoint> locations;
        WebCore::ShapeDetection::LandmarkType type;
    };
    static_assert(sizeof(ShouldBeSameSizeAsLandmark) == sizeof(WebCore::ShapeDetection::Landmark));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ShapeDetection::Landmark, locations)
        , offsetof(WebCore::ShapeDetection::Landmark, type)
    >::value);

    encoder << instance.locations;
    encoder << instance.type;
}

std::optional<WebCore::ShapeDetection::Landmark> ArgumentCoder<WebCore::ShapeDetection::Landmark>::decode(Decoder& decoder)
{
    auto locations = decoder.decode<Vector<WebCore::FloatPoint>>();
    auto type = decoder.decode<WebCore::ShapeDetection::LandmarkType>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ShapeDetection::Landmark {
            WTFMove(*locations),
            WTFMove(*type)
        }
    };
}

#endif

void ArgumentCoder<WebCore::TextExtraction::Editable>::encode(Encoder& encoder, const WebCore::TextExtraction::Editable& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.placeholder)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isSecure)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isFocused)>, bool>);
    struct ShouldBeSameSizeAsEditable : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::TextExtraction::Editable>, false> {
        String label;
        String placeholder;
        bool isSecure;
        bool isFocused;
    };
    static_assert(sizeof(ShouldBeSameSizeAsEditable) == sizeof(WebCore::TextExtraction::Editable));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::TextExtraction::Editable, label)
        , offsetof(WebCore::TextExtraction::Editable, placeholder)
        , offsetof(WebCore::TextExtraction::Editable, isSecure)
        , offsetof(WebCore::TextExtraction::Editable, isFocused)
    >::value);

    encoder << instance.label;
    encoder << instance.placeholder;
    encoder << instance.isSecure;
    encoder << instance.isFocused;
}

std::optional<WebCore::TextExtraction::Editable> ArgumentCoder<WebCore::TextExtraction::Editable>::decode(Decoder& decoder)
{
    auto label = decoder.decode<String>();
    auto placeholder = decoder.decode<String>();
    auto isSecure = decoder.decode<bool>();
    auto isFocused = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TextExtraction::Editable {
            WTFMove(*label),
            WTFMove(*placeholder),
            WTFMove(*isSecure),
            WTFMove(*isFocused)
        }
    };
}

void ArgumentCoder<WebCore::TextExtraction::TextItemData>::encode(Encoder& encoder, const WebCore::TextExtraction::TextItemData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.links)>, Vector<std::pair<URL, WebCore::CharacterRange>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selectedRange)>, std::optional<WebCore::CharacterRange>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.content)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.editable)>, std::optional<WebCore::TextExtraction::Editable>>);
    struct ShouldBeSameSizeAsTextItemData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::TextExtraction::TextItemData>, false> {
        Vector<std::pair<URL, WebCore::CharacterRange>> links;
        std::optional<WebCore::CharacterRange> selectedRange;
        String content;
        std::optional<WebCore::TextExtraction::Editable> editable;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTextItemData) == sizeof(WebCore::TextExtraction::TextItemData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::TextExtraction::TextItemData, links)
        , offsetof(WebCore::TextExtraction::TextItemData, selectedRange)
        , offsetof(WebCore::TextExtraction::TextItemData, content)
        , offsetof(WebCore::TextExtraction::TextItemData, editable)
    >::value);

    encoder << instance.links;
    encoder << instance.selectedRange;
    encoder << instance.content;
    encoder << instance.editable;
}

std::optional<WebCore::TextExtraction::TextItemData> ArgumentCoder<WebCore::TextExtraction::TextItemData>::decode(Decoder& decoder)
{
    auto links = decoder.decode<Vector<std::pair<URL, WebCore::CharacterRange>>>();
    auto selectedRange = decoder.decode<std::optional<WebCore::CharacterRange>>();
    auto content = decoder.decode<String>();
    auto editable = decoder.decode<std::optional<WebCore::TextExtraction::Editable>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TextExtraction::TextItemData {
            WTFMove(*links),
            WTFMove(*selectedRange),
            WTFMove(*content),
            WTFMove(*editable)
        }
    };
}

void ArgumentCoder<WebCore::TextExtraction::ScrollableItemData>::encode(Encoder& encoder, const WebCore::TextExtraction::ScrollableItemData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentSize)>, WebCore::FloatSize>);
    struct ShouldBeSameSizeAsScrollableItemData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::TextExtraction::ScrollableItemData>, false> {
        WebCore::FloatSize contentSize;
    };
    static_assert(sizeof(ShouldBeSameSizeAsScrollableItemData) == sizeof(WebCore::TextExtraction::ScrollableItemData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::TextExtraction::ScrollableItemData, contentSize)
    >::value);

    encoder << instance.contentSize;
}

std::optional<WebCore::TextExtraction::ScrollableItemData> ArgumentCoder<WebCore::TextExtraction::ScrollableItemData>::decode(Decoder& decoder)
{
    auto contentSize = decoder.decode<WebCore::FloatSize>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TextExtraction::ScrollableItemData {
            WTFMove(*contentSize)
        }
    };
}

void ArgumentCoder<WebCore::TextExtraction::ImageItemData>::encode(Encoder& encoder, const WebCore::TextExtraction::ImageItemData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.altText)>, String>);
    struct ShouldBeSameSizeAsImageItemData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::TextExtraction::ImageItemData>, false> {
        String name;
        String altText;
    };
    static_assert(sizeof(ShouldBeSameSizeAsImageItemData) == sizeof(WebCore::TextExtraction::ImageItemData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::TextExtraction::ImageItemData, name)
        , offsetof(WebCore::TextExtraction::ImageItemData, altText)
    >::value);

    encoder << instance.name;
    encoder << instance.altText;
}

std::optional<WebCore::TextExtraction::ImageItemData> ArgumentCoder<WebCore::TextExtraction::ImageItemData>::decode(Decoder& decoder)
{
    auto name = decoder.decode<String>();
    auto altText = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TextExtraction::ImageItemData {
            WTFMove(*name),
            WTFMove(*altText)
        }
    };
}

void ArgumentCoder<WebCore::TextExtraction::Item>::encode(Encoder& encoder, const WebCore::TextExtraction::Item& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data)>, Variant<WebCore::TextExtraction::ContainerType, WebCore::TextExtraction::TextItemData, WebCore::TextExtraction::ScrollableItemData, WebCore::TextExtraction::ImageItemData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rectInRootView)>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.children)>, Vector<WebCore::TextExtraction::Item>>);
    struct ShouldBeSameSizeAsItem : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::TextExtraction::Item>, false> {
        Variant<WebCore::TextExtraction::ContainerType, WebCore::TextExtraction::TextItemData, WebCore::TextExtraction::ScrollableItemData, WebCore::TextExtraction::ImageItemData> data;
        WebCore::FloatRect rectInRootView;
        Vector<WebCore::TextExtraction::Item> children;
    };
    static_assert(sizeof(ShouldBeSameSizeAsItem) == sizeof(WebCore::TextExtraction::Item));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::TextExtraction::Item, data)
        , offsetof(WebCore::TextExtraction::Item, rectInRootView)
        , offsetof(WebCore::TextExtraction::Item, children)
    >::value);

    encoder << instance.data;
    encoder << instance.rectInRootView;
    encoder << instance.children;
}

std::optional<WebCore::TextExtraction::Item> ArgumentCoder<WebCore::TextExtraction::Item>::decode(Decoder& decoder)
{
    auto data = decoder.decode<Variant<WebCore::TextExtraction::ContainerType, WebCore::TextExtraction::TextItemData, WebCore::TextExtraction::ScrollableItemData, WebCore::TextExtraction::ImageItemData>>();
    auto rectInRootView = decoder.decode<WebCore::FloatRect>();
    auto children = decoder.decode<Vector<WebCore::TextExtraction::Item>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TextExtraction::Item {
            WTFMove(*data),
            WTFMove(*rectInRootView),
            WTFMove(*children)
        }
    };
}

#if ENABLE(WRITING_TOOLS)
void ArgumentCoder<WebCore::WritingTools::Session>::encode(Encoder& encoder, const WebCore::WritingTools::Session& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, WebCore::WritingTools::SessionID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::WritingTools::SessionType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.compositionType)>, WebCore::WritingTools::SessionCompositionType>);
    struct ShouldBeSameSizeAsSession : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::WritingTools::Session>, false> {
        WebCore::WritingTools::SessionID identifier;
        WebCore::WritingTools::SessionType type;
        WebCore::WritingTools::SessionCompositionType compositionType;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSession) == sizeof(WebCore::WritingTools::Session));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::WritingTools::Session, identifier)
        , offsetof(WebCore::WritingTools::Session, type)
        , offsetof(WebCore::WritingTools::Session, compositionType)
    >::value);

    encoder << instance.identifier;
    encoder << instance.type;
    encoder << instance.compositionType;
}

std::optional<WebCore::WritingTools::Session> ArgumentCoder<WebCore::WritingTools::Session>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<WebCore::WritingTools::SessionID>();
    auto type = decoder.decode<WebCore::WritingTools::SessionType>();
    auto compositionType = decoder.decode<WebCore::WritingTools::SessionCompositionType>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::WritingTools::Session {
            WTFMove(*identifier),
            WTFMove(*type),
            WTFMove(*compositionType)
        }
    };
}

#endif

#if ENABLE(WRITING_TOOLS)
void ArgumentCoder<WebCore::WritingTools::Context>::encode(Encoder& encoder, const WebCore::WritingTools::Context& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, Markable<WebCore::WritingTools::ContextID>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.attributedText)>, WebCore::AttributedString>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.range)>, WebCore::CharacterRange>);
    struct ShouldBeSameSizeAsContext : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::WritingTools::Context>, false> {
        Markable<WebCore::WritingTools::ContextID> identifier;
        WebCore::AttributedString attributedText;
        WebCore::CharacterRange range;
    };
    static_assert(sizeof(ShouldBeSameSizeAsContext) == sizeof(WebCore::WritingTools::Context));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::WritingTools::Context, identifier)
        , offsetof(WebCore::WritingTools::Context, attributedText)
        , offsetof(WebCore::WritingTools::Context, range)
    >::value);

    encoder << instance.identifier;
    encoder << instance.attributedText;
    encoder << instance.range;
}

std::optional<WebCore::WritingTools::Context> ArgumentCoder<WebCore::WritingTools::Context>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<Markable<WebCore::WritingTools::ContextID>>();
    auto attributedText = decoder.decode<WebCore::AttributedString>();
    auto range = decoder.decode<WebCore::CharacterRange>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::WritingTools::Context {
            WTFMove(*identifier),
            WTFMove(*attributedText),
            WTFMove(*range)
        }
    };
}

#endif

#if ENABLE(WRITING_TOOLS)
void ArgumentCoder<WebCore::WritingTools::TextSuggestion>::encode(Encoder& encoder, const WebCore::WritingTools::TextSuggestion& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, WebCore::WritingTools::TextSuggestionID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.originalRange)>, WebCore::CharacterRange>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.replacement)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.state)>, WebCore::WritingTools::TextSuggestionState>);
    struct ShouldBeSameSizeAsTextSuggestion : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::WritingTools::TextSuggestion>, false> {
        WebCore::WritingTools::TextSuggestionID identifier;
        WebCore::CharacterRange originalRange;
        String replacement;
        WebCore::WritingTools::TextSuggestionState state;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTextSuggestion) == sizeof(WebCore::WritingTools::TextSuggestion));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::WritingTools::TextSuggestion, identifier)
        , offsetof(WebCore::WritingTools::TextSuggestion, originalRange)
        , offsetof(WebCore::WritingTools::TextSuggestion, replacement)
        , offsetof(WebCore::WritingTools::TextSuggestion, state)
    >::value);

    encoder << instance.identifier;
    encoder << instance.originalRange;
    encoder << instance.replacement;
    encoder << instance.state;
}

std::optional<WebCore::WritingTools::TextSuggestion> ArgumentCoder<WebCore::WritingTools::TextSuggestion>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<WebCore::WritingTools::TextSuggestionID>();
    auto originalRange = decoder.decode<WebCore::CharacterRange>();
    auto replacement = decoder.decode<String>();
    auto state = decoder.decode<WebCore::WritingTools::TextSuggestionState>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::WritingTools::TextSuggestion {
            WTFMove(*identifier),
            WTFMove(*originalRange),
            WTFMove(*replacement),
            WTFMove(*state)
        }
    };
}

#endif

#if ENABLE(MEDIA_STREAM)
void ArgumentCoder<WebCore::CaptureSourceError>::encode(Encoder& encoder, const WebCore::CaptureSourceError& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.errorMessage)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.denialReason)>, WebCore::MediaAccessDenialReason>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.invalidConstraint)>, WebCore::MediaConstraintType>);
    struct ShouldBeSameSizeAsCaptureSourceError : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::CaptureSourceError>, false> {
        String errorMessage;
        WebCore::MediaAccessDenialReason denialReason;
        WebCore::MediaConstraintType invalidConstraint;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCaptureSourceError) == sizeof(WebCore::CaptureSourceError));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::CaptureSourceError, errorMessage)
        , offsetof(WebCore::CaptureSourceError, denialReason)
        , offsetof(WebCore::CaptureSourceError, invalidConstraint)
    >::value);

    encoder << instance.errorMessage;
    encoder << instance.denialReason;
    encoder << instance.invalidConstraint;
}

std::optional<WebCore::CaptureSourceError> ArgumentCoder<WebCore::CaptureSourceError>::decode(Decoder& decoder)
{
    auto errorMessage = decoder.decode<String>();
    auto denialReason = decoder.decode<WebCore::MediaAccessDenialReason>();
    auto invalidConstraint = decoder.decode<WebCore::MediaConstraintType>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CaptureSourceError {
            WTFMove(*errorMessage),
            WTFMove(*denialReason),
            WTFMove(*invalidConstraint)
        }
    };
}

#endif

#if ENABLE(MEDIA_STREAM)
void ArgumentCoder<WebCore::MediaSettingsRange>::encode(Encoder& encoder, const WebCore::MediaSettingsRange& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.max)>, std::optional<double>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.min)>, std::optional<double>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.step)>, std::optional<double>>);
    struct ShouldBeSameSizeAsMediaSettingsRange : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MediaSettingsRange>, false> {
        std::optional<double> max;
        std::optional<double> min;
        std::optional<double> step;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMediaSettingsRange) == sizeof(WebCore::MediaSettingsRange));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MediaSettingsRange, max)
        , offsetof(WebCore::MediaSettingsRange, min)
        , offsetof(WebCore::MediaSettingsRange, step)
    >::value);

    encoder << instance.max;
    encoder << instance.min;
    encoder << instance.step;
}

std::optional<WebCore::MediaSettingsRange> ArgumentCoder<WebCore::MediaSettingsRange>::decode(Decoder& decoder)
{
    auto max = decoder.decode<std::optional<double>>();
    auto min = decoder.decode<std::optional<double>>();
    auto step = decoder.decode<std::optional<double>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MediaSettingsRange {
            WTFMove(*max),
            WTFMove(*min),
            WTFMove(*step)
        }
    };
}

#endif

#if ENABLE(MEDIA_STREAM)
void ArgumentCoder<WebCore::PhotoCapabilities>::encode(Encoder& encoder, const WebCore::PhotoCapabilities& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.redEyeReduction)>, std::optional<WebCore::RedEyeReduction>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.imageHeight)>, std::optional<WebCore::MediaSettingsRange>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.imageWidth)>, std::optional<WebCore::MediaSettingsRange>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fillLightMode)>, std::optional<Vector<WebCore::FillLightMode>>>);
    struct ShouldBeSameSizeAsPhotoCapabilities : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PhotoCapabilities>, false> {
        std::optional<WebCore::RedEyeReduction> redEyeReduction;
        std::optional<WebCore::MediaSettingsRange> imageHeight;
        std::optional<WebCore::MediaSettingsRange> imageWidth;
        std::optional<Vector<WebCore::FillLightMode>> fillLightMode;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPhotoCapabilities) == sizeof(WebCore::PhotoCapabilities));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PhotoCapabilities, redEyeReduction)
        , offsetof(WebCore::PhotoCapabilities, imageHeight)
        , offsetof(WebCore::PhotoCapabilities, imageWidth)
        , offsetof(WebCore::PhotoCapabilities, fillLightMode)
    >::value);

    encoder << instance.redEyeReduction;
    encoder << instance.imageHeight;
    encoder << instance.imageWidth;
    encoder << instance.fillLightMode;
}

std::optional<WebCore::PhotoCapabilities> ArgumentCoder<WebCore::PhotoCapabilities>::decode(Decoder& decoder)
{
    auto redEyeReduction = decoder.decode<std::optional<WebCore::RedEyeReduction>>();
    auto imageHeight = decoder.decode<std::optional<WebCore::MediaSettingsRange>>();
    auto imageWidth = decoder.decode<std::optional<WebCore::MediaSettingsRange>>();
    auto fillLightMode = decoder.decode<std::optional<Vector<WebCore::FillLightMode>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PhotoCapabilities {
            WTFMove(*redEyeReduction),
            WTFMove(*imageHeight),
            WTFMove(*imageWidth),
            WTFMove(*fillLightMode)
        }
    };
}

#endif

#if ENABLE(MEDIA_STREAM)
void ArgumentCoder<WebCore::PhotoSettings>::encode(Encoder& encoder, const WebCore::PhotoSettings& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fillLightMode)>, std::optional<WebCore::FillLightMode>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.imageHeight)>, std::optional<double>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.imageWidth)>, std::optional<double>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.redEyeReduction)>, std::optional<bool>>);
    struct ShouldBeSameSizeAsPhotoSettings : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PhotoSettings>, false> {
        std::optional<WebCore::FillLightMode> fillLightMode;
        std::optional<double> imageHeight;
        std::optional<double> imageWidth;
        std::optional<bool> redEyeReduction;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPhotoSettings) == sizeof(WebCore::PhotoSettings));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PhotoSettings, fillLightMode)
        , offsetof(WebCore::PhotoSettings, imageHeight)
        , offsetof(WebCore::PhotoSettings, imageWidth)
        , offsetof(WebCore::PhotoSettings, redEyeReduction)
    >::value);

    encoder << instance.fillLightMode;
    encoder << instance.imageHeight;
    encoder << instance.imageWidth;
    encoder << instance.redEyeReduction;
}

std::optional<WebCore::PhotoSettings> ArgumentCoder<WebCore::PhotoSettings>::decode(Decoder& decoder)
{
    auto fillLightMode = decoder.decode<std::optional<WebCore::FillLightMode>>();
    auto imageHeight = decoder.decode<std::optional<double>>();
    auto imageWidth = decoder.decode<std::optional<double>>();
    auto redEyeReduction = decoder.decode<std::optional<bool>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PhotoSettings {
            WTFMove(*fillLightMode),
            WTFMove(*imageHeight),
            WTFMove(*imageWidth),
            WTFMove(*redEyeReduction)
        }
    };
}

#endif

void ArgumentCoder<WebCore::CookieStoreGetOptions>::encode(Encoder& encoder, const WebCore::CookieStoreGetOptions& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url)>, String>);
    struct ShouldBeSameSizeAsCookieStoreGetOptions : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::CookieStoreGetOptions>, false> {
        String name;
        String url;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCookieStoreGetOptions) == sizeof(WebCore::CookieStoreGetOptions));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::CookieStoreGetOptions, name)
        , offsetof(WebCore::CookieStoreGetOptions, url)
    >::value);

    encoder << instance.name;
    encoder << instance.url;
}

std::optional<WebCore::CookieStoreGetOptions> ArgumentCoder<WebCore::CookieStoreGetOptions>::decode(Decoder& decoder)
{
    auto name = decoder.decode<String>();
    auto url = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CookieStoreGetOptions {
            WTFMove(*name),
            WTFMove(*url)
        }
    };
}

void ArgumentCoder<WebCore::CookieChangeSubscription>::encode(Encoder& encoder, const WebCore::CookieChangeSubscription& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url)>, String>);
    struct ShouldBeSameSizeAsCookieChangeSubscription : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::CookieChangeSubscription>, false> {
        String name;
        String url;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCookieChangeSubscription) == sizeof(WebCore::CookieChangeSubscription));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::CookieChangeSubscription, name)
        , offsetof(WebCore::CookieChangeSubscription, url)
    >::value);

    encoder << instance.name;
    encoder << instance.url;
}

std::optional<WebCore::CookieChangeSubscription> ArgumentCoder<WebCore::CookieChangeSubscription>::decode(Decoder& decoder)
{
    auto name = decoder.decode<String>();
    auto url = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CookieChangeSubscription {
            WTFMove(*name),
            WTFMove(*url)
        }
    };
}

void ArgumentCoder<WebCore::Model>::encode(Encoder& encoder, const WebCore::Model& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data())>, Ref<WebCore::SharedBuffer>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mimeType())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url())>, URL>);

    encoder << instance.data();
    encoder << instance.mimeType();
    encoder << instance.url();
}

std::optional<Ref<WebCore::Model>> ArgumentCoder<WebCore::Model>::decode(Decoder& decoder)
{
    auto data = decoder.decode<Ref<WebCore::SharedBuffer>>();
    auto mimeType = decoder.decode<String>();
    auto url = decoder.decode<URL>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Model::create(
            WTFMove(*data),
            WTFMove(*mimeType),
            WTFMove(*url)
        )
    };
}

void ArgumentCoder<WebCore::ModelPlayerAnimationState>::encode(Encoder& encoder, const WebCore::ModelPlayerAnimationState& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.autoplay())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.loop())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.paused())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.duration())>, Seconds>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.effectivePlaybackRate())>, std::optional<double>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lastCachedCurrentTime())>, std::optional<Seconds>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lastCachedClockTimestamp())>, std::optional<MonotonicTime>>);

    encoder << instance.autoplay();
    encoder << instance.loop();
    encoder << instance.paused();
    encoder << instance.duration();
    encoder << instance.effectivePlaybackRate();
    encoder << instance.lastCachedCurrentTime();
    encoder << instance.lastCachedClockTimestamp();
}

std::optional<WebCore::ModelPlayerAnimationState> ArgumentCoder<WebCore::ModelPlayerAnimationState>::decode(Decoder& decoder)
{
    auto autoplay = decoder.decode<bool>();
    auto loop = decoder.decode<bool>();
    auto paused = decoder.decode<bool>();
    auto duration = decoder.decode<Seconds>();
    auto effectivePlaybackRate = decoder.decode<std::optional<double>>();
    auto lastCachedCurrentTime = decoder.decode<std::optional<Seconds>>();
    auto lastCachedClockTimestamp = decoder.decode<std::optional<MonotonicTime>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ModelPlayerAnimationState {
            WTFMove(*autoplay),
            WTFMove(*loop),
            WTFMove(*paused),
            WTFMove(*duration),
            WTFMove(*effectivePlaybackRate),
            WTFMove(*lastCachedCurrentTime),
            WTFMove(*lastCachedClockTimestamp)
        }
    };
}

#if ENABLE(MODEL_PROCESS)
void ArgumentCoder<WebCore::ModelContext>::encode(Encoder& encoder, const WebCore::ModelContext& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.modelLayerIdentifier())>, WebCore::PlatformLayerIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.modelContentsLayerHostingContextIdentifier())>, WebCore::LayerHostingContextIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.modelLayoutSize())>, WebCore::LayoutSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.disablePortal())>, WebCore::ModelContextDisablePortal>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.backgroundColor())>, std::optional<WebCore::Color>>);

    encoder << instance.modelLayerIdentifier();
    encoder << instance.modelContentsLayerHostingContextIdentifier();
    encoder << instance.modelLayoutSize();
    encoder << instance.disablePortal();
    encoder << instance.backgroundColor();
}

std::optional<Ref<WebCore::ModelContext>> ArgumentCoder<WebCore::ModelContext>::decode(Decoder& decoder)
{
    auto modelLayerIdentifier = decoder.decode<WebCore::PlatformLayerIdentifier>();
    auto modelContentsLayerHostingContextIdentifier = decoder.decode<WebCore::LayerHostingContextIdentifier>();
    auto modelLayoutSize = decoder.decode<WebCore::LayoutSize>();
    auto disablePortal = decoder.decode<WebCore::ModelContextDisablePortal>();
    auto backgroundColor = decoder.decode<std::optional<WebCore::Color>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ModelContext::create(
            WTFMove(*modelLayerIdentifier),
            WTFMove(*modelContentsLayerHostingContextIdentifier),
            WTFMove(*modelLayoutSize),
            WTFMove(*disablePortal),
            WTFMove(*backgroundColor)
        )
    };
}

#endif

#if PLATFORM(IOS_FAMILY)
void ArgumentCoder<WebCore::InspectorOverlayLabel::Content::Decoration>::encode(Encoder& encoder, const WebCore::InspectorOverlayLabel::Content::Decoration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::InspectorOverlayLabel::Content::Decoration::Type>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.color)>, WebCore::Color>);
    struct ShouldBeSameSizeAsDecoration : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::InspectorOverlayLabel::Content::Decoration>, false> {
        WebCore::InspectorOverlayLabel::Content::Decoration::Type type;
        WebCore::Color color;
    };
    static_assert(sizeof(ShouldBeSameSizeAsDecoration) == sizeof(WebCore::InspectorOverlayLabel::Content::Decoration));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::InspectorOverlayLabel::Content::Decoration, type)
        , offsetof(WebCore::InspectorOverlayLabel::Content::Decoration, color)
    >::value);

    encoder << instance.type;
    encoder << instance.color;
}

std::optional<WebCore::InspectorOverlayLabel::Content::Decoration> ArgumentCoder<WebCore::InspectorOverlayLabel::Content::Decoration>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::InspectorOverlayLabel::Content::Decoration::Type>();
    auto color = decoder.decode<WebCore::Color>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::InspectorOverlayLabel::Content::Decoration {
            WTFMove(*type),
            WTFMove(*color)
        }
    };
}

#endif

#if PLATFORM(IOS_FAMILY)
void ArgumentCoder<WebCore::InspectorOverlayLabel::Content>::encode(Encoder& encoder, const WebCore::InspectorOverlayLabel::Content& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.text)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.textColor)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.decoration)>, WebCore::InspectorOverlayLabel::Content::Decoration>);
    struct ShouldBeSameSizeAsContent : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::InspectorOverlayLabel::Content>, false> {
        String text;
        WebCore::Color textColor;
        WebCore::InspectorOverlayLabel::Content::Decoration decoration;
    };
    static_assert(sizeof(ShouldBeSameSizeAsContent) == sizeof(WebCore::InspectorOverlayLabel::Content));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::InspectorOverlayLabel::Content, text)
        , offsetof(WebCore::InspectorOverlayLabel::Content, textColor)
        , offsetof(WebCore::InspectorOverlayLabel::Content, decoration)
    >::value);

    encoder << instance.text;
    encoder << instance.textColor;
    encoder << instance.decoration;
}

std::optional<WebCore::InspectorOverlayLabel::Content> ArgumentCoder<WebCore::InspectorOverlayLabel::Content>::decode(Decoder& decoder)
{
    auto text = decoder.decode<String>();
    auto textColor = decoder.decode<WebCore::Color>();
    auto decoration = decoder.decode<WebCore::InspectorOverlayLabel::Content::Decoration>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::InspectorOverlayLabel::Content {
            WTFMove(*text),
            WTFMove(*textColor),
            WTFMove(*decoration)
        }
    };
}

#endif

#if PLATFORM(IOS_FAMILY)
void ArgumentCoder<WebCore::InspectorOverlayLabel::Arrow>::encode(Encoder& encoder, const WebCore::InspectorOverlayLabel::Arrow& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.direction)>, WebCore::InspectorOverlayLabel::Arrow::Direction>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.alignment)>, WebCore::InspectorOverlayLabel::Arrow::Alignment>);
    struct ShouldBeSameSizeAsArrow : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::InspectorOverlayLabel::Arrow>, false> {
        WebCore::InspectorOverlayLabel::Arrow::Direction direction;
        WebCore::InspectorOverlayLabel::Arrow::Alignment alignment;
    };
    static_assert(sizeof(ShouldBeSameSizeAsArrow) == sizeof(WebCore::InspectorOverlayLabel::Arrow));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::InspectorOverlayLabel::Arrow, direction)
        , offsetof(WebCore::InspectorOverlayLabel::Arrow, alignment)
    >::value);

    encoder << instance.direction;
    encoder << instance.alignment;
}

std::optional<WebCore::InspectorOverlayLabel::Arrow> ArgumentCoder<WebCore::InspectorOverlayLabel::Arrow>::decode(Decoder& decoder)
{
    auto direction = decoder.decode<WebCore::InspectorOverlayLabel::Arrow::Direction>();
    auto alignment = decoder.decode<WebCore::InspectorOverlayLabel::Arrow::Alignment>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::InspectorOverlayLabel::Arrow {
            WTFMove(*direction),
            WTFMove(*alignment)
        }
    };
}

#endif

#if PLATFORM(IOS_FAMILY)
void ArgumentCoder<WebCore::InspectorOverlayLabel>::encode(Encoder& encoder, const WebCore::InspectorOverlayLabel& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_contents)>, Vector<WebCore::InspectorOverlayLabel::Content>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_location)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_backgroundColor)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_arrow)>, WebCore::InspectorOverlayLabel::Arrow>);
    struct ShouldBeSameSizeAsInspectorOverlayLabel : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::InspectorOverlayLabel>, false> {
        Vector<WebCore::InspectorOverlayLabel::Content> m_contents;
        WebCore::FloatPoint m_location;
        WebCore::Color m_backgroundColor;
        WebCore::InspectorOverlayLabel::Arrow m_arrow;
    };
    static_assert(sizeof(ShouldBeSameSizeAsInspectorOverlayLabel) == sizeof(WebCore::InspectorOverlayLabel));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::InspectorOverlayLabel, m_contents)
        , offsetof(WebCore::InspectorOverlayLabel, m_location)
        , offsetof(WebCore::InspectorOverlayLabel, m_backgroundColor)
        , offsetof(WebCore::InspectorOverlayLabel, m_arrow)
    >::value);

    encoder << instance.m_contents;
    encoder << instance.m_location;
    encoder << instance.m_backgroundColor;
    encoder << instance.m_arrow;
}

std::optional<WebCore::InspectorOverlayLabel> ArgumentCoder<WebCore::InspectorOverlayLabel>::decode(Decoder& decoder)
{
    auto m_contents = decoder.decode<Vector<WebCore::InspectorOverlayLabel::Content>>();
    auto m_location = decoder.decode<WebCore::FloatPoint>();
    auto m_backgroundColor = decoder.decode<WebCore::Color>();
    auto m_arrow = decoder.decode<WebCore::InspectorOverlayLabel::Arrow>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::InspectorOverlayLabel {
            WTFMove(*m_contents),
            WTFMove(*m_location),
            WTFMove(*m_backgroundColor),
            WTFMove(*m_arrow)
        }
    };
}

#endif

#if PLATFORM(IOS_FAMILY)
void ArgumentCoder<WebCore::InspectorOverlayHighlight::FlexHighlightOverlay>::encode(Encoder& encoder, const WebCore::InspectorOverlayHighlight::FlexHighlightOverlay& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.color)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.containerBounds)>, WebCore::FloatQuad>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.itemBounds)>, Vector<WebCore::FloatQuad>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mainAxisGaps)>, Vector<WebCore::FloatQuad>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mainAxisSpaceBetweenItemsAndGaps)>, Vector<WebCore::FloatQuad>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.spaceBetweenItemsAndCrossAxisSpace)>, Vector<WebCore::FloatQuad>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.crossAxisGaps)>, Vector<WebCore::FloatQuad>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.labels)>, Vector<WebCore::InspectorOverlayLabel>>);
    struct ShouldBeSameSizeAsFlexHighlightOverlay : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::InspectorOverlayHighlight::FlexHighlightOverlay>, false> {
        WebCore::Color color;
        WebCore::FloatQuad containerBounds;
        Vector<WebCore::FloatQuad> itemBounds;
        Vector<WebCore::FloatQuad> mainAxisGaps;
        Vector<WebCore::FloatQuad> mainAxisSpaceBetweenItemsAndGaps;
        Vector<WebCore::FloatQuad> spaceBetweenItemsAndCrossAxisSpace;
        Vector<WebCore::FloatQuad> crossAxisGaps;
        Vector<WebCore::InspectorOverlayLabel> labels;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFlexHighlightOverlay) == sizeof(WebCore::InspectorOverlayHighlight::FlexHighlightOverlay));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::InspectorOverlayHighlight::FlexHighlightOverlay, color)
        , offsetof(WebCore::InspectorOverlayHighlight::FlexHighlightOverlay, containerBounds)
        , offsetof(WebCore::InspectorOverlayHighlight::FlexHighlightOverlay, itemBounds)
        , offsetof(WebCore::InspectorOverlayHighlight::FlexHighlightOverlay, mainAxisGaps)
        , offsetof(WebCore::InspectorOverlayHighlight::FlexHighlightOverlay, mainAxisSpaceBetweenItemsAndGaps)
        , offsetof(WebCore::InspectorOverlayHighlight::FlexHighlightOverlay, spaceBetweenItemsAndCrossAxisSpace)
        , offsetof(WebCore::InspectorOverlayHighlight::FlexHighlightOverlay, crossAxisGaps)
        , offsetof(WebCore::InspectorOverlayHighlight::FlexHighlightOverlay, labels)
    >::value);

    encoder << instance.color;
    encoder << instance.containerBounds;
    encoder << instance.itemBounds;
    encoder << instance.mainAxisGaps;
    encoder << instance.mainAxisSpaceBetweenItemsAndGaps;
    encoder << instance.spaceBetweenItemsAndCrossAxisSpace;
    encoder << instance.crossAxisGaps;
    encoder << instance.labels;
}

std::optional<WebCore::InspectorOverlayHighlight::FlexHighlightOverlay> ArgumentCoder<WebCore::InspectorOverlayHighlight::FlexHighlightOverlay>::decode(Decoder& decoder)
{
    auto color = decoder.decode<WebCore::Color>();
    auto containerBounds = decoder.decode<WebCore::FloatQuad>();
    auto itemBounds = decoder.decode<Vector<WebCore::FloatQuad>>();
    auto mainAxisGaps = decoder.decode<Vector<WebCore::FloatQuad>>();
    auto mainAxisSpaceBetweenItemsAndGaps = decoder.decode<Vector<WebCore::FloatQuad>>();
    auto spaceBetweenItemsAndCrossAxisSpace = decoder.decode<Vector<WebCore::FloatQuad>>();
    auto crossAxisGaps = decoder.decode<Vector<WebCore::FloatQuad>>();
    auto labels = decoder.decode<Vector<WebCore::InspectorOverlayLabel>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::InspectorOverlayHighlight::FlexHighlightOverlay {
            WTFMove(*color),
            WTFMove(*containerBounds),
            WTFMove(*itemBounds),
            WTFMove(*mainAxisGaps),
            WTFMove(*mainAxisSpaceBetweenItemsAndGaps),
            WTFMove(*spaceBetweenItemsAndCrossAxisSpace),
            WTFMove(*crossAxisGaps),
            WTFMove(*labels)
        }
    };
}

#endif

#if PLATFORM(IOS_FAMILY)
void ArgumentCoder<WebCore::InspectorOverlayHighlight::GridHighlightOverlay::Area>::encode(Encoder& encoder, const WebCore::InspectorOverlayHighlight::GridHighlightOverlay::Area& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.quad)>, WebCore::FloatQuad>);
    struct ShouldBeSameSizeAsArea : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::InspectorOverlayHighlight::GridHighlightOverlay::Area>, false> {
        String name;
        WebCore::FloatQuad quad;
    };
    static_assert(sizeof(ShouldBeSameSizeAsArea) == sizeof(WebCore::InspectorOverlayHighlight::GridHighlightOverlay::Area));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::InspectorOverlayHighlight::GridHighlightOverlay::Area, name)
        , offsetof(WebCore::InspectorOverlayHighlight::GridHighlightOverlay::Area, quad)
    >::value);

    encoder << instance.name;
    encoder << instance.quad;
}

std::optional<WebCore::InspectorOverlayHighlight::GridHighlightOverlay::Area> ArgumentCoder<WebCore::InspectorOverlayHighlight::GridHighlightOverlay::Area>::decode(Decoder& decoder)
{
    auto name = decoder.decode<String>();
    auto quad = decoder.decode<WebCore::FloatQuad>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::InspectorOverlayHighlight::GridHighlightOverlay::Area {
            WTFMove(*name),
            WTFMove(*quad)
        }
    };
}

#endif

#if PLATFORM(IOS_FAMILY)
void ArgumentCoder<WebCore::InspectorOverlayHighlight::GridHighlightOverlay>::encode(Encoder& encoder, const WebCore::InspectorOverlayHighlight::GridHighlightOverlay& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.color)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.gridLines)>, Vector<WebCore::FloatLine>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.gaps)>, Vector<WebCore::FloatQuad>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.areas)>, Vector<WebCore::InspectorOverlayHighlight::GridHighlightOverlay::Area>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.labels)>, Vector<WebCore::InspectorOverlayLabel>>);
    struct ShouldBeSameSizeAsGridHighlightOverlay : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::InspectorOverlayHighlight::GridHighlightOverlay>, false> {
        WebCore::Color color;
        Vector<WebCore::FloatLine> gridLines;
        Vector<WebCore::FloatQuad> gaps;
        Vector<WebCore::InspectorOverlayHighlight::GridHighlightOverlay::Area> areas;
        Vector<WebCore::InspectorOverlayLabel> labels;
    };
    static_assert(sizeof(ShouldBeSameSizeAsGridHighlightOverlay) == sizeof(WebCore::InspectorOverlayHighlight::GridHighlightOverlay));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::InspectorOverlayHighlight::GridHighlightOverlay, color)
        , offsetof(WebCore::InspectorOverlayHighlight::GridHighlightOverlay, gridLines)
        , offsetof(WebCore::InspectorOverlayHighlight::GridHighlightOverlay, gaps)
        , offsetof(WebCore::InspectorOverlayHighlight::GridHighlightOverlay, areas)
        , offsetof(WebCore::InspectorOverlayHighlight::GridHighlightOverlay, labels)
    >::value);

    encoder << instance.color;
    encoder << instance.gridLines;
    encoder << instance.gaps;
    encoder << instance.areas;
    encoder << instance.labels;
}

std::optional<WebCore::InspectorOverlayHighlight::GridHighlightOverlay> ArgumentCoder<WebCore::InspectorOverlayHighlight::GridHighlightOverlay>::decode(Decoder& decoder)
{
    auto color = decoder.decode<WebCore::Color>();
    auto gridLines = decoder.decode<Vector<WebCore::FloatLine>>();
    auto gaps = decoder.decode<Vector<WebCore::FloatQuad>>();
    auto areas = decoder.decode<Vector<WebCore::InspectorOverlayHighlight::GridHighlightOverlay::Area>>();
    auto labels = decoder.decode<Vector<WebCore::InspectorOverlayLabel>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::InspectorOverlayHighlight::GridHighlightOverlay {
            WTFMove(*color),
            WTFMove(*gridLines),
            WTFMove(*gaps),
            WTFMove(*areas),
            WTFMove(*labels)
        }
    };
}

#endif

#if PLATFORM(IOS_FAMILY)
void ArgumentCoder<WebCore::InspectorOverlayHighlight>::encode(Encoder& encoder, const WebCore::InspectorOverlayHighlight& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentColor)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentOutlineColor)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.paddingColor)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.borderColor)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.marginColor)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::InspectorOverlayHighlight::Type>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.quads)>, Vector<WebCore::FloatQuad>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.gridHighlightOverlays)>, Vector<WebCore::InspectorOverlayHighlight::GridHighlightOverlay>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.flexHighlightOverlays)>, Vector<WebCore::InspectorOverlayHighlight::FlexHighlightOverlay>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.usePageCoordinates)>, bool>);
    struct ShouldBeSameSizeAsInspectorOverlayHighlight : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::InspectorOverlayHighlight>, false> {
        WebCore::Color contentColor;
        WebCore::Color contentOutlineColor;
        WebCore::Color paddingColor;
        WebCore::Color borderColor;
        WebCore::Color marginColor;
        WebCore::InspectorOverlayHighlight::Type type;
        Vector<WebCore::FloatQuad> quads;
        Vector<WebCore::InspectorOverlayHighlight::GridHighlightOverlay> gridHighlightOverlays;
        Vector<WebCore::InspectorOverlayHighlight::FlexHighlightOverlay> flexHighlightOverlays;
        bool usePageCoordinates;
    };
    static_assert(sizeof(ShouldBeSameSizeAsInspectorOverlayHighlight) == sizeof(WebCore::InspectorOverlayHighlight));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::InspectorOverlayHighlight, contentColor)
        , offsetof(WebCore::InspectorOverlayHighlight, contentOutlineColor)
        , offsetof(WebCore::InspectorOverlayHighlight, paddingColor)
        , offsetof(WebCore::InspectorOverlayHighlight, borderColor)
        , offsetof(WebCore::InspectorOverlayHighlight, marginColor)
        , offsetof(WebCore::InspectorOverlayHighlight, type)
        , offsetof(WebCore::InspectorOverlayHighlight, quads)
        , offsetof(WebCore::InspectorOverlayHighlight, gridHighlightOverlays)
        , offsetof(WebCore::InspectorOverlayHighlight, flexHighlightOverlays)
        , offsetof(WebCore::InspectorOverlayHighlight, usePageCoordinates)
    >::value);

    encoder << instance.contentColor;
    encoder << instance.contentOutlineColor;
    encoder << instance.paddingColor;
    encoder << instance.borderColor;
    encoder << instance.marginColor;
    encoder << instance.type;
    encoder << instance.quads;
    encoder << instance.gridHighlightOverlays;
    encoder << instance.flexHighlightOverlays;
    encoder << instance.usePageCoordinates;
}

std::optional<WebCore::InspectorOverlayHighlight> ArgumentCoder<WebCore::InspectorOverlayHighlight>::decode(Decoder& decoder)
{
    auto contentColor = decoder.decode<WebCore::Color>();
    auto contentOutlineColor = decoder.decode<WebCore::Color>();
    auto paddingColor = decoder.decode<WebCore::Color>();
    auto borderColor = decoder.decode<WebCore::Color>();
    auto marginColor = decoder.decode<WebCore::Color>();
    auto type = decoder.decode<WebCore::InspectorOverlayHighlight::Type>();
    auto quads = decoder.decode<Vector<WebCore::FloatQuad>>();
    auto gridHighlightOverlays = decoder.decode<Vector<WebCore::InspectorOverlayHighlight::GridHighlightOverlay>>();
    auto flexHighlightOverlays = decoder.decode<Vector<WebCore::InspectorOverlayHighlight::FlexHighlightOverlay>>();
    auto usePageCoordinates = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::InspectorOverlayHighlight {
            WTFMove(*contentColor),
            WTFMove(*contentOutlineColor),
            WTFMove(*paddingColor),
            WTFMove(*borderColor),
            WTFMove(*marginColor),
            WTFMove(*type),
            WTFMove(*quads),
            WTFMove(*gridHighlightOverlays),
            WTFMove(*flexHighlightOverlays),
            WTFMove(*usePageCoordinates)
        }
    };
}

#endif

void ArgumentCoder<WebCore::DiagnosticLoggingDictionary>::encode(Encoder& encoder, const WebCore::DiagnosticLoggingDictionary& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dictionary)>, HashMap<String, Variant<String, uint64_t, int64_t, bool, double>>>);
    struct ShouldBeSameSizeAsDiagnosticLoggingDictionary : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::DiagnosticLoggingDictionary>, false> {
        HashMap<String, Variant<String, uint64_t, int64_t, bool, double>> dictionary;
    };
    static_assert(sizeof(ShouldBeSameSizeAsDiagnosticLoggingDictionary) == sizeof(WebCore::DiagnosticLoggingDictionary));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::DiagnosticLoggingDictionary, dictionary)
    >::value);

    encoder << instance.dictionary;
}

std::optional<WebCore::DiagnosticLoggingDictionary> ArgumentCoder<WebCore::DiagnosticLoggingDictionary>::decode(Decoder& decoder)
{
    auto dictionary = decoder.decode<HashMap<String, Variant<String, uint64_t, int64_t, bool, double>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DiagnosticLoggingDictionary {
            WTFMove(*dictionary)
        }
    };
}

void ArgumentCoder<WebCore::FixedPositionViewportConstraints>::encode(Encoder& encoder, const WebCore::FixedPositionViewportConstraints& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.alignmentOffset())>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.anchorEdges())>, WebCore::ViewportConstraints::AnchorEdges>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.viewportRectAtLastLayout())>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.layerPositionAtLastLayout())>, WebCore::FloatPoint>);

    encoder << instance.alignmentOffset();
    encoder << instance.anchorEdges();
    encoder << instance.viewportRectAtLastLayout();
    encoder << instance.layerPositionAtLastLayout();
}

std::optional<WebCore::FixedPositionViewportConstraints> ArgumentCoder<WebCore::FixedPositionViewportConstraints>::decode(Decoder& decoder)
{
    auto alignmentOffset = decoder.decode<WebCore::FloatSize>();
    auto anchorEdges = decoder.decode<WebCore::ViewportConstraints::AnchorEdges>();
    auto viewportRectAtLastLayout = decoder.decode<WebCore::FloatRect>();
    auto layerPositionAtLastLayout = decoder.decode<WebCore::FloatPoint>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FixedPositionViewportConstraints {
            WTFMove(*alignmentOffset),
            WTFMove(*anchorEdges),
            WTFMove(*viewportRectAtLastLayout),
            WTFMove(*layerPositionAtLastLayout)
        }
    };
}

void ArgumentCoder<WebCore::StickyPositionViewportConstraints>::encode(Encoder& encoder, const WebCore::StickyPositionViewportConstraints& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.alignmentOffset())>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.anchorEdges())>, WebCore::ViewportConstraints::AnchorEdges>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.leftOffset())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rightOffset())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.topOffset())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bottomOffset())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.constrainingRectAtLastLayout())>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.containingBlockRect())>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stickyBoxRect())>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stickyOffsetAtLastLayout())>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.anchorLayerOffsetAtLastLayout())>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.viewportRectAtLastLayout())>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.layerPositionAtLastLayout())>, WebCore::FloatPoint>);

    encoder << instance.alignmentOffset();
    encoder << instance.anchorEdges();
    encoder << instance.leftOffset();
    encoder << instance.rightOffset();
    encoder << instance.topOffset();
    encoder << instance.bottomOffset();
    encoder << instance.constrainingRectAtLastLayout();
    encoder << instance.containingBlockRect();
    encoder << instance.stickyBoxRect();
    encoder << instance.stickyOffsetAtLastLayout();
    encoder << instance.anchorLayerOffsetAtLastLayout();
    encoder << instance.viewportRectAtLastLayout();
    encoder << instance.layerPositionAtLastLayout();
}

std::optional<WebCore::StickyPositionViewportConstraints> ArgumentCoder<WebCore::StickyPositionViewportConstraints>::decode(Decoder& decoder)
{
    auto alignmentOffset = decoder.decode<WebCore::FloatSize>();
    auto anchorEdges = decoder.decode<WebCore::ViewportConstraints::AnchorEdges>();
    auto leftOffset = decoder.decode<float>();
    auto rightOffset = decoder.decode<float>();
    auto topOffset = decoder.decode<float>();
    auto bottomOffset = decoder.decode<float>();
    auto constrainingRectAtLastLayout = decoder.decode<WebCore::FloatRect>();
    auto containingBlockRect = decoder.decode<WebCore::FloatRect>();
    auto stickyBoxRect = decoder.decode<WebCore::FloatRect>();
    auto stickyOffsetAtLastLayout = decoder.decode<WebCore::FloatSize>();
    auto anchorLayerOffsetAtLastLayout = decoder.decode<WebCore::FloatSize>();
    auto viewportRectAtLastLayout = decoder.decode<WebCore::FloatRect>();
    auto layerPositionAtLastLayout = decoder.decode<WebCore::FloatPoint>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::StickyPositionViewportConstraints {
            WTFMove(*alignmentOffset),
            WTFMove(*anchorEdges),
            WTFMove(*leftOffset),
            WTFMove(*rightOffset),
            WTFMove(*topOffset),
            WTFMove(*bottomOffset),
            WTFMove(*constrainingRectAtLastLayout),
            WTFMove(*containingBlockRect),
            WTFMove(*stickyBoxRect),
            WTFMove(*stickyOffsetAtLastLayout),
            WTFMove(*anchorLayerOffsetAtLastLayout),
            WTFMove(*viewportRectAtLastLayout),
            WTFMove(*layerPositionAtLastLayout)
        }
    };
}

void ArgumentCoder<WebCore::FloatLine>::encode(Encoder& encoder, const WebCore::FloatLine& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.start())>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.end())>, WebCore::FloatPoint>);

    encoder << instance.start();
    encoder << instance.end();
}

std::optional<WebCore::FloatLine> ArgumentCoder<WebCore::FloatLine>::decode(Decoder& decoder)
{
    auto start = decoder.decode<WebCore::FloatPoint>();
    auto end = decoder.decode<WebCore::FloatPoint>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FloatLine {
            WTFMove(*start),
            WTFMove(*end)
        }
    };
}

void ArgumentCoder<WebCore::FontCachePrewarmInformation>::encode(Encoder& encoder, const WebCore::FontCachePrewarmInformation& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.seenFamilies)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fontNamesRequiringSystemFallback)>, Vector<String>>);
    struct ShouldBeSameSizeAsFontCachePrewarmInformation : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FontCachePrewarmInformation>, false> {
        Vector<String> seenFamilies;
        Vector<String> fontNamesRequiringSystemFallback;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFontCachePrewarmInformation) == sizeof(WebCore::FontCachePrewarmInformation));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FontCachePrewarmInformation, seenFamilies)
        , offsetof(WebCore::FontCachePrewarmInformation, fontNamesRequiringSystemFallback)
    >::value);

    encoder << instance.seenFamilies;
    encoder << instance.fontNamesRequiringSystemFallback;
}

std::optional<WebCore::FontCachePrewarmInformation> ArgumentCoder<WebCore::FontCachePrewarmInformation>::decode(Decoder& decoder)
{
    auto seenFamilies = decoder.decode<Vector<String>>();
    auto fontNamesRequiringSystemFallback = decoder.decode<Vector<String>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FontCachePrewarmInformation {
            WTFMove(*seenFamilies),
            WTFMove(*fontNamesRequiringSystemFallback)
        }
    };
}

void ArgumentCoder<WebCore::PrewarmInformation>::encode(Encoder& encoder, const WebCore::PrewarmInformation& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fontCache)>, WebCore::FontCachePrewarmInformation>);
    struct ShouldBeSameSizeAsPrewarmInformation : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PrewarmInformation>, false> {
        WebCore::FontCachePrewarmInformation fontCache;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPrewarmInformation) == sizeof(WebCore::PrewarmInformation));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PrewarmInformation, fontCache)
    >::value);

    encoder << instance.fontCache;
}

std::optional<WebCore::PrewarmInformation> ArgumentCoder<WebCore::PrewarmInformation>::decode(Decoder& decoder)
{
    auto fontCache = decoder.decode<WebCore::FontCachePrewarmInformation>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PrewarmInformation {
            WTFMove(*fontCache)
        }
    };
}

void ArgumentCoder<WebCore::FontSelectionValue>::encode(Encoder& encoder, const WebCore::FontSelectionValue& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rawValue())>, WebCore::FontSelectionValue::BackingType>);

    encoder << instance.rawValue();
}

std::optional<WebCore::FontSelectionValue> ArgumentCoder<WebCore::FontSelectionValue>::decode(Decoder& decoder)
{
    auto rawValue = decoder.decode<WebCore::FontSelectionValue::BackingType>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FontSelectionValue {
            WTFMove(*rawValue)
        }
    };
}

void ArgumentCoder<WebCore::FontSelectionRange>::encode(Encoder& encoder, const WebCore::FontSelectionRange& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.minimum)>, WebCore::FontSelectionValue>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maximum)>, WebCore::FontSelectionValue>);
    struct ShouldBeSameSizeAsFontSelectionRange : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FontSelectionRange>, false> {
        WebCore::FontSelectionValue minimum;
        WebCore::FontSelectionValue maximum;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFontSelectionRange) == sizeof(WebCore::FontSelectionRange));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FontSelectionRange, minimum)
        , offsetof(WebCore::FontSelectionRange, maximum)
    >::value);

    encoder << instance.minimum;
    encoder << instance.maximum;
}

std::optional<WebCore::FontSelectionRange> ArgumentCoder<WebCore::FontSelectionRange>::decode(Decoder& decoder)
{
    auto minimum = decoder.decode<WebCore::FontSelectionValue>();
    auto maximum = decoder.decode<WebCore::FontSelectionValue>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FontSelectionRange {
            WTFMove(*minimum),
            WTFMove(*maximum)
        }
    };
}

void ArgumentCoder<WebCore::FontSelectionSpecifiedCapabilities>::encode(Encoder& encoder, const WebCore::FontSelectionSpecifiedCapabilities& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.weight)>, std::optional<WebCore::FontSelectionRange>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.width)>, std::optional<WebCore::FontSelectionRange>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.slope)>, std::optional<WebCore::FontSelectionRange>>);
    struct ShouldBeSameSizeAsFontSelectionSpecifiedCapabilities : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FontSelectionSpecifiedCapabilities>, false> {
        std::optional<WebCore::FontSelectionRange> weight;
        std::optional<WebCore::FontSelectionRange> width;
        std::optional<WebCore::FontSelectionRange> slope;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFontSelectionSpecifiedCapabilities) == sizeof(WebCore::FontSelectionSpecifiedCapabilities));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FontSelectionSpecifiedCapabilities, weight)
        , offsetof(WebCore::FontSelectionSpecifiedCapabilities, width)
        , offsetof(WebCore::FontSelectionSpecifiedCapabilities, slope)
    >::value);

    encoder << instance.weight;
    encoder << instance.width;
    encoder << instance.slope;
}

std::optional<WebCore::FontSelectionSpecifiedCapabilities> ArgumentCoder<WebCore::FontSelectionSpecifiedCapabilities>::decode(Decoder& decoder)
{
    auto weight = decoder.decode<std::optional<WebCore::FontSelectionRange>>();
    auto width = decoder.decode<std::optional<WebCore::FontSelectionRange>>();
    auto slope = decoder.decode<std::optional<WebCore::FontSelectionRange>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FontSelectionSpecifiedCapabilities {
            WTFMove(*weight),
            WTFMove(*width),
            WTFMove(*slope)
        }
    };
}

void ArgumentCoder<WebCore::RemoteUserInputEventData>::encode(Encoder& encoder, const WebCore::RemoteUserInputEventData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.targetFrameID)>, WebCore::FrameIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.transformedPoint)>, WebCore::IntPoint>);
    struct ShouldBeSameSizeAsRemoteUserInputEventData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::RemoteUserInputEventData>, false> {
        WebCore::FrameIdentifier targetFrameID;
        WebCore::IntPoint transformedPoint;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRemoteUserInputEventData) == sizeof(WebCore::RemoteUserInputEventData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::RemoteUserInputEventData, targetFrameID)
        , offsetof(WebCore::RemoteUserInputEventData, transformedPoint)
    >::value);

    encoder << instance.targetFrameID;
    encoder << instance.transformedPoint;
}

std::optional<WebCore::RemoteUserInputEventData> ArgumentCoder<WebCore::RemoteUserInputEventData>::decode(Decoder& decoder)
{
    auto targetFrameID = decoder.decode<WebCore::FrameIdentifier>();
    auto transformedPoint = decoder.decode<WebCore::IntPoint>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::RemoteUserInputEventData {
            WTFMove(*targetFrameID),
            WTFMove(*transformedPoint)
        }
    };
}

void ArgumentCoder<WebCore::LinkDecorationFilteringData>::encode(Encoder& encoder, const WebCore::LinkDecorationFilteringData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.domain)>, WebCore::RegistrableDomain>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.path)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.linkDecoration)>, String>);
    struct ShouldBeSameSizeAsLinkDecorationFilteringData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::LinkDecorationFilteringData>, false> {
        WebCore::RegistrableDomain domain;
        String path;
        String linkDecoration;
    };
    static_assert(sizeof(ShouldBeSameSizeAsLinkDecorationFilteringData) == sizeof(WebCore::LinkDecorationFilteringData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::LinkDecorationFilteringData, domain)
        , offsetof(WebCore::LinkDecorationFilteringData, path)
        , offsetof(WebCore::LinkDecorationFilteringData, linkDecoration)
    >::value);

    encoder << instance.domain;
    encoder << instance.path;
    encoder << instance.linkDecoration;
}

std::optional<WebCore::LinkDecorationFilteringData> ArgumentCoder<WebCore::LinkDecorationFilteringData>::decode(Decoder& decoder)
{
    auto domain = decoder.decode<WebCore::RegistrableDomain>();
    auto path = decoder.decode<String>();
    auto linkDecoration = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::LinkDecorationFilteringData {
            WTFMove(*domain),
            WTFMove(*path),
            WTFMove(*linkDecoration)
        }
    };
}

void ArgumentCoder<WebCore::InspectorFrontendClientSaveData>::encode(Encoder& encoder, const WebCore::InspectorFrontendClientSaveData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.displayType)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.content)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.base64Encoded)>, bool>);
    struct ShouldBeSameSizeAsInspectorFrontendClientSaveData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::InspectorFrontendClientSaveData>, false> {
        String displayType;
        String url;
        String content;
        bool base64Encoded;
    };
    static_assert(sizeof(ShouldBeSameSizeAsInspectorFrontendClientSaveData) == sizeof(WebCore::InspectorFrontendClientSaveData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::InspectorFrontendClientSaveData, displayType)
        , offsetof(WebCore::InspectorFrontendClientSaveData, url)
        , offsetof(WebCore::InspectorFrontendClientSaveData, content)
        , offsetof(WebCore::InspectorFrontendClientSaveData, base64Encoded)
    >::value);

    encoder << instance.displayType;
    encoder << instance.url;
    encoder << instance.content;
    encoder << instance.base64Encoded;
}

std::optional<WebCore::InspectorFrontendClientSaveData> ArgumentCoder<WebCore::InspectorFrontendClientSaveData>::decode(Decoder& decoder)
{
    auto displayType = decoder.decode<String>();
    auto url = decoder.decode<String>();
    auto content = decoder.decode<String>();
    auto base64Encoded = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::InspectorFrontendClientSaveData {
            WTFMove(*displayType),
            WTFMove(*url),
            WTFMove(*content),
            WTFMove(*base64Encoded)
        }
    };
}

#if ENABLE(VIDEO)
void ArgumentCoder<WebCore::PlatformTextTrackData>::encode(Encoder& encoder, const WebCore::PlatformTextTrackData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_label)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_language)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_url)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_mode)>, WebCore::PlatformTextTrackData::TrackMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_kind)>, WebCore::PlatformTextTrackData::TrackKind>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_type)>, WebCore::PlatformTextTrackData::TrackType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_uniqueId)>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_isDefault)>, bool>);
    struct ShouldBeSameSizeAsPlatformTextTrackData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::PlatformTextTrackData>, false> {
        String m_label;
        String m_language;
        String m_url;
        WebCore::PlatformTextTrackData::TrackMode m_mode;
        WebCore::PlatformTextTrackData::TrackKind m_kind;
        WebCore::PlatformTextTrackData::TrackType m_type;
        int m_uniqueId;
        bool m_isDefault;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPlatformTextTrackData) == sizeof(WebCore::PlatformTextTrackData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::PlatformTextTrackData, m_label)
        , offsetof(WebCore::PlatformTextTrackData, m_language)
        , offsetof(WebCore::PlatformTextTrackData, m_url)
        , offsetof(WebCore::PlatformTextTrackData, m_mode)
        , offsetof(WebCore::PlatformTextTrackData, m_kind)
        , offsetof(WebCore::PlatformTextTrackData, m_type)
        , offsetof(WebCore::PlatformTextTrackData, m_uniqueId)
        , offsetof(WebCore::PlatformTextTrackData, m_isDefault)
    >::value);

    encoder << instance.m_label;
    encoder << instance.m_language;
    encoder << instance.m_url;
    encoder << instance.m_mode;
    encoder << instance.m_kind;
    encoder << instance.m_type;
    encoder << instance.m_uniqueId;
    encoder << instance.m_isDefault;
}

std::optional<WebCore::PlatformTextTrackData> ArgumentCoder<WebCore::PlatformTextTrackData>::decode(Decoder& decoder)
{
    auto m_label = decoder.decode<String>();
    auto m_language = decoder.decode<String>();
    auto m_url = decoder.decode<String>();
    auto m_mode = decoder.decode<WebCore::PlatformTextTrackData::TrackMode>();
    auto m_kind = decoder.decode<WebCore::PlatformTextTrackData::TrackKind>();
    auto m_type = decoder.decode<WebCore::PlatformTextTrackData::TrackType>();
    auto m_uniqueId = decoder.decode<int>();
    auto m_isDefault = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PlatformTextTrackData {
            WTFMove(*m_label),
            WTFMove(*m_language),
            WTFMove(*m_url),
            WTFMove(*m_mode),
            WTFMove(*m_kind),
            WTFMove(*m_type),
            WTFMove(*m_uniqueId),
            WTFMove(*m_isDefault)
        }
    };
}

#endif

void ArgumentCoder<WebCore::NetworkLoadMetrics>::encode(Encoder& encoder, const WebCore::NetworkLoadMetrics& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.redirectStart)>, MonotonicTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fetchStart)>, MonotonicTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.domainLookupStart)>, MonotonicTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.domainLookupEnd)>, MonotonicTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.connectStart)>, MonotonicTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.secureConnectionStart)>, MonotonicTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.connectEnd)>, MonotonicTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requestStart)>, MonotonicTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.responseStart)>, MonotonicTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.responseEnd)>, MonotonicTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.workerStart)>, MonotonicTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.protocol)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.redirectCount)>, uint16_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isComplete())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isCellular())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isExpensive())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isConstrained())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isMultipath())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.reusedConnection())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.doesFailTAOCheck())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.crossOriginRedirect())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.privacyStance)>, WebCore::PrivacyStance>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.responseBodyBytesReceived)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.responseBodyDecodedSize)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.additionalNetworkLoadMetricsForWebInspector)>, RefPtr<WebCore::AdditionalNetworkLoadMetricsForWebInspector>>);

    encoder << instance.redirectStart;
    encoder << instance.fetchStart;
    encoder << instance.domainLookupStart;
    encoder << instance.domainLookupEnd;
    encoder << instance.connectStart;
    encoder << instance.secureConnectionStart;
    encoder << instance.connectEnd;
    encoder << instance.requestStart;
    encoder << instance.responseStart;
    encoder << instance.responseEnd;
    encoder << instance.workerStart;
    encoder << instance.protocol;
    encoder << instance.redirectCount;
    encoder << instance.isComplete();
    encoder << instance.isCellular();
    encoder << instance.isExpensive();
    encoder << instance.isConstrained();
    encoder << instance.isMultipath();
    encoder << instance.reusedConnection();
    encoder << instance.doesFailTAOCheck();
    encoder << instance.crossOriginRedirect();
    encoder << instance.privacyStance;
    encoder << instance.responseBodyBytesReceived;
    encoder << instance.responseBodyDecodedSize;
    encoder << instance.additionalNetworkLoadMetricsForWebInspector;
}

std::optional<WebCore::NetworkLoadMetrics> ArgumentCoder<WebCore::NetworkLoadMetrics>::decode(Decoder& decoder)
{
    auto redirectStart = decoder.decode<MonotonicTime>();
    auto fetchStart = decoder.decode<MonotonicTime>();
    auto domainLookupStart = decoder.decode<MonotonicTime>();
    auto domainLookupEnd = decoder.decode<MonotonicTime>();
    auto connectStart = decoder.decode<MonotonicTime>();
    auto secureConnectionStart = decoder.decode<MonotonicTime>();
    auto connectEnd = decoder.decode<MonotonicTime>();
    auto requestStart = decoder.decode<MonotonicTime>();
    auto responseStart = decoder.decode<MonotonicTime>();
    auto responseEnd = decoder.decode<MonotonicTime>();
    auto workerStart = decoder.decode<MonotonicTime>();
    auto protocol = decoder.decode<String>();
    auto redirectCount = decoder.decode<uint16_t>();
    auto isComplete = decoder.decode<bool>();
    auto isCellular = decoder.decode<bool>();
    auto isExpensive = decoder.decode<bool>();
    auto isConstrained = decoder.decode<bool>();
    auto isMultipath = decoder.decode<bool>();
    auto reusedConnection = decoder.decode<bool>();
    auto doesFailTAOCheck = decoder.decode<bool>();
    auto crossOriginRedirect = decoder.decode<bool>();
    auto privacyStance = decoder.decode<WebCore::PrivacyStance>();
    auto responseBodyBytesReceived = decoder.decode<uint64_t>();
    auto responseBodyDecodedSize = decoder.decode<uint64_t>();
    auto additionalNetworkLoadMetricsForWebInspector = decoder.decode<RefPtr<WebCore::AdditionalNetworkLoadMetricsForWebInspector>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::NetworkLoadMetrics {
            WTFMove(*redirectStart),
            WTFMove(*fetchStart),
            WTFMove(*domainLookupStart),
            WTFMove(*domainLookupEnd),
            WTFMove(*connectStart),
            WTFMove(*secureConnectionStart),
            WTFMove(*connectEnd),
            WTFMove(*requestStart),
            WTFMove(*responseStart),
            WTFMove(*responseEnd),
            WTFMove(*workerStart),
            WTFMove(*protocol),
            WTFMove(*redirectCount),
            WTFMove(*isComplete),
            WTFMove(*isCellular),
            WTFMove(*isExpensive),
            WTFMove(*isConstrained),
            WTFMove(*isMultipath),
            WTFMove(*reusedConnection),
            WTFMove(*doesFailTAOCheck),
            WTFMove(*crossOriginRedirect),
            WTFMove(*privacyStance),
            WTFMove(*responseBodyBytesReceived),
            WTFMove(*responseBodyDecodedSize),
            WTFMove(*additionalNetworkLoadMetricsForWebInspector)
        }
    };
}

void ArgumentCoder<WebCore::AdditionalNetworkLoadMetricsForWebInspector>::encode(Encoder& encoder, const WebCore::AdditionalNetworkLoadMetricsForWebInspector& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.priority)>, WebCore::NetworkLoadPriority>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.remoteAddress)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.connectionIdentifier)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tlsProtocol)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tlsCipher)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requestHeaders)>, WebCore::HTTPHeaderMap>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requestHeaderBytesSent)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.responseHeaderBytesReceived)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requestBodyBytesSent)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isProxyConnection)>, bool>);
    struct ShouldBeSameSizeAsAdditionalNetworkLoadMetricsForWebInspector : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::AdditionalNetworkLoadMetricsForWebInspector>, true> {
        WebCore::NetworkLoadPriority priority;
        String remoteAddress;
        String connectionIdentifier;
        String tlsProtocol;
        String tlsCipher;
        WebCore::HTTPHeaderMap requestHeaders;
        uint64_t requestHeaderBytesSent;
        uint64_t responseHeaderBytesReceived;
        uint64_t requestBodyBytesSent;
        bool isProxyConnection;
    };
    static_assert(sizeof(ShouldBeSameSizeAsAdditionalNetworkLoadMetricsForWebInspector) == sizeof(WebCore::AdditionalNetworkLoadMetricsForWebInspector));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::AdditionalNetworkLoadMetricsForWebInspector, priority)
        , offsetof(WebCore::AdditionalNetworkLoadMetricsForWebInspector, remoteAddress)
        , offsetof(WebCore::AdditionalNetworkLoadMetricsForWebInspector, connectionIdentifier)
        , offsetof(WebCore::AdditionalNetworkLoadMetricsForWebInspector, tlsProtocol)
        , offsetof(WebCore::AdditionalNetworkLoadMetricsForWebInspector, tlsCipher)
        , offsetof(WebCore::AdditionalNetworkLoadMetricsForWebInspector, requestHeaders)
        , offsetof(WebCore::AdditionalNetworkLoadMetricsForWebInspector, requestHeaderBytesSent)
        , offsetof(WebCore::AdditionalNetworkLoadMetricsForWebInspector, responseHeaderBytesReceived)
        , offsetof(WebCore::AdditionalNetworkLoadMetricsForWebInspector, requestBodyBytesSent)
        , offsetof(WebCore::AdditionalNetworkLoadMetricsForWebInspector, isProxyConnection)
    >::value);

    encoder << instance.priority;
    encoder << instance.remoteAddress;
    encoder << instance.connectionIdentifier;
    encoder << instance.tlsProtocol;
    encoder << instance.tlsCipher;
    encoder << instance.requestHeaders;
    encoder << instance.requestHeaderBytesSent;
    encoder << instance.responseHeaderBytesReceived;
    encoder << instance.requestBodyBytesSent;
    encoder << instance.isProxyConnection;
}

std::optional<Ref<WebCore::AdditionalNetworkLoadMetricsForWebInspector>> ArgumentCoder<WebCore::AdditionalNetworkLoadMetricsForWebInspector>::decode(Decoder& decoder)
{
    auto priority = decoder.decode<WebCore::NetworkLoadPriority>();
    auto remoteAddress = decoder.decode<String>();
    auto connectionIdentifier = decoder.decode<String>();
    auto tlsProtocol = decoder.decode<String>();
    auto tlsCipher = decoder.decode<String>();
    auto requestHeaders = decoder.decode<WebCore::HTTPHeaderMap>();
    auto requestHeaderBytesSent = decoder.decode<uint64_t>();
    auto responseHeaderBytesReceived = decoder.decode<uint64_t>();
    auto requestBodyBytesSent = decoder.decode<uint64_t>();
    auto isProxyConnection = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::AdditionalNetworkLoadMetricsForWebInspector::create(
            WTFMove(*priority),
            WTFMove(*remoteAddress),
            WTFMove(*connectionIdentifier),
            WTFMove(*tlsProtocol),
            WTFMove(*tlsCipher),
            WTFMove(*requestHeaders),
            WTFMove(*requestHeaderBytesSent),
            WTFMove(*responseHeaderBytesReceived),
            WTFMove(*requestBodyBytesSent),
            WTFMove(*isProxyConnection)
        )
    };
}

void ArgumentCoder<WebCore::DisplayUpdate>::encode(Encoder& encoder, const WebCore::DisplayUpdate& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.updateIndex)>, unsigned>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.updatesPerSecond)>, WebCore::FramesPerSecond>);
    struct ShouldBeSameSizeAsDisplayUpdate : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::DisplayUpdate>, false> {
        unsigned updateIndex;
        WebCore::FramesPerSecond updatesPerSecond;
    };
    static_assert(sizeof(ShouldBeSameSizeAsDisplayUpdate) == sizeof(WebCore::DisplayUpdate));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::DisplayUpdate, updateIndex)
        , offsetof(WebCore::DisplayUpdate, updatesPerSecond)
    >::value);

    encoder << instance.updateIndex;
    encoder << instance.updatesPerSecond;
}

std::optional<WebCore::DisplayUpdate> ArgumentCoder<WebCore::DisplayUpdate>::decode(Decoder& decoder)
{
    auto updateIndex = decoder.decode<unsigned>();
    auto updatesPerSecond = decoder.decode<WebCore::FramesPerSecond>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DisplayUpdate {
            WTFMove(*updateIndex),
            WTFMove(*updatesPerSecond)
        }
    };
}

void ArgumentCoder<WebCore::MediaUsageInfo>::encode(Encoder& encoder, const WebCore::MediaUsageInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasSource)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isPlaying)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.canShowControlsManager)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.canShowNowPlayingControls)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isSuspended)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isInActiveDocument)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isFullscreen)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isMuted)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isMediaDocumentInMainFrame)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isVideo)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isAudio)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasVideo)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasAudio)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasRenderer)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.audioElementWithUserGesture)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.userHasPlayedAudioBefore)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isElementRectMostlyInMainFrame)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.playbackPermitted)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pageMediaPlaybackSuspended)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isMediaDocumentAndNotOwnerElement)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pageExplicitlyAllowsElementToAutoplayInline)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requiresFullscreenForVideoPlaybackAndFullscreenNotPermitted)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isVideoAndRequiresUserGestureForVideoRateChange)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isAudioAndRequiresUserGestureForAudioRateChange)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isVideoAndRequiresUserGestureForVideoDueToLowPowerMode)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isVideoAndRequiresUserGestureForVideoDueToAggressiveThermalMitigation)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.noUserGestureRequired)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requiresPlaybackAndIsNotPlaying)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasEverNotifiedAboutPlaying)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.outsideOfFullscreen)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isLargeEnoughForMainContent)>, bool>);
#if PLATFORM(COCOA) && !HAVE(CGS_FIX_FOR_RADAR_97530095)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isInViewport)>, bool>);
#endif
    struct ShouldBeSameSizeAsMediaUsageInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MediaUsageInfo>, false> {
        URL mediaURL;
        bool hasSource;
        bool isPlaying;
        bool canShowControlsManager;
        bool canShowNowPlayingControls;
        bool isSuspended;
        bool isInActiveDocument;
        bool isFullscreen;
        bool isMuted;
        bool isMediaDocumentInMainFrame;
        bool isVideo;
        bool isAudio;
        bool hasVideo;
        bool hasAudio;
        bool hasRenderer;
        bool audioElementWithUserGesture;
        bool userHasPlayedAudioBefore;
        bool isElementRectMostlyInMainFrame;
        bool playbackPermitted;
        bool pageMediaPlaybackSuspended;
        bool isMediaDocumentAndNotOwnerElement;
        bool pageExplicitlyAllowsElementToAutoplayInline;
        bool requiresFullscreenForVideoPlaybackAndFullscreenNotPermitted;
        bool isVideoAndRequiresUserGestureForVideoRateChange;
        bool isAudioAndRequiresUserGestureForAudioRateChange;
        bool isVideoAndRequiresUserGestureForVideoDueToLowPowerMode;
        bool isVideoAndRequiresUserGestureForVideoDueToAggressiveThermalMitigation;
        bool noUserGestureRequired;
        bool requiresPlaybackAndIsNotPlaying;
        bool hasEverNotifiedAboutPlaying;
        bool outsideOfFullscreen;
        bool isLargeEnoughForMainContent;
#if PLATFORM(COCOA) && !HAVE(CGS_FIX_FOR_RADAR_97530095)
        bool isInViewport;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsMediaUsageInfo) == sizeof(WebCore::MediaUsageInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MediaUsageInfo, mediaURL)
        , offsetof(WebCore::MediaUsageInfo, hasSource)
        , offsetof(WebCore::MediaUsageInfo, isPlaying)
        , offsetof(WebCore::MediaUsageInfo, canShowControlsManager)
        , offsetof(WebCore::MediaUsageInfo, canShowNowPlayingControls)
        , offsetof(WebCore::MediaUsageInfo, isSuspended)
        , offsetof(WebCore::MediaUsageInfo, isInActiveDocument)
        , offsetof(WebCore::MediaUsageInfo, isFullscreen)
        , offsetof(WebCore::MediaUsageInfo, isMuted)
        , offsetof(WebCore::MediaUsageInfo, isMediaDocumentInMainFrame)
        , offsetof(WebCore::MediaUsageInfo, isVideo)
        , offsetof(WebCore::MediaUsageInfo, isAudio)
        , offsetof(WebCore::MediaUsageInfo, hasVideo)
        , offsetof(WebCore::MediaUsageInfo, hasAudio)
        , offsetof(WebCore::MediaUsageInfo, hasRenderer)
        , offsetof(WebCore::MediaUsageInfo, audioElementWithUserGesture)
        , offsetof(WebCore::MediaUsageInfo, userHasPlayedAudioBefore)
        , offsetof(WebCore::MediaUsageInfo, isElementRectMostlyInMainFrame)
        , offsetof(WebCore::MediaUsageInfo, playbackPermitted)
        , offsetof(WebCore::MediaUsageInfo, pageMediaPlaybackSuspended)
        , offsetof(WebCore::MediaUsageInfo, isMediaDocumentAndNotOwnerElement)
        , offsetof(WebCore::MediaUsageInfo, pageExplicitlyAllowsElementToAutoplayInline)
        , offsetof(WebCore::MediaUsageInfo, requiresFullscreenForVideoPlaybackAndFullscreenNotPermitted)
        , offsetof(WebCore::MediaUsageInfo, isVideoAndRequiresUserGestureForVideoRateChange)
        , offsetof(WebCore::MediaUsageInfo, isAudioAndRequiresUserGestureForAudioRateChange)
        , offsetof(WebCore::MediaUsageInfo, isVideoAndRequiresUserGestureForVideoDueToLowPowerMode)
        , offsetof(WebCore::MediaUsageInfo, isVideoAndRequiresUserGestureForVideoDueToAggressiveThermalMitigation)
        , offsetof(WebCore::MediaUsageInfo, noUserGestureRequired)
        , offsetof(WebCore::MediaUsageInfo, requiresPlaybackAndIsNotPlaying)
        , offsetof(WebCore::MediaUsageInfo, hasEverNotifiedAboutPlaying)
        , offsetof(WebCore::MediaUsageInfo, outsideOfFullscreen)
        , offsetof(WebCore::MediaUsageInfo, isLargeEnoughForMainContent)
#if PLATFORM(COCOA) && !HAVE(CGS_FIX_FOR_RADAR_97530095)
        , offsetof(WebCore::MediaUsageInfo, isInViewport)
#endif
    >::value);

    encoder << instance.mediaURL;
    encoder << instance.hasSource;
    encoder << instance.isPlaying;
    encoder << instance.canShowControlsManager;
    encoder << instance.canShowNowPlayingControls;
    encoder << instance.isSuspended;
    encoder << instance.isInActiveDocument;
    encoder << instance.isFullscreen;
    encoder << instance.isMuted;
    encoder << instance.isMediaDocumentInMainFrame;
    encoder << instance.isVideo;
    encoder << instance.isAudio;
    encoder << instance.hasVideo;
    encoder << instance.hasAudio;
    encoder << instance.hasRenderer;
    encoder << instance.audioElementWithUserGesture;
    encoder << instance.userHasPlayedAudioBefore;
    encoder << instance.isElementRectMostlyInMainFrame;
    encoder << instance.playbackPermitted;
    encoder << instance.pageMediaPlaybackSuspended;
    encoder << instance.isMediaDocumentAndNotOwnerElement;
    encoder << instance.pageExplicitlyAllowsElementToAutoplayInline;
    encoder << instance.requiresFullscreenForVideoPlaybackAndFullscreenNotPermitted;
    encoder << instance.isVideoAndRequiresUserGestureForVideoRateChange;
    encoder << instance.isAudioAndRequiresUserGestureForAudioRateChange;
    encoder << instance.isVideoAndRequiresUserGestureForVideoDueToLowPowerMode;
    encoder << instance.isVideoAndRequiresUserGestureForVideoDueToAggressiveThermalMitigation;
    encoder << instance.noUserGestureRequired;
    encoder << instance.requiresPlaybackAndIsNotPlaying;
    encoder << instance.hasEverNotifiedAboutPlaying;
    encoder << instance.outsideOfFullscreen;
    encoder << instance.isLargeEnoughForMainContent;
#if PLATFORM(COCOA) && !HAVE(CGS_FIX_FOR_RADAR_97530095)
    encoder << instance.isInViewport;
#endif
}

std::optional<WebCore::MediaUsageInfo> ArgumentCoder<WebCore::MediaUsageInfo>::decode(Decoder& decoder)
{
    auto mediaURL = decoder.decode<URL>();
    auto hasSource = decoder.decode<bool>();
    auto isPlaying = decoder.decode<bool>();
    auto canShowControlsManager = decoder.decode<bool>();
    auto canShowNowPlayingControls = decoder.decode<bool>();
    auto isSuspended = decoder.decode<bool>();
    auto isInActiveDocument = decoder.decode<bool>();
    auto isFullscreen = decoder.decode<bool>();
    auto isMuted = decoder.decode<bool>();
    auto isMediaDocumentInMainFrame = decoder.decode<bool>();
    auto isVideo = decoder.decode<bool>();
    auto isAudio = decoder.decode<bool>();
    auto hasVideo = decoder.decode<bool>();
    auto hasAudio = decoder.decode<bool>();
    auto hasRenderer = decoder.decode<bool>();
    auto audioElementWithUserGesture = decoder.decode<bool>();
    auto userHasPlayedAudioBefore = decoder.decode<bool>();
    auto isElementRectMostlyInMainFrame = decoder.decode<bool>();
    auto playbackPermitted = decoder.decode<bool>();
    auto pageMediaPlaybackSuspended = decoder.decode<bool>();
    auto isMediaDocumentAndNotOwnerElement = decoder.decode<bool>();
    auto pageExplicitlyAllowsElementToAutoplayInline = decoder.decode<bool>();
    auto requiresFullscreenForVideoPlaybackAndFullscreenNotPermitted = decoder.decode<bool>();
    auto isVideoAndRequiresUserGestureForVideoRateChange = decoder.decode<bool>();
    auto isAudioAndRequiresUserGestureForAudioRateChange = decoder.decode<bool>();
    auto isVideoAndRequiresUserGestureForVideoDueToLowPowerMode = decoder.decode<bool>();
    auto isVideoAndRequiresUserGestureForVideoDueToAggressiveThermalMitigation = decoder.decode<bool>();
    auto noUserGestureRequired = decoder.decode<bool>();
    auto requiresPlaybackAndIsNotPlaying = decoder.decode<bool>();
    auto hasEverNotifiedAboutPlaying = decoder.decode<bool>();
    auto outsideOfFullscreen = decoder.decode<bool>();
    auto isLargeEnoughForMainContent = decoder.decode<bool>();
#if PLATFORM(COCOA) && !HAVE(CGS_FIX_FOR_RADAR_97530095)
    auto isInViewport = decoder.decode<bool>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MediaUsageInfo {
            WTFMove(*mediaURL),
            WTFMove(*hasSource),
            WTFMove(*isPlaying),
            WTFMove(*canShowControlsManager),
            WTFMove(*canShowNowPlayingControls),
            WTFMove(*isSuspended),
            WTFMove(*isInActiveDocument),
            WTFMove(*isFullscreen),
            WTFMove(*isMuted),
            WTFMove(*isMediaDocumentInMainFrame),
            WTFMove(*isVideo),
            WTFMove(*isAudio),
            WTFMove(*hasVideo),
            WTFMove(*hasAudio),
            WTFMove(*hasRenderer),
            WTFMove(*audioElementWithUserGesture),
            WTFMove(*userHasPlayedAudioBefore),
            WTFMove(*isElementRectMostlyInMainFrame),
            WTFMove(*playbackPermitted),
            WTFMove(*pageMediaPlaybackSuspended),
            WTFMove(*isMediaDocumentAndNotOwnerElement),
            WTFMove(*pageExplicitlyAllowsElementToAutoplayInline),
            WTFMove(*requiresFullscreenForVideoPlaybackAndFullscreenNotPermitted),
            WTFMove(*isVideoAndRequiresUserGestureForVideoRateChange),
            WTFMove(*isAudioAndRequiresUserGestureForAudioRateChange),
            WTFMove(*isVideoAndRequiresUserGestureForVideoDueToLowPowerMode),
            WTFMove(*isVideoAndRequiresUserGestureForVideoDueToAggressiveThermalMitigation),
            WTFMove(*noUserGestureRequired),
            WTFMove(*requiresPlaybackAndIsNotPlaying),
            WTFMove(*hasEverNotifiedAboutPlaying),
            WTFMove(*outsideOfFullscreen),
            WTFMove(*isLargeEnoughForMainContent),
#if PLATFORM(COCOA) && !HAVE(CGS_FIX_FOR_RADAR_97530095)
            WTFMove(*isInViewport)
#endif
        }
    };
}

void ArgumentCoder<WebCore::NowPlayingInfoArtwork>::encode(Encoder& encoder, const WebCore::NowPlayingInfoArtwork& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.src)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mimeType)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.image)>, RefPtr<WebCore::Image>>);
    struct ShouldBeSameSizeAsNowPlayingInfoArtwork : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::NowPlayingInfoArtwork>, false> {
        String src;
        String mimeType;
        RefPtr<WebCore::Image> image;
    };
    static_assert(sizeof(ShouldBeSameSizeAsNowPlayingInfoArtwork) == sizeof(WebCore::NowPlayingInfoArtwork));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::NowPlayingInfoArtwork, src)
        , offsetof(WebCore::NowPlayingInfoArtwork, mimeType)
        , offsetof(WebCore::NowPlayingInfoArtwork, image)
    >::value);

    encoder << instance.src;
    encoder << instance.mimeType;
    encoder << instance.image;
}

std::optional<WebCore::NowPlayingInfoArtwork> ArgumentCoder<WebCore::NowPlayingInfoArtwork>::decode(Decoder& decoder)
{
    auto src = decoder.decode<String>();
    auto mimeType = decoder.decode<String>();
    auto image = decoder.decode<RefPtr<WebCore::Image>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::NowPlayingInfoArtwork {
            WTFMove(*src),
            WTFMove(*mimeType),
            WTFMove(*image)
        }
    };
}

void ArgumentCoder<WebCore::NowPlayingMetadata>::encode(Encoder& encoder, const WebCore::NowPlayingMetadata& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.title)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.artist)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.album)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceApplicationIdentifier)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.artwork)>, std::optional<WebCore::NowPlayingInfoArtwork>>);
    struct ShouldBeSameSizeAsNowPlayingMetadata : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::NowPlayingMetadata>, false> {
        String title;
        String artist;
        String album;
        String sourceApplicationIdentifier;
        std::optional<WebCore::NowPlayingInfoArtwork> artwork;
    };
    static_assert(sizeof(ShouldBeSameSizeAsNowPlayingMetadata) == sizeof(WebCore::NowPlayingMetadata));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::NowPlayingMetadata, title)
        , offsetof(WebCore::NowPlayingMetadata, artist)
        , offsetof(WebCore::NowPlayingMetadata, album)
        , offsetof(WebCore::NowPlayingMetadata, sourceApplicationIdentifier)
        , offsetof(WebCore::NowPlayingMetadata, artwork)
    >::value);

    encoder << instance.title;
    encoder << instance.artist;
    encoder << instance.album;
    encoder << instance.sourceApplicationIdentifier;
    encoder << instance.artwork;
}

std::optional<WebCore::NowPlayingMetadata> ArgumentCoder<WebCore::NowPlayingMetadata>::decode(Decoder& decoder)
{
    auto title = decoder.decode<String>();
    auto artist = decoder.decode<String>();
    auto album = decoder.decode<String>();
    auto sourceApplicationIdentifier = decoder.decode<String>();
    auto artwork = decoder.decode<std::optional<WebCore::NowPlayingInfoArtwork>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::NowPlayingMetadata {
            WTFMove(*title),
            WTFMove(*artist),
            WTFMove(*album),
            WTFMove(*sourceApplicationIdentifier),
            WTFMove(*artwork)
        }
    };
}

void ArgumentCoder<WebCore::NowPlayingInfo>::encode(Encoder& encoder, const WebCore::NowPlayingInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.metadata)>, WebCore::NowPlayingMetadata>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.duration)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.currentTime)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rate)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsSeeking)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.uniqueIdentifier)>, Markable<WebCore::MediaUniqueIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isPlaying)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowsNowPlayingControlsVisibility)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isVideo)>, bool>);
    struct ShouldBeSameSizeAsNowPlayingInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::NowPlayingInfo>, false> {
        WebCore::NowPlayingMetadata metadata;
        double duration;
        double currentTime;
        double rate;
        bool supportsSeeking;
        Markable<WebCore::MediaUniqueIdentifier> uniqueIdentifier;
        bool isPlaying;
        bool allowsNowPlayingControlsVisibility;
        bool isVideo;
    };
    static_assert(sizeof(ShouldBeSameSizeAsNowPlayingInfo) == sizeof(WebCore::NowPlayingInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::NowPlayingInfo, metadata)
        , offsetof(WebCore::NowPlayingInfo, duration)
        , offsetof(WebCore::NowPlayingInfo, currentTime)
        , offsetof(WebCore::NowPlayingInfo, rate)
        , offsetof(WebCore::NowPlayingInfo, supportsSeeking)
        , offsetof(WebCore::NowPlayingInfo, uniqueIdentifier)
        , offsetof(WebCore::NowPlayingInfo, isPlaying)
        , offsetof(WebCore::NowPlayingInfo, allowsNowPlayingControlsVisibility)
        , offsetof(WebCore::NowPlayingInfo, isVideo)
    >::value);

    encoder << instance.metadata;
    encoder << instance.duration;
    encoder << instance.currentTime;
    encoder << instance.rate;
    encoder << instance.supportsSeeking;
    encoder << instance.uniqueIdentifier;
    encoder << instance.isPlaying;
    encoder << instance.allowsNowPlayingControlsVisibility;
    encoder << instance.isVideo;
}

std::optional<WebCore::NowPlayingInfo> ArgumentCoder<WebCore::NowPlayingInfo>::decode(Decoder& decoder)
{
    auto metadata = decoder.decode<WebCore::NowPlayingMetadata>();
    auto duration = decoder.decode<double>();
    auto currentTime = decoder.decode<double>();
    auto rate = decoder.decode<double>();
    auto supportsSeeking = decoder.decode<bool>();
    auto uniqueIdentifier = decoder.decode<Markable<WebCore::MediaUniqueIdentifier>>();
    auto isPlaying = decoder.decode<bool>();
    auto allowsNowPlayingControlsVisibility = decoder.decode<bool>();
    auto isVideo = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::NowPlayingInfo {
            WTFMove(*metadata),
            WTFMove(*duration),
            WTFMove(*currentTime),
            WTFMove(*rate),
            WTFMove(*supportsSeeking),
            WTFMove(*uniqueIdentifier),
            WTFMove(*isPlaying),
            WTFMove(*allowsNowPlayingControlsVisibility),
            WTFMove(*isVideo)
        }
    };
}

void ArgumentCoder<WebCore::VideoConfiguration>::encode(Encoder& encoder, const WebCore::VideoConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentType)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.width)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.height)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bitrate)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.framerate)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.alphaChannel)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorGamut)>, std::optional<WebCore::ColorGamut>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hdrMetadataType)>, std::optional<WebCore::HdrMetadataType>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.transferFunction)>, std::optional<WebCore::TransferFunction>>);
    struct ShouldBeSameSizeAsVideoConfiguration : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::VideoConfiguration>, false> {
        String contentType;
        uint32_t width;
        uint32_t height;
        uint64_t bitrate;
        double framerate;
        std::optional<bool> alphaChannel;
        std::optional<WebCore::ColorGamut> colorGamut;
        std::optional<WebCore::HdrMetadataType> hdrMetadataType;
        std::optional<WebCore::TransferFunction> transferFunction;
    };
    static_assert(sizeof(ShouldBeSameSizeAsVideoConfiguration) == sizeof(WebCore::VideoConfiguration));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::VideoConfiguration, contentType)
        , offsetof(WebCore::VideoConfiguration, width)
        , offsetof(WebCore::VideoConfiguration, height)
        , offsetof(WebCore::VideoConfiguration, bitrate)
        , offsetof(WebCore::VideoConfiguration, framerate)
        , offsetof(WebCore::VideoConfiguration, alphaChannel)
        , offsetof(WebCore::VideoConfiguration, colorGamut)
        , offsetof(WebCore::VideoConfiguration, hdrMetadataType)
        , offsetof(WebCore::VideoConfiguration, transferFunction)
    >::value);

    encoder << instance.contentType;
    encoder << instance.width;
    encoder << instance.height;
    encoder << instance.bitrate;
    encoder << instance.framerate;
    encoder << instance.alphaChannel;
    encoder << instance.colorGamut;
    encoder << instance.hdrMetadataType;
    encoder << instance.transferFunction;
}

std::optional<WebCore::VideoConfiguration> ArgumentCoder<WebCore::VideoConfiguration>::decode(Decoder& decoder)
{
    auto contentType = decoder.decode<String>();
    auto width = decoder.decode<uint32_t>();
    auto height = decoder.decode<uint32_t>();
    auto bitrate = decoder.decode<uint64_t>();
    auto framerate = decoder.decode<double>();
    auto alphaChannel = decoder.decode<std::optional<bool>>();
    auto colorGamut = decoder.decode<std::optional<WebCore::ColorGamut>>();
    auto hdrMetadataType = decoder.decode<std::optional<WebCore::HdrMetadataType>>();
    auto transferFunction = decoder.decode<std::optional<WebCore::TransferFunction>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::VideoConfiguration {
            WTFMove(*contentType),
            WTFMove(*width),
            WTFMove(*height),
            WTFMove(*bitrate),
            WTFMove(*framerate),
            WTFMove(*alphaChannel),
            WTFMove(*colorGamut),
            WTFMove(*hdrMetadataType),
            WTFMove(*transferFunction)
        }
    };
}

void ArgumentCoder<WebCore::FloatFontTaggedSetting>::encode(Encoder& encoder, const WebCore::FloatFontTaggedSetting& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_tag)>, WebCore::FontTag>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_value)>, float>);
    struct ShouldBeSameSizeAsFloatFontTaggedSetting : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FloatFontTaggedSetting>, false> {
        WebCore::FontTag m_tag;
        float m_value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFloatFontTaggedSetting) == sizeof(WebCore::FloatFontTaggedSetting));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FloatFontTaggedSetting, m_tag)
        , offsetof(WebCore::FloatFontTaggedSetting, m_value)
    >::value);

    encoder << instance.m_tag;
    encoder << instance.m_value;
}

std::optional<WebCore::FloatFontTaggedSetting> ArgumentCoder<WebCore::FloatFontTaggedSetting>::decode(Decoder& decoder)
{
    auto m_tag = decoder.decode<WebCore::FontTag>();
    auto m_value = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FloatFontTaggedSetting {
            WTFMove(*m_tag),
            WTFMove(*m_value)
        }
    };
}

void ArgumentCoder<WebCore::IntFontTaggedSetting>::encode(Encoder& encoder, const WebCore::IntFontTaggedSetting& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_tag)>, WebCore::FontTag>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_value)>, int>);
    struct ShouldBeSameSizeAsIntFontTaggedSetting : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::IntFontTaggedSetting>, false> {
        WebCore::FontTag m_tag;
        int m_value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsIntFontTaggedSetting) == sizeof(WebCore::IntFontTaggedSetting));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::IntFontTaggedSetting, m_tag)
        , offsetof(WebCore::IntFontTaggedSetting, m_value)
    >::value);

    encoder << instance.m_tag;
    encoder << instance.m_value;
}

std::optional<WebCore::IntFontTaggedSetting> ArgumentCoder<WebCore::IntFontTaggedSetting>::decode(Decoder& decoder)
{
    auto m_tag = decoder.decode<WebCore::FontTag>();
    auto m_value = decoder.decode<int>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::IntFontTaggedSetting {
            WTFMove(*m_tag),
            WTFMove(*m_value)
        }
    };
}

void ArgumentCoder<WebCore::FontVariationSettings>::encode(Encoder& encoder, const WebCore::FontVariationSettings& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_list)>, Vector<WebCore::FloatFontTaggedSetting>>);
    struct ShouldBeSameSizeAsFontVariationSettings : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FontVariationSettings>, false> {
        Vector<WebCore::FloatFontTaggedSetting> m_list;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFontVariationSettings) == sizeof(WebCore::FontVariationSettings));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FontVariationSettings, m_list)
    >::value);

    encoder << instance.m_list;
}

std::optional<WebCore::FontVariationSettings> ArgumentCoder<WebCore::FontVariationSettings>::decode(Decoder& decoder)
{
    auto m_list = decoder.decode<Vector<WebCore::FloatFontTaggedSetting>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    WebCore::FontVariationSettings result;
    result.m_list = WTFMove(*m_list);
    return { WTFMove(result) };
}

void ArgumentCoder<WebCore::FontFeatureSettings>::encode(Encoder& encoder, const WebCore::FontFeatureSettings& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_list)>, Vector<WebCore::IntFontTaggedSetting>>);
    struct ShouldBeSameSizeAsFontFeatureSettings : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FontFeatureSettings>, false> {
        Vector<WebCore::IntFontTaggedSetting> m_list;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFontFeatureSettings) == sizeof(WebCore::FontFeatureSettings));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FontFeatureSettings, m_list)
    >::value);

    encoder << instance.m_list;
}

std::optional<WebCore::FontFeatureSettings> ArgumentCoder<WebCore::FontFeatureSettings>::decode(Decoder& decoder)
{
    auto m_list = decoder.decode<Vector<WebCore::IntFontTaggedSetting>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    WebCore::FontFeatureSettings result;
    result.m_list = WTFMove(*m_list);
    return { WTFMove(result) };
}

void ArgumentCoder<WebCore::UserScript>::encode(Encoder& encoder, const WebCore::UserScript& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.source())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url())>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowlist())>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.blocklist())>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.injectionTime())>, WebCore::UserScriptInjectionTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.injectedFrames())>, WebCore::UserContentInjectedFrames>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.matchParentFrame())>, WebCore::UserContentMatchParentFrame>);

    encoder << instance.source();
    encoder << instance.url();
    encoder << instance.allowlist();
    encoder << instance.blocklist();
    encoder << instance.injectionTime();
    encoder << instance.injectedFrames();
    encoder << instance.matchParentFrame();
}

std::optional<WebCore::UserScript> ArgumentCoder<WebCore::UserScript>::decode(Decoder& decoder)
{
    bool addedDecodingFailureIndex = false;
    auto source = decoder.decode<String>();
    if (!source && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(0);
        addedDecodingFailureIndex = true;
    }
    auto url = decoder.decode<URL>();
    if (!url && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(1);
        addedDecodingFailureIndex = true;
    }
    auto allowlist = decoder.decode<Vector<String>>();
    if (!allowlist && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(2);
        addedDecodingFailureIndex = true;
    }
    auto blocklist = decoder.decode<Vector<String>>();
    if (!blocklist && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(3);
        addedDecodingFailureIndex = true;
    }
    auto injectionTime = decoder.decode<WebCore::UserScriptInjectionTime>();
    if (!injectionTime && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(4);
        addedDecodingFailureIndex = true;
    }
    auto injectedFrames = decoder.decode<WebCore::UserContentInjectedFrames>();
    if (!injectedFrames && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(5);
        addedDecodingFailureIndex = true;
    }
    auto matchParentFrame = decoder.decode<WebCore::UserContentMatchParentFrame>();
    if (!matchParentFrame && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(6);
        addedDecodingFailureIndex = true;
    }
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::UserScript {
            WTFMove(*source),
            WTFMove(*url),
            WTFMove(*allowlist),
            WTFMove(*blocklist),
            WTFMove(*injectionTime),
            WTFMove(*injectedFrames),
            WTFMove(*matchParentFrame)
        }
    };
}

void ArgumentCoder<WebCore::ContentSecurityPolicyResponseHeaders>::encode(Encoder& encoder, const WebCore::ContentSecurityPolicyResponseHeaders& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.headers())>, Vector<std::pair<String, WebCore::ContentSecurityPolicyHeaderType>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.httpStatusCode())>, int>);

    encoder << instance.headers();
    encoder << instance.httpStatusCode();
}

std::optional<WebCore::ContentSecurityPolicyResponseHeaders> ArgumentCoder<WebCore::ContentSecurityPolicyResponseHeaders>::decode(Decoder& decoder)
{
    auto headers = decoder.decode<Vector<std::pair<String, WebCore::ContentSecurityPolicyHeaderType>>>();
    auto httpStatusCode = decoder.decode<int>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ContentSecurityPolicyResponseHeaders {
            WTFMove(*headers),
            WTFMove(*httpStatusCode)
        }
    };
}

void ArgumentCoder<WebCore::DragImage>::encode(Encoder& encoder, const WebCore::DragImage& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.textIndicator())>, RefPtr<WebCore::TextIndicator>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.visiblePath())>, std::optional<WebCore::Path>>);

    encoder << instance.textIndicator();
    encoder << instance.visiblePath();
}

std::optional<WebCore::DragImage> ArgumentCoder<WebCore::DragImage>::decode(Decoder& decoder)
{
    auto textIndicator = decoder.decode<RefPtr<WebCore::TextIndicator>>();
    auto visiblePath = decoder.decode<std::optional<WebCore::Path>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DragImage {
            WTFMove(*textIndicator),
            WTFMove(*visiblePath)
        }
    };
}

void ArgumentCoder<WebCore::DragItem>::encode(Encoder& encoder, const WebCore::DragItem& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.image)>, WebCore::DragImage>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.imageAnchorPoint)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceAction)>, std::optional<WebCore::DragSourceAction>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.eventPositionInContentCoordinates)>, WebCore::IntPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dragLocationInContentCoordinates)>, WebCore::IntPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dragLocationInWindowCoordinates)>, WebCore::IntPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.title)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dragPreviewFrameInRootViewCoordinates)>, WebCore::IntRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.containsSelection)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.promisedAttachmentInfo)>, WebCore::PromisedAttachmentInfo>);
#if ENABLE(MODEL_PROCESS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.modelLayerID)>, Markable<WebCore::PlatformLayerIdentifier>>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data)>, WebCore::PasteboardWriterData>);
    struct ShouldBeSameSizeAsDragItem : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::DragItem>, false> {
        WebCore::DragImage image;
        WebCore::FloatPoint imageAnchorPoint;
        std::optional<WebCore::DragSourceAction> sourceAction;
        WebCore::IntPoint eventPositionInContentCoordinates;
        WebCore::IntPoint dragLocationInContentCoordinates;
        WebCore::IntPoint dragLocationInWindowCoordinates;
        String title;
        URL url;
        WebCore::IntRect dragPreviewFrameInRootViewCoordinates;
        bool containsSelection;
        WebCore::PromisedAttachmentInfo promisedAttachmentInfo;
#if ENABLE(MODEL_PROCESS)
        Markable<WebCore::PlatformLayerIdentifier> modelLayerID;
#endif
        WebCore::PasteboardWriterData data;
    };
    static_assert(sizeof(ShouldBeSameSizeAsDragItem) == sizeof(WebCore::DragItem));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::DragItem, image)
        , offsetof(WebCore::DragItem, imageAnchorPoint)
        , offsetof(WebCore::DragItem, sourceAction)
        , offsetof(WebCore::DragItem, eventPositionInContentCoordinates)
        , offsetof(WebCore::DragItem, dragLocationInContentCoordinates)
        , offsetof(WebCore::DragItem, dragLocationInWindowCoordinates)
        , offsetof(WebCore::DragItem, title)
        , offsetof(WebCore::DragItem, url)
        , offsetof(WebCore::DragItem, dragPreviewFrameInRootViewCoordinates)
        , offsetof(WebCore::DragItem, containsSelection)
        , offsetof(WebCore::DragItem, promisedAttachmentInfo)
#if ENABLE(MODEL_PROCESS)
        , offsetof(WebCore::DragItem, modelLayerID)
#endif
        , offsetof(WebCore::DragItem, data)
    >::value);

    encoder << instance.image;
    encoder << instance.imageAnchorPoint;
    encoder << instance.sourceAction;
    encoder << instance.eventPositionInContentCoordinates;
    encoder << instance.dragLocationInContentCoordinates;
    encoder << instance.dragLocationInWindowCoordinates;
    encoder << instance.title;
    encoder << instance.url;
    encoder << instance.dragPreviewFrameInRootViewCoordinates;
    encoder << instance.containsSelection;
    encoder << instance.promisedAttachmentInfo;
#if ENABLE(MODEL_PROCESS)
    encoder << instance.modelLayerID;
#endif
}

std::optional<WebCore::DragItem> ArgumentCoder<WebCore::DragItem>::decode(Decoder& decoder)
{
    auto image = decoder.decode<WebCore::DragImage>();
    auto imageAnchorPoint = decoder.decode<WebCore::FloatPoint>();
    auto sourceAction = decoder.decode<std::optional<WebCore::DragSourceAction>>();
    auto eventPositionInContentCoordinates = decoder.decode<WebCore::IntPoint>();
    auto dragLocationInContentCoordinates = decoder.decode<WebCore::IntPoint>();
    auto dragLocationInWindowCoordinates = decoder.decode<WebCore::IntPoint>();
    auto title = decoder.decode<String>();
    auto url = decoder.decode<URL>();
    auto dragPreviewFrameInRootViewCoordinates = decoder.decode<WebCore::IntRect>();
    auto containsSelection = decoder.decode<bool>();
    auto promisedAttachmentInfo = decoder.decode<WebCore::PromisedAttachmentInfo>();
#if ENABLE(MODEL_PROCESS)
    auto modelLayerID = decoder.decode<Markable<WebCore::PlatformLayerIdentifier>>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DragItem {
            WTFMove(*image),
            WTFMove(*imageAnchorPoint),
            WTFMove(*sourceAction),
            WTFMove(*eventPositionInContentCoordinates),
            WTFMove(*dragLocationInContentCoordinates),
            WTFMove(*dragLocationInWindowCoordinates),
            WTFMove(*title),
            WTFMove(*url),
            WTFMove(*dragPreviewFrameInRootViewCoordinates),
            WTFMove(*containsSelection),
            WTFMove(*promisedAttachmentInfo),
#if ENABLE(MODEL_PROCESS)
            WTFMove(*modelLayerID)
#endif
        }
    };
}

#if PLATFORM(COCOA)
void ArgumentCoder<WebCore::KeypressCommand>::encode(Encoder& encoder, const WebCore::KeypressCommand& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.commandName)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.text)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.underlines)>, Vector<WebCore::CompositionUnderline>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.highlights)>, Vector<WebCore::CompositionHighlight>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selectedRange)>, WebCore::CharacterRange>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.replacementRange)>, WebCore::CharacterRange>);
    struct ShouldBeSameSizeAsKeypressCommand : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::KeypressCommand>, false> {
        String commandName;
        String text;
        Vector<WebCore::CompositionUnderline> underlines;
        Vector<WebCore::CompositionHighlight> highlights;
        WebCore::CharacterRange selectedRange;
        WebCore::CharacterRange replacementRange;
    };
    static_assert(sizeof(ShouldBeSameSizeAsKeypressCommand) == sizeof(WebCore::KeypressCommand));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::KeypressCommand, commandName)
        , offsetof(WebCore::KeypressCommand, text)
        , offsetof(WebCore::KeypressCommand, underlines)
        , offsetof(WebCore::KeypressCommand, highlights)
        , offsetof(WebCore::KeypressCommand, selectedRange)
        , offsetof(WebCore::KeypressCommand, replacementRange)
    >::value);

    encoder << instance.commandName;
    encoder << instance.text;
    encoder << instance.underlines;
    encoder << instance.highlights;
    encoder << instance.selectedRange;
    encoder << instance.replacementRange;
}

std::optional<WebCore::KeypressCommand> ArgumentCoder<WebCore::KeypressCommand>::decode(Decoder& decoder)
{
    auto commandName = decoder.decode<String>();
    auto text = decoder.decode<String>();
    auto underlines = decoder.decode<Vector<WebCore::CompositionUnderline>>();
    auto highlights = decoder.decode<Vector<WebCore::CompositionHighlight>>();
    auto selectedRange = decoder.decode<WebCore::CharacterRange>();
    auto replacementRange = decoder.decode<WebCore::CharacterRange>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::KeypressCommand {
            WTFMove(*commandName),
            WTFMove(*text),
            WTFMove(*underlines),
            WTFMove(*highlights),
            WTFMove(*selectedRange),
            WTFMove(*replacementRange)
        }
    };
}

#endif

#if !USE(COORDINATED_GRAPHICS)
void ArgumentCoder<WebCore::FilterOperations>::encode(Encoder& encoder, const WebCore::FilterOperations& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_operations)>, Vector<Ref<WebCore::FilterOperation>>>);
    struct ShouldBeSameSizeAsFilterOperations : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FilterOperations>, false> {
        Vector<Ref<WebCore::FilterOperation>> m_operations;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFilterOperations) == sizeof(WebCore::FilterOperations));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FilterOperations, m_operations)
    >::value);

    encoder << instance.m_operations;
}

std::optional<WebCore::FilterOperations> ArgumentCoder<WebCore::FilterOperations>::decode(Decoder& decoder)
{
    auto m_operations = decoder.decode<Vector<Ref<WebCore::FilterOperation>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FilterOperations {
            WTFMove(*m_operations)
        }
    };
}

#endif

enum class WebCore_Filter_Subclass : IPC::EncodedVariantIndex {
    CSSFilter
    , SVGFilter
};

IGNORE_WARNINGS_BEGIN("missing-noreturn")
void ArgumentCoder<WebCore::Filter>::encode(Encoder& encoder, const WebCore::Filter& instance)
{
    if (auto* subclass = dynamicDowncast<WebCore::CSSFilter>(instance)) {
        encoder << WebCore_Filter_Subclass::CSSFilter;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::SVGFilter>(instance)) {
        encoder << WebCore_Filter_Subclass::SVGFilter;
        encoder << *subclass;
        return;
    }
    ASSERT_NOT_REACHED();
}
IGNORE_WARNINGS_END

IGNORE_WARNINGS_BEGIN("missing-noreturn")
void ArgumentCoder<WebCore::Filter>::encode(StreamConnectionEncoder& encoder, const WebCore::Filter& instance)
{
    if (auto* subclass = dynamicDowncast<WebCore::CSSFilter>(instance)) {
        encoder << WebCore_Filter_Subclass::CSSFilter;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::SVGFilter>(instance)) {
        encoder << WebCore_Filter_Subclass::SVGFilter;
        encoder << *subclass;
        return;
    }
    ASSERT_NOT_REACHED();
}
IGNORE_WARNINGS_END

std::optional<Ref<WebCore::Filter>> ArgumentCoder<WebCore::Filter>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore_Filter_Subclass>();
    UNUSED_PARAM(type);
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (type == WebCore_Filter_Subclass::CSSFilter) {
        auto result = decoder.decode<Ref<WebCore::CSSFilter>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_Filter_Subclass::SVGFilter) {
        auto result = decoder.decode<Ref<WebCore::SVGFilter>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    ASSERT_NOT_REACHED();
    return std::nullopt;
}

void ArgumentCoder<WebCore::CSSFilter>::encode(Encoder& encoder, const WebCore::CSSFilter& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.functions())>, Vector<Ref<WebCore::FilterFunction>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.filterRenderingModes())>, OptionSet<WebCore::FilterRenderingMode>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.filterScale())>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.filterRegion())>, WebCore::FloatRect>);

    encoder << instance.functions();
    encoder << instance.filterRenderingModes();
    encoder << instance.filterScale();
    encoder << instance.filterRegion();
}

void ArgumentCoder<WebCore::CSSFilter>::encode(StreamConnectionEncoder& encoder, const WebCore::CSSFilter& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.functions())>, Vector<Ref<WebCore::FilterFunction>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.filterRenderingModes())>, OptionSet<WebCore::FilterRenderingMode>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.filterScale())>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.filterRegion())>, WebCore::FloatRect>);

    encoder << instance.functions();
    encoder << instance.filterRenderingModes();
    encoder << instance.filterScale();
    encoder << instance.filterRegion();
}

std::optional<Ref<WebCore::CSSFilter>> ArgumentCoder<WebCore::CSSFilter>::decode(Decoder& decoder)
{
    auto functions = decoder.decode<Vector<Ref<WebCore::FilterFunction>>>();
    auto filterRenderingModes = decoder.decode<OptionSet<WebCore::FilterRenderingMode>>();
    auto filterScale = decoder.decode<WebCore::FloatSize>();
    auto filterRegion = decoder.decode<WebCore::FloatRect>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CSSFilter::create(
            WTFMove(*functions),
            WTFMove(*filterRenderingModes),
            WTFMove(*filterScale),
            WTFMove(*filterRegion)
        )
    };
}

void ArgumentCoder<WebCore::SVGFilter>::encode(Encoder& encoder, const WebCore::SVGFilter& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.targetBoundingBox())>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.primitiveUnits())>, WebCore::SVGUnitTypes::SVGUnitType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.expression())>, WebCore::SVGFilterExpression>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.effects())>, Vector<Ref<WebCore::FilterEffect>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.renderingResourceIdentifierIfExists())>, std::optional<WebCore::RenderingResourceIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.filterRenderingModes())>, OptionSet<WebCore::FilterRenderingMode>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.filterScale())>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.filterRegion())>, WebCore::FloatRect>);

    encoder << instance.targetBoundingBox();
    encoder << instance.primitiveUnits();
    encoder << instance.expression();
    encoder << instance.effects();
    encoder << instance.renderingResourceIdentifierIfExists();
    encoder << instance.filterRenderingModes();
    encoder << instance.filterScale();
    encoder << instance.filterRegion();
}

void ArgumentCoder<WebCore::SVGFilter>::encode(StreamConnectionEncoder& encoder, const WebCore::SVGFilter& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.targetBoundingBox())>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.primitiveUnits())>, WebCore::SVGUnitTypes::SVGUnitType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.expression())>, WebCore::SVGFilterExpression>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.effects())>, Vector<Ref<WebCore::FilterEffect>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.renderingResourceIdentifierIfExists())>, std::optional<WebCore::RenderingResourceIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.filterRenderingModes())>, OptionSet<WebCore::FilterRenderingMode>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.filterScale())>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.filterRegion())>, WebCore::FloatRect>);

    encoder << instance.targetBoundingBox();
    encoder << instance.primitiveUnits();
    encoder << instance.expression();
    encoder << instance.effects();
    encoder << instance.renderingResourceIdentifierIfExists();
    encoder << instance.filterRenderingModes();
    encoder << instance.filterScale();
    encoder << instance.filterRegion();
}

std::optional<Ref<WebCore::SVGFilter>> ArgumentCoder<WebCore::SVGFilter>::decode(Decoder& decoder)
{
    auto targetBoundingBox = decoder.decode<WebCore::FloatRect>();
    auto primitiveUnits = decoder.decode<WebCore::SVGUnitTypes::SVGUnitType>();
    auto expression = decoder.decode<WebCore::SVGFilterExpression>();
    auto effects = decoder.decode<Vector<Ref<WebCore::FilterEffect>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(WebCore::SVGFilter::isValidSVGFilterExpression(*expression, *effects)))
        return std::nullopt;
    auto renderingResourceIdentifierIfExists = decoder.decode<std::optional<WebCore::RenderingResourceIdentifier>>();
    auto filterRenderingModes = decoder.decode<OptionSet<WebCore::FilterRenderingMode>>();
    auto filterScale = decoder.decode<WebCore::FloatSize>();
    auto filterRegion = decoder.decode<WebCore::FloatRect>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SVGFilter::create(
            WTFMove(*targetBoundingBox),
            WTFMove(*primitiveUnits),
            WTFMove(*expression),
            WTFMove(*effects),
            WTFMove(*renderingResourceIdentifierIfExists),
            WTFMove(*filterRenderingModes),
            WTFMove(*filterScale),
            WTFMove(*filterRegion)
        )
    };
}

void ArgumentCoder<WebCore::ByteArrayPixelBuffer>::encode(Encoder& encoder, const WebCore::ByteArrayPixelBuffer& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.format())>, WebCore::PixelBufferFormat>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size())>, WebCore::IntSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.span())>, std::span<const uint8_t>>);

    encoder << instance.format();
    encoder << instance.size();
    encoder << instance.span();
}

void ArgumentCoder<WebCore::ByteArrayPixelBuffer>::encode(StreamConnectionEncoder& encoder, const WebCore::ByteArrayPixelBuffer& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.format())>, WebCore::PixelBufferFormat>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size())>, WebCore::IntSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.span())>, std::span<const uint8_t>>);

    encoder << instance.format();
    encoder << instance.size();
    encoder << instance.span();
}

std::optional<Ref<WebCore::ByteArrayPixelBuffer>> ArgumentCoder<WebCore::ByteArrayPixelBuffer>::decode(Decoder& decoder)
{
    auto format = decoder.decode<WebCore::PixelBufferFormat>();
    auto size = decoder.decode<WebCore::IntSize>();
    auto span = decoder.decode<std::span<const uint8_t>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ByteArrayPixelBuffer::create(
            WTFMove(*format),
            WTFMove(*size),
            WTFMove(*span)
        )
    };
}

void ArgumentCoder<WebCore::PixelBufferSourceView>::encode(Encoder& encoder, const WebCore::PixelBufferSourceView& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.format())>, WebCore::PixelBufferFormat>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size())>, WebCore::IntSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bytes())>, std::span<const uint8_t>>);

    encoder << instance.format();
    encoder << instance.size();
    encoder << instance.bytes();
}

void ArgumentCoder<WebCore::PixelBufferSourceView>::encode(StreamConnectionEncoder& encoder, const WebCore::PixelBufferSourceView& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.format())>, WebCore::PixelBufferFormat>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size())>, WebCore::IntSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bytes())>, std::span<const uint8_t>>);

    encoder << instance.format();
    encoder << instance.size();
    encoder << instance.bytes();
}

std::optional<WebCore::PixelBufferSourceView> ArgumentCoder<WebCore::PixelBufferSourceView>::decode(Decoder& decoder)
{
    auto format = decoder.decode<WebCore::PixelBufferFormat>();
    auto size = decoder.decode<WebCore::IntSize>();
    auto bytes = decoder.decode<std::span<const uint8_t>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PixelBufferSourceView::create(
            WTFMove(*format),
            WTFMove(*size),
            WTFMove(*bytes)
        )
    };
}

void ArgumentCoder<WebCore::MarkupExclusionRule>::encode(Encoder& encoder, const WebCore::MarkupExclusionRule& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.elementLocalName)>, AtomString>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.attributes)>, Vector<std::pair<AtomString, AtomString>>>);
    struct ShouldBeSameSizeAsMarkupExclusionRule : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MarkupExclusionRule>, false> {
        AtomString elementLocalName;
        Vector<std::pair<AtomString, AtomString>> attributes;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMarkupExclusionRule) == sizeof(WebCore::MarkupExclusionRule));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MarkupExclusionRule, elementLocalName)
        , offsetof(WebCore::MarkupExclusionRule, attributes)
    >::value);

    encoder << instance.elementLocalName;
    encoder << instance.attributes;
}

std::optional<WebCore::MarkupExclusionRule> ArgumentCoder<WebCore::MarkupExclusionRule>::decode(Decoder& decoder)
{
    auto elementLocalName = decoder.decode<AtomString>();
    auto attributes = decoder.decode<Vector<std::pair<AtomString, AtomString>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MarkupExclusionRule {
            WTFMove(*elementLocalName),
            WTFMove(*attributes)
        }
    };
}

enum class WebCore_SystemImage_Subclass : IPC::EncodedVariantIndex {
#if ENABLE(APPLE_PAY)
    ApplePayLogoSystemImage
#endif
#if USE(SYSTEM_PREVIEW)
    , ARKitBadgeSystemImage
#endif
#if USE(APPKIT)
    , AppKitControlSystemImage
#endif
};

IGNORE_WARNINGS_BEGIN("missing-noreturn")
void ArgumentCoder<WebCore::SystemImage>::encode(Encoder& encoder, const WebCore::SystemImage& instance)
{
#if ENABLE(APPLE_PAY)
    if (auto* subclass = dynamicDowncast<WebCore::ApplePayLogoSystemImage>(instance)) {
        encoder << WebCore_SystemImage_Subclass::ApplePayLogoSystemImage;
        encoder << *subclass;
        return;
    }
#endif
#if USE(SYSTEM_PREVIEW)
    if (auto* subclass = dynamicDowncast<WebCore::ARKitBadgeSystemImage>(instance)) {
        encoder << WebCore_SystemImage_Subclass::ARKitBadgeSystemImage;
        encoder << *subclass;
        return;
    }
#endif
#if USE(APPKIT)
    if (auto* subclass = dynamicDowncast<WebCore::AppKitControlSystemImage>(instance)) {
        encoder << WebCore_SystemImage_Subclass::AppKitControlSystemImage;
        encoder << *subclass;
        return;
    }
#endif
    ASSERT_NOT_REACHED();
}
IGNORE_WARNINGS_END

IGNORE_WARNINGS_BEGIN("missing-noreturn")
void ArgumentCoder<WebCore::SystemImage>::encode(StreamConnectionEncoder& encoder, const WebCore::SystemImage& instance)
{
#if ENABLE(APPLE_PAY)
    if (auto* subclass = dynamicDowncast<WebCore::ApplePayLogoSystemImage>(instance)) {
        encoder << WebCore_SystemImage_Subclass::ApplePayLogoSystemImage;
        encoder << *subclass;
        return;
    }
#endif
#if USE(SYSTEM_PREVIEW)
    if (auto* subclass = dynamicDowncast<WebCore::ARKitBadgeSystemImage>(instance)) {
        encoder << WebCore_SystemImage_Subclass::ARKitBadgeSystemImage;
        encoder << *subclass;
        return;
    }
#endif
#if USE(APPKIT)
    if (auto* subclass = dynamicDowncast<WebCore::AppKitControlSystemImage>(instance)) {
        encoder << WebCore_SystemImage_Subclass::AppKitControlSystemImage;
        encoder << *subclass;
        return;
    }
#endif
    ASSERT_NOT_REACHED();
}
IGNORE_WARNINGS_END

std::optional<Ref<WebCore::SystemImage>> ArgumentCoder<WebCore::SystemImage>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore_SystemImage_Subclass>();
    UNUSED_PARAM(type);
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

#if ENABLE(APPLE_PAY)
    if (type == WebCore_SystemImage_Subclass::ApplePayLogoSystemImage) {
        auto result = decoder.decode<Ref<WebCore::ApplePayLogoSystemImage>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
#endif
#if USE(SYSTEM_PREVIEW)
    if (type == WebCore_SystemImage_Subclass::ARKitBadgeSystemImage) {
        auto result = decoder.decode<Ref<WebCore::ARKitBadgeSystemImage>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
#endif
#if USE(APPKIT)
    if (type == WebCore_SystemImage_Subclass::AppKitControlSystemImage) {
        auto result = decoder.decode<Ref<WebCore::AppKitControlSystemImage>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
#endif
    ASSERT_NOT_REACHED();
    return std::nullopt;
}

#if ENABLE(WEB_CODECS)
void ArgumentCoder<WebCore::WebCodecsEncodedVideoChunkStorage>::encode(Encoder& encoder, const WebCore::WebCodecsEncodedVideoChunkStorage& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data())>, WebCore::WebCodecsEncodedVideoChunkData>);

    encoder << instance.data();
}

std::optional<Ref<WebCore::WebCodecsEncodedVideoChunkStorage>> ArgumentCoder<WebCore::WebCodecsEncodedVideoChunkStorage>::decode(Decoder& decoder)
{
    auto data = decoder.decode<WebCore::WebCodecsEncodedVideoChunkData>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::WebCodecsEncodedVideoChunkStorage::create(
            WTFMove(*data)
        )
    };
}

#endif

#if ENABLE(WEB_CODECS)
void ArgumentCoder<WebCore::WebCodecsEncodedAudioChunkStorage>::encode(Encoder& encoder, const WebCore::WebCodecsEncodedAudioChunkStorage& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data())>, WebCore::WebCodecsEncodedAudioChunkData>);

    encoder << instance.data();
}

std::optional<Ref<WebCore::WebCodecsEncodedAudioChunkStorage>> ArgumentCoder<WebCore::WebCodecsEncodedAudioChunkStorage>::decode(Decoder& decoder)
{
    auto data = decoder.decode<WebCore::WebCodecsEncodedAudioChunkData>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::WebCodecsEncodedAudioChunkStorage::create(
            WTFMove(*data)
        )
    };
}

#endif

void ArgumentCoder<WebCore::SerializedScriptValue::Internals>::encode(Encoder& encoder, const WebCore::SerializedScriptValue::Internals& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data)>, Vector<uint8_t>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.arrayBufferContentsArray)>, std::unique_ptr<Vector<JSC::ArrayBufferContents>>>);
#if ENABLE(WEB_RTC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.detachedRTCDataChannels)>, Vector<std::unique_ptr<WebCore::DetachedRTCDataChannel>>>);
#endif
#if ENABLE(WEB_CODECS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.serializedVideoChunks)>, Vector<RefPtr<WebCore::WebCodecsEncodedVideoChunkStorage>>>);
#endif
#if ENABLE(WEB_CODECS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.serializedAudioChunks)>, Vector<RefPtr<WebCore::WebCodecsEncodedAudioChunkStorage>>>);
#endif
#if ENABLE(WEB_CODECS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.serializedVideoFrames)>, Vector<WebCore::WebCodecsVideoFrameData>>);
#endif
#if ENABLE(WEB_CODECS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.serializedAudioData)>, Vector<WebCore::WebCodecsAudioInternalData>>);
#endif
#if ENABLE(WEB_RTC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.serializedRTCEncodedAudioFrames)>, Vector<RefPtr<WebCore::RTCRtpTransformableFrame>>>);
#endif
#if ENABLE(WEB_RTC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.serializedRTCEncodedVideoFrames)>, Vector<RefPtr<WebCore::RTCRtpTransformableFrame>>>);
#endif
#if ENABLE(MEDIA_SOURCE_IN_WORKERS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.detachedMediaSourceHandles)>, Vector<RefPtr<WebCore::DetachedMediaSourceHandle>>>);
#endif
#if ENABLE(MEDIA_STREAM)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.serializedMediaStreamTracks)>, Vector<std::unique_ptr<WebCore::MediaStreamTrackDataHolder>>>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sharedBufferContentsArray)>, std::unique_ptr<Vector<JSC::ArrayBufferContents>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.detachedImageBitmaps)>, Vector<std::optional<WebCore::DetachedImageBitmap>>>);
#if ENABLE(OFFSCREEN_CANVAS_IN_WORKERS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.detachedOffscreenCanvases)>, Vector<std::unique_ptr<WebCore::DetachedOffscreenCanvas>>>);
#endif
#if ENABLE(OFFSCREEN_CANVAS_IN_WORKERS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.inMemoryOffscreenCanvases)>, Vector<RefPtr<WebCore::OffscreenCanvas>>>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.inMemoryMessagePorts)>, Vector<Ref<WebCore::MessagePort>>>);
#if ENABLE(WEBASSEMBLY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.wasmModulesArray)>, std::unique_ptr<Vector<RefPtr<JSC::Wasm::Module>>>>);
#endif
#if ENABLE(WEBASSEMBLY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.wasmMemoryHandlesArray)>, std::unique_ptr<Vector<RefPtr<JSC::SharedArrayBufferContents>>>>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.blobHandles)>, Vector<WebCore::URLKeepingBlobAlive>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.memoryCost)>, uint64_t>);
    struct ShouldBeSameSizeAsInternals : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SerializedScriptValue::Internals>, false> {
        Vector<uint8_t> data;
        std::unique_ptr<Vector<JSC::ArrayBufferContents>> arrayBufferContentsArray;
#if ENABLE(WEB_RTC)
        Vector<std::unique_ptr<WebCore::DetachedRTCDataChannel>> detachedRTCDataChannels;
#endif
#if ENABLE(WEB_CODECS)
        Vector<RefPtr<WebCore::WebCodecsEncodedVideoChunkStorage>> serializedVideoChunks;
#endif
#if ENABLE(WEB_CODECS)
        Vector<RefPtr<WebCore::WebCodecsEncodedAudioChunkStorage>> serializedAudioChunks;
#endif
#if ENABLE(WEB_CODECS)
        Vector<WebCore::WebCodecsVideoFrameData> serializedVideoFrames;
#endif
#if ENABLE(WEB_CODECS)
        Vector<WebCore::WebCodecsAudioInternalData> serializedAudioData;
#endif
#if ENABLE(WEB_RTC)
        Vector<RefPtr<WebCore::RTCRtpTransformableFrame>> serializedRTCEncodedAudioFrames;
#endif
#if ENABLE(WEB_RTC)
        Vector<RefPtr<WebCore::RTCRtpTransformableFrame>> serializedRTCEncodedVideoFrames;
#endif
#if ENABLE(MEDIA_SOURCE_IN_WORKERS)
        Vector<RefPtr<WebCore::DetachedMediaSourceHandle>> detachedMediaSourceHandles;
#endif
#if ENABLE(MEDIA_STREAM)
        Vector<std::unique_ptr<WebCore::MediaStreamTrackDataHolder>> serializedMediaStreamTracks;
#endif
        std::unique_ptr<Vector<JSC::ArrayBufferContents>> sharedBufferContentsArray;
        Vector<std::optional<WebCore::DetachedImageBitmap>> detachedImageBitmaps;
#if ENABLE(OFFSCREEN_CANVAS_IN_WORKERS)
        Vector<std::unique_ptr<WebCore::DetachedOffscreenCanvas>> detachedOffscreenCanvases;
#endif
#if ENABLE(OFFSCREEN_CANVAS_IN_WORKERS)
        Vector<RefPtr<WebCore::OffscreenCanvas>> inMemoryOffscreenCanvases;
#endif
        Vector<Ref<WebCore::MessagePort>> inMemoryMessagePorts;
#if ENABLE(WEBASSEMBLY)
        std::unique_ptr<Vector<RefPtr<JSC::Wasm::Module>>> wasmModulesArray;
#endif
#if ENABLE(WEBASSEMBLY)
        std::unique_ptr<Vector<RefPtr<JSC::SharedArrayBufferContents>>> wasmMemoryHandlesArray;
#endif
        Vector<WebCore::URLKeepingBlobAlive> blobHandles;
        uint64_t memoryCost;
    };
    static_assert(sizeof(ShouldBeSameSizeAsInternals) == sizeof(WebCore::SerializedScriptValue::Internals));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SerializedScriptValue::Internals, data)
        , offsetof(WebCore::SerializedScriptValue::Internals, arrayBufferContentsArray)
#if ENABLE(WEB_RTC)
        , offsetof(WebCore::SerializedScriptValue::Internals, detachedRTCDataChannels)
#endif
#if ENABLE(WEB_CODECS)
        , offsetof(WebCore::SerializedScriptValue::Internals, serializedVideoChunks)
#endif
#if ENABLE(WEB_CODECS)
        , offsetof(WebCore::SerializedScriptValue::Internals, serializedAudioChunks)
#endif
#if ENABLE(WEB_CODECS)
        , offsetof(WebCore::SerializedScriptValue::Internals, serializedVideoFrames)
#endif
#if ENABLE(WEB_CODECS)
        , offsetof(WebCore::SerializedScriptValue::Internals, serializedAudioData)
#endif
#if ENABLE(WEB_RTC)
        , offsetof(WebCore::SerializedScriptValue::Internals, serializedRTCEncodedAudioFrames)
#endif
#if ENABLE(WEB_RTC)
        , offsetof(WebCore::SerializedScriptValue::Internals, serializedRTCEncodedVideoFrames)
#endif
#if ENABLE(MEDIA_SOURCE_IN_WORKERS)
        , offsetof(WebCore::SerializedScriptValue::Internals, detachedMediaSourceHandles)
#endif
#if ENABLE(MEDIA_STREAM)
        , offsetof(WebCore::SerializedScriptValue::Internals, serializedMediaStreamTracks)
#endif
        , offsetof(WebCore::SerializedScriptValue::Internals, sharedBufferContentsArray)
        , offsetof(WebCore::SerializedScriptValue::Internals, detachedImageBitmaps)
#if ENABLE(OFFSCREEN_CANVAS_IN_WORKERS)
        , offsetof(WebCore::SerializedScriptValue::Internals, detachedOffscreenCanvases)
#endif
#if ENABLE(OFFSCREEN_CANVAS_IN_WORKERS)
        , offsetof(WebCore::SerializedScriptValue::Internals, inMemoryOffscreenCanvases)
#endif
        , offsetof(WebCore::SerializedScriptValue::Internals, inMemoryMessagePorts)
#if ENABLE(WEBASSEMBLY)
        , offsetof(WebCore::SerializedScriptValue::Internals, wasmModulesArray)
#endif
#if ENABLE(WEBASSEMBLY)
        , offsetof(WebCore::SerializedScriptValue::Internals, wasmMemoryHandlesArray)
#endif
        , offsetof(WebCore::SerializedScriptValue::Internals, blobHandles)
        , offsetof(WebCore::SerializedScriptValue::Internals, memoryCost)
    >::value);

    encoder << instance.data;
    encoder << instance.arrayBufferContentsArray;
#if ENABLE(WEB_RTC)
    encoder << instance.detachedRTCDataChannels;
#endif
#if ENABLE(WEB_CODECS)
    encoder << instance.serializedVideoChunks;
#endif
#if ENABLE(WEB_CODECS)
    encoder << instance.serializedAudioChunks;
#endif
}

std::optional<WebCore::SerializedScriptValue::Internals> ArgumentCoder<WebCore::SerializedScriptValue::Internals>::decode(Decoder& decoder)
{
    auto data = decoder.decode<Vector<uint8_t>>();
    auto arrayBufferContentsArray = decoder.decode<std::unique_ptr<Vector<JSC::ArrayBufferContents>>>();
#if ENABLE(WEB_RTC)
    auto detachedRTCDataChannels = decoder.decode<Vector<std::unique_ptr<WebCore::DetachedRTCDataChannel>>>();
#endif
#if ENABLE(WEB_CODECS)
    auto serializedVideoChunks = decoder.decode<Vector<RefPtr<WebCore::WebCodecsEncodedVideoChunkStorage>>>();
#endif
#if ENABLE(WEB_CODECS)
    auto serializedAudioChunks = decoder.decode<Vector<RefPtr<WebCore::WebCodecsEncodedAudioChunkStorage>>>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SerializedScriptValue::Internals {
            WTFMove(*data),
            WTFMove(*arrayBufferContentsArray),
#if ENABLE(WEB_RTC)
            WTFMove(*detachedRTCDataChannels),
#endif
#if ENABLE(WEB_CODECS)
            WTFMove(*serializedVideoChunks),
#endif
#if ENABLE(WEB_CODECS)
            WTFMove(*serializedAudioChunks)
#endif
        }
    };
}

void ArgumentCoder<WebCore::SerializedScriptValue>::encode(Encoder& encoder, const WebCore::SerializedScriptValue& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_internals)>, WebCore::SerializedScriptValue::Internals>);
    struct ShouldBeSameSizeAsSerializedScriptValue : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SerializedScriptValue>, true> {
        WebCore::SerializedScriptValue::Internals m_internals;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSerializedScriptValue) == sizeof(WebCore::SerializedScriptValue));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SerializedScriptValue, m_internals)
    >::value);

    encoder << instance.m_internals;
}

std::optional<Ref<WebCore::SerializedScriptValue>> ArgumentCoder<WebCore::SerializedScriptValue>::decode(Decoder& decoder)
{
    auto m_internals = decoder.decode<WebCore::SerializedScriptValue::Internals>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SerializedScriptValue::create(
            WTFMove(*m_internals)
        )
    };
}

void ArgumentCoder<WebCore::SharedBuffer>::encode(Encoder& encoder, const WebCore::SharedBuffer& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.asFragmentedSharedBuffer())>, Ref<WebCore::FragmentedSharedBuffer>>);

    encoder << instance.asFragmentedSharedBuffer();
}

std::optional<Ref<WebCore::SharedBuffer>> ArgumentCoder<WebCore::SharedBuffer>::decode(Decoder& decoder)
{
    auto asFragmentedSharedBuffer = decoder.decode<Ref<WebCore::FragmentedSharedBuffer>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SharedBuffer::create(
            WTFMove(*asFragmentedSharedBuffer)
        )
    };
}

#if !USE(COORDINATED_GRAPHICS)
enum class WebCore_FilterOperation_Subclass : IPC::EncodedVariantIndex {
    BasicColorMatrixFilterOperation
    , BasicComponentTransferFilterOperation
    , BlurFilterOperation
    , DropShadowFilterOperation
    , DefaultFilterOperation
    , PassthroughFilterOperation
};

IGNORE_WARNINGS_BEGIN("missing-noreturn")
void ArgumentCoder<WebCore::FilterOperation>::encode(Encoder& encoder, const WebCore::FilterOperation& instance)
{
    if (auto* subclass = dynamicDowncast<WebCore::BasicColorMatrixFilterOperation>(instance)) {
        encoder << WebCore_FilterOperation_Subclass::BasicColorMatrixFilterOperation;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::BasicComponentTransferFilterOperation>(instance)) {
        encoder << WebCore_FilterOperation_Subclass::BasicComponentTransferFilterOperation;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::BlurFilterOperation>(instance)) {
        encoder << WebCore_FilterOperation_Subclass::BlurFilterOperation;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::DropShadowFilterOperation>(instance)) {
        encoder << WebCore_FilterOperation_Subclass::DropShadowFilterOperation;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::DefaultFilterOperation>(instance)) {
        encoder << WebCore_FilterOperation_Subclass::DefaultFilterOperation;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::PassthroughFilterOperation>(instance)) {
        encoder << WebCore_FilterOperation_Subclass::PassthroughFilterOperation;
        encoder << *subclass;
        return;
    }
    ASSERT_NOT_REACHED();
}
IGNORE_WARNINGS_END

std::optional<Ref<WebCore::FilterOperation>> ArgumentCoder<WebCore::FilterOperation>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore_FilterOperation_Subclass>();
    UNUSED_PARAM(type);
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (type == WebCore_FilterOperation_Subclass::BasicColorMatrixFilterOperation) {
        auto result = decoder.decode<Ref<WebCore::BasicColorMatrixFilterOperation>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterOperation_Subclass::BasicComponentTransferFilterOperation) {
        auto result = decoder.decode<Ref<WebCore::BasicComponentTransferFilterOperation>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterOperation_Subclass::BlurFilterOperation) {
        auto result = decoder.decode<Ref<WebCore::BlurFilterOperation>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterOperation_Subclass::DropShadowFilterOperation) {
        auto result = decoder.decode<Ref<WebCore::DropShadowFilterOperation>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterOperation_Subclass::DefaultFilterOperation) {
        auto result = decoder.decode<Ref<WebCore::DefaultFilterOperation>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterOperation_Subclass::PassthroughFilterOperation) {
        auto result = decoder.decode<Ref<WebCore::PassthroughFilterOperation>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    ASSERT_NOT_REACHED();
    return std::nullopt;
}

#endif

#if !USE(COORDINATED_GRAPHICS)
void ArgumentCoder<WebCore::BasicColorMatrixFilterOperation>::encode(Encoder& encoder, const WebCore::BasicColorMatrixFilterOperation& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.amount())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebCore::FilterOperation::Type>);

    encoder << instance.amount();
    encoder << instance.type();
}

std::optional<Ref<WebCore::BasicColorMatrixFilterOperation>> ArgumentCoder<WebCore::BasicColorMatrixFilterOperation>::decode(Decoder& decoder)
{
    auto amount = decoder.decode<double>();
    auto type = decoder.decode<WebCore::FilterOperation::Type>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(WebCore::FilterOperation::isBasicColorMatrixFilterOperationType(*type)))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::BasicColorMatrixFilterOperation::create(
            WTFMove(*amount),
            WTFMove(*type)
        )
    };
}

#endif

#if !USE(COORDINATED_GRAPHICS)
void ArgumentCoder<WebCore::BasicComponentTransferFilterOperation>::encode(Encoder& encoder, const WebCore::BasicComponentTransferFilterOperation& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.amount())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebCore::FilterOperation::Type>);

    encoder << instance.amount();
    encoder << instance.type();
}

std::optional<Ref<WebCore::BasicComponentTransferFilterOperation>> ArgumentCoder<WebCore::BasicComponentTransferFilterOperation>::decode(Decoder& decoder)
{
    auto amount = decoder.decode<double>();
    auto type = decoder.decode<WebCore::FilterOperation::Type>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(WebCore::FilterOperation::isBasicComponentTransferFilterOperationType(*type)))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::BasicComponentTransferFilterOperation::create(
            WTFMove(*amount),
            WTFMove(*type)
        )
    };
}

#endif

#if !USE(COORDINATED_GRAPHICS)
void ArgumentCoder<WebCore::BlurFilterOperation>::encode(Encoder& encoder, const WebCore::BlurFilterOperation& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stdDeviation())>, WebCore::Length>);

    encoder << instance.stdDeviation();
}

std::optional<Ref<WebCore::BlurFilterOperation>> ArgumentCoder<WebCore::BlurFilterOperation>::decode(Decoder& decoder)
{
    auto stdDeviation = decoder.decode<WebCore::Length>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::BlurFilterOperation::create(
            WTFMove(*stdDeviation)
        )
    };
}

#endif

#if !USE(COORDINATED_GRAPHICS)
void ArgumentCoder<WebCore::DropShadowFilterOperation>::encode(Encoder& encoder, const WebCore::DropShadowFilterOperation& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.location())>, WebCore::IntPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stdDeviation())>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.color())>, WebCore::Color>);

    encoder << instance.location();
    encoder << instance.stdDeviation();
    encoder << instance.color();
}

std::optional<Ref<WebCore::DropShadowFilterOperation>> ArgumentCoder<WebCore::DropShadowFilterOperation>::decode(Decoder& decoder)
{
    auto location = decoder.decode<WebCore::IntPoint>();
    auto stdDeviation = decoder.decode<int>();
    auto color = decoder.decode<WebCore::Color>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DropShadowFilterOperation::create(
            WTFMove(*location),
            WTFMove(*stdDeviation),
            WTFMove(*color)
        )
    };
}

#endif

#if !USE(COORDINATED_GRAPHICS)
void ArgumentCoder<WebCore::DefaultFilterOperation>::encode(Encoder& encoder, const WebCore::DefaultFilterOperation& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.representedType())>, WebCore::FilterOperation::Type>);

    encoder << instance.representedType();
}

std::optional<Ref<WebCore::DefaultFilterOperation>> ArgumentCoder<WebCore::DefaultFilterOperation>::decode(Decoder& decoder)
{
    auto representedType = decoder.decode<WebCore::FilterOperation::Type>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DefaultFilterOperation::create(
            WTFMove(*representedType)
        )
    };
}

#endif

#if !USE(COORDINATED_GRAPHICS)
void ArgumentCoder<WebCore::PassthroughFilterOperation>::encode(Encoder& encoder, const WebCore::PassthroughFilterOperation& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebCore::FilterOperation::Type>);

}

std::optional<Ref<WebCore::PassthroughFilterOperation>> ArgumentCoder<WebCore::PassthroughFilterOperation>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PassthroughFilterOperation::create(
        )
    };
}

#endif

enum class WebCore_FilterEffect_Subclass : IPC::EncodedVariantIndex {
    FEBlend
    , FEColorMatrix
    , FEComponentTransfer
    , FEComposite
    , FEConvolveMatrix
    , FEDiffuseLighting
    , FEDisplacementMap
    , FEDropShadow
    , FEFlood
    , FEGaussianBlur
    , FEImage
    , FEMerge
    , FEMorphology
    , FEOffset
    , FETile
    , FESpecularLighting
    , FETurbulence
    , SourceAlpha
    , SourceGraphic
};

IGNORE_WARNINGS_BEGIN("missing-noreturn")
void ArgumentCoder<WebCore::FilterEffect>::encode(Encoder& encoder, const WebCore::FilterEffect& instance)
{
    if (auto* subclass = dynamicDowncast<WebCore::FEBlend>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FEBlend;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEColorMatrix>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FEColorMatrix;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEComponentTransfer>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FEComponentTransfer;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEComposite>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FEComposite;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEConvolveMatrix>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FEConvolveMatrix;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEDiffuseLighting>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FEDiffuseLighting;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEDisplacementMap>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FEDisplacementMap;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEDropShadow>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FEDropShadow;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEFlood>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FEFlood;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEGaussianBlur>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FEGaussianBlur;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEImage>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FEImage;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEMerge>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FEMerge;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEMorphology>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FEMorphology;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEOffset>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FEOffset;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FETile>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FETile;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FESpecularLighting>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FESpecularLighting;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FETurbulence>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FETurbulence;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::SourceAlpha>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::SourceAlpha;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::SourceGraphic>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::SourceGraphic;
        encoder << *subclass;
        return;
    }
    ASSERT_NOT_REACHED();
}
IGNORE_WARNINGS_END

IGNORE_WARNINGS_BEGIN("missing-noreturn")
void ArgumentCoder<WebCore::FilterEffect>::encode(StreamConnectionEncoder& encoder, const WebCore::FilterEffect& instance)
{
    if (auto* subclass = dynamicDowncast<WebCore::FEBlend>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FEBlend;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEColorMatrix>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FEColorMatrix;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEComponentTransfer>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FEComponentTransfer;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEComposite>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FEComposite;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEConvolveMatrix>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FEConvolveMatrix;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEDiffuseLighting>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FEDiffuseLighting;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEDisplacementMap>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FEDisplacementMap;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEDropShadow>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FEDropShadow;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEFlood>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FEFlood;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEGaussianBlur>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FEGaussianBlur;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEImage>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FEImage;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEMerge>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FEMerge;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEMorphology>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FEMorphology;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEOffset>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FEOffset;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FETile>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FETile;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FESpecularLighting>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FESpecularLighting;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FETurbulence>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::FETurbulence;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::SourceAlpha>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::SourceAlpha;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::SourceGraphic>(instance)) {
        encoder << WebCore_FilterEffect_Subclass::SourceGraphic;
        encoder << *subclass;
        return;
    }
    ASSERT_NOT_REACHED();
}
IGNORE_WARNINGS_END

std::optional<Ref<WebCore::FilterEffect>> ArgumentCoder<WebCore::FilterEffect>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore_FilterEffect_Subclass>();
    UNUSED_PARAM(type);
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (type == WebCore_FilterEffect_Subclass::FEBlend) {
        auto result = decoder.decode<Ref<WebCore::FEBlend>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterEffect_Subclass::FEColorMatrix) {
        auto result = decoder.decode<Ref<WebCore::FEColorMatrix>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterEffect_Subclass::FEComponentTransfer) {
        auto result = decoder.decode<Ref<WebCore::FEComponentTransfer>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterEffect_Subclass::FEComposite) {
        auto result = decoder.decode<Ref<WebCore::FEComposite>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterEffect_Subclass::FEConvolveMatrix) {
        auto result = decoder.decode<Ref<WebCore::FEConvolveMatrix>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterEffect_Subclass::FEDiffuseLighting) {
        auto result = decoder.decode<Ref<WebCore::FEDiffuseLighting>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterEffect_Subclass::FEDisplacementMap) {
        auto result = decoder.decode<Ref<WebCore::FEDisplacementMap>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterEffect_Subclass::FEDropShadow) {
        auto result = decoder.decode<Ref<WebCore::FEDropShadow>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterEffect_Subclass::FEFlood) {
        auto result = decoder.decode<Ref<WebCore::FEFlood>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterEffect_Subclass::FEGaussianBlur) {
        auto result = decoder.decode<Ref<WebCore::FEGaussianBlur>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterEffect_Subclass::FEImage) {
        auto result = decoder.decode<Ref<WebCore::FEImage>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterEffect_Subclass::FEMerge) {
        auto result = decoder.decode<Ref<WebCore::FEMerge>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterEffect_Subclass::FEMorphology) {
        auto result = decoder.decode<Ref<WebCore::FEMorphology>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterEffect_Subclass::FEOffset) {
        auto result = decoder.decode<Ref<WebCore::FEOffset>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterEffect_Subclass::FETile) {
        auto result = decoder.decode<Ref<WebCore::FETile>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterEffect_Subclass::FESpecularLighting) {
        auto result = decoder.decode<Ref<WebCore::FESpecularLighting>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterEffect_Subclass::FETurbulence) {
        auto result = decoder.decode<Ref<WebCore::FETurbulence>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterEffect_Subclass::SourceAlpha) {
        auto result = decoder.decode<Ref<WebCore::SourceAlpha>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterEffect_Subclass::SourceGraphic) {
        auto result = decoder.decode<Ref<WebCore::SourceGraphic>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    ASSERT_NOT_REACHED();
    return std::nullopt;
}

#if HAVE(CORE_MATERIAL)
void ArgumentCoder<WebCore::AppleVisualEffectData>::encode(Encoder& encoder, const WebCore::AppleVisualEffectData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.effect)>, WebCore::AppleVisualEffect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contextEffect)>, WebCore::AppleVisualEffect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorScheme)>, WebCore::AppleVisualEffectData::ColorScheme>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.borderRect)>, std::optional<WebCore::FloatRoundedRect>>);
    struct ShouldBeSameSizeAsAppleVisualEffectData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::AppleVisualEffectData>, false> {
        WebCore::AppleVisualEffect effect;
        WebCore::AppleVisualEffect contextEffect;
        WebCore::AppleVisualEffectData::ColorScheme colorScheme;
        std::optional<WebCore::FloatRoundedRect> borderRect;
    };
    static_assert(sizeof(ShouldBeSameSizeAsAppleVisualEffectData) == sizeof(WebCore::AppleVisualEffectData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::AppleVisualEffectData, effect)
        , offsetof(WebCore::AppleVisualEffectData, contextEffect)
        , offsetof(WebCore::AppleVisualEffectData, colorScheme)
        , offsetof(WebCore::AppleVisualEffectData, borderRect)
    >::value);

    encoder << instance.effect;
    encoder << instance.contextEffect;
    encoder << instance.colorScheme;
    encoder << instance.borderRect;
}

std::optional<WebCore::AppleVisualEffectData> ArgumentCoder<WebCore::AppleVisualEffectData>::decode(Decoder& decoder)
{
    auto effect = decoder.decode<WebCore::AppleVisualEffect>();
    auto contextEffect = decoder.decode<WebCore::AppleVisualEffect>();
    auto colorScheme = decoder.decode<WebCore::AppleVisualEffectData::ColorScheme>();
    auto borderRect = decoder.decode<std::optional<WebCore::FloatRoundedRect>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::AppleVisualEffectData {
            WTFMove(*effect),
            WTFMove(*contextEffect),
            WTFMove(*colorScheme),
            WTFMove(*borderRect)
        }
    };
}

#endif

#if ENABLE(MEDIA_SOURCE)
void ArgumentCoder<WebCore::SourceBufferEvictionData>::encode(Encoder& encoder, const WebCore::SourceBufferEvictionData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentSize)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.evictableSize)>, int64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maximumBufferSize)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.numMediaSamples)>, uint64_t>);
    struct ShouldBeSameSizeAsSourceBufferEvictionData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SourceBufferEvictionData>, false> {
        uint64_t contentSize;
        int64_t evictableSize;
        uint64_t maximumBufferSize;
        uint64_t numMediaSamples;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSourceBufferEvictionData) == sizeof(WebCore::SourceBufferEvictionData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::SourceBufferEvictionData, contentSize)
        , offsetof(WebCore::SourceBufferEvictionData, evictableSize)
        , offsetof(WebCore::SourceBufferEvictionData, maximumBufferSize)
        , offsetof(WebCore::SourceBufferEvictionData, numMediaSamples)
    >::value);

    encoder << instance.contentSize;
    encoder << instance.evictableSize;
    encoder << instance.maximumBufferSize;
    encoder << instance.numMediaSamples;
}

std::optional<WebCore::SourceBufferEvictionData> ArgumentCoder<WebCore::SourceBufferEvictionData>::decode(Decoder& decoder)
{
    auto contentSize = decoder.decode<uint64_t>();
    auto evictableSize = decoder.decode<int64_t>();
    auto maximumBufferSize = decoder.decode<uint64_t>();
    auto numMediaSamples = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SourceBufferEvictionData {
            WTFMove(*contentSize),
            WTFMove(*evictableSize),
            WTFMove(*maximumBufferSize),
            WTFMove(*numMediaSamples)
        }
    };
}

#endif

#if ENABLE(MEDIA_SOURCE)
void ArgumentCoder<WebCore::MediaSourceConfiguration>::encode(Encoder& encoder, const WebCore::MediaSourceConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.textTracksEnabled)>, bool>);
    struct ShouldBeSameSizeAsMediaSourceConfiguration : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MediaSourceConfiguration>, false> {
        bool textTracksEnabled;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMediaSourceConfiguration) == sizeof(WebCore::MediaSourceConfiguration));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MediaSourceConfiguration, textTracksEnabled)
    >::value);

    encoder << instance.textTracksEnabled;
}

std::optional<WebCore::MediaSourceConfiguration> ArgumentCoder<WebCore::MediaSourceConfiguration>::decode(Decoder& decoder)
{
    auto textTracksEnabled = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MediaSourceConfiguration {
            WTFMove(*textTracksEnabled)
        }
    };
}

#endif

void ArgumentCoder<WebCore::FontInternalAttributes>::encode(Encoder& encoder, const WebCore::FontInternalAttributes& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.renderingResourceIdentifier)>, std::optional<WebCore::RenderingResourceIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.origin)>, WebCore::FontOrigin>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isInterstitial)>, WebCore::FontIsInterstitial>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.visibility)>, WebCore::FontVisibility>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isTextOrientationFallback)>, WebCore::FontIsOrientationFallback>);
    struct ShouldBeSameSizeAsFontInternalAttributes : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FontInternalAttributes>, false> {
        std::optional<WebCore::RenderingResourceIdentifier> renderingResourceIdentifier;
        WebCore::FontOrigin origin : 1;
        WebCore::FontIsInterstitial isInterstitial : 1;
        WebCore::FontVisibility visibility : 1;
        WebCore::FontIsOrientationFallback isTextOrientationFallback : 1;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFontInternalAttributes) == sizeof(WebCore::FontInternalAttributes));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FontInternalAttributes, renderingResourceIdentifier)
    >::value);

    encoder << instance.renderingResourceIdentifier;
    encoder << instance.origin;
    encoder << instance.isInterstitial;
    encoder << instance.visibility;
    encoder << instance.isTextOrientationFallback;
}

std::optional<WebCore::FontInternalAttributes> ArgumentCoder<WebCore::FontInternalAttributes>::decode(Decoder& decoder)
{
    auto renderingResourceIdentifier = decoder.decode<std::optional<WebCore::RenderingResourceIdentifier>>();
    auto origin = decoder.decode<WebCore::FontOrigin>();
    auto isInterstitial = decoder.decode<WebCore::FontIsInterstitial>();
    auto visibility = decoder.decode<WebCore::FontVisibility>();
    auto isTextOrientationFallback = decoder.decode<WebCore::FontIsOrientationFallback>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FontInternalAttributes {
            WTFMove(*renderingResourceIdentifier),
            WTFMove(*origin),
            WTFMove(*isInterstitial),
            WTFMove(*visibility),
            WTFMove(*isTextOrientationFallback)
        }
    };
}

void ArgumentCoder<WebCore::Cursor::CustomCursorIPCData>::encode(Encoder& encoder, const WebCore::Cursor::CustomCursorIPCData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.image)>, Ref<WebCore::Image>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hotSpot)>, WebCore::IntPoint>);
#if ENABLE(MOUSE_CURSOR_SCALE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scaleFactor)>, float>);
#endif
    struct ShouldBeSameSizeAsCustomCursorIPCData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Cursor::CustomCursorIPCData>, false> {
        Ref<WebCore::Image> image;
        WebCore::IntPoint hotSpot;
#if ENABLE(MOUSE_CURSOR_SCALE)
        float scaleFactor;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsCustomCursorIPCData) == sizeof(WebCore::Cursor::CustomCursorIPCData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Cursor::CustomCursorIPCData, image)
        , offsetof(WebCore::Cursor::CustomCursorIPCData, hotSpot)
#if ENABLE(MOUSE_CURSOR_SCALE)
        , offsetof(WebCore::Cursor::CustomCursorIPCData, scaleFactor)
#endif
    >::value);

    encoder << instance.image;
    encoder << instance.hotSpot;
#if ENABLE(MOUSE_CURSOR_SCALE)
    encoder << instance.scaleFactor;
#endif
}

std::optional<WebCore::Cursor::CustomCursorIPCData> ArgumentCoder<WebCore::Cursor::CustomCursorIPCData>::decode(Decoder& decoder)
{
    auto image = decoder.decode<Ref<WebCore::Image>>();
    auto hotSpot = decoder.decode<WebCore::IntPoint>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!((*image)->rect().contains(*hotSpot)))
        return std::nullopt;
#if ENABLE(MOUSE_CURSOR_SCALE)
    auto scaleFactor = decoder.decode<float>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Cursor::CustomCursorIPCData {
            WTFMove(*image),
            WTFMove(*hotSpot),
#if ENABLE(MOUSE_CURSOR_SCALE)
            WTFMove(*scaleFactor)
#endif
        }
    };
}

void ArgumentCoder<WebCore::Cursor>::encode(Encoder& encoder, const WebCore::Cursor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ipcData())>, Variant<WebCore::PlatformCursorType, std::optional<WebCore::Cursor::CustomCursorIPCData>>>);

    encoder << instance.ipcData();
}

std::optional<WebCore::Cursor> ArgumentCoder<WebCore::Cursor>::decode(Decoder& decoder)
{
    auto ipcData = decoder.decode<Variant<WebCore::PlatformCursorType, std::optional<WebCore::Cursor::CustomCursorIPCData>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Cursor::fromIPCData(
            WTFMove(*ipcData)
        )
    };
}

void ArgumentCoder<WebCore::DOMCacheEngine::Record>::encode(Encoder& encoder, const WebCore::DOMCacheEngine::Record& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.updateResponseCounter)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requestHeadersGuard)>, WebCore::FetchHeadersGuard>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.request)>, WebCore::ResourceRequest>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.options)>, WebCore::FetchOptions>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.referrer)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.responseHeadersGuard)>, WebCore::FetchHeadersGuard>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.response)>, WebCore::ResourceResponse>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.responseBody)>, Variant<std::nullptr_t, Ref<WebCore::FormData>, Ref<WebCore::SharedBuffer>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.responseBodySize)>, uint64_t>);
    struct ShouldBeSameSizeAsRecord : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::DOMCacheEngine::Record>, false> {
        uint64_t identifier;
        uint64_t updateResponseCounter;
        WebCore::FetchHeadersGuard requestHeadersGuard;
        WebCore::ResourceRequest request;
        WebCore::FetchOptions options;
        String referrer;
        WebCore::FetchHeadersGuard responseHeadersGuard;
        WebCore::ResourceResponse response;
        Variant<std::nullptr_t, Ref<WebCore::FormData>, Ref<WebCore::SharedBuffer>> responseBody;
        uint64_t responseBodySize;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRecord) == sizeof(WebCore::DOMCacheEngine::Record));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::DOMCacheEngine::Record, identifier)
        , offsetof(WebCore::DOMCacheEngine::Record, updateResponseCounter)
        , offsetof(WebCore::DOMCacheEngine::Record, requestHeadersGuard)
        , offsetof(WebCore::DOMCacheEngine::Record, request)
        , offsetof(WebCore::DOMCacheEngine::Record, options)
        , offsetof(WebCore::DOMCacheEngine::Record, referrer)
        , offsetof(WebCore::DOMCacheEngine::Record, responseHeadersGuard)
        , offsetof(WebCore::DOMCacheEngine::Record, response)
        , offsetof(WebCore::DOMCacheEngine::Record, responseBody)
        , offsetof(WebCore::DOMCacheEngine::Record, responseBodySize)
    >::value);

    encoder << instance.identifier;
    encoder << instance.updateResponseCounter;
    encoder << instance.requestHeadersGuard;
    encoder << instance.request;
    encoder << instance.options;
    encoder << instance.referrer;
    encoder << instance.responseHeadersGuard;
    encoder << instance.response;
    encoder << instance.responseBody;
    encoder << instance.responseBodySize;
}

std::optional<WebCore::DOMCacheEngine::Record> ArgumentCoder<WebCore::DOMCacheEngine::Record>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<uint64_t>();
    auto updateResponseCounter = decoder.decode<uint64_t>();
    auto requestHeadersGuard = decoder.decode<WebCore::FetchHeadersGuard>();
    auto request = decoder.decode<WebCore::ResourceRequest>();
    auto options = decoder.decode<WebCore::FetchOptions>();
    auto referrer = decoder.decode<String>();
    auto responseHeadersGuard = decoder.decode<WebCore::FetchHeadersGuard>();
    auto response = decoder.decode<WebCore::ResourceResponse>();
    auto responseBody = decoder.decode<Variant<std::nullptr_t, Ref<WebCore::FormData>, Ref<WebCore::SharedBuffer>>>();
    auto responseBodySize = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DOMCacheEngine::Record {
            WTFMove(*identifier),
            WTFMove(*updateResponseCounter),
            WTFMove(*requestHeadersGuard),
            WTFMove(*request),
            WTFMove(*options),
            WTFMove(*referrer),
            WTFMove(*responseHeadersGuard),
            WTFMove(*response),
            WTFMove(*responseBody),
            WTFMove(*responseBodySize)
        }
    };
}

enum class WebCore_LightSource_Subclass : IPC::EncodedVariantIndex {
    DistantLightSource
    , PointLightSource
    , SpotLightSource
};

IGNORE_WARNINGS_BEGIN("missing-noreturn")
void ArgumentCoder<WebCore::LightSource>::encode(Encoder& encoder, const WebCore::LightSource& instance)
{
    if (auto* subclass = dynamicDowncast<WebCore::DistantLightSource>(instance)) {
        encoder << WebCore_LightSource_Subclass::DistantLightSource;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::PointLightSource>(instance)) {
        encoder << WebCore_LightSource_Subclass::PointLightSource;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::SpotLightSource>(instance)) {
        encoder << WebCore_LightSource_Subclass::SpotLightSource;
        encoder << *subclass;
        return;
    }
    ASSERT_NOT_REACHED();
}
IGNORE_WARNINGS_END

IGNORE_WARNINGS_BEGIN("missing-noreturn")
void ArgumentCoder<WebCore::LightSource>::encode(StreamConnectionEncoder& encoder, const WebCore::LightSource& instance)
{
    if (auto* subclass = dynamicDowncast<WebCore::DistantLightSource>(instance)) {
        encoder << WebCore_LightSource_Subclass::DistantLightSource;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::PointLightSource>(instance)) {
        encoder << WebCore_LightSource_Subclass::PointLightSource;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::SpotLightSource>(instance)) {
        encoder << WebCore_LightSource_Subclass::SpotLightSource;
        encoder << *subclass;
        return;
    }
    ASSERT_NOT_REACHED();
}
IGNORE_WARNINGS_END

std::optional<Ref<WebCore::LightSource>> ArgumentCoder<WebCore::LightSource>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore_LightSource_Subclass>();
    UNUSED_PARAM(type);
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (type == WebCore_LightSource_Subclass::DistantLightSource) {
        auto result = decoder.decode<Ref<WebCore::DistantLightSource>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_LightSource_Subclass::PointLightSource) {
        auto result = decoder.decode<Ref<WebCore::PointLightSource>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_LightSource_Subclass::SpotLightSource) {
        auto result = decoder.decode<Ref<WebCore::SpotLightSource>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    ASSERT_NOT_REACHED();
    return std::nullopt;
}

void ArgumentCoder<WebCore::Image>::encode(Encoder& encoder, const WebCore::Image& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.toShareableBitmap())>, RefPtr<WebCore::ShareableBitmap>>);

    encoder << instance.toShareableBitmap();
}

std::optional<Ref<WebCore::Image>> ArgumentCoder<WebCore::Image>::decode(Decoder& decoder)
{
    auto toShareableBitmap = decoder.decode<RefPtr<WebCore::ShareableBitmap>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Image::create(
            WTFMove(*toShareableBitmap)
        )
    };
}

void ArgumentCoder<WebCore::Length>::encode(Encoder& encoder, const WebCore::Length& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ipcData())>, Variant<WebCore::Length::AutoData, WebCore::Length::NormalData, WebCore::Length::RelativeData, WebCore::Length::PercentData, WebCore::Length::FixedData, WebCore::Length::IntrinsicData, WebCore::Length::MinIntrinsicData, WebCore::Length::MinContentData, WebCore::Length::MaxContentData, WebCore::Length::FillAvailableData, WebCore::Length::FitContentData, WebCore::Length::ContentData, WebCore::Length::UndefinedData>>);

    encoder << instance.ipcData();
}

std::optional<WebCore::Length> ArgumentCoder<WebCore::Length>::decode(Decoder& decoder)
{
    auto ipcData = decoder.decode<Variant<WebCore::Length::AutoData, WebCore::Length::NormalData, WebCore::Length::RelativeData, WebCore::Length::PercentData, WebCore::Length::FixedData, WebCore::Length::IntrinsicData, WebCore::Length::MinIntrinsicData, WebCore::Length::MinContentData, WebCore::Length::MaxContentData, WebCore::Length::FillAvailableData, WebCore::Length::FitContentData, WebCore::Length::ContentData, WebCore::Length::UndefinedData>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Length {
            WTFMove(*ipcData)
        }
    };
}

void ArgumentCoder<WebCore::Length::AutoData>::encode(Encoder& encoder, const WebCore::Length::AutoData& instance)
{
    struct ShouldBeSameSizeAsAutoData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Length::AutoData>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsAutoData) == sizeof(WebCore::Length::AutoData));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::Length::AutoData> ArgumentCoder<WebCore::Length::AutoData>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Length::AutoData {
        }
    };
}

void ArgumentCoder<WebCore::Length::NormalData>::encode(Encoder& encoder, const WebCore::Length::NormalData& instance)
{
    struct ShouldBeSameSizeAsNormalData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Length::NormalData>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsNormalData) == sizeof(WebCore::Length::NormalData));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::Length::NormalData> ArgumentCoder<WebCore::Length::NormalData>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Length::NormalData {
        }
    };
}

void ArgumentCoder<WebCore::Length::RelativeData>::encode(Encoder& encoder, const WebCore::Length::RelativeData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, Variant<float, int>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasQuirk)>, bool>);
    struct ShouldBeSameSizeAsRelativeData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Length::RelativeData>, false> {
        Variant<float, int> value;
        bool hasQuirk;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRelativeData) == sizeof(WebCore::Length::RelativeData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Length::RelativeData, value)
        , offsetof(WebCore::Length::RelativeData, hasQuirk)
    >::value);

    encoder << instance.value;
    encoder << instance.hasQuirk;
}

std::optional<WebCore::Length::RelativeData> ArgumentCoder<WebCore::Length::RelativeData>::decode(Decoder& decoder)
{
    auto value = decoder.decode<Variant<float, int>>();
    auto hasQuirk = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Length::RelativeData {
            WTFMove(*value),
            WTFMove(*hasQuirk)
        }
    };
}

void ArgumentCoder<WebCore::Length::PercentData>::encode(Encoder& encoder, const WebCore::Length::PercentData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, Variant<float, int>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasQuirk)>, bool>);
    struct ShouldBeSameSizeAsPercentData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Length::PercentData>, false> {
        Variant<float, int> value;
        bool hasQuirk;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPercentData) == sizeof(WebCore::Length::PercentData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Length::PercentData, value)
        , offsetof(WebCore::Length::PercentData, hasQuirk)
    >::value);

    encoder << instance.value;
    encoder << instance.hasQuirk;
}

std::optional<WebCore::Length::PercentData> ArgumentCoder<WebCore::Length::PercentData>::decode(Decoder& decoder)
{
    auto value = decoder.decode<Variant<float, int>>();
    auto hasQuirk = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Length::PercentData {
            WTFMove(*value),
            WTFMove(*hasQuirk)
        }
    };
}

void ArgumentCoder<WebCore::Length::FixedData>::encode(Encoder& encoder, const WebCore::Length::FixedData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, Variant<float, int>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasQuirk)>, bool>);
    struct ShouldBeSameSizeAsFixedData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Length::FixedData>, false> {
        Variant<float, int> value;
        bool hasQuirk;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFixedData) == sizeof(WebCore::Length::FixedData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Length::FixedData, value)
        , offsetof(WebCore::Length::FixedData, hasQuirk)
    >::value);

    encoder << instance.value;
    encoder << instance.hasQuirk;
}

std::optional<WebCore::Length::FixedData> ArgumentCoder<WebCore::Length::FixedData>::decode(Decoder& decoder)
{
    auto value = decoder.decode<Variant<float, int>>();
    auto hasQuirk = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Length::FixedData {
            WTFMove(*value),
            WTFMove(*hasQuirk)
        }
    };
}

void ArgumentCoder<WebCore::Length::IntrinsicData>::encode(Encoder& encoder, const WebCore::Length::IntrinsicData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, Variant<float, int>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasQuirk)>, bool>);
    struct ShouldBeSameSizeAsIntrinsicData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Length::IntrinsicData>, false> {
        Variant<float, int> value;
        bool hasQuirk;
    };
    static_assert(sizeof(ShouldBeSameSizeAsIntrinsicData) == sizeof(WebCore::Length::IntrinsicData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Length::IntrinsicData, value)
        , offsetof(WebCore::Length::IntrinsicData, hasQuirk)
    >::value);

    encoder << instance.value;
    encoder << instance.hasQuirk;
}

std::optional<WebCore::Length::IntrinsicData> ArgumentCoder<WebCore::Length::IntrinsicData>::decode(Decoder& decoder)
{
    auto value = decoder.decode<Variant<float, int>>();
    auto hasQuirk = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Length::IntrinsicData {
            WTFMove(*value),
            WTFMove(*hasQuirk)
        }
    };
}

void ArgumentCoder<WebCore::Length::MinIntrinsicData>::encode(Encoder& encoder, const WebCore::Length::MinIntrinsicData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, Variant<float, int>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasQuirk)>, bool>);
    struct ShouldBeSameSizeAsMinIntrinsicData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Length::MinIntrinsicData>, false> {
        Variant<float, int> value;
        bool hasQuirk;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMinIntrinsicData) == sizeof(WebCore::Length::MinIntrinsicData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Length::MinIntrinsicData, value)
        , offsetof(WebCore::Length::MinIntrinsicData, hasQuirk)
    >::value);

    encoder << instance.value;
    encoder << instance.hasQuirk;
}

std::optional<WebCore::Length::MinIntrinsicData> ArgumentCoder<WebCore::Length::MinIntrinsicData>::decode(Decoder& decoder)
{
    auto value = decoder.decode<Variant<float, int>>();
    auto hasQuirk = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Length::MinIntrinsicData {
            WTFMove(*value),
            WTFMove(*hasQuirk)
        }
    };
}

void ArgumentCoder<WebCore::Length::MinContentData>::encode(Encoder& encoder, const WebCore::Length::MinContentData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, Variant<float, int>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasQuirk)>, bool>);
    struct ShouldBeSameSizeAsMinContentData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Length::MinContentData>, false> {
        Variant<float, int> value;
        bool hasQuirk;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMinContentData) == sizeof(WebCore::Length::MinContentData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Length::MinContentData, value)
        , offsetof(WebCore::Length::MinContentData, hasQuirk)
    >::value);

    encoder << instance.value;
    encoder << instance.hasQuirk;
}

std::optional<WebCore::Length::MinContentData> ArgumentCoder<WebCore::Length::MinContentData>::decode(Decoder& decoder)
{
    auto value = decoder.decode<Variant<float, int>>();
    auto hasQuirk = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Length::MinContentData {
            WTFMove(*value),
            WTFMove(*hasQuirk)
        }
    };
}

void ArgumentCoder<WebCore::Length::MaxContentData>::encode(Encoder& encoder, const WebCore::Length::MaxContentData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, Variant<float, int>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasQuirk)>, bool>);
    struct ShouldBeSameSizeAsMaxContentData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Length::MaxContentData>, false> {
        Variant<float, int> value;
        bool hasQuirk;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMaxContentData) == sizeof(WebCore::Length::MaxContentData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Length::MaxContentData, value)
        , offsetof(WebCore::Length::MaxContentData, hasQuirk)
    >::value);

    encoder << instance.value;
    encoder << instance.hasQuirk;
}

std::optional<WebCore::Length::MaxContentData> ArgumentCoder<WebCore::Length::MaxContentData>::decode(Decoder& decoder)
{
    auto value = decoder.decode<Variant<float, int>>();
    auto hasQuirk = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Length::MaxContentData {
            WTFMove(*value),
            WTFMove(*hasQuirk)
        }
    };
}

void ArgumentCoder<WebCore::Length::FillAvailableData>::encode(Encoder& encoder, const WebCore::Length::FillAvailableData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, Variant<float, int>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasQuirk)>, bool>);
    struct ShouldBeSameSizeAsFillAvailableData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Length::FillAvailableData>, false> {
        Variant<float, int> value;
        bool hasQuirk;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFillAvailableData) == sizeof(WebCore::Length::FillAvailableData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Length::FillAvailableData, value)
        , offsetof(WebCore::Length::FillAvailableData, hasQuirk)
    >::value);

    encoder << instance.value;
    encoder << instance.hasQuirk;
}

std::optional<WebCore::Length::FillAvailableData> ArgumentCoder<WebCore::Length::FillAvailableData>::decode(Decoder& decoder)
{
    auto value = decoder.decode<Variant<float, int>>();
    auto hasQuirk = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Length::FillAvailableData {
            WTFMove(*value),
            WTFMove(*hasQuirk)
        }
    };
}

void ArgumentCoder<WebCore::Length::FitContentData>::encode(Encoder& encoder, const WebCore::Length::FitContentData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, Variant<float, int>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasQuirk)>, bool>);
    struct ShouldBeSameSizeAsFitContentData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Length::FitContentData>, false> {
        Variant<float, int> value;
        bool hasQuirk;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFitContentData) == sizeof(WebCore::Length::FitContentData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::Length::FitContentData, value)
        , offsetof(WebCore::Length::FitContentData, hasQuirk)
    >::value);

    encoder << instance.value;
    encoder << instance.hasQuirk;
}

std::optional<WebCore::Length::FitContentData> ArgumentCoder<WebCore::Length::FitContentData>::decode(Decoder& decoder)
{
    auto value = decoder.decode<Variant<float, int>>();
    auto hasQuirk = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Length::FitContentData {
            WTFMove(*value),
            WTFMove(*hasQuirk)
        }
    };
}

void ArgumentCoder<WebCore::Length::ContentData>::encode(Encoder& encoder, const WebCore::Length::ContentData& instance)
{
    struct ShouldBeSameSizeAsContentData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Length::ContentData>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsContentData) == sizeof(WebCore::Length::ContentData));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::Length::ContentData> ArgumentCoder<WebCore::Length::ContentData>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Length::ContentData {
        }
    };
}

void ArgumentCoder<WebCore::Length::UndefinedData>::encode(Encoder& encoder, const WebCore::Length::UndefinedData& instance)
{
    struct ShouldBeSameSizeAsUndefinedData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Length::UndefinedData>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsUndefinedData) == sizeof(WebCore::Length::UndefinedData));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::Length::UndefinedData> ArgumentCoder<WebCore::Length::UndefinedData>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Length::UndefinedData {
        }
    };
}

enum class WebCore_FilterFunction_Subclass : IPC::EncodedVariantIndex {
    SVGFilter
    , FEBlend
    , FEColorMatrix
    , FEComponentTransfer
    , FEComposite
    , FEConvolveMatrix
    , FEDiffuseLighting
    , FEDisplacementMap
    , FEDropShadow
    , FEFlood
    , FEGaussianBlur
    , FEImage
    , FEMerge
    , FEMorphology
    , FEOffset
    , FESpecularLighting
    , FETile
    , FETurbulence
    , SourceAlpha
    , SourceGraphic
};

IGNORE_WARNINGS_BEGIN("missing-noreturn")
void ArgumentCoder<WebCore::FilterFunction>::encode(Encoder& encoder, const WebCore::FilterFunction& instance)
{
    if (auto* subclass = dynamicDowncast<WebCore::SVGFilter>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::SVGFilter;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEBlend>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FEBlend;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEColorMatrix>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FEColorMatrix;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEComponentTransfer>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FEComponentTransfer;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEComposite>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FEComposite;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEConvolveMatrix>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FEConvolveMatrix;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEDiffuseLighting>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FEDiffuseLighting;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEDisplacementMap>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FEDisplacementMap;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEDropShadow>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FEDropShadow;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEFlood>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FEFlood;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEGaussianBlur>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FEGaussianBlur;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEImage>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FEImage;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEMerge>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FEMerge;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEMorphology>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FEMorphology;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEOffset>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FEOffset;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FESpecularLighting>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FESpecularLighting;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FETile>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FETile;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FETurbulence>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FETurbulence;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::SourceAlpha>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::SourceAlpha;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::SourceGraphic>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::SourceGraphic;
        encoder << *subclass;
        return;
    }
    ASSERT_NOT_REACHED();
}
IGNORE_WARNINGS_END

IGNORE_WARNINGS_BEGIN("missing-noreturn")
void ArgumentCoder<WebCore::FilterFunction>::encode(StreamConnectionEncoder& encoder, const WebCore::FilterFunction& instance)
{
    if (auto* subclass = dynamicDowncast<WebCore::SVGFilter>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::SVGFilter;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEBlend>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FEBlend;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEColorMatrix>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FEColorMatrix;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEComponentTransfer>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FEComponentTransfer;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEComposite>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FEComposite;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEConvolveMatrix>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FEConvolveMatrix;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEDiffuseLighting>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FEDiffuseLighting;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEDisplacementMap>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FEDisplacementMap;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEDropShadow>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FEDropShadow;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEFlood>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FEFlood;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEGaussianBlur>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FEGaussianBlur;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEImage>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FEImage;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEMerge>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FEMerge;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEMorphology>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FEMorphology;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FEOffset>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FEOffset;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FESpecularLighting>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FESpecularLighting;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FETile>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FETile;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::FETurbulence>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::FETurbulence;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::SourceAlpha>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::SourceAlpha;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebCore::SourceGraphic>(instance)) {
        encoder << WebCore_FilterFunction_Subclass::SourceGraphic;
        encoder << *subclass;
        return;
    }
    ASSERT_NOT_REACHED();
}
IGNORE_WARNINGS_END

std::optional<Ref<WebCore::FilterFunction>> ArgumentCoder<WebCore::FilterFunction>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore_FilterFunction_Subclass>();
    UNUSED_PARAM(type);
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (type == WebCore_FilterFunction_Subclass::SVGFilter) {
        auto result = decoder.decode<Ref<WebCore::SVGFilter>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterFunction_Subclass::FEBlend) {
        auto result = decoder.decode<Ref<WebCore::FEBlend>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterFunction_Subclass::FEColorMatrix) {
        auto result = decoder.decode<Ref<WebCore::FEColorMatrix>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterFunction_Subclass::FEComponentTransfer) {
        auto result = decoder.decode<Ref<WebCore::FEComponentTransfer>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterFunction_Subclass::FEComposite) {
        auto result = decoder.decode<Ref<WebCore::FEComposite>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterFunction_Subclass::FEConvolveMatrix) {
        auto result = decoder.decode<Ref<WebCore::FEConvolveMatrix>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterFunction_Subclass::FEDiffuseLighting) {
        auto result = decoder.decode<Ref<WebCore::FEDiffuseLighting>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterFunction_Subclass::FEDisplacementMap) {
        auto result = decoder.decode<Ref<WebCore::FEDisplacementMap>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterFunction_Subclass::FEDropShadow) {
        auto result = decoder.decode<Ref<WebCore::FEDropShadow>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterFunction_Subclass::FEFlood) {
        auto result = decoder.decode<Ref<WebCore::FEFlood>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterFunction_Subclass::FEGaussianBlur) {
        auto result = decoder.decode<Ref<WebCore::FEGaussianBlur>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterFunction_Subclass::FEImage) {
        auto result = decoder.decode<Ref<WebCore::FEImage>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterFunction_Subclass::FEMerge) {
        auto result = decoder.decode<Ref<WebCore::FEMerge>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterFunction_Subclass::FEMorphology) {
        auto result = decoder.decode<Ref<WebCore::FEMorphology>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterFunction_Subclass::FEOffset) {
        auto result = decoder.decode<Ref<WebCore::FEOffset>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterFunction_Subclass::FESpecularLighting) {
        auto result = decoder.decode<Ref<WebCore::FESpecularLighting>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterFunction_Subclass::FETile) {
        auto result = decoder.decode<Ref<WebCore::FETile>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterFunction_Subclass::FETurbulence) {
        auto result = decoder.decode<Ref<WebCore::FETurbulence>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterFunction_Subclass::SourceAlpha) {
        auto result = decoder.decode<Ref<WebCore::SourceAlpha>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == WebCore_FilterFunction_Subclass::SourceGraphic) {
        auto result = decoder.decode<Ref<WebCore::SourceGraphic>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    ASSERT_NOT_REACHED();
    return std::nullopt;
}

void ArgumentCoder<WebCore::OrganizationStorageAccessPromptQuirk>::encode(Encoder& encoder, const WebCore::OrganizationStorageAccessPromptQuirk& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.organizationName)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.quirkDomains)>, HashMap<WebCore::RegistrableDomain, Vector<WebCore::RegistrableDomain>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.triggerPages)>, Vector<URL>>);
    struct ShouldBeSameSizeAsOrganizationStorageAccessPromptQuirk : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::OrganizationStorageAccessPromptQuirk>, false> {
        String organizationName;
        HashMap<WebCore::RegistrableDomain, Vector<WebCore::RegistrableDomain>> quirkDomains;
        Vector<URL> triggerPages;
    };
    static_assert(sizeof(ShouldBeSameSizeAsOrganizationStorageAccessPromptQuirk) == sizeof(WebCore::OrganizationStorageAccessPromptQuirk));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::OrganizationStorageAccessPromptQuirk, organizationName)
        , offsetof(WebCore::OrganizationStorageAccessPromptQuirk, quirkDomains)
        , offsetof(WebCore::OrganizationStorageAccessPromptQuirk, triggerPages)
    >::value);

    encoder << instance.organizationName;
    encoder << instance.quirkDomains;
    encoder << instance.triggerPages;
}

std::optional<WebCore::OrganizationStorageAccessPromptQuirk> ArgumentCoder<WebCore::OrganizationStorageAccessPromptQuirk>::decode(Decoder& decoder)
{
    auto organizationName = decoder.decode<String>();
    auto quirkDomains = decoder.decode<HashMap<WebCore::RegistrableDomain, Vector<WebCore::RegistrableDomain>>>();
    auto triggerPages = decoder.decode<Vector<URL>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::OrganizationStorageAccessPromptQuirk {
            WTFMove(*organizationName),
            WTFMove(*quirkDomains),
            WTFMove(*triggerPages)
        }
    };
}

#if ENABLE(SHAREABLE_RESOURCE)
void ArgumentCoder<WebCore::ShareableResourceHandle>::encode(Encoder& encoder, WebCore::ShareableResourceHandle&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_handle)>, WebCore::SharedMemoryHandle>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_offset)>, unsigned>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_size)>, unsigned>);
    struct ShouldBeSameSizeAsShareableResourceHandle : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ShareableResourceHandle>, false> {
        WebCore::SharedMemoryHandle m_handle;
        unsigned m_offset;
        unsigned m_size;
    };
    static_assert(sizeof(ShouldBeSameSizeAsShareableResourceHandle) == sizeof(WebCore::ShareableResourceHandle));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ShareableResourceHandle, m_handle)
        , offsetof(WebCore::ShareableResourceHandle, m_offset)
        , offsetof(WebCore::ShareableResourceHandle, m_size)
    >::value);

    encoder << WTFMove(instance.m_handle);
    encoder << WTFMove(instance.m_offset);
    encoder << WTFMove(instance.m_size);
}

std::optional<WebCore::ShareableResourceHandle> ArgumentCoder<WebCore::ShareableResourceHandle>::decode(Decoder& decoder)
{
    auto m_handle = decoder.decode<WebCore::SharedMemoryHandle>();
    auto m_offset = decoder.decode<unsigned>();
    auto m_size = decoder.decode<unsigned>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(!(Checked<unsigned> { *m_offset } + *m_size).hasOverflowed() && (*m_offset + *m_size <= m_handle->size())))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ShareableResourceHandle {
            WTFMove(*m_handle),
            WTFMove(*m_offset),
            WTFMove(*m_size)
        }
    };
}

#endif

#if ENABLE(RE_DYNAMIC_CONTENT_SCALING)
void ArgumentCoder<WebCore::DynamicContentScalingDisplayList>::encode(Encoder& encoder, WebCore::DynamicContentScalingDisplayList&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.displayList())>, Ref<WebCore::SharedBuffer>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.takeSurfaces())>, Vector<MachSendRight>>);

    encoder << instance.displayList();
    encoder << instance.takeSurfaces();
}

std::optional<WebCore::DynamicContentScalingDisplayList> ArgumentCoder<WebCore::DynamicContentScalingDisplayList>::decode(Decoder& decoder)
{
    auto displayList = decoder.decode<Ref<WebCore::SharedBuffer>>();
    auto takeSurfaces = decoder.decode<Vector<MachSendRight>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DynamicContentScalingDisplayList {
            WTFMove(*displayList),
            WTFMove(*takeSurfaces)
        }
    };
}

#endif

#if PLATFORM(COCOA)
void ArgumentCoder<WebCore::TextAttachmentMissingImage>::encode(Encoder& encoder, const WebCore::TextAttachmentMissingImage& instance)
{
    struct ShouldBeSameSizeAsTextAttachmentMissingImage : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::TextAttachmentMissingImage>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsTextAttachmentMissingImage) == sizeof(WebCore::TextAttachmentMissingImage));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::TextAttachmentMissingImage> ArgumentCoder<WebCore::TextAttachmentMissingImage>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TextAttachmentMissingImage {
        }
    };
}

#endif

#if PLATFORM(COCOA)
void ArgumentCoder<WebCore::TextAttachmentFileWrapper>::encode(Encoder& encoder, const WebCore::TextAttachmentFileWrapper& instance)
{
#if !PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ignoresOrientation)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.preferredFilename)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data)>, RetainPtr<CFDataRef>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.accessibilityLabel)>, String>);
    struct ShouldBeSameSizeAsTextAttachmentFileWrapper : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::TextAttachmentFileWrapper>, false> {
#if !PLATFORM(IOS_FAMILY)
        bool ignoresOrientation;
#endif
        String preferredFilename;
        RetainPtr<CFDataRef> data;
        String accessibilityLabel;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTextAttachmentFileWrapper) == sizeof(WebCore::TextAttachmentFileWrapper));
    static_assert(MembersInCorrectOrder < 0
#if !PLATFORM(IOS_FAMILY)
        , offsetof(WebCore::TextAttachmentFileWrapper, ignoresOrientation)
#endif
        , offsetof(WebCore::TextAttachmentFileWrapper, preferredFilename)
        , offsetof(WebCore::TextAttachmentFileWrapper, data)
        , offsetof(WebCore::TextAttachmentFileWrapper, accessibilityLabel)
    >::value);

#if !PLATFORM(IOS_FAMILY)
    encoder << instance.ignoresOrientation;
#endif
    encoder << instance.preferredFilename;
    encoder << instance.data;
    encoder << instance.accessibilityLabel;
}

std::optional<WebCore::TextAttachmentFileWrapper> ArgumentCoder<WebCore::TextAttachmentFileWrapper>::decode(Decoder& decoder)
{
#if !PLATFORM(IOS_FAMILY)
    auto ignoresOrientation = decoder.decode<bool>();
#endif
    auto preferredFilename = decoder.decode<String>();
    auto data = decoder.decode<RetainPtr<CFDataRef>>();
    auto accessibilityLabel = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TextAttachmentFileWrapper {
#if !PLATFORM(IOS_FAMILY)
            WTFMove(*ignoresOrientation),
#endif
            WTFMove(*preferredFilename),
            WTFMove(*data),
            WTFMove(*accessibilityLabel)
        }
    };
}

#endif

#if (PLATFORM(COCOA)) && (ENABLE(MULTI_REPRESENTATION_HEIC))
void ArgumentCoder<WebCore::MultiRepresentationHEICAttachmentSingleImage>::encode(Encoder& encoder, const WebCore::MultiRepresentationHEICAttachmentSingleImage& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.image)>, RefPtr<WebCore::Image>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size)>, WebCore::FloatSize>);
    struct ShouldBeSameSizeAsMultiRepresentationHEICAttachmentSingleImage : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MultiRepresentationHEICAttachmentSingleImage>, false> {
        RefPtr<WebCore::Image> image;
        WebCore::FloatSize size;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMultiRepresentationHEICAttachmentSingleImage) == sizeof(WebCore::MultiRepresentationHEICAttachmentSingleImage));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MultiRepresentationHEICAttachmentSingleImage, image)
        , offsetof(WebCore::MultiRepresentationHEICAttachmentSingleImage, size)
    >::value);

    encoder << instance.image;
    encoder << instance.size;
}

std::optional<WebCore::MultiRepresentationHEICAttachmentSingleImage> ArgumentCoder<WebCore::MultiRepresentationHEICAttachmentSingleImage>::decode(Decoder& decoder)
{
    auto image = decoder.decode<RefPtr<WebCore::Image>>();
    auto size = decoder.decode<WebCore::FloatSize>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MultiRepresentationHEICAttachmentSingleImage {
            WTFMove(*image),
            WTFMove(*size)
        }
    };
}

#endif

#if (PLATFORM(COCOA)) && (ENABLE(MULTI_REPRESENTATION_HEIC))
void ArgumentCoder<WebCore::MultiRepresentationHEICAttachmentData>::encode(Encoder& encoder, const WebCore::MultiRepresentationHEICAttachmentData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.description)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.credit)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.digitalSourceType)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.images)>, Vector<WebCore::MultiRepresentationHEICAttachmentSingleImage>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data)>, RetainPtr<CFDataRef>>);
    struct ShouldBeSameSizeAsMultiRepresentationHEICAttachmentData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MultiRepresentationHEICAttachmentData>, false> {
        String identifier;
        String description;
        String credit;
        String digitalSourceType;
        Vector<WebCore::MultiRepresentationHEICAttachmentSingleImage> images;
        RetainPtr<CFDataRef> data;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMultiRepresentationHEICAttachmentData) == sizeof(WebCore::MultiRepresentationHEICAttachmentData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MultiRepresentationHEICAttachmentData, identifier)
        , offsetof(WebCore::MultiRepresentationHEICAttachmentData, description)
        , offsetof(WebCore::MultiRepresentationHEICAttachmentData, credit)
        , offsetof(WebCore::MultiRepresentationHEICAttachmentData, digitalSourceType)
        , offsetof(WebCore::MultiRepresentationHEICAttachmentData, images)
        , offsetof(WebCore::MultiRepresentationHEICAttachmentData, data)
    >::value);

    encoder << instance.identifier;
    encoder << instance.description;
    encoder << instance.credit;
    encoder << instance.digitalSourceType;
    encoder << instance.images;
}

std::optional<WebCore::MultiRepresentationHEICAttachmentData> ArgumentCoder<WebCore::MultiRepresentationHEICAttachmentData>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<String>();
    auto description = decoder.decode<String>();
    auto credit = decoder.decode<String>();
    auto digitalSourceType = decoder.decode<String>();
    auto images = decoder.decode<Vector<WebCore::MultiRepresentationHEICAttachmentSingleImage>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MultiRepresentationHEICAttachmentData {
            WTFMove(*identifier),
            WTFMove(*description),
            WTFMove(*credit),
            WTFMove(*digitalSourceType),
            WTFMove(*images)
        }
    };
}

#endif

#if ENABLE(IMAGE_ANALYSIS) && ENABLE(DATA_DETECTION)
void ArgumentCoder<WebCore::TextRecognitionDataDetector>::encode(Encoder& encoder, const WebCore::TextRecognitionDataDetector& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.result)>, RetainPtr<DDScannerResult>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.normalizedQuads)>, Vector<WebCore::FloatQuad>>);
    struct ShouldBeSameSizeAsTextRecognitionDataDetector : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::TextRecognitionDataDetector>, false> {
        RetainPtr<DDScannerResult> result;
        Vector<WebCore::FloatQuad> normalizedQuads;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTextRecognitionDataDetector) == sizeof(WebCore::TextRecognitionDataDetector));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::TextRecognitionDataDetector, result)
        , offsetof(WebCore::TextRecognitionDataDetector, normalizedQuads)
    >::value);

    encoder << instance.result;
    encoder << instance.normalizedQuads;
}

std::optional<WebCore::TextRecognitionDataDetector> ArgumentCoder<WebCore::TextRecognitionDataDetector>::decode(Decoder& decoder)
{
    auto result = decoder.decode<RetainPtr<DDScannerResult>>();
    auto normalizedQuads = decoder.decode<Vector<WebCore::FloatQuad>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::TextRecognitionDataDetector {
            WTFMove(*result),
            WTFMove(*normalizedQuads)
        }
    };
}

#endif

void ArgumentCoder<WebCore::ShareableBitmapConfiguration>::encode(Encoder& encoder, const WebCore::ShareableBitmapConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_size)>, WebCore::IntSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_colorSpace)>, std::optional<WebCore::DestinationColorSpace>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_headroom)>, WebCore::Headroom>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_isOpaque)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bitsPerComponent())>, unsigned>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bytesPerPixel())>, unsigned>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bytesPerRow())>, unsigned>);
#if USE(CG)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_bitmapInfo)>, CGBitmapInfo>);
#endif

    encoder << instance.m_size;
    encoder << instance.m_colorSpace;
    encoder << instance.m_headroom;
    encoder << instance.m_isOpaque;
    encoder << instance.bitsPerComponent();
    encoder << instance.bytesPerPixel();
    encoder << instance.bytesPerRow();
#if USE(CG)
    encoder << instance.m_bitmapInfo;
#endif
}

std::optional<WebCore::ShareableBitmapConfiguration> ArgumentCoder<WebCore::ShareableBitmapConfiguration>::decode(Decoder& decoder)
{
    auto m_size = decoder.decode<WebCore::IntSize>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(m_size->width() >= 0 && m_size->height() >= 0))
        return std::nullopt;
    auto m_colorSpace = decoder.decode<std::optional<WebCore::DestinationColorSpace>>();
    auto m_headroom = decoder.decode<WebCore::Headroom>();
    auto m_isOpaque = decoder.decode<bool>();
    auto bitsPerComponent = decoder.decode<unsigned>();
    auto bytesPerPixel = decoder.decode<unsigned>();
    auto bytesPerRow = decoder.decode<unsigned>();
#if USE(CG)
    auto m_bitmapInfo = decoder.decode<CGBitmapInfo>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ShareableBitmapConfiguration {
            WTFMove(*m_size),
            WTFMove(*m_colorSpace),
            WTFMove(*m_headroom),
            WTFMove(*m_isOpaque),
            WTFMove(*bitsPerComponent),
            WTFMove(*bytesPerPixel),
            WTFMove(*bytesPerRow),
#if USE(CG)
            WTFMove(*m_bitmapInfo)
#endif
        }
    };
}

void ArgumentCoder<WebCore::ShareableBitmapHandle>::encode(Encoder& encoder, WebCore::ShareableBitmapHandle&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_handle)>, WebCore::SharedMemoryHandle>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_configuration)>, WebCore::ShareableBitmapConfiguration>);
    struct ShouldBeSameSizeAsShareableBitmapHandle : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ShareableBitmapHandle>, false> {
        WebCore::SharedMemoryHandle m_handle;
        WebCore::ShareableBitmapConfiguration m_configuration;
    };
    static_assert(sizeof(ShouldBeSameSizeAsShareableBitmapHandle) == sizeof(WebCore::ShareableBitmapHandle));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ShareableBitmapHandle, m_handle)
        , offsetof(WebCore::ShareableBitmapHandle, m_configuration)
    >::value);

    encoder << WTFMove(instance.m_handle);
    encoder << WTFMove(instance.m_configuration);
}

std::optional<WebCore::ShareableBitmapHandle> ArgumentCoder<WebCore::ShareableBitmapHandle>::decode(Decoder& decoder)
{
    auto m_handle = decoder.decode<WebCore::SharedMemoryHandle>();
    auto m_configuration = decoder.decode<WebCore::ShareableBitmapConfiguration>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(!m_configuration->sizeInBytes().hasOverflowed() && m_handle->size() >= m_configuration->sizeInBytes()))
        return std::nullopt;
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ShareableBitmapHandle {
            WTFMove(*m_handle),
            WTFMove(*m_configuration)
        }
    };
}

void ArgumentCoder<WebCore::ShareableBitmap>::encode(Encoder& encoder, const WebCore::ShareableBitmap& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.createReadOnlyHandle())>, std::optional<WebCore::ShareableBitmapHandle>>);

    encoder << instance.createReadOnlyHandle();
}

std::optional<Ref<WebCore::ShareableBitmap>> ArgumentCoder<WebCore::ShareableBitmap>::decode(Decoder& decoder)
{
    auto createReadOnlyHandle = decoder.decode<std::optional<WebCore::ShareableBitmapHandle>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ShareableBitmap::createReadOnly(
            WTFMove(*createReadOnlyHandle)
        )
    };
}

#if ENABLE(DATA_DETECTION)
void ArgumentCoder<WebCore::DataDetectorElementInfo>::encode(Encoder& encoder, const WebCore::DataDetectorElementInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.result)>, RetainPtr<DDScannerResult>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.elementBounds)>, WebCore::IntRect>);
    struct ShouldBeSameSizeAsDataDetectorElementInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::DataDetectorElementInfo>, false> {
        RetainPtr<DDScannerResult> result;
        WebCore::IntRect elementBounds;
    };
    static_assert(sizeof(ShouldBeSameSizeAsDataDetectorElementInfo) == sizeof(WebCore::DataDetectorElementInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::DataDetectorElementInfo, result)
        , offsetof(WebCore::DataDetectorElementInfo, elementBounds)
    >::value);

    encoder << instance.result;
    encoder << instance.elementBounds;
}

std::optional<WebCore::DataDetectorElementInfo> ArgumentCoder<WebCore::DataDetectorElementInfo>::decode(Decoder& decoder)
{
    auto result = decoder.decode<RetainPtr<DDScannerResult>>();
    auto elementBounds = decoder.decode<WebCore::IntRect>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DataDetectorElementInfo {
            WTFMove(*result),
            WTFMove(*elementBounds)
        }
    };
}

#endif

#if ENABLE(VIDEO)
void ArgumentCoder<WebCore::SerializedPlatformDataCueValue>::encode(Encoder& encoder, const WebCore::SerializedPlatformDataCueValue& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data())>, std::optional<WebCore::SerializedPlatformDataCueValue::Data>>);

    encoder << instance.data();
}

std::optional<WebCore::SerializedPlatformDataCueValue> ArgumentCoder<WebCore::SerializedPlatformDataCueValue>::decode(Decoder& decoder)
{
    auto data = decoder.decode<std::optional<WebCore::SerializedPlatformDataCueValue::Data>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SerializedPlatformDataCueValue {
            WTFMove(*data)
        }
    };
}

#endif

#if ENABLE(VIDEO)
void ArgumentCoder<WebCore::SerializedPlatformDataCueValue::Data>::encode(Encoder& encoder, const WebCore::SerializedPlatformDataCueValue::Data& instance)
{
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, String>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.otherAttributes)>, HashMap<String, String>>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.key)>, String>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.locale)>, RetainPtr<NSLocale>>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, Variant<std::nullptr_t, RetainPtr<NSString>, RetainPtr<NSDate>, RetainPtr<NSNumber>, RetainPtr<NSData>>>);
#endif
    struct ShouldBeSameSizeAsData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::SerializedPlatformDataCueValue::Data>, false> {
#if PLATFORM(COCOA)
        String type;
#endif
#if PLATFORM(COCOA)
        HashMap<String, String> otherAttributes;
#endif
#if PLATFORM(COCOA)
        String key;
#endif
#if PLATFORM(COCOA)
        RetainPtr<NSLocale> locale;
#endif
#if PLATFORM(COCOA)
        Variant<std::nullptr_t, RetainPtr<NSString>, RetainPtr<NSDate>, RetainPtr<NSNumber>, RetainPtr<NSData>> value;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsData) == sizeof(WebCore::SerializedPlatformDataCueValue::Data));
    static_assert(MembersInCorrectOrder < 0
#if PLATFORM(COCOA)
        , offsetof(WebCore::SerializedPlatformDataCueValue::Data, type)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebCore::SerializedPlatformDataCueValue::Data, otherAttributes)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebCore::SerializedPlatformDataCueValue::Data, key)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebCore::SerializedPlatformDataCueValue::Data, locale)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebCore::SerializedPlatformDataCueValue::Data, value)
#endif
    >::value);

#if PLATFORM(COCOA)
    encoder << instance.type;
#endif
#if PLATFORM(COCOA)
    encoder << instance.otherAttributes;
#endif
#if PLATFORM(COCOA)
    encoder << instance.key;
#endif
#if PLATFORM(COCOA)
    encoder << instance.locale;
#endif
#if PLATFORM(COCOA)
    encoder << instance.value;
#endif
}

std::optional<WebCore::SerializedPlatformDataCueValue::Data> ArgumentCoder<WebCore::SerializedPlatformDataCueValue::Data>::decode(Decoder& decoder)
{
#if PLATFORM(COCOA)
    auto type = decoder.decode<String>();
#endif
#if PLATFORM(COCOA)
    auto otherAttributes = decoder.decode<HashMap<String, String>>();
#endif
#if PLATFORM(COCOA)
    auto key = decoder.decode<String>();
#endif
#if PLATFORM(COCOA)
    auto locale = decoder.decode<RetainPtr<NSLocale>>();
#endif
#if PLATFORM(COCOA)
    auto value = decoder.decode<Variant<std::nullptr_t, RetainPtr<NSString>, RetainPtr<NSDate>, RetainPtr<NSNumber>, RetainPtr<NSData>>>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::SerializedPlatformDataCueValue::Data {
#if PLATFORM(COCOA)
            WTFMove(*type),
#endif
#if PLATFORM(COCOA)
            WTFMove(*otherAttributes),
#endif
#if PLATFORM(COCOA)
            WTFMove(*key),
#endif
#if PLATFORM(COCOA)
            WTFMove(*locale),
#endif
#if PLATFORM(COCOA)
            WTFMove(*value)
#endif
        }
    };
}

#endif

void ArgumentCoder<WebCore::FragmentedSharedBuffer>::encode(Encoder& encoder, const WebCore::FragmentedSharedBuffer& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.toIPCData())>, Variant<std::optional<WebCore::SharedMemoryHandle>, Vector<std::span<const uint8_t>>>>);

    encoder << instance.toIPCData();
}

std::optional<Ref<WebCore::FragmentedSharedBuffer>> ArgumentCoder<WebCore::FragmentedSharedBuffer>::decode(Decoder& decoder)
{
    auto toIPCData = decoder.decode<Variant<std::optional<WebCore::SharedMemoryHandle>, Vector<std::span<const uint8_t>>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FragmentedSharedBuffer::fromIPCData(
            WTFMove(*toIPCData)
        )
    };
}

void ArgumentCoder<WebCore::PublicSuffix>::encode(Encoder& encoder, const WebCore::PublicSuffix& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.string())>, String>);

    encoder << instance.string();
}

std::optional<WebCore::PublicSuffix> ArgumentCoder<WebCore::PublicSuffix>::decode(Decoder& decoder)
{
    auto string = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PublicSuffix::fromRawString(
            WTFMove(*string)
        )
    };
}

void ArgumentCoder<WebCore::WrappedCryptoKey>::encode(Encoder& encoder, const WebCore::WrappedCryptoKey& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.wrappedKEK)>, std::array<uint8_t, 24>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.encryptedKey)>, Vector<uint8_t>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tag)>, std::array<uint8_t, 16>>);
    struct ShouldBeSameSizeAsWrappedCryptoKey : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::WrappedCryptoKey>, false> {
        std::array<uint8_t, 24> wrappedKEK;
        Vector<uint8_t> encryptedKey;
        std::array<uint8_t, 16> tag;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWrappedCryptoKey) == sizeof(WebCore::WrappedCryptoKey));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::WrappedCryptoKey, wrappedKEK)
        , offsetof(WebCore::WrappedCryptoKey, encryptedKey)
        , offsetof(WebCore::WrappedCryptoKey, tag)
    >::value);

    encoder << instance.wrappedKEK;
    encoder << instance.encryptedKey;
    encoder << instance.tag;
}

std::optional<WebCore::WrappedCryptoKey> ArgumentCoder<WebCore::WrappedCryptoKey>::decode(Decoder& decoder)
{
    auto wrappedKEK = decoder.decode<std::array<uint8_t, 24>>();
    auto encryptedKey = decoder.decode<Vector<uint8_t>>();
    auto tag = decoder.decode<std::array<uint8_t, 16>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::WrappedCryptoKey {
            WTFMove(*wrappedKEK),
            WTFMove(*encryptedKey),
            WTFMove(*tag)
        }
    };
}

void ArgumentCoder<WebCore::Allowlist::AllowAllOrigins>::encode(Encoder& encoder, const WebCore::Allowlist::AllowAllOrigins& instance)
{
    struct ShouldBeSameSizeAsAllowAllOrigins : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::Allowlist::AllowAllOrigins>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsAllowAllOrigins) == sizeof(WebCore::Allowlist::AllowAllOrigins));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::Allowlist::AllowAllOrigins> ArgumentCoder<WebCore::Allowlist::AllowAllOrigins>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Allowlist::AllowAllOrigins {
        }
    };
}

void ArgumentCoder<WebCore::Allowlist>::encode(Encoder& encoder, const WebCore::Allowlist& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.origins())>, Variant<HashSet<WebCore::SecurityOriginData>, WebCore::Allowlist::AllowAllOrigins>>);

    encoder << instance.origins();
}

std::optional<WebCore::Allowlist> ArgumentCoder<WebCore::Allowlist>::decode(Decoder& decoder)
{
    auto origins = decoder.decode<Variant<HashSet<WebCore::SecurityOriginData>, WebCore::Allowlist::AllowAllOrigins>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Allowlist {
            WTFMove(*origins)
        }
    };
}

void ArgumentCoder<WebCore::OwnerPermissionsPolicyData>::encode(Encoder& encoder, const WebCore::OwnerPermissionsPolicyData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.documentOrigin)>, WebCore::SecurityOriginData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.documentPolicy)>, WebCore::PermissionsPolicy>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.containerPolicy)>, WebCore::OwnerPermissionsPolicyData::PolicyDirective>);
    struct ShouldBeSameSizeAsOwnerPermissionsPolicyData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::OwnerPermissionsPolicyData>, false> {
        WebCore::SecurityOriginData documentOrigin;
        WebCore::PermissionsPolicy documentPolicy;
        WebCore::OwnerPermissionsPolicyData::PolicyDirective containerPolicy;
    };
    static_assert(sizeof(ShouldBeSameSizeAsOwnerPermissionsPolicyData) == sizeof(WebCore::OwnerPermissionsPolicyData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::OwnerPermissionsPolicyData, documentOrigin)
        , offsetof(WebCore::OwnerPermissionsPolicyData, documentPolicy)
        , offsetof(WebCore::OwnerPermissionsPolicyData, containerPolicy)
    >::value);

    encoder << instance.documentOrigin;
    encoder << instance.documentPolicy;
    encoder << instance.containerPolicy;
}

std::optional<WebCore::OwnerPermissionsPolicyData> ArgumentCoder<WebCore::OwnerPermissionsPolicyData>::decode(Decoder& decoder)
{
    auto documentOrigin = decoder.decode<WebCore::SecurityOriginData>();
    auto documentPolicy = decoder.decode<WebCore::PermissionsPolicy>();
    auto containerPolicy = decoder.decode<WebCore::OwnerPermissionsPolicyData::PolicyDirective>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::OwnerPermissionsPolicyData {
            WTFMove(*documentOrigin),
            WTFMove(*documentPolicy),
            WTFMove(*containerPolicy)
        }
    };
}

void ArgumentCoder<WebCore::PermissionsPolicy>::encode(Encoder& encoder, const WebCore::PermissionsPolicy& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.inheritedPolicy())>, WebCore::PermissionsPolicy::InheritedPolicy>);

    encoder << instance.inheritedPolicy();
}

std::optional<WebCore::PermissionsPolicy> ArgumentCoder<WebCore::PermissionsPolicy>::decode(Decoder& decoder)
{
    auto inheritedPolicy = decoder.decode<WebCore::PermissionsPolicy::InheritedPolicy>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::PermissionsPolicy {
            WTFMove(*inheritedPolicy)
        }
    };
}

void ArgumentCoder<WebCore::ImageBufferResourceLimits>::encode(Encoder& encoder, const WebCore::ImageBufferResourceLimits& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.acceleratedImageBufferForCanvasCount)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.acceleratedImageBufferForCanvasLimit)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.globalAcceleratedImageBufferCount)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.globalAcceleratedImageBufferLimit)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.globalImageBufferForCanvasCount)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.globalImageBufferForCanvasLimit)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.imageBufferForCanvasCount)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.imageBufferForCanvasLimit)>, uint64_t>);
    struct ShouldBeSameSizeAsImageBufferResourceLimits : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ImageBufferResourceLimits>, false> {
        uint64_t acceleratedImageBufferForCanvasCount;
        uint64_t acceleratedImageBufferForCanvasLimit;
        uint64_t globalAcceleratedImageBufferCount;
        uint64_t globalAcceleratedImageBufferLimit;
        uint64_t globalImageBufferForCanvasCount;
        uint64_t globalImageBufferForCanvasLimit;
        uint64_t imageBufferForCanvasCount;
        uint64_t imageBufferForCanvasLimit;
    };
    static_assert(sizeof(ShouldBeSameSizeAsImageBufferResourceLimits) == sizeof(WebCore::ImageBufferResourceLimits));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ImageBufferResourceLimits, acceleratedImageBufferForCanvasCount)
        , offsetof(WebCore::ImageBufferResourceLimits, acceleratedImageBufferForCanvasLimit)
        , offsetof(WebCore::ImageBufferResourceLimits, globalAcceleratedImageBufferCount)
        , offsetof(WebCore::ImageBufferResourceLimits, globalAcceleratedImageBufferLimit)
        , offsetof(WebCore::ImageBufferResourceLimits, globalImageBufferForCanvasCount)
        , offsetof(WebCore::ImageBufferResourceLimits, globalImageBufferForCanvasLimit)
        , offsetof(WebCore::ImageBufferResourceLimits, imageBufferForCanvasCount)
        , offsetof(WebCore::ImageBufferResourceLimits, imageBufferForCanvasLimit)
    >::value);

    encoder << instance.acceleratedImageBufferForCanvasCount;
    encoder << instance.acceleratedImageBufferForCanvasLimit;
    encoder << instance.globalAcceleratedImageBufferCount;
    encoder << instance.globalAcceleratedImageBufferLimit;
    encoder << instance.globalImageBufferForCanvasCount;
    encoder << instance.globalImageBufferForCanvasLimit;
    encoder << instance.imageBufferForCanvasCount;
    encoder << instance.imageBufferForCanvasLimit;
}

std::optional<WebCore::ImageBufferResourceLimits> ArgumentCoder<WebCore::ImageBufferResourceLimits>::decode(Decoder& decoder)
{
    auto acceleratedImageBufferForCanvasCount = decoder.decode<uint64_t>();
    auto acceleratedImageBufferForCanvasLimit = decoder.decode<uint64_t>();
    auto globalAcceleratedImageBufferCount = decoder.decode<uint64_t>();
    auto globalAcceleratedImageBufferLimit = decoder.decode<uint64_t>();
    auto globalImageBufferForCanvasCount = decoder.decode<uint64_t>();
    auto globalImageBufferForCanvasLimit = decoder.decode<uint64_t>();
    auto imageBufferForCanvasCount = decoder.decode<uint64_t>();
    auto imageBufferForCanvasLimit = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ImageBufferResourceLimits {
            WTFMove(*acceleratedImageBufferForCanvasCount),
            WTFMove(*acceleratedImageBufferForCanvasLimit),
            WTFMove(*globalAcceleratedImageBufferCount),
            WTFMove(*globalAcceleratedImageBufferLimit),
            WTFMove(*globalImageBufferForCanvasCount),
            WTFMove(*globalImageBufferForCanvasLimit),
            WTFMove(*imageBufferForCanvasCount),
            WTFMove(*imageBufferForCanvasLimit)
        }
    };
}

void ArgumentCoder<WebCore::RsaOtherPrimesInfo>::encode(Encoder& encoder, const WebCore::RsaOtherPrimesInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.r)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.d)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.t)>, String>);
    struct ShouldBeSameSizeAsRsaOtherPrimesInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::RsaOtherPrimesInfo>, false> {
        String r;
        String d;
        String t;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRsaOtherPrimesInfo) == sizeof(WebCore::RsaOtherPrimesInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::RsaOtherPrimesInfo, r)
        , offsetof(WebCore::RsaOtherPrimesInfo, d)
        , offsetof(WebCore::RsaOtherPrimesInfo, t)
    >::value);

    encoder << instance.r;
    encoder << instance.d;
    encoder << instance.t;
}

std::optional<WebCore::RsaOtherPrimesInfo> ArgumentCoder<WebCore::RsaOtherPrimesInfo>::decode(Decoder& decoder)
{
    auto r = decoder.decode<String>();
    auto d = decoder.decode<String>();
    auto t = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::RsaOtherPrimesInfo {
            WTFMove(*r),
            WTFMove(*d),
            WTFMove(*t)
        }
    };
}

void ArgumentCoder<WebCore::JsonWebKey>::encode(Encoder& encoder, const WebCore::JsonWebKey& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.kty)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.use)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.key_ops)>, std::optional<Vector<WebCore::CryptoKeyUsage>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.usages)>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.alg)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ext)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.crv)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.x)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.y)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.d)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.n)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.e)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.p)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.q)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dp)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dq)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.qi)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.oth)>, std::optional<Vector<WebCore::RsaOtherPrimesInfo>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.k)>, String>);
    struct ShouldBeSameSizeAsJsonWebKey : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::JsonWebKey>, false> {
        String kty;
        String use;
        std::optional<Vector<WebCore::CryptoKeyUsage>> key_ops;
        int usages;
        String alg;
        std::optional<bool> ext;
        String crv;
        String x;
        String y;
        String d;
        String n;
        String e;
        String p;
        String q;
        String dp;
        String dq;
        String qi;
        std::optional<Vector<WebCore::RsaOtherPrimesInfo>> oth;
        String k;
    };
    static_assert(sizeof(ShouldBeSameSizeAsJsonWebKey) == sizeof(WebCore::JsonWebKey));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::JsonWebKey, kty)
        , offsetof(WebCore::JsonWebKey, use)
        , offsetof(WebCore::JsonWebKey, key_ops)
        , offsetof(WebCore::JsonWebKey, usages)
        , offsetof(WebCore::JsonWebKey, alg)
        , offsetof(WebCore::JsonWebKey, ext)
        , offsetof(WebCore::JsonWebKey, crv)
        , offsetof(WebCore::JsonWebKey, x)
        , offsetof(WebCore::JsonWebKey, y)
        , offsetof(WebCore::JsonWebKey, d)
        , offsetof(WebCore::JsonWebKey, n)
        , offsetof(WebCore::JsonWebKey, e)
        , offsetof(WebCore::JsonWebKey, p)
        , offsetof(WebCore::JsonWebKey, q)
        , offsetof(WebCore::JsonWebKey, dp)
        , offsetof(WebCore::JsonWebKey, dq)
        , offsetof(WebCore::JsonWebKey, qi)
        , offsetof(WebCore::JsonWebKey, oth)
        , offsetof(WebCore::JsonWebKey, k)
    >::value);

    encoder << instance.kty;
    encoder << instance.use;
    encoder << instance.key_ops;
    encoder << instance.usages;
    encoder << instance.alg;
    encoder << instance.ext;
    encoder << instance.crv;
    encoder << instance.x;
    encoder << instance.y;
    encoder << instance.d;
    encoder << instance.n;
    encoder << instance.e;
    encoder << instance.p;
    encoder << instance.q;
    encoder << instance.dp;
    encoder << instance.dq;
    encoder << instance.qi;
    encoder << instance.oth;
    encoder << instance.k;
}

std::optional<WebCore::JsonWebKey> ArgumentCoder<WebCore::JsonWebKey>::decode(Decoder& decoder)
{
    auto kty = decoder.decode<String>();
    auto use = decoder.decode<String>();
    auto key_ops = decoder.decode<std::optional<Vector<WebCore::CryptoKeyUsage>>>();
    auto usages = decoder.decode<int>();
    auto alg = decoder.decode<String>();
    auto ext = decoder.decode<std::optional<bool>>();
    auto crv = decoder.decode<String>();
    auto x = decoder.decode<String>();
    auto y = decoder.decode<String>();
    auto d = decoder.decode<String>();
    auto n = decoder.decode<String>();
    auto e = decoder.decode<String>();
    auto p = decoder.decode<String>();
    auto q = decoder.decode<String>();
    auto dp = decoder.decode<String>();
    auto dq = decoder.decode<String>();
    auto qi = decoder.decode<String>();
    auto oth = decoder.decode<std::optional<Vector<WebCore::RsaOtherPrimesInfo>>>();
    auto k = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::JsonWebKey {
            WTFMove(*kty),
            WTFMove(*use),
            WTFMove(*key_ops),
            WTFMove(*usages),
            WTFMove(*alg),
            WTFMove(*ext),
            WTFMove(*crv),
            WTFMove(*x),
            WTFMove(*y),
            WTFMove(*d),
            WTFMove(*n),
            WTFMove(*e),
            WTFMove(*p),
            WTFMove(*q),
            WTFMove(*dp),
            WTFMove(*dq),
            WTFMove(*qi),
            WTFMove(*oth),
            WTFMove(*k)
        }
    };
}

void ArgumentCoder<WebCore::CryptoKeyData>::encode(Encoder& encoder, const WebCore::CryptoKeyData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.keyClass)>, WebCore::CryptoKeyClass>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.algorithmIdentifier)>, WebCore::CryptoAlgorithmIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.extractable)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.usages)>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.key)>, std::optional<Vector<uint8_t>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.jwk)>, std::optional<WebCore::JsonWebKey>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hashAlgorithmIdentifier)>, std::optional<WebCore::CryptoAlgorithmIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.namedCurveString)>, std::optional<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lengthBits)>, std::optional<uint64_t>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, std::optional<WebCore::CryptoKeyType>>);
    struct ShouldBeSameSizeAsCryptoKeyData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::CryptoKeyData>, false> {
        WebCore::CryptoKeyClass keyClass;
        WebCore::CryptoAlgorithmIdentifier algorithmIdentifier;
        bool extractable;
        int usages;
        std::optional<Vector<uint8_t>> key;
        std::optional<WebCore::JsonWebKey> jwk;
        std::optional<WebCore::CryptoAlgorithmIdentifier> hashAlgorithmIdentifier;
        std::optional<String> namedCurveString;
        std::optional<uint64_t> lengthBits;
        std::optional<WebCore::CryptoKeyType> type;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCryptoKeyData) == sizeof(WebCore::CryptoKeyData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::CryptoKeyData, keyClass)
        , offsetof(WebCore::CryptoKeyData, algorithmIdentifier)
        , offsetof(WebCore::CryptoKeyData, extractable)
        , offsetof(WebCore::CryptoKeyData, usages)
        , offsetof(WebCore::CryptoKeyData, key)
        , offsetof(WebCore::CryptoKeyData, jwk)
        , offsetof(WebCore::CryptoKeyData, hashAlgorithmIdentifier)
        , offsetof(WebCore::CryptoKeyData, namedCurveString)
        , offsetof(WebCore::CryptoKeyData, lengthBits)
        , offsetof(WebCore::CryptoKeyData, type)
    >::value);

    encoder << instance.keyClass;
    encoder << instance.algorithmIdentifier;
    encoder << instance.extractable;
    encoder << instance.usages;
    encoder << instance.key;
    encoder << instance.jwk;
    encoder << instance.hashAlgorithmIdentifier;
    encoder << instance.namedCurveString;
    encoder << instance.lengthBits;
    encoder << instance.type;
}

std::optional<WebCore::CryptoKeyData> ArgumentCoder<WebCore::CryptoKeyData>::decode(Decoder& decoder)
{
    auto keyClass = decoder.decode<WebCore::CryptoKeyClass>();
    auto algorithmIdentifier = decoder.decode<WebCore::CryptoAlgorithmIdentifier>();
    auto extractable = decoder.decode<bool>();
    auto usages = decoder.decode<int>();
    auto key = decoder.decode<std::optional<Vector<uint8_t>>>();
    auto jwk = decoder.decode<std::optional<WebCore::JsonWebKey>>();
    auto hashAlgorithmIdentifier = decoder.decode<std::optional<WebCore::CryptoAlgorithmIdentifier>>();
    auto namedCurveString = decoder.decode<std::optional<String>>();
    auto lengthBits = decoder.decode<std::optional<uint64_t>>();
    auto type = decoder.decode<std::optional<WebCore::CryptoKeyType>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CryptoKeyData {
            WTFMove(*keyClass),
            WTFMove(*algorithmIdentifier),
            WTFMove(*extractable),
            WTFMove(*usages),
            WTFMove(*key),
            WTFMove(*jwk),
            WTFMove(*hashAlgorithmIdentifier),
            WTFMove(*namedCurveString),
            WTFMove(*lengthBits),
            WTFMove(*type)
        }
    };
}

void ArgumentCoder<WebCore::MediaSamplesBlock::MediaSampleItem>::encode(Encoder& encoder, const WebCore::MediaSamplesBlock::MediaSampleItem& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.presentationTime)>, MediaTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.decodeTime)>, MediaTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.duration)>, MediaTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.trimInterval)>, std::pair<MediaTime, MediaTime>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data)>, RefPtr<WebCore::FragmentedSharedBuffer>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hdrMetadata)>, RefPtr<WebCore::SharedBuffer>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hdrMetadataType)>, std::optional<WebCore::HdrMetadataType>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.flags)>, uint32_t>);
    struct ShouldBeSameSizeAsMediaSampleItem : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MediaSamplesBlock::MediaSampleItem>, false> {
        MediaTime presentationTime;
        MediaTime decodeTime;
        MediaTime duration;
        std::pair<MediaTime, MediaTime> trimInterval;
        RefPtr<WebCore::FragmentedSharedBuffer> data;
        RefPtr<WebCore::SharedBuffer> hdrMetadata;
        std::optional<WebCore::HdrMetadataType> hdrMetadataType;
        uint32_t flags;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMediaSampleItem) == sizeof(WebCore::MediaSamplesBlock::MediaSampleItem));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MediaSamplesBlock::MediaSampleItem, presentationTime)
        , offsetof(WebCore::MediaSamplesBlock::MediaSampleItem, decodeTime)
        , offsetof(WebCore::MediaSamplesBlock::MediaSampleItem, duration)
        , offsetof(WebCore::MediaSamplesBlock::MediaSampleItem, trimInterval)
        , offsetof(WebCore::MediaSamplesBlock::MediaSampleItem, data)
        , offsetof(WebCore::MediaSamplesBlock::MediaSampleItem, hdrMetadata)
        , offsetof(WebCore::MediaSamplesBlock::MediaSampleItem, hdrMetadataType)
        , offsetof(WebCore::MediaSamplesBlock::MediaSampleItem, flags)
    >::value);

    encoder << instance.presentationTime;
    encoder << instance.decodeTime;
    encoder << instance.duration;
    encoder << instance.trimInterval;
    encoder << instance.data;
    encoder << instance.hdrMetadata;
    encoder << instance.hdrMetadataType;
    encoder << instance.flags;
}

std::optional<WebCore::MediaSamplesBlock::MediaSampleItem> ArgumentCoder<WebCore::MediaSamplesBlock::MediaSampleItem>::decode(Decoder& decoder)
{
    auto presentationTime = decoder.decode<MediaTime>();
    auto decodeTime = decoder.decode<MediaTime>();
    auto duration = decoder.decode<MediaTime>();
    auto trimInterval = decoder.decode<std::pair<MediaTime, MediaTime>>();
    auto data = decoder.decode<RefPtr<WebCore::FragmentedSharedBuffer>>();
    auto hdrMetadata = decoder.decode<RefPtr<WebCore::SharedBuffer>>();
    auto hdrMetadataType = decoder.decode<std::optional<WebCore::HdrMetadataType>>();
    auto flags = decoder.decode<uint32_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MediaSamplesBlock::MediaSampleItem {
            WTFMove(*presentationTime),
            WTFMove(*decodeTime),
            WTFMove(*duration),
            WTFMove(*trimInterval),
            WTFMove(*data),
            WTFMove(*hdrMetadata),
            WTFMove(*hdrMetadataType),
            WTFMove(*flags)
        }
    };
}

void ArgumentCoder<WebCore::RectEdges<WebCore::FixedContainerEdge>>::encode(Encoder& encoder, const WebCore::RectEdges<WebCore::FixedContainerEdge>& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.top())>, WebCore::FixedContainerEdge>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.right())>, WebCore::FixedContainerEdge>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bottom())>, WebCore::FixedContainerEdge>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.left())>, WebCore::FixedContainerEdge>);

    encoder << instance.top();
    encoder << instance.right();
    encoder << instance.bottom();
    encoder << instance.left();
}

std::optional<WebCore::RectEdges<WebCore::FixedContainerEdge>> ArgumentCoder<WebCore::RectEdges<WebCore::FixedContainerEdge>>::decode(Decoder& decoder)
{
    auto top = decoder.decode<WebCore::FixedContainerEdge>();
    auto right = decoder.decode<WebCore::FixedContainerEdge>();
    auto bottom = decoder.decode<WebCore::FixedContainerEdge>();
    auto left = decoder.decode<WebCore::FixedContainerEdge>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::RectEdges<WebCore::FixedContainerEdge> {
            WTFMove(*top),
            WTFMove(*right),
            WTFMove(*bottom),
            WTFMove(*left)
        }
    };
}

void ArgumentCoder<WebCore::FixedContainerEdges>::encode(Encoder& encoder, const WebCore::FixedContainerEdges& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colors)>, WebCore::RectEdges<WebCore::FixedContainerEdge>>);
    struct ShouldBeSameSizeAsFixedContainerEdges : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FixedContainerEdges>, false> {
        WebCore::RectEdges<WebCore::FixedContainerEdge> colors;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFixedContainerEdges) == sizeof(WebCore::FixedContainerEdges));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FixedContainerEdges, colors)
    >::value);

    encoder << instance.colors;
}

std::optional<WebCore::FixedContainerEdges> ArgumentCoder<WebCore::FixedContainerEdges>::decode(Decoder& decoder)
{
    auto colors = decoder.decode<WebCore::RectEdges<WebCore::FixedContainerEdge>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FixedContainerEdges {
            WTFMove(*colors)
        }
    };
}

void ArgumentCoder<WebCore::MessageForTesting>::encode(Encoder& encoder, const WebCore::MessageForTesting& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, AtomString>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data)>, String>);
    struct ShouldBeSameSizeAsMessageForTesting : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::MessageForTesting>, false> {
        AtomString type;
        String data;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMessageForTesting) == sizeof(WebCore::MessageForTesting));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::MessageForTesting, type)
        , offsetof(WebCore::MessageForTesting, data)
    >::value);

    encoder << instance.type;
    encoder << instance.data;
}

std::optional<WebCore::MessageForTesting> ArgumentCoder<WebCore::MessageForTesting>::decode(Decoder& decoder)
{
    auto type = decoder.decode<AtomString>();
    auto data = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::MessageForTesting {
            WTFMove(*type),
            WTFMove(*data)
        }
    };
}

void ArgumentCoder<WebCore::HostingContext>::encode(Encoder& encoder, const WebCore::HostingContext& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contextID)>, uint32_t>);
#if ENABLE(MACH_PORT_LAYER_HOSTING)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sendRightAnnotated)>, WTF::MachSendRightAnnotated>);
#endif
    struct ShouldBeSameSizeAsHostingContext : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::HostingContext>, false> {
        uint32_t contextID;
#if ENABLE(MACH_PORT_LAYER_HOSTING)
        WTF::MachSendRightAnnotated sendRightAnnotated;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsHostingContext) == sizeof(WebCore::HostingContext));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::HostingContext, contextID)
#if ENABLE(MACH_PORT_LAYER_HOSTING)
        , offsetof(WebCore::HostingContext, sendRightAnnotated)
#endif
    >::value);

    encoder << instance.contextID;
#if ENABLE(MACH_PORT_LAYER_HOSTING)
    encoder << instance.sendRightAnnotated;
#endif
}

std::optional<WebCore::HostingContext> ArgumentCoder<WebCore::HostingContext>::decode(Decoder& decoder)
{
    auto contextID = decoder.decode<uint32_t>();
#if ENABLE(MACH_PORT_LAYER_HOSTING)
    auto sendRightAnnotated = decoder.decode<WTF::MachSendRightAnnotated>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::HostingContext {
            WTFMove(*contextID),
#if ENABLE(MACH_PORT_LAYER_HOSTING)
            WTFMove(*sendRightAnnotated)
#endif
        }
    };
}

void ArgumentCoder<WebCore::FocusEventData>::encode(Encoder& encoder, const WebCore::FocusEventData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, AtomString>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.keyIdentifier)>, AtomString>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.altKey)>, bool>);
    struct ShouldBeSameSizeAsFocusEventData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FocusEventData>, false> {
        AtomString type;
        AtomString keyIdentifier;
        bool altKey;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFocusEventData) == sizeof(WebCore::FocusEventData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FocusEventData, type)
        , offsetof(WebCore::FocusEventData, keyIdentifier)
        , offsetof(WebCore::FocusEventData, altKey)
    >::value);

    encoder << instance.type;
    encoder << instance.keyIdentifier;
    encoder << instance.altKey;
}

std::optional<WebCore::FocusEventData> ArgumentCoder<WebCore::FocusEventData>::decode(Decoder& decoder)
{
    auto type = decoder.decode<AtomString>();
    auto keyIdentifier = decoder.decode<AtomString>();
    auto altKey = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FocusEventData {
            WTFMove(*type),
            WTFMove(*keyIdentifier),
            WTFMove(*altKey)
        }
    };
}

void ArgumentCoder<WebCore::AXDebugInfo>::encode(Encoder& encoder, const WebCore::AXDebugInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isAccessibilityEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isAccessibilityThreadInitialized)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.liveTree)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isolatedTree)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.remoteTokenHash)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webProcessLocalTokenHash)>, uint64_t>);
    struct ShouldBeSameSizeAsAXDebugInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::AXDebugInfo>, false> {
        bool isAccessibilityEnabled;
        bool isAccessibilityThreadInitialized;
        String liveTree;
        String isolatedTree;
        uint64_t remoteTokenHash;
        uint64_t webProcessLocalTokenHash;
    };
    static_assert(sizeof(ShouldBeSameSizeAsAXDebugInfo) == sizeof(WebCore::AXDebugInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::AXDebugInfo, isAccessibilityEnabled)
        , offsetof(WebCore::AXDebugInfo, isAccessibilityThreadInitialized)
        , offsetof(WebCore::AXDebugInfo, liveTree)
        , offsetof(WebCore::AXDebugInfo, isolatedTree)
        , offsetof(WebCore::AXDebugInfo, remoteTokenHash)
        , offsetof(WebCore::AXDebugInfo, webProcessLocalTokenHash)
    >::value);

    encoder << instance.isAccessibilityEnabled;
    encoder << instance.isAccessibilityThreadInitialized;
    encoder << instance.liveTree;
    encoder << instance.isolatedTree;
    encoder << instance.remoteTokenHash;
    encoder << instance.webProcessLocalTokenHash;
}

std::optional<WebCore::AXDebugInfo> ArgumentCoder<WebCore::AXDebugInfo>::decode(Decoder& decoder)
{
    auto isAccessibilityEnabled = decoder.decode<bool>();
    auto isAccessibilityThreadInitialized = decoder.decode<bool>();
    auto liveTree = decoder.decode<String>();
    auto isolatedTree = decoder.decode<String>();
    auto remoteTokenHash = decoder.decode<uint64_t>();
    auto webProcessLocalTokenHash = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::AXDebugInfo {
            WTFMove(*isAccessibilityEnabled),
            WTFMove(*isAccessibilityThreadInitialized),
            WTFMove(*liveTree),
            WTFMove(*isolatedTree),
            WTFMove(*remoteTokenHash),
            WTFMove(*webProcessLocalTokenHash)
        }
    };
}

void ArgumentCoder<WebCore::Font>::encode(Encoder& encoder, const WebCore::Font& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.attributes())>, WebCore::FontInternalAttributes>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.platformData())>, WebCore::FontPlatformData>);

    encoder << instance.attributes();
    encoder << instance.platformData();
}

std::optional<Ref<WebCore::Font>> ArgumentCoder<WebCore::Font>::decode(Decoder& decoder)
{
    auto attributes = decoder.decode<WebCore::FontInternalAttributes>();
    auto platformData = decoder.decode<WebCore::FontPlatformData>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::Font::create(
            WTFMove(*attributes),
            WTFMove(*platformData)
        )
    };
}

void ArgumentCoder<WebCore::FontPlatformData>::encode(Encoder& encoder, const WebCore::FontPlatformData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.orientation())>, WebCore::FontOrientation>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.widthVariant())>, WebCore::FontWidthVariant>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.textRenderingMode())>, WebCore::TextRenderingMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.syntheticBold())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.syntheticOblique())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.toIPCData())>, WebCore::FontPlatformData::IPCData>);

    encoder << instance.size();
    encoder << instance.orientation();
    encoder << instance.widthVariant();
    encoder << instance.textRenderingMode();
    encoder << instance.syntheticBold();
    encoder << instance.syntheticOblique();
    encoder << instance.toIPCData();
}

std::optional<WebCore::FontPlatformData> ArgumentCoder<WebCore::FontPlatformData>::decode(Decoder& decoder)
{
    auto size = decoder.decode<float>();
    auto orientation = decoder.decode<WebCore::FontOrientation>();
    auto widthVariant = decoder.decode<WebCore::FontWidthVariant>();
    auto textRenderingMode = decoder.decode<WebCore::TextRenderingMode>();
    auto syntheticBold = decoder.decode<bool>();
    auto syntheticOblique = decoder.decode<bool>();
    auto toIPCData = decoder.decode<WebCore::FontPlatformData::IPCData>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FontPlatformData::fromIPCData(
            WTFMove(*size),
            WTFMove(*orientation),
            WTFMove(*widthVariant),
            WTFMove(*textRenderingMode),
            WTFMove(*syntheticBold),
            WTFMove(*syntheticOblique),
            WTFMove(*toIPCData)
        )
    };
}

void ArgumentCoder<WebCore::FontPlatformDataAttributes>::encode(Encoder& encoder, const WebCore::FontPlatformDataAttributes& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_size)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_orientation)>, WebCore::FontOrientation>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_widthVariant)>, WebCore::FontWidthVariant>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_textRenderingMode)>, WebCore::TextRenderingMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_syntheticBold)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_syntheticOblique)>, bool>);
#if PLATFORM(WIN) && USE(CAIRO)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_font)>, LOGFONT>);
#endif
#if USE(CORE_TEXT)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_attributes)>, RetainPtr<CFDictionaryRef>>);
#endif
#if USE(CORE_TEXT)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_options)>, CTFontDescriptorOptions>);
#endif
#if USE(CORE_TEXT)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_url)>, RetainPtr<CFStringRef>>);
#endif
#if USE(CORE_TEXT)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_psName)>, RetainPtr<CFStringRef>>);
#endif
#if USE(SKIA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_familyName)>, SkString>);
#endif
#if USE(SKIA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_style)>, SkFontStyle>);
#endif
#if USE(SKIA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_features)>, Vector<hb_feature_t>>);
#endif
    struct ShouldBeSameSizeAsFontPlatformDataAttributes : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FontPlatformDataAttributes>, false> {
        float m_size;
        WebCore::FontOrientation m_orientation;
        WebCore::FontWidthVariant m_widthVariant;
        WebCore::TextRenderingMode m_textRenderingMode;
        bool m_syntheticBold;
        bool m_syntheticOblique;
#if PLATFORM(WIN) && USE(CAIRO)
        LOGFONT m_font;
#endif
#if USE(CORE_TEXT)
        RetainPtr<CFDictionaryRef> m_attributes;
#endif
#if USE(CORE_TEXT)
        CTFontDescriptorOptions m_options;
#endif
#if USE(CORE_TEXT)
        RetainPtr<CFStringRef> m_url;
#endif
#if USE(CORE_TEXT)
        RetainPtr<CFStringRef> m_psName;
#endif
#if USE(SKIA)
        SkString m_familyName;
#endif
#if USE(SKIA)
        SkFontStyle m_style;
#endif
#if USE(SKIA)
        Vector<hb_feature_t> m_features;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsFontPlatformDataAttributes) == sizeof(WebCore::FontPlatformDataAttributes));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FontPlatformDataAttributes, m_size)
        , offsetof(WebCore::FontPlatformDataAttributes, m_orientation)
        , offsetof(WebCore::FontPlatformDataAttributes, m_widthVariant)
        , offsetof(WebCore::FontPlatformDataAttributes, m_textRenderingMode)
        , offsetof(WebCore::FontPlatformDataAttributes, m_syntheticBold)
        , offsetof(WebCore::FontPlatformDataAttributes, m_syntheticOblique)
#if PLATFORM(WIN) && USE(CAIRO)
        , offsetof(WebCore::FontPlatformDataAttributes, m_font)
#endif
#if USE(CORE_TEXT)
        , offsetof(WebCore::FontPlatformDataAttributes, m_attributes)
#endif
#if USE(CORE_TEXT)
        , offsetof(WebCore::FontPlatformDataAttributes, m_options)
#endif
#if USE(CORE_TEXT)
        , offsetof(WebCore::FontPlatformDataAttributes, m_url)
#endif
#if USE(CORE_TEXT)
        , offsetof(WebCore::FontPlatformDataAttributes, m_psName)
#endif
#if USE(SKIA)
        , offsetof(WebCore::FontPlatformDataAttributes, m_familyName)
#endif
#if USE(SKIA)
        , offsetof(WebCore::FontPlatformDataAttributes, m_style)
#endif
#if USE(SKIA)
        , offsetof(WebCore::FontPlatformDataAttributes, m_features)
#endif
    >::value);

    encoder << instance.m_size;
    encoder << instance.m_orientation;
    encoder << instance.m_widthVariant;
    encoder << instance.m_textRenderingMode;
    encoder << instance.m_syntheticBold;
    encoder << instance.m_syntheticOblique;
#if PLATFORM(WIN) && USE(CAIRO)
    encoder << instance.m_font;
#endif
#if USE(CORE_TEXT)
    encoder << instance.m_attributes;
#endif
#if USE(CORE_TEXT)
    encoder << instance.m_options;
#endif
#if USE(CORE_TEXT)
    encoder << instance.m_url;
#endif
#if USE(CORE_TEXT)
    encoder << instance.m_psName;
#endif
#if USE(SKIA)
    encoder << instance.m_familyName;
#endif
#if USE(SKIA)
    encoder << instance.m_style;
#endif
#if USE(SKIA)
    encoder << instance.m_features;
#endif
}

std::optional<WebCore::FontPlatformDataAttributes> ArgumentCoder<WebCore::FontPlatformDataAttributes>::decode(Decoder& decoder)
{
    auto m_size = decoder.decode<float>();
    auto m_orientation = decoder.decode<WebCore::FontOrientation>();
    auto m_widthVariant = decoder.decode<WebCore::FontWidthVariant>();
    auto m_textRenderingMode = decoder.decode<WebCore::TextRenderingMode>();
    auto m_syntheticBold = decoder.decode<bool>();
    auto m_syntheticOblique = decoder.decode<bool>();
#if PLATFORM(WIN) && USE(CAIRO)
    auto m_font = decoder.decode<LOGFONT>();
#endif
#if USE(CORE_TEXT)
    auto m_attributes = decoder.decode<RetainPtr<CFDictionaryRef>>();
#endif
#if USE(CORE_TEXT)
    auto m_options = decoder.decode<CTFontDescriptorOptions>();
#endif
#if USE(CORE_TEXT)
    auto m_url = decoder.decode<RetainPtr<CFStringRef>>();
#endif
#if USE(CORE_TEXT)
    auto m_psName = decoder.decode<RetainPtr<CFStringRef>>();
#endif
#if USE(SKIA)
    auto m_familyName = decoder.decode<SkString>();
#endif
#if USE(SKIA)
    auto m_style = decoder.decode<SkFontStyle>();
#endif
#if USE(SKIA)
    auto m_features = decoder.decode<Vector<hb_feature_t>>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FontPlatformDataAttributes {
            WTFMove(*m_size),
            WTFMove(*m_orientation),
            WTFMove(*m_widthVariant),
            WTFMove(*m_textRenderingMode),
            WTFMove(*m_syntheticBold),
            WTFMove(*m_syntheticOblique),
#if PLATFORM(WIN) && USE(CAIRO)
            WTFMove(*m_font),
#endif
#if USE(CORE_TEXT)
            WTFMove(*m_attributes),
#endif
#if USE(CORE_TEXT)
            WTFMove(*m_options),
#endif
#if USE(CORE_TEXT)
            WTFMove(*m_url),
#endif
#if USE(CORE_TEXT)
            WTFMove(*m_psName),
#endif
#if USE(SKIA)
            WTFMove(*m_familyName),
#endif
#if USE(SKIA)
            WTFMove(*m_style),
#endif
#if USE(SKIA)
            WTFMove(*m_features)
#endif
        }
    };
}

void ArgumentCoder<WebCore::FontCustomPlatformSerializedData>::encode(Encoder& encoder, const WebCore::FontCustomPlatformSerializedData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fontFaceData)>, Ref<WebCore::SharedBuffer>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.itemInCollection)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.renderingResourceIdentifier)>, WebCore::RenderingResourceIdentifier>);
    struct ShouldBeSameSizeAsFontCustomPlatformSerializedData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FontCustomPlatformSerializedData>, false> {
        Ref<WebCore::SharedBuffer> fontFaceData;
        String itemInCollection;
        WebCore::RenderingResourceIdentifier renderingResourceIdentifier;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFontCustomPlatformSerializedData) == sizeof(WebCore::FontCustomPlatformSerializedData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FontCustomPlatformSerializedData, fontFaceData)
        , offsetof(WebCore::FontCustomPlatformSerializedData, itemInCollection)
        , offsetof(WebCore::FontCustomPlatformSerializedData, renderingResourceIdentifier)
    >::value);

    encoder << instance.fontFaceData;
    encoder << instance.itemInCollection;
    encoder << instance.renderingResourceIdentifier;
}

std::optional<WebCore::FontCustomPlatformSerializedData> ArgumentCoder<WebCore::FontCustomPlatformSerializedData>::decode(Decoder& decoder)
{
    auto fontFaceData = decoder.decode<Ref<WebCore::SharedBuffer>>();
    auto itemInCollection = decoder.decode<String>();
    auto renderingResourceIdentifier = decoder.decode<WebCore::RenderingResourceIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FontCustomPlatformSerializedData {
            WTFMove(*fontFaceData),
            WTFMove(*itemInCollection),
            WTFMove(*renderingResourceIdentifier)
        }
    };
}

#if ENABLE(CONTENT_EXTENSIONS)
void ArgumentCoder<WebKit::WebCompiledContentRuleListData>::encode(Encoder& encoder, const WebKit::WebCompiledContentRuleListData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.createDataHandle())>, std::optional<WebCore::SharedMemoryHandle>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.actionsOffset)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.actionsSize)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.urlFiltersBytecodeOffset)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.urlFiltersBytecodeSize)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.topURLFiltersBytecodeOffset)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.topURLFiltersBytecodeSize)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameURLFiltersBytecodeOffset)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameURLFiltersBytecodeSize)>, uint64_t>);

    encoder << instance.identifier;
    encoder << instance.createDataHandle();
    encoder << instance.actionsOffset;
    encoder << instance.actionsSize;
    encoder << instance.urlFiltersBytecodeOffset;
    encoder << instance.urlFiltersBytecodeSize;
    encoder << instance.topURLFiltersBytecodeOffset;
    encoder << instance.topURLFiltersBytecodeSize;
    encoder << instance.frameURLFiltersBytecodeOffset;
    encoder << instance.frameURLFiltersBytecodeSize;
}

std::optional<WebKit::WebCompiledContentRuleListData> ArgumentCoder<WebKit::WebCompiledContentRuleListData>::decode(Decoder& decoder)
{
    bool addedDecodingFailureIndex = false;
    auto identifier = decoder.decode<String>();
    if (!identifier && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(0);
        addedDecodingFailureIndex = true;
    }
    auto createDataHandle = decoder.decode<std::optional<WebCore::SharedMemoryHandle>>();
    if (!createDataHandle && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(1);
        addedDecodingFailureIndex = true;
    }
    auto actionsOffset = decoder.decode<uint64_t>();
    if (!actionsOffset && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(2);
        addedDecodingFailureIndex = true;
    }
    auto actionsSize = decoder.decode<uint64_t>();
    if (!actionsSize && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(3);
        addedDecodingFailureIndex = true;
    }
    auto urlFiltersBytecodeOffset = decoder.decode<uint64_t>();
    if (!urlFiltersBytecodeOffset && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(4);
        addedDecodingFailureIndex = true;
    }
    auto urlFiltersBytecodeSize = decoder.decode<uint64_t>();
    if (!urlFiltersBytecodeSize && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(5);
        addedDecodingFailureIndex = true;
    }
    auto topURLFiltersBytecodeOffset = decoder.decode<uint64_t>();
    if (!topURLFiltersBytecodeOffset && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(6);
        addedDecodingFailureIndex = true;
    }
    auto topURLFiltersBytecodeSize = decoder.decode<uint64_t>();
    if (!topURLFiltersBytecodeSize && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(7);
        addedDecodingFailureIndex = true;
    }
    auto frameURLFiltersBytecodeOffset = decoder.decode<uint64_t>();
    if (!frameURLFiltersBytecodeOffset && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(8);
        addedDecodingFailureIndex = true;
    }
    auto frameURLFiltersBytecodeSize = decoder.decode<uint64_t>();
    if (!frameURLFiltersBytecodeSize && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(9);
        addedDecodingFailureIndex = true;
    }
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebCompiledContentRuleListData {
            WTFMove(*identifier),
            WTFMove(*createDataHandle),
            WTFMove(*actionsOffset),
            WTFMove(*actionsSize),
            WTFMove(*urlFiltersBytecodeOffset),
            WTFMove(*urlFiltersBytecodeSize),
            WTFMove(*topURLFiltersBytecodeOffset),
            WTFMove(*topURLFiltersBytecodeSize),
            WTFMove(*frameURLFiltersBytecodeOffset),
            WTFMove(*frameURLFiltersBytecodeSize)
        }
    };
}

#endif

void ArgumentCoder<WebKit::WebEvent>::encode(Encoder& encoder, const WebKit::WebEvent& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebKit::WebEventType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.modifiers())>, OptionSet<WebKit::WebEventModifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timestamp())>, WallTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.authorizationToken())>, WTF::UUID>);

    encoder << instance.type();
    encoder << instance.modifiers();
    encoder << instance.timestamp();
    encoder << instance.authorizationToken();
}

std::optional<WebKit::WebEvent> ArgumentCoder<WebKit::WebEvent>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebKit::WebEventType>();
    auto modifiers = decoder.decode<OptionSet<WebKit::WebEventModifier>>();
    auto timestamp = decoder.decode<WallTime>();
    auto authorizationToken = decoder.decode<WTF::UUID>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebEvent {
            WTFMove(*type),
            WTFMove(*modifiers),
            WTFMove(*timestamp),
            WTFMove(*authorizationToken)
        }
    };
}

void ArgumentCoder<WebKit::WebKeyboardEvent>::encode(Encoder& encoder, const WebKit::WebKeyboardEvent& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebKit::WebEventType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.modifiers())>, OptionSet<WebKit::WebEventModifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timestamp())>, WallTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.authorizationToken())>, WTF::UUID>);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.text())>, String>);
#if !PLATFORM(GTK) && !USE(LIBWPE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.unmodifiedText())>, String>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.key())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.code())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.keyIdentifier())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.windowsVirtualKeyCode())>, int32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.nativeVirtualKeyCode())>, int32_t>);
#if !PLATFORM(GTK) && !USE(LIBWPE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.macCharCode())>, int32_t>);
#endif
#if USE(APPKIT) || PLATFORM(IOS_FAMILY) || PLATFORM(GTK) || USE(LIBWPE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.handledByInputMethod())>, bool>);
#endif
#if PLATFORM(GTK) || USE(LIBWPE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.preeditUnderlines())>, std::optional<Vector<WebCore::CompositionUnderline>>>);
#endif
#if PLATFORM(GTK) || USE(LIBWPE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.preeditSelectionRange())>, std::optional<WebKit::EditingRange>>);
#endif
#if USE(APPKIT)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.commands())>, Vector<WebCore::KeypressCommand>>);
#endif
#if !USE(APPKIT) && PLATFORM(GTK)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.commands())>, Vector<String>>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isAutoRepeat())>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isKeypad())>, bool>);
#if !PLATFORM(GTK) && !USE(LIBWPE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isSystemKey())>, bool>);
#endif

    encoder << instance.type();
    encoder << instance.modifiers();
    encoder << instance.timestamp();
    encoder << instance.authorizationToken();
    encoder << instance.text();
#if !PLATFORM(GTK) && !USE(LIBWPE)
    encoder << instance.unmodifiedText();
#endif
    encoder << instance.key();
    encoder << instance.code();
    encoder << instance.keyIdentifier();
    encoder << instance.windowsVirtualKeyCode();
    encoder << instance.nativeVirtualKeyCode();
#if !PLATFORM(GTK) && !USE(LIBWPE)
    encoder << instance.macCharCode();
#endif
#if USE(APPKIT) || PLATFORM(IOS_FAMILY) || PLATFORM(GTK) || USE(LIBWPE)
    encoder << instance.handledByInputMethod();
#endif
#if PLATFORM(GTK) || USE(LIBWPE)
    encoder << instance.preeditUnderlines();
#endif
#if PLATFORM(GTK) || USE(LIBWPE)
    encoder << instance.preeditSelectionRange();
#endif
#if USE(APPKIT)
    encoder << instance.commands();
#endif
#if !USE(APPKIT) && PLATFORM(GTK)
    encoder << instance.commands();
#endif
    encoder << instance.isAutoRepeat();
    encoder << instance.isKeypad();
#if !PLATFORM(GTK) && !USE(LIBWPE)
    encoder << instance.isSystemKey();
#endif
}

std::optional<WebKit::WebKeyboardEvent> ArgumentCoder<WebKit::WebKeyboardEvent>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebKit::WebEventType>();
    auto modifiers = decoder.decode<OptionSet<WebKit::WebEventModifier>>();
    auto timestamp = decoder.decode<WallTime>();
    auto authorizationToken = decoder.decode<WTF::UUID>();
    auto text = decoder.decode<String>();
#if !PLATFORM(GTK) && !USE(LIBWPE)
    auto unmodifiedText = decoder.decode<String>();
#endif
    auto key = decoder.decode<String>();
    auto code = decoder.decode<String>();
    auto keyIdentifier = decoder.decode<String>();
    auto windowsVirtualKeyCode = decoder.decode<int32_t>();
    auto nativeVirtualKeyCode = decoder.decode<int32_t>();
#if !PLATFORM(GTK) && !USE(LIBWPE)
    auto macCharCode = decoder.decode<int32_t>();
#endif
#if USE(APPKIT) || PLATFORM(IOS_FAMILY) || PLATFORM(GTK) || USE(LIBWPE)
    auto handledByInputMethod = decoder.decode<bool>();
#endif
#if PLATFORM(GTK) || USE(LIBWPE)
    auto preeditUnderlines = decoder.decode<std::optional<Vector<WebCore::CompositionUnderline>>>();
#endif
#if PLATFORM(GTK) || USE(LIBWPE)
    auto preeditSelectionRange = decoder.decode<std::optional<WebKit::EditingRange>>();
#endif
#if USE(APPKIT)
    auto commands = decoder.decode<Vector<WebCore::KeypressCommand>>();
#endif
#if !USE(APPKIT) && PLATFORM(GTK)
    auto commands = decoder.decode<Vector<String>>();
#endif
    auto isAutoRepeat = decoder.decode<bool>();
    auto isKeypad = decoder.decode<bool>();
#if !PLATFORM(GTK) && !USE(LIBWPE)
    auto isSystemKey = decoder.decode<bool>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebKeyboardEvent {
            WebKit::WebEvent {
                WTFMove(*type),
                WTFMove(*modifiers),
                WTFMove(*timestamp),
                WTFMove(*authorizationToken)
            },
            WTFMove(*text),
#if !PLATFORM(GTK) && !USE(LIBWPE)
            WTFMove(*unmodifiedText),
#endif
            WTFMove(*key),
            WTFMove(*code),
            WTFMove(*keyIdentifier),
            WTFMove(*windowsVirtualKeyCode),
            WTFMove(*nativeVirtualKeyCode),
#if !PLATFORM(GTK) && !USE(LIBWPE)
            WTFMove(*macCharCode),
#endif
#if USE(APPKIT) || PLATFORM(IOS_FAMILY) || PLATFORM(GTK) || USE(LIBWPE)
            WTFMove(*handledByInputMethod),
#endif
#if PLATFORM(GTK) || USE(LIBWPE)
            WTFMove(*preeditUnderlines),
#endif
#if PLATFORM(GTK) || USE(LIBWPE)
            WTFMove(*preeditSelectionRange),
#endif
#if USE(APPKIT)
            WTFMove(*commands),
#endif
#if !USE(APPKIT) && PLATFORM(GTK)
            WTFMove(*commands),
#endif
            WTFMove(*isAutoRepeat),
            WTFMove(*isKeypad),
#if !PLATFORM(GTK) && !USE(LIBWPE)
            WTFMove(*isSystemKey)
#endif
        }
    };
}

#if ENABLE(TOUCH_EVENTS)
void ArgumentCoder<WebKit::WebTouchEvent>::encode(Encoder& encoder, const WebKit::WebTouchEvent& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebKit::WebEventType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.modifiers())>, OptionSet<WebKit::WebEventModifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timestamp())>, WallTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.authorizationToken())>, WTF::UUID>);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.touchPoints())>, Vector<WebKit::WebPlatformTouchPoint>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.coalescedEvents())>, Vector<WebKit::WebTouchEvent>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.predictedEvents())>, Vector<WebKit::WebTouchEvent>>);
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.position())>, WebCore::IntPoint>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isPotentialTap())>, bool>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isGesture())>, bool>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.gestureScale())>, float>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.gestureRotation())>, float>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.canPreventNativeGestures())>, bool>);
#endif

    encoder << instance.type();
    encoder << instance.modifiers();
    encoder << instance.timestamp();
    encoder << instance.authorizationToken();
    encoder << instance.touchPoints();
    encoder << instance.coalescedEvents();
    encoder << instance.predictedEvents();
#if PLATFORM(IOS_FAMILY)
    encoder << instance.position();
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.isPotentialTap();
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.isGesture();
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.gestureScale();
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.gestureRotation();
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.canPreventNativeGestures();
#endif
}

std::optional<WebKit::WebTouchEvent> ArgumentCoder<WebKit::WebTouchEvent>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebKit::WebEventType>();
    auto modifiers = decoder.decode<OptionSet<WebKit::WebEventModifier>>();
    auto timestamp = decoder.decode<WallTime>();
    auto authorizationToken = decoder.decode<WTF::UUID>();
    auto touchPoints = decoder.decode<Vector<WebKit::WebPlatformTouchPoint>>();
    auto coalescedEvents = decoder.decode<Vector<WebKit::WebTouchEvent>>();
    auto predictedEvents = decoder.decode<Vector<WebKit::WebTouchEvent>>();
#if PLATFORM(IOS_FAMILY)
    auto position = decoder.decode<WebCore::IntPoint>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto isPotentialTap = decoder.decode<bool>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto isGesture = decoder.decode<bool>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto gestureScale = decoder.decode<float>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto gestureRotation = decoder.decode<float>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto canPreventNativeGestures = decoder.decode<bool>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebTouchEvent {
            WebKit::WebEvent {
                WTFMove(*type),
                WTFMove(*modifiers),
                WTFMove(*timestamp),
                WTFMove(*authorizationToken)
            },
            WTFMove(*touchPoints),
            WTFMove(*coalescedEvents),
            WTFMove(*predictedEvents),
#if PLATFORM(IOS_FAMILY)
            WTFMove(*position),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*isPotentialTap),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*isGesture),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*gestureScale),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*gestureRotation),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*canPreventNativeGestures)
#endif
        }
    };
}

#endif

#if ENABLE(TOUCH_EVENTS)
void ArgumentCoder<WebKit::WebPlatformTouchPoint>::encode(Encoder& encoder, const WebKit::WebPlatformTouchPoint& instance)
{
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier())>, unsigned>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.locationInRootView())>, WebCore::IntPoint>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.locationInViewport())>, WebCore::IntPoint>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.phase())>, WebKit::WebPlatformTouchPoint::State>);
#endif
#if PLATFORM(IOS_FAMILY) && ENABLE(IOS_TOUCH_EVENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radiusX())>, double>);
#endif
#if PLATFORM(IOS_FAMILY) && ENABLE(IOS_TOUCH_EVENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radiusY())>, double>);
#endif
#if PLATFORM(IOS_FAMILY) && ENABLE(IOS_TOUCH_EVENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rotationAngle())>, double>);
#endif
#if PLATFORM(IOS_FAMILY) && ENABLE(IOS_TOUCH_EVENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.force())>, double>);
#endif
#if PLATFORM(IOS_FAMILY) && ENABLE(IOS_TOUCH_EVENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.altitudeAngle())>, double>);
#endif
#if PLATFORM(IOS_FAMILY) && ENABLE(IOS_TOUCH_EVENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.azimuthAngle())>, double>);
#endif
#if PLATFORM(IOS_FAMILY) && ENABLE(IOS_TOUCH_EVENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.touchType())>, WebKit::WebPlatformTouchPoint::TouchType>);
#endif
#if !PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.id())>, uint32_t>);
#endif
#if !PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.state())>, WebKit::WebPlatformTouchPoint::State>);
#endif
#if !PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.screenPosition())>, WebCore::IntPoint>);
#endif
#if !PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.position())>, WebCore::IntPoint>);
#endif
#if !PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radius())>, WebCore::IntSize>);
#endif
#if !PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rotationAngle())>, float>);
#endif
#if !PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.force())>, float>);
#endif

#if PLATFORM(IOS_FAMILY)
    encoder << instance.identifier();
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.locationInRootView();
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.locationInViewport();
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << instance.phase();
#endif
#if PLATFORM(IOS_FAMILY) && ENABLE(IOS_TOUCH_EVENTS)
    encoder << instance.radiusX();
#endif
#if PLATFORM(IOS_FAMILY) && ENABLE(IOS_TOUCH_EVENTS)
    encoder << instance.radiusY();
#endif
#if PLATFORM(IOS_FAMILY) && ENABLE(IOS_TOUCH_EVENTS)
    encoder << instance.rotationAngle();
#endif
#if PLATFORM(IOS_FAMILY) && ENABLE(IOS_TOUCH_EVENTS)
    encoder << instance.force();
#endif
#if PLATFORM(IOS_FAMILY) && ENABLE(IOS_TOUCH_EVENTS)
    encoder << instance.altitudeAngle();
#endif
#if PLATFORM(IOS_FAMILY) && ENABLE(IOS_TOUCH_EVENTS)
    encoder << instance.azimuthAngle();
#endif
#if PLATFORM(IOS_FAMILY) && ENABLE(IOS_TOUCH_EVENTS)
    encoder << instance.touchType();
#endif
#if !PLATFORM(IOS_FAMILY)
    encoder << instance.id();
#endif
#if !PLATFORM(IOS_FAMILY)
    encoder << instance.state();
#endif
#if !PLATFORM(IOS_FAMILY)
    encoder << instance.screenPosition();
#endif
#if !PLATFORM(IOS_FAMILY)
    encoder << instance.position();
#endif
#if !PLATFORM(IOS_FAMILY)
    encoder << instance.radius();
#endif
#if !PLATFORM(IOS_FAMILY)
    encoder << instance.rotationAngle();
#endif
#if !PLATFORM(IOS_FAMILY)
    encoder << instance.force();
#endif
}

std::optional<WebKit::WebPlatformTouchPoint> ArgumentCoder<WebKit::WebPlatformTouchPoint>::decode(Decoder& decoder)
{
#if PLATFORM(IOS_FAMILY)
    auto identifier = decoder.decode<unsigned>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto locationInRootView = decoder.decode<WebCore::IntPoint>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto locationInViewport = decoder.decode<WebCore::IntPoint>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto phase = decoder.decode<WebKit::WebPlatformTouchPoint::State>();
#endif
#if PLATFORM(IOS_FAMILY) && ENABLE(IOS_TOUCH_EVENTS)
    auto radiusX = decoder.decode<double>();
#endif
#if PLATFORM(IOS_FAMILY) && ENABLE(IOS_TOUCH_EVENTS)
    auto radiusY = decoder.decode<double>();
#endif
#if PLATFORM(IOS_FAMILY) && ENABLE(IOS_TOUCH_EVENTS)
    auto rotationAngle = decoder.decode<double>();
#endif
#if PLATFORM(IOS_FAMILY) && ENABLE(IOS_TOUCH_EVENTS)
    auto force = decoder.decode<double>();
#endif
#if PLATFORM(IOS_FAMILY) && ENABLE(IOS_TOUCH_EVENTS)
    auto altitudeAngle = decoder.decode<double>();
#endif
#if PLATFORM(IOS_FAMILY) && ENABLE(IOS_TOUCH_EVENTS)
    auto azimuthAngle = decoder.decode<double>();
#endif
#if PLATFORM(IOS_FAMILY) && ENABLE(IOS_TOUCH_EVENTS)
    auto touchType = decoder.decode<WebKit::WebPlatformTouchPoint::TouchType>();
#endif
#if !PLATFORM(IOS_FAMILY)
    auto id = decoder.decode<uint32_t>();
#endif
#if !PLATFORM(IOS_FAMILY)
    auto state = decoder.decode<WebKit::WebPlatformTouchPoint::State>();
#endif
#if !PLATFORM(IOS_FAMILY)
    auto screenPosition = decoder.decode<WebCore::IntPoint>();
#endif
#if !PLATFORM(IOS_FAMILY)
    auto position = decoder.decode<WebCore::IntPoint>();
#endif
#if !PLATFORM(IOS_FAMILY)
    auto radius = decoder.decode<WebCore::IntSize>();
#endif
#if !PLATFORM(IOS_FAMILY)
    auto rotationAngle = decoder.decode<float>();
#endif
#if !PLATFORM(IOS_FAMILY)
    auto force = decoder.decode<float>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebPlatformTouchPoint {
#if PLATFORM(IOS_FAMILY)
            WTFMove(*identifier),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*locationInRootView),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*locationInViewport),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*phase),
#endif
#if PLATFORM(IOS_FAMILY) && ENABLE(IOS_TOUCH_EVENTS)
            WTFMove(*radiusX),
#endif
#if PLATFORM(IOS_FAMILY) && ENABLE(IOS_TOUCH_EVENTS)
            WTFMove(*radiusY),
#endif
#if PLATFORM(IOS_FAMILY) && ENABLE(IOS_TOUCH_EVENTS)
            WTFMove(*rotationAngle),
#endif
#if PLATFORM(IOS_FAMILY) && ENABLE(IOS_TOUCH_EVENTS)
            WTFMove(*force),
#endif
#if PLATFORM(IOS_FAMILY) && ENABLE(IOS_TOUCH_EVENTS)
            WTFMove(*altitudeAngle),
#endif
#if PLATFORM(IOS_FAMILY) && ENABLE(IOS_TOUCH_EVENTS)
            WTFMove(*azimuthAngle),
#endif
#if PLATFORM(IOS_FAMILY) && ENABLE(IOS_TOUCH_EVENTS)
            WTFMove(*touchType),
#endif
#if !PLATFORM(IOS_FAMILY)
            WTFMove(*id),
#endif
#if !PLATFORM(IOS_FAMILY)
            WTFMove(*state),
#endif
#if !PLATFORM(IOS_FAMILY)
            WTFMove(*screenPosition),
#endif
#if !PLATFORM(IOS_FAMILY)
            WTFMove(*position),
#endif
#if !PLATFORM(IOS_FAMILY)
            WTFMove(*radius),
#endif
#if !PLATFORM(IOS_FAMILY)
            WTFMove(*rotationAngle),
#endif
#if !PLATFORM(IOS_FAMILY)
            WTFMove(*force)
#endif
        }
    };
}

#endif

void ArgumentCoder<WebKit::WebMouseEvent>::encode(Encoder& encoder, const WebKit::WebMouseEvent& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebKit::WebEventType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.modifiers())>, OptionSet<WebKit::WebEventModifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timestamp())>, WallTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.authorizationToken())>, WTF::UUID>);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.button())>, WebKit::WebMouseEventButton>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.buttons())>, unsigned short>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.position())>, WebCore::IntPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.globalPosition())>, WebCore::IntPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.deltaX())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.deltaY())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.deltaZ())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.clickCount())>, int32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.force())>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.syntheticClickType())>, WebKit::WebMouseEventSyntheticClickType>);
#if PLATFORM(MAC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.eventNumber())>, int32_t>);
#endif
#if PLATFORM(MAC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.menuTypeForEvent())>, int32_t>);
#endif
#if !PLATFORM(MAC) && PLATFORM(GTK)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isTouchEvent())>, WebCore::PlatformMouseEvent::IsTouch>);
#endif
#if !PLATFORM(MAC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pointerId())>, WebCore::PointerID>);
#endif
#if !PLATFORM(MAC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pointerType())>, String>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.gestureWasCancelled())>, WebKit::GestureWasCancelled>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.unadjustedMovementDelta())>, WebCore::IntPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.coalescedEvents())>, Vector<WebKit::WebMouseEvent>>);

    encoder << instance.type();
    encoder << instance.modifiers();
    encoder << instance.timestamp();
    encoder << instance.authorizationToken();
    encoder << instance.button();
    encoder << instance.buttons();
    encoder << instance.position();
    encoder << instance.globalPosition();
    encoder << instance.deltaX();
    encoder << instance.deltaY();
    encoder << instance.deltaZ();
    encoder << instance.clickCount();
    encoder << instance.force();
    encoder << instance.syntheticClickType();
#if PLATFORM(MAC)
    encoder << instance.eventNumber();
#endif
#if PLATFORM(MAC)
    encoder << instance.menuTypeForEvent();
#endif
#if !PLATFORM(MAC) && PLATFORM(GTK)
    encoder << instance.isTouchEvent();
#endif
#if !PLATFORM(MAC)
    encoder << instance.pointerId();
#endif
#if !PLATFORM(MAC)
    encoder << instance.pointerType();
#endif
    encoder << instance.gestureWasCancelled();
    encoder << instance.unadjustedMovementDelta();
    encoder << instance.coalescedEvents();
}

std::optional<WebKit::WebMouseEvent> ArgumentCoder<WebKit::WebMouseEvent>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebKit::WebEventType>();
    auto modifiers = decoder.decode<OptionSet<WebKit::WebEventModifier>>();
    auto timestamp = decoder.decode<WallTime>();
    auto authorizationToken = decoder.decode<WTF::UUID>();
    auto button = decoder.decode<WebKit::WebMouseEventButton>();
    auto buttons = decoder.decode<unsigned short>();
    auto position = decoder.decode<WebCore::IntPoint>();
    auto globalPosition = decoder.decode<WebCore::IntPoint>();
    auto deltaX = decoder.decode<float>();
    auto deltaY = decoder.decode<float>();
    auto deltaZ = decoder.decode<float>();
    auto clickCount = decoder.decode<int32_t>();
    auto force = decoder.decode<double>();
    auto syntheticClickType = decoder.decode<WebKit::WebMouseEventSyntheticClickType>();
#if PLATFORM(MAC)
    auto eventNumber = decoder.decode<int32_t>();
#endif
#if PLATFORM(MAC)
    auto menuTypeForEvent = decoder.decode<int32_t>();
#endif
#if !PLATFORM(MAC) && PLATFORM(GTK)
    auto isTouchEvent = decoder.decode<WebCore::PlatformMouseEvent::IsTouch>();
#endif
#if !PLATFORM(MAC)
    auto pointerId = decoder.decode<WebCore::PointerID>();
#endif
#if !PLATFORM(MAC)
    auto pointerType = decoder.decode<String>();
#endif
    auto gestureWasCancelled = decoder.decode<WebKit::GestureWasCancelled>();
    auto unadjustedMovementDelta = decoder.decode<WebCore::IntPoint>();
    auto coalescedEvents = decoder.decode<Vector<WebKit::WebMouseEvent>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebMouseEvent {
            WebKit::WebEvent {
                WTFMove(*type),
                WTFMove(*modifiers),
                WTFMove(*timestamp),
                WTFMove(*authorizationToken)
            },
            WTFMove(*button),
            WTFMove(*buttons),
            WTFMove(*position),
            WTFMove(*globalPosition),
            WTFMove(*deltaX),
            WTFMove(*deltaY),
            WTFMove(*deltaZ),
            WTFMove(*clickCount),
            WTFMove(*force),
            WTFMove(*syntheticClickType),
#if PLATFORM(MAC)
            WTFMove(*eventNumber),
#endif
#if PLATFORM(MAC)
            WTFMove(*menuTypeForEvent),
#endif
#if !PLATFORM(MAC) && PLATFORM(GTK)
            WTFMove(*isTouchEvent),
#endif
#if !PLATFORM(MAC)
            WTFMove(*pointerId),
#endif
#if !PLATFORM(MAC)
            WTFMove(*pointerType),
#endif
            WTFMove(*gestureWasCancelled),
            WTFMove(*unadjustedMovementDelta),
            WTFMove(*coalescedEvents)
        }
    };
}

#if ENABLE(MAC_GESTURE_EVENTS)
void ArgumentCoder<WebKit::WebGestureEvent>::encode(Encoder& encoder, const WebKit::WebGestureEvent& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebKit::WebEventType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.modifiers())>, OptionSet<WebKit::WebEventModifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timestamp())>, WallTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.authorizationToken())>, WTF::UUID>);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.position())>, WebCore::IntPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.gestureScale())>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.gestureRotation())>, float>);

    encoder << instance.type();
    encoder << instance.modifiers();
    encoder << instance.timestamp();
    encoder << instance.authorizationToken();
    encoder << instance.position();
    encoder << instance.gestureScale();
    encoder << instance.gestureRotation();
}

std::optional<WebKit::WebGestureEvent> ArgumentCoder<WebKit::WebGestureEvent>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebKit::WebEventType>();
    auto modifiers = decoder.decode<OptionSet<WebKit::WebEventModifier>>();
    auto timestamp = decoder.decode<WallTime>();
    auto authorizationToken = decoder.decode<WTF::UUID>();
    auto position = decoder.decode<WebCore::IntPoint>();
    auto gestureScale = decoder.decode<float>();
    auto gestureRotation = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGestureEvent {
            WebKit::WebEvent {
                WTFMove(*type),
                WTFMove(*modifiers),
                WTFMove(*timestamp),
                WTFMove(*authorizationToken)
            },
            WTFMove(*position),
            WTFMove(*gestureScale),
            WTFMove(*gestureRotation)
        }
    };
}

#endif

void ArgumentCoder<WebKit::WebWheelEvent>::encode(Encoder& encoder, const WebKit::WebWheelEvent& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type())>, WebKit::WebEventType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.modifiers())>, OptionSet<WebKit::WebEventModifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timestamp())>, WallTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.authorizationToken())>, WTF::UUID>);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.position())>, WebCore::IntPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.globalPosition())>, WebCore::IntPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.delta())>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.wheelTicks())>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.granularity())>, WebKit::WebWheelEvent::Granularity>);
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.directionInvertedFromDevice())>, bool>);
#endif
#if PLATFORM(COCOA) || PLATFORM(GTK) || USE(LIBWPE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.phase())>, WebKit::WebWheelEvent::Phase>);
#endif
#if PLATFORM(COCOA) || PLATFORM(GTK) || USE(LIBWPE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.momentumPhase())>, WebKit::WebWheelEvent::Phase>);
#endif
#if PLATFORM(COCOA) || PLATFORM(GTK) || USE(LIBWPE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasPreciseScrollingDeltas())>, bool>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scrollCount())>, uint32_t>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.unacceleratedScrollingDelta())>, WebCore::FloatSize>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ioHIDEventTimestamp())>, WallTime>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rawPlatformDelta())>, std::optional<WebCore::FloatSize>>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.momentumEndType())>, WebKit::WebWheelEvent::MomentumEndType>);
#endif

    encoder << instance.type();
    encoder << instance.modifiers();
    encoder << instance.timestamp();
    encoder << instance.authorizationToken();
    encoder << instance.position();
    encoder << instance.globalPosition();
    encoder << instance.delta();
    encoder << instance.wheelTicks();
    encoder << instance.granularity();
#if PLATFORM(COCOA)
    encoder << instance.directionInvertedFromDevice();
#endif
#if PLATFORM(COCOA) || PLATFORM(GTK) || USE(LIBWPE)
    encoder << instance.phase();
#endif
#if PLATFORM(COCOA) || PLATFORM(GTK) || USE(LIBWPE)
    encoder << instance.momentumPhase();
#endif
#if PLATFORM(COCOA) || PLATFORM(GTK) || USE(LIBWPE)
    encoder << instance.hasPreciseScrollingDeltas();
#endif
#if PLATFORM(COCOA)
    encoder << instance.scrollCount();
#endif
#if PLATFORM(COCOA)
    encoder << instance.unacceleratedScrollingDelta();
#endif
#if PLATFORM(COCOA)
    encoder << instance.ioHIDEventTimestamp();
#endif
#if PLATFORM(COCOA)
    encoder << instance.rawPlatformDelta();
#endif
#if PLATFORM(COCOA)
    encoder << instance.momentumEndType();
#endif
}

std::optional<WebKit::WebWheelEvent> ArgumentCoder<WebKit::WebWheelEvent>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebKit::WebEventType>();
    auto modifiers = decoder.decode<OptionSet<WebKit::WebEventModifier>>();
    auto timestamp = decoder.decode<WallTime>();
    auto authorizationToken = decoder.decode<WTF::UUID>();
    auto position = decoder.decode<WebCore::IntPoint>();
    auto globalPosition = decoder.decode<WebCore::IntPoint>();
    auto delta = decoder.decode<WebCore::FloatSize>();
    auto wheelTicks = decoder.decode<WebCore::FloatSize>();
    auto granularity = decoder.decode<WebKit::WebWheelEvent::Granularity>();
#if PLATFORM(COCOA)
    auto directionInvertedFromDevice = decoder.decode<bool>();
#endif
#if PLATFORM(COCOA) || PLATFORM(GTK) || USE(LIBWPE)
    auto phase = decoder.decode<WebKit::WebWheelEvent::Phase>();
#endif
#if PLATFORM(COCOA) || PLATFORM(GTK) || USE(LIBWPE)
    auto momentumPhase = decoder.decode<WebKit::WebWheelEvent::Phase>();
#endif
#if PLATFORM(COCOA) || PLATFORM(GTK) || USE(LIBWPE)
    auto hasPreciseScrollingDeltas = decoder.decode<bool>();
#endif
#if PLATFORM(COCOA)
    auto scrollCount = decoder.decode<uint32_t>();
#endif
#if PLATFORM(COCOA)
    auto unacceleratedScrollingDelta = decoder.decode<WebCore::FloatSize>();
#endif
#if PLATFORM(COCOA)
    auto ioHIDEventTimestamp = decoder.decode<WallTime>();
#endif
#if PLATFORM(COCOA)
    auto rawPlatformDelta = decoder.decode<std::optional<WebCore::FloatSize>>();
#endif
#if PLATFORM(COCOA)
    auto momentumEndType = decoder.decode<WebKit::WebWheelEvent::MomentumEndType>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebWheelEvent {
            WebKit::WebEvent {
                WTFMove(*type),
                WTFMove(*modifiers),
                WTFMove(*timestamp),
                WTFMove(*authorizationToken)
            },
            WTFMove(*position),
            WTFMove(*globalPosition),
            WTFMove(*delta),
            WTFMove(*wheelTicks),
            WTFMove(*granularity),
#if PLATFORM(COCOA)
            WTFMove(*directionInvertedFromDevice),
#endif
#if PLATFORM(COCOA) || PLATFORM(GTK) || USE(LIBWPE)
            WTFMove(*phase),
#endif
#if PLATFORM(COCOA) || PLATFORM(GTK) || USE(LIBWPE)
            WTFMove(*momentumPhase),
#endif
#if PLATFORM(COCOA) || PLATFORM(GTK) || USE(LIBWPE)
            WTFMove(*hasPreciseScrollingDeltas),
#endif
#if PLATFORM(COCOA)
            WTFMove(*scrollCount),
#endif
#if PLATFORM(COCOA)
            WTFMove(*unacceleratedScrollingDelta),
#endif
#if PLATFORM(COCOA)
            WTFMove(*ioHIDEventTimestamp),
#endif
#if PLATFORM(COCOA)
            WTFMove(*rawPlatformDelta),
#endif
#if PLATFORM(COCOA)
            WTFMove(*momentumEndType)
#endif
        }
    };
}

void ArgumentCoder<WebKit::WebFoundTextRange::DOMData>::encode(Encoder& encoder, const WebKit::WebFoundTextRange::DOMData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.location)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.length)>, uint64_t>);
    struct ShouldBeSameSizeAsDOMData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebFoundTextRange::DOMData>, false> {
        uint64_t location;
        uint64_t length;
    };
    static_assert(sizeof(ShouldBeSameSizeAsDOMData) == sizeof(WebKit::WebFoundTextRange::DOMData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebFoundTextRange::DOMData, location)
        , offsetof(WebKit::WebFoundTextRange::DOMData, length)
    >::value);

    encoder << instance.location;
    encoder << instance.length;
}

std::optional<WebKit::WebFoundTextRange::DOMData> ArgumentCoder<WebKit::WebFoundTextRange::DOMData>::decode(Decoder& decoder)
{
    auto location = decoder.decode<uint64_t>();
    auto length = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebFoundTextRange::DOMData {
            WTFMove(*location),
            WTFMove(*length)
        }
    };
}

void ArgumentCoder<WebKit::WebFoundTextRange::PDFData>::encode(Encoder& encoder, const WebKit::WebFoundTextRange::PDFData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.startPage)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.startOffset)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.endPage)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.endOffset)>, uint64_t>);
    struct ShouldBeSameSizeAsPDFData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebFoundTextRange::PDFData>, false> {
        uint64_t startPage;
        uint64_t startOffset;
        uint64_t endPage;
        uint64_t endOffset;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPDFData) == sizeof(WebKit::WebFoundTextRange::PDFData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebFoundTextRange::PDFData, startPage)
        , offsetof(WebKit::WebFoundTextRange::PDFData, startOffset)
        , offsetof(WebKit::WebFoundTextRange::PDFData, endPage)
        , offsetof(WebKit::WebFoundTextRange::PDFData, endOffset)
    >::value);

    encoder << instance.startPage;
    encoder << instance.startOffset;
    encoder << instance.endPage;
    encoder << instance.endOffset;
}

std::optional<WebKit::WebFoundTextRange::PDFData> ArgumentCoder<WebKit::WebFoundTextRange::PDFData>::decode(Decoder& decoder)
{
    auto startPage = decoder.decode<uint64_t>();
    auto startOffset = decoder.decode<uint64_t>();
    auto endPage = decoder.decode<uint64_t>();
    auto endOffset = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebFoundTextRange::PDFData {
            WTFMove(*startPage),
            WTFMove(*startOffset),
            WTFMove(*endPage),
            WTFMove(*endOffset)
        }
    };
}

void ArgumentCoder<WebKit::WebFoundTextRange>::encode(Encoder& encoder, const WebKit::WebFoundTextRange& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data)>, Variant<WebKit::WebFoundTextRange::DOMData, WebKit::WebFoundTextRange::PDFData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameIdentifier)>, AtomString>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.order)>, uint64_t>);
    struct ShouldBeSameSizeAsWebFoundTextRange : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebFoundTextRange>, false> {
        Variant<WebKit::WebFoundTextRange::DOMData, WebKit::WebFoundTextRange::PDFData> data;
        AtomString frameIdentifier;
        uint64_t order;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebFoundTextRange) == sizeof(WebKit::WebFoundTextRange));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebFoundTextRange, data)
        , offsetof(WebKit::WebFoundTextRange, frameIdentifier)
        , offsetof(WebKit::WebFoundTextRange, order)
    >::value);

    encoder << instance.data;
    encoder << instance.frameIdentifier;
    encoder << instance.order;
}

std::optional<WebKit::WebFoundTextRange> ArgumentCoder<WebKit::WebFoundTextRange>::decode(Decoder& decoder)
{
    auto data = decoder.decode<Variant<WebKit::WebFoundTextRange::DOMData, WebKit::WebFoundTextRange::PDFData>>();
    auto frameIdentifier = decoder.decode<AtomString>();
    auto order = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebFoundTextRange {
            WTFMove(*data),
            WTFMove(*frameIdentifier),
            WTFMove(*order)
        }
    };
}

void ArgumentCoder<WebKit::WebFrameMetrics>::encode(Encoder& encoder, const WebKit::WebFrameMetrics& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isScrollable)>, WebKit::IsScrollable>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentSize)>, WebCore::IntSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.visibleContentSize)>, WebCore::IntSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.visibleContentSizeExcludingScrollbars)>, WebCore::IntSize>);
    struct ShouldBeSameSizeAsWebFrameMetrics : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebFrameMetrics>, false> {
        WebKit::IsScrollable isScrollable;
        WebCore::IntSize contentSize;
        WebCore::IntSize visibleContentSize;
        WebCore::IntSize visibleContentSizeExcludingScrollbars;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebFrameMetrics) == sizeof(WebKit::WebFrameMetrics));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebFrameMetrics, isScrollable)
        , offsetof(WebKit::WebFrameMetrics, contentSize)
        , offsetof(WebKit::WebFrameMetrics, visibleContentSize)
        , offsetof(WebKit::WebFrameMetrics, visibleContentSizeExcludingScrollbars)
    >::value);

    encoder << instance.isScrollable;
    encoder << instance.contentSize;
    encoder << instance.visibleContentSize;
    encoder << instance.visibleContentSizeExcludingScrollbars;
}

std::optional<WebKit::WebFrameMetrics> ArgumentCoder<WebKit::WebFrameMetrics>::decode(Decoder& decoder)
{
    auto isScrollable = decoder.decode<WebKit::IsScrollable>();
    auto contentSize = decoder.decode<WebCore::IntSize>();
    auto visibleContentSize = decoder.decode<WebCore::IntSize>();
    auto visibleContentSizeExcludingScrollbars = decoder.decode<WebCore::IntSize>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebFrameMetrics {
            WTFMove(*isScrollable),
            WTFMove(*contentSize),
            WTFMove(*visibleContentSize),
            WTFMove(*visibleContentSizeExcludingScrollbars)
        }
    };
}

void ArgumentCoder<WebKit::WebHitTestResultData>::encode(Encoder& encoder, const WebKit::WebHitTestResultData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.absoluteImageURL)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.absolutePDFURL)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.absoluteLinkURL)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.absoluteMediaURL)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.linkLabel)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.linkTitle)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.linkSuggestedFilename)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.imageSuggestedFilename)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isContentEditable)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.elementBoundingBox)>, WebCore::IntRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isScrollbar)>, WebKit::WebHitTestResultData::IsScrollbar>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isSelected)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isTextNode)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isOverTextInsideFormControlElement)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isDownloadableMedia)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaIsInFullscreen)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isActivePDFAnnotation)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.elementType)>, WebKit::WebHitTestResultData::ElementType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameInfo)>, std::optional<WebKit::FrameInfoData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.remoteUserInputEventData)>, std::optional<WebCore::RemoteUserInputEventData>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lookupText)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.toolTipText)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.imageText)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.getImageSharedMemoryHandle())>, std::optional<WebCore::SharedMemoryHandle>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.imageBitmap)>, RefPtr<WebCore::ShareableBitmap>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceImageMIMEType)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasEntireImage)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowsFollowingLink)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowsFollowingImageURL)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.linkLocalResourceResponse)>, std::optional<WebCore::ResourceResponse>>);
#if PLATFORM(MAC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.platformData)>, WebKit::WebHitTestResultPlatformData>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dictionaryPopupInfo)>, WebCore::DictionaryPopupInfo>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.linkTextIndicator)>, RefPtr<WebCore::TextIndicator>>);

    encoder << instance.absoluteImageURL;
    encoder << instance.absolutePDFURL;
    encoder << instance.absoluteLinkURL;
    encoder << instance.absoluteMediaURL;
    encoder << instance.linkLabel;
    encoder << instance.linkTitle;
    encoder << instance.linkSuggestedFilename;
    encoder << instance.imageSuggestedFilename;
    encoder << instance.isContentEditable;
    encoder << instance.elementBoundingBox;
    encoder << instance.isScrollbar;
    encoder << instance.isSelected;
    encoder << instance.isTextNode;
    encoder << instance.isOverTextInsideFormControlElement;
    encoder << instance.isDownloadableMedia;
    encoder << instance.mediaIsInFullscreen;
    encoder << instance.isActivePDFAnnotation;
    encoder << instance.elementType;
    encoder << instance.frameInfo;
    encoder << instance.remoteUserInputEventData;
    encoder << instance.lookupText;
    encoder << instance.toolTipText;
    encoder << instance.imageText;
    encoder << instance.getImageSharedMemoryHandle();
    encoder << instance.imageBitmap;
    encoder << instance.sourceImageMIMEType;
    encoder << instance.hasEntireImage;
    encoder << instance.allowsFollowingLink;
    encoder << instance.allowsFollowingImageURL;
    encoder << instance.linkLocalResourceResponse;
#if PLATFORM(MAC)
    encoder << instance.platformData;
#endif
    encoder << instance.dictionaryPopupInfo;
    encoder << instance.linkTextIndicator;
}

std::optional<WebKit::WebHitTestResultData> ArgumentCoder<WebKit::WebHitTestResultData>::decode(Decoder& decoder)
{
    auto absoluteImageURL = decoder.decode<String>();
    auto absolutePDFURL = decoder.decode<String>();
    auto absoluteLinkURL = decoder.decode<String>();
    auto absoluteMediaURL = decoder.decode<String>();
    auto linkLabel = decoder.decode<String>();
    auto linkTitle = decoder.decode<String>();
    auto linkSuggestedFilename = decoder.decode<String>();
    auto imageSuggestedFilename = decoder.decode<String>();
    auto isContentEditable = decoder.decode<bool>();
    auto elementBoundingBox = decoder.decode<WebCore::IntRect>();
    auto isScrollbar = decoder.decode<WebKit::WebHitTestResultData::IsScrollbar>();
    auto isSelected = decoder.decode<bool>();
    auto isTextNode = decoder.decode<bool>();
    auto isOverTextInsideFormControlElement = decoder.decode<bool>();
    auto isDownloadableMedia = decoder.decode<bool>();
    auto mediaIsInFullscreen = decoder.decode<bool>();
    auto isActivePDFAnnotation = decoder.decode<bool>();
    auto elementType = decoder.decode<WebKit::WebHitTestResultData::ElementType>();
    auto frameInfo = decoder.decode<std::optional<WebKit::FrameInfoData>>();
    auto remoteUserInputEventData = decoder.decode<std::optional<WebCore::RemoteUserInputEventData>>();
    auto lookupText = decoder.decode<String>();
    auto toolTipText = decoder.decode<String>();
    auto imageText = decoder.decode<String>();
    auto getImageSharedMemoryHandle = decoder.decode<std::optional<WebCore::SharedMemoryHandle>>();
    auto imageBitmap = decoder.decode<RefPtr<WebCore::ShareableBitmap>>();
    auto sourceImageMIMEType = decoder.decode<String>();
    auto hasEntireImage = decoder.decode<bool>();
    auto allowsFollowingLink = decoder.decode<bool>();
    auto allowsFollowingImageURL = decoder.decode<bool>();
    auto linkLocalResourceResponse = decoder.decode<std::optional<WebCore::ResourceResponse>>();
#if PLATFORM(MAC)
    auto platformData = decoder.decode<WebKit::WebHitTestResultPlatformData>();
#endif
    auto dictionaryPopupInfo = decoder.decode<WebCore::DictionaryPopupInfo>();
    auto linkTextIndicator = decoder.decode<RefPtr<WebCore::TextIndicator>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebHitTestResultData {
            WTFMove(*absoluteImageURL),
            WTFMove(*absolutePDFURL),
            WTFMove(*absoluteLinkURL),
            WTFMove(*absoluteMediaURL),
            WTFMove(*linkLabel),
            WTFMove(*linkTitle),
            WTFMove(*linkSuggestedFilename),
            WTFMove(*imageSuggestedFilename),
            WTFMove(*isContentEditable),
            WTFMove(*elementBoundingBox),
            WTFMove(*isScrollbar),
            WTFMove(*isSelected),
            WTFMove(*isTextNode),
            WTFMove(*isOverTextInsideFormControlElement),
            WTFMove(*isDownloadableMedia),
            WTFMove(*mediaIsInFullscreen),
            WTFMove(*isActivePDFAnnotation),
            WTFMove(*elementType),
            WTFMove(*frameInfo),
            WTFMove(*remoteUserInputEventData),
            WTFMove(*lookupText),
            WTFMove(*toolTipText),
            WTFMove(*imageText),
            WTFMove(*getImageSharedMemoryHandle),
            WTFMove(*imageBitmap),
            WTFMove(*sourceImageMIMEType),
            WTFMove(*hasEntireImage),
            WTFMove(*allowsFollowingLink),
            WTFMove(*allowsFollowingImageURL),
            WTFMove(*linkLocalResourceResponse),
#if PLATFORM(MAC)
            WTFMove(*platformData),
#endif
            WTFMove(*dictionaryPopupInfo),
            WTFMove(*linkTextIndicator)
        }
    };
}

void ArgumentCoder<WebKit::WebImage>::encode(Encoder& encoder, const WebKit::WebImage& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.parametersAndHandle())>, std::optional<std::pair<WebCore::ImageBufferParameters, WebCore::ShareableBitmapHandle>>>);

    encoder << instance.parametersAndHandle();
}

std::optional<Ref<WebKit::WebImage>> ArgumentCoder<WebKit::WebImage>::decode(Decoder& decoder)
{
    auto parametersAndHandle = decoder.decode<std::optional<std::pair<WebCore::ImageBufferParameters, WebCore::ShareableBitmapHandle>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebImage::create(
            WTFMove(*parametersAndHandle)
        )
    };
}

void ArgumentCoder<WebKit::WebNavigationDataStore>::encode(Encoder& encoder, const WebKit::WebNavigationDataStore& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.title)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.originalRequest)>, WebCore::ResourceRequest>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.response)>, WebCore::ResourceResponse>);
    struct ShouldBeSameSizeAsWebNavigationDataStore : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebNavigationDataStore>, false> {
        String url;
        String title;
        WebCore::ResourceRequest originalRequest;
        WebCore::ResourceResponse response;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebNavigationDataStore) == sizeof(WebKit::WebNavigationDataStore));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebNavigationDataStore, url)
        , offsetof(WebKit::WebNavigationDataStore, title)
        , offsetof(WebKit::WebNavigationDataStore, originalRequest)
        , offsetof(WebKit::WebNavigationDataStore, response)
    >::value);

    encoder << instance.url;
    encoder << instance.title;
    encoder << instance.originalRequest;
    encoder << instance.response;
}

std::optional<WebKit::WebNavigationDataStore> ArgumentCoder<WebKit::WebNavigationDataStore>::decode(Decoder& decoder)
{
    auto url = decoder.decode<String>();
    auto title = decoder.decode<String>();
    auto originalRequest = decoder.decode<WebCore::ResourceRequest>();
    auto response = decoder.decode<WebCore::ResourceResponse>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebNavigationDataStore {
            WTFMove(*url),
            WTFMove(*title),
            WTFMove(*originalRequest),
            WTFMove(*response)
        }
    };
}

void ArgumentCoder<WebKit::WebPageCreationParameters>::encode(Encoder& encoder, WebKit::WebPageCreationParameters&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.viewSize)>, WebCore::IntSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.activityState)>, OptionSet<WebCore::ActivityState>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.store)>, WebKit::WebPreferencesStore>);
#if ENABLE(TILED_CA_DRAWING_AREA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.drawingAreaType)>, WebKit::DrawingAreaType>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.drawingAreaIdentifier)>, WebKit::DrawingAreaIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webPageProxyIdentifier)>, WebKit::WebPageProxyIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pageGroupData)>, WebKit::WebPageGroupData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isEditable)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.underlayColor)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.useFixedLayout)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fixedLayoutSize)>, WebCore::IntSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.defaultUnobscuredSize)>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.minimumUnobscuredSize)>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maximumUnobscuredSize)>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.viewExposedRect)>, std::optional<WebCore::FloatRect>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.displayID)>, std::optional<uint32_t>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.nominalFramesPerSecond)>, std::optional<unsigned>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.alwaysShowsHorizontalScroller)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.alwaysShowsVerticalScroller)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.suppressScrollbarAnimations)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.paginationMode)>, WebCore::PaginationMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.paginationBehavesLikeColumns)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pageLength)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.gapBetweenPages)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.userAgent)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.visitedLinkTableID)>, WebKit::VisitedLinkTableIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.canRunBeforeUnloadConfirmPanel)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.canRunModal)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.deviceScaleFactor)>, float>);
#if USE(GRAPHICS_LAYER_WC) || USE(GRAPHICS_LAYER_TEXTURE_MAPPER)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.intrinsicDeviceScaleFactor)>, float>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.viewScaleFactor)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.textZoomFactor)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pageZoomFactor)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.obscuredContentInsets)>, WebCore::FloatBoxExtent>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaVolume)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.muted)>, WebCore::MediaProducerMutedStateFlags>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.openedByDOM)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mayStartMediaWhenInWindow)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaPlaybackIsSuspended)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.minimumSizeForAutoLayout)>, WebCore::IntSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sizeToContentAutoSizeMaximumSize)>, WebCore::IntSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.autoSizingShouldExpandToViewHeight)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.viewportSizeForCSSViewportUnits)>, std::optional<WebCore::FloatSize>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scrollPinningBehavior)>, WebCore::ScrollPinningBehavior>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scrollbarOverlayStyle)>, std::optional<WebCore::ScrollbarOverlayStyle>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.backgroundExtendsBeyondPage)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasResourceLoadClient)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mimeTypesWithCustomContentProviders)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.controlledByAutomation)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isProcessSwap)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.useDarkAppearance)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.useElevatedUserInterfaceLevel)>, bool>);
#if PLATFORM(MAC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorSpace)>, std::optional<WebCore::DestinationColorSpace>>);
#endif
#if PLATFORM(MAC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.useFormSemanticContext)>, bool>);
#endif
#if PLATFORM(MAC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.headerBannerHeight)>, int>);
#endif
#if PLATFORM(MAC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.footerBannerHeight)>, int>);
#endif
#if PLATFORM(MAC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.viewWindowCoordinates)>, std::optional<WebKit::ViewWindowCoordinates>>);
#endif
#if ENABLE(META_VIEWPORT)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ignoresViewportScaleLimits)>, bool>);
#endif
#if ENABLE(META_VIEWPORT)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.viewportConfigurationViewLayoutSize)>, WebCore::FloatSize>);
#endif
#if ENABLE(META_VIEWPORT)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.viewportConfigurationLayoutSizeScaleFactorFromClient)>, double>);
#endif
#if ENABLE(META_VIEWPORT)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.viewportConfigurationMinimumEffectiveDeviceWidth)>, double>);
#endif
#if ENABLE(META_VIEWPORT)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.viewportConfigurationViewSize)>, WebCore::FloatSize>);
#endif
#if ENABLE(META_VIEWPORT)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.overrideViewportArguments)>, std::optional<WebCore::ViewportArguments>>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.screenSize)>, WebCore::FloatSize>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.availableScreenSize)>, WebCore::FloatSize>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.overrideScreenSize)>, WebCore::FloatSize>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.overrideAvailableScreenSize)>, WebCore::FloatSize>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.textAutosizingWidth)>, float>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.deviceOrientation)>, WebCore::IntDegrees>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hardwareKeyboardState)>, WebKit::HardwareKeyboardState>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.canShowWhileLocked)>, bool>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isCapturingScreen)>, bool>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.insertionPointColor)>, WebCore::Color>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.smartInsertDeleteEnabled)>, bool>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.additionalSupportedImageTypes)>, Vector<String>>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.gpuIOKitExtensionHandles)>, Vector<WebKit::SandboxExtensionHandle>>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.gpuMachExtensionHandles)>, Vector<WebKit::SandboxExtensionHandle>>);
#endif
#if ENABLE(TILED_CA_DRAWING_AREA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.renderServerMachExtensionHandle)>, WebKit::SandboxExtensionHandle>);
#endif
#if HAVE(STATIC_FONT_REGISTRY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fontMachExtensionHandles)>, Vector<WebKit::SandboxExtensionHandle>>);
#endif
#if HAVE(APP_ACCENT_COLORS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.accentColor)>, WebCore::Color>);
#endif
#if HAVE(APP_ACCENT_COLORS) && PLATFORM(MAC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.appUsesCustomAccentColor)>, bool>);
#endif
#if USE(WPE_RENDERER)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hostFileDescriptor)>, UnixFileDescriptor>);
#endif
#if USE(GRAPHICS_LAYER_TEXTURE_MAPPER) || USE(GRAPHICS_LAYER_WC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.nativeWindowHandle)>, uint64_t>);
#endif
#if USE(GRAPHICS_LAYER_WC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.usesOffscreenRendering)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldScaleViewToFitDocument)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.userInterfaceLayoutDirection)>, WebCore::UserInterfaceLayoutDirection>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.observedLayoutMilestones)>, OptionSet<WebCore::LayoutMilestone>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.overrideContentSecurityPolicy)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cpuLimit)>, std::optional<double>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.urlSchemeHandlers)>, HashMap<String, WebKit::WebURLSchemeHandlerIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.urlSchemesWithLegacyCustomProtocolHandlers)>, Vector<String>>);
#if ENABLE(APPLICATION_MANIFEST)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.applicationManifest)>, std::optional<WebCore::ApplicationManifest>>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.needsFontAttributes)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.needsScrollGeometryUpdates)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.iceCandidateFilteringEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.enumeratingAllNetworkInterfacesEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.userContentControllerParameters)>, WebKit::UserContentControllerParameters>);
#if ENABLE(WK_WEB_EXTENSIONS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webExtensionControllerParameters)>, std::optional<WebKit::WebExtensionControllerParameters>>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.backgroundColor)>, std::optional<WebCore::Color>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.oldPageID)>, std::optional<WebCore::PageIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.overriddenMediaType)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.corsDisablingPatterns)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maskedURLSchemes)>, HashSet<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.loadsSubresources)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowedNetworkHosts)>, std::optional<MemoryCompactLookupOnlyRobinHoodHashSet<String>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.portsForUpgradingInsecureSchemeForTesting)>, std::optional<std::pair<uint16_t, uint16_t>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.crossOriginAccessControlCheckEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processDisplayName)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldCaptureAudioInUIProcess)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldCaptureAudioInGPUProcess)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldCaptureVideoInUIProcess)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldCaptureVideoInGPUProcess)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldCaptureDisplayInUIProcess)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldCaptureDisplayInGPUProcess)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldRenderCanvasInGPUProcess)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldRenderDOMInGPUProcess)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldPlayMediaInGPUProcess)>, bool>);
#if ENABLE(WEBGL)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldRenderWebGLInGPUProcess)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldEnableVP8Decoder)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldEnableVP9Decoder)>, bool>);
#if ENABLE(APP_BOUND_DOMAINS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.limitsNavigationsToAppBoundDomains)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lastNavigationWasAppInitiated)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.canUseCredentialStorage)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldRelaxThirdPartyCookieBlocking)>, WebCore::ShouldRelaxThirdPartyCookieBlocking>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.httpsUpgradeEnabled)>, bool>);
#if ENABLE(APP_HIGHLIGHTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.appHighlightsVisible)>, WebCore::HighlightVisibility>);
#endif
#if HAVE(TOUCH_BAR)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requiresUserActionForEditingControlsManager)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasResizableWindows)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentSecurityPolicyModeForExtension)>, WebCore::ContentSecurityPolicyModeForExtension>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.remotePageParameters)>, std::optional<WebKit::RemotePageParameters>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.provisionalFrameCreationParameters)>, std::optional<WebKit::ProvisionalFrameCreationParameters>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mainFrameIdentifier)>, WebCore::FrameIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.openedMainFrameName)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mainFrameOpenerIdentifier)>, std::optional<WebCore::FrameIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.initialSandboxFlags)>, WebCore::SandboxFlags>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.windowFeatures)>, std::optional<WebCore::WindowFeatures>>);
#if ENABLE(ADVANCED_PRIVACY_PROTECTIONS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.linkDecorationFilteringData)>, Vector<WebCore::LinkDecorationFilteringData>>);
#endif
#if ENABLE(ADVANCED_PRIVACY_PROTECTIONS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowedQueryParametersForAdvancedPrivacyProtections)>, Vector<WebCore::LinkDecorationFilteringData>>);
#endif
#if HAVE(MACH_BOOTSTRAP_EXTENSION)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.machBootstrapHandle)>, WebKit::SandboxExtensionHandle>);
#endif
#if (PLATFORM(GTK) || PLATFORM(WPE)) && (USE(GBM))
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.preferredBufferFormats)>, Vector<WebKit::RendererBufferFormat>>);
#endif
#if PLATFORM(VISION) && ENABLE(GAMEPAD)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.gamepadAccessRequiresExplicitConsent)>, WebCore::ShouldRequireExplicitConsentForGamepadAccess>);
#endif
#if HAVE(AUDIT_TOKEN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.presentingApplicationAuditToken)>, std::optional<WebKit::CoreIPCAuditToken>>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.presentingApplicationBundleIdentifier)>, String>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldSendConsoleLogsToUIProcessForTesting)>, bool>);
    struct ShouldBeSameSizeAsWebPageCreationParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebPageCreationParameters>, false> {
        WebCore::IntSize viewSize;
        OptionSet<WebCore::ActivityState> activityState;
        WebKit::WebPreferencesStore store;
#if ENABLE(TILED_CA_DRAWING_AREA)
        WebKit::DrawingAreaType drawingAreaType;
#endif
        WebKit::DrawingAreaIdentifier drawingAreaIdentifier;
        WebKit::WebPageProxyIdentifier webPageProxyIdentifier;
        WebKit::WebPageGroupData pageGroupData;
        bool isEditable;
        WebCore::Color underlayColor;
        bool useFixedLayout;
        WebCore::IntSize fixedLayoutSize;
        WebCore::FloatSize defaultUnobscuredSize;
        WebCore::FloatSize minimumUnobscuredSize;
        WebCore::FloatSize maximumUnobscuredSize;
        std::optional<WebCore::FloatRect> viewExposedRect;
        std::optional<uint32_t> displayID;
        std::optional<unsigned> nominalFramesPerSecond;
        bool alwaysShowsHorizontalScroller;
        bool alwaysShowsVerticalScroller;
        bool suppressScrollbarAnimations;
        WebCore::PaginationMode paginationMode;
        bool paginationBehavesLikeColumns;
        double pageLength;
        double gapBetweenPages;
        String userAgent;
        WebKit::VisitedLinkTableIdentifier visitedLinkTableID;
        bool canRunBeforeUnloadConfirmPanel;
        bool canRunModal;
        float deviceScaleFactor;
#if USE(GRAPHICS_LAYER_WC) || USE(GRAPHICS_LAYER_TEXTURE_MAPPER)
        float intrinsicDeviceScaleFactor;
#endif
        float viewScaleFactor;
        double textZoomFactor;
        double pageZoomFactor;
        WebCore::FloatBoxExtent obscuredContentInsets;
        float mediaVolume;
        WebCore::MediaProducerMutedStateFlags muted;
        bool openedByDOM;
        bool mayStartMediaWhenInWindow;
        bool mediaPlaybackIsSuspended;
        WebCore::IntSize minimumSizeForAutoLayout;
        WebCore::IntSize sizeToContentAutoSizeMaximumSize;
        bool autoSizingShouldExpandToViewHeight;
        std::optional<WebCore::FloatSize> viewportSizeForCSSViewportUnits;
        WebCore::ScrollPinningBehavior scrollPinningBehavior;
        std::optional<WebCore::ScrollbarOverlayStyle> scrollbarOverlayStyle;
        bool backgroundExtendsBeyondPage;
        bool hasResourceLoadClient;
        Vector<String> mimeTypesWithCustomContentProviders;
        bool controlledByAutomation;
        bool isProcessSwap;
        bool useDarkAppearance;
        bool useElevatedUserInterfaceLevel;
#if PLATFORM(MAC)
        std::optional<WebCore::DestinationColorSpace> colorSpace;
#endif
#if PLATFORM(MAC)
        bool useFormSemanticContext;
#endif
#if PLATFORM(MAC)
        int headerBannerHeight;
#endif
#if PLATFORM(MAC)
        int footerBannerHeight;
#endif
#if PLATFORM(MAC)
        std::optional<WebKit::ViewWindowCoordinates> viewWindowCoordinates;
#endif
#if ENABLE(META_VIEWPORT)
        bool ignoresViewportScaleLimits;
#endif
#if ENABLE(META_VIEWPORT)
        WebCore::FloatSize viewportConfigurationViewLayoutSize;
#endif
#if ENABLE(META_VIEWPORT)
        double viewportConfigurationLayoutSizeScaleFactorFromClient;
#endif
#if ENABLE(META_VIEWPORT)
        double viewportConfigurationMinimumEffectiveDeviceWidth;
#endif
#if ENABLE(META_VIEWPORT)
        WebCore::FloatSize viewportConfigurationViewSize;
#endif
#if ENABLE(META_VIEWPORT)
        std::optional<WebCore::ViewportArguments> overrideViewportArguments;
#endif
#if PLATFORM(IOS_FAMILY)
        WebCore::FloatSize screenSize;
#endif
#if PLATFORM(IOS_FAMILY)
        WebCore::FloatSize availableScreenSize;
#endif
#if PLATFORM(IOS_FAMILY)
        WebCore::FloatSize overrideScreenSize;
#endif
#if PLATFORM(IOS_FAMILY)
        WebCore::FloatSize overrideAvailableScreenSize;
#endif
#if PLATFORM(IOS_FAMILY)
        float textAutosizingWidth;
#endif
#if PLATFORM(IOS_FAMILY)
        WebCore::IntDegrees deviceOrientation;
#endif
#if PLATFORM(IOS_FAMILY)
        WebKit::HardwareKeyboardState hardwareKeyboardState;
#endif
#if PLATFORM(IOS_FAMILY)
        bool canShowWhileLocked;
#endif
#if PLATFORM(IOS_FAMILY)
        bool isCapturingScreen;
#endif
#if PLATFORM(IOS_FAMILY)
        WebCore::Color insertionPointColor;
#endif
#if PLATFORM(COCOA)
        bool smartInsertDeleteEnabled;
#endif
#if PLATFORM(COCOA)
        Vector<String> additionalSupportedImageTypes;
#endif
#if PLATFORM(COCOA)
        Vector<WebKit::SandboxExtensionHandle> gpuIOKitExtensionHandles;
#endif
#if PLATFORM(COCOA)
        Vector<WebKit::SandboxExtensionHandle> gpuMachExtensionHandles;
#endif
#if ENABLE(TILED_CA_DRAWING_AREA)
        WebKit::SandboxExtensionHandle renderServerMachExtensionHandle;
#endif
#if HAVE(STATIC_FONT_REGISTRY)
        Vector<WebKit::SandboxExtensionHandle> fontMachExtensionHandles;
#endif
#if HAVE(APP_ACCENT_COLORS)
        WebCore::Color accentColor;
#endif
#if HAVE(APP_ACCENT_COLORS) && PLATFORM(MAC)
        bool appUsesCustomAccentColor;
#endif
#if USE(WPE_RENDERER)
        UnixFileDescriptor hostFileDescriptor;
#endif
#if USE(GRAPHICS_LAYER_TEXTURE_MAPPER) || USE(GRAPHICS_LAYER_WC)
        uint64_t nativeWindowHandle;
#endif
#if USE(GRAPHICS_LAYER_WC)
        bool usesOffscreenRendering;
#endif
        bool shouldScaleViewToFitDocument;
        WebCore::UserInterfaceLayoutDirection userInterfaceLayoutDirection;
        OptionSet<WebCore::LayoutMilestone> observedLayoutMilestones;
        String overrideContentSecurityPolicy;
        std::optional<double> cpuLimit;
        HashMap<String, WebKit::WebURLSchemeHandlerIdentifier> urlSchemeHandlers;
        Vector<String> urlSchemesWithLegacyCustomProtocolHandlers;
#if ENABLE(APPLICATION_MANIFEST)
        std::optional<WebCore::ApplicationManifest> applicationManifest;
#endif
        bool needsFontAttributes;
        bool needsScrollGeometryUpdates;
        bool iceCandidateFilteringEnabled;
        bool enumeratingAllNetworkInterfacesEnabled;
        WebKit::UserContentControllerParameters userContentControllerParameters;
#if ENABLE(WK_WEB_EXTENSIONS)
        std::optional<WebKit::WebExtensionControllerParameters> webExtensionControllerParameters;
#endif
        std::optional<WebCore::Color> backgroundColor;
        std::optional<WebCore::PageIdentifier> oldPageID;
        String overriddenMediaType;
        Vector<String> corsDisablingPatterns;
        HashSet<String> maskedURLSchemes;
        bool loadsSubresources;
        std::optional<MemoryCompactLookupOnlyRobinHoodHashSet<String>> allowedNetworkHosts;
        std::optional<std::pair<uint16_t, uint16_t>> portsForUpgradingInsecureSchemeForTesting;
        bool crossOriginAccessControlCheckEnabled;
        String processDisplayName;
        bool shouldCaptureAudioInUIProcess;
        bool shouldCaptureAudioInGPUProcess;
        bool shouldCaptureVideoInUIProcess;
        bool shouldCaptureVideoInGPUProcess;
        bool shouldCaptureDisplayInUIProcess;
        bool shouldCaptureDisplayInGPUProcess;
        bool shouldRenderCanvasInGPUProcess;
        bool shouldRenderDOMInGPUProcess;
        bool shouldPlayMediaInGPUProcess;
#if ENABLE(WEBGL)
        bool shouldRenderWebGLInGPUProcess;
#endif
        bool shouldEnableVP8Decoder;
        bool shouldEnableVP9Decoder;
#if ENABLE(APP_BOUND_DOMAINS)
        bool limitsNavigationsToAppBoundDomains;
#endif
        bool lastNavigationWasAppInitiated;
        bool canUseCredentialStorage;
        WebCore::ShouldRelaxThirdPartyCookieBlocking shouldRelaxThirdPartyCookieBlocking;
        bool httpsUpgradeEnabled;
#if ENABLE(APP_HIGHLIGHTS)
        WebCore::HighlightVisibility appHighlightsVisible;
#endif
#if HAVE(TOUCH_BAR)
        bool requiresUserActionForEditingControlsManager;
#endif
        bool hasResizableWindows;
        WebCore::ContentSecurityPolicyModeForExtension contentSecurityPolicyModeForExtension;
        std::optional<WebKit::RemotePageParameters> remotePageParameters;
        std::optional<WebKit::ProvisionalFrameCreationParameters> provisionalFrameCreationParameters;
        WebCore::FrameIdentifier mainFrameIdentifier;
        String openedMainFrameName;
        std::optional<WebCore::FrameIdentifier> mainFrameOpenerIdentifier;
        WebCore::SandboxFlags initialSandboxFlags;
        std::optional<WebCore::WindowFeatures> windowFeatures;
#if ENABLE(ADVANCED_PRIVACY_PROTECTIONS)
        Vector<WebCore::LinkDecorationFilteringData> linkDecorationFilteringData;
#endif
#if ENABLE(ADVANCED_PRIVACY_PROTECTIONS)
        Vector<WebCore::LinkDecorationFilteringData> allowedQueryParametersForAdvancedPrivacyProtections;
#endif
#if HAVE(MACH_BOOTSTRAP_EXTENSION)
        WebKit::SandboxExtensionHandle machBootstrapHandle;
#endif
#if (PLATFORM(GTK) || PLATFORM(WPE)) && (USE(GBM))
        Vector<WebKit::RendererBufferFormat> preferredBufferFormats;
#endif
#if PLATFORM(VISION) && ENABLE(GAMEPAD)
        WebCore::ShouldRequireExplicitConsentForGamepadAccess gamepadAccessRequiresExplicitConsent;
#endif
#if HAVE(AUDIT_TOKEN)
        std::optional<WebKit::CoreIPCAuditToken> presentingApplicationAuditToken;
#endif
#if PLATFORM(COCOA)
        String presentingApplicationBundleIdentifier;
#endif
        bool shouldSendConsoleLogsToUIProcessForTesting;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebPageCreationParameters) == sizeof(WebKit::WebPageCreationParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebPageCreationParameters, viewSize)
        , offsetof(WebKit::WebPageCreationParameters, activityState)
        , offsetof(WebKit::WebPageCreationParameters, store)
#if ENABLE(TILED_CA_DRAWING_AREA)
        , offsetof(WebKit::WebPageCreationParameters, drawingAreaType)
#endif
        , offsetof(WebKit::WebPageCreationParameters, drawingAreaIdentifier)
        , offsetof(WebKit::WebPageCreationParameters, webPageProxyIdentifier)
        , offsetof(WebKit::WebPageCreationParameters, pageGroupData)
        , offsetof(WebKit::WebPageCreationParameters, isEditable)
        , offsetof(WebKit::WebPageCreationParameters, underlayColor)
        , offsetof(WebKit::WebPageCreationParameters, useFixedLayout)
        , offsetof(WebKit::WebPageCreationParameters, fixedLayoutSize)
        , offsetof(WebKit::WebPageCreationParameters, defaultUnobscuredSize)
        , offsetof(WebKit::WebPageCreationParameters, minimumUnobscuredSize)
        , offsetof(WebKit::WebPageCreationParameters, maximumUnobscuredSize)
        , offsetof(WebKit::WebPageCreationParameters, viewExposedRect)
        , offsetof(WebKit::WebPageCreationParameters, displayID)
        , offsetof(WebKit::WebPageCreationParameters, nominalFramesPerSecond)
        , offsetof(WebKit::WebPageCreationParameters, alwaysShowsHorizontalScroller)
        , offsetof(WebKit::WebPageCreationParameters, alwaysShowsVerticalScroller)
        , offsetof(WebKit::WebPageCreationParameters, suppressScrollbarAnimations)
        , offsetof(WebKit::WebPageCreationParameters, paginationMode)
        , offsetof(WebKit::WebPageCreationParameters, paginationBehavesLikeColumns)
        , offsetof(WebKit::WebPageCreationParameters, pageLength)
        , offsetof(WebKit::WebPageCreationParameters, gapBetweenPages)
        , offsetof(WebKit::WebPageCreationParameters, userAgent)
        , offsetof(WebKit::WebPageCreationParameters, visitedLinkTableID)
        , offsetof(WebKit::WebPageCreationParameters, canRunBeforeUnloadConfirmPanel)
        , offsetof(WebKit::WebPageCreationParameters, canRunModal)
        , offsetof(WebKit::WebPageCreationParameters, deviceScaleFactor)
#if USE(GRAPHICS_LAYER_WC) || USE(GRAPHICS_LAYER_TEXTURE_MAPPER)
        , offsetof(WebKit::WebPageCreationParameters, intrinsicDeviceScaleFactor)
#endif
        , offsetof(WebKit::WebPageCreationParameters, viewScaleFactor)
        , offsetof(WebKit::WebPageCreationParameters, textZoomFactor)
        , offsetof(WebKit::WebPageCreationParameters, pageZoomFactor)
        , offsetof(WebKit::WebPageCreationParameters, obscuredContentInsets)
        , offsetof(WebKit::WebPageCreationParameters, mediaVolume)
        , offsetof(WebKit::WebPageCreationParameters, muted)
        , offsetof(WebKit::WebPageCreationParameters, openedByDOM)
        , offsetof(WebKit::WebPageCreationParameters, mayStartMediaWhenInWindow)
        , offsetof(WebKit::WebPageCreationParameters, mediaPlaybackIsSuspended)
        , offsetof(WebKit::WebPageCreationParameters, minimumSizeForAutoLayout)
        , offsetof(WebKit::WebPageCreationParameters, sizeToContentAutoSizeMaximumSize)
        , offsetof(WebKit::WebPageCreationParameters, autoSizingShouldExpandToViewHeight)
        , offsetof(WebKit::WebPageCreationParameters, viewportSizeForCSSViewportUnits)
        , offsetof(WebKit::WebPageCreationParameters, scrollPinningBehavior)
        , offsetof(WebKit::WebPageCreationParameters, scrollbarOverlayStyle)
        , offsetof(WebKit::WebPageCreationParameters, backgroundExtendsBeyondPage)
        , offsetof(WebKit::WebPageCreationParameters, hasResourceLoadClient)
        , offsetof(WebKit::WebPageCreationParameters, mimeTypesWithCustomContentProviders)
        , offsetof(WebKit::WebPageCreationParameters, controlledByAutomation)
        , offsetof(WebKit::WebPageCreationParameters, isProcessSwap)
        , offsetof(WebKit::WebPageCreationParameters, useDarkAppearance)
        , offsetof(WebKit::WebPageCreationParameters, useElevatedUserInterfaceLevel)
#if PLATFORM(MAC)
        , offsetof(WebKit::WebPageCreationParameters, colorSpace)
#endif
#if PLATFORM(MAC)
        , offsetof(WebKit::WebPageCreationParameters, useFormSemanticContext)
#endif
#if PLATFORM(MAC)
        , offsetof(WebKit::WebPageCreationParameters, headerBannerHeight)
#endif
#if PLATFORM(MAC)
        , offsetof(WebKit::WebPageCreationParameters, footerBannerHeight)
#endif
#if PLATFORM(MAC)
        , offsetof(WebKit::WebPageCreationParameters, viewWindowCoordinates)
#endif
#if ENABLE(META_VIEWPORT)
        , offsetof(WebKit::WebPageCreationParameters, ignoresViewportScaleLimits)
#endif
#if ENABLE(META_VIEWPORT)
        , offsetof(WebKit::WebPageCreationParameters, viewportConfigurationViewLayoutSize)
#endif
#if ENABLE(META_VIEWPORT)
        , offsetof(WebKit::WebPageCreationParameters, viewportConfigurationLayoutSizeScaleFactorFromClient)
#endif
#if ENABLE(META_VIEWPORT)
        , offsetof(WebKit::WebPageCreationParameters, viewportConfigurationMinimumEffectiveDeviceWidth)
#endif
#if ENABLE(META_VIEWPORT)
        , offsetof(WebKit::WebPageCreationParameters, viewportConfigurationViewSize)
#endif
#if ENABLE(META_VIEWPORT)
        , offsetof(WebKit::WebPageCreationParameters, overrideViewportArguments)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::WebPageCreationParameters, screenSize)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::WebPageCreationParameters, availableScreenSize)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::WebPageCreationParameters, overrideScreenSize)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::WebPageCreationParameters, overrideAvailableScreenSize)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::WebPageCreationParameters, textAutosizingWidth)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::WebPageCreationParameters, deviceOrientation)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::WebPageCreationParameters, hardwareKeyboardState)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::WebPageCreationParameters, canShowWhileLocked)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::WebPageCreationParameters, isCapturingScreen)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::WebPageCreationParameters, insertionPointColor)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::WebPageCreationParameters, smartInsertDeleteEnabled)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::WebPageCreationParameters, additionalSupportedImageTypes)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::WebPageCreationParameters, gpuIOKitExtensionHandles)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::WebPageCreationParameters, gpuMachExtensionHandles)
#endif
#if ENABLE(TILED_CA_DRAWING_AREA)
        , offsetof(WebKit::WebPageCreationParameters, renderServerMachExtensionHandle)
#endif
#if HAVE(STATIC_FONT_REGISTRY)
        , offsetof(WebKit::WebPageCreationParameters, fontMachExtensionHandles)
#endif
#if HAVE(APP_ACCENT_COLORS)
        , offsetof(WebKit::WebPageCreationParameters, accentColor)
#endif
#if HAVE(APP_ACCENT_COLORS) && PLATFORM(MAC)
        , offsetof(WebKit::WebPageCreationParameters, appUsesCustomAccentColor)
#endif
#if USE(WPE_RENDERER)
        , offsetof(WebKit::WebPageCreationParameters, hostFileDescriptor)
#endif
#if USE(GRAPHICS_LAYER_TEXTURE_MAPPER) || USE(GRAPHICS_LAYER_WC)
        , offsetof(WebKit::WebPageCreationParameters, nativeWindowHandle)
#endif
#if USE(GRAPHICS_LAYER_WC)
        , offsetof(WebKit::WebPageCreationParameters, usesOffscreenRendering)
#endif
        , offsetof(WebKit::WebPageCreationParameters, shouldScaleViewToFitDocument)
        , offsetof(WebKit::WebPageCreationParameters, userInterfaceLayoutDirection)
        , offsetof(WebKit::WebPageCreationParameters, observedLayoutMilestones)
        , offsetof(WebKit::WebPageCreationParameters, overrideContentSecurityPolicy)
        , offsetof(WebKit::WebPageCreationParameters, cpuLimit)
        , offsetof(WebKit::WebPageCreationParameters, urlSchemeHandlers)
        , offsetof(WebKit::WebPageCreationParameters, urlSchemesWithLegacyCustomProtocolHandlers)
#if ENABLE(APPLICATION_MANIFEST)
        , offsetof(WebKit::WebPageCreationParameters, applicationManifest)
#endif
        , offsetof(WebKit::WebPageCreationParameters, needsFontAttributes)
        , offsetof(WebKit::WebPageCreationParameters, needsScrollGeometryUpdates)
        , offsetof(WebKit::WebPageCreationParameters, iceCandidateFilteringEnabled)
        , offsetof(WebKit::WebPageCreationParameters, enumeratingAllNetworkInterfacesEnabled)
        , offsetof(WebKit::WebPageCreationParameters, userContentControllerParameters)
#if ENABLE(WK_WEB_EXTENSIONS)
        , offsetof(WebKit::WebPageCreationParameters, webExtensionControllerParameters)
#endif
        , offsetof(WebKit::WebPageCreationParameters, backgroundColor)
        , offsetof(WebKit::WebPageCreationParameters, oldPageID)
        , offsetof(WebKit::WebPageCreationParameters, overriddenMediaType)
        , offsetof(WebKit::WebPageCreationParameters, corsDisablingPatterns)
        , offsetof(WebKit::WebPageCreationParameters, maskedURLSchemes)
        , offsetof(WebKit::WebPageCreationParameters, loadsSubresources)
        , offsetof(WebKit::WebPageCreationParameters, allowedNetworkHosts)
        , offsetof(WebKit::WebPageCreationParameters, portsForUpgradingInsecureSchemeForTesting)
        , offsetof(WebKit::WebPageCreationParameters, crossOriginAccessControlCheckEnabled)
        , offsetof(WebKit::WebPageCreationParameters, processDisplayName)
        , offsetof(WebKit::WebPageCreationParameters, shouldCaptureAudioInUIProcess)
        , offsetof(WebKit::WebPageCreationParameters, shouldCaptureAudioInGPUProcess)
        , offsetof(WebKit::WebPageCreationParameters, shouldCaptureVideoInUIProcess)
        , offsetof(WebKit::WebPageCreationParameters, shouldCaptureVideoInGPUProcess)
        , offsetof(WebKit::WebPageCreationParameters, shouldCaptureDisplayInUIProcess)
        , offsetof(WebKit::WebPageCreationParameters, shouldCaptureDisplayInGPUProcess)
        , offsetof(WebKit::WebPageCreationParameters, shouldRenderCanvasInGPUProcess)
        , offsetof(WebKit::WebPageCreationParameters, shouldRenderDOMInGPUProcess)
        , offsetof(WebKit::WebPageCreationParameters, shouldPlayMediaInGPUProcess)
#if ENABLE(WEBGL)
        , offsetof(WebKit::WebPageCreationParameters, shouldRenderWebGLInGPUProcess)
#endif
        , offsetof(WebKit::WebPageCreationParameters, shouldEnableVP8Decoder)
        , offsetof(WebKit::WebPageCreationParameters, shouldEnableVP9Decoder)
#if ENABLE(APP_BOUND_DOMAINS)
        , offsetof(WebKit::WebPageCreationParameters, limitsNavigationsToAppBoundDomains)
#endif
        , offsetof(WebKit::WebPageCreationParameters, lastNavigationWasAppInitiated)
        , offsetof(WebKit::WebPageCreationParameters, canUseCredentialStorage)
        , offsetof(WebKit::WebPageCreationParameters, shouldRelaxThirdPartyCookieBlocking)
        , offsetof(WebKit::WebPageCreationParameters, httpsUpgradeEnabled)
#if ENABLE(APP_HIGHLIGHTS)
        , offsetof(WebKit::WebPageCreationParameters, appHighlightsVisible)
#endif
#if HAVE(TOUCH_BAR)
        , offsetof(WebKit::WebPageCreationParameters, requiresUserActionForEditingControlsManager)
#endif
        , offsetof(WebKit::WebPageCreationParameters, hasResizableWindows)
        , offsetof(WebKit::WebPageCreationParameters, contentSecurityPolicyModeForExtension)
        , offsetof(WebKit::WebPageCreationParameters, remotePageParameters)
        , offsetof(WebKit::WebPageCreationParameters, provisionalFrameCreationParameters)
        , offsetof(WebKit::WebPageCreationParameters, mainFrameIdentifier)
        , offsetof(WebKit::WebPageCreationParameters, openedMainFrameName)
        , offsetof(WebKit::WebPageCreationParameters, mainFrameOpenerIdentifier)
        , offsetof(WebKit::WebPageCreationParameters, initialSandboxFlags)
        , offsetof(WebKit::WebPageCreationParameters, windowFeatures)
#if ENABLE(ADVANCED_PRIVACY_PROTECTIONS)
        , offsetof(WebKit::WebPageCreationParameters, linkDecorationFilteringData)
#endif
#if ENABLE(ADVANCED_PRIVACY_PROTECTIONS)
        , offsetof(WebKit::WebPageCreationParameters, allowedQueryParametersForAdvancedPrivacyProtections)
#endif
#if HAVE(MACH_BOOTSTRAP_EXTENSION)
        , offsetof(WebKit::WebPageCreationParameters, machBootstrapHandle)
#endif
#if (PLATFORM(GTK) || PLATFORM(WPE)) && (USE(GBM))
        , offsetof(WebKit::WebPageCreationParameters, preferredBufferFormats)
#endif
#if PLATFORM(VISION) && ENABLE(GAMEPAD)
        , offsetof(WebKit::WebPageCreationParameters, gamepadAccessRequiresExplicitConsent)
#endif
#if HAVE(AUDIT_TOKEN)
        , offsetof(WebKit::WebPageCreationParameters, presentingApplicationAuditToken)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::WebPageCreationParameters, presentingApplicationBundleIdentifier)
#endif
        , offsetof(WebKit::WebPageCreationParameters, shouldSendConsoleLogsToUIProcessForTesting)
    >::value);

    encoder << WTFMove(instance.viewSize);
    encoder << WTFMove(instance.activityState);
    encoder << WTFMove(instance.store);
#if ENABLE(TILED_CA_DRAWING_AREA)
    encoder << WTFMove(instance.drawingAreaType);
#endif
    encoder << WTFMove(instance.drawingAreaIdentifier);
    encoder << WTFMove(instance.webPageProxyIdentifier);
    encoder << WTFMove(instance.pageGroupData);
    encoder << WTFMove(instance.isEditable);
    encoder << WTFMove(instance.underlayColor);
    encoder << WTFMove(instance.useFixedLayout);
    encoder << WTFMove(instance.fixedLayoutSize);
    encoder << WTFMove(instance.defaultUnobscuredSize);
    encoder << WTFMove(instance.minimumUnobscuredSize);
    encoder << WTFMove(instance.maximumUnobscuredSize);
    encoder << WTFMove(instance.viewExposedRect);
    encoder << WTFMove(instance.displayID);
    encoder << WTFMove(instance.nominalFramesPerSecond);
    encoder << WTFMove(instance.alwaysShowsHorizontalScroller);
    encoder << WTFMove(instance.alwaysShowsVerticalScroller);
    encoder << WTFMove(instance.suppressScrollbarAnimations);
    encoder << WTFMove(instance.paginationMode);
    encoder << WTFMove(instance.paginationBehavesLikeColumns);
    encoder << WTFMove(instance.pageLength);
    encoder << WTFMove(instance.gapBetweenPages);
    encoder << WTFMove(instance.userAgent);
    encoder << WTFMove(instance.visitedLinkTableID);
    encoder << WTFMove(instance.canRunBeforeUnloadConfirmPanel);
    encoder << WTFMove(instance.canRunModal);
    encoder << WTFMove(instance.deviceScaleFactor);
#if USE(GRAPHICS_LAYER_WC) || USE(GRAPHICS_LAYER_TEXTURE_MAPPER)
    encoder << WTFMove(instance.intrinsicDeviceScaleFactor);
#endif
    encoder << WTFMove(instance.viewScaleFactor);
    encoder << WTFMove(instance.textZoomFactor);
    encoder << WTFMove(instance.pageZoomFactor);
    encoder << WTFMove(instance.obscuredContentInsets);
    encoder << WTFMove(instance.mediaVolume);
    encoder << WTFMove(instance.muted);
    encoder << WTFMove(instance.openedByDOM);
    encoder << WTFMove(instance.mayStartMediaWhenInWindow);
    encoder << WTFMove(instance.mediaPlaybackIsSuspended);
    encoder << WTFMove(instance.minimumSizeForAutoLayout);
    encoder << WTFMove(instance.sizeToContentAutoSizeMaximumSize);
    encoder << WTFMove(instance.autoSizingShouldExpandToViewHeight);
    encoder << WTFMove(instance.viewportSizeForCSSViewportUnits);
    encoder << WTFMove(instance.scrollPinningBehavior);
    encoder << WTFMove(instance.scrollbarOverlayStyle);
    encoder << WTFMove(instance.backgroundExtendsBeyondPage);
    encoder << WTFMove(instance.hasResourceLoadClient);
    encoder << WTFMove(instance.mimeTypesWithCustomContentProviders);
    encoder << WTFMove(instance.controlledByAutomation);
    encoder << WTFMove(instance.isProcessSwap);
    encoder << WTFMove(instance.useDarkAppearance);
    encoder << WTFMove(instance.useElevatedUserInterfaceLevel);
#if PLATFORM(MAC)
    encoder << WTFMove(instance.colorSpace);
#endif
#if PLATFORM(MAC)
    encoder << WTFMove(instance.useFormSemanticContext);
#endif
#if PLATFORM(MAC)
    encoder << WTFMove(instance.headerBannerHeight);
#endif
#if PLATFORM(MAC)
    encoder << WTFMove(instance.footerBannerHeight);
#endif
#if PLATFORM(MAC)
    encoder << WTFMove(instance.viewWindowCoordinates);
#endif
#if ENABLE(META_VIEWPORT)
    encoder << WTFMove(instance.ignoresViewportScaleLimits);
#endif
#if ENABLE(META_VIEWPORT)
    encoder << WTFMove(instance.viewportConfigurationViewLayoutSize);
#endif
#if ENABLE(META_VIEWPORT)
    encoder << WTFMove(instance.viewportConfigurationLayoutSizeScaleFactorFromClient);
#endif
#if ENABLE(META_VIEWPORT)
    encoder << WTFMove(instance.viewportConfigurationMinimumEffectiveDeviceWidth);
#endif
#if ENABLE(META_VIEWPORT)
    encoder << WTFMove(instance.viewportConfigurationViewSize);
#endif
#if ENABLE(META_VIEWPORT)
    encoder << WTFMove(instance.overrideViewportArguments);
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << WTFMove(instance.screenSize);
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << WTFMove(instance.availableScreenSize);
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << WTFMove(instance.overrideScreenSize);
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << WTFMove(instance.overrideAvailableScreenSize);
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << WTFMove(instance.textAutosizingWidth);
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << WTFMove(instance.deviceOrientation);
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << WTFMove(instance.hardwareKeyboardState);
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << WTFMove(instance.canShowWhileLocked);
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << WTFMove(instance.isCapturingScreen);
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << WTFMove(instance.insertionPointColor);
#endif
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.smartInsertDeleteEnabled);
#endif
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.additionalSupportedImageTypes);
#endif
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.gpuIOKitExtensionHandles);
#endif
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.gpuMachExtensionHandles);
#endif
#if ENABLE(TILED_CA_DRAWING_AREA)
    encoder << WTFMove(instance.renderServerMachExtensionHandle);
#endif
#if HAVE(STATIC_FONT_REGISTRY)
    encoder << WTFMove(instance.fontMachExtensionHandles);
#endif
#if HAVE(APP_ACCENT_COLORS)
    encoder << WTFMove(instance.accentColor);
#endif
#if HAVE(APP_ACCENT_COLORS) && PLATFORM(MAC)
    encoder << WTFMove(instance.appUsesCustomAccentColor);
#endif
#if USE(WPE_RENDERER)
    encoder << WTFMove(instance.hostFileDescriptor);
#endif
#if USE(GRAPHICS_LAYER_TEXTURE_MAPPER) || USE(GRAPHICS_LAYER_WC)
    encoder << WTFMove(instance.nativeWindowHandle);
#endif
#if USE(GRAPHICS_LAYER_WC)
    encoder << WTFMove(instance.usesOffscreenRendering);
#endif
    encoder << WTFMove(instance.shouldScaleViewToFitDocument);
    encoder << WTFMove(instance.userInterfaceLayoutDirection);
    encoder << WTFMove(instance.observedLayoutMilestones);
    encoder << WTFMove(instance.overrideContentSecurityPolicy);
    encoder << WTFMove(instance.cpuLimit);
    encoder << WTFMove(instance.urlSchemeHandlers);
    encoder << WTFMove(instance.urlSchemesWithLegacyCustomProtocolHandlers);
#if ENABLE(APPLICATION_MANIFEST)
    encoder << WTFMove(instance.applicationManifest);
#endif
    encoder << WTFMove(instance.needsFontAttributes);
    encoder << WTFMove(instance.needsScrollGeometryUpdates);
    encoder << WTFMove(instance.iceCandidateFilteringEnabled);
    encoder << WTFMove(instance.enumeratingAllNetworkInterfacesEnabled);
    encoder << WTFMove(instance.userContentControllerParameters);
#if ENABLE(WK_WEB_EXTENSIONS)
    encoder << WTFMove(instance.webExtensionControllerParameters);
#endif
    encoder << WTFMove(instance.backgroundColor);
    encoder << WTFMove(instance.oldPageID);
    encoder << WTFMove(instance.overriddenMediaType);
    encoder << WTFMove(instance.corsDisablingPatterns);
    encoder << WTFMove(instance.maskedURLSchemes);
    encoder << WTFMove(instance.loadsSubresources);
    encoder << WTFMove(instance.allowedNetworkHosts);
    encoder << WTFMove(instance.portsForUpgradingInsecureSchemeForTesting);
    encoder << WTFMove(instance.crossOriginAccessControlCheckEnabled);
    encoder << WTFMove(instance.processDisplayName);
    encoder << WTFMove(instance.shouldCaptureAudioInUIProcess);
    encoder << WTFMove(instance.shouldCaptureAudioInGPUProcess);
    encoder << WTFMove(instance.shouldCaptureVideoInUIProcess);
    encoder << WTFMove(instance.shouldCaptureVideoInGPUProcess);
    encoder << WTFMove(instance.shouldCaptureDisplayInUIProcess);
    encoder << WTFMove(instance.shouldCaptureDisplayInGPUProcess);
    encoder << WTFMove(instance.shouldRenderCanvasInGPUProcess);
    encoder << WTFMove(instance.shouldRenderDOMInGPUProcess);
    encoder << WTFMove(instance.shouldPlayMediaInGPUProcess);
#if ENABLE(WEBGL)
    encoder << WTFMove(instance.shouldRenderWebGLInGPUProcess);
#endif
    encoder << WTFMove(instance.shouldEnableVP8Decoder);
    encoder << WTFMove(instance.shouldEnableVP9Decoder);
#if ENABLE(APP_BOUND_DOMAINS)
    encoder << WTFMove(instance.limitsNavigationsToAppBoundDomains);
#endif
    encoder << WTFMove(instance.lastNavigationWasAppInitiated);
    encoder << WTFMove(instance.canUseCredentialStorage);
    encoder << WTFMove(instance.shouldRelaxThirdPartyCookieBlocking);
    encoder << WTFMove(instance.httpsUpgradeEnabled);
#if ENABLE(APP_HIGHLIGHTS)
    encoder << WTFMove(instance.appHighlightsVisible);
#endif
#if HAVE(TOUCH_BAR)
    encoder << WTFMove(instance.requiresUserActionForEditingControlsManager);
#endif
    encoder << WTFMove(instance.hasResizableWindows);
    encoder << WTFMove(instance.contentSecurityPolicyModeForExtension);
    encoder << WTFMove(instance.remotePageParameters);
    encoder << WTFMove(instance.provisionalFrameCreationParameters);
    encoder << WTFMove(instance.mainFrameIdentifier);
    encoder << WTFMove(instance.openedMainFrameName);
    encoder << WTFMove(instance.mainFrameOpenerIdentifier);
    encoder << WTFMove(instance.initialSandboxFlags);
    encoder << WTFMove(instance.windowFeatures);
#if ENABLE(ADVANCED_PRIVACY_PROTECTIONS)
    encoder << WTFMove(instance.linkDecorationFilteringData);
#endif
#if ENABLE(ADVANCED_PRIVACY_PROTECTIONS)
    encoder << WTFMove(instance.allowedQueryParametersForAdvancedPrivacyProtections);
#endif
#if HAVE(MACH_BOOTSTRAP_EXTENSION)
    encoder << WTFMove(instance.machBootstrapHandle);
#endif
#if (PLATFORM(GTK) || PLATFORM(WPE)) && (USE(GBM))
    encoder << WTFMove(instance.preferredBufferFormats);
#endif
#if PLATFORM(VISION) && ENABLE(GAMEPAD)
    encoder << WTFMove(instance.gamepadAccessRequiresExplicitConsent);
#endif
#if HAVE(AUDIT_TOKEN)
    encoder << WTFMove(instance.presentingApplicationAuditToken);
#endif
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.presentingApplicationBundleIdentifier);
#endif
    encoder << WTFMove(instance.shouldSendConsoleLogsToUIProcessForTesting);
}

std::optional<WebKit::WebPageCreationParameters> ArgumentCoder<WebKit::WebPageCreationParameters>::decode(Decoder& decoder)
{
    bool addedDecodingFailureIndex = false;
    auto viewSize = decoder.decode<WebCore::IntSize>();
    if (!viewSize && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(0);
        addedDecodingFailureIndex = true;
    }
    auto activityState = decoder.decode<OptionSet<WebCore::ActivityState>>();
    if (!activityState && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(1);
        addedDecodingFailureIndex = true;
    }
    auto store = decoder.decode<WebKit::WebPreferencesStore>();
    if (!store && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(2);
        addedDecodingFailureIndex = true;
    }
#if ENABLE(TILED_CA_DRAWING_AREA)
    auto drawingAreaType = decoder.decode<WebKit::DrawingAreaType>();
    if (!drawingAreaType && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(3);
        addedDecodingFailureIndex = true;
    }
#endif
    auto drawingAreaIdentifier = decoder.decode<WebKit::DrawingAreaIdentifier>();
    if (!drawingAreaIdentifier && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(4);
        addedDecodingFailureIndex = true;
    }
    auto webPageProxyIdentifier = decoder.decode<WebKit::WebPageProxyIdentifier>();
    if (!webPageProxyIdentifier && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(5);
        addedDecodingFailureIndex = true;
    }
    auto pageGroupData = decoder.decode<WebKit::WebPageGroupData>();
    if (!pageGroupData && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(6);
        addedDecodingFailureIndex = true;
    }
    auto isEditable = decoder.decode<bool>();
    if (!isEditable && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(7);
        addedDecodingFailureIndex = true;
    }
    auto underlayColor = decoder.decode<WebCore::Color>();
    if (!underlayColor && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(8);
        addedDecodingFailureIndex = true;
    }
    auto useFixedLayout = decoder.decode<bool>();
    if (!useFixedLayout && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(9);
        addedDecodingFailureIndex = true;
    }
    auto fixedLayoutSize = decoder.decode<WebCore::IntSize>();
    if (!fixedLayoutSize && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(10);
        addedDecodingFailureIndex = true;
    }
    auto defaultUnobscuredSize = decoder.decode<WebCore::FloatSize>();
    if (!defaultUnobscuredSize && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(11);
        addedDecodingFailureIndex = true;
    }
    auto minimumUnobscuredSize = decoder.decode<WebCore::FloatSize>();
    if (!minimumUnobscuredSize && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(12);
        addedDecodingFailureIndex = true;
    }
    auto maximumUnobscuredSize = decoder.decode<WebCore::FloatSize>();
    if (!maximumUnobscuredSize && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(13);
        addedDecodingFailureIndex = true;
    }
    auto viewExposedRect = decoder.decode<std::optional<WebCore::FloatRect>>();
    if (!viewExposedRect && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(14);
        addedDecodingFailureIndex = true;
    }
    auto displayID = decoder.decode<std::optional<uint32_t>>();
    if (!displayID && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(15);
        addedDecodingFailureIndex = true;
    }
    auto nominalFramesPerSecond = decoder.decode<std::optional<unsigned>>();
    if (!nominalFramesPerSecond && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(16);
        addedDecodingFailureIndex = true;
    }
    auto alwaysShowsHorizontalScroller = decoder.decode<bool>();
    if (!alwaysShowsHorizontalScroller && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(17);
        addedDecodingFailureIndex = true;
    }
    auto alwaysShowsVerticalScroller = decoder.decode<bool>();
    if (!alwaysShowsVerticalScroller && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(18);
        addedDecodingFailureIndex = true;
    }
    auto suppressScrollbarAnimations = decoder.decode<bool>();
    if (!suppressScrollbarAnimations && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(19);
        addedDecodingFailureIndex = true;
    }
    auto paginationMode = decoder.decode<WebCore::PaginationMode>();
    if (!paginationMode && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(20);
        addedDecodingFailureIndex = true;
    }
    auto paginationBehavesLikeColumns = decoder.decode<bool>();
    if (!paginationBehavesLikeColumns && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(21);
        addedDecodingFailureIndex = true;
    }
    auto pageLength = decoder.decode<double>();
    if (!pageLength && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(22);
        addedDecodingFailureIndex = true;
    }
    auto gapBetweenPages = decoder.decode<double>();
    if (!gapBetweenPages && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(23);
        addedDecodingFailureIndex = true;
    }
    auto userAgent = decoder.decode<String>();
    if (!userAgent && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(24);
        addedDecodingFailureIndex = true;
    }
    auto visitedLinkTableID = decoder.decode<WebKit::VisitedLinkTableIdentifier>();
    if (!visitedLinkTableID && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(25);
        addedDecodingFailureIndex = true;
    }
    auto canRunBeforeUnloadConfirmPanel = decoder.decode<bool>();
    if (!canRunBeforeUnloadConfirmPanel && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(26);
        addedDecodingFailureIndex = true;
    }
    auto canRunModal = decoder.decode<bool>();
    if (!canRunModal && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(27);
        addedDecodingFailureIndex = true;
    }
    auto deviceScaleFactor = decoder.decode<float>();
    if (!deviceScaleFactor && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(28);
        addedDecodingFailureIndex = true;
    }
#if USE(GRAPHICS_LAYER_WC) || USE(GRAPHICS_LAYER_TEXTURE_MAPPER)
    auto intrinsicDeviceScaleFactor = decoder.decode<float>();
    if (!intrinsicDeviceScaleFactor && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(29);
        addedDecodingFailureIndex = true;
    }
#endif
    auto viewScaleFactor = decoder.decode<float>();
    if (!viewScaleFactor && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(30);
        addedDecodingFailureIndex = true;
    }
    auto textZoomFactor = decoder.decode<double>();
    if (!textZoomFactor && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(31);
        addedDecodingFailureIndex = true;
    }
    auto pageZoomFactor = decoder.decode<double>();
    if (!pageZoomFactor && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(32);
        addedDecodingFailureIndex = true;
    }
    auto obscuredContentInsets = decoder.decode<WebCore::FloatBoxExtent>();
    if (!obscuredContentInsets && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(33);
        addedDecodingFailureIndex = true;
    }
    auto mediaVolume = decoder.decode<float>();
    if (!mediaVolume && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(34);
        addedDecodingFailureIndex = true;
    }
    auto muted = decoder.decode<WebCore::MediaProducerMutedStateFlags>();
    if (!muted && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(35);
        addedDecodingFailureIndex = true;
    }
    auto openedByDOM = decoder.decode<bool>();
    if (!openedByDOM && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(36);
        addedDecodingFailureIndex = true;
    }
    auto mayStartMediaWhenInWindow = decoder.decode<bool>();
    if (!mayStartMediaWhenInWindow && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(37);
        addedDecodingFailureIndex = true;
    }
    auto mediaPlaybackIsSuspended = decoder.decode<bool>();
    if (!mediaPlaybackIsSuspended && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(38);
        addedDecodingFailureIndex = true;
    }
    auto minimumSizeForAutoLayout = decoder.decode<WebCore::IntSize>();
    if (!minimumSizeForAutoLayout && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(39);
        addedDecodingFailureIndex = true;
    }
    auto sizeToContentAutoSizeMaximumSize = decoder.decode<WebCore::IntSize>();
    if (!sizeToContentAutoSizeMaximumSize && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(40);
        addedDecodingFailureIndex = true;
    }
    auto autoSizingShouldExpandToViewHeight = decoder.decode<bool>();
    if (!autoSizingShouldExpandToViewHeight && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(41);
        addedDecodingFailureIndex = true;
    }
    auto viewportSizeForCSSViewportUnits = decoder.decode<std::optional<WebCore::FloatSize>>();
    if (!viewportSizeForCSSViewportUnits && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(42);
        addedDecodingFailureIndex = true;
    }
    auto scrollPinningBehavior = decoder.decode<WebCore::ScrollPinningBehavior>();
    if (!scrollPinningBehavior && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(43);
        addedDecodingFailureIndex = true;
    }
    auto scrollbarOverlayStyle = decoder.decode<std::optional<WebCore::ScrollbarOverlayStyle>>();
    if (!scrollbarOverlayStyle && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(44);
        addedDecodingFailureIndex = true;
    }
    auto backgroundExtendsBeyondPage = decoder.decode<bool>();
    if (!backgroundExtendsBeyondPage && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(45);
        addedDecodingFailureIndex = true;
    }
    auto hasResourceLoadClient = decoder.decode<bool>();
    if (!hasResourceLoadClient && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(46);
        addedDecodingFailureIndex = true;
    }
    auto mimeTypesWithCustomContentProviders = decoder.decode<Vector<String>>();
    if (!mimeTypesWithCustomContentProviders && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(47);
        addedDecodingFailureIndex = true;
    }
    auto controlledByAutomation = decoder.decode<bool>();
    if (!controlledByAutomation && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(48);
        addedDecodingFailureIndex = true;
    }
    auto isProcessSwap = decoder.decode<bool>();
    if (!isProcessSwap && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(49);
        addedDecodingFailureIndex = true;
    }
    auto useDarkAppearance = decoder.decode<bool>();
    if (!useDarkAppearance && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(50);
        addedDecodingFailureIndex = true;
    }
    auto useElevatedUserInterfaceLevel = decoder.decode<bool>();
    if (!useElevatedUserInterfaceLevel && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(51);
        addedDecodingFailureIndex = true;
    }
#if PLATFORM(MAC)
    auto colorSpace = decoder.decode<std::optional<WebCore::DestinationColorSpace>>();
    if (!colorSpace && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(52);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(MAC)
    auto useFormSemanticContext = decoder.decode<bool>();
    if (!useFormSemanticContext && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(53);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(MAC)
    auto headerBannerHeight = decoder.decode<int>();
    if (!headerBannerHeight && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(54);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(MAC)
    auto footerBannerHeight = decoder.decode<int>();
    if (!footerBannerHeight && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(55);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(MAC)
    auto viewWindowCoordinates = decoder.decode<std::optional<WebKit::ViewWindowCoordinates>>();
    if (!viewWindowCoordinates && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(56);
        addedDecodingFailureIndex = true;
    }
#endif
#if ENABLE(META_VIEWPORT)
    auto ignoresViewportScaleLimits = decoder.decode<bool>();
    if (!ignoresViewportScaleLimits && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(57);
        addedDecodingFailureIndex = true;
    }
#endif
#if ENABLE(META_VIEWPORT)
    auto viewportConfigurationViewLayoutSize = decoder.decode<WebCore::FloatSize>();
    if (!viewportConfigurationViewLayoutSize && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(58);
        addedDecodingFailureIndex = true;
    }
#endif
#if ENABLE(META_VIEWPORT)
    auto viewportConfigurationLayoutSizeScaleFactorFromClient = decoder.decode<double>();
    if (!viewportConfigurationLayoutSizeScaleFactorFromClient && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(59);
        addedDecodingFailureIndex = true;
    }
#endif
#if ENABLE(META_VIEWPORT)
    auto viewportConfigurationMinimumEffectiveDeviceWidth = decoder.decode<double>();
    if (!viewportConfigurationMinimumEffectiveDeviceWidth && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(60);
        addedDecodingFailureIndex = true;
    }
#endif
#if ENABLE(META_VIEWPORT)
    auto viewportConfigurationViewSize = decoder.decode<WebCore::FloatSize>();
    if (!viewportConfigurationViewSize && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(61);
        addedDecodingFailureIndex = true;
    }
#endif
#if ENABLE(META_VIEWPORT)
    auto overrideViewportArguments = decoder.decode<std::optional<WebCore::ViewportArguments>>();
    if (!overrideViewportArguments && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(62);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(IOS_FAMILY)
    auto screenSize = decoder.decode<WebCore::FloatSize>();
    if (!screenSize && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(63);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(IOS_FAMILY)
    auto availableScreenSize = decoder.decode<WebCore::FloatSize>();
    if (!availableScreenSize && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(64);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(IOS_FAMILY)
    auto overrideScreenSize = decoder.decode<WebCore::FloatSize>();
    if (!overrideScreenSize && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(65);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(IOS_FAMILY)
    auto overrideAvailableScreenSize = decoder.decode<WebCore::FloatSize>();
    if (!overrideAvailableScreenSize && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(66);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(IOS_FAMILY)
    auto textAutosizingWidth = decoder.decode<float>();
    if (!textAutosizingWidth && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(67);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(IOS_FAMILY)
    auto deviceOrientation = decoder.decode<WebCore::IntDegrees>();
    if (!deviceOrientation && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(68);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(IOS_FAMILY)
    auto hardwareKeyboardState = decoder.decode<WebKit::HardwareKeyboardState>();
    if (!hardwareKeyboardState && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(69);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(IOS_FAMILY)
    auto canShowWhileLocked = decoder.decode<bool>();
    if (!canShowWhileLocked && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(70);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(IOS_FAMILY)
    auto isCapturingScreen = decoder.decode<bool>();
    if (!isCapturingScreen && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(71);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(IOS_FAMILY)
    auto insertionPointColor = decoder.decode<WebCore::Color>();
    if (!insertionPointColor && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(72);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(COCOA)
    auto smartInsertDeleteEnabled = decoder.decode<bool>();
    if (!smartInsertDeleteEnabled && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(73);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(COCOA)
    auto additionalSupportedImageTypes = decoder.decode<Vector<String>>();
    if (!additionalSupportedImageTypes && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(74);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(COCOA)
    auto gpuIOKitExtensionHandles = decoder.decode<Vector<WebKit::SandboxExtensionHandle>>();
    if (!gpuIOKitExtensionHandles && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(75);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(COCOA)
    auto gpuMachExtensionHandles = decoder.decode<Vector<WebKit::SandboxExtensionHandle>>();
    if (!gpuMachExtensionHandles && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(76);
        addedDecodingFailureIndex = true;
    }
#endif
#if ENABLE(TILED_CA_DRAWING_AREA)
    auto renderServerMachExtensionHandle = decoder.decode<WebKit::SandboxExtensionHandle>();
    if (!renderServerMachExtensionHandle && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(77);
        addedDecodingFailureIndex = true;
    }
#endif
#if HAVE(STATIC_FONT_REGISTRY)
    auto fontMachExtensionHandles = decoder.decode<Vector<WebKit::SandboxExtensionHandle>>();
    if (!fontMachExtensionHandles && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(78);
        addedDecodingFailureIndex = true;
    }
#endif
#if HAVE(APP_ACCENT_COLORS)
    auto accentColor = decoder.decode<WebCore::Color>();
    if (!accentColor && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(79);
        addedDecodingFailureIndex = true;
    }
#endif
#if HAVE(APP_ACCENT_COLORS) && PLATFORM(MAC)
    auto appUsesCustomAccentColor = decoder.decode<bool>();
    if (!appUsesCustomAccentColor && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(80);
        addedDecodingFailureIndex = true;
    }
#endif
#if USE(WPE_RENDERER)
    auto hostFileDescriptor = decoder.decode<UnixFileDescriptor>();
    if (!hostFileDescriptor && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(81);
        addedDecodingFailureIndex = true;
    }
#endif
#if USE(GRAPHICS_LAYER_TEXTURE_MAPPER) || USE(GRAPHICS_LAYER_WC)
    auto nativeWindowHandle = decoder.decode<uint64_t>();
    if (!nativeWindowHandle && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(82);
        addedDecodingFailureIndex = true;
    }
#endif
#if USE(GRAPHICS_LAYER_WC)
    auto usesOffscreenRendering = decoder.decode<bool>();
    if (!usesOffscreenRendering && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(83);
        addedDecodingFailureIndex = true;
    }
#endif
    auto shouldScaleViewToFitDocument = decoder.decode<bool>();
    if (!shouldScaleViewToFitDocument && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(84);
        addedDecodingFailureIndex = true;
    }
    auto userInterfaceLayoutDirection = decoder.decode<WebCore::UserInterfaceLayoutDirection>();
    if (!userInterfaceLayoutDirection && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(85);
        addedDecodingFailureIndex = true;
    }
    auto observedLayoutMilestones = decoder.decode<OptionSet<WebCore::LayoutMilestone>>();
    if (!observedLayoutMilestones && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(86);
        addedDecodingFailureIndex = true;
    }
    auto overrideContentSecurityPolicy = decoder.decode<String>();
    if (!overrideContentSecurityPolicy && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(87);
        addedDecodingFailureIndex = true;
    }
    auto cpuLimit = decoder.decode<std::optional<double>>();
    if (!cpuLimit && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(88);
        addedDecodingFailureIndex = true;
    }
    auto urlSchemeHandlers = decoder.decode<HashMap<String, WebKit::WebURLSchemeHandlerIdentifier>>();
    if (!urlSchemeHandlers && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(89);
        addedDecodingFailureIndex = true;
    }
    auto urlSchemesWithLegacyCustomProtocolHandlers = decoder.decode<Vector<String>>();
    if (!urlSchemesWithLegacyCustomProtocolHandlers && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(90);
        addedDecodingFailureIndex = true;
    }
#if ENABLE(APPLICATION_MANIFEST)
    auto applicationManifest = decoder.decode<std::optional<WebCore::ApplicationManifest>>();
    if (!applicationManifest && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(91);
        addedDecodingFailureIndex = true;
    }
#endif
    auto needsFontAttributes = decoder.decode<bool>();
    if (!needsFontAttributes && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(92);
        addedDecodingFailureIndex = true;
    }
    auto needsScrollGeometryUpdates = decoder.decode<bool>();
    if (!needsScrollGeometryUpdates && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(93);
        addedDecodingFailureIndex = true;
    }
    auto iceCandidateFilteringEnabled = decoder.decode<bool>();
    if (!iceCandidateFilteringEnabled && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(94);
        addedDecodingFailureIndex = true;
    }
    auto enumeratingAllNetworkInterfacesEnabled = decoder.decode<bool>();
    if (!enumeratingAllNetworkInterfacesEnabled && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(95);
        addedDecodingFailureIndex = true;
    }
    auto userContentControllerParameters = decoder.decode<WebKit::UserContentControllerParameters>();
    if (!userContentControllerParameters && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(96);
        addedDecodingFailureIndex = true;
    }
#if ENABLE(WK_WEB_EXTENSIONS)
    auto webExtensionControllerParameters = decoder.decode<std::optional<WebKit::WebExtensionControllerParameters>>();
    if (!webExtensionControllerParameters && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(97);
        addedDecodingFailureIndex = true;
    }
#endif
    auto backgroundColor = decoder.decode<std::optional<WebCore::Color>>();
    if (!backgroundColor && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(98);
        addedDecodingFailureIndex = true;
    }
    auto oldPageID = decoder.decode<std::optional<WebCore::PageIdentifier>>();
    if (!oldPageID && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(99);
        addedDecodingFailureIndex = true;
    }
    auto overriddenMediaType = decoder.decode<String>();
    if (!overriddenMediaType && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(100);
        addedDecodingFailureIndex = true;
    }
    auto corsDisablingPatterns = decoder.decode<Vector<String>>();
    if (!corsDisablingPatterns && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(101);
        addedDecodingFailureIndex = true;
    }
    auto maskedURLSchemes = decoder.decode<HashSet<String>>();
    if (!maskedURLSchemes && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(102);
        addedDecodingFailureIndex = true;
    }
    auto loadsSubresources = decoder.decode<bool>();
    if (!loadsSubresources && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(103);
        addedDecodingFailureIndex = true;
    }
    auto allowedNetworkHosts = decoder.decode<std::optional<MemoryCompactLookupOnlyRobinHoodHashSet<String>>>();
    if (!allowedNetworkHosts && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(104);
        addedDecodingFailureIndex = true;
    }
    auto portsForUpgradingInsecureSchemeForTesting = decoder.decode<std::optional<std::pair<uint16_t, uint16_t>>>();
    if (!portsForUpgradingInsecureSchemeForTesting && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(105);
        addedDecodingFailureIndex = true;
    }
    auto crossOriginAccessControlCheckEnabled = decoder.decode<bool>();
    if (!crossOriginAccessControlCheckEnabled && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(106);
        addedDecodingFailureIndex = true;
    }
    auto processDisplayName = decoder.decode<String>();
    if (!processDisplayName && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(107);
        addedDecodingFailureIndex = true;
    }
    auto shouldCaptureAudioInUIProcess = decoder.decode<bool>();
    if (!shouldCaptureAudioInUIProcess && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(108);
        addedDecodingFailureIndex = true;
    }
    auto shouldCaptureAudioInGPUProcess = decoder.decode<bool>();
    if (!shouldCaptureAudioInGPUProcess && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(109);
        addedDecodingFailureIndex = true;
    }
    auto shouldCaptureVideoInUIProcess = decoder.decode<bool>();
    if (!shouldCaptureVideoInUIProcess && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(110);
        addedDecodingFailureIndex = true;
    }
    auto shouldCaptureVideoInGPUProcess = decoder.decode<bool>();
    if (!shouldCaptureVideoInGPUProcess && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(111);
        addedDecodingFailureIndex = true;
    }
    auto shouldCaptureDisplayInUIProcess = decoder.decode<bool>();
    if (!shouldCaptureDisplayInUIProcess && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(112);
        addedDecodingFailureIndex = true;
    }
    auto shouldCaptureDisplayInGPUProcess = decoder.decode<bool>();
    if (!shouldCaptureDisplayInGPUProcess && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(113);
        addedDecodingFailureIndex = true;
    }
    auto shouldRenderCanvasInGPUProcess = decoder.decode<bool>();
    if (!shouldRenderCanvasInGPUProcess && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(114);
        addedDecodingFailureIndex = true;
    }
    auto shouldRenderDOMInGPUProcess = decoder.decode<bool>();
    if (!shouldRenderDOMInGPUProcess && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(115);
        addedDecodingFailureIndex = true;
    }
    auto shouldPlayMediaInGPUProcess = decoder.decode<bool>();
    if (!shouldPlayMediaInGPUProcess && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(116);
        addedDecodingFailureIndex = true;
    }
#if ENABLE(WEBGL)
    auto shouldRenderWebGLInGPUProcess = decoder.decode<bool>();
    if (!shouldRenderWebGLInGPUProcess && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(117);
        addedDecodingFailureIndex = true;
    }
#endif
    auto shouldEnableVP8Decoder = decoder.decode<bool>();
    if (!shouldEnableVP8Decoder && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(118);
        addedDecodingFailureIndex = true;
    }
    auto shouldEnableVP9Decoder = decoder.decode<bool>();
    if (!shouldEnableVP9Decoder && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(119);
        addedDecodingFailureIndex = true;
    }
#if ENABLE(APP_BOUND_DOMAINS)
    auto limitsNavigationsToAppBoundDomains = decoder.decode<bool>();
    if (!limitsNavigationsToAppBoundDomains && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(120);
        addedDecodingFailureIndex = true;
    }
#endif
    auto lastNavigationWasAppInitiated = decoder.decode<bool>();
    if (!lastNavigationWasAppInitiated && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(121);
        addedDecodingFailureIndex = true;
    }
    auto canUseCredentialStorage = decoder.decode<bool>();
    if (!canUseCredentialStorage && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(122);
        addedDecodingFailureIndex = true;
    }
    auto shouldRelaxThirdPartyCookieBlocking = decoder.decode<WebCore::ShouldRelaxThirdPartyCookieBlocking>();
    if (!shouldRelaxThirdPartyCookieBlocking && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(123);
        addedDecodingFailureIndex = true;
    }
    auto httpsUpgradeEnabled = decoder.decode<bool>();
    if (!httpsUpgradeEnabled && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(124);
        addedDecodingFailureIndex = true;
    }
#if ENABLE(APP_HIGHLIGHTS)
    auto appHighlightsVisible = decoder.decode<WebCore::HighlightVisibility>();
    if (!appHighlightsVisible && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(125);
        addedDecodingFailureIndex = true;
    }
#endif
#if HAVE(TOUCH_BAR)
    auto requiresUserActionForEditingControlsManager = decoder.decode<bool>();
    if (!requiresUserActionForEditingControlsManager && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(126);
        addedDecodingFailureIndex = true;
    }
#endif
    auto hasResizableWindows = decoder.decode<bool>();
    if (!hasResizableWindows && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(127);
        addedDecodingFailureIndex = true;
    }
    auto contentSecurityPolicyModeForExtension = decoder.decode<WebCore::ContentSecurityPolicyModeForExtension>();
    if (!contentSecurityPolicyModeForExtension && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(128);
        addedDecodingFailureIndex = true;
    }
    auto remotePageParameters = decoder.decode<std::optional<WebKit::RemotePageParameters>>();
    if (!remotePageParameters && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(129);
        addedDecodingFailureIndex = true;
    }
    auto provisionalFrameCreationParameters = decoder.decode<std::optional<WebKit::ProvisionalFrameCreationParameters>>();
    if (!provisionalFrameCreationParameters && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(130);
        addedDecodingFailureIndex = true;
    }
    auto mainFrameIdentifier = decoder.decode<WebCore::FrameIdentifier>();
    if (!mainFrameIdentifier && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(131);
        addedDecodingFailureIndex = true;
    }
    auto openedMainFrameName = decoder.decode<String>();
    if (!openedMainFrameName && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(132);
        addedDecodingFailureIndex = true;
    }
    auto mainFrameOpenerIdentifier = decoder.decode<std::optional<WebCore::FrameIdentifier>>();
    if (!mainFrameOpenerIdentifier && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(133);
        addedDecodingFailureIndex = true;
    }
    auto initialSandboxFlags = decoder.decode<WebCore::SandboxFlags>();
    if (!initialSandboxFlags && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(134);
        addedDecodingFailureIndex = true;
    }
    auto windowFeatures = decoder.decode<std::optional<WebCore::WindowFeatures>>();
    if (!windowFeatures && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(135);
        addedDecodingFailureIndex = true;
    }
#if ENABLE(ADVANCED_PRIVACY_PROTECTIONS)
    auto linkDecorationFilteringData = decoder.decode<Vector<WebCore::LinkDecorationFilteringData>>();
    if (!linkDecorationFilteringData && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(136);
        addedDecodingFailureIndex = true;
    }
#endif
#if ENABLE(ADVANCED_PRIVACY_PROTECTIONS)
    auto allowedQueryParametersForAdvancedPrivacyProtections = decoder.decode<Vector<WebCore::LinkDecorationFilteringData>>();
    if (!allowedQueryParametersForAdvancedPrivacyProtections && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(137);
        addedDecodingFailureIndex = true;
    }
#endif
#if HAVE(MACH_BOOTSTRAP_EXTENSION)
    auto machBootstrapHandle = decoder.decode<WebKit::SandboxExtensionHandle>();
    if (!machBootstrapHandle && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(138);
        addedDecodingFailureIndex = true;
    }
#endif
#if (PLATFORM(GTK) || PLATFORM(WPE)) && (USE(GBM))
    auto preferredBufferFormats = decoder.decode<Vector<WebKit::RendererBufferFormat>>();
    if (!preferredBufferFormats && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(139);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(VISION) && ENABLE(GAMEPAD)
    auto gamepadAccessRequiresExplicitConsent = decoder.decode<WebCore::ShouldRequireExplicitConsentForGamepadAccess>();
    if (!gamepadAccessRequiresExplicitConsent && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(140);
        addedDecodingFailureIndex = true;
    }
#endif
#if HAVE(AUDIT_TOKEN)
    auto presentingApplicationAuditToken = decoder.decode<std::optional<WebKit::CoreIPCAuditToken>>();
    if (!presentingApplicationAuditToken && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(141);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(COCOA)
    auto presentingApplicationBundleIdentifier = decoder.decode<String>();
    if (!presentingApplicationBundleIdentifier && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(142);
        addedDecodingFailureIndex = true;
    }
#endif
    auto shouldSendConsoleLogsToUIProcessForTesting = decoder.decode<bool>();
    if (!shouldSendConsoleLogsToUIProcessForTesting && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(143);
        addedDecodingFailureIndex = true;
    }
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebPageCreationParameters {
            WTFMove(*viewSize),
            WTFMove(*activityState),
            WTFMove(*store),
#if ENABLE(TILED_CA_DRAWING_AREA)
            WTFMove(*drawingAreaType),
#endif
            WTFMove(*drawingAreaIdentifier),
            WTFMove(*webPageProxyIdentifier),
            WTFMove(*pageGroupData),
            WTFMove(*isEditable),
            WTFMove(*underlayColor),
            WTFMove(*useFixedLayout),
            WTFMove(*fixedLayoutSize),
            WTFMove(*defaultUnobscuredSize),
            WTFMove(*minimumUnobscuredSize),
            WTFMove(*maximumUnobscuredSize),
            WTFMove(*viewExposedRect),
            WTFMove(*displayID),
            WTFMove(*nominalFramesPerSecond),
            WTFMove(*alwaysShowsHorizontalScroller),
            WTFMove(*alwaysShowsVerticalScroller),
            WTFMove(*suppressScrollbarAnimations),
            WTFMove(*paginationMode),
            WTFMove(*paginationBehavesLikeColumns),
            WTFMove(*pageLength),
            WTFMove(*gapBetweenPages),
            WTFMove(*userAgent),
            WTFMove(*visitedLinkTableID),
            WTFMove(*canRunBeforeUnloadConfirmPanel),
            WTFMove(*canRunModal),
            WTFMove(*deviceScaleFactor),
#if USE(GRAPHICS_LAYER_WC) || USE(GRAPHICS_LAYER_TEXTURE_MAPPER)
            WTFMove(*intrinsicDeviceScaleFactor),
#endif
            WTFMove(*viewScaleFactor),
            WTFMove(*textZoomFactor),
            WTFMove(*pageZoomFactor),
            WTFMove(*obscuredContentInsets),
            WTFMove(*mediaVolume),
            WTFMove(*muted),
            WTFMove(*openedByDOM),
            WTFMove(*mayStartMediaWhenInWindow),
            WTFMove(*mediaPlaybackIsSuspended),
            WTFMove(*minimumSizeForAutoLayout),
            WTFMove(*sizeToContentAutoSizeMaximumSize),
            WTFMove(*autoSizingShouldExpandToViewHeight),
            WTFMove(*viewportSizeForCSSViewportUnits),
            WTFMove(*scrollPinningBehavior),
            WTFMove(*scrollbarOverlayStyle),
            WTFMove(*backgroundExtendsBeyondPage),
            WTFMove(*hasResourceLoadClient),
            WTFMove(*mimeTypesWithCustomContentProviders),
            WTFMove(*controlledByAutomation),
            WTFMove(*isProcessSwap),
            WTFMove(*useDarkAppearance),
            WTFMove(*useElevatedUserInterfaceLevel),
#if PLATFORM(MAC)
            WTFMove(*colorSpace),
#endif
#if PLATFORM(MAC)
            WTFMove(*useFormSemanticContext),
#endif
#if PLATFORM(MAC)
            WTFMove(*headerBannerHeight),
#endif
#if PLATFORM(MAC)
            WTFMove(*footerBannerHeight),
#endif
#if PLATFORM(MAC)
            WTFMove(*viewWindowCoordinates),
#endif
#if ENABLE(META_VIEWPORT)
            WTFMove(*ignoresViewportScaleLimits),
#endif
#if ENABLE(META_VIEWPORT)
            WTFMove(*viewportConfigurationViewLayoutSize),
#endif
#if ENABLE(META_VIEWPORT)
            WTFMove(*viewportConfigurationLayoutSizeScaleFactorFromClient),
#endif
#if ENABLE(META_VIEWPORT)
            WTFMove(*viewportConfigurationMinimumEffectiveDeviceWidth),
#endif
#if ENABLE(META_VIEWPORT)
            WTFMove(*viewportConfigurationViewSize),
#endif
#if ENABLE(META_VIEWPORT)
            WTFMove(*overrideViewportArguments),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*screenSize),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*availableScreenSize),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*overrideScreenSize),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*overrideAvailableScreenSize),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*textAutosizingWidth),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*deviceOrientation),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*hardwareKeyboardState),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*canShowWhileLocked),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*isCapturingScreen),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*insertionPointColor),
#endif
#if PLATFORM(COCOA)
            WTFMove(*smartInsertDeleteEnabled),
#endif
#if PLATFORM(COCOA)
            WTFMove(*additionalSupportedImageTypes),
#endif
#if PLATFORM(COCOA)
            WTFMove(*gpuIOKitExtensionHandles),
#endif
#if PLATFORM(COCOA)
            WTFMove(*gpuMachExtensionHandles),
#endif
#if ENABLE(TILED_CA_DRAWING_AREA)
            WTFMove(*renderServerMachExtensionHandle),
#endif
#if HAVE(STATIC_FONT_REGISTRY)
            WTFMove(*fontMachExtensionHandles),
#endif
#if HAVE(APP_ACCENT_COLORS)
            WTFMove(*accentColor),
#endif
#if HAVE(APP_ACCENT_COLORS) && PLATFORM(MAC)
            WTFMove(*appUsesCustomAccentColor),
#endif
#if USE(WPE_RENDERER)
            WTFMove(*hostFileDescriptor),
#endif
#if USE(GRAPHICS_LAYER_TEXTURE_MAPPER) || USE(GRAPHICS_LAYER_WC)
            WTFMove(*nativeWindowHandle),
#endif
#if USE(GRAPHICS_LAYER_WC)
            WTFMove(*usesOffscreenRendering),
#endif
            WTFMove(*shouldScaleViewToFitDocument),
            WTFMove(*userInterfaceLayoutDirection),
            WTFMove(*observedLayoutMilestones),
            WTFMove(*overrideContentSecurityPolicy),
            WTFMove(*cpuLimit),
            WTFMove(*urlSchemeHandlers),
            WTFMove(*urlSchemesWithLegacyCustomProtocolHandlers),
#if ENABLE(APPLICATION_MANIFEST)
            WTFMove(*applicationManifest),
#endif
            WTFMove(*needsFontAttributes),
            WTFMove(*needsScrollGeometryUpdates),
            WTFMove(*iceCandidateFilteringEnabled),
            WTFMove(*enumeratingAllNetworkInterfacesEnabled),
            WTFMove(*userContentControllerParameters),
#if ENABLE(WK_WEB_EXTENSIONS)
            WTFMove(*webExtensionControllerParameters),
#endif
            WTFMove(*backgroundColor),
            WTFMove(*oldPageID),
            WTFMove(*overriddenMediaType),
            WTFMove(*corsDisablingPatterns),
            WTFMove(*maskedURLSchemes),
            WTFMove(*loadsSubresources),
            WTFMove(*allowedNetworkHosts),
            WTFMove(*portsForUpgradingInsecureSchemeForTesting),
            WTFMove(*crossOriginAccessControlCheckEnabled),
            WTFMove(*processDisplayName),
            WTFMove(*shouldCaptureAudioInUIProcess),
            WTFMove(*shouldCaptureAudioInGPUProcess),
            WTFMove(*shouldCaptureVideoInUIProcess),
            WTFMove(*shouldCaptureVideoInGPUProcess),
            WTFMove(*shouldCaptureDisplayInUIProcess),
            WTFMove(*shouldCaptureDisplayInGPUProcess),
            WTFMove(*shouldRenderCanvasInGPUProcess),
            WTFMove(*shouldRenderDOMInGPUProcess),
            WTFMove(*shouldPlayMediaInGPUProcess),
#if ENABLE(WEBGL)
            WTFMove(*shouldRenderWebGLInGPUProcess),
#endif
            WTFMove(*shouldEnableVP8Decoder),
            WTFMove(*shouldEnableVP9Decoder),
#if ENABLE(APP_BOUND_DOMAINS)
            WTFMove(*limitsNavigationsToAppBoundDomains),
#endif
            WTFMove(*lastNavigationWasAppInitiated),
            WTFMove(*canUseCredentialStorage),
            WTFMove(*shouldRelaxThirdPartyCookieBlocking),
            WTFMove(*httpsUpgradeEnabled),
#if ENABLE(APP_HIGHLIGHTS)
            WTFMove(*appHighlightsVisible),
#endif
#if HAVE(TOUCH_BAR)
            WTFMove(*requiresUserActionForEditingControlsManager),
#endif
            WTFMove(*hasResizableWindows),
            WTFMove(*contentSecurityPolicyModeForExtension),
            WTFMove(*remotePageParameters),
            WTFMove(*provisionalFrameCreationParameters),
            WTFMove(*mainFrameIdentifier),
            WTFMove(*openedMainFrameName),
            WTFMove(*mainFrameOpenerIdentifier),
            WTFMove(*initialSandboxFlags),
            WTFMove(*windowFeatures),
#if ENABLE(ADVANCED_PRIVACY_PROTECTIONS)
            WTFMove(*linkDecorationFilteringData),
#endif
#if ENABLE(ADVANCED_PRIVACY_PROTECTIONS)
            WTFMove(*allowedQueryParametersForAdvancedPrivacyProtections),
#endif
#if HAVE(MACH_BOOTSTRAP_EXTENSION)
            WTFMove(*machBootstrapHandle),
#endif
#if (PLATFORM(GTK) || PLATFORM(WPE)) && (USE(GBM))
            WTFMove(*preferredBufferFormats),
#endif
#if PLATFORM(VISION) && ENABLE(GAMEPAD)
            WTFMove(*gamepadAccessRequiresExplicitConsent),
#endif
#if HAVE(AUDIT_TOKEN)
            WTFMove(*presentingApplicationAuditToken),
#endif
#if PLATFORM(COCOA)
            WTFMove(*presentingApplicationBundleIdentifier),
#endif
            WTFMove(*shouldSendConsoleLogsToUIProcessForTesting)
        }
    };
}

void ArgumentCoder<WebKit::RemotePageParameters>::encode(Encoder& encoder, const WebKit::RemotePageParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.initialMainDocumentURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameTreeParameters)>, WebKit::FrameTreeCreationParameters>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.websitePoliciesData)>, std::optional<WebKit::WebsitePoliciesData>>);
    struct ShouldBeSameSizeAsRemotePageParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::RemotePageParameters>, false> {
        URL initialMainDocumentURL;
        WebKit::FrameTreeCreationParameters frameTreeParameters;
        std::optional<WebKit::WebsitePoliciesData> websitePoliciesData;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRemotePageParameters) == sizeof(WebKit::RemotePageParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::RemotePageParameters, initialMainDocumentURL)
        , offsetof(WebKit::RemotePageParameters, frameTreeParameters)
        , offsetof(WebKit::RemotePageParameters, websitePoliciesData)
    >::value);

    encoder << instance.initialMainDocumentURL;
    encoder << instance.frameTreeParameters;
    encoder << instance.websitePoliciesData;
}

std::optional<WebKit::RemotePageParameters> ArgumentCoder<WebKit::RemotePageParameters>::decode(Decoder& decoder)
{
    auto initialMainDocumentURL = decoder.decode<URL>();
    auto frameTreeParameters = decoder.decode<WebKit::FrameTreeCreationParameters>();
    auto websitePoliciesData = decoder.decode<std::optional<WebKit::WebsitePoliciesData>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::RemotePageParameters {
            WTFMove(*initialMainDocumentURL),
            WTFMove(*frameTreeParameters),
            WTFMove(*websitePoliciesData)
        }
    };
}

void ArgumentCoder<WebKit::WebPageGroupData>::encode(Encoder& encoder, const WebKit::WebPageGroupData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pageGroupID)>, WebKit::PageGroupIdentifier>);
    struct ShouldBeSameSizeAsWebPageGroupData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebPageGroupData>, false> {
        String identifier;
        WebKit::PageGroupIdentifier pageGroupID;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebPageGroupData) == sizeof(WebKit::WebPageGroupData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebPageGroupData, identifier)
        , offsetof(WebKit::WebPageGroupData, pageGroupID)
    >::value);

    encoder << instance.identifier;
    encoder << instance.pageGroupID;
}

std::optional<WebKit::WebPageGroupData> ArgumentCoder<WebKit::WebPageGroupData>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<String>();
    auto pageGroupID = decoder.decode<WebKit::PageGroupIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebPageGroupData {
            WTFMove(*identifier),
            WTFMove(*pageGroupID)
        }
    };
}

void ArgumentCoder<WebKit::WebPageNetworkParameters>::encode(Encoder& encoder, const WebKit::WebPageNetworkParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.attributedBundleIdentifier())>, String>);

    encoder << instance.attributedBundleIdentifier();
}

std::optional<WebKit::WebPageNetworkParameters> ArgumentCoder<WebKit::WebPageNetworkParameters>::decode(Decoder& decoder)
{
    auto attributedBundleIdentifier = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebPageNetworkParameters {
            WTFMove(*attributedBundleIdentifier)
        }
    };
}

void ArgumentCoder<WebKit::WebPopupItem>::encode(Encoder& encoder, const WebKit::WebPopupItem& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_type)>, WebKit::WebPopupItem::Type>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_text)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_language)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_textDirection)>, WebCore::TextDirection>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_hasTextDirectionOverride)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_toolTip)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_accessibilityText)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_isEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_isLabel)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_isSelected)>, bool>);
    struct ShouldBeSameSizeAsWebPopupItem : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebPopupItem>, false> {
        WebKit::WebPopupItem::Type m_type;
        String m_text;
        String m_language;
        WebCore::TextDirection m_textDirection;
        bool m_hasTextDirectionOverride;
        String m_toolTip;
        String m_accessibilityText;
        bool m_isEnabled;
        bool m_isLabel;
        bool m_isSelected;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebPopupItem) == sizeof(WebKit::WebPopupItem));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebPopupItem, m_type)
        , offsetof(WebKit::WebPopupItem, m_text)
        , offsetof(WebKit::WebPopupItem, m_language)
        , offsetof(WebKit::WebPopupItem, m_textDirection)
        , offsetof(WebKit::WebPopupItem, m_hasTextDirectionOverride)
        , offsetof(WebKit::WebPopupItem, m_toolTip)
        , offsetof(WebKit::WebPopupItem, m_accessibilityText)
        , offsetof(WebKit::WebPopupItem, m_isEnabled)
        , offsetof(WebKit::WebPopupItem, m_isLabel)
        , offsetof(WebKit::WebPopupItem, m_isSelected)
    >::value);

    encoder << instance.m_type;
    encoder << instance.m_text;
    encoder << instance.m_language;
    encoder << instance.m_textDirection;
    encoder << instance.m_hasTextDirectionOverride;
    encoder << instance.m_toolTip;
    encoder << instance.m_accessibilityText;
    encoder << instance.m_isEnabled;
    encoder << instance.m_isLabel;
    encoder << instance.m_isSelected;
}

std::optional<WebKit::WebPopupItem> ArgumentCoder<WebKit::WebPopupItem>::decode(Decoder& decoder)
{
    auto m_type = decoder.decode<WebKit::WebPopupItem::Type>();
    auto m_text = decoder.decode<String>();
    auto m_language = decoder.decode<String>();
    auto m_textDirection = decoder.decode<WebCore::TextDirection>();
    auto m_hasTextDirectionOverride = decoder.decode<bool>();
    auto m_toolTip = decoder.decode<String>();
    auto m_accessibilityText = decoder.decode<String>();
    auto m_isEnabled = decoder.decode<bool>();
    auto m_isLabel = decoder.decode<bool>();
    auto m_isSelected = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebPopupItem {
            WTFMove(*m_type),
            WTFMove(*m_text),
            WTFMove(*m_language),
            WTFMove(*m_textDirection),
            WTFMove(*m_hasTextDirectionOverride),
            WTFMove(*m_toolTip),
            WTFMove(*m_accessibilityText),
            WTFMove(*m_isEnabled),
            WTFMove(*m_isLabel),
            WTFMove(*m_isSelected)
        }
    };
}

void ArgumentCoder<WebKit::WebPreferencesStore>::encode(Encoder& encoder, const WebKit::WebPreferencesStore& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_values)>, WebKit::WebPreferencesStore::ValueMap>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_overriddenDefaults)>, WebKit::WebPreferencesStore::ValueMap>);
    struct ShouldBeSameSizeAsWebPreferencesStore : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebPreferencesStore>, false> {
        WebKit::WebPreferencesStore::ValueMap m_values;
        WebKit::WebPreferencesStore::ValueMap m_overriddenDefaults;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebPreferencesStore) == sizeof(WebKit::WebPreferencesStore));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebPreferencesStore, m_values)
        , offsetof(WebKit::WebPreferencesStore, m_overriddenDefaults)
    >::value);

    encoder << instance.m_values;
    encoder << instance.m_overriddenDefaults;
}

std::optional<WebKit::WebPreferencesStore> ArgumentCoder<WebKit::WebPreferencesStore>::decode(Decoder& decoder)
{
    auto m_values = decoder.decode<WebKit::WebPreferencesStore::ValueMap>();
    auto m_overriddenDefaults = decoder.decode<WebKit::WebPreferencesStore::ValueMap>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebPreferencesStore {
            WTFMove(*m_values),
            WTFMove(*m_overriddenDefaults)
        }
    };
}

void ArgumentCoder<WebKit::WebProcessCreationParameters>::encode(Encoder& encoder, WebKit::WebProcessCreationParameters&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.auxiliaryProcessParameters)>, WebKit::AuxiliaryProcessCreationParameters>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.injectedBundlePath)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.injectedBundlePathExtensionHandle)>, WebKit::SandboxExtensionHandle>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.additionalSandboxExtensionHandles)>, Vector<WebKit::SandboxExtensionHandle>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.initializationUserData)>, WebKit::UserData>);
#if PLATFORM(COCOA) && ENABLE(REMOTE_INSPECTOR)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.enableRemoteWebInspectorExtensionHandles)>, Vector<WebKit::SandboxExtensionHandle>>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.urlSchemesRegisteredAsEmptyDocument)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.urlSchemesRegisteredAsSecure)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.urlSchemesRegisteredAsBypassingContentSecurityPolicy)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.urlSchemesForWhichDomainRelaxationIsForbidden)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.urlSchemesRegisteredAsLocal)>, Vector<String>>);
#if ENABLE(ALL_LEGACY_REGISTERED_SPECIAL_URL_SCHEMES)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.urlSchemesRegisteredAsNoAccess)>, Vector<String>>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.urlSchemesRegisteredAsDisplayIsolated)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.urlSchemesRegisteredAsCORSEnabled)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.urlSchemesRegisteredAsAlwaysRevalidated)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.urlSchemesRegisteredAsCachePartitioned)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.urlSchemesRegisteredAsCanDisplayOnlyIfCanRequest)>, Vector<String>>);
#if ENABLE(WK_WEB_EXTENSIONS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.urlSchemesRegisteredAsWebExtensions)>, Vector<String>>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fontAllowList)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.overrideLanguages)>, Vector<String>>);
#if USE(GSTREAMER)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.gstreamerOptions)>, Vector<String>>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cacheModel)>, WebKit::CacheModel>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.defaultRequestTimeoutInterval)>, Markable<double>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.backForwardCacheCapacity)>, unsigned>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldAlwaysUseComplexTextCodePath)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldEnableMemoryPressureReliefLogging)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldSuppressMemoryPressureHandler)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.disableFontSubpixelAntialiasingForTesting)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fullKeyboardAccessEnabled)>, bool>);
#if HAVE(MOUSE_DEVICE_OBSERVATION)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasMouseDevice)>, bool>);
#endif
#if HAVE(STYLUS_DEVICE_OBSERVATION)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasStylusDevice)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.memoryCacheDisabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.attrStyleEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldThrowExceptionForGlobalConstantRedeclaration)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.crossOriginMode)>, WebCore::CrossOriginMode>);
#if ENABLE(SERVICE_CONTROLS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasImageServices)>, bool>);
#endif
#if ENABLE(SERVICE_CONTROLS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasSelectionServices)>, bool>);
#endif
#if ENABLE(SERVICE_CONTROLS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasRichContentServices)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.textCheckerState)>, OptionSet<WebKit::TextCheckerState>>);
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.uiProcessBundleIdentifier)>, String>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.latencyQOS)>, int>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.throughputQOS)>, int>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.presentingApplicationPID)>, ProcessID>);
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.uiProcessBundleResourcePath)>, String>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.uiProcessBundleResourcePathExtensionHandle)>, WebKit::SandboxExtensionHandle>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldEnableJIT)>, bool>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldEnableFTLJIT)>, bool>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.accessibilityEnhancedUserInterfaceEnabled)>, bool>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bundleParameterData)>, RefPtr<API::Data>>);
#endif
#if ENABLE(NOTIFICATIONS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.notificationPermissions)>, HashMap<String, bool>>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.networkATSContext)>, RetainPtr<CFDataRef>>);
#endif
#if PLATFORM(WAYLAND)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.waylandCompositorDisplayName)>, String>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaMIMETypes)>, Vector<String>>);
#endif
#if PLATFORM(COCOA) || PLATFORM(GTK) || (PLATFORM(WPE) && ENABLE(WPE_PLATFORM))
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.screenProperties)>, WebCore::ScreenProperties>);
#endif
#if !RELEASE_LOG_DISABLED
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldLogUserInteraction)>, bool>);
#endif
#if PLATFORM(MAC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.useOverlayScrollbars)>, bool>);
#endif
#if USE(WPE_RENDERER)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isServiceWorkerProcess)>, bool>);
#endif
#if USE(WPE_RENDERER)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hostClientFileDescriptor)>, UnixFileDescriptor>);
#endif
#if USE(WPE_RENDERER)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.implementationLibraryName)>, CString>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.websiteDataStoreParameters)>, std::optional<WebKit::WebProcessDataStoreParameters>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mobileGestaltExtensionHandle)>, std::optional<WebKit::SandboxExtensionHandle>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.launchServicesExtensionHandle)>, std::optional<WebKit::SandboxExtensionHandle>>);
#if (PLATFORM(MAC) || PLATFORM(MACCATALYST)) && HAVE(VIDEO_RESTRICTED_DECODING)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.trustdExtensionHandle)>, WebKit::SandboxExtensionHandle>);
#endif
#if HAVE(VIDEO_RESTRICTED_DECODING)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.enableDecodingHEIC)>, bool>);
#endif
#if HAVE(VIDEO_RESTRICTED_DECODING)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.enableDecodingAVIF)>, bool>);
#endif
#if PLATFORM(VISION)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.metalCacheDirectoryExtensionHandles)>, Vector<WebKit::SandboxExtensionHandle>>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.systemHasBattery)>, bool>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.systemHasAC)>, bool>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.currentUserInterfaceIdiom)>, PAL::UserInterfaceIdiom>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsPictureInPicture)>, bool>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cssValueToSystemColorMap)>, WebCore::RenderThemeIOS::CSSValueToSystemColorMap>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.focusRingColor)>, WebCore::Color>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.localizedDeviceModel)>, String>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentSizeCategory)>, String>);
#endif
#if USE(GBM)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.renderDeviceFile)>, String>);
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rendererBufferTransportMode)>, OptionSet<WebKit::RendererBufferTransportMode>>);
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.systemSettings)>, WebCore::SystemSettings::State>);
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.memoryPressureHandlerConfiguration)>, std::optional<WTF::MemoryPressureHandler::Configuration>>);
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.disableFontHintingForTesting)>, bool>);
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.availableInputDevices)>, OptionSet<WebKit::AvailableInputDevices>>);
#endif
#if PLATFORM(GTK)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.useSystemAppearanceForScrollbars)>, bool>);
#endif
#if HAVE(CATALYST_USER_INTERFACE_IDIOM_AND_SCALE_FACTOR)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.overrideUserInterfaceIdiomAndScale)>, std::pair<int64_t, double>>);
#endif
#if HAVE(IOSURFACE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maximumIOSurfaceSize)>, WebCore::IntSize>);
#endif
#if HAVE(IOSURFACE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bytesPerRowIOSurfaceAlignment)>, uint64_t>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.accessibilityPreferences)>, WebKit::AccessibilityPreferences>);
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.applicationAccessibilityEnabled)>, bool>);
#endif
#if USE(GLIB)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.applicationID)>, String>);
#endif
#if USE(GLIB)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.applicationName)>, String>);
#endif
#if USE(GLIB) && ENABLE(REMOTE_INSPECTOR)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.inspectorServerAddress)>, CString>);
#endif
#if USE(ATSPI)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.accessibilityBusAddress)>, String>);
#endif
#if USE(ATSPI)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.accessibilityBusName)>, String>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timeZoneOverride)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.storageAccessUserAgentStringQuirksData)>, HashMap<WebCore::RegistrableDomain, String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.storageAccessPromptQuirksDomains)>, HashSet<WebCore::RegistrableDomain>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.scriptTrackingPrivacyRules)>, WebKit::ScriptTrackingPrivacyRules>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.memoryFootprintPollIntervalForTesting)>, Seconds>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.memoryFootprintNotificationThresholds)>, Vector<uint64_t>>);
#if ENABLE(NOTIFY_BLOCKING)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.notifyState)>, Vector<std::pair<String, uint64_t>>>);
#endif
#if ENABLE(INITIALIZE_ACCESSIBILITY_ON_DEMAND)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldInitializeAccessibility)>, bool>);
#endif
#if HAVE(LIQUID_GLASS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isLiquidGlassEnabled)>, bool>);
#endif
    struct ShouldBeSameSizeAsWebProcessCreationParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebProcessCreationParameters>, false> {
        WebKit::AuxiliaryProcessCreationParameters auxiliaryProcessParameters;
        String injectedBundlePath;
        WebKit::SandboxExtensionHandle injectedBundlePathExtensionHandle;
        Vector<WebKit::SandboxExtensionHandle> additionalSandboxExtensionHandles;
        WebKit::UserData initializationUserData;
#if PLATFORM(COCOA) && ENABLE(REMOTE_INSPECTOR)
        Vector<WebKit::SandboxExtensionHandle> enableRemoteWebInspectorExtensionHandles;
#endif
        Vector<String> urlSchemesRegisteredAsEmptyDocument;
        Vector<String> urlSchemesRegisteredAsSecure;
        Vector<String> urlSchemesRegisteredAsBypassingContentSecurityPolicy;
        Vector<String> urlSchemesForWhichDomainRelaxationIsForbidden;
        Vector<String> urlSchemesRegisteredAsLocal;
#if ENABLE(ALL_LEGACY_REGISTERED_SPECIAL_URL_SCHEMES)
        Vector<String> urlSchemesRegisteredAsNoAccess;
#endif
        Vector<String> urlSchemesRegisteredAsDisplayIsolated;
        Vector<String> urlSchemesRegisteredAsCORSEnabled;
        Vector<String> urlSchemesRegisteredAsAlwaysRevalidated;
        Vector<String> urlSchemesRegisteredAsCachePartitioned;
        Vector<String> urlSchemesRegisteredAsCanDisplayOnlyIfCanRequest;
#if ENABLE(WK_WEB_EXTENSIONS)
        Vector<String> urlSchemesRegisteredAsWebExtensions;
#endif
        Vector<String> fontAllowList;
        Vector<String> overrideLanguages;
#if USE(GSTREAMER)
        Vector<String> gstreamerOptions;
#endif
        WebKit::CacheModel cacheModel;
        Markable<double> defaultRequestTimeoutInterval;
        unsigned backForwardCacheCapacity;
        bool shouldAlwaysUseComplexTextCodePath;
        bool shouldEnableMemoryPressureReliefLogging;
        bool shouldSuppressMemoryPressureHandler;
        bool disableFontSubpixelAntialiasingForTesting;
        bool fullKeyboardAccessEnabled;
#if HAVE(MOUSE_DEVICE_OBSERVATION)
        bool hasMouseDevice;
#endif
#if HAVE(STYLUS_DEVICE_OBSERVATION)
        bool hasStylusDevice;
#endif
        bool memoryCacheDisabled;
        bool attrStyleEnabled;
        bool shouldThrowExceptionForGlobalConstantRedeclaration;
        WebCore::CrossOriginMode crossOriginMode;
#if ENABLE(SERVICE_CONTROLS)
        bool hasImageServices;
#endif
#if ENABLE(SERVICE_CONTROLS)
        bool hasSelectionServices;
#endif
#if ENABLE(SERVICE_CONTROLS)
        bool hasRichContentServices;
#endif
        OptionSet<WebKit::TextCheckerState> textCheckerState;
#if PLATFORM(COCOA)
        String uiProcessBundleIdentifier;
#endif
#if PLATFORM(COCOA)
        int latencyQOS;
#endif
#if PLATFORM(COCOA)
        int throughputQOS;
#endif
        ProcessID presentingApplicationPID;
#if PLATFORM(COCOA)
        String uiProcessBundleResourcePath;
#endif
#if PLATFORM(COCOA)
        WebKit::SandboxExtensionHandle uiProcessBundleResourcePathExtensionHandle;
#endif
#if PLATFORM(COCOA)
        bool shouldEnableJIT;
#endif
#if PLATFORM(COCOA)
        bool shouldEnableFTLJIT;
#endif
#if PLATFORM(COCOA)
        bool accessibilityEnhancedUserInterfaceEnabled;
#endif
#if PLATFORM(COCOA)
        RefPtr<API::Data> bundleParameterData;
#endif
#if ENABLE(NOTIFICATIONS)
        HashMap<String, bool> notificationPermissions;
#endif
#if PLATFORM(COCOA)
        RetainPtr<CFDataRef> networkATSContext;
#endif
#if PLATFORM(WAYLAND)
        String waylandCompositorDisplayName;
#endif
#if PLATFORM(COCOA)
        Vector<String> mediaMIMETypes;
#endif
#if PLATFORM(COCOA) || PLATFORM(GTK) || (PLATFORM(WPE) && ENABLE(WPE_PLATFORM))
        WebCore::ScreenProperties screenProperties;
#endif
#if !RELEASE_LOG_DISABLED
        bool shouldLogUserInteraction;
#endif
#if PLATFORM(MAC)
        bool useOverlayScrollbars;
#endif
#if USE(WPE_RENDERER)
        bool isServiceWorkerProcess;
#endif
#if USE(WPE_RENDERER)
        UnixFileDescriptor hostClientFileDescriptor;
#endif
#if USE(WPE_RENDERER)
        CString implementationLibraryName;
#endif
        std::optional<WebKit::WebProcessDataStoreParameters> websiteDataStoreParameters;
        std::optional<WebKit::SandboxExtensionHandle> mobileGestaltExtensionHandle;
        std::optional<WebKit::SandboxExtensionHandle> launchServicesExtensionHandle;
#if (PLATFORM(MAC) || PLATFORM(MACCATALYST)) && HAVE(VIDEO_RESTRICTED_DECODING)
        WebKit::SandboxExtensionHandle trustdExtensionHandle;
#endif
#if HAVE(VIDEO_RESTRICTED_DECODING)
        bool enableDecodingHEIC;
#endif
#if HAVE(VIDEO_RESTRICTED_DECODING)
        bool enableDecodingAVIF;
#endif
#if PLATFORM(VISION)
        Vector<WebKit::SandboxExtensionHandle> metalCacheDirectoryExtensionHandles;
#endif
#if PLATFORM(COCOA)
        bool systemHasBattery;
#endif
#if PLATFORM(COCOA)
        bool systemHasAC;
#endif
#if PLATFORM(IOS_FAMILY)
        PAL::UserInterfaceIdiom currentUserInterfaceIdiom;
#endif
#if PLATFORM(IOS_FAMILY)
        bool supportsPictureInPicture;
#endif
#if PLATFORM(IOS_FAMILY)
        WebCore::RenderThemeIOS::CSSValueToSystemColorMap cssValueToSystemColorMap;
#endif
#if PLATFORM(IOS_FAMILY)
        WebCore::Color focusRingColor;
#endif
#if PLATFORM(IOS_FAMILY)
        String localizedDeviceModel;
#endif
#if PLATFORM(IOS_FAMILY)
        String contentSizeCategory;
#endif
#if USE(GBM)
        String renderDeviceFile;
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
        OptionSet<WebKit::RendererBufferTransportMode> rendererBufferTransportMode;
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
        WebCore::SystemSettings::State systemSettings;
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
        std::optional<WTF::MemoryPressureHandler::Configuration> memoryPressureHandlerConfiguration;
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
        bool disableFontHintingForTesting;
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
        OptionSet<WebKit::AvailableInputDevices> availableInputDevices;
#endif
#if PLATFORM(GTK)
        bool useSystemAppearanceForScrollbars;
#endif
#if HAVE(CATALYST_USER_INTERFACE_IDIOM_AND_SCALE_FACTOR)
        std::pair<int64_t, double> overrideUserInterfaceIdiomAndScale;
#endif
#if HAVE(IOSURFACE)
        WebCore::IntSize maximumIOSurfaceSize;
#endif
#if HAVE(IOSURFACE)
        uint64_t bytesPerRowIOSurfaceAlignment;
#endif
        WebKit::AccessibilityPreferences accessibilityPreferences;
#if PLATFORM(IOS_FAMILY)
        bool applicationAccessibilityEnabled;
#endif
#if USE(GLIB)
        String applicationID;
#endif
#if USE(GLIB)
        String applicationName;
#endif
#if USE(GLIB) && ENABLE(REMOTE_INSPECTOR)
        CString inspectorServerAddress;
#endif
#if USE(ATSPI)
        String accessibilityBusAddress;
#endif
#if USE(ATSPI)
        String accessibilityBusName;
#endif
        String timeZoneOverride;
        HashMap<WebCore::RegistrableDomain, String> storageAccessUserAgentStringQuirksData;
        HashSet<WebCore::RegistrableDomain> storageAccessPromptQuirksDomains;
        WebKit::ScriptTrackingPrivacyRules scriptTrackingPrivacyRules;
        Seconds memoryFootprintPollIntervalForTesting;
        Vector<uint64_t> memoryFootprintNotificationThresholds;
#if ENABLE(NOTIFY_BLOCKING)
        Vector<std::pair<String, uint64_t>> notifyState;
#endif
#if ENABLE(INITIALIZE_ACCESSIBILITY_ON_DEMAND)
        bool shouldInitializeAccessibility;
#endif
#if HAVE(LIQUID_GLASS)
        bool isLiquidGlassEnabled;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebProcessCreationParameters) == sizeof(WebKit::WebProcessCreationParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebProcessCreationParameters, auxiliaryProcessParameters)
        , offsetof(WebKit::WebProcessCreationParameters, injectedBundlePath)
        , offsetof(WebKit::WebProcessCreationParameters, injectedBundlePathExtensionHandle)
        , offsetof(WebKit::WebProcessCreationParameters, additionalSandboxExtensionHandles)
        , offsetof(WebKit::WebProcessCreationParameters, initializationUserData)
#if PLATFORM(COCOA) && ENABLE(REMOTE_INSPECTOR)
        , offsetof(WebKit::WebProcessCreationParameters, enableRemoteWebInspectorExtensionHandles)
#endif
        , offsetof(WebKit::WebProcessCreationParameters, urlSchemesRegisteredAsEmptyDocument)
        , offsetof(WebKit::WebProcessCreationParameters, urlSchemesRegisteredAsSecure)
        , offsetof(WebKit::WebProcessCreationParameters, urlSchemesRegisteredAsBypassingContentSecurityPolicy)
        , offsetof(WebKit::WebProcessCreationParameters, urlSchemesForWhichDomainRelaxationIsForbidden)
        , offsetof(WebKit::WebProcessCreationParameters, urlSchemesRegisteredAsLocal)
#if ENABLE(ALL_LEGACY_REGISTERED_SPECIAL_URL_SCHEMES)
        , offsetof(WebKit::WebProcessCreationParameters, urlSchemesRegisteredAsNoAccess)
#endif
        , offsetof(WebKit::WebProcessCreationParameters, urlSchemesRegisteredAsDisplayIsolated)
        , offsetof(WebKit::WebProcessCreationParameters, urlSchemesRegisteredAsCORSEnabled)
        , offsetof(WebKit::WebProcessCreationParameters, urlSchemesRegisteredAsAlwaysRevalidated)
        , offsetof(WebKit::WebProcessCreationParameters, urlSchemesRegisteredAsCachePartitioned)
        , offsetof(WebKit::WebProcessCreationParameters, urlSchemesRegisteredAsCanDisplayOnlyIfCanRequest)
#if ENABLE(WK_WEB_EXTENSIONS)
        , offsetof(WebKit::WebProcessCreationParameters, urlSchemesRegisteredAsWebExtensions)
#endif
        , offsetof(WebKit::WebProcessCreationParameters, fontAllowList)
        , offsetof(WebKit::WebProcessCreationParameters, overrideLanguages)
#if USE(GSTREAMER)
        , offsetof(WebKit::WebProcessCreationParameters, gstreamerOptions)
#endif
        , offsetof(WebKit::WebProcessCreationParameters, cacheModel)
        , offsetof(WebKit::WebProcessCreationParameters, defaultRequestTimeoutInterval)
        , offsetof(WebKit::WebProcessCreationParameters, backForwardCacheCapacity)
        , offsetof(WebKit::WebProcessCreationParameters, shouldAlwaysUseComplexTextCodePath)
        , offsetof(WebKit::WebProcessCreationParameters, shouldEnableMemoryPressureReliefLogging)
        , offsetof(WebKit::WebProcessCreationParameters, shouldSuppressMemoryPressureHandler)
        , offsetof(WebKit::WebProcessCreationParameters, disableFontSubpixelAntialiasingForTesting)
        , offsetof(WebKit::WebProcessCreationParameters, fullKeyboardAccessEnabled)
#if HAVE(MOUSE_DEVICE_OBSERVATION)
        , offsetof(WebKit::WebProcessCreationParameters, hasMouseDevice)
#endif
#if HAVE(STYLUS_DEVICE_OBSERVATION)
        , offsetof(WebKit::WebProcessCreationParameters, hasStylusDevice)
#endif
        , offsetof(WebKit::WebProcessCreationParameters, memoryCacheDisabled)
        , offsetof(WebKit::WebProcessCreationParameters, attrStyleEnabled)
        , offsetof(WebKit::WebProcessCreationParameters, shouldThrowExceptionForGlobalConstantRedeclaration)
        , offsetof(WebKit::WebProcessCreationParameters, crossOriginMode)
#if ENABLE(SERVICE_CONTROLS)
        , offsetof(WebKit::WebProcessCreationParameters, hasImageServices)
#endif
#if ENABLE(SERVICE_CONTROLS)
        , offsetof(WebKit::WebProcessCreationParameters, hasSelectionServices)
#endif
#if ENABLE(SERVICE_CONTROLS)
        , offsetof(WebKit::WebProcessCreationParameters, hasRichContentServices)
#endif
        , offsetof(WebKit::WebProcessCreationParameters, textCheckerState)
#if PLATFORM(COCOA)
        , offsetof(WebKit::WebProcessCreationParameters, uiProcessBundleIdentifier)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::WebProcessCreationParameters, latencyQOS)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::WebProcessCreationParameters, throughputQOS)
#endif
        , offsetof(WebKit::WebProcessCreationParameters, presentingApplicationPID)
#if PLATFORM(COCOA)
        , offsetof(WebKit::WebProcessCreationParameters, uiProcessBundleResourcePath)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::WebProcessCreationParameters, uiProcessBundleResourcePathExtensionHandle)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::WebProcessCreationParameters, shouldEnableJIT)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::WebProcessCreationParameters, shouldEnableFTLJIT)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::WebProcessCreationParameters, accessibilityEnhancedUserInterfaceEnabled)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::WebProcessCreationParameters, bundleParameterData)
#endif
#if ENABLE(NOTIFICATIONS)
        , offsetof(WebKit::WebProcessCreationParameters, notificationPermissions)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::WebProcessCreationParameters, networkATSContext)
#endif
#if PLATFORM(WAYLAND)
        , offsetof(WebKit::WebProcessCreationParameters, waylandCompositorDisplayName)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::WebProcessCreationParameters, mediaMIMETypes)
#endif
#if PLATFORM(COCOA) || PLATFORM(GTK) || (PLATFORM(WPE) && ENABLE(WPE_PLATFORM))
        , offsetof(WebKit::WebProcessCreationParameters, screenProperties)
#endif
#if !RELEASE_LOG_DISABLED
        , offsetof(WebKit::WebProcessCreationParameters, shouldLogUserInteraction)
#endif
#if PLATFORM(MAC)
        , offsetof(WebKit::WebProcessCreationParameters, useOverlayScrollbars)
#endif
#if USE(WPE_RENDERER)
        , offsetof(WebKit::WebProcessCreationParameters, isServiceWorkerProcess)
#endif
#if USE(WPE_RENDERER)
        , offsetof(WebKit::WebProcessCreationParameters, hostClientFileDescriptor)
#endif
#if USE(WPE_RENDERER)
        , offsetof(WebKit::WebProcessCreationParameters, implementationLibraryName)
#endif
        , offsetof(WebKit::WebProcessCreationParameters, websiteDataStoreParameters)
        , offsetof(WebKit::WebProcessCreationParameters, mobileGestaltExtensionHandle)
        , offsetof(WebKit::WebProcessCreationParameters, launchServicesExtensionHandle)
#if (PLATFORM(MAC) || PLATFORM(MACCATALYST)) && HAVE(VIDEO_RESTRICTED_DECODING)
        , offsetof(WebKit::WebProcessCreationParameters, trustdExtensionHandle)
#endif
#if HAVE(VIDEO_RESTRICTED_DECODING)
        , offsetof(WebKit::WebProcessCreationParameters, enableDecodingHEIC)
#endif
#if HAVE(VIDEO_RESTRICTED_DECODING)
        , offsetof(WebKit::WebProcessCreationParameters, enableDecodingAVIF)
#endif
#if PLATFORM(VISION)
        , offsetof(WebKit::WebProcessCreationParameters, metalCacheDirectoryExtensionHandles)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::WebProcessCreationParameters, systemHasBattery)
#endif
#if PLATFORM(COCOA)
        , offsetof(WebKit::WebProcessCreationParameters, systemHasAC)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::WebProcessCreationParameters, currentUserInterfaceIdiom)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::WebProcessCreationParameters, supportsPictureInPicture)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::WebProcessCreationParameters, cssValueToSystemColorMap)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::WebProcessCreationParameters, focusRingColor)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::WebProcessCreationParameters, localizedDeviceModel)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::WebProcessCreationParameters, contentSizeCategory)
#endif
#if USE(GBM)
        , offsetof(WebKit::WebProcessCreationParameters, renderDeviceFile)
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
        , offsetof(WebKit::WebProcessCreationParameters, rendererBufferTransportMode)
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
        , offsetof(WebKit::WebProcessCreationParameters, systemSettings)
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
        , offsetof(WebKit::WebProcessCreationParameters, memoryPressureHandlerConfiguration)
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
        , offsetof(WebKit::WebProcessCreationParameters, disableFontHintingForTesting)
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
        , offsetof(WebKit::WebProcessCreationParameters, availableInputDevices)
#endif
#if PLATFORM(GTK)
        , offsetof(WebKit::WebProcessCreationParameters, useSystemAppearanceForScrollbars)
#endif
#if HAVE(CATALYST_USER_INTERFACE_IDIOM_AND_SCALE_FACTOR)
        , offsetof(WebKit::WebProcessCreationParameters, overrideUserInterfaceIdiomAndScale)
#endif
#if HAVE(IOSURFACE)
        , offsetof(WebKit::WebProcessCreationParameters, maximumIOSurfaceSize)
#endif
#if HAVE(IOSURFACE)
        , offsetof(WebKit::WebProcessCreationParameters, bytesPerRowIOSurfaceAlignment)
#endif
        , offsetof(WebKit::WebProcessCreationParameters, accessibilityPreferences)
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::WebProcessCreationParameters, applicationAccessibilityEnabled)
#endif
#if USE(GLIB)
        , offsetof(WebKit::WebProcessCreationParameters, applicationID)
#endif
#if USE(GLIB)
        , offsetof(WebKit::WebProcessCreationParameters, applicationName)
#endif
#if USE(GLIB) && ENABLE(REMOTE_INSPECTOR)
        , offsetof(WebKit::WebProcessCreationParameters, inspectorServerAddress)
#endif
#if USE(ATSPI)
        , offsetof(WebKit::WebProcessCreationParameters, accessibilityBusAddress)
#endif
#if USE(ATSPI)
        , offsetof(WebKit::WebProcessCreationParameters, accessibilityBusName)
#endif
        , offsetof(WebKit::WebProcessCreationParameters, timeZoneOverride)
        , offsetof(WebKit::WebProcessCreationParameters, storageAccessUserAgentStringQuirksData)
        , offsetof(WebKit::WebProcessCreationParameters, storageAccessPromptQuirksDomains)
        , offsetof(WebKit::WebProcessCreationParameters, scriptTrackingPrivacyRules)
        , offsetof(WebKit::WebProcessCreationParameters, memoryFootprintPollIntervalForTesting)
        , offsetof(WebKit::WebProcessCreationParameters, memoryFootprintNotificationThresholds)
#if ENABLE(NOTIFY_BLOCKING)
        , offsetof(WebKit::WebProcessCreationParameters, notifyState)
#endif
#if ENABLE(INITIALIZE_ACCESSIBILITY_ON_DEMAND)
        , offsetof(WebKit::WebProcessCreationParameters, shouldInitializeAccessibility)
#endif
#if HAVE(LIQUID_GLASS)
        , offsetof(WebKit::WebProcessCreationParameters, isLiquidGlassEnabled)
#endif
    >::value);

    encoder << WTFMove(instance.auxiliaryProcessParameters);
    encoder << WTFMove(instance.injectedBundlePath);
    encoder << WTFMove(instance.injectedBundlePathExtensionHandle);
    encoder << WTFMove(instance.additionalSandboxExtensionHandles);
    encoder << WTFMove(instance.initializationUserData);
#if PLATFORM(COCOA) && ENABLE(REMOTE_INSPECTOR)
    encoder << WTFMove(instance.enableRemoteWebInspectorExtensionHandles);
#endif
    encoder << WTFMove(instance.urlSchemesRegisteredAsEmptyDocument);
    encoder << WTFMove(instance.urlSchemesRegisteredAsSecure);
    encoder << WTFMove(instance.urlSchemesRegisteredAsBypassingContentSecurityPolicy);
    encoder << WTFMove(instance.urlSchemesForWhichDomainRelaxationIsForbidden);
    encoder << WTFMove(instance.urlSchemesRegisteredAsLocal);
#if ENABLE(ALL_LEGACY_REGISTERED_SPECIAL_URL_SCHEMES)
    encoder << WTFMove(instance.urlSchemesRegisteredAsNoAccess);
#endif
    encoder << WTFMove(instance.urlSchemesRegisteredAsDisplayIsolated);
    encoder << WTFMove(instance.urlSchemesRegisteredAsCORSEnabled);
    encoder << WTFMove(instance.urlSchemesRegisteredAsAlwaysRevalidated);
    encoder << WTFMove(instance.urlSchemesRegisteredAsCachePartitioned);
    encoder << WTFMove(instance.urlSchemesRegisteredAsCanDisplayOnlyIfCanRequest);
#if ENABLE(WK_WEB_EXTENSIONS)
    encoder << WTFMove(instance.urlSchemesRegisteredAsWebExtensions);
#endif
    encoder << WTFMove(instance.fontAllowList);
    encoder << WTFMove(instance.overrideLanguages);
#if USE(GSTREAMER)
    encoder << WTFMove(instance.gstreamerOptions);
#endif
    encoder << WTFMove(instance.cacheModel);
    encoder << WTFMove(instance.defaultRequestTimeoutInterval);
    encoder << WTFMove(instance.backForwardCacheCapacity);
    encoder << WTFMove(instance.shouldAlwaysUseComplexTextCodePath);
    encoder << WTFMove(instance.shouldEnableMemoryPressureReliefLogging);
    encoder << WTFMove(instance.shouldSuppressMemoryPressureHandler);
    encoder << WTFMove(instance.disableFontSubpixelAntialiasingForTesting);
    encoder << WTFMove(instance.fullKeyboardAccessEnabled);
#if HAVE(MOUSE_DEVICE_OBSERVATION)
    encoder << WTFMove(instance.hasMouseDevice);
#endif
#if HAVE(STYLUS_DEVICE_OBSERVATION)
    encoder << WTFMove(instance.hasStylusDevice);
#endif
    encoder << WTFMove(instance.memoryCacheDisabled);
    encoder << WTFMove(instance.attrStyleEnabled);
    encoder << WTFMove(instance.shouldThrowExceptionForGlobalConstantRedeclaration);
    encoder << WTFMove(instance.crossOriginMode);
#if ENABLE(SERVICE_CONTROLS)
    encoder << WTFMove(instance.hasImageServices);
#endif
#if ENABLE(SERVICE_CONTROLS)
    encoder << WTFMove(instance.hasSelectionServices);
#endif
#if ENABLE(SERVICE_CONTROLS)
    encoder << WTFMove(instance.hasRichContentServices);
#endif
    encoder << WTFMove(instance.textCheckerState);
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.uiProcessBundleIdentifier);
#endif
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.latencyQOS);
#endif
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.throughputQOS);
#endif
    encoder << WTFMove(instance.presentingApplicationPID);
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.uiProcessBundleResourcePath);
#endif
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.uiProcessBundleResourcePathExtensionHandle);
#endif
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.shouldEnableJIT);
#endif
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.shouldEnableFTLJIT);
#endif
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.accessibilityEnhancedUserInterfaceEnabled);
#endif
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.bundleParameterData);
#endif
#if ENABLE(NOTIFICATIONS)
    encoder << WTFMove(instance.notificationPermissions);
#endif
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.networkATSContext);
#endif
#if PLATFORM(WAYLAND)
    encoder << WTFMove(instance.waylandCompositorDisplayName);
#endif
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.mediaMIMETypes);
#endif
#if PLATFORM(COCOA) || PLATFORM(GTK) || (PLATFORM(WPE) && ENABLE(WPE_PLATFORM))
    encoder << WTFMove(instance.screenProperties);
#endif
#if !RELEASE_LOG_DISABLED
    encoder << WTFMove(instance.shouldLogUserInteraction);
#endif
#if PLATFORM(MAC)
    encoder << WTFMove(instance.useOverlayScrollbars);
#endif
#if USE(WPE_RENDERER)
    encoder << WTFMove(instance.isServiceWorkerProcess);
#endif
#if USE(WPE_RENDERER)
    encoder << WTFMove(instance.hostClientFileDescriptor);
#endif
#if USE(WPE_RENDERER)
    encoder << WTFMove(instance.implementationLibraryName);
#endif
    encoder << WTFMove(instance.websiteDataStoreParameters);
    encoder << WTFMove(instance.mobileGestaltExtensionHandle);
    encoder << WTFMove(instance.launchServicesExtensionHandle);
#if (PLATFORM(MAC) || PLATFORM(MACCATALYST)) && HAVE(VIDEO_RESTRICTED_DECODING)
    encoder << WTFMove(instance.trustdExtensionHandle);
#endif
#if HAVE(VIDEO_RESTRICTED_DECODING)
    encoder << WTFMove(instance.enableDecodingHEIC);
#endif
#if HAVE(VIDEO_RESTRICTED_DECODING)
    encoder << WTFMove(instance.enableDecodingAVIF);
#endif
#if PLATFORM(VISION)
    encoder << WTFMove(instance.metalCacheDirectoryExtensionHandles);
#endif
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.systemHasBattery);
#endif
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.systemHasAC);
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << WTFMove(instance.currentUserInterfaceIdiom);
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << WTFMove(instance.supportsPictureInPicture);
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << WTFMove(instance.cssValueToSystemColorMap);
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << WTFMove(instance.focusRingColor);
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << WTFMove(instance.localizedDeviceModel);
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << WTFMove(instance.contentSizeCategory);
#endif
#if USE(GBM)
    encoder << WTFMove(instance.renderDeviceFile);
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    encoder << WTFMove(instance.rendererBufferTransportMode);
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    encoder << WTFMove(instance.systemSettings);
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    encoder << WTFMove(instance.memoryPressureHandlerConfiguration);
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    encoder << WTFMove(instance.disableFontHintingForTesting);
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    encoder << WTFMove(instance.availableInputDevices);
#endif
#if PLATFORM(GTK)
    encoder << WTFMove(instance.useSystemAppearanceForScrollbars);
#endif
#if HAVE(CATALYST_USER_INTERFACE_IDIOM_AND_SCALE_FACTOR)
    encoder << WTFMove(instance.overrideUserInterfaceIdiomAndScale);
#endif
#if HAVE(IOSURFACE)
    encoder << WTFMove(instance.maximumIOSurfaceSize);
#endif
#if HAVE(IOSURFACE)
    encoder << WTFMove(instance.bytesPerRowIOSurfaceAlignment);
#endif
    encoder << WTFMove(instance.accessibilityPreferences);
#if PLATFORM(IOS_FAMILY)
    encoder << WTFMove(instance.applicationAccessibilityEnabled);
#endif
#if USE(GLIB)
    encoder << WTFMove(instance.applicationID);
#endif
#if USE(GLIB)
    encoder << WTFMove(instance.applicationName);
#endif
#if USE(GLIB) && ENABLE(REMOTE_INSPECTOR)
    encoder << WTFMove(instance.inspectorServerAddress);
#endif
#if USE(ATSPI)
    encoder << WTFMove(instance.accessibilityBusAddress);
#endif
#if USE(ATSPI)
    encoder << WTFMove(instance.accessibilityBusName);
#endif
    encoder << WTFMove(instance.timeZoneOverride);
    encoder << WTFMove(instance.storageAccessUserAgentStringQuirksData);
    encoder << WTFMove(instance.storageAccessPromptQuirksDomains);
    encoder << WTFMove(instance.scriptTrackingPrivacyRules);
    encoder << WTFMove(instance.memoryFootprintPollIntervalForTesting);
    encoder << WTFMove(instance.memoryFootprintNotificationThresholds);
#if ENABLE(NOTIFY_BLOCKING)
    encoder << WTFMove(instance.notifyState);
#endif
#if ENABLE(INITIALIZE_ACCESSIBILITY_ON_DEMAND)
    encoder << WTFMove(instance.shouldInitializeAccessibility);
#endif
#if HAVE(LIQUID_GLASS)
    encoder << WTFMove(instance.isLiquidGlassEnabled);
#endif
}

std::optional<WebKit::WebProcessCreationParameters> ArgumentCoder<WebKit::WebProcessCreationParameters>::decode(Decoder& decoder)
{
    bool addedDecodingFailureIndex = false;
    auto auxiliaryProcessParameters = decoder.decode<WebKit::AuxiliaryProcessCreationParameters>();
    if (!auxiliaryProcessParameters && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(0);
        addedDecodingFailureIndex = true;
    }
    auto injectedBundlePath = decoder.decode<String>();
    if (!injectedBundlePath && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(1);
        addedDecodingFailureIndex = true;
    }
    auto injectedBundlePathExtensionHandle = decoder.decode<WebKit::SandboxExtensionHandle>();
    if (!injectedBundlePathExtensionHandle && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(2);
        addedDecodingFailureIndex = true;
    }
    auto additionalSandboxExtensionHandles = decoder.decode<Vector<WebKit::SandboxExtensionHandle>>();
    if (!additionalSandboxExtensionHandles && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(3);
        addedDecodingFailureIndex = true;
    }
    auto initializationUserData = decoder.decode<WebKit::UserData>();
    if (!initializationUserData && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(4);
        addedDecodingFailureIndex = true;
    }
#if PLATFORM(COCOA) && ENABLE(REMOTE_INSPECTOR)
    auto enableRemoteWebInspectorExtensionHandles = decoder.decode<Vector<WebKit::SandboxExtensionHandle>>();
    if (!enableRemoteWebInspectorExtensionHandles && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(5);
        addedDecodingFailureIndex = true;
    }
#endif
    auto urlSchemesRegisteredAsEmptyDocument = decoder.decode<Vector<String>>();
    if (!urlSchemesRegisteredAsEmptyDocument && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(6);
        addedDecodingFailureIndex = true;
    }
    auto urlSchemesRegisteredAsSecure = decoder.decode<Vector<String>>();
    if (!urlSchemesRegisteredAsSecure && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(7);
        addedDecodingFailureIndex = true;
    }
    auto urlSchemesRegisteredAsBypassingContentSecurityPolicy = decoder.decode<Vector<String>>();
    if (!urlSchemesRegisteredAsBypassingContentSecurityPolicy && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(8);
        addedDecodingFailureIndex = true;
    }
    auto urlSchemesForWhichDomainRelaxationIsForbidden = decoder.decode<Vector<String>>();
    if (!urlSchemesForWhichDomainRelaxationIsForbidden && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(9);
        addedDecodingFailureIndex = true;
    }
    auto urlSchemesRegisteredAsLocal = decoder.decode<Vector<String>>();
    if (!urlSchemesRegisteredAsLocal && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(10);
        addedDecodingFailureIndex = true;
    }
#if ENABLE(ALL_LEGACY_REGISTERED_SPECIAL_URL_SCHEMES)
    auto urlSchemesRegisteredAsNoAccess = decoder.decode<Vector<String>>();
    if (!urlSchemesRegisteredAsNoAccess && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(11);
        addedDecodingFailureIndex = true;
    }
#endif
    auto urlSchemesRegisteredAsDisplayIsolated = decoder.decode<Vector<String>>();
    if (!urlSchemesRegisteredAsDisplayIsolated && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(12);
        addedDecodingFailureIndex = true;
    }
    auto urlSchemesRegisteredAsCORSEnabled = decoder.decode<Vector<String>>();
    if (!urlSchemesRegisteredAsCORSEnabled && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(13);
        addedDecodingFailureIndex = true;
    }
    auto urlSchemesRegisteredAsAlwaysRevalidated = decoder.decode<Vector<String>>();
    if (!urlSchemesRegisteredAsAlwaysRevalidated && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(14);
        addedDecodingFailureIndex = true;
    }
    auto urlSchemesRegisteredAsCachePartitioned = decoder.decode<Vector<String>>();
    if (!urlSchemesRegisteredAsCachePartitioned && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(15);
        addedDecodingFailureIndex = true;
    }
    auto urlSchemesRegisteredAsCanDisplayOnlyIfCanRequest = decoder.decode<Vector<String>>();
    if (!urlSchemesRegisteredAsCanDisplayOnlyIfCanRequest && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(16);
        addedDecodingFailureIndex = true;
    }
#if ENABLE(WK_WEB_EXTENSIONS)
    auto urlSchemesRegisteredAsWebExtensions = decoder.decode<Vector<String>>();
    if (!urlSchemesRegisteredAsWebExtensions && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(17);
        addedDecodingFailureIndex = true;
    }
#endif
    auto fontAllowList = decoder.decode<Vector<String>>();
    if (!fontAllowList && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(18);
        addedDecodingFailureIndex = true;
    }
    auto overrideLanguages = decoder.decode<Vector<String>>();
    if (!overrideLanguages && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(19);
        addedDecodingFailureIndex = true;
    }
#if USE(GSTREAMER)
    auto gstreamerOptions = decoder.decode<Vector<String>>();
    if (!gstreamerOptions && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(20);
        addedDecodingFailureIndex = true;
    }
#endif
    auto cacheModel = decoder.decode<WebKit::CacheModel>();
    if (!cacheModel && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(21);
        addedDecodingFailureIndex = true;
    }
    auto defaultRequestTimeoutInterval = decoder.decode<Markable<double>>();
    if (!defaultRequestTimeoutInterval && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(22);
        addedDecodingFailureIndex = true;
    }
    auto backForwardCacheCapacity = decoder.decode<unsigned>();
    if (!backForwardCacheCapacity && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(23);
        addedDecodingFailureIndex = true;
    }
    auto shouldAlwaysUseComplexTextCodePath = decoder.decode<bool>();
    if (!shouldAlwaysUseComplexTextCodePath && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(24);
        addedDecodingFailureIndex = true;
    }
    auto shouldEnableMemoryPressureReliefLogging = decoder.decode<bool>();
    if (!shouldEnableMemoryPressureReliefLogging && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(25);
        addedDecodingFailureIndex = true;
    }
    auto shouldSuppressMemoryPressureHandler = decoder.decode<bool>();
    if (!shouldSuppressMemoryPressureHandler && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(26);
        addedDecodingFailureIndex = true;
    }
    auto disableFontSubpixelAntialiasingForTesting = decoder.decode<bool>();
    if (!disableFontSubpixelAntialiasingForTesting && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(27);
        addedDecodingFailureIndex = true;
    }
    auto fullKeyboardAccessEnabled = decoder.decode<bool>();
    if (!fullKeyboardAccessEnabled && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(28);
        addedDecodingFailureIndex = true;
    }
#if HAVE(MOUSE_DEVICE_OBSERVATION)
    auto hasMouseDevice = decoder.decode<bool>();
    if (!hasMouseDevice && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(29);
        addedDecodingFailureIndex = true;
    }
#endif
#if HAVE(STYLUS_DEVICE_OBSERVATION)
    auto hasStylusDevice = decoder.decode<bool>();
    if (!hasStylusDevice && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(30);
        addedDecodingFailureIndex = true;
    }
#endif
    auto memoryCacheDisabled = decoder.decode<bool>();
    if (!memoryCacheDisabled && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(31);
        addedDecodingFailureIndex = true;
    }
    auto attrStyleEnabled = decoder.decode<bool>();
    if (!attrStyleEnabled && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(32);
        addedDecodingFailureIndex = true;
    }
    auto shouldThrowExceptionForGlobalConstantRedeclaration = decoder.decode<bool>();
    if (!shouldThrowExceptionForGlobalConstantRedeclaration && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(33);
        addedDecodingFailureIndex = true;
    }
    auto crossOriginMode = decoder.decode<WebCore::CrossOriginMode>();
    if (!crossOriginMode && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(34);
        addedDecodingFailureIndex = true;
    }
#if ENABLE(SERVICE_CONTROLS)
    auto hasImageServices = decoder.decode<bool>();
    if (!hasImageServices && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(35);
        addedDecodingFailureIndex = true;
    }
#endif
#if ENABLE(SERVICE_CONTROLS)
    auto hasSelectionServices = decoder.decode<bool>();
    if (!hasSelectionServices && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(36);
        addedDecodingFailureIndex = true;
    }
#endif
#if ENABLE(SERVICE_CONTROLS)
    auto hasRichContentServices = decoder.decode<bool>();
    if (!hasRichContentServices && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(37);
        addedDecodingFailureIndex = true;
    }
#endif
    auto textCheckerState = decoder.decode<OptionSet<WebKit::TextCheckerState>>();
    if (!textCheckerState && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(38);
        addedDecodingFailureIndex = true;
    }
#if PLATFORM(COCOA)
    auto uiProcessBundleIdentifier = decoder.decode<String>();
    if (!uiProcessBundleIdentifier && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(39);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(COCOA)
    auto latencyQOS = decoder.decode<int>();
    if (!latencyQOS && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(40);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(COCOA)
    auto throughputQOS = decoder.decode<int>();
    if (!throughputQOS && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(41);
        addedDecodingFailureIndex = true;
    }
#endif
    auto presentingApplicationPID = decoder.decode<ProcessID>();
    if (!presentingApplicationPID && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(42);
        addedDecodingFailureIndex = true;
    }
#if PLATFORM(COCOA)
    auto uiProcessBundleResourcePath = decoder.decode<String>();
    if (!uiProcessBundleResourcePath && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(43);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(COCOA)
    auto uiProcessBundleResourcePathExtensionHandle = decoder.decode<WebKit::SandboxExtensionHandle>();
    if (!uiProcessBundleResourcePathExtensionHandle && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(44);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(COCOA)
    auto shouldEnableJIT = decoder.decode<bool>();
    if (!shouldEnableJIT && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(45);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(COCOA)
    auto shouldEnableFTLJIT = decoder.decode<bool>();
    if (!shouldEnableFTLJIT && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(46);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(COCOA)
    auto accessibilityEnhancedUserInterfaceEnabled = decoder.decode<bool>();
    if (!accessibilityEnhancedUserInterfaceEnabled && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(47);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(COCOA)
    auto bundleParameterData = decoder.decode<RefPtr<API::Data>>();
    if (!bundleParameterData && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(48);
        addedDecodingFailureIndex = true;
    }
#endif
#if ENABLE(NOTIFICATIONS)
    auto notificationPermissions = decoder.decode<HashMap<String, bool>>();
    if (!notificationPermissions && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(49);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(COCOA)
    auto networkATSContext = decoder.decode<RetainPtr<CFDataRef>>();
    if (!networkATSContext && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(50);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(WAYLAND)
    auto waylandCompositorDisplayName = decoder.decode<String>();
    if (!waylandCompositorDisplayName && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(51);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(COCOA)
    auto mediaMIMETypes = decoder.decode<Vector<String>>();
    if (!mediaMIMETypes && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(52);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(COCOA) || PLATFORM(GTK) || (PLATFORM(WPE) && ENABLE(WPE_PLATFORM))
    auto screenProperties = decoder.decode<WebCore::ScreenProperties>();
    if (!screenProperties && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(53);
        addedDecodingFailureIndex = true;
    }
#endif
#if !RELEASE_LOG_DISABLED
    auto shouldLogUserInteraction = decoder.decode<bool>();
    if (!shouldLogUserInteraction && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(54);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(MAC)
    auto useOverlayScrollbars = decoder.decode<bool>();
    if (!useOverlayScrollbars && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(55);
        addedDecodingFailureIndex = true;
    }
#endif
#if USE(WPE_RENDERER)
    auto isServiceWorkerProcess = decoder.decode<bool>();
    if (!isServiceWorkerProcess && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(56);
        addedDecodingFailureIndex = true;
    }
#endif
#if USE(WPE_RENDERER)
    auto hostClientFileDescriptor = decoder.decode<UnixFileDescriptor>();
    if (!hostClientFileDescriptor && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(57);
        addedDecodingFailureIndex = true;
    }
#endif
#if USE(WPE_RENDERER)
    auto implementationLibraryName = decoder.decode<CString>();
    if (!implementationLibraryName && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(58);
        addedDecodingFailureIndex = true;
    }
#endif
    auto websiteDataStoreParameters = decoder.decode<std::optional<WebKit::WebProcessDataStoreParameters>>();
    if (!websiteDataStoreParameters && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(59);
        addedDecodingFailureIndex = true;
    }
    auto mobileGestaltExtensionHandle = decoder.decode<std::optional<WebKit::SandboxExtensionHandle>>();
    if (!mobileGestaltExtensionHandle && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(60);
        addedDecodingFailureIndex = true;
    }
    auto launchServicesExtensionHandle = decoder.decode<std::optional<WebKit::SandboxExtensionHandle>>();
    if (!launchServicesExtensionHandle && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(61);
        addedDecodingFailureIndex = true;
    }
#if (PLATFORM(MAC) || PLATFORM(MACCATALYST)) && HAVE(VIDEO_RESTRICTED_DECODING)
    auto trustdExtensionHandle = decoder.decode<WebKit::SandboxExtensionHandle>();
    if (!trustdExtensionHandle && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(62);
        addedDecodingFailureIndex = true;
    }
#endif
#if HAVE(VIDEO_RESTRICTED_DECODING)
    auto enableDecodingHEIC = decoder.decode<bool>();
    if (!enableDecodingHEIC && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(63);
        addedDecodingFailureIndex = true;
    }
#endif
#if HAVE(VIDEO_RESTRICTED_DECODING)
    auto enableDecodingAVIF = decoder.decode<bool>();
    if (!enableDecodingAVIF && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(64);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(VISION)
    auto metalCacheDirectoryExtensionHandles = decoder.decode<Vector<WebKit::SandboxExtensionHandle>>();
    if (!metalCacheDirectoryExtensionHandles && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(65);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(COCOA)
    auto systemHasBattery = decoder.decode<bool>();
    if (!systemHasBattery && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(66);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(COCOA)
    auto systemHasAC = decoder.decode<bool>();
    if (!systemHasAC && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(67);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(IOS_FAMILY)
    auto currentUserInterfaceIdiom = decoder.decode<PAL::UserInterfaceIdiom>();
    if (!currentUserInterfaceIdiom && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(68);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(IOS_FAMILY)
    auto supportsPictureInPicture = decoder.decode<bool>();
    if (!supportsPictureInPicture && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(69);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(IOS_FAMILY)
    auto cssValueToSystemColorMap = decoder.decode<WebCore::RenderThemeIOS::CSSValueToSystemColorMap>();
    if (!cssValueToSystemColorMap && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(70);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(IOS_FAMILY)
    auto focusRingColor = decoder.decode<WebCore::Color>();
    if (!focusRingColor && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(71);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(IOS_FAMILY)
    auto localizedDeviceModel = decoder.decode<String>();
    if (!localizedDeviceModel && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(72);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(IOS_FAMILY)
    auto contentSizeCategory = decoder.decode<String>();
    if (!contentSizeCategory && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(73);
        addedDecodingFailureIndex = true;
    }
#endif
#if USE(GBM)
    auto renderDeviceFile = decoder.decode<String>();
    if (!renderDeviceFile && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(74);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    auto rendererBufferTransportMode = decoder.decode<OptionSet<WebKit::RendererBufferTransportMode>>();
    if (!rendererBufferTransportMode && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(75);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    auto systemSettings = decoder.decode<WebCore::SystemSettings::State>();
    if (!systemSettings && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(76);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    auto memoryPressureHandlerConfiguration = decoder.decode<std::optional<WTF::MemoryPressureHandler::Configuration>>();
    if (!memoryPressureHandlerConfiguration && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(77);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    auto disableFontHintingForTesting = decoder.decode<bool>();
    if (!disableFontHintingForTesting && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(78);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
    auto availableInputDevices = decoder.decode<OptionSet<WebKit::AvailableInputDevices>>();
    if (!availableInputDevices && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(79);
        addedDecodingFailureIndex = true;
    }
#endif
#if PLATFORM(GTK)
    auto useSystemAppearanceForScrollbars = decoder.decode<bool>();
    if (!useSystemAppearanceForScrollbars && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(80);
        addedDecodingFailureIndex = true;
    }
#endif
#if HAVE(CATALYST_USER_INTERFACE_IDIOM_AND_SCALE_FACTOR)
    auto overrideUserInterfaceIdiomAndScale = decoder.decode<std::pair<int64_t, double>>();
    if (!overrideUserInterfaceIdiomAndScale && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(81);
        addedDecodingFailureIndex = true;
    }
#endif
#if HAVE(IOSURFACE)
    auto maximumIOSurfaceSize = decoder.decode<WebCore::IntSize>();
    if (!maximumIOSurfaceSize && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(82);
        addedDecodingFailureIndex = true;
    }
#endif
#if HAVE(IOSURFACE)
    auto bytesPerRowIOSurfaceAlignment = decoder.decode<uint64_t>();
    if (!bytesPerRowIOSurfaceAlignment && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(83);
        addedDecodingFailureIndex = true;
    }
#endif
    auto accessibilityPreferences = decoder.decode<WebKit::AccessibilityPreferences>();
    if (!accessibilityPreferences && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(84);
        addedDecodingFailureIndex = true;
    }
#if PLATFORM(IOS_FAMILY)
    auto applicationAccessibilityEnabled = decoder.decode<bool>();
    if (!applicationAccessibilityEnabled && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(85);
        addedDecodingFailureIndex = true;
    }
#endif
#if USE(GLIB)
    auto applicationID = decoder.decode<String>();
    if (!applicationID && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(86);
        addedDecodingFailureIndex = true;
    }
#endif
#if USE(GLIB)
    auto applicationName = decoder.decode<String>();
    if (!applicationName && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(87);
        addedDecodingFailureIndex = true;
    }
#endif
#if USE(GLIB) && ENABLE(REMOTE_INSPECTOR)
    auto inspectorServerAddress = decoder.decode<CString>();
    if (!inspectorServerAddress && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(88);
        addedDecodingFailureIndex = true;
    }
#endif
#if USE(ATSPI)
    auto accessibilityBusAddress = decoder.decode<String>();
    if (!accessibilityBusAddress && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(89);
        addedDecodingFailureIndex = true;
    }
#endif
#if USE(ATSPI)
    auto accessibilityBusName = decoder.decode<String>();
    if (!accessibilityBusName && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(90);
        addedDecodingFailureIndex = true;
    }
#endif
    auto timeZoneOverride = decoder.decode<String>();
    if (!timeZoneOverride && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(91);
        addedDecodingFailureIndex = true;
    }
    auto storageAccessUserAgentStringQuirksData = decoder.decode<HashMap<WebCore::RegistrableDomain, String>>();
    if (!storageAccessUserAgentStringQuirksData && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(92);
        addedDecodingFailureIndex = true;
    }
    auto storageAccessPromptQuirksDomains = decoder.decode<HashSet<WebCore::RegistrableDomain>>();
    if (!storageAccessPromptQuirksDomains && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(93);
        addedDecodingFailureIndex = true;
    }
    auto scriptTrackingPrivacyRules = decoder.decode<WebKit::ScriptTrackingPrivacyRules>();
    if (!scriptTrackingPrivacyRules && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(94);
        addedDecodingFailureIndex = true;
    }
    auto memoryFootprintPollIntervalForTesting = decoder.decode<Seconds>();
    if (!memoryFootprintPollIntervalForTesting && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(95);
        addedDecodingFailureIndex = true;
    }
    auto memoryFootprintNotificationThresholds = decoder.decode<Vector<uint64_t>>();
    if (!memoryFootprintNotificationThresholds && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(96);
        addedDecodingFailureIndex = true;
    }
#if ENABLE(NOTIFY_BLOCKING)
    auto notifyState = decoder.decode<Vector<std::pair<String, uint64_t>>>();
    if (!notifyState && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(97);
        addedDecodingFailureIndex = true;
    }
#endif
#if ENABLE(INITIALIZE_ACCESSIBILITY_ON_DEMAND)
    auto shouldInitializeAccessibility = decoder.decode<bool>();
    if (!shouldInitializeAccessibility && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(98);
        addedDecodingFailureIndex = true;
    }
#endif
#if HAVE(LIQUID_GLASS)
    auto isLiquidGlassEnabled = decoder.decode<bool>();
    if (!isLiquidGlassEnabled && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(99);
        addedDecodingFailureIndex = true;
    }
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebProcessCreationParameters {
            WTFMove(*auxiliaryProcessParameters),
            WTFMove(*injectedBundlePath),
            WTFMove(*injectedBundlePathExtensionHandle),
            WTFMove(*additionalSandboxExtensionHandles),
            WTFMove(*initializationUserData),
#if PLATFORM(COCOA) && ENABLE(REMOTE_INSPECTOR)
            WTFMove(*enableRemoteWebInspectorExtensionHandles),
#endif
            WTFMove(*urlSchemesRegisteredAsEmptyDocument),
            WTFMove(*urlSchemesRegisteredAsSecure),
            WTFMove(*urlSchemesRegisteredAsBypassingContentSecurityPolicy),
            WTFMove(*urlSchemesForWhichDomainRelaxationIsForbidden),
            WTFMove(*urlSchemesRegisteredAsLocal),
#if ENABLE(ALL_LEGACY_REGISTERED_SPECIAL_URL_SCHEMES)
            WTFMove(*urlSchemesRegisteredAsNoAccess),
#endif
            WTFMove(*urlSchemesRegisteredAsDisplayIsolated),
            WTFMove(*urlSchemesRegisteredAsCORSEnabled),
            WTFMove(*urlSchemesRegisteredAsAlwaysRevalidated),
            WTFMove(*urlSchemesRegisteredAsCachePartitioned),
            WTFMove(*urlSchemesRegisteredAsCanDisplayOnlyIfCanRequest),
#if ENABLE(WK_WEB_EXTENSIONS)
            WTFMove(*urlSchemesRegisteredAsWebExtensions),
#endif
            WTFMove(*fontAllowList),
            WTFMove(*overrideLanguages),
#if USE(GSTREAMER)
            WTFMove(*gstreamerOptions),
#endif
            WTFMove(*cacheModel),
            WTFMove(*defaultRequestTimeoutInterval),
            WTFMove(*backForwardCacheCapacity),
            WTFMove(*shouldAlwaysUseComplexTextCodePath),
            WTFMove(*shouldEnableMemoryPressureReliefLogging),
            WTFMove(*shouldSuppressMemoryPressureHandler),
            WTFMove(*disableFontSubpixelAntialiasingForTesting),
            WTFMove(*fullKeyboardAccessEnabled),
#if HAVE(MOUSE_DEVICE_OBSERVATION)
            WTFMove(*hasMouseDevice),
#endif
#if HAVE(STYLUS_DEVICE_OBSERVATION)
            WTFMove(*hasStylusDevice),
#endif
            WTFMove(*memoryCacheDisabled),
            WTFMove(*attrStyleEnabled),
            WTFMove(*shouldThrowExceptionForGlobalConstantRedeclaration),
            WTFMove(*crossOriginMode),
#if ENABLE(SERVICE_CONTROLS)
            WTFMove(*hasImageServices),
#endif
#if ENABLE(SERVICE_CONTROLS)
            WTFMove(*hasSelectionServices),
#endif
#if ENABLE(SERVICE_CONTROLS)
            WTFMove(*hasRichContentServices),
#endif
            WTFMove(*textCheckerState),
#if PLATFORM(COCOA)
            WTFMove(*uiProcessBundleIdentifier),
#endif
#if PLATFORM(COCOA)
            WTFMove(*latencyQOS),
#endif
#if PLATFORM(COCOA)
            WTFMove(*throughputQOS),
#endif
            WTFMove(*presentingApplicationPID),
#if PLATFORM(COCOA)
            WTFMove(*uiProcessBundleResourcePath),
#endif
#if PLATFORM(COCOA)
            WTFMove(*uiProcessBundleResourcePathExtensionHandle),
#endif
#if PLATFORM(COCOA)
            WTFMove(*shouldEnableJIT),
#endif
#if PLATFORM(COCOA)
            WTFMove(*shouldEnableFTLJIT),
#endif
#if PLATFORM(COCOA)
            WTFMove(*accessibilityEnhancedUserInterfaceEnabled),
#endif
#if PLATFORM(COCOA)
            WTFMove(*bundleParameterData),
#endif
#if ENABLE(NOTIFICATIONS)
            WTFMove(*notificationPermissions),
#endif
#if PLATFORM(COCOA)
            WTFMove(*networkATSContext),
#endif
#if PLATFORM(WAYLAND)
            WTFMove(*waylandCompositorDisplayName),
#endif
#if PLATFORM(COCOA)
            WTFMove(*mediaMIMETypes),
#endif
#if PLATFORM(COCOA) || PLATFORM(GTK) || (PLATFORM(WPE) && ENABLE(WPE_PLATFORM))
            WTFMove(*screenProperties),
#endif
#if !RELEASE_LOG_DISABLED
            WTFMove(*shouldLogUserInteraction),
#endif
#if PLATFORM(MAC)
            WTFMove(*useOverlayScrollbars),
#endif
#if USE(WPE_RENDERER)
            WTFMove(*isServiceWorkerProcess),
#endif
#if USE(WPE_RENDERER)
            WTFMove(*hostClientFileDescriptor),
#endif
#if USE(WPE_RENDERER)
            WTFMove(*implementationLibraryName),
#endif
            WTFMove(*websiteDataStoreParameters),
            WTFMove(*mobileGestaltExtensionHandle),
            WTFMove(*launchServicesExtensionHandle),
#if (PLATFORM(MAC) || PLATFORM(MACCATALYST)) && HAVE(VIDEO_RESTRICTED_DECODING)
            WTFMove(*trustdExtensionHandle),
#endif
#if HAVE(VIDEO_RESTRICTED_DECODING)
            WTFMove(*enableDecodingHEIC),
#endif
#if HAVE(VIDEO_RESTRICTED_DECODING)
            WTFMove(*enableDecodingAVIF),
#endif
#if PLATFORM(VISION)
            WTFMove(*metalCacheDirectoryExtensionHandles),
#endif
#if PLATFORM(COCOA)
            WTFMove(*systemHasBattery),
#endif
#if PLATFORM(COCOA)
            WTFMove(*systemHasAC),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*currentUserInterfaceIdiom),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*supportsPictureInPicture),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*cssValueToSystemColorMap),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*focusRingColor),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*localizedDeviceModel),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*contentSizeCategory),
#endif
#if USE(GBM)
            WTFMove(*renderDeviceFile),
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
            WTFMove(*rendererBufferTransportMode),
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
            WTFMove(*systemSettings),
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
            WTFMove(*memoryPressureHandlerConfiguration),
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
            WTFMove(*disableFontHintingForTesting),
#endif
#if PLATFORM(GTK) || PLATFORM(WPE)
            WTFMove(*availableInputDevices),
#endif
#if PLATFORM(GTK)
            WTFMove(*useSystemAppearanceForScrollbars),
#endif
#if HAVE(CATALYST_USER_INTERFACE_IDIOM_AND_SCALE_FACTOR)
            WTFMove(*overrideUserInterfaceIdiomAndScale),
#endif
#if HAVE(IOSURFACE)
            WTFMove(*maximumIOSurfaceSize),
#endif
#if HAVE(IOSURFACE)
            WTFMove(*bytesPerRowIOSurfaceAlignment),
#endif
            WTFMove(*accessibilityPreferences),
#if PLATFORM(IOS_FAMILY)
            WTFMove(*applicationAccessibilityEnabled),
#endif
#if USE(GLIB)
            WTFMove(*applicationID),
#endif
#if USE(GLIB)
            WTFMove(*applicationName),
#endif
#if USE(GLIB) && ENABLE(REMOTE_INSPECTOR)
            WTFMove(*inspectorServerAddress),
#endif
#if USE(ATSPI)
            WTFMove(*accessibilityBusAddress),
#endif
#if USE(ATSPI)
            WTFMove(*accessibilityBusName),
#endif
            WTFMove(*timeZoneOverride),
            WTFMove(*storageAccessUserAgentStringQuirksData),
            WTFMove(*storageAccessPromptQuirksDomains),
            WTFMove(*scriptTrackingPrivacyRules),
            WTFMove(*memoryFootprintPollIntervalForTesting),
            WTFMove(*memoryFootprintNotificationThresholds),
#if ENABLE(NOTIFY_BLOCKING)
            WTFMove(*notifyState),
#endif
#if ENABLE(INITIALIZE_ACCESSIBILITY_ON_DEMAND)
            WTFMove(*shouldInitializeAccessibility),
#endif
#if HAVE(LIQUID_GLASS)
            WTFMove(*isLiquidGlassEnabled)
#endif
        }
    };
}

void ArgumentCoder<WebKit::WebProcessDataStoreParameters>::encode(Encoder& encoder, WebKit::WebProcessDataStoreParameters&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sessionID)>, PAL::SessionID>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaCacheDirectory)>, String>);
#if !ENABLE(GPU_PROCESS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaCacheDirectoryExtensionHandle)>, WebKit::SandboxExtensionHandle>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaKeyStorageDirectory)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaKeyStorageDirectoryExtensionHandle)>, WebKit::SandboxExtensionHandle>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaKeysStorageSalt)>, FileSystem::Salt>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.javaScriptConfigurationDirectory)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.javaScriptConfigurationDirectoryExtensionHandle)>, WebKit::SandboxExtensionHandle>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.thirdPartyCookieBlockingMode)>, WebCore::ThirdPartyCookieBlockingMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.domainsWithUserInteraction)>, HashSet<WebCore::RegistrableDomain>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.domainsWithStorageAccessQuirk)>, HashMap<WebCore::RegistrableDomain, Vector<WebCore::RegistrableDomain>>>);
#if ENABLE(ARKIT_INLINE_PREVIEW) && !PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.modelElementCacheDirectory)>, String>);
#endif
#if ENABLE(ARKIT_INLINE_PREVIEW) && !PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.modelElementCacheDirectoryExtensionHandle)>, WebKit::SandboxExtensionHandle>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.containerTemporaryDirectoryExtensionHandle)>, WebKit::SandboxExtensionHandle>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.trackingPreventionEnabled)>, bool>);
#if HAVE(ALLOW_ONLY_PARTITIONED_COOKIES)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isOptInCookiePartitioningEnabled)>, bool>);
#endif
    struct ShouldBeSameSizeAsWebProcessDataStoreParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebProcessDataStoreParameters>, false> {
        PAL::SessionID sessionID;
        String mediaCacheDirectory;
#if !ENABLE(GPU_PROCESS)
        WebKit::SandboxExtensionHandle mediaCacheDirectoryExtensionHandle;
#endif
        String mediaKeyStorageDirectory;
        WebKit::SandboxExtensionHandle mediaKeyStorageDirectoryExtensionHandle;
        FileSystem::Salt mediaKeysStorageSalt;
        String javaScriptConfigurationDirectory;
        WebKit::SandboxExtensionHandle javaScriptConfigurationDirectoryExtensionHandle;
        WebCore::ThirdPartyCookieBlockingMode thirdPartyCookieBlockingMode;
        HashSet<WebCore::RegistrableDomain> domainsWithUserInteraction;
        HashMap<WebCore::RegistrableDomain, Vector<WebCore::RegistrableDomain>> domainsWithStorageAccessQuirk;
#if ENABLE(ARKIT_INLINE_PREVIEW) && !PLATFORM(IOS_FAMILY)
        String modelElementCacheDirectory;
#endif
#if ENABLE(ARKIT_INLINE_PREVIEW) && !PLATFORM(IOS_FAMILY)
        WebKit::SandboxExtensionHandle modelElementCacheDirectoryExtensionHandle;
#endif
#if PLATFORM(IOS_FAMILY)
        WebKit::SandboxExtensionHandle containerTemporaryDirectoryExtensionHandle;
#endif
        bool trackingPreventionEnabled;
#if HAVE(ALLOW_ONLY_PARTITIONED_COOKIES)
        bool isOptInCookiePartitioningEnabled;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebProcessDataStoreParameters) == sizeof(WebKit::WebProcessDataStoreParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebProcessDataStoreParameters, sessionID)
        , offsetof(WebKit::WebProcessDataStoreParameters, mediaCacheDirectory)
#if !ENABLE(GPU_PROCESS)
        , offsetof(WebKit::WebProcessDataStoreParameters, mediaCacheDirectoryExtensionHandle)
#endif
        , offsetof(WebKit::WebProcessDataStoreParameters, mediaKeyStorageDirectory)
        , offsetof(WebKit::WebProcessDataStoreParameters, mediaKeyStorageDirectoryExtensionHandle)
        , offsetof(WebKit::WebProcessDataStoreParameters, mediaKeysStorageSalt)
        , offsetof(WebKit::WebProcessDataStoreParameters, javaScriptConfigurationDirectory)
        , offsetof(WebKit::WebProcessDataStoreParameters, javaScriptConfigurationDirectoryExtensionHandle)
        , offsetof(WebKit::WebProcessDataStoreParameters, thirdPartyCookieBlockingMode)
        , offsetof(WebKit::WebProcessDataStoreParameters, domainsWithUserInteraction)
        , offsetof(WebKit::WebProcessDataStoreParameters, domainsWithStorageAccessQuirk)
#if ENABLE(ARKIT_INLINE_PREVIEW) && !PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::WebProcessDataStoreParameters, modelElementCacheDirectory)
#endif
#if ENABLE(ARKIT_INLINE_PREVIEW) && !PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::WebProcessDataStoreParameters, modelElementCacheDirectoryExtensionHandle)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::WebProcessDataStoreParameters, containerTemporaryDirectoryExtensionHandle)
#endif
        , offsetof(WebKit::WebProcessDataStoreParameters, trackingPreventionEnabled)
#if HAVE(ALLOW_ONLY_PARTITIONED_COOKIES)
        , offsetof(WebKit::WebProcessDataStoreParameters, isOptInCookiePartitioningEnabled)
#endif
    >::value);

    encoder << WTFMove(instance.sessionID);
    encoder << WTFMove(instance.mediaCacheDirectory);
#if !ENABLE(GPU_PROCESS)
    encoder << WTFMove(instance.mediaCacheDirectoryExtensionHandle);
#endif
    encoder << WTFMove(instance.mediaKeyStorageDirectory);
    encoder << WTFMove(instance.mediaKeyStorageDirectoryExtensionHandle);
    encoder << WTFMove(instance.mediaKeysStorageSalt);
    encoder << WTFMove(instance.javaScriptConfigurationDirectory);
    encoder << WTFMove(instance.javaScriptConfigurationDirectoryExtensionHandle);
    encoder << WTFMove(instance.thirdPartyCookieBlockingMode);
    encoder << WTFMove(instance.domainsWithUserInteraction);
    encoder << WTFMove(instance.domainsWithStorageAccessQuirk);
#if ENABLE(ARKIT_INLINE_PREVIEW) && !PLATFORM(IOS_FAMILY)
    encoder << WTFMove(instance.modelElementCacheDirectory);
#endif
#if ENABLE(ARKIT_INLINE_PREVIEW) && !PLATFORM(IOS_FAMILY)
    encoder << WTFMove(instance.modelElementCacheDirectoryExtensionHandle);
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << WTFMove(instance.containerTemporaryDirectoryExtensionHandle);
#endif
    encoder << WTFMove(instance.trackingPreventionEnabled);
#if HAVE(ALLOW_ONLY_PARTITIONED_COOKIES)
    encoder << WTFMove(instance.isOptInCookiePartitioningEnabled);
#endif
}

std::optional<WebKit::WebProcessDataStoreParameters> ArgumentCoder<WebKit::WebProcessDataStoreParameters>::decode(Decoder& decoder)
{
    auto sessionID = decoder.decode<PAL::SessionID>();
    auto mediaCacheDirectory = decoder.decode<String>();
#if !ENABLE(GPU_PROCESS)
    auto mediaCacheDirectoryExtensionHandle = decoder.decode<WebKit::SandboxExtensionHandle>();
#endif
    auto mediaKeyStorageDirectory = decoder.decode<String>();
    auto mediaKeyStorageDirectoryExtensionHandle = decoder.decode<WebKit::SandboxExtensionHandle>();
    auto mediaKeysStorageSalt = decoder.decode<FileSystem::Salt>();
    auto javaScriptConfigurationDirectory = decoder.decode<String>();
    auto javaScriptConfigurationDirectoryExtensionHandle = decoder.decode<WebKit::SandboxExtensionHandle>();
    auto thirdPartyCookieBlockingMode = decoder.decode<WebCore::ThirdPartyCookieBlockingMode>();
    auto domainsWithUserInteraction = decoder.decode<HashSet<WebCore::RegistrableDomain>>();
    auto domainsWithStorageAccessQuirk = decoder.decode<HashMap<WebCore::RegistrableDomain, Vector<WebCore::RegistrableDomain>>>();
#if ENABLE(ARKIT_INLINE_PREVIEW) && !PLATFORM(IOS_FAMILY)
    auto modelElementCacheDirectory = decoder.decode<String>();
#endif
#if ENABLE(ARKIT_INLINE_PREVIEW) && !PLATFORM(IOS_FAMILY)
    auto modelElementCacheDirectoryExtensionHandle = decoder.decode<WebKit::SandboxExtensionHandle>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto containerTemporaryDirectoryExtensionHandle = decoder.decode<WebKit::SandboxExtensionHandle>();
#endif
    auto trackingPreventionEnabled = decoder.decode<bool>();
#if HAVE(ALLOW_ONLY_PARTITIONED_COOKIES)
    auto isOptInCookiePartitioningEnabled = decoder.decode<bool>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebProcessDataStoreParameters {
            WTFMove(*sessionID),
            WTFMove(*mediaCacheDirectory),
#if !ENABLE(GPU_PROCESS)
            WTFMove(*mediaCacheDirectoryExtensionHandle),
#endif
            WTFMove(*mediaKeyStorageDirectory),
            WTFMove(*mediaKeyStorageDirectoryExtensionHandle),
            WTFMove(*mediaKeysStorageSalt),
            WTFMove(*javaScriptConfigurationDirectory),
            WTFMove(*javaScriptConfigurationDirectoryExtensionHandle),
            WTFMove(*thirdPartyCookieBlockingMode),
            WTFMove(*domainsWithUserInteraction),
            WTFMove(*domainsWithStorageAccessQuirk),
#if ENABLE(ARKIT_INLINE_PREVIEW) && !PLATFORM(IOS_FAMILY)
            WTFMove(*modelElementCacheDirectory),
#endif
#if ENABLE(ARKIT_INLINE_PREVIEW) && !PLATFORM(IOS_FAMILY)
            WTFMove(*modelElementCacheDirectoryExtensionHandle),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*containerTemporaryDirectoryExtensionHandle),
#endif
            WTFMove(*trackingPreventionEnabled),
#if HAVE(ALLOW_ONLY_PARTITIONED_COOKIES)
            WTFMove(*isOptInCookiePartitioningEnabled)
#endif
        }
    };
}

void ArgumentCoder<WebKit::WebUserScriptData>::encode(Encoder& encoder, const WebKit::WebUserScriptData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, WebKit::UserScriptIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.worldIdentifier)>, WebKit::ContentWorldIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.userScript)>, WebCore::UserScript>);
    struct ShouldBeSameSizeAsWebUserScriptData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebUserScriptData>, false> {
        WebKit::UserScriptIdentifier identifier;
        WebKit::ContentWorldIdentifier worldIdentifier;
        WebCore::UserScript userScript;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebUserScriptData) == sizeof(WebKit::WebUserScriptData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebUserScriptData, identifier)
        , offsetof(WebKit::WebUserScriptData, worldIdentifier)
        , offsetof(WebKit::WebUserScriptData, userScript)
    >::value);

    encoder << instance.identifier;
    encoder << instance.worldIdentifier;
    encoder << instance.userScript;
}

std::optional<WebKit::WebUserScriptData> ArgumentCoder<WebKit::WebUserScriptData>::decode(Decoder& decoder)
{
    bool addedDecodingFailureIndex = false;
    auto identifier = decoder.decode<WebKit::UserScriptIdentifier>();
    if (!identifier && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(0);
        addedDecodingFailureIndex = true;
    }
    auto worldIdentifier = decoder.decode<WebKit::ContentWorldIdentifier>();
    if (!worldIdentifier && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(1);
        addedDecodingFailureIndex = true;
    }
    auto userScript = decoder.decode<WebCore::UserScript>();
    if (!userScript && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(2);
        addedDecodingFailureIndex = true;
    }
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebUserScriptData {
            WTFMove(*identifier),
            WTFMove(*worldIdentifier),
            WTFMove(*userScript)
        }
    };
}

void ArgumentCoder<WebKit::WebUserStyleSheetData>::encode(Encoder& encoder, const WebKit::WebUserStyleSheetData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, WebKit::UserStyleSheetIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.worldIdentifier)>, WebKit::ContentWorldIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.userStyleSheet)>, WebCore::UserStyleSheet>);
    struct ShouldBeSameSizeAsWebUserStyleSheetData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebUserStyleSheetData>, false> {
        WebKit::UserStyleSheetIdentifier identifier;
        WebKit::ContentWorldIdentifier worldIdentifier;
        WebCore::UserStyleSheet userStyleSheet;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebUserStyleSheetData) == sizeof(WebKit::WebUserStyleSheetData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebUserStyleSheetData, identifier)
        , offsetof(WebKit::WebUserStyleSheetData, worldIdentifier)
        , offsetof(WebKit::WebUserStyleSheetData, userStyleSheet)
    >::value);

    encoder << instance.identifier;
    encoder << instance.worldIdentifier;
    encoder << instance.userStyleSheet;
}

std::optional<WebKit::WebUserStyleSheetData> ArgumentCoder<WebKit::WebUserStyleSheetData>::decode(Decoder& decoder)
{
    bool addedDecodingFailureIndex = false;
    auto identifier = decoder.decode<WebKit::UserStyleSheetIdentifier>();
    if (!identifier && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(0);
        addedDecodingFailureIndex = true;
    }
    auto worldIdentifier = decoder.decode<WebKit::ContentWorldIdentifier>();
    if (!worldIdentifier && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(1);
        addedDecodingFailureIndex = true;
    }
    auto userStyleSheet = decoder.decode<WebCore::UserStyleSheet>();
    if (!userStyleSheet && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(2);
        addedDecodingFailureIndex = true;
    }
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebUserStyleSheetData {
            WTFMove(*identifier),
            WTFMove(*worldIdentifier),
            WTFMove(*userStyleSheet)
        }
    };
}

void ArgumentCoder<WebKit::WebScriptMessageHandlerData>::encode(Encoder& encoder, const WebKit::WebScriptMessageHandlerData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, WebKit::ScriptMessageHandlerIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.worldIdentifier)>, WebKit::ContentWorldIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, String>);
    struct ShouldBeSameSizeAsWebScriptMessageHandlerData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebScriptMessageHandlerData>, false> {
        WebKit::ScriptMessageHandlerIdentifier identifier;
        WebKit::ContentWorldIdentifier worldIdentifier;
        String name;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebScriptMessageHandlerData) == sizeof(WebKit::WebScriptMessageHandlerData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebScriptMessageHandlerData, identifier)
        , offsetof(WebKit::WebScriptMessageHandlerData, worldIdentifier)
        , offsetof(WebKit::WebScriptMessageHandlerData, name)
    >::value);

    encoder << instance.identifier;
    encoder << instance.worldIdentifier;
    encoder << instance.name;
}

std::optional<WebKit::WebScriptMessageHandlerData> ArgumentCoder<WebKit::WebScriptMessageHandlerData>::decode(Decoder& decoder)
{
    bool addedDecodingFailureIndex = false;
    auto identifier = decoder.decode<WebKit::ScriptMessageHandlerIdentifier>();
    if (!identifier && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(0);
        addedDecodingFailureIndex = true;
    }
    auto worldIdentifier = decoder.decode<WebKit::ContentWorldIdentifier>();
    if (!worldIdentifier && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(1);
        addedDecodingFailureIndex = true;
    }
    auto name = decoder.decode<String>();
    if (!name && !addedDecodingFailureIndex) [[unlikely]] {
        decoder.addIndexOfDecodingFailure(2);
        addedDecodingFailureIndex = true;
    }
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebScriptMessageHandlerData {
            WTFMove(*identifier),
            WTFMove(*worldIdentifier),
            WTFMove(*name)
        }
    };
}

void ArgumentCoder<WebKit::WebsiteDataStoreParameters>::encode(Encoder& encoder, WebKit::WebsiteDataStoreParameters&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.uiProcessCookieStorageIdentifier)>, Vector<uint8_t>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cookieStoragePathExtensionHandle)>, WebKit::SandboxExtensionHandle>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.networkSessionParameters)>, WebKit::NetworkSessionCreationParameters>);
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cookieStorageDirectoryExtensionHandle)>, std::optional<WebKit::SandboxExtensionHandle>>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.containerCachesDirectoryExtensionHandle)>, std::optional<WebKit::SandboxExtensionHandle>>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.parentBundleDirectoryExtensionHandle)>, std::optional<WebKit::SandboxExtensionHandle>>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tempDirectoryExtensionHandle)>, std::optional<WebKit::SandboxExtensionHandle>>);
#endif
#if PLATFORM(IOS_FAMILY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tempDirectoryRootExtensionHandle)>, std::optional<WebKit::SandboxExtensionHandle>>);
#endif
    struct ShouldBeSameSizeAsWebsiteDataStoreParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebsiteDataStoreParameters>, false> {
        Vector<uint8_t> uiProcessCookieStorageIdentifier;
        WebKit::SandboxExtensionHandle cookieStoragePathExtensionHandle;
        WebKit::NetworkSessionCreationParameters networkSessionParameters;
#if PLATFORM(IOS_FAMILY)
        std::optional<WebKit::SandboxExtensionHandle> cookieStorageDirectoryExtensionHandle;
#endif
#if PLATFORM(IOS_FAMILY)
        std::optional<WebKit::SandboxExtensionHandle> containerCachesDirectoryExtensionHandle;
#endif
#if PLATFORM(IOS_FAMILY)
        std::optional<WebKit::SandboxExtensionHandle> parentBundleDirectoryExtensionHandle;
#endif
#if PLATFORM(IOS_FAMILY)
        std::optional<WebKit::SandboxExtensionHandle> tempDirectoryExtensionHandle;
#endif
#if PLATFORM(IOS_FAMILY)
        std::optional<WebKit::SandboxExtensionHandle> tempDirectoryRootExtensionHandle;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebsiteDataStoreParameters) == sizeof(WebKit::WebsiteDataStoreParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebsiteDataStoreParameters, uiProcessCookieStorageIdentifier)
        , offsetof(WebKit::WebsiteDataStoreParameters, cookieStoragePathExtensionHandle)
        , offsetof(WebKit::WebsiteDataStoreParameters, networkSessionParameters)
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::WebsiteDataStoreParameters, cookieStorageDirectoryExtensionHandle)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::WebsiteDataStoreParameters, containerCachesDirectoryExtensionHandle)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::WebsiteDataStoreParameters, parentBundleDirectoryExtensionHandle)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::WebsiteDataStoreParameters, tempDirectoryExtensionHandle)
#endif
#if PLATFORM(IOS_FAMILY)
        , offsetof(WebKit::WebsiteDataStoreParameters, tempDirectoryRootExtensionHandle)
#endif
    >::value);

    encoder << WTFMove(instance.uiProcessCookieStorageIdentifier);
    encoder << WTFMove(instance.cookieStoragePathExtensionHandle);
    encoder << WTFMove(instance.networkSessionParameters);
#if PLATFORM(IOS_FAMILY)
    encoder << WTFMove(instance.cookieStorageDirectoryExtensionHandle);
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << WTFMove(instance.containerCachesDirectoryExtensionHandle);
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << WTFMove(instance.parentBundleDirectoryExtensionHandle);
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << WTFMove(instance.tempDirectoryExtensionHandle);
#endif
#if PLATFORM(IOS_FAMILY)
    encoder << WTFMove(instance.tempDirectoryRootExtensionHandle);
#endif
}

std::optional<WebKit::WebsiteDataStoreParameters> ArgumentCoder<WebKit::WebsiteDataStoreParameters>::decode(Decoder& decoder)
{
    auto uiProcessCookieStorageIdentifier = decoder.decode<Vector<uint8_t>>();
    auto cookieStoragePathExtensionHandle = decoder.decode<WebKit::SandboxExtensionHandle>();
    auto networkSessionParameters = decoder.decode<WebKit::NetworkSessionCreationParameters>();
#if PLATFORM(IOS_FAMILY)
    auto cookieStorageDirectoryExtensionHandle = decoder.decode<std::optional<WebKit::SandboxExtensionHandle>>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto containerCachesDirectoryExtensionHandle = decoder.decode<std::optional<WebKit::SandboxExtensionHandle>>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto parentBundleDirectoryExtensionHandle = decoder.decode<std::optional<WebKit::SandboxExtensionHandle>>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto tempDirectoryExtensionHandle = decoder.decode<std::optional<WebKit::SandboxExtensionHandle>>();
#endif
#if PLATFORM(IOS_FAMILY)
    auto tempDirectoryRootExtensionHandle = decoder.decode<std::optional<WebKit::SandboxExtensionHandle>>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebsiteDataStoreParameters {
            WTFMove(*uiProcessCookieStorageIdentifier),
            WTFMove(*cookieStoragePathExtensionHandle),
            WTFMove(*networkSessionParameters),
#if PLATFORM(IOS_FAMILY)
            WTFMove(*cookieStorageDirectoryExtensionHandle),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*containerCachesDirectoryExtensionHandle),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*parentBundleDirectoryExtensionHandle),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*tempDirectoryExtensionHandle),
#endif
#if PLATFORM(IOS_FAMILY)
            WTFMove(*tempDirectoryRootExtensionHandle)
#endif
        }
    };
}

void ArgumentCoder<WebKit::WebsitePoliciesData>::encode(Encoder& encoder, const WebKit::WebsitePoliciesData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.activeContentRuleListActionPatterns)>, HashMap<String, Vector<String>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.customHeaderFields)>, Vector<WebCore::CustomHeaderFields>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.visibilityAdjustmentSelectors)>, Vector<WebCore::TargetedElementSelectors>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.customUserAgent)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.customUserAgentAsSiteSpecificQuirks)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.customNavigatorPlatform)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.applicationNameForDesktopUserAgent)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.advancedPrivacyProtections)>, OptionSet<WebCore::AdvancedPrivacyProtections>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowedAutoplayQuirks)>, OptionSet<WebKit::WebsiteAutoplayQuirk>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentExtensionEnablement)>, WebCore::ContentExtensionEnablement>);
#if ENABLE(TOUCH_EVENTS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.overrideTouchEventDOMAttributesEnabled)>, std::optional<bool>>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.autoplayPolicy)>, WebKit::WebsiteAutoplayPolicy>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.popUpPolicy)>, WebKit::WebsitePopUpPolicy>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.metaViewportPolicy)>, WebKit::WebsiteMetaViewportPolicy>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaSourcePolicy)>, WebKit::WebsiteMediaSourcePolicy>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.simulatedMouseEventsDispatchPolicy)>, WebKit::WebsiteSimulatedMouseEventsDispatchPolicy>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.legacyOverflowScrollingTouchPolicy)>, WebKit::WebsiteLegacyOverflowScrollingTouchPolicy>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowsContentJavaScript)>, WebCore::AllowsContentJavaScript>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mouseEventPolicy)>, WebCore::MouseEventPolicy>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.modalContainerObservationPolicy)>, WebCore::ModalContainerObservationPolicy>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorSchemePreference)>, WebCore::ColorSchemePreference>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.preferredContentMode)>, WebKit::WebContentMode>);
#if ENABLE(DEVICE_ORIENTATION)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.deviceOrientationAndMotionAccessState)>, std::optional<WebCore::DeviceOrientationOrMotionPermissionState>>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.httpsByDefaultMode)>, WebCore::HTTPSByDefaultMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.idempotentModeAutosizingOnlyHonorsPercentages)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowPrivacyProxy)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowSiteSpecificQuirksToOverrideContentMode)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pushAndNotificationsEnabledPolicy)>, WebKit::WebsitePushAndNotificationsEnabledPolicy>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.inlineMediaPlaybackPolicy)>, WebKit::WebsiteInlineMediaPlaybackPolicy>);
    struct ShouldBeSameSizeAsWebsitePoliciesData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebsitePoliciesData>, false> {
        HashMap<String, Vector<String>> activeContentRuleListActionPatterns;
        Vector<WebCore::CustomHeaderFields> customHeaderFields;
        Vector<WebCore::TargetedElementSelectors> visibilityAdjustmentSelectors;
        String customUserAgent;
        String customUserAgentAsSiteSpecificQuirks;
        String customNavigatorPlatform;
        String applicationNameForDesktopUserAgent;
        OptionSet<WebCore::AdvancedPrivacyProtections> advancedPrivacyProtections;
        OptionSet<WebKit::WebsiteAutoplayQuirk> allowedAutoplayQuirks;
        WebCore::ContentExtensionEnablement contentExtensionEnablement;
#if ENABLE(TOUCH_EVENTS)
        std::optional<bool> overrideTouchEventDOMAttributesEnabled;
#endif
        WebKit::WebsiteAutoplayPolicy autoplayPolicy;
        WebKit::WebsitePopUpPolicy popUpPolicy;
        WebKit::WebsiteMetaViewportPolicy metaViewportPolicy;
        WebKit::WebsiteMediaSourcePolicy mediaSourcePolicy;
        WebKit::WebsiteSimulatedMouseEventsDispatchPolicy simulatedMouseEventsDispatchPolicy;
        WebKit::WebsiteLegacyOverflowScrollingTouchPolicy legacyOverflowScrollingTouchPolicy;
        WebCore::AllowsContentJavaScript allowsContentJavaScript;
        WebCore::MouseEventPolicy mouseEventPolicy;
        WebCore::ModalContainerObservationPolicy modalContainerObservationPolicy;
        WebCore::ColorSchemePreference colorSchemePreference;
        WebKit::WebContentMode preferredContentMode;
#if ENABLE(DEVICE_ORIENTATION)
        std::optional<WebCore::DeviceOrientationOrMotionPermissionState> deviceOrientationAndMotionAccessState;
#endif
        WebCore::HTTPSByDefaultMode httpsByDefaultMode;
        bool idempotentModeAutosizingOnlyHonorsPercentages;
        bool allowPrivacyProxy;
        bool allowSiteSpecificQuirksToOverrideContentMode;
        WebKit::WebsitePushAndNotificationsEnabledPolicy pushAndNotificationsEnabledPolicy;
        WebKit::WebsiteInlineMediaPlaybackPolicy inlineMediaPlaybackPolicy;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebsitePoliciesData) == sizeof(WebKit::WebsitePoliciesData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebsitePoliciesData, activeContentRuleListActionPatterns)
        , offsetof(WebKit::WebsitePoliciesData, customHeaderFields)
        , offsetof(WebKit::WebsitePoliciesData, visibilityAdjustmentSelectors)
        , offsetof(WebKit::WebsitePoliciesData, customUserAgent)
        , offsetof(WebKit::WebsitePoliciesData, customUserAgentAsSiteSpecificQuirks)
        , offsetof(WebKit::WebsitePoliciesData, customNavigatorPlatform)
        , offsetof(WebKit::WebsitePoliciesData, applicationNameForDesktopUserAgent)
        , offsetof(WebKit::WebsitePoliciesData, advancedPrivacyProtections)
        , offsetof(WebKit::WebsitePoliciesData, allowedAutoplayQuirks)
        , offsetof(WebKit::WebsitePoliciesData, contentExtensionEnablement)
#if ENABLE(TOUCH_EVENTS)
        , offsetof(WebKit::WebsitePoliciesData, overrideTouchEventDOMAttributesEnabled)
#endif
        , offsetof(WebKit::WebsitePoliciesData, autoplayPolicy)
        , offsetof(WebKit::WebsitePoliciesData, popUpPolicy)
        , offsetof(WebKit::WebsitePoliciesData, metaViewportPolicy)
        , offsetof(WebKit::WebsitePoliciesData, mediaSourcePolicy)
        , offsetof(WebKit::WebsitePoliciesData, simulatedMouseEventsDispatchPolicy)
        , offsetof(WebKit::WebsitePoliciesData, legacyOverflowScrollingTouchPolicy)
        , offsetof(WebKit::WebsitePoliciesData, allowsContentJavaScript)
        , offsetof(WebKit::WebsitePoliciesData, mouseEventPolicy)
        , offsetof(WebKit::WebsitePoliciesData, modalContainerObservationPolicy)
        , offsetof(WebKit::WebsitePoliciesData, colorSchemePreference)
        , offsetof(WebKit::WebsitePoliciesData, preferredContentMode)
#if ENABLE(DEVICE_ORIENTATION)
        , offsetof(WebKit::WebsitePoliciesData, deviceOrientationAndMotionAccessState)
#endif
        , offsetof(WebKit::WebsitePoliciesData, httpsByDefaultMode)
        , offsetof(WebKit::WebsitePoliciesData, idempotentModeAutosizingOnlyHonorsPercentages)
        , offsetof(WebKit::WebsitePoliciesData, allowPrivacyProxy)
        , offsetof(WebKit::WebsitePoliciesData, allowSiteSpecificQuirksToOverrideContentMode)
        , offsetof(WebKit::WebsitePoliciesData, pushAndNotificationsEnabledPolicy)
        , offsetof(WebKit::WebsitePoliciesData, inlineMediaPlaybackPolicy)
    >::value);

    encoder << instance.activeContentRuleListActionPatterns;
    encoder << instance.customHeaderFields;
    encoder << instance.visibilityAdjustmentSelectors;
    encoder << instance.customUserAgent;
    encoder << instance.customUserAgentAsSiteSpecificQuirks;
    encoder << instance.customNavigatorPlatform;
    encoder << instance.applicationNameForDesktopUserAgent;
    encoder << instance.advancedPrivacyProtections;
    encoder << instance.allowedAutoplayQuirks;
    encoder << instance.contentExtensionEnablement;
#if ENABLE(TOUCH_EVENTS)
    encoder << instance.overrideTouchEventDOMAttributesEnabled;
#endif
    encoder << instance.autoplayPolicy;
    encoder << instance.popUpPolicy;
    encoder << instance.metaViewportPolicy;
    encoder << instance.mediaSourcePolicy;
    encoder << instance.simulatedMouseEventsDispatchPolicy;
    encoder << instance.legacyOverflowScrollingTouchPolicy;
    encoder << instance.allowsContentJavaScript;
    encoder << instance.mouseEventPolicy;
    encoder << instance.modalContainerObservationPolicy;
    encoder << instance.colorSchemePreference;
    encoder << instance.preferredContentMode;
#if ENABLE(DEVICE_ORIENTATION)
    encoder << instance.deviceOrientationAndMotionAccessState;
#endif
    encoder << instance.httpsByDefaultMode;
    encoder << instance.idempotentModeAutosizingOnlyHonorsPercentages;
    encoder << instance.allowPrivacyProxy;
    encoder << instance.allowSiteSpecificQuirksToOverrideContentMode;
    encoder << instance.pushAndNotificationsEnabledPolicy;
    encoder << instance.inlineMediaPlaybackPolicy;
}

std::optional<WebKit::WebsitePoliciesData> ArgumentCoder<WebKit::WebsitePoliciesData>::decode(Decoder& decoder)
{
    auto activeContentRuleListActionPatterns = decoder.decode<HashMap<String, Vector<String>>>();
    auto customHeaderFields = decoder.decode<Vector<WebCore::CustomHeaderFields>>();
    auto visibilityAdjustmentSelectors = decoder.decode<Vector<WebCore::TargetedElementSelectors>>();
    auto customUserAgent = decoder.decode<String>();
    auto customUserAgentAsSiteSpecificQuirks = decoder.decode<String>();
    auto customNavigatorPlatform = decoder.decode<String>();
    auto applicationNameForDesktopUserAgent = decoder.decode<String>();
    auto advancedPrivacyProtections = decoder.decode<OptionSet<WebCore::AdvancedPrivacyProtections>>();
    auto allowedAutoplayQuirks = decoder.decode<OptionSet<WebKit::WebsiteAutoplayQuirk>>();
    auto contentExtensionEnablement = decoder.decode<WebCore::ContentExtensionEnablement>();
#if ENABLE(TOUCH_EVENTS)
    auto overrideTouchEventDOMAttributesEnabled = decoder.decode<std::optional<bool>>();
#endif
    auto autoplayPolicy = decoder.decode<WebKit::WebsiteAutoplayPolicy>();
    auto popUpPolicy = decoder.decode<WebKit::WebsitePopUpPolicy>();
    auto metaViewportPolicy = decoder.decode<WebKit::WebsiteMetaViewportPolicy>();
    auto mediaSourcePolicy = decoder.decode<WebKit::WebsiteMediaSourcePolicy>();
    auto simulatedMouseEventsDispatchPolicy = decoder.decode<WebKit::WebsiteSimulatedMouseEventsDispatchPolicy>();
    auto legacyOverflowScrollingTouchPolicy = decoder.decode<WebKit::WebsiteLegacyOverflowScrollingTouchPolicy>();
    auto allowsContentJavaScript = decoder.decode<WebCore::AllowsContentJavaScript>();
    auto mouseEventPolicy = decoder.decode<WebCore::MouseEventPolicy>();
    auto modalContainerObservationPolicy = decoder.decode<WebCore::ModalContainerObservationPolicy>();
    auto colorSchemePreference = decoder.decode<WebCore::ColorSchemePreference>();
    auto preferredContentMode = decoder.decode<WebKit::WebContentMode>();
#if ENABLE(DEVICE_ORIENTATION)
    auto deviceOrientationAndMotionAccessState = decoder.decode<std::optional<WebCore::DeviceOrientationOrMotionPermissionState>>();
#endif
    auto httpsByDefaultMode = decoder.decode<WebCore::HTTPSByDefaultMode>();
    auto idempotentModeAutosizingOnlyHonorsPercentages = decoder.decode<bool>();
    auto allowPrivacyProxy = decoder.decode<bool>();
    auto allowSiteSpecificQuirksToOverrideContentMode = decoder.decode<bool>();
    auto pushAndNotificationsEnabledPolicy = decoder.decode<WebKit::WebsitePushAndNotificationsEnabledPolicy>();
    auto inlineMediaPlaybackPolicy = decoder.decode<WebKit::WebsiteInlineMediaPlaybackPolicy>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebsitePoliciesData {
            WTFMove(*activeContentRuleListActionPatterns),
            WTFMove(*customHeaderFields),
            WTFMove(*visibilityAdjustmentSelectors),
            WTFMove(*customUserAgent),
            WTFMove(*customUserAgentAsSiteSpecificQuirks),
            WTFMove(*customNavigatorPlatform),
            WTFMove(*applicationNameForDesktopUserAgent),
            WTFMove(*advancedPrivacyProtections),
            WTFMove(*allowedAutoplayQuirks),
            WTFMove(*contentExtensionEnablement),
#if ENABLE(TOUCH_EVENTS)
            WTFMove(*overrideTouchEventDOMAttributesEnabled),
#endif
            WTFMove(*autoplayPolicy),
            WTFMove(*popUpPolicy),
            WTFMove(*metaViewportPolicy),
            WTFMove(*mediaSourcePolicy),
            WTFMove(*simulatedMouseEventsDispatchPolicy),
            WTFMove(*legacyOverflowScrollingTouchPolicy),
            WTFMove(*allowsContentJavaScript),
            WTFMove(*mouseEventPolicy),
            WTFMove(*modalContainerObservationPolicy),
            WTFMove(*colorSchemePreference),
            WTFMove(*preferredContentMode),
#if ENABLE(DEVICE_ORIENTATION)
            WTFMove(*deviceOrientationAndMotionAccessState),
#endif
            WTFMove(*httpsByDefaultMode),
            WTFMove(*idempotentModeAutosizingOnlyHonorsPercentages),
            WTFMove(*allowPrivacyProxy),
            WTFMove(*allowSiteSpecificQuirksToOverrideContentMode),
            WTFMove(*pushAndNotificationsEnabledPolicy),
            WTFMove(*inlineMediaPlaybackPolicy)
        }
    };
}

void ArgumentCoder<API::Array>::encode(Encoder& encoder, const API::Array& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.elements())>, Vector<RefPtr<API::Object>>>);

    encoder << instance.elements();
}

std::optional<Ref<API::Array>> ArgumentCoder<API::Array>::decode(Decoder& decoder)
{
    auto elements = decoder.decode<Vector<RefPtr<API::Object>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        API::Array::create(
            WTFMove(*elements)
        )
    };
}

void ArgumentCoder<API::Data>::encode(Encoder& encoder, const API::Data& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.span())>, std::span<const uint8_t>>);

    encoder << instance.span();
}

std::optional<Ref<API::Data>> ArgumentCoder<API::Data>::decode(Decoder& decoder)
{
    auto span = decoder.decode<std::span<const uint8_t>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        API::Data::create(
            WTFMove(*span)
        )
    };
}

void ArgumentCoder<API::Dictionary>::encode(Encoder& encoder, const API::Dictionary& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.map())>, HashMap<String, RefPtr<API::Object>>>);

    encoder << instance.map();
}

std::optional<Ref<API::Dictionary>> ArgumentCoder<API::Dictionary>::decode(Decoder& decoder)
{
    auto map = decoder.decode<HashMap<String, RefPtr<API::Object>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        API::Dictionary::create(
            WTFMove(*map)
        )
    };
}

void ArgumentCoder<API::Error>::encode(Encoder& encoder, const API::Error& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.platformError())>, WebCore::ResourceError>);

    encoder << instance.platformError();
}

std::optional<Ref<API::Error>> ArgumentCoder<API::Error>::decode(Decoder& decoder)
{
    auto platformError = decoder.decode<WebCore::ResourceError>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        API::Error::create(
            WTFMove(*platformError)
        )
    };
}

void ArgumentCoder<API::FrameHandle>::encode(Encoder& encoder, const API::FrameHandle& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameID())>, Markable<WebCore::FrameIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isAutoconverting())>, bool>);

    encoder << instance.frameID();
    encoder << instance.isAutoconverting();
}

std::optional<Ref<API::FrameHandle>> ArgumentCoder<API::FrameHandle>::decode(Decoder& decoder)
{
    auto frameID = decoder.decode<Markable<WebCore::FrameIdentifier>>();
    auto isAutoconverting = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        API::FrameHandle::create(
            WTFMove(*frameID),
            WTFMove(*isAutoconverting)
        )
    };
}

void ArgumentCoder<API::Size>::encode(Encoder& encoder, const API::Size& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size().width)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size().height)>, double>);

    encoder << instance.size().width;
    encoder << instance.size().height;
}

std::optional<Ref<API::Size>> ArgumentCoder<API::Size>::decode(Decoder& decoder)
{
    auto sizewidth = decoder.decode<double>();
    auto sizeheight = decoder.decode<double>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        API::Size::create(
            WTFMove(*sizewidth),
            WTFMove(*sizeheight)
        )
    };
}

void ArgumentCoder<API::Point>::encode(Encoder& encoder, const API::Point& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.point().x)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.point().y)>, double>);

    encoder << instance.point().x;
    encoder << instance.point().y;
}

std::optional<Ref<API::Point>> ArgumentCoder<API::Point>::decode(Decoder& decoder)
{
    auto pointx = decoder.decode<double>();
    auto pointy = decoder.decode<double>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        API::Point::create(
            WTFMove(*pointx),
            WTFMove(*pointy)
        )
    };
}

void ArgumentCoder<API::Rect>::encode(Encoder& encoder, const API::Rect& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rect().origin.x)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rect().origin.y)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rect().size.width)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rect().size.height)>, double>);

    encoder << instance.rect().origin.x;
    encoder << instance.rect().origin.y;
    encoder << instance.rect().size.width;
    encoder << instance.rect().size.height;
}

std::optional<Ref<API::Rect>> ArgumentCoder<API::Rect>::decode(Decoder& decoder)
{
    auto rectoriginx = decoder.decode<double>();
    auto rectoriginy = decoder.decode<double>();
    auto rectsizewidth = decoder.decode<double>();
    auto rectsizeheight = decoder.decode<double>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        API::Rect::create(
            WTFMove(*rectoriginx),
            WTFMove(*rectoriginy),
            WTFMove(*rectsizewidth),
            WTFMove(*rectsizeheight)
        )
    };
}

void ArgumentCoder<API::Boolean>::encode(Encoder& encoder, const API::Boolean& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value())>, bool>);

    encoder << instance.value();
}

std::optional<Ref<API::Boolean>> ArgumentCoder<API::Boolean>::decode(Decoder& decoder)
{
    auto value = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        API::Boolean::create(
            WTFMove(*value)
        )
    };
}

void ArgumentCoder<API::Double>::encode(Encoder& encoder, const API::Double& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value())>, double>);

    encoder << instance.value();
}

std::optional<Ref<API::Double>> ArgumentCoder<API::Double>::decode(Decoder& decoder)
{
    auto value = decoder.decode<double>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        API::Double::create(
            WTFMove(*value)
        )
    };
}

void ArgumentCoder<API::UInt64>::encode(Encoder& encoder, const API::UInt64& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value())>, uint64_t>);

    encoder << instance.value();
}

std::optional<Ref<API::UInt64>> ArgumentCoder<API::UInt64>::decode(Decoder& decoder)
{
    auto value = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        API::UInt64::create(
            WTFMove(*value)
        )
    };
}

void ArgumentCoder<API::Int64>::encode(Encoder& encoder, const API::Int64& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value())>, int64_t>);

    encoder << instance.value();
}

std::optional<Ref<API::Int64>> ArgumentCoder<API::Int64>::decode(Decoder& decoder)
{
    auto value = decoder.decode<int64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        API::Int64::create(
            WTFMove(*value)
        )
    };
}

enum class API_Object_Subclass : IPC::EncodedVariantIndex {
    Array
    , Boolean
    , Data
    , Dictionary
    , Double
    , Error
    , FrameHandle
    , WebImage
    , PageHandle
    , Point
    , Rect
    , Size
    , String
    , URL
    , URLRequest
    , URLResponse
    , UInt64
    , Int64
    , UserContentURLPattern
};

IGNORE_WARNINGS_BEGIN("missing-noreturn")
void ArgumentCoder<API::Object>::encode(Encoder& encoder, const API::Object& instance)
{
    if (auto* subclass = dynamicDowncast<API::Array>(instance)) {
        encoder << API_Object_Subclass::Array;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<API::Boolean>(instance)) {
        encoder << API_Object_Subclass::Boolean;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<API::Data>(instance)) {
        encoder << API_Object_Subclass::Data;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<API::Dictionary>(instance)) {
        encoder << API_Object_Subclass::Dictionary;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<API::Double>(instance)) {
        encoder << API_Object_Subclass::Double;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<API::Error>(instance)) {
        encoder << API_Object_Subclass::Error;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<API::FrameHandle>(instance)) {
        encoder << API_Object_Subclass::FrameHandle;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<WebKit::WebImage>(instance)) {
        encoder << API_Object_Subclass::WebImage;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<API::PageHandle>(instance)) {
        encoder << API_Object_Subclass::PageHandle;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<API::Point>(instance)) {
        encoder << API_Object_Subclass::Point;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<API::Rect>(instance)) {
        encoder << API_Object_Subclass::Rect;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<API::Size>(instance)) {
        encoder << API_Object_Subclass::Size;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<API::String>(instance)) {
        encoder << API_Object_Subclass::String;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<API::URL>(instance)) {
        encoder << API_Object_Subclass::URL;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<API::URLRequest>(instance)) {
        encoder << API_Object_Subclass::URLRequest;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<API::URLResponse>(instance)) {
        encoder << API_Object_Subclass::URLResponse;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<API::UInt64>(instance)) {
        encoder << API_Object_Subclass::UInt64;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<API::Int64>(instance)) {
        encoder << API_Object_Subclass::Int64;
        encoder << *subclass;
        return;
    }
    if (auto* subclass = dynamicDowncast<API::UserContentURLPattern>(instance)) {
        encoder << API_Object_Subclass::UserContentURLPattern;
        encoder << *subclass;
        return;
    }
    ASSERT_NOT_REACHED();
}
IGNORE_WARNINGS_END

std::optional<Ref<API::Object>> ArgumentCoder<API::Object>::decode(Decoder& decoder)
{
    auto type = decoder.decode<API_Object_Subclass>();
    UNUSED_PARAM(type);
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (type == API_Object_Subclass::Array) {
        auto result = decoder.decode<Ref<API::Array>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == API_Object_Subclass::Boolean) {
        auto result = decoder.decode<Ref<API::Boolean>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == API_Object_Subclass::Data) {
        auto result = decoder.decode<Ref<API::Data>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == API_Object_Subclass::Dictionary) {
        auto result = decoder.decode<Ref<API::Dictionary>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == API_Object_Subclass::Double) {
        auto result = decoder.decode<Ref<API::Double>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == API_Object_Subclass::Error) {
        auto result = decoder.decode<Ref<API::Error>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == API_Object_Subclass::FrameHandle) {
        auto result = decoder.decode<Ref<API::FrameHandle>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == API_Object_Subclass::WebImage) {
        auto result = decoder.decode<Ref<WebKit::WebImage>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == API_Object_Subclass::PageHandle) {
        auto result = decoder.decode<Ref<API::PageHandle>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == API_Object_Subclass::Point) {
        auto result = decoder.decode<Ref<API::Point>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == API_Object_Subclass::Rect) {
        auto result = decoder.decode<Ref<API::Rect>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == API_Object_Subclass::Size) {
        auto result = decoder.decode<Ref<API::Size>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == API_Object_Subclass::String) {
        auto result = decoder.decode<Ref<API::String>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == API_Object_Subclass::URL) {
        auto result = decoder.decode<Ref<API::URL>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == API_Object_Subclass::URLRequest) {
        auto result = decoder.decode<Ref<API::URLRequest>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == API_Object_Subclass::URLResponse) {
        auto result = decoder.decode<Ref<API::URLResponse>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == API_Object_Subclass::UInt64) {
        auto result = decoder.decode<Ref<API::UInt64>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == API_Object_Subclass::Int64) {
        auto result = decoder.decode<Ref<API::Int64>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    if (type == API_Object_Subclass::UserContentURLPattern) {
        auto result = decoder.decode<Ref<API::UserContentURLPattern>>();
        if (!decoder.isValid()) [[unlikely]]
            return std::nullopt;
        return WTFMove(*result);
    }
    ASSERT_NOT_REACHED();
    return std::nullopt;
}

void ArgumentCoder<API::PageHandle>::encode(Encoder& encoder, const API::PageHandle& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pageProxyID())>, WebKit::WebPageProxyIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webPageID())>, WebCore::PageIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isAutoconverting())>, bool>);

    encoder << instance.pageProxyID();
    encoder << instance.webPageID();
    encoder << instance.isAutoconverting();
}

std::optional<Ref<API::PageHandle>> ArgumentCoder<API::PageHandle>::decode(Decoder& decoder)
{
    auto pageProxyID = decoder.decode<WebKit::WebPageProxyIdentifier>();
    auto webPageID = decoder.decode<WebCore::PageIdentifier>();
    auto isAutoconverting = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        API::PageHandle::create(
            WTFMove(*pageProxyID),
            WTFMove(*webPageID),
            WTFMove(*isAutoconverting)
        )
    };
}

void ArgumentCoder<API::String>::encode(Encoder& encoder, const API::String& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.string())>, String>);

    encoder << instance.string();
}

std::optional<Ref<API::String>> ArgumentCoder<API::String>::decode(Decoder& decoder)
{
    auto string = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        API::String::create(
            WTFMove(*string)
        )
    };
}

void ArgumentCoder<API::URL>::encode(Encoder& encoder, const API::URL& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.string())>, String>);

    encoder << instance.string();
}

std::optional<Ref<API::URL>> ArgumentCoder<API::URL>::decode(Decoder& decoder)
{
    auto string = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        API::URL::create(
            WTFMove(*string)
        )
    };
}

void ArgumentCoder<API::URLRequest>::encode(Encoder& encoder, const API::URLRequest& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.resourceRequest())>, WebCore::ResourceRequest>);

    encoder << instance.resourceRequest();
}

std::optional<Ref<API::URLRequest>> ArgumentCoder<API::URLRequest>::decode(Decoder& decoder)
{
    auto resourceRequest = decoder.decode<WebCore::ResourceRequest>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        API::URLRequest::create(
            WTFMove(*resourceRequest)
        )
    };
}

void ArgumentCoder<API::URLResponse>::encode(Encoder& encoder, const API::URLResponse& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.resourceResponse())>, WebCore::ResourceResponse>);

    encoder << instance.resourceResponse();
}

std::optional<Ref<API::URLResponse>> ArgumentCoder<API::URLResponse>::decode(Decoder& decoder)
{
    auto resourceResponse = decoder.decode<WebCore::ResourceResponse>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        API::URLResponse::create(
            WTFMove(*resourceResponse)
        )
    };
}

void ArgumentCoder<API::UserContentURLPattern>::encode(Encoder& encoder, const API::UserContentURLPattern& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.patternString())>, String>);

    encoder << instance.patternString();
}

std::optional<Ref<API::UserContentURLPattern>> ArgumentCoder<API::UserContentURLPattern>::decode(Decoder& decoder)
{
    auto patternString = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        API::UserContentURLPattern::create(
            WTFMove(*patternString)
        )
    };
}

void ArgumentCoder<WebKit::WebIDBResult>::encode(Encoder& encoder, WebKit::WebIDBResult&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_resultData)>, WebCore::IDBResultData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.m_handles)>, Vector<WebKit::SandboxExtensionHandle>>);
    struct ShouldBeSameSizeAsWebIDBResult : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebIDBResult>, false> {
        WebCore::IDBResultData m_resultData;
        Vector<WebKit::SandboxExtensionHandle> m_handles;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebIDBResult) == sizeof(WebKit::WebIDBResult));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebIDBResult, m_resultData)
        , offsetof(WebKit::WebIDBResult, m_handles)
    >::value);

    encoder << WTFMove(instance.m_resultData);
    encoder << WTFMove(instance.m_handles);
}

std::optional<WebKit::WebIDBResult> ArgumentCoder<WebKit::WebIDBResult>::decode(Decoder& decoder)
{
    auto m_resultData = decoder.decode<WebCore::IDBResultData>();
    auto m_handles = decoder.decode<Vector<WebKit::SandboxExtensionHandle>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebIDBResult {
            WTFMove(*m_resultData),
            WTFMove(*m_handles)
        }
    };
}

#if ENABLE(WK_WEB_EXTENSIONS)
void ArgumentCoder<WebKit::WebExtensionAlarmParameters>::encode(Encoder& encoder, const WebKit::WebExtensionAlarmParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.initialInterval)>, Seconds>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.repeatInterval)>, Seconds>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.nextScheduledTime)>, MonotonicTime>);
    struct ShouldBeSameSizeAsWebExtensionAlarmParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebExtensionAlarmParameters>, false> {
        String name;
        Seconds initialInterval;
        Seconds repeatInterval;
        MonotonicTime nextScheduledTime;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebExtensionAlarmParameters) == sizeof(WebKit::WebExtensionAlarmParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebExtensionAlarmParameters, name)
        , offsetof(WebKit::WebExtensionAlarmParameters, initialInterval)
        , offsetof(WebKit::WebExtensionAlarmParameters, repeatInterval)
        , offsetof(WebKit::WebExtensionAlarmParameters, nextScheduledTime)
    >::value);

    encoder << instance.name;
    encoder << instance.initialInterval;
    encoder << instance.repeatInterval;
    encoder << instance.nextScheduledTime;
}

std::optional<WebKit::WebExtensionAlarmParameters> ArgumentCoder<WebKit::WebExtensionAlarmParameters>::decode(Decoder& decoder)
{
    auto name = decoder.decode<String>();
    auto initialInterval = decoder.decode<Seconds>();
    auto repeatInterval = decoder.decode<Seconds>();
    auto nextScheduledTime = decoder.decode<MonotonicTime>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebExtensionAlarmParameters {
            WTFMove(*name),
            WTFMove(*initialInterval),
            WTFMove(*repeatInterval),
            WTFMove(*nextScheduledTime)
        }
    };
}

#endif

#if ENABLE(WK_WEB_EXTENSIONS_BOOKMARKS)
void ArgumentCoder<WebKit::WebExtensionBookmarksParameters>::encode(Encoder& encoder, const WebKit::WebExtensionBookmarksParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.nodeId)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.parentId)>, std::optional<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.index)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.title)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url)>, std::optional<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.children)>, std::optional<Vector<WebKit::WebExtensionBookmarksParameters>>>);
    struct ShouldBeSameSizeAsWebExtensionBookmarksParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebExtensionBookmarksParameters>, false> {
        String nodeId;
        std::optional<String> parentId;
        uint64_t index;
        String title;
        std::optional<String> url;
        std::optional<Vector<WebKit::WebExtensionBookmarksParameters>> children;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebExtensionBookmarksParameters) == sizeof(WebKit::WebExtensionBookmarksParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebExtensionBookmarksParameters, nodeId)
        , offsetof(WebKit::WebExtensionBookmarksParameters, parentId)
        , offsetof(WebKit::WebExtensionBookmarksParameters, index)
        , offsetof(WebKit::WebExtensionBookmarksParameters, title)
        , offsetof(WebKit::WebExtensionBookmarksParameters, url)
        , offsetof(WebKit::WebExtensionBookmarksParameters, children)
    >::value);

    encoder << instance.nodeId;
    encoder << instance.parentId;
    encoder << instance.index;
    encoder << instance.title;
    encoder << instance.url;
    encoder << instance.children;
}

std::optional<WebKit::WebExtensionBookmarksParameters> ArgumentCoder<WebKit::WebExtensionBookmarksParameters>::decode(Decoder& decoder)
{
    auto nodeId = decoder.decode<String>();
    auto parentId = decoder.decode<std::optional<String>>();
    auto index = decoder.decode<uint64_t>();
    auto title = decoder.decode<String>();
    auto url = decoder.decode<std::optional<String>>();
    auto children = decoder.decode<std::optional<Vector<WebKit::WebExtensionBookmarksParameters>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebExtensionBookmarksParameters {
            WTFMove(*nodeId),
            WTFMove(*parentId),
            WTFMove(*index),
            WTFMove(*title),
            WTFMove(*url),
            WTFMove(*children)
        }
    };
}

#endif

#if ENABLE(WK_WEB_EXTENSIONS)
void ArgumentCoder<WebKit::WebExtensionCommandParameters>::encode(Encoder& encoder, const WebKit::WebExtensionCommandParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.description)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shortcut)>, String>);
    struct ShouldBeSameSizeAsWebExtensionCommandParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebExtensionCommandParameters>, false> {
        String identifier;
        String description;
        String shortcut;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebExtensionCommandParameters) == sizeof(WebKit::WebExtensionCommandParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebExtensionCommandParameters, identifier)
        , offsetof(WebKit::WebExtensionCommandParameters, description)
        , offsetof(WebKit::WebExtensionCommandParameters, shortcut)
    >::value);

    encoder << instance.identifier;
    encoder << instance.description;
    encoder << instance.shortcut;
}

std::optional<WebKit::WebExtensionCommandParameters> ArgumentCoder<WebKit::WebExtensionCommandParameters>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<String>();
    auto description = decoder.decode<String>();
    auto shortcut = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebExtensionCommandParameters {
            WTFMove(*identifier),
            WTFMove(*description),
            WTFMove(*shortcut)
        }
    };
}

#endif

#if ENABLE(WK_WEB_EXTENSIONS)
void ArgumentCoder<WebKit::WebExtensionContextParameters>::encode(Encoder& encoder, const WebKit::WebExtensionContextParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.unprivilegedIdentifier)>, WebKit::WebExtensionContextIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.privilegedIdentifier)>, Markable<WebKit::WebExtensionContextIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.baseURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.uniqueIdentifier)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.unsupportedAPIs)>, HashSet<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.grantedPermissions)>, HashMap<String, WallTime>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.localizationJSON)>, RefPtr<API::Data>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.manifestJSON)>, RefPtr<API::Data>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.manifestVersion)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isSessionStorageAllowedInContentScripts)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.backgroundPageIdentifier)>, std::optional<WebCore::PageIdentifier>>);
#if ENABLE(INSPECTOR_EXTENSIONS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.inspectorPageIdentifiers)>, Vector<WebKit::WebExtensionContext::PageIdentifierTuple>>);
#endif
#if ENABLE(INSPECTOR_EXTENSIONS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.inspectorBackgroundPageIdentifiers)>, Vector<WebKit::WebExtensionContext::PageIdentifierTuple>>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.popupPageIdentifiers)>, Vector<WebKit::WebExtensionContext::PageIdentifierTuple>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tabPageIdentifiers)>, Vector<WebKit::WebExtensionContext::PageIdentifierTuple>>);
    struct ShouldBeSameSizeAsWebExtensionContextParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebExtensionContextParameters>, false> {
        WebKit::WebExtensionContextIdentifier unprivilegedIdentifier;
        Markable<WebKit::WebExtensionContextIdentifier> privilegedIdentifier;
        URL baseURL;
        String uniqueIdentifier;
        HashSet<String> unsupportedAPIs;
        HashMap<String, WallTime> grantedPermissions;
        RefPtr<API::Data> localizationJSON;
        RefPtr<API::Data> manifestJSON;
        double manifestVersion;
        bool isSessionStorageAllowedInContentScripts;
        std::optional<WebCore::PageIdentifier> backgroundPageIdentifier;
#if ENABLE(INSPECTOR_EXTENSIONS)
        Vector<WebKit::WebExtensionContext::PageIdentifierTuple> inspectorPageIdentifiers;
#endif
#if ENABLE(INSPECTOR_EXTENSIONS)
        Vector<WebKit::WebExtensionContext::PageIdentifierTuple> inspectorBackgroundPageIdentifiers;
#endif
        Vector<WebKit::WebExtensionContext::PageIdentifierTuple> popupPageIdentifiers;
        Vector<WebKit::WebExtensionContext::PageIdentifierTuple> tabPageIdentifiers;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebExtensionContextParameters) == sizeof(WebKit::WebExtensionContextParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebExtensionContextParameters, unprivilegedIdentifier)
        , offsetof(WebKit::WebExtensionContextParameters, privilegedIdentifier)
        , offsetof(WebKit::WebExtensionContextParameters, baseURL)
        , offsetof(WebKit::WebExtensionContextParameters, uniqueIdentifier)
        , offsetof(WebKit::WebExtensionContextParameters, unsupportedAPIs)
        , offsetof(WebKit::WebExtensionContextParameters, grantedPermissions)
        , offsetof(WebKit::WebExtensionContextParameters, localizationJSON)
        , offsetof(WebKit::WebExtensionContextParameters, manifestJSON)
        , offsetof(WebKit::WebExtensionContextParameters, manifestVersion)
        , offsetof(WebKit::WebExtensionContextParameters, isSessionStorageAllowedInContentScripts)
        , offsetof(WebKit::WebExtensionContextParameters, backgroundPageIdentifier)
#if ENABLE(INSPECTOR_EXTENSIONS)
        , offsetof(WebKit::WebExtensionContextParameters, inspectorPageIdentifiers)
#endif
#if ENABLE(INSPECTOR_EXTENSIONS)
        , offsetof(WebKit::WebExtensionContextParameters, inspectorBackgroundPageIdentifiers)
#endif
        , offsetof(WebKit::WebExtensionContextParameters, popupPageIdentifiers)
        , offsetof(WebKit::WebExtensionContextParameters, tabPageIdentifiers)
    >::value);

    encoder << instance.unprivilegedIdentifier;
    encoder << instance.privilegedIdentifier;
    encoder << instance.baseURL;
    encoder << instance.uniqueIdentifier;
    encoder << instance.unsupportedAPIs;
    encoder << instance.grantedPermissions;
    encoder << instance.localizationJSON;
    encoder << instance.manifestJSON;
    encoder << instance.manifestVersion;
    encoder << instance.isSessionStorageAllowedInContentScripts;
    encoder << instance.backgroundPageIdentifier;
#if ENABLE(INSPECTOR_EXTENSIONS)
    encoder << instance.inspectorPageIdentifiers;
#endif
#if ENABLE(INSPECTOR_EXTENSIONS)
    encoder << instance.inspectorBackgroundPageIdentifiers;
#endif
    encoder << instance.popupPageIdentifiers;
    encoder << instance.tabPageIdentifiers;
}

std::optional<WebKit::WebExtensionContextParameters> ArgumentCoder<WebKit::WebExtensionContextParameters>::decode(Decoder& decoder)
{
    auto unprivilegedIdentifier = decoder.decode<WebKit::WebExtensionContextIdentifier>();
    auto privilegedIdentifier = decoder.decode<Markable<WebKit::WebExtensionContextIdentifier>>();
    auto baseURL = decoder.decode<URL>();
    auto uniqueIdentifier = decoder.decode<String>();
    auto unsupportedAPIs = decoder.decode<HashSet<String>>();
    auto grantedPermissions = decoder.decode<HashMap<String, WallTime>>();
    auto localizationJSON = decoder.decode<RefPtr<API::Data>>();
    auto manifestJSON = decoder.decode<RefPtr<API::Data>>();
    auto manifestVersion = decoder.decode<double>();
    auto isSessionStorageAllowedInContentScripts = decoder.decode<bool>();
    auto backgroundPageIdentifier = decoder.decode<std::optional<WebCore::PageIdentifier>>();
#if ENABLE(INSPECTOR_EXTENSIONS)
    auto inspectorPageIdentifiers = decoder.decode<Vector<WebKit::WebExtensionContext::PageIdentifierTuple>>();
#endif
#if ENABLE(INSPECTOR_EXTENSIONS)
    auto inspectorBackgroundPageIdentifiers = decoder.decode<Vector<WebKit::WebExtensionContext::PageIdentifierTuple>>();
#endif
    auto popupPageIdentifiers = decoder.decode<Vector<WebKit::WebExtensionContext::PageIdentifierTuple>>();
    auto tabPageIdentifiers = decoder.decode<Vector<WebKit::WebExtensionContext::PageIdentifierTuple>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebExtensionContextParameters {
            WTFMove(*unprivilegedIdentifier),
            WTFMove(*privilegedIdentifier),
            WTFMove(*baseURL),
            WTFMove(*uniqueIdentifier),
            WTFMove(*unsupportedAPIs),
            WTFMove(*grantedPermissions),
            WTFMove(*localizationJSON),
            WTFMove(*manifestJSON),
            WTFMove(*manifestVersion),
            WTFMove(*isSessionStorageAllowedInContentScripts),
            WTFMove(*backgroundPageIdentifier),
#if ENABLE(INSPECTOR_EXTENSIONS)
            WTFMove(*inspectorPageIdentifiers),
#endif
#if ENABLE(INSPECTOR_EXTENSIONS)
            WTFMove(*inspectorBackgroundPageIdentifiers),
#endif
            WTFMove(*popupPageIdentifiers),
            WTFMove(*tabPageIdentifiers)
        }
    };
}

#endif

#if ENABLE(WK_WEB_EXTENSIONS)
void ArgumentCoder<WebKit::WebExtensionControllerParameters>::encode(Encoder& encoder, const WebKit::WebExtensionControllerParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, WebKit::WebExtensionControllerIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.testingMode)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contextParameters)>, Vector<WebKit::WebExtensionContextParameters>>);
    struct ShouldBeSameSizeAsWebExtensionControllerParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebExtensionControllerParameters>, false> {
        WebKit::WebExtensionControllerIdentifier identifier;
        bool testingMode;
        Vector<WebKit::WebExtensionContextParameters> contextParameters;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebExtensionControllerParameters) == sizeof(WebKit::WebExtensionControllerParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebExtensionControllerParameters, identifier)
        , offsetof(WebKit::WebExtensionControllerParameters, testingMode)
        , offsetof(WebKit::WebExtensionControllerParameters, contextParameters)
    >::value);

    encoder << instance.identifier;
    encoder << instance.testingMode;
    encoder << instance.contextParameters;
}

std::optional<WebKit::WebExtensionControllerParameters> ArgumentCoder<WebKit::WebExtensionControllerParameters>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<WebKit::WebExtensionControllerIdentifier>();
    auto testingMode = decoder.decode<bool>();
    auto contextParameters = decoder.decode<Vector<WebKit::WebExtensionContextParameters>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebExtensionControllerParameters {
            WTFMove(*identifier),
            WTFMove(*testingMode),
            WTFMove(*contextParameters)
        }
    };
}

#endif

#if ENABLE(WK_WEB_EXTENSIONS)
void ArgumentCoder<WebKit::WebExtensionCookieParameters>::encode(Encoder& encoder, const WebKit::WebExtensionCookieParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sessionIdentifier)>, std::optional<PAL::SessionID>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cookie)>, WebCore::Cookie>);
    struct ShouldBeSameSizeAsWebExtensionCookieParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebExtensionCookieParameters>, false> {
        std::optional<PAL::SessionID> sessionIdentifier;
        WebCore::Cookie cookie;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebExtensionCookieParameters) == sizeof(WebKit::WebExtensionCookieParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebExtensionCookieParameters, sessionIdentifier)
        , offsetof(WebKit::WebExtensionCookieParameters, cookie)
    >::value);

    encoder << instance.sessionIdentifier;
    encoder << instance.cookie;
}

std::optional<WebKit::WebExtensionCookieParameters> ArgumentCoder<WebKit::WebExtensionCookieParameters>::decode(Decoder& decoder)
{
    auto sessionIdentifier = decoder.decode<std::optional<PAL::SessionID>>();
    auto cookie = decoder.decode<WebCore::Cookie>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebExtensionCookieParameters {
            WTFMove(*sessionIdentifier),
            WTFMove(*cookie)
        }
    };
}

#endif

#if ENABLE(WK_WEB_EXTENSIONS)
void ArgumentCoder<WebKit::WebExtensionCookieFilterParameters>::encode(Encoder& encoder, const WebKit::WebExtensionCookieFilterParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, std::optional<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.domain)>, std::optional<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.path)>, std::optional<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.secure)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.session)>, std::optional<bool>>);
    struct ShouldBeSameSizeAsWebExtensionCookieFilterParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebExtensionCookieFilterParameters>, false> {
        std::optional<String> name;
        std::optional<String> domain;
        std::optional<String> path;
        std::optional<bool> secure;
        std::optional<bool> session;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebExtensionCookieFilterParameters) == sizeof(WebKit::WebExtensionCookieFilterParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebExtensionCookieFilterParameters, name)
        , offsetof(WebKit::WebExtensionCookieFilterParameters, domain)
        , offsetof(WebKit::WebExtensionCookieFilterParameters, path)
        , offsetof(WebKit::WebExtensionCookieFilterParameters, secure)
        , offsetof(WebKit::WebExtensionCookieFilterParameters, session)
    >::value);

    encoder << instance.name;
    encoder << instance.domain;
    encoder << instance.path;
    encoder << instance.secure;
    encoder << instance.session;
}

std::optional<WebKit::WebExtensionCookieFilterParameters> ArgumentCoder<WebKit::WebExtensionCookieFilterParameters>::decode(Decoder& decoder)
{
    auto name = decoder.decode<std::optional<String>>();
    auto domain = decoder.decode<std::optional<String>>();
    auto path = decoder.decode<std::optional<String>>();
    auto secure = decoder.decode<std::optional<bool>>();
    auto session = decoder.decode<std::optional<bool>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebExtensionCookieFilterParameters {
            WTFMove(*name),
            WTFMove(*domain),
            WTFMove(*path),
            WTFMove(*secure),
            WTFMove(*session)
        }
    };
}

#endif

#if ENABLE(WK_WEB_EXTENSIONS)
void ArgumentCoder<WebKit::WebExtensionScriptInjectionParameters>::encode(Encoder& encoder, const WebKit::WebExtensionScriptInjectionParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tabIdentifier)>, std::optional<WebKit::WebExtensionTabIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.arguments)>, std::optional<Ref<API::Data>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.files)>, std::optional<Vector<String>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameIdentifiers)>, std::optional<Vector<WebKit::WebExtensionFrameIdentifier>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.documentIdentifiers)>, std::optional<Vector<WTF::UUID>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.code)>, std::optional<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.css)>, std::optional<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.function)>, std::optional<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.world)>, WebKit::WebExtensionContentWorldType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.styleLevel)>, WebCore::UserStyleLevel>);
    struct ShouldBeSameSizeAsWebExtensionScriptInjectionParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebExtensionScriptInjectionParameters>, false> {
        std::optional<WebKit::WebExtensionTabIdentifier> tabIdentifier;
        std::optional<Ref<API::Data>> arguments;
        std::optional<Vector<String>> files;
        std::optional<Vector<WebKit::WebExtensionFrameIdentifier>> frameIdentifiers;
        std::optional<Vector<WTF::UUID>> documentIdentifiers;
        std::optional<String> code;
        std::optional<String> css;
        std::optional<String> function;
        WebKit::WebExtensionContentWorldType world;
        WebCore::UserStyleLevel styleLevel;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebExtensionScriptInjectionParameters) == sizeof(WebKit::WebExtensionScriptInjectionParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebExtensionScriptInjectionParameters, tabIdentifier)
        , offsetof(WebKit::WebExtensionScriptInjectionParameters, arguments)
        , offsetof(WebKit::WebExtensionScriptInjectionParameters, files)
        , offsetof(WebKit::WebExtensionScriptInjectionParameters, frameIdentifiers)
        , offsetof(WebKit::WebExtensionScriptInjectionParameters, documentIdentifiers)
        , offsetof(WebKit::WebExtensionScriptInjectionParameters, code)
        , offsetof(WebKit::WebExtensionScriptInjectionParameters, css)
        , offsetof(WebKit::WebExtensionScriptInjectionParameters, function)
        , offsetof(WebKit::WebExtensionScriptInjectionParameters, world)
        , offsetof(WebKit::WebExtensionScriptInjectionParameters, styleLevel)
    >::value);

    encoder << instance.tabIdentifier;
    encoder << instance.arguments;
    encoder << instance.files;
    encoder << instance.frameIdentifiers;
    encoder << instance.documentIdentifiers;
    encoder << instance.code;
    encoder << instance.css;
    encoder << instance.function;
    encoder << instance.world;
    encoder << instance.styleLevel;
}

std::optional<WebKit::WebExtensionScriptInjectionParameters> ArgumentCoder<WebKit::WebExtensionScriptInjectionParameters>::decode(Decoder& decoder)
{
    auto tabIdentifier = decoder.decode<std::optional<WebKit::WebExtensionTabIdentifier>>();
    auto arguments = decoder.decode<std::optional<Ref<API::Data>>>();
    auto files = decoder.decode<std::optional<Vector<String>>>();
    auto frameIdentifiers = decoder.decode<std::optional<Vector<WebKit::WebExtensionFrameIdentifier>>>();
    auto documentIdentifiers = decoder.decode<std::optional<Vector<WTF::UUID>>>();
    auto code = decoder.decode<std::optional<String>>();
    auto css = decoder.decode<std::optional<String>>();
    auto function = decoder.decode<std::optional<String>>();
    auto world = decoder.decode<WebKit::WebExtensionContentWorldType>();
    auto styleLevel = decoder.decode<WebCore::UserStyleLevel>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebExtensionScriptInjectionParameters {
            WTFMove(*tabIdentifier),
            WTFMove(*arguments),
            WTFMove(*files),
            WTFMove(*frameIdentifiers),
            WTFMove(*documentIdentifiers),
            WTFMove(*code),
            WTFMove(*css),
            WTFMove(*function),
            WTFMove(*world),
            WTFMove(*styleLevel)
        }
    };
}

#endif

#if ENABLE(WK_WEB_EXTENSIONS)
void ArgumentCoder<WebKit::WebExtensionScriptInjectionResultParameters>::encode(Encoder& encoder, const WebKit::WebExtensionScriptInjectionResultParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.error)>, std::optional<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.resultJSON)>, std::optional<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameIdentifier)>, std::optional<WebKit::WebExtensionFrameIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.documentIdentifier)>, Markable<WTF::UUID>>);
    struct ShouldBeSameSizeAsWebExtensionScriptInjectionResultParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebExtensionScriptInjectionResultParameters>, false> {
        std::optional<String> error;
        std::optional<String> resultJSON;
        std::optional<WebKit::WebExtensionFrameIdentifier> frameIdentifier;
        Markable<WTF::UUID> documentIdentifier;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebExtensionScriptInjectionResultParameters) == sizeof(WebKit::WebExtensionScriptInjectionResultParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebExtensionScriptInjectionResultParameters, error)
        , offsetof(WebKit::WebExtensionScriptInjectionResultParameters, resultJSON)
        , offsetof(WebKit::WebExtensionScriptInjectionResultParameters, frameIdentifier)
        , offsetof(WebKit::WebExtensionScriptInjectionResultParameters, documentIdentifier)
    >::value);

    encoder << instance.error;
    encoder << instance.resultJSON;
    encoder << instance.frameIdentifier;
    encoder << instance.documentIdentifier;
}

std::optional<WebKit::WebExtensionScriptInjectionResultParameters> ArgumentCoder<WebKit::WebExtensionScriptInjectionResultParameters>::decode(Decoder& decoder)
{
    auto error = decoder.decode<std::optional<String>>();
    auto resultJSON = decoder.decode<std::optional<String>>();
    auto frameIdentifier = decoder.decode<std::optional<WebKit::WebExtensionFrameIdentifier>>();
    auto documentIdentifier = decoder.decode<Markable<WTF::UUID>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebExtensionScriptInjectionResultParameters {
            WTFMove(*error),
            WTFMove(*resultJSON),
            WTFMove(*frameIdentifier),
            WTFMove(*documentIdentifier)
        }
    };
}

#endif

#if ENABLE(WK_WEB_EXTENSIONS)
void ArgumentCoder<WebKit::WebExtensionRegisteredScriptParameters>::encode(Encoder& encoder, const WebKit::WebExtensionRegisteredScriptParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.css)>, std::optional<Vector<String>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.js)>, std::optional<Vector<String>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.injectionTime)>, std::optional<WebKit::WebExtension::InjectionTime>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.excludeMatchPatterns)>, std::optional<Vector<String>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.matchPatterns)>, std::optional<Vector<String>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allFrames)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.matchParentFrame)>, std::optional<WebCore::UserContentMatchParentFrame>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.persistent)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.world)>, std::optional<WebKit::WebExtensionContentWorldType>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.styleLevel)>, std::optional<WebCore::UserStyleLevel>>);
    struct ShouldBeSameSizeAsWebExtensionRegisteredScriptParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebExtensionRegisteredScriptParameters>, false> {
        std::optional<Vector<String>> css;
        std::optional<Vector<String>> js;
        String identifier;
        std::optional<WebKit::WebExtension::InjectionTime> injectionTime;
        std::optional<Vector<String>> excludeMatchPatterns;
        std::optional<Vector<String>> matchPatterns;
        std::optional<bool> allFrames;
        std::optional<WebCore::UserContentMatchParentFrame> matchParentFrame;
        std::optional<bool> persistent;
        std::optional<WebKit::WebExtensionContentWorldType> world;
        std::optional<WebCore::UserStyleLevel> styleLevel;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebExtensionRegisteredScriptParameters) == sizeof(WebKit::WebExtensionRegisteredScriptParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebExtensionRegisteredScriptParameters, css)
        , offsetof(WebKit::WebExtensionRegisteredScriptParameters, js)
        , offsetof(WebKit::WebExtensionRegisteredScriptParameters, identifier)
        , offsetof(WebKit::WebExtensionRegisteredScriptParameters, injectionTime)
        , offsetof(WebKit::WebExtensionRegisteredScriptParameters, excludeMatchPatterns)
        , offsetof(WebKit::WebExtensionRegisteredScriptParameters, matchPatterns)
        , offsetof(WebKit::WebExtensionRegisteredScriptParameters, allFrames)
        , offsetof(WebKit::WebExtensionRegisteredScriptParameters, matchParentFrame)
        , offsetof(WebKit::WebExtensionRegisteredScriptParameters, persistent)
        , offsetof(WebKit::WebExtensionRegisteredScriptParameters, world)
        , offsetof(WebKit::WebExtensionRegisteredScriptParameters, styleLevel)
    >::value);

    encoder << instance.css;
    encoder << instance.js;
    encoder << instance.identifier;
    encoder << instance.injectionTime;
    encoder << instance.excludeMatchPatterns;
    encoder << instance.matchPatterns;
    encoder << instance.allFrames;
    encoder << instance.matchParentFrame;
    encoder << instance.persistent;
    encoder << instance.world;
    encoder << instance.styleLevel;
}

std::optional<WebKit::WebExtensionRegisteredScriptParameters> ArgumentCoder<WebKit::WebExtensionRegisteredScriptParameters>::decode(Decoder& decoder)
{
    auto css = decoder.decode<std::optional<Vector<String>>>();
    auto js = decoder.decode<std::optional<Vector<String>>>();
    auto identifier = decoder.decode<String>();
    auto injectionTime = decoder.decode<std::optional<WebKit::WebExtension::InjectionTime>>();
    auto excludeMatchPatterns = decoder.decode<std::optional<Vector<String>>>();
    auto matchPatterns = decoder.decode<std::optional<Vector<String>>>();
    auto allFrames = decoder.decode<std::optional<bool>>();
    auto matchParentFrame = decoder.decode<std::optional<WebCore::UserContentMatchParentFrame>>();
    auto persistent = decoder.decode<std::optional<bool>>();
    auto world = decoder.decode<std::optional<WebKit::WebExtensionContentWorldType>>();
    auto styleLevel = decoder.decode<std::optional<WebCore::UserStyleLevel>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebExtensionRegisteredScriptParameters {
            WTFMove(*css),
            WTFMove(*js),
            WTFMove(*identifier),
            WTFMove(*injectionTime),
            WTFMove(*excludeMatchPatterns),
            WTFMove(*matchPatterns),
            WTFMove(*allFrames),
            WTFMove(*matchParentFrame),
            WTFMove(*persistent),
            WTFMove(*world),
            WTFMove(*styleLevel)
        }
    };
}

#endif

#if ENABLE(WK_WEB_EXTENSIONS)
void ArgumentCoder<WebKit::WebExtensionFrameParameters>::encode(Encoder& encoder, const WebKit::WebExtensionFrameParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.errorOccurred)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url)>, std::optional<URL>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.parentFrameIdentifier)>, WebKit::WebExtensionFrameIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameIdentifier)>, std::optional<WebKit::WebExtensionFrameIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.documentIdentifier)>, Markable<WTF::UUID>>);
    struct ShouldBeSameSizeAsWebExtensionFrameParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebExtensionFrameParameters>, false> {
        bool errorOccurred;
        std::optional<URL> url;
        WebKit::WebExtensionFrameIdentifier parentFrameIdentifier;
        std::optional<WebKit::WebExtensionFrameIdentifier> frameIdentifier;
        Markable<WTF::UUID> documentIdentifier;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebExtensionFrameParameters) == sizeof(WebKit::WebExtensionFrameParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebExtensionFrameParameters, errorOccurred)
        , offsetof(WebKit::WebExtensionFrameParameters, url)
        , offsetof(WebKit::WebExtensionFrameParameters, parentFrameIdentifier)
        , offsetof(WebKit::WebExtensionFrameParameters, frameIdentifier)
        , offsetof(WebKit::WebExtensionFrameParameters, documentIdentifier)
    >::value);

    encoder << instance.errorOccurred;
    encoder << instance.url;
    encoder << instance.parentFrameIdentifier;
    encoder << instance.frameIdentifier;
    encoder << instance.documentIdentifier;
}

std::optional<WebKit::WebExtensionFrameParameters> ArgumentCoder<WebKit::WebExtensionFrameParameters>::decode(Decoder& decoder)
{
    auto errorOccurred = decoder.decode<bool>();
    auto url = decoder.decode<std::optional<URL>>();
    auto parentFrameIdentifier = decoder.decode<WebKit::WebExtensionFrameIdentifier>();
    auto frameIdentifier = decoder.decode<std::optional<WebKit::WebExtensionFrameIdentifier>>();
    auto documentIdentifier = decoder.decode<Markable<WTF::UUID>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebExtensionFrameParameters {
            WTFMove(*errorOccurred),
            WTFMove(*url),
            WTFMove(*parentFrameIdentifier),
            WTFMove(*frameIdentifier),
            WTFMove(*documentIdentifier)
        }
    };
}

#endif

#if ENABLE(WK_WEB_EXTENSIONS)
void ArgumentCoder<WebKit::WebExtensionMatchedRuleParameters>::encode(Encoder& encoder, const WebKit::WebExtensionMatchedRuleParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timeStamp)>, WallTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tabIdentifier)>, WebKit::WebExtensionTabIdentifier>);
    struct ShouldBeSameSizeAsWebExtensionMatchedRuleParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebExtensionMatchedRuleParameters>, false> {
        URL url;
        WallTime timeStamp;
        WebKit::WebExtensionTabIdentifier tabIdentifier;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebExtensionMatchedRuleParameters) == sizeof(WebKit::WebExtensionMatchedRuleParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebExtensionMatchedRuleParameters, url)
        , offsetof(WebKit::WebExtensionMatchedRuleParameters, timeStamp)
        , offsetof(WebKit::WebExtensionMatchedRuleParameters, tabIdentifier)
    >::value);

    encoder << instance.url;
    encoder << instance.timeStamp;
    encoder << instance.tabIdentifier;
}

std::optional<WebKit::WebExtensionMatchedRuleParameters> ArgumentCoder<WebKit::WebExtensionMatchedRuleParameters>::decode(Decoder& decoder)
{
    auto url = decoder.decode<URL>();
    auto timeStamp = decoder.decode<WallTime>();
    auto tabIdentifier = decoder.decode<WebKit::WebExtensionTabIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebExtensionMatchedRuleParameters {
            WTFMove(*url),
            WTFMove(*timeStamp),
            WTFMove(*tabIdentifier)
        }
    };
}

#endif

#if ENABLE(WK_WEB_EXTENSIONS)
void ArgumentCoder<WebKit::WebExtensionMenuItemParameters>::encode(Encoder& encoder, const WebKit::WebExtensionMenuItemParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.parentIdentifier)>, std::optional<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, std::optional<WebKit::WebExtensionMenuItemType>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.title)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.command)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.iconsJSON)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.checked)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.enabled)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.visible)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.documentURLPatterns)>, std::optional<Vector<String>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.targetURLPatterns)>, std::optional<Vector<String>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contexts)>, std::optional<OptionSet<WebKit::WebExtensionMenuItemContextType>>>);
    struct ShouldBeSameSizeAsWebExtensionMenuItemParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebExtensionMenuItemParameters>, false> {
        String identifier;
        std::optional<String> parentIdentifier;
        std::optional<WebKit::WebExtensionMenuItemType> type;
        String title;
        String command;
        String iconsJSON;
        std::optional<bool> checked;
        std::optional<bool> enabled;
        std::optional<bool> visible;
        std::optional<Vector<String>> documentURLPatterns;
        std::optional<Vector<String>> targetURLPatterns;
        std::optional<OptionSet<WebKit::WebExtensionMenuItemContextType>> contexts;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebExtensionMenuItemParameters) == sizeof(WebKit::WebExtensionMenuItemParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebExtensionMenuItemParameters, identifier)
        , offsetof(WebKit::WebExtensionMenuItemParameters, parentIdentifier)
        , offsetof(WebKit::WebExtensionMenuItemParameters, type)
        , offsetof(WebKit::WebExtensionMenuItemParameters, title)
        , offsetof(WebKit::WebExtensionMenuItemParameters, command)
        , offsetof(WebKit::WebExtensionMenuItemParameters, iconsJSON)
        , offsetof(WebKit::WebExtensionMenuItemParameters, checked)
        , offsetof(WebKit::WebExtensionMenuItemParameters, enabled)
        , offsetof(WebKit::WebExtensionMenuItemParameters, visible)
        , offsetof(WebKit::WebExtensionMenuItemParameters, documentURLPatterns)
        , offsetof(WebKit::WebExtensionMenuItemParameters, targetURLPatterns)
        , offsetof(WebKit::WebExtensionMenuItemParameters, contexts)
    >::value);

    encoder << instance.identifier;
    encoder << instance.parentIdentifier;
    encoder << instance.type;
    encoder << instance.title;
    encoder << instance.command;
    encoder << instance.iconsJSON;
    encoder << instance.checked;
    encoder << instance.enabled;
    encoder << instance.visible;
    encoder << instance.documentURLPatterns;
    encoder << instance.targetURLPatterns;
    encoder << instance.contexts;
}

std::optional<WebKit::WebExtensionMenuItemParameters> ArgumentCoder<WebKit::WebExtensionMenuItemParameters>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<String>();
    auto parentIdentifier = decoder.decode<std::optional<String>>();
    auto type = decoder.decode<std::optional<WebKit::WebExtensionMenuItemType>>();
    auto title = decoder.decode<String>();
    auto command = decoder.decode<String>();
    auto iconsJSON = decoder.decode<String>();
    auto checked = decoder.decode<std::optional<bool>>();
    auto enabled = decoder.decode<std::optional<bool>>();
    auto visible = decoder.decode<std::optional<bool>>();
    auto documentURLPatterns = decoder.decode<std::optional<Vector<String>>>();
    auto targetURLPatterns = decoder.decode<std::optional<Vector<String>>>();
    auto contexts = decoder.decode<std::optional<OptionSet<WebKit::WebExtensionMenuItemContextType>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebExtensionMenuItemParameters {
            WTFMove(*identifier),
            WTFMove(*parentIdentifier),
            WTFMove(*type),
            WTFMove(*title),
            WTFMove(*command),
            WTFMove(*iconsJSON),
            WTFMove(*checked),
            WTFMove(*enabled),
            WTFMove(*visible),
            WTFMove(*documentURLPatterns),
            WTFMove(*targetURLPatterns),
            WTFMove(*contexts)
        }
    };
}

#endif

#if ENABLE(WK_WEB_EXTENSIONS)
void ArgumentCoder<WebKit::WebExtensionMenuItemContextParameters>::encode(Encoder& encoder, const WebKit::WebExtensionMenuItemContextParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.types)>, OptionSet<WebKit::WebExtensionMenuItemContextType>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tabIdentifier)>, std::optional<WebKit::WebExtensionTabIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameIdentifier)>, std::optional<WebKit::WebExtensionFrameIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.linkText)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.linkURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sourceURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selectionString)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.editable)>, bool>);
    struct ShouldBeSameSizeAsWebExtensionMenuItemContextParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebExtensionMenuItemContextParameters>, false> {
        OptionSet<WebKit::WebExtensionMenuItemContextType> types;
        std::optional<WebKit::WebExtensionTabIdentifier> tabIdentifier;
        std::optional<WebKit::WebExtensionFrameIdentifier> frameIdentifier;
        URL frameURL;
        String linkText;
        URL linkURL;
        URL sourceURL;
        String selectionString;
        bool editable;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebExtensionMenuItemContextParameters) == sizeof(WebKit::WebExtensionMenuItemContextParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebExtensionMenuItemContextParameters, types)
        , offsetof(WebKit::WebExtensionMenuItemContextParameters, tabIdentifier)
        , offsetof(WebKit::WebExtensionMenuItemContextParameters, frameIdentifier)
        , offsetof(WebKit::WebExtensionMenuItemContextParameters, frameURL)
        , offsetof(WebKit::WebExtensionMenuItemContextParameters, linkText)
        , offsetof(WebKit::WebExtensionMenuItemContextParameters, linkURL)
        , offsetof(WebKit::WebExtensionMenuItemContextParameters, sourceURL)
        , offsetof(WebKit::WebExtensionMenuItemContextParameters, selectionString)
        , offsetof(WebKit::WebExtensionMenuItemContextParameters, editable)
    >::value);

    encoder << instance.types;
    encoder << instance.tabIdentifier;
    encoder << instance.frameIdentifier;
    encoder << instance.frameURL;
    encoder << instance.linkText;
    encoder << instance.linkURL;
    encoder << instance.sourceURL;
    encoder << instance.selectionString;
    encoder << instance.editable;
}

std::optional<WebKit::WebExtensionMenuItemContextParameters> ArgumentCoder<WebKit::WebExtensionMenuItemContextParameters>::decode(Decoder& decoder)
{
    auto types = decoder.decode<OptionSet<WebKit::WebExtensionMenuItemContextType>>();
    auto tabIdentifier = decoder.decode<std::optional<WebKit::WebExtensionTabIdentifier>>();
    auto frameIdentifier = decoder.decode<std::optional<WebKit::WebExtensionFrameIdentifier>>();
    auto frameURL = decoder.decode<URL>();
    auto linkText = decoder.decode<String>();
    auto linkURL = decoder.decode<URL>();
    auto sourceURL = decoder.decode<URL>();
    auto selectionString = decoder.decode<String>();
    auto editable = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebExtensionMenuItemContextParameters {
            WTFMove(*types),
            WTFMove(*tabIdentifier),
            WTFMove(*frameIdentifier),
            WTFMove(*frameURL),
            WTFMove(*linkText),
            WTFMove(*linkURL),
            WTFMove(*sourceURL),
            WTFMove(*selectionString),
            WTFMove(*editable)
        }
    };
}

#endif

#if ENABLE(WK_WEB_EXTENSIONS)
void ArgumentCoder<WebKit::WebExtensionMessageSenderParameters>::encode(Encoder& encoder, const WebKit::WebExtensionMessageSenderParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.extensionUniqueIdentifier)>, std::optional<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tabParameters)>, std::optional<WebKit::WebExtensionTabParameters>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameIdentifier)>, std::optional<WebKit::WebExtensionFrameIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pageProxyIdentifier)>, WebKit::WebPageProxyIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentWorldType)>, WebKit::WebExtensionContentWorldType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.documentIdentifier)>, WTF::UUID>);
    struct ShouldBeSameSizeAsWebExtensionMessageSenderParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebExtensionMessageSenderParameters>, false> {
        std::optional<String> extensionUniqueIdentifier;
        std::optional<WebKit::WebExtensionTabParameters> tabParameters;
        std::optional<WebKit::WebExtensionFrameIdentifier> frameIdentifier;
        WebKit::WebPageProxyIdentifier pageProxyIdentifier;
        WebKit::WebExtensionContentWorldType contentWorldType;
        URL url;
        WTF::UUID documentIdentifier;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebExtensionMessageSenderParameters) == sizeof(WebKit::WebExtensionMessageSenderParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebExtensionMessageSenderParameters, extensionUniqueIdentifier)
        , offsetof(WebKit::WebExtensionMessageSenderParameters, tabParameters)
        , offsetof(WebKit::WebExtensionMessageSenderParameters, frameIdentifier)
        , offsetof(WebKit::WebExtensionMessageSenderParameters, pageProxyIdentifier)
        , offsetof(WebKit::WebExtensionMessageSenderParameters, contentWorldType)
        , offsetof(WebKit::WebExtensionMessageSenderParameters, url)
        , offsetof(WebKit::WebExtensionMessageSenderParameters, documentIdentifier)
    >::value);

    encoder << instance.extensionUniqueIdentifier;
    encoder << instance.tabParameters;
    encoder << instance.frameIdentifier;
    encoder << instance.pageProxyIdentifier;
    encoder << instance.contentWorldType;
    encoder << instance.url;
    encoder << instance.documentIdentifier;
}

std::optional<WebKit::WebExtensionMessageSenderParameters> ArgumentCoder<WebKit::WebExtensionMessageSenderParameters>::decode(Decoder& decoder)
{
    auto extensionUniqueIdentifier = decoder.decode<std::optional<String>>();
    auto tabParameters = decoder.decode<std::optional<WebKit::WebExtensionTabParameters>>();
    auto frameIdentifier = decoder.decode<std::optional<WebKit::WebExtensionFrameIdentifier>>();
    auto pageProxyIdentifier = decoder.decode<WebKit::WebPageProxyIdentifier>();
    auto contentWorldType = decoder.decode<WebKit::WebExtensionContentWorldType>();
    auto url = decoder.decode<URL>();
    auto documentIdentifier = decoder.decode<WTF::UUID>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebExtensionMessageSenderParameters {
            WTFMove(*extensionUniqueIdentifier),
            WTFMove(*tabParameters),
            WTFMove(*frameIdentifier),
            WTFMove(*pageProxyIdentifier),
            WTFMove(*contentWorldType),
            WTFMove(*url),
            WTFMove(*documentIdentifier)
        }
    };
}

#endif

#if ENABLE(WK_WEB_EXTENSIONS)
void ArgumentCoder<WebKit::WebExtensionMessageTargetParameters>::encode(Encoder& encoder, const WebKit::WebExtensionMessageTargetParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pageProxyIdentifier)>, std::optional<WebKit::WebPageProxyIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameIdentifier)>, std::optional<WebKit::WebExtensionFrameIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.documentIdentifier)>, Markable<WTF::UUID>>);
    struct ShouldBeSameSizeAsWebExtensionMessageTargetParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebExtensionMessageTargetParameters>, false> {
        std::optional<WebKit::WebPageProxyIdentifier> pageProxyIdentifier;
        std::optional<WebKit::WebExtensionFrameIdentifier> frameIdentifier;
        Markable<WTF::UUID> documentIdentifier;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebExtensionMessageTargetParameters) == sizeof(WebKit::WebExtensionMessageTargetParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebExtensionMessageTargetParameters, pageProxyIdentifier)
        , offsetof(WebKit::WebExtensionMessageTargetParameters, frameIdentifier)
        , offsetof(WebKit::WebExtensionMessageTargetParameters, documentIdentifier)
    >::value);

    encoder << instance.pageProxyIdentifier;
    encoder << instance.frameIdentifier;
    encoder << instance.documentIdentifier;
}

std::optional<WebKit::WebExtensionMessageTargetParameters> ArgumentCoder<WebKit::WebExtensionMessageTargetParameters>::decode(Decoder& decoder)
{
    auto pageProxyIdentifier = decoder.decode<std::optional<WebKit::WebPageProxyIdentifier>>();
    auto frameIdentifier = decoder.decode<std::optional<WebKit::WebExtensionFrameIdentifier>>();
    auto documentIdentifier = decoder.decode<Markable<WTF::UUID>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebExtensionMessageTargetParameters {
            WTFMove(*pageProxyIdentifier),
            WTFMove(*frameIdentifier),
            WTFMove(*documentIdentifier)
        }
    };
}

#endif

#if ENABLE(WK_WEB_EXTENSIONS_SIDEBAR)
void ArgumentCoder<WebKit::WebExtensionSidebarParameters>::encode(Encoder& encoder, const WebKit::WebExtensionSidebarParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.enabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.panelPath)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tabIdentifier)>, std::optional<WebKit::WebExtensionTabIdentifier>>);
    struct ShouldBeSameSizeAsWebExtensionSidebarParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebExtensionSidebarParameters>, false> {
        bool enabled;
        String panelPath;
        std::optional<WebKit::WebExtensionTabIdentifier> tabIdentifier;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebExtensionSidebarParameters) == sizeof(WebKit::WebExtensionSidebarParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebExtensionSidebarParameters, enabled)
        , offsetof(WebKit::WebExtensionSidebarParameters, panelPath)
        , offsetof(WebKit::WebExtensionSidebarParameters, tabIdentifier)
    >::value);

    encoder << instance.enabled;
    encoder << instance.panelPath;
    encoder << instance.tabIdentifier;
}

std::optional<WebKit::WebExtensionSidebarParameters> ArgumentCoder<WebKit::WebExtensionSidebarParameters>::decode(Decoder& decoder)
{
    auto enabled = decoder.decode<bool>();
    auto panelPath = decoder.decode<String>();
    auto tabIdentifier = decoder.decode<std::optional<WebKit::WebExtensionTabIdentifier>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebExtensionSidebarParameters {
            WTFMove(*enabled),
            WTFMove(*panelPath),
            WTFMove(*tabIdentifier)
        }
    };
}

#endif

#if ENABLE(WK_WEB_EXTENSIONS)
void ArgumentCoder<WebKit::WebExtensionTabParameters>::encode(Encoder& encoder, const WebKit::WebExtensionTabParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, std::optional<WebKit::WebExtensionTabIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url)>, std::optional<URL>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.title)>, std::optional<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.windowIdentifier)>, std::optional<WebKit::WebExtensionWindowIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.index)>, std::optional<uint64_t>>);
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size)>, std::optional<WebKit::DoubleSize>>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.parentTabIdentifier)>, std::optional<WebKit::WebExtensionTabIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.active)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selected)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pinned)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.audible)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.muted)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.loading)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.privateBrowsing)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.readerModeAvailable)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.showingReaderMode)>, std::optional<bool>>);
    struct ShouldBeSameSizeAsWebExtensionTabParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebExtensionTabParameters>, false> {
        std::optional<WebKit::WebExtensionTabIdentifier> identifier;
        std::optional<URL> url;
        std::optional<String> title;
        std::optional<WebKit::WebExtensionWindowIdentifier> windowIdentifier;
        std::optional<uint64_t> index;
#if PLATFORM(COCOA)
        std::optional<WebKit::DoubleSize> size;
#endif
        std::optional<WebKit::WebExtensionTabIdentifier> parentTabIdentifier;
        std::optional<bool> active;
        std::optional<bool> selected;
        std::optional<bool> pinned;
        std::optional<bool> audible;
        std::optional<bool> muted;
        std::optional<bool> loading;
        std::optional<bool> privateBrowsing;
        std::optional<bool> readerModeAvailable;
        std::optional<bool> showingReaderMode;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebExtensionTabParameters) == sizeof(WebKit::WebExtensionTabParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebExtensionTabParameters, identifier)
        , offsetof(WebKit::WebExtensionTabParameters, url)
        , offsetof(WebKit::WebExtensionTabParameters, title)
        , offsetof(WebKit::WebExtensionTabParameters, windowIdentifier)
        , offsetof(WebKit::WebExtensionTabParameters, index)
#if PLATFORM(COCOA)
        , offsetof(WebKit::WebExtensionTabParameters, size)
#endif
        , offsetof(WebKit::WebExtensionTabParameters, parentTabIdentifier)
        , offsetof(WebKit::WebExtensionTabParameters, active)
        , offsetof(WebKit::WebExtensionTabParameters, selected)
        , offsetof(WebKit::WebExtensionTabParameters, pinned)
        , offsetof(WebKit::WebExtensionTabParameters, audible)
        , offsetof(WebKit::WebExtensionTabParameters, muted)
        , offsetof(WebKit::WebExtensionTabParameters, loading)
        , offsetof(WebKit::WebExtensionTabParameters, privateBrowsing)
        , offsetof(WebKit::WebExtensionTabParameters, readerModeAvailable)
        , offsetof(WebKit::WebExtensionTabParameters, showingReaderMode)
    >::value);

    encoder << instance.identifier;
    encoder << instance.url;
    encoder << instance.title;
    encoder << instance.windowIdentifier;
    encoder << instance.index;
#if PLATFORM(COCOA)
    encoder << instance.size;
#endif
    encoder << instance.parentTabIdentifier;
    encoder << instance.active;
    encoder << instance.selected;
    encoder << instance.pinned;
    encoder << instance.audible;
    encoder << instance.muted;
    encoder << instance.loading;
    encoder << instance.privateBrowsing;
    encoder << instance.readerModeAvailable;
    encoder << instance.showingReaderMode;
}

std::optional<WebKit::WebExtensionTabParameters> ArgumentCoder<WebKit::WebExtensionTabParameters>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<std::optional<WebKit::WebExtensionTabIdentifier>>();
    auto url = decoder.decode<std::optional<URL>>();
    auto title = decoder.decode<std::optional<String>>();
    auto windowIdentifier = decoder.decode<std::optional<WebKit::WebExtensionWindowIdentifier>>();
    auto index = decoder.decode<std::optional<uint64_t>>();
#if PLATFORM(COCOA)
    auto size = decoder.decode<std::optional<WebKit::DoubleSize>>();
#endif
    auto parentTabIdentifier = decoder.decode<std::optional<WebKit::WebExtensionTabIdentifier>>();
    auto active = decoder.decode<std::optional<bool>>();
    auto selected = decoder.decode<std::optional<bool>>();
    auto pinned = decoder.decode<std::optional<bool>>();
    auto audible = decoder.decode<std::optional<bool>>();
    auto muted = decoder.decode<std::optional<bool>>();
    auto loading = decoder.decode<std::optional<bool>>();
    auto privateBrowsing = decoder.decode<std::optional<bool>>();
    auto readerModeAvailable = decoder.decode<std::optional<bool>>();
    auto showingReaderMode = decoder.decode<std::optional<bool>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebExtensionTabParameters {
            WTFMove(*identifier),
            WTFMove(*url),
            WTFMove(*title),
            WTFMove(*windowIdentifier),
            WTFMove(*index),
#if PLATFORM(COCOA)
            WTFMove(*size),
#endif
            WTFMove(*parentTabIdentifier),
            WTFMove(*active),
            WTFMove(*selected),
            WTFMove(*pinned),
            WTFMove(*audible),
            WTFMove(*muted),
            WTFMove(*loading),
            WTFMove(*privateBrowsing),
            WTFMove(*readerModeAvailable),
            WTFMove(*showingReaderMode)
        }
    };
}

#endif

#if ENABLE(WK_WEB_EXTENSIONS)
void ArgumentCoder<WebKit::WebExtensionTabQueryParameters>::encode(Encoder& encoder, const WebKit::WebExtensionTabQueryParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.urlPatterns)>, std::optional<Vector<String>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.titlePattern)>, std::optional<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.windowIdentifier)>, std::optional<WebKit::WebExtensionWindowIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.windowType)>, std::optional<OptionSet<WebKit::WebExtensionWindowTypeFilter>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.currentWindow)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frontmostWindow)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.index)>, std::optional<uint64_t>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.active)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.audible)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hidden)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.loading)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.muted)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pinned)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.selected)>, std::optional<bool>>);
    struct ShouldBeSameSizeAsWebExtensionTabQueryParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebExtensionTabQueryParameters>, false> {
        std::optional<Vector<String>> urlPatterns;
        std::optional<String> titlePattern;
        std::optional<WebKit::WebExtensionWindowIdentifier> windowIdentifier;
        std::optional<OptionSet<WebKit::WebExtensionWindowTypeFilter>> windowType;
        std::optional<bool> currentWindow;
        std::optional<bool> frontmostWindow;
        std::optional<uint64_t> index;
        std::optional<bool> active;
        std::optional<bool> audible;
        std::optional<bool> hidden;
        std::optional<bool> loading;
        std::optional<bool> muted;
        std::optional<bool> pinned;
        std::optional<bool> selected;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebExtensionTabQueryParameters) == sizeof(WebKit::WebExtensionTabQueryParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebExtensionTabQueryParameters, urlPatterns)
        , offsetof(WebKit::WebExtensionTabQueryParameters, titlePattern)
        , offsetof(WebKit::WebExtensionTabQueryParameters, windowIdentifier)
        , offsetof(WebKit::WebExtensionTabQueryParameters, windowType)
        , offsetof(WebKit::WebExtensionTabQueryParameters, currentWindow)
        , offsetof(WebKit::WebExtensionTabQueryParameters, frontmostWindow)
        , offsetof(WebKit::WebExtensionTabQueryParameters, index)
        , offsetof(WebKit::WebExtensionTabQueryParameters, active)
        , offsetof(WebKit::WebExtensionTabQueryParameters, audible)
        , offsetof(WebKit::WebExtensionTabQueryParameters, hidden)
        , offsetof(WebKit::WebExtensionTabQueryParameters, loading)
        , offsetof(WebKit::WebExtensionTabQueryParameters, muted)
        , offsetof(WebKit::WebExtensionTabQueryParameters, pinned)
        , offsetof(WebKit::WebExtensionTabQueryParameters, selected)
    >::value);

    encoder << instance.urlPatterns;
    encoder << instance.titlePattern;
    encoder << instance.windowIdentifier;
    encoder << instance.windowType;
    encoder << instance.currentWindow;
    encoder << instance.frontmostWindow;
    encoder << instance.index;
    encoder << instance.active;
    encoder << instance.audible;
    encoder << instance.hidden;
    encoder << instance.loading;
    encoder << instance.muted;
    encoder << instance.pinned;
    encoder << instance.selected;
}

std::optional<WebKit::WebExtensionTabQueryParameters> ArgumentCoder<WebKit::WebExtensionTabQueryParameters>::decode(Decoder& decoder)
{
    auto urlPatterns = decoder.decode<std::optional<Vector<String>>>();
    auto titlePattern = decoder.decode<std::optional<String>>();
    auto windowIdentifier = decoder.decode<std::optional<WebKit::WebExtensionWindowIdentifier>>();
    auto windowType = decoder.decode<std::optional<OptionSet<WebKit::WebExtensionWindowTypeFilter>>>();
    auto currentWindow = decoder.decode<std::optional<bool>>();
    auto frontmostWindow = decoder.decode<std::optional<bool>>();
    auto index = decoder.decode<std::optional<uint64_t>>();
    auto active = decoder.decode<std::optional<bool>>();
    auto audible = decoder.decode<std::optional<bool>>();
    auto hidden = decoder.decode<std::optional<bool>>();
    auto loading = decoder.decode<std::optional<bool>>();
    auto muted = decoder.decode<std::optional<bool>>();
    auto pinned = decoder.decode<std::optional<bool>>();
    auto selected = decoder.decode<std::optional<bool>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebExtensionTabQueryParameters {
            WTFMove(*urlPatterns),
            WTFMove(*titlePattern),
            WTFMove(*windowIdentifier),
            WTFMove(*windowType),
            WTFMove(*currentWindow),
            WTFMove(*frontmostWindow),
            WTFMove(*index),
            WTFMove(*active),
            WTFMove(*audible),
            WTFMove(*hidden),
            WTFMove(*loading),
            WTFMove(*muted),
            WTFMove(*pinned),
            WTFMove(*selected)
        }
    };
}

#endif

#if ENABLE(WK_WEB_EXTENSIONS)
void ArgumentCoder<WebKit::WebExtensionWindowParameters>::encode(Encoder& encoder, const WebKit::WebExtensionWindowParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, std::optional<WebKit::WebExtensionWindowIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.state)>, std::optional<WebKit::WebExtensionWindow::State>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, std::optional<WebKit::WebExtensionWindow::Type>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tabs)>, std::optional<Vector<WebKit::WebExtensionTabParameters>>>);
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frame)>, std::optional<WebKit::DoubleRect>>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.focused)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.privateBrowsing)>, std::optional<bool>>);
    struct ShouldBeSameSizeAsWebExtensionWindowParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebExtensionWindowParameters>, false> {
        std::optional<WebKit::WebExtensionWindowIdentifier> identifier;
        std::optional<WebKit::WebExtensionWindow::State> state;
        std::optional<WebKit::WebExtensionWindow::Type> type;
        std::optional<Vector<WebKit::WebExtensionTabParameters>> tabs;
#if PLATFORM(COCOA)
        std::optional<WebKit::DoubleRect> frame;
#endif
        std::optional<bool> focused;
        std::optional<bool> privateBrowsing;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebExtensionWindowParameters) == sizeof(WebKit::WebExtensionWindowParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebExtensionWindowParameters, identifier)
        , offsetof(WebKit::WebExtensionWindowParameters, state)
        , offsetof(WebKit::WebExtensionWindowParameters, type)
        , offsetof(WebKit::WebExtensionWindowParameters, tabs)
#if PLATFORM(COCOA)
        , offsetof(WebKit::WebExtensionWindowParameters, frame)
#endif
        , offsetof(WebKit::WebExtensionWindowParameters, focused)
        , offsetof(WebKit::WebExtensionWindowParameters, privateBrowsing)
    >::value);

    encoder << instance.identifier;
    encoder << instance.state;
    encoder << instance.type;
    encoder << instance.tabs;
#if PLATFORM(COCOA)
    encoder << instance.frame;
#endif
    encoder << instance.focused;
    encoder << instance.privateBrowsing;
}

std::optional<WebKit::WebExtensionWindowParameters> ArgumentCoder<WebKit::WebExtensionWindowParameters>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<std::optional<WebKit::WebExtensionWindowIdentifier>>();
    auto state = decoder.decode<std::optional<WebKit::WebExtensionWindow::State>>();
    auto type = decoder.decode<std::optional<WebKit::WebExtensionWindow::Type>>();
    auto tabs = decoder.decode<std::optional<Vector<WebKit::WebExtensionTabParameters>>>();
#if PLATFORM(COCOA)
    auto frame = decoder.decode<std::optional<WebKit::DoubleRect>>();
#endif
    auto focused = decoder.decode<std::optional<bool>>();
    auto privateBrowsing = decoder.decode<std::optional<bool>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebExtensionWindowParameters {
            WTFMove(*identifier),
            WTFMove(*state),
            WTFMove(*type),
            WTFMove(*tabs),
#if PLATFORM(COCOA)
            WTFMove(*frame),
#endif
            WTFMove(*focused),
            WTFMove(*privateBrowsing)
        }
    };
}

#endif

#if ENABLE(GAMEPAD)
void ArgumentCoder<WebKit::GamepadData>::encode(Encoder& encoder, const WebKit::GamepadData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.index())>, unsigned>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.id())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mapping())>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.axisValues())>, Vector<double>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.buttonValues())>, Vector<double>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lastUpdateTime())>, MonotonicTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportedEffectTypes())>, HashSet<WebCore::GamepadHapticEffectType, IntHash<WebCore::GamepadHapticEffectType>, WTF::StrongEnumHashTraits<WebCore::GamepadHapticEffectType>>>);

    encoder << instance.index();
    encoder << instance.id();
    encoder << instance.mapping();
    encoder << instance.axisValues();
    encoder << instance.buttonValues();
    encoder << instance.lastUpdateTime();
    encoder << instance.supportedEffectTypes();
}

std::optional<WebKit::GamepadData> ArgumentCoder<WebKit::GamepadData>::decode(Decoder& decoder)
{
    auto index = decoder.decode<unsigned>();
    auto id = decoder.decode<String>();
    auto mapping = decoder.decode<String>();
    auto axisValues = decoder.decode<Vector<double>>();
    auto buttonValues = decoder.decode<Vector<double>>();
    auto lastUpdateTime = decoder.decode<MonotonicTime>();
    auto supportedEffectTypes = decoder.decode<HashSet<WebCore::GamepadHapticEffectType, IntHash<WebCore::GamepadHapticEffectType>, WTF::StrongEnumHashTraits<WebCore::GamepadHapticEffectType>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::GamepadData {
            WTFMove(*index),
            WTFMove(*id),
            WTFMove(*mapping),
            WTFMove(*axisValues),
            WTFMove(*buttonValues),
            WTFMove(*lastUpdateTime),
            WTFMove(*supportedEffectTypes)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::RemoteImageBufferSetConfiguration>::encode(Encoder& encoder, const WebKit::RemoteImageBufferSetConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.logicalSize)>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.resolutionScale)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorSpace)>, WebCore::DestinationColorSpace>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentsFormat)>, WebCore::ContentsFormat>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bufferFormat)>, WebCore::ImageBufferFormat>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.renderingMode)>, WebCore::RenderingMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.renderingPurpose)>, WebCore::RenderingPurpose>);
#if ENABLE(RE_DYNAMIC_CONTENT_SCALING)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.includeDisplayList)>, WebCore::IncludeDynamicContentScalingDisplayList>);
#endif
    struct ShouldBeSameSizeAsRemoteImageBufferSetConfiguration : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::RemoteImageBufferSetConfiguration>, false> {
        WebCore::FloatSize logicalSize;
        float resolutionScale;
        WebCore::DestinationColorSpace colorSpace;
        WebCore::ContentsFormat contentsFormat;
        WebCore::ImageBufferFormat bufferFormat;
        WebCore::RenderingMode renderingMode;
        WebCore::RenderingPurpose renderingPurpose;
#if ENABLE(RE_DYNAMIC_CONTENT_SCALING)
        WebCore::IncludeDynamicContentScalingDisplayList includeDisplayList;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsRemoteImageBufferSetConfiguration) == sizeof(WebKit::RemoteImageBufferSetConfiguration));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::RemoteImageBufferSetConfiguration, logicalSize)
        , offsetof(WebKit::RemoteImageBufferSetConfiguration, resolutionScale)
        , offsetof(WebKit::RemoteImageBufferSetConfiguration, colorSpace)
        , offsetof(WebKit::RemoteImageBufferSetConfiguration, contentsFormat)
        , offsetof(WebKit::RemoteImageBufferSetConfiguration, bufferFormat)
        , offsetof(WebKit::RemoteImageBufferSetConfiguration, renderingMode)
        , offsetof(WebKit::RemoteImageBufferSetConfiguration, renderingPurpose)
#if ENABLE(RE_DYNAMIC_CONTENT_SCALING)
        , offsetof(WebKit::RemoteImageBufferSetConfiguration, includeDisplayList)
#endif
    >::value);

    encoder << instance.logicalSize;
    encoder << instance.resolutionScale;
    encoder << instance.colorSpace;
    encoder << instance.contentsFormat;
    encoder << instance.bufferFormat;
    encoder << instance.renderingMode;
    encoder << instance.renderingPurpose;
#if ENABLE(RE_DYNAMIC_CONTENT_SCALING)
    encoder << instance.includeDisplayList;
#endif
}

void ArgumentCoder<WebKit::RemoteImageBufferSetConfiguration>::encode(StreamConnectionEncoder& encoder, const WebKit::RemoteImageBufferSetConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.logicalSize)>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.resolutionScale)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorSpace)>, WebCore::DestinationColorSpace>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentsFormat)>, WebCore::ContentsFormat>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bufferFormat)>, WebCore::ImageBufferFormat>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.renderingMode)>, WebCore::RenderingMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.renderingPurpose)>, WebCore::RenderingPurpose>);
#if ENABLE(RE_DYNAMIC_CONTENT_SCALING)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.includeDisplayList)>, WebCore::IncludeDynamicContentScalingDisplayList>);
#endif
    struct ShouldBeSameSizeAsRemoteImageBufferSetConfiguration : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::RemoteImageBufferSetConfiguration>, false> {
        WebCore::FloatSize logicalSize;
        float resolutionScale;
        WebCore::DestinationColorSpace colorSpace;
        WebCore::ContentsFormat contentsFormat;
        WebCore::ImageBufferFormat bufferFormat;
        WebCore::RenderingMode renderingMode;
        WebCore::RenderingPurpose renderingPurpose;
#if ENABLE(RE_DYNAMIC_CONTENT_SCALING)
        WebCore::IncludeDynamicContentScalingDisplayList includeDisplayList;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsRemoteImageBufferSetConfiguration) == sizeof(WebKit::RemoteImageBufferSetConfiguration));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::RemoteImageBufferSetConfiguration, logicalSize)
        , offsetof(WebKit::RemoteImageBufferSetConfiguration, resolutionScale)
        , offsetof(WebKit::RemoteImageBufferSetConfiguration, colorSpace)
        , offsetof(WebKit::RemoteImageBufferSetConfiguration, contentsFormat)
        , offsetof(WebKit::RemoteImageBufferSetConfiguration, bufferFormat)
        , offsetof(WebKit::RemoteImageBufferSetConfiguration, renderingMode)
        , offsetof(WebKit::RemoteImageBufferSetConfiguration, renderingPurpose)
#if ENABLE(RE_DYNAMIC_CONTENT_SCALING)
        , offsetof(WebKit::RemoteImageBufferSetConfiguration, includeDisplayList)
#endif
    >::value);

    encoder << instance.logicalSize;
    encoder << instance.resolutionScale;
    encoder << instance.colorSpace;
    encoder << instance.contentsFormat;
    encoder << instance.bufferFormat;
    encoder << instance.renderingMode;
    encoder << instance.renderingPurpose;
#if ENABLE(RE_DYNAMIC_CONTENT_SCALING)
    encoder << instance.includeDisplayList;
#endif
}

std::optional<WebKit::RemoteImageBufferSetConfiguration> ArgumentCoder<WebKit::RemoteImageBufferSetConfiguration>::decode(Decoder& decoder)
{
    auto logicalSize = decoder.decode<WebCore::FloatSize>();
    auto resolutionScale = decoder.decode<float>();
    auto colorSpace = decoder.decode<WebCore::DestinationColorSpace>();
    auto contentsFormat = decoder.decode<WebCore::ContentsFormat>();
    auto bufferFormat = decoder.decode<WebCore::ImageBufferFormat>();
    auto renderingMode = decoder.decode<WebCore::RenderingMode>();
    auto renderingPurpose = decoder.decode<WebCore::RenderingPurpose>();
#if ENABLE(RE_DYNAMIC_CONTENT_SCALING)
    auto includeDisplayList = decoder.decode<WebCore::IncludeDynamicContentScalingDisplayList>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::RemoteImageBufferSetConfiguration {
            WTFMove(*logicalSize),
            WTFMove(*resolutionScale),
            WTFMove(*colorSpace),
            WTFMove(*contentsFormat),
            WTFMove(*bufferFormat),
            WTFMove(*renderingMode),
            WTFMove(*renderingPurpose),
#if ENABLE(RE_DYNAMIC_CONTENT_SCALING)
            WTFMove(*includeDisplayList)
#endif
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::BindGroupDescriptor>::encode(Encoder& encoder, const WebKit::WebGPU::BindGroupDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bindGroupLayout)>, WebKit::WebGPUIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.entries)>, Vector<WebKit::WebGPU::BindGroupEntry>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::BindGroupDescriptor, bindGroupLayout)
        , offsetof(WebKit::WebGPU::BindGroupDescriptor, entries)
    >::value);

    encoder << instance.label;
    encoder << instance.bindGroupLayout;
    encoder << instance.entries;
}

void ArgumentCoder<WebKit::WebGPU::BindGroupDescriptor>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::BindGroupDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bindGroupLayout)>, WebKit::WebGPUIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.entries)>, Vector<WebKit::WebGPU::BindGroupEntry>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::BindGroupDescriptor, bindGroupLayout)
        , offsetof(WebKit::WebGPU::BindGroupDescriptor, entries)
    >::value);

    encoder << instance.label;
    encoder << instance.bindGroupLayout;
    encoder << instance.entries;
}

std::optional<WebKit::WebGPU::BindGroupDescriptor> ArgumentCoder<WebKit::WebGPU::BindGroupDescriptor>::decode(Decoder& decoder)
{
    auto label = decoder.decode<String>();
    auto bindGroupLayout = decoder.decode<WebKit::WebGPUIdentifier>();
    auto entries = decoder.decode<Vector<WebKit::WebGPU::BindGroupEntry>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::BindGroupDescriptor {
            WebKit::WebGPU::ObjectDescriptorBase {
                WTFMove(*label)
            },
            WTFMove(*bindGroupLayout),
            WTFMove(*entries)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::BindGroupEntry>::encode(Encoder& encoder, const WebKit::WebGPU::BindGroupEntry& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.binding)>, WebCore::WebGPU::Index32>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bufferBinding)>, WebKit::WebGPU::BufferBinding>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, WebKit::WebGPUIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebKit::WebGPU::BindingResourceType>);
    struct ShouldBeSameSizeAsBindGroupEntry : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::BindGroupEntry>, false> {
        WebCore::WebGPU::Index32 binding;
        WebKit::WebGPU::BufferBinding bufferBinding;
        WebKit::WebGPUIdentifier identifier;
        WebKit::WebGPU::BindingResourceType type;
    };
    static_assert(sizeof(ShouldBeSameSizeAsBindGroupEntry) == sizeof(WebKit::WebGPU::BindGroupEntry));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::BindGroupEntry, binding)
        , offsetof(WebKit::WebGPU::BindGroupEntry, bufferBinding)
        , offsetof(WebKit::WebGPU::BindGroupEntry, identifier)
        , offsetof(WebKit::WebGPU::BindGroupEntry, type)
    >::value);

    encoder << instance.binding;
    encoder << instance.bufferBinding;
    encoder << instance.identifier;
    encoder << instance.type;
}

void ArgumentCoder<WebKit::WebGPU::BindGroupEntry>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::BindGroupEntry& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.binding)>, WebCore::WebGPU::Index32>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bufferBinding)>, WebKit::WebGPU::BufferBinding>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, WebKit::WebGPUIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebKit::WebGPU::BindingResourceType>);
    struct ShouldBeSameSizeAsBindGroupEntry : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::BindGroupEntry>, false> {
        WebCore::WebGPU::Index32 binding;
        WebKit::WebGPU::BufferBinding bufferBinding;
        WebKit::WebGPUIdentifier identifier;
        WebKit::WebGPU::BindingResourceType type;
    };
    static_assert(sizeof(ShouldBeSameSizeAsBindGroupEntry) == sizeof(WebKit::WebGPU::BindGroupEntry));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::BindGroupEntry, binding)
        , offsetof(WebKit::WebGPU::BindGroupEntry, bufferBinding)
        , offsetof(WebKit::WebGPU::BindGroupEntry, identifier)
        , offsetof(WebKit::WebGPU::BindGroupEntry, type)
    >::value);

    encoder << instance.binding;
    encoder << instance.bufferBinding;
    encoder << instance.identifier;
    encoder << instance.type;
}

std::optional<WebKit::WebGPU::BindGroupEntry> ArgumentCoder<WebKit::WebGPU::BindGroupEntry>::decode(Decoder& decoder)
{
    auto binding = decoder.decode<WebCore::WebGPU::Index32>();
    auto bufferBinding = decoder.decode<WebKit::WebGPU::BufferBinding>();
    auto identifier = decoder.decode<WebKit::WebGPUIdentifier>();
    auto type = decoder.decode<WebKit::WebGPU::BindingResourceType>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::BindGroupEntry {
            WTFMove(*binding),
            WTFMove(*bufferBinding),
            WTFMove(*identifier),
            WTFMove(*type)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::BindGroupLayoutDescriptor>::encode(Encoder& encoder, const WebKit::WebGPU::BindGroupLayoutDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.entries)>, Vector<WebKit::WebGPU::BindGroupLayoutEntry>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::BindGroupLayoutDescriptor, entries)
    >::value);

    encoder << instance.label;
    encoder << instance.entries;
}

void ArgumentCoder<WebKit::WebGPU::BindGroupLayoutDescriptor>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::BindGroupLayoutDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.entries)>, Vector<WebKit::WebGPU::BindGroupLayoutEntry>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::BindGroupLayoutDescriptor, entries)
    >::value);

    encoder << instance.label;
    encoder << instance.entries;
}

std::optional<WebKit::WebGPU::BindGroupLayoutDescriptor> ArgumentCoder<WebKit::WebGPU::BindGroupLayoutDescriptor>::decode(Decoder& decoder)
{
    auto label = decoder.decode<String>();
    auto entries = decoder.decode<Vector<WebKit::WebGPU::BindGroupLayoutEntry>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::BindGroupLayoutDescriptor {
            WebKit::WebGPU::ObjectDescriptorBase {
                WTFMove(*label)
            },
            WTFMove(*entries)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::BindGroupLayoutEntry>::encode(Encoder& encoder, const WebKit::WebGPU::BindGroupLayoutEntry& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.binding)>, WebCore::WebGPU::Index32>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.visibility)>, WebCore::WebGPU::ShaderStageFlags>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.buffer)>, std::optional<WebKit::WebGPU::BufferBindingLayout>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sampler)>, std::optional<WebKit::WebGPU::SamplerBindingLayout>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.texture)>, std::optional<WebKit::WebGPU::TextureBindingLayout>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.storageTexture)>, std::optional<WebKit::WebGPU::StorageTextureBindingLayout>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.externalTexture)>, std::optional<WebKit::WebGPU::ExternalTextureBindingLayout>>);
    struct ShouldBeSameSizeAsBindGroupLayoutEntry : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::BindGroupLayoutEntry>, false> {
        WebCore::WebGPU::Index32 binding;
        WebCore::WebGPU::ShaderStageFlags visibility;
        std::optional<WebKit::WebGPU::BufferBindingLayout> buffer;
        std::optional<WebKit::WebGPU::SamplerBindingLayout> sampler;
        std::optional<WebKit::WebGPU::TextureBindingLayout> texture;
        std::optional<WebKit::WebGPU::StorageTextureBindingLayout> storageTexture;
        std::optional<WebKit::WebGPU::ExternalTextureBindingLayout> externalTexture;
    };
    static_assert(sizeof(ShouldBeSameSizeAsBindGroupLayoutEntry) == sizeof(WebKit::WebGPU::BindGroupLayoutEntry));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::BindGroupLayoutEntry, binding)
        , offsetof(WebKit::WebGPU::BindGroupLayoutEntry, visibility)
        , offsetof(WebKit::WebGPU::BindGroupLayoutEntry, buffer)
        , offsetof(WebKit::WebGPU::BindGroupLayoutEntry, sampler)
        , offsetof(WebKit::WebGPU::BindGroupLayoutEntry, texture)
        , offsetof(WebKit::WebGPU::BindGroupLayoutEntry, storageTexture)
        , offsetof(WebKit::WebGPU::BindGroupLayoutEntry, externalTexture)
    >::value);

    encoder << instance.binding;
    encoder << instance.visibility;
    encoder << instance.buffer;
    encoder << instance.sampler;
    encoder << instance.texture;
    encoder << instance.storageTexture;
    encoder << instance.externalTexture;
}

void ArgumentCoder<WebKit::WebGPU::BindGroupLayoutEntry>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::BindGroupLayoutEntry& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.binding)>, WebCore::WebGPU::Index32>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.visibility)>, WebCore::WebGPU::ShaderStageFlags>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.buffer)>, std::optional<WebKit::WebGPU::BufferBindingLayout>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sampler)>, std::optional<WebKit::WebGPU::SamplerBindingLayout>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.texture)>, std::optional<WebKit::WebGPU::TextureBindingLayout>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.storageTexture)>, std::optional<WebKit::WebGPU::StorageTextureBindingLayout>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.externalTexture)>, std::optional<WebKit::WebGPU::ExternalTextureBindingLayout>>);
    struct ShouldBeSameSizeAsBindGroupLayoutEntry : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::BindGroupLayoutEntry>, false> {
        WebCore::WebGPU::Index32 binding;
        WebCore::WebGPU::ShaderStageFlags visibility;
        std::optional<WebKit::WebGPU::BufferBindingLayout> buffer;
        std::optional<WebKit::WebGPU::SamplerBindingLayout> sampler;
        std::optional<WebKit::WebGPU::TextureBindingLayout> texture;
        std::optional<WebKit::WebGPU::StorageTextureBindingLayout> storageTexture;
        std::optional<WebKit::WebGPU::ExternalTextureBindingLayout> externalTexture;
    };
    static_assert(sizeof(ShouldBeSameSizeAsBindGroupLayoutEntry) == sizeof(WebKit::WebGPU::BindGroupLayoutEntry));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::BindGroupLayoutEntry, binding)
        , offsetof(WebKit::WebGPU::BindGroupLayoutEntry, visibility)
        , offsetof(WebKit::WebGPU::BindGroupLayoutEntry, buffer)
        , offsetof(WebKit::WebGPU::BindGroupLayoutEntry, sampler)
        , offsetof(WebKit::WebGPU::BindGroupLayoutEntry, texture)
        , offsetof(WebKit::WebGPU::BindGroupLayoutEntry, storageTexture)
        , offsetof(WebKit::WebGPU::BindGroupLayoutEntry, externalTexture)
    >::value);

    encoder << instance.binding;
    encoder << instance.visibility;
    encoder << instance.buffer;
    encoder << instance.sampler;
    encoder << instance.texture;
    encoder << instance.storageTexture;
    encoder << instance.externalTexture;
}

std::optional<WebKit::WebGPU::BindGroupLayoutEntry> ArgumentCoder<WebKit::WebGPU::BindGroupLayoutEntry>::decode(Decoder& decoder)
{
    auto binding = decoder.decode<WebCore::WebGPU::Index32>();
    auto visibility = decoder.decode<WebCore::WebGPU::ShaderStageFlags>();
    auto buffer = decoder.decode<std::optional<WebKit::WebGPU::BufferBindingLayout>>();
    auto sampler = decoder.decode<std::optional<WebKit::WebGPU::SamplerBindingLayout>>();
    auto texture = decoder.decode<std::optional<WebKit::WebGPU::TextureBindingLayout>>();
    auto storageTexture = decoder.decode<std::optional<WebKit::WebGPU::StorageTextureBindingLayout>>();
    auto externalTexture = decoder.decode<std::optional<WebKit::WebGPU::ExternalTextureBindingLayout>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::BindGroupLayoutEntry {
            WTFMove(*binding),
            WTFMove(*visibility),
            WTFMove(*buffer),
            WTFMove(*sampler),
            WTFMove(*texture),
            WTFMove(*storageTexture),
            WTFMove(*externalTexture)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::BlendComponent>::encode(Encoder& encoder, const WebKit::WebGPU::BlendComponent& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operation)>, WebCore::WebGPU::BlendOperation>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.srcFactor)>, WebCore::WebGPU::BlendFactor>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dstFactor)>, WebCore::WebGPU::BlendFactor>);
    struct ShouldBeSameSizeAsBlendComponent : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::BlendComponent>, false> {
        WebCore::WebGPU::BlendOperation operation;
        WebCore::WebGPU::BlendFactor srcFactor;
        WebCore::WebGPU::BlendFactor dstFactor;
    };
    static_assert(sizeof(ShouldBeSameSizeAsBlendComponent) == sizeof(WebKit::WebGPU::BlendComponent));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::BlendComponent, operation)
        , offsetof(WebKit::WebGPU::BlendComponent, srcFactor)
        , offsetof(WebKit::WebGPU::BlendComponent, dstFactor)
    >::value);

    encoder << instance.operation;
    encoder << instance.srcFactor;
    encoder << instance.dstFactor;
}

void ArgumentCoder<WebKit::WebGPU::BlendComponent>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::BlendComponent& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.operation)>, WebCore::WebGPU::BlendOperation>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.srcFactor)>, WebCore::WebGPU::BlendFactor>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dstFactor)>, WebCore::WebGPU::BlendFactor>);
    struct ShouldBeSameSizeAsBlendComponent : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::BlendComponent>, false> {
        WebCore::WebGPU::BlendOperation operation;
        WebCore::WebGPU::BlendFactor srcFactor;
        WebCore::WebGPU::BlendFactor dstFactor;
    };
    static_assert(sizeof(ShouldBeSameSizeAsBlendComponent) == sizeof(WebKit::WebGPU::BlendComponent));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::BlendComponent, operation)
        , offsetof(WebKit::WebGPU::BlendComponent, srcFactor)
        , offsetof(WebKit::WebGPU::BlendComponent, dstFactor)
    >::value);

    encoder << instance.operation;
    encoder << instance.srcFactor;
    encoder << instance.dstFactor;
}

std::optional<WebKit::WebGPU::BlendComponent> ArgumentCoder<WebKit::WebGPU::BlendComponent>::decode(Decoder& decoder)
{
    auto operation = decoder.decode<WebCore::WebGPU::BlendOperation>();
    auto srcFactor = decoder.decode<WebCore::WebGPU::BlendFactor>();
    auto dstFactor = decoder.decode<WebCore::WebGPU::BlendFactor>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::BlendComponent {
            WTFMove(*operation),
            WTFMove(*srcFactor),
            WTFMove(*dstFactor)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::BlendState>::encode(Encoder& encoder, const WebKit::WebGPU::BlendState& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.color)>, WebKit::WebGPU::BlendComponent>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.alpha)>, WebKit::WebGPU::BlendComponent>);
    struct ShouldBeSameSizeAsBlendState : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::BlendState>, false> {
        WebKit::WebGPU::BlendComponent color;
        WebKit::WebGPU::BlendComponent alpha;
    };
    static_assert(sizeof(ShouldBeSameSizeAsBlendState) == sizeof(WebKit::WebGPU::BlendState));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::BlendState, color)
        , offsetof(WebKit::WebGPU::BlendState, alpha)
    >::value);

    encoder << instance.color;
    encoder << instance.alpha;
}

void ArgumentCoder<WebKit::WebGPU::BlendState>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::BlendState& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.color)>, WebKit::WebGPU::BlendComponent>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.alpha)>, WebKit::WebGPU::BlendComponent>);
    struct ShouldBeSameSizeAsBlendState : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::BlendState>, false> {
        WebKit::WebGPU::BlendComponent color;
        WebKit::WebGPU::BlendComponent alpha;
    };
    static_assert(sizeof(ShouldBeSameSizeAsBlendState) == sizeof(WebKit::WebGPU::BlendState));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::BlendState, color)
        , offsetof(WebKit::WebGPU::BlendState, alpha)
    >::value);

    encoder << instance.color;
    encoder << instance.alpha;
}

std::optional<WebKit::WebGPU::BlendState> ArgumentCoder<WebKit::WebGPU::BlendState>::decode(Decoder& decoder)
{
    auto color = decoder.decode<WebKit::WebGPU::BlendComponent>();
    auto alpha = decoder.decode<WebKit::WebGPU::BlendComponent>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::BlendState {
            WTFMove(*color),
            WTFMove(*alpha)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::BufferBinding>::encode(Encoder& encoder, const WebKit::WebGPU::BufferBinding& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.buffer)>, WebKit::WebGPUIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, WebCore::WebGPU::Size64>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size)>, std::optional<WebCore::WebGPU::Size64>>);
    struct ShouldBeSameSizeAsBufferBinding : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::BufferBinding>, false> {
        WebKit::WebGPUIdentifier buffer;
        WebCore::WebGPU::Size64 offset;
        std::optional<WebCore::WebGPU::Size64> size;
    };
    static_assert(sizeof(ShouldBeSameSizeAsBufferBinding) == sizeof(WebKit::WebGPU::BufferBinding));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::BufferBinding, buffer)
        , offsetof(WebKit::WebGPU::BufferBinding, offset)
        , offsetof(WebKit::WebGPU::BufferBinding, size)
    >::value);

    encoder << instance.buffer;
    encoder << instance.offset;
    encoder << instance.size;
}

void ArgumentCoder<WebKit::WebGPU::BufferBinding>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::BufferBinding& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.buffer)>, WebKit::WebGPUIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, WebCore::WebGPU::Size64>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size)>, std::optional<WebCore::WebGPU::Size64>>);
    struct ShouldBeSameSizeAsBufferBinding : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::BufferBinding>, false> {
        WebKit::WebGPUIdentifier buffer;
        WebCore::WebGPU::Size64 offset;
        std::optional<WebCore::WebGPU::Size64> size;
    };
    static_assert(sizeof(ShouldBeSameSizeAsBufferBinding) == sizeof(WebKit::WebGPU::BufferBinding));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::BufferBinding, buffer)
        , offsetof(WebKit::WebGPU::BufferBinding, offset)
        , offsetof(WebKit::WebGPU::BufferBinding, size)
    >::value);

    encoder << instance.buffer;
    encoder << instance.offset;
    encoder << instance.size;
}

std::optional<WebKit::WebGPU::BufferBinding> ArgumentCoder<WebKit::WebGPU::BufferBinding>::decode(Decoder& decoder)
{
    auto buffer = decoder.decode<WebKit::WebGPUIdentifier>();
    auto offset = decoder.decode<WebCore::WebGPU::Size64>();
    auto size = decoder.decode<std::optional<WebCore::WebGPU::Size64>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::BufferBinding {
            WTFMove(*buffer),
            WTFMove(*offset),
            WTFMove(*size)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::BufferBindingLayout>::encode(Encoder& encoder, const WebKit::WebGPU::BufferBindingLayout& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::WebGPU::BufferBindingType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasDynamicOffset)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.minBindingSize)>, WebCore::WebGPU::Size64>);
    struct ShouldBeSameSizeAsBufferBindingLayout : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::BufferBindingLayout>, false> {
        WebCore::WebGPU::BufferBindingType type;
        bool hasDynamicOffset;
        WebCore::WebGPU::Size64 minBindingSize;
    };
    static_assert(sizeof(ShouldBeSameSizeAsBufferBindingLayout) == sizeof(WebKit::WebGPU::BufferBindingLayout));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::BufferBindingLayout, type)
        , offsetof(WebKit::WebGPU::BufferBindingLayout, hasDynamicOffset)
        , offsetof(WebKit::WebGPU::BufferBindingLayout, minBindingSize)
    >::value);

    encoder << instance.type;
    encoder << instance.hasDynamicOffset;
    encoder << instance.minBindingSize;
}

void ArgumentCoder<WebKit::WebGPU::BufferBindingLayout>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::BufferBindingLayout& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::WebGPU::BufferBindingType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasDynamicOffset)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.minBindingSize)>, WebCore::WebGPU::Size64>);
    struct ShouldBeSameSizeAsBufferBindingLayout : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::BufferBindingLayout>, false> {
        WebCore::WebGPU::BufferBindingType type;
        bool hasDynamicOffset;
        WebCore::WebGPU::Size64 minBindingSize;
    };
    static_assert(sizeof(ShouldBeSameSizeAsBufferBindingLayout) == sizeof(WebKit::WebGPU::BufferBindingLayout));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::BufferBindingLayout, type)
        , offsetof(WebKit::WebGPU::BufferBindingLayout, hasDynamicOffset)
        , offsetof(WebKit::WebGPU::BufferBindingLayout, minBindingSize)
    >::value);

    encoder << instance.type;
    encoder << instance.hasDynamicOffset;
    encoder << instance.minBindingSize;
}

std::optional<WebKit::WebGPU::BufferBindingLayout> ArgumentCoder<WebKit::WebGPU::BufferBindingLayout>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::WebGPU::BufferBindingType>();
    auto hasDynamicOffset = decoder.decode<bool>();
    auto minBindingSize = decoder.decode<WebCore::WebGPU::Size64>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::BufferBindingLayout {
            WTFMove(*type),
            WTFMove(*hasDynamicOffset),
            WTFMove(*minBindingSize)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::BufferDescriptor>::encode(Encoder& encoder, const WebKit::WebGPU::BufferDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size)>, WebCore::WebGPU::Size64>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.usage)>, WebCore::WebGPU::BufferUsageFlags>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mappedAtCreation)>, bool>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::BufferDescriptor, size)
        , offsetof(WebKit::WebGPU::BufferDescriptor, usage)
        , offsetof(WebKit::WebGPU::BufferDescriptor, mappedAtCreation)
    >::value);

    encoder << instance.label;
    encoder << instance.size;
    encoder << instance.usage;
    encoder << instance.mappedAtCreation;
}

void ArgumentCoder<WebKit::WebGPU::BufferDescriptor>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::BufferDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size)>, WebCore::WebGPU::Size64>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.usage)>, WebCore::WebGPU::BufferUsageFlags>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mappedAtCreation)>, bool>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::BufferDescriptor, size)
        , offsetof(WebKit::WebGPU::BufferDescriptor, usage)
        , offsetof(WebKit::WebGPU::BufferDescriptor, mappedAtCreation)
    >::value);

    encoder << instance.label;
    encoder << instance.size;
    encoder << instance.usage;
    encoder << instance.mappedAtCreation;
}

std::optional<WebKit::WebGPU::BufferDescriptor> ArgumentCoder<WebKit::WebGPU::BufferDescriptor>::decode(Decoder& decoder)
{
    auto label = decoder.decode<String>();
    auto size = decoder.decode<WebCore::WebGPU::Size64>();
    auto usage = decoder.decode<WebCore::WebGPU::BufferUsageFlags>();
    auto mappedAtCreation = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::BufferDescriptor {
            WebKit::WebGPU::ObjectDescriptorBase {
                WTFMove(*label)
            },
            WTFMove(*size),
            WTFMove(*usage),
            WTFMove(*mappedAtCreation)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::CanvasConfiguration>::encode(Encoder& encoder, const WebKit::WebGPU::CanvasConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.device)>, WebKit::WebGPUIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.format)>, WebCore::WebGPU::TextureFormat>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.usage)>, WebCore::WebGPU::TextureUsageFlags>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.viewFormats)>, Vector<WebCore::WebGPU::TextureFormat>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorSpace)>, WebCore::WebGPU::PredefinedColorSpace>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.toneMappingMode)>, WebCore::WebGPU::CanvasToneMappingMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.compositingAlphaMode)>, WebCore::WebGPU::CanvasAlphaMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.reportValidationErrors)>, bool>);
    struct ShouldBeSameSizeAsCanvasConfiguration : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::CanvasConfiguration>, false> {
        WebKit::WebGPUIdentifier device;
        WebCore::WebGPU::TextureFormat format;
        WebCore::WebGPU::TextureUsageFlags usage;
        Vector<WebCore::WebGPU::TextureFormat> viewFormats;
        WebCore::WebGPU::PredefinedColorSpace colorSpace;
        WebCore::WebGPU::CanvasToneMappingMode toneMappingMode;
        WebCore::WebGPU::CanvasAlphaMode compositingAlphaMode;
        bool reportValidationErrors;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCanvasConfiguration) == sizeof(WebKit::WebGPU::CanvasConfiguration));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::CanvasConfiguration, device)
        , offsetof(WebKit::WebGPU::CanvasConfiguration, format)
        , offsetof(WebKit::WebGPU::CanvasConfiguration, usage)
        , offsetof(WebKit::WebGPU::CanvasConfiguration, viewFormats)
        , offsetof(WebKit::WebGPU::CanvasConfiguration, colorSpace)
        , offsetof(WebKit::WebGPU::CanvasConfiguration, toneMappingMode)
        , offsetof(WebKit::WebGPU::CanvasConfiguration, compositingAlphaMode)
        , offsetof(WebKit::WebGPU::CanvasConfiguration, reportValidationErrors)
    >::value);

    encoder << instance.device;
    encoder << instance.format;
    encoder << instance.usage;
    encoder << instance.viewFormats;
    encoder << instance.colorSpace;
    encoder << instance.toneMappingMode;
    encoder << instance.compositingAlphaMode;
    encoder << instance.reportValidationErrors;
}

void ArgumentCoder<WebKit::WebGPU::CanvasConfiguration>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::CanvasConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.device)>, WebKit::WebGPUIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.format)>, WebCore::WebGPU::TextureFormat>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.usage)>, WebCore::WebGPU::TextureUsageFlags>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.viewFormats)>, Vector<WebCore::WebGPU::TextureFormat>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorSpace)>, WebCore::WebGPU::PredefinedColorSpace>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.toneMappingMode)>, WebCore::WebGPU::CanvasToneMappingMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.compositingAlphaMode)>, WebCore::WebGPU::CanvasAlphaMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.reportValidationErrors)>, bool>);
    struct ShouldBeSameSizeAsCanvasConfiguration : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::CanvasConfiguration>, false> {
        WebKit::WebGPUIdentifier device;
        WebCore::WebGPU::TextureFormat format;
        WebCore::WebGPU::TextureUsageFlags usage;
        Vector<WebCore::WebGPU::TextureFormat> viewFormats;
        WebCore::WebGPU::PredefinedColorSpace colorSpace;
        WebCore::WebGPU::CanvasToneMappingMode toneMappingMode;
        WebCore::WebGPU::CanvasAlphaMode compositingAlphaMode;
        bool reportValidationErrors;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCanvasConfiguration) == sizeof(WebKit::WebGPU::CanvasConfiguration));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::CanvasConfiguration, device)
        , offsetof(WebKit::WebGPU::CanvasConfiguration, format)
        , offsetof(WebKit::WebGPU::CanvasConfiguration, usage)
        , offsetof(WebKit::WebGPU::CanvasConfiguration, viewFormats)
        , offsetof(WebKit::WebGPU::CanvasConfiguration, colorSpace)
        , offsetof(WebKit::WebGPU::CanvasConfiguration, toneMappingMode)
        , offsetof(WebKit::WebGPU::CanvasConfiguration, compositingAlphaMode)
        , offsetof(WebKit::WebGPU::CanvasConfiguration, reportValidationErrors)
    >::value);

    encoder << instance.device;
    encoder << instance.format;
    encoder << instance.usage;
    encoder << instance.viewFormats;
    encoder << instance.colorSpace;
    encoder << instance.toneMappingMode;
    encoder << instance.compositingAlphaMode;
    encoder << instance.reportValidationErrors;
}

std::optional<WebKit::WebGPU::CanvasConfiguration> ArgumentCoder<WebKit::WebGPU::CanvasConfiguration>::decode(Decoder& decoder)
{
    auto device = decoder.decode<WebKit::WebGPUIdentifier>();
    auto format = decoder.decode<WebCore::WebGPU::TextureFormat>();
    auto usage = decoder.decode<WebCore::WebGPU::TextureUsageFlags>();
    auto viewFormats = decoder.decode<Vector<WebCore::WebGPU::TextureFormat>>();
    auto colorSpace = decoder.decode<WebCore::WebGPU::PredefinedColorSpace>();
    auto toneMappingMode = decoder.decode<WebCore::WebGPU::CanvasToneMappingMode>();
    auto compositingAlphaMode = decoder.decode<WebCore::WebGPU::CanvasAlphaMode>();
    auto reportValidationErrors = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::CanvasConfiguration {
            WTFMove(*device),
            WTFMove(*format),
            WTFMove(*usage),
            WTFMove(*viewFormats),
            WTFMove(*colorSpace),
            WTFMove(*toneMappingMode),
            WTFMove(*compositingAlphaMode),
            WTFMove(*reportValidationErrors)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::ColorDict>::encode(Encoder& encoder, const WebKit::WebGPU::ColorDict& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.r)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.g)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.b)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.a)>, double>);
    struct ShouldBeSameSizeAsColorDict : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::ColorDict>, false> {
        double r;
        double g;
        double b;
        double a;
    };
    static_assert(sizeof(ShouldBeSameSizeAsColorDict) == sizeof(WebKit::WebGPU::ColorDict));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ColorDict, r)
        , offsetof(WebKit::WebGPU::ColorDict, g)
        , offsetof(WebKit::WebGPU::ColorDict, b)
        , offsetof(WebKit::WebGPU::ColorDict, a)
    >::value);

    encoder << instance.r;
    encoder << instance.g;
    encoder << instance.b;
    encoder << instance.a;
}

void ArgumentCoder<WebKit::WebGPU::ColorDict>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::ColorDict& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.r)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.g)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.b)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.a)>, double>);
    struct ShouldBeSameSizeAsColorDict : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::ColorDict>, false> {
        double r;
        double g;
        double b;
        double a;
    };
    static_assert(sizeof(ShouldBeSameSizeAsColorDict) == sizeof(WebKit::WebGPU::ColorDict));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ColorDict, r)
        , offsetof(WebKit::WebGPU::ColorDict, g)
        , offsetof(WebKit::WebGPU::ColorDict, b)
        , offsetof(WebKit::WebGPU::ColorDict, a)
    >::value);

    encoder << instance.r;
    encoder << instance.g;
    encoder << instance.b;
    encoder << instance.a;
}

std::optional<WebKit::WebGPU::ColorDict> ArgumentCoder<WebKit::WebGPU::ColorDict>::decode(Decoder& decoder)
{
    auto r = decoder.decode<double>();
    auto g = decoder.decode<double>();
    auto b = decoder.decode<double>();
    auto a = decoder.decode<double>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::ColorDict {
            WTFMove(*r),
            WTFMove(*g),
            WTFMove(*b),
            WTFMove(*a)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::ColorTargetState>::encode(Encoder& encoder, const WebKit::WebGPU::ColorTargetState& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.format)>, WebCore::WebGPU::TextureFormat>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.blend)>, std::optional<WebKit::WebGPU::BlendState>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.writeMask)>, WebCore::WebGPU::ColorWriteFlags>);
    struct ShouldBeSameSizeAsColorTargetState : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::ColorTargetState>, false> {
        WebCore::WebGPU::TextureFormat format;
        std::optional<WebKit::WebGPU::BlendState> blend;
        WebCore::WebGPU::ColorWriteFlags writeMask;
    };
    static_assert(sizeof(ShouldBeSameSizeAsColorTargetState) == sizeof(WebKit::WebGPU::ColorTargetState));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ColorTargetState, format)
        , offsetof(WebKit::WebGPU::ColorTargetState, blend)
        , offsetof(WebKit::WebGPU::ColorTargetState, writeMask)
    >::value);

    encoder << instance.format;
    encoder << instance.blend;
    encoder << instance.writeMask;
}

void ArgumentCoder<WebKit::WebGPU::ColorTargetState>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::ColorTargetState& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.format)>, WebCore::WebGPU::TextureFormat>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.blend)>, std::optional<WebKit::WebGPU::BlendState>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.writeMask)>, WebCore::WebGPU::ColorWriteFlags>);
    struct ShouldBeSameSizeAsColorTargetState : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::ColorTargetState>, false> {
        WebCore::WebGPU::TextureFormat format;
        std::optional<WebKit::WebGPU::BlendState> blend;
        WebCore::WebGPU::ColorWriteFlags writeMask;
    };
    static_assert(sizeof(ShouldBeSameSizeAsColorTargetState) == sizeof(WebKit::WebGPU::ColorTargetState));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ColorTargetState, format)
        , offsetof(WebKit::WebGPU::ColorTargetState, blend)
        , offsetof(WebKit::WebGPU::ColorTargetState, writeMask)
    >::value);

    encoder << instance.format;
    encoder << instance.blend;
    encoder << instance.writeMask;
}

std::optional<WebKit::WebGPU::ColorTargetState> ArgumentCoder<WebKit::WebGPU::ColorTargetState>::decode(Decoder& decoder)
{
    auto format = decoder.decode<WebCore::WebGPU::TextureFormat>();
    auto blend = decoder.decode<std::optional<WebKit::WebGPU::BlendState>>();
    auto writeMask = decoder.decode<WebCore::WebGPU::ColorWriteFlags>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::ColorTargetState {
            WTFMove(*format),
            WTFMove(*blend),
            WTFMove(*writeMask)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::CommandBufferDescriptor>::encode(Encoder& encoder, const WebKit::WebGPU::CommandBufferDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(MembersInCorrectOrder < 0
    >::value);

    encoder << instance.label;
}

void ArgumentCoder<WebKit::WebGPU::CommandBufferDescriptor>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::CommandBufferDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(MembersInCorrectOrder < 0
    >::value);

    encoder << instance.label;
}

std::optional<WebKit::WebGPU::CommandBufferDescriptor> ArgumentCoder<WebKit::WebGPU::CommandBufferDescriptor>::decode(Decoder& decoder)
{
    auto label = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::CommandBufferDescriptor {
            WebKit::WebGPU::ObjectDescriptorBase {
                WTFMove(*label)
            }
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::CommandEncoderDescriptor>::encode(Encoder& encoder, const WebKit::WebGPU::CommandEncoderDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(MembersInCorrectOrder < 0
    >::value);

    encoder << instance.label;
}

void ArgumentCoder<WebKit::WebGPU::CommandEncoderDescriptor>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::CommandEncoderDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(MembersInCorrectOrder < 0
    >::value);

    encoder << instance.label;
}

std::optional<WebKit::WebGPU::CommandEncoderDescriptor> ArgumentCoder<WebKit::WebGPU::CommandEncoderDescriptor>::decode(Decoder& decoder)
{
    auto label = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::CommandEncoderDescriptor {
            WebKit::WebGPU::ObjectDescriptorBase {
                WTFMove(*label)
            }
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::CompilationMessage>::encode(Encoder& encoder, const WebKit::WebGPU::CompilationMessage& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.message)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::WebGPU::CompilationMessageType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lineNum)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.linePos)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.length)>, uint64_t>);
    struct ShouldBeSameSizeAsCompilationMessage : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::CompilationMessage>, false> {
        String message;
        WebCore::WebGPU::CompilationMessageType type;
        uint64_t lineNum;
        uint64_t linePos;
        uint64_t offset;
        uint64_t length;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCompilationMessage) == sizeof(WebKit::WebGPU::CompilationMessage));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::CompilationMessage, message)
        , offsetof(WebKit::WebGPU::CompilationMessage, type)
        , offsetof(WebKit::WebGPU::CompilationMessage, lineNum)
        , offsetof(WebKit::WebGPU::CompilationMessage, linePos)
        , offsetof(WebKit::WebGPU::CompilationMessage, offset)
        , offsetof(WebKit::WebGPU::CompilationMessage, length)
    >::value);

    encoder << instance.message;
    encoder << instance.type;
    encoder << instance.lineNum;
    encoder << instance.linePos;
    encoder << instance.offset;
    encoder << instance.length;
}

void ArgumentCoder<WebKit::WebGPU::CompilationMessage>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::CompilationMessage& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.message)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::WebGPU::CompilationMessageType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lineNum)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.linePos)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.length)>, uint64_t>);
    struct ShouldBeSameSizeAsCompilationMessage : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::CompilationMessage>, false> {
        String message;
        WebCore::WebGPU::CompilationMessageType type;
        uint64_t lineNum;
        uint64_t linePos;
        uint64_t offset;
        uint64_t length;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCompilationMessage) == sizeof(WebKit::WebGPU::CompilationMessage));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::CompilationMessage, message)
        , offsetof(WebKit::WebGPU::CompilationMessage, type)
        , offsetof(WebKit::WebGPU::CompilationMessage, lineNum)
        , offsetof(WebKit::WebGPU::CompilationMessage, linePos)
        , offsetof(WebKit::WebGPU::CompilationMessage, offset)
        , offsetof(WebKit::WebGPU::CompilationMessage, length)
    >::value);

    encoder << instance.message;
    encoder << instance.type;
    encoder << instance.lineNum;
    encoder << instance.linePos;
    encoder << instance.offset;
    encoder << instance.length;
}

std::optional<WebKit::WebGPU::CompilationMessage> ArgumentCoder<WebKit::WebGPU::CompilationMessage>::decode(Decoder& decoder)
{
    auto message = decoder.decode<String>();
    auto type = decoder.decode<WebCore::WebGPU::CompilationMessageType>();
    auto lineNum = decoder.decode<uint64_t>();
    auto linePos = decoder.decode<uint64_t>();
    auto offset = decoder.decode<uint64_t>();
    auto length = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::CompilationMessage {
            WTFMove(*message),
            WTFMove(*type),
            WTFMove(*lineNum),
            WTFMove(*linePos),
            WTFMove(*offset),
            WTFMove(*length)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::ComputePassDescriptor>::encode(Encoder& encoder, const WebKit::WebGPU::ComputePassDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timestampWrites)>, std::optional<WebKit::WebGPU::ComputePassTimestampWrites>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ComputePassDescriptor, timestampWrites)
    >::value);

    encoder << instance.label;
    encoder << instance.timestampWrites;
}

void ArgumentCoder<WebKit::WebGPU::ComputePassDescriptor>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::ComputePassDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timestampWrites)>, std::optional<WebKit::WebGPU::ComputePassTimestampWrites>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ComputePassDescriptor, timestampWrites)
    >::value);

    encoder << instance.label;
    encoder << instance.timestampWrites;
}

std::optional<WebKit::WebGPU::ComputePassDescriptor> ArgumentCoder<WebKit::WebGPU::ComputePassDescriptor>::decode(Decoder& decoder)
{
    auto label = decoder.decode<String>();
    auto timestampWrites = decoder.decode<std::optional<WebKit::WebGPU::ComputePassTimestampWrites>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::ComputePassDescriptor {
            WebKit::WebGPU::ObjectDescriptorBase {
                WTFMove(*label)
            },
            WTFMove(*timestampWrites)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::ComputePassTimestampWrites>::encode(Encoder& encoder, const WebKit::WebGPU::ComputePassTimestampWrites& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.querySet)>, WebKit::WebGPUIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.beginningOfPassWriteIndex)>, WebCore::WebGPU::Size32>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.endOfPassWriteIndex)>, WebCore::WebGPU::Size32>);
    struct ShouldBeSameSizeAsComputePassTimestampWrites : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::ComputePassTimestampWrites>, false> {
        WebKit::WebGPUIdentifier querySet;
        WebCore::WebGPU::Size32 beginningOfPassWriteIndex;
        WebCore::WebGPU::Size32 endOfPassWriteIndex;
    };
    static_assert(sizeof(ShouldBeSameSizeAsComputePassTimestampWrites) == sizeof(WebKit::WebGPU::ComputePassTimestampWrites));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ComputePassTimestampWrites, querySet)
        , offsetof(WebKit::WebGPU::ComputePassTimestampWrites, beginningOfPassWriteIndex)
        , offsetof(WebKit::WebGPU::ComputePassTimestampWrites, endOfPassWriteIndex)
    >::value);

    encoder << instance.querySet;
    encoder << instance.beginningOfPassWriteIndex;
    encoder << instance.endOfPassWriteIndex;
}

void ArgumentCoder<WebKit::WebGPU::ComputePassTimestampWrites>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::ComputePassTimestampWrites& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.querySet)>, WebKit::WebGPUIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.beginningOfPassWriteIndex)>, WebCore::WebGPU::Size32>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.endOfPassWriteIndex)>, WebCore::WebGPU::Size32>);
    struct ShouldBeSameSizeAsComputePassTimestampWrites : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::ComputePassTimestampWrites>, false> {
        WebKit::WebGPUIdentifier querySet;
        WebCore::WebGPU::Size32 beginningOfPassWriteIndex;
        WebCore::WebGPU::Size32 endOfPassWriteIndex;
    };
    static_assert(sizeof(ShouldBeSameSizeAsComputePassTimestampWrites) == sizeof(WebKit::WebGPU::ComputePassTimestampWrites));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ComputePassTimestampWrites, querySet)
        , offsetof(WebKit::WebGPU::ComputePassTimestampWrites, beginningOfPassWriteIndex)
        , offsetof(WebKit::WebGPU::ComputePassTimestampWrites, endOfPassWriteIndex)
    >::value);

    encoder << instance.querySet;
    encoder << instance.beginningOfPassWriteIndex;
    encoder << instance.endOfPassWriteIndex;
}

std::optional<WebKit::WebGPU::ComputePassTimestampWrites> ArgumentCoder<WebKit::WebGPU::ComputePassTimestampWrites>::decode(Decoder& decoder)
{
    auto querySet = decoder.decode<WebKit::WebGPUIdentifier>();
    auto beginningOfPassWriteIndex = decoder.decode<WebCore::WebGPU::Size32>();
    auto endOfPassWriteIndex = decoder.decode<WebCore::WebGPU::Size32>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::ComputePassTimestampWrites {
            WTFMove(*querySet),
            WTFMove(*beginningOfPassWriteIndex),
            WTFMove(*endOfPassWriteIndex)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::ComputePipelineDescriptor>::encode(Encoder& encoder, const WebKit::WebGPU::ComputePipelineDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.layout)>, Markable<WebKit::WebGPUIdentifier>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::PipelineDescriptorBase, layout)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.compute)>, WebKit::WebGPU::ProgrammableStage>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ComputePipelineDescriptor, compute)
    >::value);

    encoder << instance.label;
    encoder << instance.layout;
    encoder << instance.compute;
}

void ArgumentCoder<WebKit::WebGPU::ComputePipelineDescriptor>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::ComputePipelineDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.layout)>, Markable<WebKit::WebGPUIdentifier>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::PipelineDescriptorBase, layout)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.compute)>, WebKit::WebGPU::ProgrammableStage>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ComputePipelineDescriptor, compute)
    >::value);

    encoder << instance.label;
    encoder << instance.layout;
    encoder << instance.compute;
}

std::optional<WebKit::WebGPU::ComputePipelineDescriptor> ArgumentCoder<WebKit::WebGPU::ComputePipelineDescriptor>::decode(Decoder& decoder)
{
    auto label = decoder.decode<String>();
    auto layout = decoder.decode<Markable<WebKit::WebGPUIdentifier>>();
    auto compute = decoder.decode<WebKit::WebGPU::ProgrammableStage>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::ComputePipelineDescriptor {
            WebKit::WebGPU::PipelineDescriptorBase {
                WebKit::WebGPU::ObjectDescriptorBase {
                    WTFMove(*label)
                },
                WTFMove(*layout)
            },
            WTFMove(*compute)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::DepthStencilState>::encode(Encoder& encoder, const WebKit::WebGPU::DepthStencilState& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.format)>, WebCore::WebGPU::TextureFormat>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthWriteEnabled)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthCompare)>, std::optional<WebCore::WebGPU::CompareFunction>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stencilFront)>, WebKit::WebGPU::StencilFaceState>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stencilBack)>, WebKit::WebGPU::StencilFaceState>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stencilReadMask)>, std::optional<WebCore::WebGPU::StencilValue>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stencilWriteMask)>, std::optional<WebCore::WebGPU::StencilValue>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthBias)>, WebCore::WebGPU::DepthBias>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthBiasSlopeScale)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthBiasClamp)>, float>);
    struct ShouldBeSameSizeAsDepthStencilState : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::DepthStencilState>, false> {
        WebCore::WebGPU::TextureFormat format;
        std::optional<bool> depthWriteEnabled;
        std::optional<WebCore::WebGPU::CompareFunction> depthCompare;
        WebKit::WebGPU::StencilFaceState stencilFront;
        WebKit::WebGPU::StencilFaceState stencilBack;
        std::optional<WebCore::WebGPU::StencilValue> stencilReadMask;
        std::optional<WebCore::WebGPU::StencilValue> stencilWriteMask;
        WebCore::WebGPU::DepthBias depthBias;
        float depthBiasSlopeScale;
        float depthBiasClamp;
    };
    static_assert(sizeof(ShouldBeSameSizeAsDepthStencilState) == sizeof(WebKit::WebGPU::DepthStencilState));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::DepthStencilState, format)
        , offsetof(WebKit::WebGPU::DepthStencilState, depthWriteEnabled)
        , offsetof(WebKit::WebGPU::DepthStencilState, depthCompare)
        , offsetof(WebKit::WebGPU::DepthStencilState, stencilFront)
        , offsetof(WebKit::WebGPU::DepthStencilState, stencilBack)
        , offsetof(WebKit::WebGPU::DepthStencilState, stencilReadMask)
        , offsetof(WebKit::WebGPU::DepthStencilState, stencilWriteMask)
        , offsetof(WebKit::WebGPU::DepthStencilState, depthBias)
        , offsetof(WebKit::WebGPU::DepthStencilState, depthBiasSlopeScale)
        , offsetof(WebKit::WebGPU::DepthStencilState, depthBiasClamp)
    >::value);

    encoder << instance.format;
    encoder << instance.depthWriteEnabled;
    encoder << instance.depthCompare;
    encoder << instance.stencilFront;
    encoder << instance.stencilBack;
    encoder << instance.stencilReadMask;
    encoder << instance.stencilWriteMask;
    encoder << instance.depthBias;
    encoder << instance.depthBiasSlopeScale;
    encoder << instance.depthBiasClamp;
}

void ArgumentCoder<WebKit::WebGPU::DepthStencilState>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::DepthStencilState& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.format)>, WebCore::WebGPU::TextureFormat>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthWriteEnabled)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthCompare)>, std::optional<WebCore::WebGPU::CompareFunction>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stencilFront)>, WebKit::WebGPU::StencilFaceState>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stencilBack)>, WebKit::WebGPU::StencilFaceState>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stencilReadMask)>, std::optional<WebCore::WebGPU::StencilValue>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stencilWriteMask)>, std::optional<WebCore::WebGPU::StencilValue>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthBias)>, WebCore::WebGPU::DepthBias>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthBiasSlopeScale)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthBiasClamp)>, float>);
    struct ShouldBeSameSizeAsDepthStencilState : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::DepthStencilState>, false> {
        WebCore::WebGPU::TextureFormat format;
        std::optional<bool> depthWriteEnabled;
        std::optional<WebCore::WebGPU::CompareFunction> depthCompare;
        WebKit::WebGPU::StencilFaceState stencilFront;
        WebKit::WebGPU::StencilFaceState stencilBack;
        std::optional<WebCore::WebGPU::StencilValue> stencilReadMask;
        std::optional<WebCore::WebGPU::StencilValue> stencilWriteMask;
        WebCore::WebGPU::DepthBias depthBias;
        float depthBiasSlopeScale;
        float depthBiasClamp;
    };
    static_assert(sizeof(ShouldBeSameSizeAsDepthStencilState) == sizeof(WebKit::WebGPU::DepthStencilState));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::DepthStencilState, format)
        , offsetof(WebKit::WebGPU::DepthStencilState, depthWriteEnabled)
        , offsetof(WebKit::WebGPU::DepthStencilState, depthCompare)
        , offsetof(WebKit::WebGPU::DepthStencilState, stencilFront)
        , offsetof(WebKit::WebGPU::DepthStencilState, stencilBack)
        , offsetof(WebKit::WebGPU::DepthStencilState, stencilReadMask)
        , offsetof(WebKit::WebGPU::DepthStencilState, stencilWriteMask)
        , offsetof(WebKit::WebGPU::DepthStencilState, depthBias)
        , offsetof(WebKit::WebGPU::DepthStencilState, depthBiasSlopeScale)
        , offsetof(WebKit::WebGPU::DepthStencilState, depthBiasClamp)
    >::value);

    encoder << instance.format;
    encoder << instance.depthWriteEnabled;
    encoder << instance.depthCompare;
    encoder << instance.stencilFront;
    encoder << instance.stencilBack;
    encoder << instance.stencilReadMask;
    encoder << instance.stencilWriteMask;
    encoder << instance.depthBias;
    encoder << instance.depthBiasSlopeScale;
    encoder << instance.depthBiasClamp;
}

std::optional<WebKit::WebGPU::DepthStencilState> ArgumentCoder<WebKit::WebGPU::DepthStencilState>::decode(Decoder& decoder)
{
    auto format = decoder.decode<WebCore::WebGPU::TextureFormat>();
    auto depthWriteEnabled = decoder.decode<std::optional<bool>>();
    auto depthCompare = decoder.decode<std::optional<WebCore::WebGPU::CompareFunction>>();
    auto stencilFront = decoder.decode<WebKit::WebGPU::StencilFaceState>();
    auto stencilBack = decoder.decode<WebKit::WebGPU::StencilFaceState>();
    auto stencilReadMask = decoder.decode<std::optional<WebCore::WebGPU::StencilValue>>();
    auto stencilWriteMask = decoder.decode<std::optional<WebCore::WebGPU::StencilValue>>();
    auto depthBias = decoder.decode<WebCore::WebGPU::DepthBias>();
    auto depthBiasSlopeScale = decoder.decode<float>();
    auto depthBiasClamp = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::DepthStencilState {
            WTFMove(*format),
            WTFMove(*depthWriteEnabled),
            WTFMove(*depthCompare),
            WTFMove(*stencilFront),
            WTFMove(*stencilBack),
            WTFMove(*stencilReadMask),
            WTFMove(*stencilWriteMask),
            WTFMove(*depthBias),
            WTFMove(*depthBiasSlopeScale),
            WTFMove(*depthBiasClamp)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::DeviceDescriptor>::encode(Encoder& encoder, const WebKit::WebGPU::DeviceDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requiredFeatures)>, Vector<WebCore::WebGPU::FeatureName>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requiredLimits)>, Vector<KeyValuePair<String, uint64_t>>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::DeviceDescriptor, requiredFeatures)
        , offsetof(WebKit::WebGPU::DeviceDescriptor, requiredLimits)
    >::value);

    encoder << instance.label;
    encoder << instance.requiredFeatures;
    encoder << instance.requiredLimits;
}

void ArgumentCoder<WebKit::WebGPU::DeviceDescriptor>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::DeviceDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requiredFeatures)>, Vector<WebCore::WebGPU::FeatureName>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requiredLimits)>, Vector<KeyValuePair<String, uint64_t>>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::DeviceDescriptor, requiredFeatures)
        , offsetof(WebKit::WebGPU::DeviceDescriptor, requiredLimits)
    >::value);

    encoder << instance.label;
    encoder << instance.requiredFeatures;
    encoder << instance.requiredLimits;
}

std::optional<WebKit::WebGPU::DeviceDescriptor> ArgumentCoder<WebKit::WebGPU::DeviceDescriptor>::decode(Decoder& decoder)
{
    auto label = decoder.decode<String>();
    auto requiredFeatures = decoder.decode<Vector<WebCore::WebGPU::FeatureName>>();
    auto requiredLimits = decoder.decode<Vector<KeyValuePair<String, uint64_t>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::DeviceDescriptor {
            WebKit::WebGPU::ObjectDescriptorBase {
                WTFMove(*label)
            },
            WTFMove(*requiredFeatures),
            WTFMove(*requiredLimits)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::Extent3DDict>::encode(Encoder& encoder, const WebKit::WebGPU::Extent3DDict& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.width)>, WebCore::WebGPU::IntegerCoordinate>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.height)>, WebCore::WebGPU::IntegerCoordinate>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthOrArrayLayers)>, WebCore::WebGPU::IntegerCoordinate>);
    struct ShouldBeSameSizeAsExtent3DDict : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::Extent3DDict>, false> {
        WebCore::WebGPU::IntegerCoordinate width;
        WebCore::WebGPU::IntegerCoordinate height;
        WebCore::WebGPU::IntegerCoordinate depthOrArrayLayers;
    };
    static_assert(sizeof(ShouldBeSameSizeAsExtent3DDict) == sizeof(WebKit::WebGPU::Extent3DDict));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::Extent3DDict, width)
        , offsetof(WebKit::WebGPU::Extent3DDict, height)
        , offsetof(WebKit::WebGPU::Extent3DDict, depthOrArrayLayers)
    >::value);

    encoder << instance.width;
    encoder << instance.height;
    encoder << instance.depthOrArrayLayers;
}

void ArgumentCoder<WebKit::WebGPU::Extent3DDict>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::Extent3DDict& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.width)>, WebCore::WebGPU::IntegerCoordinate>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.height)>, WebCore::WebGPU::IntegerCoordinate>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthOrArrayLayers)>, WebCore::WebGPU::IntegerCoordinate>);
    struct ShouldBeSameSizeAsExtent3DDict : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::Extent3DDict>, false> {
        WebCore::WebGPU::IntegerCoordinate width;
        WebCore::WebGPU::IntegerCoordinate height;
        WebCore::WebGPU::IntegerCoordinate depthOrArrayLayers;
    };
    static_assert(sizeof(ShouldBeSameSizeAsExtent3DDict) == sizeof(WebKit::WebGPU::Extent3DDict));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::Extent3DDict, width)
        , offsetof(WebKit::WebGPU::Extent3DDict, height)
        , offsetof(WebKit::WebGPU::Extent3DDict, depthOrArrayLayers)
    >::value);

    encoder << instance.width;
    encoder << instance.height;
    encoder << instance.depthOrArrayLayers;
}

std::optional<WebKit::WebGPU::Extent3DDict> ArgumentCoder<WebKit::WebGPU::Extent3DDict>::decode(Decoder& decoder)
{
    auto width = decoder.decode<WebCore::WebGPU::IntegerCoordinate>();
    auto height = decoder.decode<WebCore::WebGPU::IntegerCoordinate>();
    auto depthOrArrayLayers = decoder.decode<WebCore::WebGPU::IntegerCoordinate>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::Extent3DDict {
            WTFMove(*width),
            WTFMove(*height),
            WTFMove(*depthOrArrayLayers)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::ExternalTextureBindingLayout>::encode(Encoder& encoder, const WebKit::WebGPU::ExternalTextureBindingLayout& instance)
{
    struct ShouldBeSameSizeAsExternalTextureBindingLayout : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::ExternalTextureBindingLayout>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsExternalTextureBindingLayout) == sizeof(WebKit::WebGPU::ExternalTextureBindingLayout));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

void ArgumentCoder<WebKit::WebGPU::ExternalTextureBindingLayout>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::ExternalTextureBindingLayout& instance)
{
    struct ShouldBeSameSizeAsExternalTextureBindingLayout : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::ExternalTextureBindingLayout>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsExternalTextureBindingLayout) == sizeof(WebKit::WebGPU::ExternalTextureBindingLayout));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebKit::WebGPU::ExternalTextureBindingLayout> ArgumentCoder<WebKit::WebGPU::ExternalTextureBindingLayout>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::ExternalTextureBindingLayout {
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::ExternalTextureDescriptor>::encode(Encoder& encoder, WebKit::WebGPU::ExternalTextureDescriptor&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaIdentifier)>, std::optional<WebCore::MediaPlayerIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorSpace)>, WebCore::WebGPU::PredefinedColorSpace>);
#if PLATFORM(COCOA) && ENABLE(VIDEO)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sharedFrame)>, std::optional<WebKit::SharedVideoFrame>>);
#endif
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ExternalTextureDescriptor, mediaIdentifier)
        , offsetof(WebKit::WebGPU::ExternalTextureDescriptor, colorSpace)
#if PLATFORM(COCOA) && ENABLE(VIDEO)
        , offsetof(WebKit::WebGPU::ExternalTextureDescriptor, sharedFrame)
#endif
    >::value);

    encoder << instance.label;
    encoder << WTFMove(instance.mediaIdentifier);
    encoder << WTFMove(instance.colorSpace);
#if PLATFORM(COCOA) && ENABLE(VIDEO)
    encoder << WTFMove(instance.sharedFrame);
#endif
}

std::optional<WebKit::WebGPU::ExternalTextureDescriptor> ArgumentCoder<WebKit::WebGPU::ExternalTextureDescriptor>::decode(Decoder& decoder)
{
    auto label = decoder.decode<String>();
    auto mediaIdentifier = decoder.decode<std::optional<WebCore::MediaPlayerIdentifier>>();
    auto colorSpace = decoder.decode<WebCore::WebGPU::PredefinedColorSpace>();
#if PLATFORM(COCOA) && ENABLE(VIDEO)
    auto sharedFrame = decoder.decode<std::optional<WebKit::SharedVideoFrame>>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::ExternalTextureDescriptor {
            WebKit::WebGPU::ObjectDescriptorBase {
                WTFMove(*label)
            },
            WTFMove(*mediaIdentifier),
            WTFMove(*colorSpace),
#if PLATFORM(COCOA) && ENABLE(VIDEO)
            WTFMove(*sharedFrame)
#endif
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::FragmentState>::encode(Encoder& encoder, const WebKit::WebGPU::FragmentState& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.module)>, WebKit::WebGPUIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.entryPoint)>, std::optional<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.constants)>, Vector<KeyValuePair<String, double>>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ProgrammableStage, module)
        , offsetof(WebKit::WebGPU::ProgrammableStage, entryPoint)
        , offsetof(WebKit::WebGPU::ProgrammableStage, constants)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.targets)>, Vector<std::optional<WebKit::WebGPU::ColorTargetState>>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::FragmentState, targets)
    >::value);

    encoder << instance.module;
    encoder << instance.entryPoint;
    encoder << instance.constants;
    encoder << instance.targets;
}

void ArgumentCoder<WebKit::WebGPU::FragmentState>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::FragmentState& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.module)>, WebKit::WebGPUIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.entryPoint)>, std::optional<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.constants)>, Vector<KeyValuePair<String, double>>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ProgrammableStage, module)
        , offsetof(WebKit::WebGPU::ProgrammableStage, entryPoint)
        , offsetof(WebKit::WebGPU::ProgrammableStage, constants)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.targets)>, Vector<std::optional<WebKit::WebGPU::ColorTargetState>>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::FragmentState, targets)
    >::value);

    encoder << instance.module;
    encoder << instance.entryPoint;
    encoder << instance.constants;
    encoder << instance.targets;
}

std::optional<WebKit::WebGPU::FragmentState> ArgumentCoder<WebKit::WebGPU::FragmentState>::decode(Decoder& decoder)
{
    auto module = decoder.decode<WebKit::WebGPUIdentifier>();
    auto entryPoint = decoder.decode<std::optional<String>>();
    auto constants = decoder.decode<Vector<KeyValuePair<String, double>>>();
    auto targets = decoder.decode<Vector<std::optional<WebKit::WebGPU::ColorTargetState>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::FragmentState {
            WebKit::WebGPU::ProgrammableStage {
                WTFMove(*module),
                WTFMove(*entryPoint),
                WTFMove(*constants)
            },
            WTFMove(*targets)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::ImageCopyBuffer>::encode(Encoder& encoder, const WebKit::WebGPU::ImageCopyBuffer& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, WebCore::WebGPU::Size64>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bytesPerRow)>, std::optional<WebCore::WebGPU::Size32>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rowsPerImage)>, std::optional<WebCore::WebGPU::Size32>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ImageDataLayout, offset)
        , offsetof(WebKit::WebGPU::ImageDataLayout, bytesPerRow)
        , offsetof(WebKit::WebGPU::ImageDataLayout, rowsPerImage)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.buffer)>, WebKit::WebGPUIdentifier>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ImageCopyBuffer, buffer)
    >::value);

    encoder << instance.offset;
    encoder << instance.bytesPerRow;
    encoder << instance.rowsPerImage;
    encoder << instance.buffer;
}

void ArgumentCoder<WebKit::WebGPU::ImageCopyBuffer>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::ImageCopyBuffer& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, WebCore::WebGPU::Size64>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bytesPerRow)>, std::optional<WebCore::WebGPU::Size32>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rowsPerImage)>, std::optional<WebCore::WebGPU::Size32>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ImageDataLayout, offset)
        , offsetof(WebKit::WebGPU::ImageDataLayout, bytesPerRow)
        , offsetof(WebKit::WebGPU::ImageDataLayout, rowsPerImage)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.buffer)>, WebKit::WebGPUIdentifier>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ImageCopyBuffer, buffer)
    >::value);

    encoder << instance.offset;
    encoder << instance.bytesPerRow;
    encoder << instance.rowsPerImage;
    encoder << instance.buffer;
}

std::optional<WebKit::WebGPU::ImageCopyBuffer> ArgumentCoder<WebKit::WebGPU::ImageCopyBuffer>::decode(Decoder& decoder)
{
    auto offset = decoder.decode<WebCore::WebGPU::Size64>();
    auto bytesPerRow = decoder.decode<std::optional<WebCore::WebGPU::Size32>>();
    auto rowsPerImage = decoder.decode<std::optional<WebCore::WebGPU::Size32>>();
    auto buffer = decoder.decode<WebKit::WebGPUIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::ImageCopyBuffer {
            WebKit::WebGPU::ImageDataLayout {
                WTFMove(*offset),
                WTFMove(*bytesPerRow),
                WTFMove(*rowsPerImage)
            },
            WTFMove(*buffer)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::ImageCopyExternalImage>::encode(Encoder& encoder, const WebKit::WebGPU::ImageCopyExternalImage& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.origin)>, std::optional<WebKit::WebGPU::Origin2D>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.flipY)>, bool>);
    struct ShouldBeSameSizeAsImageCopyExternalImage : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::ImageCopyExternalImage>, false> {
        std::optional<WebKit::WebGPU::Origin2D> origin;
        bool flipY;
    };
    static_assert(sizeof(ShouldBeSameSizeAsImageCopyExternalImage) == sizeof(WebKit::WebGPU::ImageCopyExternalImage));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ImageCopyExternalImage, origin)
        , offsetof(WebKit::WebGPU::ImageCopyExternalImage, flipY)
    >::value);

    encoder << instance.origin;
    encoder << instance.flipY;
}

void ArgumentCoder<WebKit::WebGPU::ImageCopyExternalImage>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::ImageCopyExternalImage& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.origin)>, std::optional<WebKit::WebGPU::Origin2D>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.flipY)>, bool>);
    struct ShouldBeSameSizeAsImageCopyExternalImage : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::ImageCopyExternalImage>, false> {
        std::optional<WebKit::WebGPU::Origin2D> origin;
        bool flipY;
    };
    static_assert(sizeof(ShouldBeSameSizeAsImageCopyExternalImage) == sizeof(WebKit::WebGPU::ImageCopyExternalImage));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ImageCopyExternalImage, origin)
        , offsetof(WebKit::WebGPU::ImageCopyExternalImage, flipY)
    >::value);

    encoder << instance.origin;
    encoder << instance.flipY;
}

std::optional<WebKit::WebGPU::ImageCopyExternalImage> ArgumentCoder<WebKit::WebGPU::ImageCopyExternalImage>::decode(Decoder& decoder)
{
    auto origin = decoder.decode<std::optional<WebKit::WebGPU::Origin2D>>();
    auto flipY = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::ImageCopyExternalImage {
            WTFMove(*origin),
            WTFMove(*flipY)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::ImageCopyTexture>::encode(Encoder& encoder, const WebKit::WebGPU::ImageCopyTexture& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.texture)>, WebKit::WebGPUIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mipLevel)>, WebCore::WebGPU::IntegerCoordinate>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.origin)>, std::optional<WebKit::WebGPU::Origin3D>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.aspect)>, WebCore::WebGPU::TextureAspect>);
    struct ShouldBeSameSizeAsImageCopyTexture : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::ImageCopyTexture>, false> {
        WebKit::WebGPUIdentifier texture;
        WebCore::WebGPU::IntegerCoordinate mipLevel;
        std::optional<WebKit::WebGPU::Origin3D> origin;
        WebCore::WebGPU::TextureAspect aspect;
    };
    static_assert(sizeof(ShouldBeSameSizeAsImageCopyTexture) == sizeof(WebKit::WebGPU::ImageCopyTexture));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ImageCopyTexture, texture)
        , offsetof(WebKit::WebGPU::ImageCopyTexture, mipLevel)
        , offsetof(WebKit::WebGPU::ImageCopyTexture, origin)
        , offsetof(WebKit::WebGPU::ImageCopyTexture, aspect)
    >::value);

    encoder << instance.texture;
    encoder << instance.mipLevel;
    encoder << instance.origin;
    encoder << instance.aspect;
}

void ArgumentCoder<WebKit::WebGPU::ImageCopyTexture>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::ImageCopyTexture& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.texture)>, WebKit::WebGPUIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mipLevel)>, WebCore::WebGPU::IntegerCoordinate>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.origin)>, std::optional<WebKit::WebGPU::Origin3D>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.aspect)>, WebCore::WebGPU::TextureAspect>);
    struct ShouldBeSameSizeAsImageCopyTexture : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::ImageCopyTexture>, false> {
        WebKit::WebGPUIdentifier texture;
        WebCore::WebGPU::IntegerCoordinate mipLevel;
        std::optional<WebKit::WebGPU::Origin3D> origin;
        WebCore::WebGPU::TextureAspect aspect;
    };
    static_assert(sizeof(ShouldBeSameSizeAsImageCopyTexture) == sizeof(WebKit::WebGPU::ImageCopyTexture));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ImageCopyTexture, texture)
        , offsetof(WebKit::WebGPU::ImageCopyTexture, mipLevel)
        , offsetof(WebKit::WebGPU::ImageCopyTexture, origin)
        , offsetof(WebKit::WebGPU::ImageCopyTexture, aspect)
    >::value);

    encoder << instance.texture;
    encoder << instance.mipLevel;
    encoder << instance.origin;
    encoder << instance.aspect;
}

std::optional<WebKit::WebGPU::ImageCopyTexture> ArgumentCoder<WebKit::WebGPU::ImageCopyTexture>::decode(Decoder& decoder)
{
    auto texture = decoder.decode<WebKit::WebGPUIdentifier>();
    auto mipLevel = decoder.decode<WebCore::WebGPU::IntegerCoordinate>();
    auto origin = decoder.decode<std::optional<WebKit::WebGPU::Origin3D>>();
    auto aspect = decoder.decode<WebCore::WebGPU::TextureAspect>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::ImageCopyTexture {
            WTFMove(*texture),
            WTFMove(*mipLevel),
            WTFMove(*origin),
            WTFMove(*aspect)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::ImageCopyTextureTagged>::encode(Encoder& encoder, const WebKit::WebGPU::ImageCopyTextureTagged& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.texture)>, WebKit::WebGPUIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mipLevel)>, WebCore::WebGPU::IntegerCoordinate>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.origin)>, std::optional<WebKit::WebGPU::Origin3D>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.aspect)>, WebCore::WebGPU::TextureAspect>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ImageCopyTexture, texture)
        , offsetof(WebKit::WebGPU::ImageCopyTexture, mipLevel)
        , offsetof(WebKit::WebGPU::ImageCopyTexture, origin)
        , offsetof(WebKit::WebGPU::ImageCopyTexture, aspect)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorSpace)>, WebCore::WebGPU::PredefinedColorSpace>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.premultipliedAlpha)>, bool>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ImageCopyTextureTagged, colorSpace)
        , offsetof(WebKit::WebGPU::ImageCopyTextureTagged, premultipliedAlpha)
    >::value);

    encoder << instance.texture;
    encoder << instance.mipLevel;
    encoder << instance.origin;
    encoder << instance.aspect;
    encoder << instance.colorSpace;
    encoder << instance.premultipliedAlpha;
}

void ArgumentCoder<WebKit::WebGPU::ImageCopyTextureTagged>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::ImageCopyTextureTagged& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.texture)>, WebKit::WebGPUIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mipLevel)>, WebCore::WebGPU::IntegerCoordinate>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.origin)>, std::optional<WebKit::WebGPU::Origin3D>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.aspect)>, WebCore::WebGPU::TextureAspect>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ImageCopyTexture, texture)
        , offsetof(WebKit::WebGPU::ImageCopyTexture, mipLevel)
        , offsetof(WebKit::WebGPU::ImageCopyTexture, origin)
        , offsetof(WebKit::WebGPU::ImageCopyTexture, aspect)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorSpace)>, WebCore::WebGPU::PredefinedColorSpace>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.premultipliedAlpha)>, bool>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ImageCopyTextureTagged, colorSpace)
        , offsetof(WebKit::WebGPU::ImageCopyTextureTagged, premultipliedAlpha)
    >::value);

    encoder << instance.texture;
    encoder << instance.mipLevel;
    encoder << instance.origin;
    encoder << instance.aspect;
    encoder << instance.colorSpace;
    encoder << instance.premultipliedAlpha;
}

std::optional<WebKit::WebGPU::ImageCopyTextureTagged> ArgumentCoder<WebKit::WebGPU::ImageCopyTextureTagged>::decode(Decoder& decoder)
{
    auto texture = decoder.decode<WebKit::WebGPUIdentifier>();
    auto mipLevel = decoder.decode<WebCore::WebGPU::IntegerCoordinate>();
    auto origin = decoder.decode<std::optional<WebKit::WebGPU::Origin3D>>();
    auto aspect = decoder.decode<WebCore::WebGPU::TextureAspect>();
    auto colorSpace = decoder.decode<WebCore::WebGPU::PredefinedColorSpace>();
    auto premultipliedAlpha = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::ImageCopyTextureTagged {
            WebKit::WebGPU::ImageCopyTexture {
                WTFMove(*texture),
                WTFMove(*mipLevel),
                WTFMove(*origin),
                WTFMove(*aspect)
            },
            WTFMove(*colorSpace),
            WTFMove(*premultipliedAlpha)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::ImageDataLayout>::encode(Encoder& encoder, const WebKit::WebGPU::ImageDataLayout& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, WebCore::WebGPU::Size64>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bytesPerRow)>, std::optional<WebCore::WebGPU::Size32>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rowsPerImage)>, std::optional<WebCore::WebGPU::Size32>>);
    struct ShouldBeSameSizeAsImageDataLayout : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::ImageDataLayout>, false> {
        WebCore::WebGPU::Size64 offset;
        std::optional<WebCore::WebGPU::Size32> bytesPerRow;
        std::optional<WebCore::WebGPU::Size32> rowsPerImage;
    };
    static_assert(sizeof(ShouldBeSameSizeAsImageDataLayout) == sizeof(WebKit::WebGPU::ImageDataLayout));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ImageDataLayout, offset)
        , offsetof(WebKit::WebGPU::ImageDataLayout, bytesPerRow)
        , offsetof(WebKit::WebGPU::ImageDataLayout, rowsPerImage)
    >::value);

    encoder << instance.offset;
    encoder << instance.bytesPerRow;
    encoder << instance.rowsPerImage;
}

void ArgumentCoder<WebKit::WebGPU::ImageDataLayout>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::ImageDataLayout& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, WebCore::WebGPU::Size64>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bytesPerRow)>, std::optional<WebCore::WebGPU::Size32>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rowsPerImage)>, std::optional<WebCore::WebGPU::Size32>>);
    struct ShouldBeSameSizeAsImageDataLayout : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::ImageDataLayout>, false> {
        WebCore::WebGPU::Size64 offset;
        std::optional<WebCore::WebGPU::Size32> bytesPerRow;
        std::optional<WebCore::WebGPU::Size32> rowsPerImage;
    };
    static_assert(sizeof(ShouldBeSameSizeAsImageDataLayout) == sizeof(WebKit::WebGPU::ImageDataLayout));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ImageDataLayout, offset)
        , offsetof(WebKit::WebGPU::ImageDataLayout, bytesPerRow)
        , offsetof(WebKit::WebGPU::ImageDataLayout, rowsPerImage)
    >::value);

    encoder << instance.offset;
    encoder << instance.bytesPerRow;
    encoder << instance.rowsPerImage;
}

std::optional<WebKit::WebGPU::ImageDataLayout> ArgumentCoder<WebKit::WebGPU::ImageDataLayout>::decode(Decoder& decoder)
{
    auto offset = decoder.decode<WebCore::WebGPU::Size64>();
    auto bytesPerRow = decoder.decode<std::optional<WebCore::WebGPU::Size32>>();
    auto rowsPerImage = decoder.decode<std::optional<WebCore::WebGPU::Size32>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::ImageDataLayout {
            WTFMove(*offset),
            WTFMove(*bytesPerRow),
            WTFMove(*rowsPerImage)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::InternalError>::encode(Encoder& encoder, const WebKit::WebGPU::InternalError& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.message)>, String>);
    struct ShouldBeSameSizeAsInternalError : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::InternalError>, false> {
        String message;
    };
    static_assert(sizeof(ShouldBeSameSizeAsInternalError) == sizeof(WebKit::WebGPU::InternalError));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::InternalError, message)
    >::value);

    encoder << instance.message;
}

void ArgumentCoder<WebKit::WebGPU::InternalError>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::InternalError& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.message)>, String>);
    struct ShouldBeSameSizeAsInternalError : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::InternalError>, false> {
        String message;
    };
    static_assert(sizeof(ShouldBeSameSizeAsInternalError) == sizeof(WebKit::WebGPU::InternalError));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::InternalError, message)
    >::value);

    encoder << instance.message;
}

std::optional<WebKit::WebGPU::InternalError> ArgumentCoder<WebKit::WebGPU::InternalError>::decode(Decoder& decoder)
{
    auto message = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::InternalError {
            WTFMove(*message)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::MultisampleState>::encode(Encoder& encoder, const WebKit::WebGPU::MultisampleState& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.count)>, WebCore::WebGPU::Size32>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mask)>, WebCore::WebGPU::SampleMask>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.alphaToCoverageEnabled)>, bool>);
    struct ShouldBeSameSizeAsMultisampleState : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::MultisampleState>, false> {
        WebCore::WebGPU::Size32 count;
        WebCore::WebGPU::SampleMask mask;
        bool alphaToCoverageEnabled;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMultisampleState) == sizeof(WebKit::WebGPU::MultisampleState));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::MultisampleState, count)
        , offsetof(WebKit::WebGPU::MultisampleState, mask)
        , offsetof(WebKit::WebGPU::MultisampleState, alphaToCoverageEnabled)
    >::value);

    encoder << instance.count;
    encoder << instance.mask;
    encoder << instance.alphaToCoverageEnabled;
}

void ArgumentCoder<WebKit::WebGPU::MultisampleState>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::MultisampleState& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.count)>, WebCore::WebGPU::Size32>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mask)>, WebCore::WebGPU::SampleMask>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.alphaToCoverageEnabled)>, bool>);
    struct ShouldBeSameSizeAsMultisampleState : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::MultisampleState>, false> {
        WebCore::WebGPU::Size32 count;
        WebCore::WebGPU::SampleMask mask;
        bool alphaToCoverageEnabled;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMultisampleState) == sizeof(WebKit::WebGPU::MultisampleState));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::MultisampleState, count)
        , offsetof(WebKit::WebGPU::MultisampleState, mask)
        , offsetof(WebKit::WebGPU::MultisampleState, alphaToCoverageEnabled)
    >::value);

    encoder << instance.count;
    encoder << instance.mask;
    encoder << instance.alphaToCoverageEnabled;
}

std::optional<WebKit::WebGPU::MultisampleState> ArgumentCoder<WebKit::WebGPU::MultisampleState>::decode(Decoder& decoder)
{
    auto count = decoder.decode<WebCore::WebGPU::Size32>();
    auto mask = decoder.decode<WebCore::WebGPU::SampleMask>();
    auto alphaToCoverageEnabled = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::MultisampleState {
            WTFMove(*count),
            WTFMove(*mask),
            WTFMove(*alphaToCoverageEnabled)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::ObjectDescriptorBase>::encode(Encoder& encoder, const WebKit::WebGPU::ObjectDescriptorBase& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    struct ShouldBeSameSizeAsObjectDescriptorBase : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::ObjectDescriptorBase>, false> {
        String label;
    };
    static_assert(sizeof(ShouldBeSameSizeAsObjectDescriptorBase) == sizeof(WebKit::WebGPU::ObjectDescriptorBase));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    encoder << instance.label;
}

void ArgumentCoder<WebKit::WebGPU::ObjectDescriptorBase>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::ObjectDescriptorBase& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    struct ShouldBeSameSizeAsObjectDescriptorBase : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::ObjectDescriptorBase>, false> {
        String label;
    };
    static_assert(sizeof(ShouldBeSameSizeAsObjectDescriptorBase) == sizeof(WebKit::WebGPU::ObjectDescriptorBase));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    encoder << instance.label;
}

std::optional<WebKit::WebGPU::ObjectDescriptorBase> ArgumentCoder<WebKit::WebGPU::ObjectDescriptorBase>::decode(Decoder& decoder)
{
    auto label = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::ObjectDescriptorBase {
            WTFMove(*label)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::Origin2DDict>::encode(Encoder& encoder, const WebKit::WebGPU::Origin2DDict& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.x)>, WebCore::WebGPU::IntegerCoordinate>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.y)>, WebCore::WebGPU::IntegerCoordinate>);
    struct ShouldBeSameSizeAsOrigin2DDict : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::Origin2DDict>, false> {
        WebCore::WebGPU::IntegerCoordinate x;
        WebCore::WebGPU::IntegerCoordinate y;
    };
    static_assert(sizeof(ShouldBeSameSizeAsOrigin2DDict) == sizeof(WebKit::WebGPU::Origin2DDict));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::Origin2DDict, x)
        , offsetof(WebKit::WebGPU::Origin2DDict, y)
    >::value);

    encoder << instance.x;
    encoder << instance.y;
}

void ArgumentCoder<WebKit::WebGPU::Origin2DDict>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::Origin2DDict& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.x)>, WebCore::WebGPU::IntegerCoordinate>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.y)>, WebCore::WebGPU::IntegerCoordinate>);
    struct ShouldBeSameSizeAsOrigin2DDict : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::Origin2DDict>, false> {
        WebCore::WebGPU::IntegerCoordinate x;
        WebCore::WebGPU::IntegerCoordinate y;
    };
    static_assert(sizeof(ShouldBeSameSizeAsOrigin2DDict) == sizeof(WebKit::WebGPU::Origin2DDict));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::Origin2DDict, x)
        , offsetof(WebKit::WebGPU::Origin2DDict, y)
    >::value);

    encoder << instance.x;
    encoder << instance.y;
}

std::optional<WebKit::WebGPU::Origin2DDict> ArgumentCoder<WebKit::WebGPU::Origin2DDict>::decode(Decoder& decoder)
{
    auto x = decoder.decode<WebCore::WebGPU::IntegerCoordinate>();
    auto y = decoder.decode<WebCore::WebGPU::IntegerCoordinate>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::Origin2DDict {
            WTFMove(*x),
            WTFMove(*y)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::Origin3DDict>::encode(Encoder& encoder, const WebKit::WebGPU::Origin3DDict& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.x)>, WebCore::WebGPU::IntegerCoordinate>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.y)>, WebCore::WebGPU::IntegerCoordinate>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.z)>, WebCore::WebGPU::IntegerCoordinate>);
    struct ShouldBeSameSizeAsOrigin3DDict : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::Origin3DDict>, false> {
        WebCore::WebGPU::IntegerCoordinate x;
        WebCore::WebGPU::IntegerCoordinate y;
        WebCore::WebGPU::IntegerCoordinate z;
    };
    static_assert(sizeof(ShouldBeSameSizeAsOrigin3DDict) == sizeof(WebKit::WebGPU::Origin3DDict));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::Origin3DDict, x)
        , offsetof(WebKit::WebGPU::Origin3DDict, y)
        , offsetof(WebKit::WebGPU::Origin3DDict, z)
    >::value);

    encoder << instance.x;
    encoder << instance.y;
    encoder << instance.z;
}

void ArgumentCoder<WebKit::WebGPU::Origin3DDict>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::Origin3DDict& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.x)>, WebCore::WebGPU::IntegerCoordinate>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.y)>, WebCore::WebGPU::IntegerCoordinate>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.z)>, WebCore::WebGPU::IntegerCoordinate>);
    struct ShouldBeSameSizeAsOrigin3DDict : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::Origin3DDict>, false> {
        WebCore::WebGPU::IntegerCoordinate x;
        WebCore::WebGPU::IntegerCoordinate y;
        WebCore::WebGPU::IntegerCoordinate z;
    };
    static_assert(sizeof(ShouldBeSameSizeAsOrigin3DDict) == sizeof(WebKit::WebGPU::Origin3DDict));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::Origin3DDict, x)
        , offsetof(WebKit::WebGPU::Origin3DDict, y)
        , offsetof(WebKit::WebGPU::Origin3DDict, z)
    >::value);

    encoder << instance.x;
    encoder << instance.y;
    encoder << instance.z;
}

std::optional<WebKit::WebGPU::Origin3DDict> ArgumentCoder<WebKit::WebGPU::Origin3DDict>::decode(Decoder& decoder)
{
    auto x = decoder.decode<WebCore::WebGPU::IntegerCoordinate>();
    auto y = decoder.decode<WebCore::WebGPU::IntegerCoordinate>();
    auto z = decoder.decode<WebCore::WebGPU::IntegerCoordinate>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::Origin3DDict {
            WTFMove(*x),
            WTFMove(*y),
            WTFMove(*z)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::OutOfMemoryError>::encode(Encoder& encoder, const WebKit::WebGPU::OutOfMemoryError& instance)
{
    struct ShouldBeSameSizeAsOutOfMemoryError : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::OutOfMemoryError>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsOutOfMemoryError) == sizeof(WebKit::WebGPU::OutOfMemoryError));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

void ArgumentCoder<WebKit::WebGPU::OutOfMemoryError>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::OutOfMemoryError& instance)
{
    struct ShouldBeSameSizeAsOutOfMemoryError : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::OutOfMemoryError>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsOutOfMemoryError) == sizeof(WebKit::WebGPU::OutOfMemoryError));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebKit::WebGPU::OutOfMemoryError> ArgumentCoder<WebKit::WebGPU::OutOfMemoryError>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::OutOfMemoryError {
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::PipelineDescriptorBase>::encode(Encoder& encoder, const WebKit::WebGPU::PipelineDescriptorBase& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.layout)>, Markable<WebKit::WebGPUIdentifier>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::PipelineDescriptorBase, layout)
    >::value);

    encoder << instance.label;
    encoder << instance.layout;
}

void ArgumentCoder<WebKit::WebGPU::PipelineDescriptorBase>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::PipelineDescriptorBase& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.layout)>, Markable<WebKit::WebGPUIdentifier>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::PipelineDescriptorBase, layout)
    >::value);

    encoder << instance.label;
    encoder << instance.layout;
}

std::optional<WebKit::WebGPU::PipelineDescriptorBase> ArgumentCoder<WebKit::WebGPU::PipelineDescriptorBase>::decode(Decoder& decoder)
{
    auto label = decoder.decode<String>();
    auto layout = decoder.decode<Markable<WebKit::WebGPUIdentifier>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::PipelineDescriptorBase {
            WebKit::WebGPU::ObjectDescriptorBase {
                WTFMove(*label)
            },
            WTFMove(*layout)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::PipelineLayoutDescriptor>::encode(Encoder& encoder, const WebKit::WebGPU::PipelineLayoutDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bindGroupLayouts)>, std::optional<Vector<WebKit::WebGPUIdentifier>>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::PipelineLayoutDescriptor, bindGroupLayouts)
    >::value);

    encoder << instance.label;
    encoder << instance.bindGroupLayouts;
}

void ArgumentCoder<WebKit::WebGPU::PipelineLayoutDescriptor>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::PipelineLayoutDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bindGroupLayouts)>, std::optional<Vector<WebKit::WebGPUIdentifier>>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::PipelineLayoutDescriptor, bindGroupLayouts)
    >::value);

    encoder << instance.label;
    encoder << instance.bindGroupLayouts;
}

std::optional<WebKit::WebGPU::PipelineLayoutDescriptor> ArgumentCoder<WebKit::WebGPU::PipelineLayoutDescriptor>::decode(Decoder& decoder)
{
    auto label = decoder.decode<String>();
    auto bindGroupLayouts = decoder.decode<std::optional<Vector<WebKit::WebGPUIdentifier>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::PipelineLayoutDescriptor {
            WebKit::WebGPU::ObjectDescriptorBase {
                WTFMove(*label)
            },
            WTFMove(*bindGroupLayouts)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::PresentationContextDescriptor>::encode(Encoder& encoder, const WebKit::WebGPU::PresentationContextDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.compositorIntegration)>, WebKit::WebGPUIdentifier>);
    struct ShouldBeSameSizeAsPresentationContextDescriptor : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::PresentationContextDescriptor>, false> {
        WebKit::WebGPUIdentifier compositorIntegration;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPresentationContextDescriptor) == sizeof(WebKit::WebGPU::PresentationContextDescriptor));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::PresentationContextDescriptor, compositorIntegration)
    >::value);

    encoder << instance.compositorIntegration;
}

void ArgumentCoder<WebKit::WebGPU::PresentationContextDescriptor>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::PresentationContextDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.compositorIntegration)>, WebKit::WebGPUIdentifier>);
    struct ShouldBeSameSizeAsPresentationContextDescriptor : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::PresentationContextDescriptor>, false> {
        WebKit::WebGPUIdentifier compositorIntegration;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPresentationContextDescriptor) == sizeof(WebKit::WebGPU::PresentationContextDescriptor));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::PresentationContextDescriptor, compositorIntegration)
    >::value);

    encoder << instance.compositorIntegration;
}

std::optional<WebKit::WebGPU::PresentationContextDescriptor> ArgumentCoder<WebKit::WebGPU::PresentationContextDescriptor>::decode(Decoder& decoder)
{
    auto compositorIntegration = decoder.decode<WebKit::WebGPUIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::PresentationContextDescriptor {
            WTFMove(*compositorIntegration)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::PrimitiveState>::encode(Encoder& encoder, const WebKit::WebGPU::PrimitiveState& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.topology)>, WebCore::WebGPU::PrimitiveTopology>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stripIndexFormat)>, std::optional<WebCore::WebGPU::IndexFormat>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frontFace)>, WebCore::WebGPU::FrontFace>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cullMode)>, WebCore::WebGPU::CullMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.unclippedDepth)>, bool>);
    struct ShouldBeSameSizeAsPrimitiveState : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::PrimitiveState>, false> {
        WebCore::WebGPU::PrimitiveTopology topology;
        std::optional<WebCore::WebGPU::IndexFormat> stripIndexFormat;
        WebCore::WebGPU::FrontFace frontFace;
        WebCore::WebGPU::CullMode cullMode;
        bool unclippedDepth;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPrimitiveState) == sizeof(WebKit::WebGPU::PrimitiveState));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::PrimitiveState, topology)
        , offsetof(WebKit::WebGPU::PrimitiveState, stripIndexFormat)
        , offsetof(WebKit::WebGPU::PrimitiveState, frontFace)
        , offsetof(WebKit::WebGPU::PrimitiveState, cullMode)
        , offsetof(WebKit::WebGPU::PrimitiveState, unclippedDepth)
    >::value);

    encoder << instance.topology;
    encoder << instance.stripIndexFormat;
    encoder << instance.frontFace;
    encoder << instance.cullMode;
    encoder << instance.unclippedDepth;
}

void ArgumentCoder<WebKit::WebGPU::PrimitiveState>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::PrimitiveState& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.topology)>, WebCore::WebGPU::PrimitiveTopology>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stripIndexFormat)>, std::optional<WebCore::WebGPU::IndexFormat>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frontFace)>, WebCore::WebGPU::FrontFace>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cullMode)>, WebCore::WebGPU::CullMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.unclippedDepth)>, bool>);
    struct ShouldBeSameSizeAsPrimitiveState : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::PrimitiveState>, false> {
        WebCore::WebGPU::PrimitiveTopology topology;
        std::optional<WebCore::WebGPU::IndexFormat> stripIndexFormat;
        WebCore::WebGPU::FrontFace frontFace;
        WebCore::WebGPU::CullMode cullMode;
        bool unclippedDepth;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPrimitiveState) == sizeof(WebKit::WebGPU::PrimitiveState));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::PrimitiveState, topology)
        , offsetof(WebKit::WebGPU::PrimitiveState, stripIndexFormat)
        , offsetof(WebKit::WebGPU::PrimitiveState, frontFace)
        , offsetof(WebKit::WebGPU::PrimitiveState, cullMode)
        , offsetof(WebKit::WebGPU::PrimitiveState, unclippedDepth)
    >::value);

    encoder << instance.topology;
    encoder << instance.stripIndexFormat;
    encoder << instance.frontFace;
    encoder << instance.cullMode;
    encoder << instance.unclippedDepth;
}

std::optional<WebKit::WebGPU::PrimitiveState> ArgumentCoder<WebKit::WebGPU::PrimitiveState>::decode(Decoder& decoder)
{
    auto topology = decoder.decode<WebCore::WebGPU::PrimitiveTopology>();
    auto stripIndexFormat = decoder.decode<std::optional<WebCore::WebGPU::IndexFormat>>();
    auto frontFace = decoder.decode<WebCore::WebGPU::FrontFace>();
    auto cullMode = decoder.decode<WebCore::WebGPU::CullMode>();
    auto unclippedDepth = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::PrimitiveState {
            WTFMove(*topology),
            WTFMove(*stripIndexFormat),
            WTFMove(*frontFace),
            WTFMove(*cullMode),
            WTFMove(*unclippedDepth)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::ProgrammableStage>::encode(Encoder& encoder, const WebKit::WebGPU::ProgrammableStage& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.module)>, WebKit::WebGPUIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.entryPoint)>, std::optional<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.constants)>, Vector<KeyValuePair<String, double>>>);
    struct ShouldBeSameSizeAsProgrammableStage : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::ProgrammableStage>, false> {
        WebKit::WebGPUIdentifier module;
        std::optional<String> entryPoint;
        Vector<KeyValuePair<String, double>> constants;
    };
    static_assert(sizeof(ShouldBeSameSizeAsProgrammableStage) == sizeof(WebKit::WebGPU::ProgrammableStage));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ProgrammableStage, module)
        , offsetof(WebKit::WebGPU::ProgrammableStage, entryPoint)
        , offsetof(WebKit::WebGPU::ProgrammableStage, constants)
    >::value);

    encoder << instance.module;
    encoder << instance.entryPoint;
    encoder << instance.constants;
}

void ArgumentCoder<WebKit::WebGPU::ProgrammableStage>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::ProgrammableStage& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.module)>, WebKit::WebGPUIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.entryPoint)>, std::optional<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.constants)>, Vector<KeyValuePair<String, double>>>);
    struct ShouldBeSameSizeAsProgrammableStage : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::ProgrammableStage>, false> {
        WebKit::WebGPUIdentifier module;
        std::optional<String> entryPoint;
        Vector<KeyValuePair<String, double>> constants;
    };
    static_assert(sizeof(ShouldBeSameSizeAsProgrammableStage) == sizeof(WebKit::WebGPU::ProgrammableStage));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ProgrammableStage, module)
        , offsetof(WebKit::WebGPU::ProgrammableStage, entryPoint)
        , offsetof(WebKit::WebGPU::ProgrammableStage, constants)
    >::value);

    encoder << instance.module;
    encoder << instance.entryPoint;
    encoder << instance.constants;
}

std::optional<WebKit::WebGPU::ProgrammableStage> ArgumentCoder<WebKit::WebGPU::ProgrammableStage>::decode(Decoder& decoder)
{
    auto module = decoder.decode<WebKit::WebGPUIdentifier>();
    auto entryPoint = decoder.decode<std::optional<String>>();
    auto constants = decoder.decode<Vector<KeyValuePair<String, double>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::ProgrammableStage {
            WTFMove(*module),
            WTFMove(*entryPoint),
            WTFMove(*constants)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::QuerySetDescriptor>::encode(Encoder& encoder, const WebKit::WebGPU::QuerySetDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::WebGPU::QueryType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.count)>, WebCore::WebGPU::Size32>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::QuerySetDescriptor, type)
        , offsetof(WebKit::WebGPU::QuerySetDescriptor, count)
    >::value);

    encoder << instance.label;
    encoder << instance.type;
    encoder << instance.count;
}

void ArgumentCoder<WebKit::WebGPU::QuerySetDescriptor>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::QuerySetDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::WebGPU::QueryType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.count)>, WebCore::WebGPU::Size32>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::QuerySetDescriptor, type)
        , offsetof(WebKit::WebGPU::QuerySetDescriptor, count)
    >::value);

    encoder << instance.label;
    encoder << instance.type;
    encoder << instance.count;
}

std::optional<WebKit::WebGPU::QuerySetDescriptor> ArgumentCoder<WebKit::WebGPU::QuerySetDescriptor>::decode(Decoder& decoder)
{
    auto label = decoder.decode<String>();
    auto type = decoder.decode<WebCore::WebGPU::QueryType>();
    auto count = decoder.decode<WebCore::WebGPU::Size32>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::QuerySetDescriptor {
            WebKit::WebGPU::ObjectDescriptorBase {
                WTFMove(*label)
            },
            WTFMove(*type),
            WTFMove(*count)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::RenderBundleDescriptor>::encode(Encoder& encoder, const WebKit::WebGPU::RenderBundleDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(MembersInCorrectOrder < 0
    >::value);

    encoder << instance.label;
}

void ArgumentCoder<WebKit::WebGPU::RenderBundleDescriptor>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::RenderBundleDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(MembersInCorrectOrder < 0
    >::value);

    encoder << instance.label;
}

std::optional<WebKit::WebGPU::RenderBundleDescriptor> ArgumentCoder<WebKit::WebGPU::RenderBundleDescriptor>::decode(Decoder& decoder)
{
    auto label = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::RenderBundleDescriptor {
            WebKit::WebGPU::ObjectDescriptorBase {
                WTFMove(*label)
            }
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::RenderBundleEncoderDescriptor>::encode(Encoder& encoder, const WebKit::WebGPU::RenderBundleEncoderDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorFormats)>, Vector<std::optional<WebCore::WebGPU::TextureFormat>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthStencilFormat)>, std::optional<WebCore::WebGPU::TextureFormat>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sampleCount)>, WebCore::WebGPU::Size32>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::RenderPassLayout, colorFormats)
        , offsetof(WebKit::WebGPU::RenderPassLayout, depthStencilFormat)
        , offsetof(WebKit::WebGPU::RenderPassLayout, sampleCount)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthReadOnly)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stencilReadOnly)>, bool>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::RenderBundleEncoderDescriptor, depthReadOnly)
        , offsetof(WebKit::WebGPU::RenderBundleEncoderDescriptor, stencilReadOnly)
    >::value);

    encoder << instance.label;
    encoder << instance.colorFormats;
    encoder << instance.depthStencilFormat;
    encoder << instance.sampleCount;
    encoder << instance.depthReadOnly;
    encoder << instance.stencilReadOnly;
}

void ArgumentCoder<WebKit::WebGPU::RenderBundleEncoderDescriptor>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::RenderBundleEncoderDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorFormats)>, Vector<std::optional<WebCore::WebGPU::TextureFormat>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthStencilFormat)>, std::optional<WebCore::WebGPU::TextureFormat>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sampleCount)>, WebCore::WebGPU::Size32>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::RenderPassLayout, colorFormats)
        , offsetof(WebKit::WebGPU::RenderPassLayout, depthStencilFormat)
        , offsetof(WebKit::WebGPU::RenderPassLayout, sampleCount)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthReadOnly)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stencilReadOnly)>, bool>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::RenderBundleEncoderDescriptor, depthReadOnly)
        , offsetof(WebKit::WebGPU::RenderBundleEncoderDescriptor, stencilReadOnly)
    >::value);

    encoder << instance.label;
    encoder << instance.colorFormats;
    encoder << instance.depthStencilFormat;
    encoder << instance.sampleCount;
    encoder << instance.depthReadOnly;
    encoder << instance.stencilReadOnly;
}

std::optional<WebKit::WebGPU::RenderBundleEncoderDescriptor> ArgumentCoder<WebKit::WebGPU::RenderBundleEncoderDescriptor>::decode(Decoder& decoder)
{
    auto label = decoder.decode<String>();
    auto colorFormats = decoder.decode<Vector<std::optional<WebCore::WebGPU::TextureFormat>>>();
    auto depthStencilFormat = decoder.decode<std::optional<WebCore::WebGPU::TextureFormat>>();
    auto sampleCount = decoder.decode<WebCore::WebGPU::Size32>();
    auto depthReadOnly = decoder.decode<bool>();
    auto stencilReadOnly = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::RenderBundleEncoderDescriptor {
            WebKit::WebGPU::RenderPassLayout {
                WebKit::WebGPU::ObjectDescriptorBase {
                    WTFMove(*label)
                },
                WTFMove(*colorFormats),
                WTFMove(*depthStencilFormat),
                WTFMove(*sampleCount)
            },
            WTFMove(*depthReadOnly),
            WTFMove(*stencilReadOnly)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::RenderPassColorAttachment>::encode(Encoder& encoder, const WebKit::WebGPU::RenderPassColorAttachment& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.view)>, WebKit::WebGPUIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthSlice)>, std::optional<WebCore::WebGPU::IntegerCoordinate>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.resolveTarget)>, std::optional<WebKit::WebGPUIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.clearValue)>, std::optional<WebKit::WebGPU::Color>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.loadOp)>, WebCore::WebGPU::LoadOp>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.storeOp)>, WebCore::WebGPU::StoreOp>);
    struct ShouldBeSameSizeAsRenderPassColorAttachment : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::RenderPassColorAttachment>, false> {
        WebKit::WebGPUIdentifier view;
        std::optional<WebCore::WebGPU::IntegerCoordinate> depthSlice;
        std::optional<WebKit::WebGPUIdentifier> resolveTarget;
        std::optional<WebKit::WebGPU::Color> clearValue;
        WebCore::WebGPU::LoadOp loadOp;
        WebCore::WebGPU::StoreOp storeOp;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRenderPassColorAttachment) == sizeof(WebKit::WebGPU::RenderPassColorAttachment));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::RenderPassColorAttachment, view)
        , offsetof(WebKit::WebGPU::RenderPassColorAttachment, depthSlice)
        , offsetof(WebKit::WebGPU::RenderPassColorAttachment, resolveTarget)
        , offsetof(WebKit::WebGPU::RenderPassColorAttachment, clearValue)
        , offsetof(WebKit::WebGPU::RenderPassColorAttachment, loadOp)
        , offsetof(WebKit::WebGPU::RenderPassColorAttachment, storeOp)
    >::value);

    encoder << instance.view;
    encoder << instance.depthSlice;
    encoder << instance.resolveTarget;
    encoder << instance.clearValue;
    encoder << instance.loadOp;
    encoder << instance.storeOp;
}

void ArgumentCoder<WebKit::WebGPU::RenderPassColorAttachment>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::RenderPassColorAttachment& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.view)>, WebKit::WebGPUIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthSlice)>, std::optional<WebCore::WebGPU::IntegerCoordinate>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.resolveTarget)>, std::optional<WebKit::WebGPUIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.clearValue)>, std::optional<WebKit::WebGPU::Color>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.loadOp)>, WebCore::WebGPU::LoadOp>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.storeOp)>, WebCore::WebGPU::StoreOp>);
    struct ShouldBeSameSizeAsRenderPassColorAttachment : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::RenderPassColorAttachment>, false> {
        WebKit::WebGPUIdentifier view;
        std::optional<WebCore::WebGPU::IntegerCoordinate> depthSlice;
        std::optional<WebKit::WebGPUIdentifier> resolveTarget;
        std::optional<WebKit::WebGPU::Color> clearValue;
        WebCore::WebGPU::LoadOp loadOp;
        WebCore::WebGPU::StoreOp storeOp;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRenderPassColorAttachment) == sizeof(WebKit::WebGPU::RenderPassColorAttachment));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::RenderPassColorAttachment, view)
        , offsetof(WebKit::WebGPU::RenderPassColorAttachment, depthSlice)
        , offsetof(WebKit::WebGPU::RenderPassColorAttachment, resolveTarget)
        , offsetof(WebKit::WebGPU::RenderPassColorAttachment, clearValue)
        , offsetof(WebKit::WebGPU::RenderPassColorAttachment, loadOp)
        , offsetof(WebKit::WebGPU::RenderPassColorAttachment, storeOp)
    >::value);

    encoder << instance.view;
    encoder << instance.depthSlice;
    encoder << instance.resolveTarget;
    encoder << instance.clearValue;
    encoder << instance.loadOp;
    encoder << instance.storeOp;
}

std::optional<WebKit::WebGPU::RenderPassColorAttachment> ArgumentCoder<WebKit::WebGPU::RenderPassColorAttachment>::decode(Decoder& decoder)
{
    auto view = decoder.decode<WebKit::WebGPUIdentifier>();
    auto depthSlice = decoder.decode<std::optional<WebCore::WebGPU::IntegerCoordinate>>();
    auto resolveTarget = decoder.decode<std::optional<WebKit::WebGPUIdentifier>>();
    auto clearValue = decoder.decode<std::optional<WebKit::WebGPU::Color>>();
    auto loadOp = decoder.decode<WebCore::WebGPU::LoadOp>();
    auto storeOp = decoder.decode<WebCore::WebGPU::StoreOp>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::RenderPassColorAttachment {
            WTFMove(*view),
            WTFMove(*depthSlice),
            WTFMove(*resolveTarget),
            WTFMove(*clearValue),
            WTFMove(*loadOp),
            WTFMove(*storeOp)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::RenderPassDepthStencilAttachment>::encode(Encoder& encoder, const WebKit::WebGPU::RenderPassDepthStencilAttachment& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.view)>, WebKit::WebGPUIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthClearValue)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthLoadOp)>, std::optional<WebCore::WebGPU::LoadOp>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthStoreOp)>, std::optional<WebCore::WebGPU::StoreOp>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthReadOnly)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stencilClearValue)>, WebCore::WebGPU::StencilValue>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stencilLoadOp)>, std::optional<WebCore::WebGPU::LoadOp>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stencilStoreOp)>, std::optional<WebCore::WebGPU::StoreOp>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stencilReadOnly)>, bool>);
    struct ShouldBeSameSizeAsRenderPassDepthStencilAttachment : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::RenderPassDepthStencilAttachment>, false> {
        WebKit::WebGPUIdentifier view;
        float depthClearValue;
        std::optional<WebCore::WebGPU::LoadOp> depthLoadOp;
        std::optional<WebCore::WebGPU::StoreOp> depthStoreOp;
        bool depthReadOnly;
        WebCore::WebGPU::StencilValue stencilClearValue;
        std::optional<WebCore::WebGPU::LoadOp> stencilLoadOp;
        std::optional<WebCore::WebGPU::StoreOp> stencilStoreOp;
        bool stencilReadOnly;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRenderPassDepthStencilAttachment) == sizeof(WebKit::WebGPU::RenderPassDepthStencilAttachment));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::RenderPassDepthStencilAttachment, view)
        , offsetof(WebKit::WebGPU::RenderPassDepthStencilAttachment, depthClearValue)
        , offsetof(WebKit::WebGPU::RenderPassDepthStencilAttachment, depthLoadOp)
        , offsetof(WebKit::WebGPU::RenderPassDepthStencilAttachment, depthStoreOp)
        , offsetof(WebKit::WebGPU::RenderPassDepthStencilAttachment, depthReadOnly)
        , offsetof(WebKit::WebGPU::RenderPassDepthStencilAttachment, stencilClearValue)
        , offsetof(WebKit::WebGPU::RenderPassDepthStencilAttachment, stencilLoadOp)
        , offsetof(WebKit::WebGPU::RenderPassDepthStencilAttachment, stencilStoreOp)
        , offsetof(WebKit::WebGPU::RenderPassDepthStencilAttachment, stencilReadOnly)
    >::value);

    encoder << instance.view;
    encoder << instance.depthClearValue;
    encoder << instance.depthLoadOp;
    encoder << instance.depthStoreOp;
    encoder << instance.depthReadOnly;
    encoder << instance.stencilClearValue;
    encoder << instance.stencilLoadOp;
    encoder << instance.stencilStoreOp;
    encoder << instance.stencilReadOnly;
}

void ArgumentCoder<WebKit::WebGPU::RenderPassDepthStencilAttachment>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::RenderPassDepthStencilAttachment& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.view)>, WebKit::WebGPUIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthClearValue)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthLoadOp)>, std::optional<WebCore::WebGPU::LoadOp>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthStoreOp)>, std::optional<WebCore::WebGPU::StoreOp>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthReadOnly)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stencilClearValue)>, WebCore::WebGPU::StencilValue>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stencilLoadOp)>, std::optional<WebCore::WebGPU::LoadOp>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stencilStoreOp)>, std::optional<WebCore::WebGPU::StoreOp>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stencilReadOnly)>, bool>);
    struct ShouldBeSameSizeAsRenderPassDepthStencilAttachment : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::RenderPassDepthStencilAttachment>, false> {
        WebKit::WebGPUIdentifier view;
        float depthClearValue;
        std::optional<WebCore::WebGPU::LoadOp> depthLoadOp;
        std::optional<WebCore::WebGPU::StoreOp> depthStoreOp;
        bool depthReadOnly;
        WebCore::WebGPU::StencilValue stencilClearValue;
        std::optional<WebCore::WebGPU::LoadOp> stencilLoadOp;
        std::optional<WebCore::WebGPU::StoreOp> stencilStoreOp;
        bool stencilReadOnly;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRenderPassDepthStencilAttachment) == sizeof(WebKit::WebGPU::RenderPassDepthStencilAttachment));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::RenderPassDepthStencilAttachment, view)
        , offsetof(WebKit::WebGPU::RenderPassDepthStencilAttachment, depthClearValue)
        , offsetof(WebKit::WebGPU::RenderPassDepthStencilAttachment, depthLoadOp)
        , offsetof(WebKit::WebGPU::RenderPassDepthStencilAttachment, depthStoreOp)
        , offsetof(WebKit::WebGPU::RenderPassDepthStencilAttachment, depthReadOnly)
        , offsetof(WebKit::WebGPU::RenderPassDepthStencilAttachment, stencilClearValue)
        , offsetof(WebKit::WebGPU::RenderPassDepthStencilAttachment, stencilLoadOp)
        , offsetof(WebKit::WebGPU::RenderPassDepthStencilAttachment, stencilStoreOp)
        , offsetof(WebKit::WebGPU::RenderPassDepthStencilAttachment, stencilReadOnly)
    >::value);

    encoder << instance.view;
    encoder << instance.depthClearValue;
    encoder << instance.depthLoadOp;
    encoder << instance.depthStoreOp;
    encoder << instance.depthReadOnly;
    encoder << instance.stencilClearValue;
    encoder << instance.stencilLoadOp;
    encoder << instance.stencilStoreOp;
    encoder << instance.stencilReadOnly;
}

std::optional<WebKit::WebGPU::RenderPassDepthStencilAttachment> ArgumentCoder<WebKit::WebGPU::RenderPassDepthStencilAttachment>::decode(Decoder& decoder)
{
    auto view = decoder.decode<WebKit::WebGPUIdentifier>();
    auto depthClearValue = decoder.decode<float>();
    auto depthLoadOp = decoder.decode<std::optional<WebCore::WebGPU::LoadOp>>();
    auto depthStoreOp = decoder.decode<std::optional<WebCore::WebGPU::StoreOp>>();
    auto depthReadOnly = decoder.decode<bool>();
    auto stencilClearValue = decoder.decode<WebCore::WebGPU::StencilValue>();
    auto stencilLoadOp = decoder.decode<std::optional<WebCore::WebGPU::LoadOp>>();
    auto stencilStoreOp = decoder.decode<std::optional<WebCore::WebGPU::StoreOp>>();
    auto stencilReadOnly = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::RenderPassDepthStencilAttachment {
            WTFMove(*view),
            WTFMove(*depthClearValue),
            WTFMove(*depthLoadOp),
            WTFMove(*depthStoreOp),
            WTFMove(*depthReadOnly),
            WTFMove(*stencilClearValue),
            WTFMove(*stencilLoadOp),
            WTFMove(*stencilStoreOp),
            WTFMove(*stencilReadOnly)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::RenderPassDescriptor>::encode(Encoder& encoder, const WebKit::WebGPU::RenderPassDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorAttachments)>, Vector<std::optional<WebKit::WebGPU::RenderPassColorAttachment>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthStencilAttachment)>, std::optional<WebKit::WebGPU::RenderPassDepthStencilAttachment>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.occlusionQuerySet)>, std::optional<WebKit::WebGPUIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timestampWrites)>, std::optional<WebKit::WebGPU::RenderPassTimestampWrites>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxDrawCount)>, std::optional<uint64_t>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::RenderPassDescriptor, colorAttachments)
        , offsetof(WebKit::WebGPU::RenderPassDescriptor, depthStencilAttachment)
        , offsetof(WebKit::WebGPU::RenderPassDescriptor, occlusionQuerySet)
        , offsetof(WebKit::WebGPU::RenderPassDescriptor, timestampWrites)
        , offsetof(WebKit::WebGPU::RenderPassDescriptor, maxDrawCount)
    >::value);

    encoder << instance.label;
    encoder << instance.colorAttachments;
    encoder << instance.depthStencilAttachment;
    encoder << instance.occlusionQuerySet;
    encoder << instance.timestampWrites;
    encoder << instance.maxDrawCount;
}

void ArgumentCoder<WebKit::WebGPU::RenderPassDescriptor>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::RenderPassDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorAttachments)>, Vector<std::optional<WebKit::WebGPU::RenderPassColorAttachment>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthStencilAttachment)>, std::optional<WebKit::WebGPU::RenderPassDepthStencilAttachment>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.occlusionQuerySet)>, std::optional<WebKit::WebGPUIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timestampWrites)>, std::optional<WebKit::WebGPU::RenderPassTimestampWrites>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxDrawCount)>, std::optional<uint64_t>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::RenderPassDescriptor, colorAttachments)
        , offsetof(WebKit::WebGPU::RenderPassDescriptor, depthStencilAttachment)
        , offsetof(WebKit::WebGPU::RenderPassDescriptor, occlusionQuerySet)
        , offsetof(WebKit::WebGPU::RenderPassDescriptor, timestampWrites)
        , offsetof(WebKit::WebGPU::RenderPassDescriptor, maxDrawCount)
    >::value);

    encoder << instance.label;
    encoder << instance.colorAttachments;
    encoder << instance.depthStencilAttachment;
    encoder << instance.occlusionQuerySet;
    encoder << instance.timestampWrites;
    encoder << instance.maxDrawCount;
}

std::optional<WebKit::WebGPU::RenderPassDescriptor> ArgumentCoder<WebKit::WebGPU::RenderPassDescriptor>::decode(Decoder& decoder)
{
    auto label = decoder.decode<String>();
    auto colorAttachments = decoder.decode<Vector<std::optional<WebKit::WebGPU::RenderPassColorAttachment>>>();
    auto depthStencilAttachment = decoder.decode<std::optional<WebKit::WebGPU::RenderPassDepthStencilAttachment>>();
    auto occlusionQuerySet = decoder.decode<std::optional<WebKit::WebGPUIdentifier>>();
    auto timestampWrites = decoder.decode<std::optional<WebKit::WebGPU::RenderPassTimestampWrites>>();
    auto maxDrawCount = decoder.decode<std::optional<uint64_t>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::RenderPassDescriptor {
            WebKit::WebGPU::ObjectDescriptorBase {
                WTFMove(*label)
            },
            WTFMove(*colorAttachments),
            WTFMove(*depthStencilAttachment),
            WTFMove(*occlusionQuerySet),
            WTFMove(*timestampWrites),
            WTFMove(*maxDrawCount)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::RenderPassLayout>::encode(Encoder& encoder, const WebKit::WebGPU::RenderPassLayout& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorFormats)>, Vector<std::optional<WebCore::WebGPU::TextureFormat>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthStencilFormat)>, std::optional<WebCore::WebGPU::TextureFormat>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sampleCount)>, WebCore::WebGPU::Size32>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::RenderPassLayout, colorFormats)
        , offsetof(WebKit::WebGPU::RenderPassLayout, depthStencilFormat)
        , offsetof(WebKit::WebGPU::RenderPassLayout, sampleCount)
    >::value);

    encoder << instance.label;
    encoder << instance.colorFormats;
    encoder << instance.depthStencilFormat;
    encoder << instance.sampleCount;
}

void ArgumentCoder<WebKit::WebGPU::RenderPassLayout>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::RenderPassLayout& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorFormats)>, Vector<std::optional<WebCore::WebGPU::TextureFormat>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthStencilFormat)>, std::optional<WebCore::WebGPU::TextureFormat>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sampleCount)>, WebCore::WebGPU::Size32>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::RenderPassLayout, colorFormats)
        , offsetof(WebKit::WebGPU::RenderPassLayout, depthStencilFormat)
        , offsetof(WebKit::WebGPU::RenderPassLayout, sampleCount)
    >::value);

    encoder << instance.label;
    encoder << instance.colorFormats;
    encoder << instance.depthStencilFormat;
    encoder << instance.sampleCount;
}

std::optional<WebKit::WebGPU::RenderPassLayout> ArgumentCoder<WebKit::WebGPU::RenderPassLayout>::decode(Decoder& decoder)
{
    auto label = decoder.decode<String>();
    auto colorFormats = decoder.decode<Vector<std::optional<WebCore::WebGPU::TextureFormat>>>();
    auto depthStencilFormat = decoder.decode<std::optional<WebCore::WebGPU::TextureFormat>>();
    auto sampleCount = decoder.decode<WebCore::WebGPU::Size32>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::RenderPassLayout {
            WebKit::WebGPU::ObjectDescriptorBase {
                WTFMove(*label)
            },
            WTFMove(*colorFormats),
            WTFMove(*depthStencilFormat),
            WTFMove(*sampleCount)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::RenderPassTimestampWrites>::encode(Encoder& encoder, const WebKit::WebGPU::RenderPassTimestampWrites& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.querySet)>, WebKit::WebGPUIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.beginningOfPassWriteIndex)>, WebCore::WebGPU::Size32>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.endOfPassWriteIndex)>, WebCore::WebGPU::Size32>);
    struct ShouldBeSameSizeAsRenderPassTimestampWrites : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::RenderPassTimestampWrites>, false> {
        WebKit::WebGPUIdentifier querySet;
        WebCore::WebGPU::Size32 beginningOfPassWriteIndex;
        WebCore::WebGPU::Size32 endOfPassWriteIndex;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRenderPassTimestampWrites) == sizeof(WebKit::WebGPU::RenderPassTimestampWrites));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::RenderPassTimestampWrites, querySet)
        , offsetof(WebKit::WebGPU::RenderPassTimestampWrites, beginningOfPassWriteIndex)
        , offsetof(WebKit::WebGPU::RenderPassTimestampWrites, endOfPassWriteIndex)
    >::value);

    encoder << instance.querySet;
    encoder << instance.beginningOfPassWriteIndex;
    encoder << instance.endOfPassWriteIndex;
}

void ArgumentCoder<WebKit::WebGPU::RenderPassTimestampWrites>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::RenderPassTimestampWrites& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.querySet)>, WebKit::WebGPUIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.beginningOfPassWriteIndex)>, WebCore::WebGPU::Size32>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.endOfPassWriteIndex)>, WebCore::WebGPU::Size32>);
    struct ShouldBeSameSizeAsRenderPassTimestampWrites : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::RenderPassTimestampWrites>, false> {
        WebKit::WebGPUIdentifier querySet;
        WebCore::WebGPU::Size32 beginningOfPassWriteIndex;
        WebCore::WebGPU::Size32 endOfPassWriteIndex;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRenderPassTimestampWrites) == sizeof(WebKit::WebGPU::RenderPassTimestampWrites));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::RenderPassTimestampWrites, querySet)
        , offsetof(WebKit::WebGPU::RenderPassTimestampWrites, beginningOfPassWriteIndex)
        , offsetof(WebKit::WebGPU::RenderPassTimestampWrites, endOfPassWriteIndex)
    >::value);

    encoder << instance.querySet;
    encoder << instance.beginningOfPassWriteIndex;
    encoder << instance.endOfPassWriteIndex;
}

std::optional<WebKit::WebGPU::RenderPassTimestampWrites> ArgumentCoder<WebKit::WebGPU::RenderPassTimestampWrites>::decode(Decoder& decoder)
{
    auto querySet = decoder.decode<WebKit::WebGPUIdentifier>();
    auto beginningOfPassWriteIndex = decoder.decode<WebCore::WebGPU::Size32>();
    auto endOfPassWriteIndex = decoder.decode<WebCore::WebGPU::Size32>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::RenderPassTimestampWrites {
            WTFMove(*querySet),
            WTFMove(*beginningOfPassWriteIndex),
            WTFMove(*endOfPassWriteIndex)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::RenderPipelineDescriptor>::encode(Encoder& encoder, const WebKit::WebGPU::RenderPipelineDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.layout)>, Markable<WebKit::WebGPUIdentifier>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::PipelineDescriptorBase, layout)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.vertex)>, WebKit::WebGPU::VertexState>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.primitive)>, std::optional<WebKit::WebGPU::PrimitiveState>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthStencil)>, std::optional<WebKit::WebGPU::DepthStencilState>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.multisample)>, std::optional<WebKit::WebGPU::MultisampleState>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fragment)>, std::optional<WebKit::WebGPU::FragmentState>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::RenderPipelineDescriptor, vertex)
        , offsetof(WebKit::WebGPU::RenderPipelineDescriptor, primitive)
        , offsetof(WebKit::WebGPU::RenderPipelineDescriptor, depthStencil)
        , offsetof(WebKit::WebGPU::RenderPipelineDescriptor, multisample)
        , offsetof(WebKit::WebGPU::RenderPipelineDescriptor, fragment)
    >::value);

    encoder << instance.label;
    encoder << instance.layout;
    encoder << instance.vertex;
    encoder << instance.primitive;
    encoder << instance.depthStencil;
    encoder << instance.multisample;
    encoder << instance.fragment;
}

void ArgumentCoder<WebKit::WebGPU::RenderPipelineDescriptor>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::RenderPipelineDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.layout)>, Markable<WebKit::WebGPUIdentifier>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::PipelineDescriptorBase, layout)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.vertex)>, WebKit::WebGPU::VertexState>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.primitive)>, std::optional<WebKit::WebGPU::PrimitiveState>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthStencil)>, std::optional<WebKit::WebGPU::DepthStencilState>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.multisample)>, std::optional<WebKit::WebGPU::MultisampleState>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fragment)>, std::optional<WebKit::WebGPU::FragmentState>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::RenderPipelineDescriptor, vertex)
        , offsetof(WebKit::WebGPU::RenderPipelineDescriptor, primitive)
        , offsetof(WebKit::WebGPU::RenderPipelineDescriptor, depthStencil)
        , offsetof(WebKit::WebGPU::RenderPipelineDescriptor, multisample)
        , offsetof(WebKit::WebGPU::RenderPipelineDescriptor, fragment)
    >::value);

    encoder << instance.label;
    encoder << instance.layout;
    encoder << instance.vertex;
    encoder << instance.primitive;
    encoder << instance.depthStencil;
    encoder << instance.multisample;
    encoder << instance.fragment;
}

std::optional<WebKit::WebGPU::RenderPipelineDescriptor> ArgumentCoder<WebKit::WebGPU::RenderPipelineDescriptor>::decode(Decoder& decoder)
{
    auto label = decoder.decode<String>();
    auto layout = decoder.decode<Markable<WebKit::WebGPUIdentifier>>();
    auto vertex = decoder.decode<WebKit::WebGPU::VertexState>();
    auto primitive = decoder.decode<std::optional<WebKit::WebGPU::PrimitiveState>>();
    auto depthStencil = decoder.decode<std::optional<WebKit::WebGPU::DepthStencilState>>();
    auto multisample = decoder.decode<std::optional<WebKit::WebGPU::MultisampleState>>();
    auto fragment = decoder.decode<std::optional<WebKit::WebGPU::FragmentState>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::RenderPipelineDescriptor {
            WebKit::WebGPU::PipelineDescriptorBase {
                WebKit::WebGPU::ObjectDescriptorBase {
                    WTFMove(*label)
                },
                WTFMove(*layout)
            },
            WTFMove(*vertex),
            WTFMove(*primitive),
            WTFMove(*depthStencil),
            WTFMove(*multisample),
            WTFMove(*fragment)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::RequestAdapterOptions>::encode(Encoder& encoder, const WebKit::WebGPU::RequestAdapterOptions& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.powerPreference)>, std::optional<WebCore::WebGPU::PowerPreference>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.forceFallbackAdapter)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.xrCompatible)>, bool>);
    struct ShouldBeSameSizeAsRequestAdapterOptions : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::RequestAdapterOptions>, false> {
        std::optional<WebCore::WebGPU::PowerPreference> powerPreference;
        bool forceFallbackAdapter;
        bool xrCompatible;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRequestAdapterOptions) == sizeof(WebKit::WebGPU::RequestAdapterOptions));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::RequestAdapterOptions, powerPreference)
        , offsetof(WebKit::WebGPU::RequestAdapterOptions, forceFallbackAdapter)
        , offsetof(WebKit::WebGPU::RequestAdapterOptions, xrCompatible)
    >::value);

    encoder << instance.powerPreference;
    encoder << instance.forceFallbackAdapter;
    encoder << instance.xrCompatible;
}

void ArgumentCoder<WebKit::WebGPU::RequestAdapterOptions>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::RequestAdapterOptions& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.powerPreference)>, std::optional<WebCore::WebGPU::PowerPreference>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.forceFallbackAdapter)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.xrCompatible)>, bool>);
    struct ShouldBeSameSizeAsRequestAdapterOptions : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::RequestAdapterOptions>, false> {
        std::optional<WebCore::WebGPU::PowerPreference> powerPreference;
        bool forceFallbackAdapter;
        bool xrCompatible;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRequestAdapterOptions) == sizeof(WebKit::WebGPU::RequestAdapterOptions));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::RequestAdapterOptions, powerPreference)
        , offsetof(WebKit::WebGPU::RequestAdapterOptions, forceFallbackAdapter)
        , offsetof(WebKit::WebGPU::RequestAdapterOptions, xrCompatible)
    >::value);

    encoder << instance.powerPreference;
    encoder << instance.forceFallbackAdapter;
    encoder << instance.xrCompatible;
}

std::optional<WebKit::WebGPU::RequestAdapterOptions> ArgumentCoder<WebKit::WebGPU::RequestAdapterOptions>::decode(Decoder& decoder)
{
    auto powerPreference = decoder.decode<std::optional<WebCore::WebGPU::PowerPreference>>();
    auto forceFallbackAdapter = decoder.decode<bool>();
    auto xrCompatible = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::RequestAdapterOptions {
            WTFMove(*powerPreference),
            WTFMove(*forceFallbackAdapter),
            WTFMove(*xrCompatible)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::SamplerBindingLayout>::encode(Encoder& encoder, const WebKit::WebGPU::SamplerBindingLayout& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::WebGPU::SamplerBindingType>);
    struct ShouldBeSameSizeAsSamplerBindingLayout : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::SamplerBindingLayout>, false> {
        WebCore::WebGPU::SamplerBindingType type;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSamplerBindingLayout) == sizeof(WebKit::WebGPU::SamplerBindingLayout));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::SamplerBindingLayout, type)
    >::value);

    encoder << instance.type;
}

void ArgumentCoder<WebKit::WebGPU::SamplerBindingLayout>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::SamplerBindingLayout& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::WebGPU::SamplerBindingType>);
    struct ShouldBeSameSizeAsSamplerBindingLayout : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::SamplerBindingLayout>, false> {
        WebCore::WebGPU::SamplerBindingType type;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSamplerBindingLayout) == sizeof(WebKit::WebGPU::SamplerBindingLayout));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::SamplerBindingLayout, type)
    >::value);

    encoder << instance.type;
}

std::optional<WebKit::WebGPU::SamplerBindingLayout> ArgumentCoder<WebKit::WebGPU::SamplerBindingLayout>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::WebGPU::SamplerBindingType>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::SamplerBindingLayout {
            WTFMove(*type)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::SamplerDescriptor>::encode(Encoder& encoder, const WebKit::WebGPU::SamplerDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.addressModeU)>, WebCore::WebGPU::AddressMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.addressModeV)>, WebCore::WebGPU::AddressMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.addressModeW)>, WebCore::WebGPU::AddressMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.magFilter)>, WebCore::WebGPU::FilterMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.minFilter)>, WebCore::WebGPU::FilterMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mipmapFilter)>, WebCore::WebGPU::MipmapFilterMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lodMinClamp)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lodMaxClamp)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.compare)>, std::optional<WebCore::WebGPU::CompareFunction>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxAnisotropy)>, uint16_t>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::SamplerDescriptor, addressModeU)
        , offsetof(WebKit::WebGPU::SamplerDescriptor, addressModeV)
        , offsetof(WebKit::WebGPU::SamplerDescriptor, addressModeW)
        , offsetof(WebKit::WebGPU::SamplerDescriptor, magFilter)
        , offsetof(WebKit::WebGPU::SamplerDescriptor, minFilter)
        , offsetof(WebKit::WebGPU::SamplerDescriptor, mipmapFilter)
        , offsetof(WebKit::WebGPU::SamplerDescriptor, lodMinClamp)
        , offsetof(WebKit::WebGPU::SamplerDescriptor, lodMaxClamp)
        , offsetof(WebKit::WebGPU::SamplerDescriptor, compare)
        , offsetof(WebKit::WebGPU::SamplerDescriptor, maxAnisotropy)
    >::value);

    encoder << instance.label;
    encoder << instance.addressModeU;
    encoder << instance.addressModeV;
    encoder << instance.addressModeW;
    encoder << instance.magFilter;
    encoder << instance.minFilter;
    encoder << instance.mipmapFilter;
    encoder << instance.lodMinClamp;
    encoder << instance.lodMaxClamp;
    encoder << instance.compare;
    encoder << instance.maxAnisotropy;
}

void ArgumentCoder<WebKit::WebGPU::SamplerDescriptor>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::SamplerDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.addressModeU)>, WebCore::WebGPU::AddressMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.addressModeV)>, WebCore::WebGPU::AddressMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.addressModeW)>, WebCore::WebGPU::AddressMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.magFilter)>, WebCore::WebGPU::FilterMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.minFilter)>, WebCore::WebGPU::FilterMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mipmapFilter)>, WebCore::WebGPU::MipmapFilterMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lodMinClamp)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lodMaxClamp)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.compare)>, std::optional<WebCore::WebGPU::CompareFunction>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxAnisotropy)>, uint16_t>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::SamplerDescriptor, addressModeU)
        , offsetof(WebKit::WebGPU::SamplerDescriptor, addressModeV)
        , offsetof(WebKit::WebGPU::SamplerDescriptor, addressModeW)
        , offsetof(WebKit::WebGPU::SamplerDescriptor, magFilter)
        , offsetof(WebKit::WebGPU::SamplerDescriptor, minFilter)
        , offsetof(WebKit::WebGPU::SamplerDescriptor, mipmapFilter)
        , offsetof(WebKit::WebGPU::SamplerDescriptor, lodMinClamp)
        , offsetof(WebKit::WebGPU::SamplerDescriptor, lodMaxClamp)
        , offsetof(WebKit::WebGPU::SamplerDescriptor, compare)
        , offsetof(WebKit::WebGPU::SamplerDescriptor, maxAnisotropy)
    >::value);

    encoder << instance.label;
    encoder << instance.addressModeU;
    encoder << instance.addressModeV;
    encoder << instance.addressModeW;
    encoder << instance.magFilter;
    encoder << instance.minFilter;
    encoder << instance.mipmapFilter;
    encoder << instance.lodMinClamp;
    encoder << instance.lodMaxClamp;
    encoder << instance.compare;
    encoder << instance.maxAnisotropy;
}

std::optional<WebKit::WebGPU::SamplerDescriptor> ArgumentCoder<WebKit::WebGPU::SamplerDescriptor>::decode(Decoder& decoder)
{
    auto label = decoder.decode<String>();
    auto addressModeU = decoder.decode<WebCore::WebGPU::AddressMode>();
    auto addressModeV = decoder.decode<WebCore::WebGPU::AddressMode>();
    auto addressModeW = decoder.decode<WebCore::WebGPU::AddressMode>();
    auto magFilter = decoder.decode<WebCore::WebGPU::FilterMode>();
    auto minFilter = decoder.decode<WebCore::WebGPU::FilterMode>();
    auto mipmapFilter = decoder.decode<WebCore::WebGPU::MipmapFilterMode>();
    auto lodMinClamp = decoder.decode<float>();
    auto lodMaxClamp = decoder.decode<float>();
    auto compare = decoder.decode<std::optional<WebCore::WebGPU::CompareFunction>>();
    auto maxAnisotropy = decoder.decode<uint16_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::SamplerDescriptor {
            WebKit::WebGPU::ObjectDescriptorBase {
                WTFMove(*label)
            },
            WTFMove(*addressModeU),
            WTFMove(*addressModeV),
            WTFMove(*addressModeW),
            WTFMove(*magFilter),
            WTFMove(*minFilter),
            WTFMove(*mipmapFilter),
            WTFMove(*lodMinClamp),
            WTFMove(*lodMaxClamp),
            WTFMove(*compare),
            WTFMove(*maxAnisotropy)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::ShaderModuleCompilationHint>::encode(Encoder& encoder, const WebKit::WebGPU::ShaderModuleCompilationHint& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pipelineLayout)>, WebKit::WebGPUIdentifier>);
    struct ShouldBeSameSizeAsShaderModuleCompilationHint : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::ShaderModuleCompilationHint>, false> {
        WebKit::WebGPUIdentifier pipelineLayout;
    };
    static_assert(sizeof(ShouldBeSameSizeAsShaderModuleCompilationHint) == sizeof(WebKit::WebGPU::ShaderModuleCompilationHint));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ShaderModuleCompilationHint, pipelineLayout)
    >::value);

    encoder << instance.pipelineLayout;
}

void ArgumentCoder<WebKit::WebGPU::ShaderModuleCompilationHint>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::ShaderModuleCompilationHint& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pipelineLayout)>, WebKit::WebGPUIdentifier>);
    struct ShouldBeSameSizeAsShaderModuleCompilationHint : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::ShaderModuleCompilationHint>, false> {
        WebKit::WebGPUIdentifier pipelineLayout;
    };
    static_assert(sizeof(ShouldBeSameSizeAsShaderModuleCompilationHint) == sizeof(WebKit::WebGPU::ShaderModuleCompilationHint));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ShaderModuleCompilationHint, pipelineLayout)
    >::value);

    encoder << instance.pipelineLayout;
}

std::optional<WebKit::WebGPU::ShaderModuleCompilationHint> ArgumentCoder<WebKit::WebGPU::ShaderModuleCompilationHint>::decode(Decoder& decoder)
{
    auto pipelineLayout = decoder.decode<WebKit::WebGPUIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::ShaderModuleCompilationHint {
            WTFMove(*pipelineLayout)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::ShaderModuleDescriptor>::encode(Encoder& encoder, const WebKit::WebGPU::ShaderModuleDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.code)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hints)>, Vector<KeyValuePair<String, WebKit::WebGPU::ShaderModuleCompilationHint>>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ShaderModuleDescriptor, code)
        , offsetof(WebKit::WebGPU::ShaderModuleDescriptor, hints)
    >::value);

    encoder << instance.label;
    encoder << instance.code;
    encoder << instance.hints;
}

void ArgumentCoder<WebKit::WebGPU::ShaderModuleDescriptor>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::ShaderModuleDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.code)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hints)>, Vector<KeyValuePair<String, WebKit::WebGPU::ShaderModuleCompilationHint>>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ShaderModuleDescriptor, code)
        , offsetof(WebKit::WebGPU::ShaderModuleDescriptor, hints)
    >::value);

    encoder << instance.label;
    encoder << instance.code;
    encoder << instance.hints;
}

std::optional<WebKit::WebGPU::ShaderModuleDescriptor> ArgumentCoder<WebKit::WebGPU::ShaderModuleDescriptor>::decode(Decoder& decoder)
{
    auto label = decoder.decode<String>();
    auto code = decoder.decode<String>();
    auto hints = decoder.decode<Vector<KeyValuePair<String, WebKit::WebGPU::ShaderModuleCompilationHint>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::ShaderModuleDescriptor {
            WebKit::WebGPU::ObjectDescriptorBase {
                WTFMove(*label)
            },
            WTFMove(*code),
            WTFMove(*hints)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::StencilFaceState>::encode(Encoder& encoder, const WebKit::WebGPU::StencilFaceState& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.compare)>, WebCore::WebGPU::CompareFunction>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.failOp)>, WebCore::WebGPU::StencilOperation>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthFailOp)>, WebCore::WebGPU::StencilOperation>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.passOp)>, WebCore::WebGPU::StencilOperation>);
    struct ShouldBeSameSizeAsStencilFaceState : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::StencilFaceState>, false> {
        WebCore::WebGPU::CompareFunction compare;
        WebCore::WebGPU::StencilOperation failOp;
        WebCore::WebGPU::StencilOperation depthFailOp;
        WebCore::WebGPU::StencilOperation passOp;
    };
    static_assert(sizeof(ShouldBeSameSizeAsStencilFaceState) == sizeof(WebKit::WebGPU::StencilFaceState));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::StencilFaceState, compare)
        , offsetof(WebKit::WebGPU::StencilFaceState, failOp)
        , offsetof(WebKit::WebGPU::StencilFaceState, depthFailOp)
        , offsetof(WebKit::WebGPU::StencilFaceState, passOp)
    >::value);

    encoder << instance.compare;
    encoder << instance.failOp;
    encoder << instance.depthFailOp;
    encoder << instance.passOp;
}

void ArgumentCoder<WebKit::WebGPU::StencilFaceState>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::StencilFaceState& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.compare)>, WebCore::WebGPU::CompareFunction>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.failOp)>, WebCore::WebGPU::StencilOperation>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthFailOp)>, WebCore::WebGPU::StencilOperation>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.passOp)>, WebCore::WebGPU::StencilOperation>);
    struct ShouldBeSameSizeAsStencilFaceState : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::StencilFaceState>, false> {
        WebCore::WebGPU::CompareFunction compare;
        WebCore::WebGPU::StencilOperation failOp;
        WebCore::WebGPU::StencilOperation depthFailOp;
        WebCore::WebGPU::StencilOperation passOp;
    };
    static_assert(sizeof(ShouldBeSameSizeAsStencilFaceState) == sizeof(WebKit::WebGPU::StencilFaceState));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::StencilFaceState, compare)
        , offsetof(WebKit::WebGPU::StencilFaceState, failOp)
        , offsetof(WebKit::WebGPU::StencilFaceState, depthFailOp)
        , offsetof(WebKit::WebGPU::StencilFaceState, passOp)
    >::value);

    encoder << instance.compare;
    encoder << instance.failOp;
    encoder << instance.depthFailOp;
    encoder << instance.passOp;
}

std::optional<WebKit::WebGPU::StencilFaceState> ArgumentCoder<WebKit::WebGPU::StencilFaceState>::decode(Decoder& decoder)
{
    auto compare = decoder.decode<WebCore::WebGPU::CompareFunction>();
    auto failOp = decoder.decode<WebCore::WebGPU::StencilOperation>();
    auto depthFailOp = decoder.decode<WebCore::WebGPU::StencilOperation>();
    auto passOp = decoder.decode<WebCore::WebGPU::StencilOperation>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::StencilFaceState {
            WTFMove(*compare),
            WTFMove(*failOp),
            WTFMove(*depthFailOp),
            WTFMove(*passOp)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::StorageTextureBindingLayout>::encode(Encoder& encoder, const WebKit::WebGPU::StorageTextureBindingLayout& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.access)>, WebCore::WebGPU::StorageTextureAccess>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.format)>, WebCore::WebGPU::TextureFormat>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.viewDimension)>, WebCore::WebGPU::TextureViewDimension>);
    struct ShouldBeSameSizeAsStorageTextureBindingLayout : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::StorageTextureBindingLayout>, false> {
        WebCore::WebGPU::StorageTextureAccess access;
        WebCore::WebGPU::TextureFormat format;
        WebCore::WebGPU::TextureViewDimension viewDimension;
    };
    static_assert(sizeof(ShouldBeSameSizeAsStorageTextureBindingLayout) == sizeof(WebKit::WebGPU::StorageTextureBindingLayout));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::StorageTextureBindingLayout, access)
        , offsetof(WebKit::WebGPU::StorageTextureBindingLayout, format)
        , offsetof(WebKit::WebGPU::StorageTextureBindingLayout, viewDimension)
    >::value);

    encoder << instance.access;
    encoder << instance.format;
    encoder << instance.viewDimension;
}

void ArgumentCoder<WebKit::WebGPU::StorageTextureBindingLayout>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::StorageTextureBindingLayout& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.access)>, WebCore::WebGPU::StorageTextureAccess>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.format)>, WebCore::WebGPU::TextureFormat>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.viewDimension)>, WebCore::WebGPU::TextureViewDimension>);
    struct ShouldBeSameSizeAsStorageTextureBindingLayout : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::StorageTextureBindingLayout>, false> {
        WebCore::WebGPU::StorageTextureAccess access;
        WebCore::WebGPU::TextureFormat format;
        WebCore::WebGPU::TextureViewDimension viewDimension;
    };
    static_assert(sizeof(ShouldBeSameSizeAsStorageTextureBindingLayout) == sizeof(WebKit::WebGPU::StorageTextureBindingLayout));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::StorageTextureBindingLayout, access)
        , offsetof(WebKit::WebGPU::StorageTextureBindingLayout, format)
        , offsetof(WebKit::WebGPU::StorageTextureBindingLayout, viewDimension)
    >::value);

    encoder << instance.access;
    encoder << instance.format;
    encoder << instance.viewDimension;
}

std::optional<WebKit::WebGPU::StorageTextureBindingLayout> ArgumentCoder<WebKit::WebGPU::StorageTextureBindingLayout>::decode(Decoder& decoder)
{
    auto access = decoder.decode<WebCore::WebGPU::StorageTextureAccess>();
    auto format = decoder.decode<WebCore::WebGPU::TextureFormat>();
    auto viewDimension = decoder.decode<WebCore::WebGPU::TextureViewDimension>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::StorageTextureBindingLayout {
            WTFMove(*access),
            WTFMove(*format),
            WTFMove(*viewDimension)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::SupportedFeatures>::encode(Encoder& encoder, const WebKit::WebGPU::SupportedFeatures& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.features)>, Vector<String>>);
    struct ShouldBeSameSizeAsSupportedFeatures : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::SupportedFeatures>, false> {
        Vector<String> features;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSupportedFeatures) == sizeof(WebKit::WebGPU::SupportedFeatures));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::SupportedFeatures, features)
    >::value);

    encoder << instance.features;
}

void ArgumentCoder<WebKit::WebGPU::SupportedFeatures>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::SupportedFeatures& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.features)>, Vector<String>>);
    struct ShouldBeSameSizeAsSupportedFeatures : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::SupportedFeatures>, false> {
        Vector<String> features;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSupportedFeatures) == sizeof(WebKit::WebGPU::SupportedFeatures));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::SupportedFeatures, features)
    >::value);

    encoder << instance.features;
}

std::optional<WebKit::WebGPU::SupportedFeatures> ArgumentCoder<WebKit::WebGPU::SupportedFeatures>::decode(Decoder& decoder)
{
    auto features = decoder.decode<Vector<String>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::SupportedFeatures {
            WTFMove(*features)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::SupportedLimits>::encode(Encoder& encoder, const WebKit::WebGPU::SupportedLimits& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxTextureDimension1D)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxTextureDimension2D)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxTextureDimension3D)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxTextureArrayLayers)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxBindGroups)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxBindGroupsPlusVertexBuffers)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxBindingsPerBindGroup)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxDynamicUniformBuffersPerPipelineLayout)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxDynamicStorageBuffersPerPipelineLayout)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxSampledTexturesPerShaderStage)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxSamplersPerShaderStage)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxStorageBuffersPerShaderStage)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxStorageTexturesPerShaderStage)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxUniformBuffersPerShaderStage)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxUniformBufferBindingSize)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxStorageBufferBindingSize)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.minUniformBufferOffsetAlignment)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.minStorageBufferOffsetAlignment)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxVertexBuffers)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxBufferSize)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxVertexAttributes)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxVertexBufferArrayStride)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxInterStageShaderComponents)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxInterStageShaderVariables)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxColorAttachments)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxColorAttachmentBytesPerSample)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxComputeWorkgroupStorageSize)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxComputeInvocationsPerWorkgroup)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxComputeWorkgroupSizeX)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxComputeWorkgroupSizeY)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxComputeWorkgroupSizeZ)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxComputeWorkgroupsPerDimension)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxStorageBuffersInFragmentStage)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxStorageTexturesInFragmentStage)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxStorageBuffersInVertexStage)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxStorageTexturesInVertexStage)>, uint32_t>);
    struct ShouldBeSameSizeAsSupportedLimits : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::SupportedLimits>, false> {
        uint32_t maxTextureDimension1D;
        uint32_t maxTextureDimension2D;
        uint32_t maxTextureDimension3D;
        uint32_t maxTextureArrayLayers;
        uint32_t maxBindGroups;
        uint32_t maxBindGroupsPlusVertexBuffers;
        uint32_t maxBindingsPerBindGroup;
        uint32_t maxDynamicUniformBuffersPerPipelineLayout;
        uint32_t maxDynamicStorageBuffersPerPipelineLayout;
        uint32_t maxSampledTexturesPerShaderStage;
        uint32_t maxSamplersPerShaderStage;
        uint32_t maxStorageBuffersPerShaderStage;
        uint32_t maxStorageTexturesPerShaderStage;
        uint32_t maxUniformBuffersPerShaderStage;
        uint64_t maxUniformBufferBindingSize;
        uint64_t maxStorageBufferBindingSize;
        uint32_t minUniformBufferOffsetAlignment;
        uint32_t minStorageBufferOffsetAlignment;
        uint32_t maxVertexBuffers;
        uint64_t maxBufferSize;
        uint32_t maxVertexAttributes;
        uint32_t maxVertexBufferArrayStride;
        uint32_t maxInterStageShaderComponents;
        uint32_t maxInterStageShaderVariables;
        uint32_t maxColorAttachments;
        uint32_t maxColorAttachmentBytesPerSample;
        uint32_t maxComputeWorkgroupStorageSize;
        uint32_t maxComputeInvocationsPerWorkgroup;
        uint32_t maxComputeWorkgroupSizeX;
        uint32_t maxComputeWorkgroupSizeY;
        uint32_t maxComputeWorkgroupSizeZ;
        uint32_t maxComputeWorkgroupsPerDimension;
        uint32_t maxStorageBuffersInFragmentStage;
        uint32_t maxStorageTexturesInFragmentStage;
        uint32_t maxStorageBuffersInVertexStage;
        uint32_t maxStorageTexturesInVertexStage;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSupportedLimits) == sizeof(WebKit::WebGPU::SupportedLimits));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::SupportedLimits, maxTextureDimension1D)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxTextureDimension2D)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxTextureDimension3D)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxTextureArrayLayers)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxBindGroups)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxBindGroupsPlusVertexBuffers)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxBindingsPerBindGroup)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxDynamicUniformBuffersPerPipelineLayout)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxDynamicStorageBuffersPerPipelineLayout)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxSampledTexturesPerShaderStage)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxSamplersPerShaderStage)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxStorageBuffersPerShaderStage)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxStorageTexturesPerShaderStage)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxUniformBuffersPerShaderStage)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxUniformBufferBindingSize)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxStorageBufferBindingSize)
        , offsetof(WebKit::WebGPU::SupportedLimits, minUniformBufferOffsetAlignment)
        , offsetof(WebKit::WebGPU::SupportedLimits, minStorageBufferOffsetAlignment)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxVertexBuffers)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxBufferSize)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxVertexAttributes)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxVertexBufferArrayStride)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxInterStageShaderComponents)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxInterStageShaderVariables)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxColorAttachments)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxColorAttachmentBytesPerSample)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxComputeWorkgroupStorageSize)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxComputeInvocationsPerWorkgroup)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxComputeWorkgroupSizeX)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxComputeWorkgroupSizeY)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxComputeWorkgroupSizeZ)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxComputeWorkgroupsPerDimension)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxStorageBuffersInFragmentStage)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxStorageTexturesInFragmentStage)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxStorageBuffersInVertexStage)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxStorageTexturesInVertexStage)
    >::value);

    encoder << instance.maxTextureDimension1D;
    encoder << instance.maxTextureDimension2D;
    encoder << instance.maxTextureDimension3D;
    encoder << instance.maxTextureArrayLayers;
    encoder << instance.maxBindGroups;
    encoder << instance.maxBindGroupsPlusVertexBuffers;
    encoder << instance.maxBindingsPerBindGroup;
    encoder << instance.maxDynamicUniformBuffersPerPipelineLayout;
    encoder << instance.maxDynamicStorageBuffersPerPipelineLayout;
    encoder << instance.maxSampledTexturesPerShaderStage;
    encoder << instance.maxSamplersPerShaderStage;
    encoder << instance.maxStorageBuffersPerShaderStage;
    encoder << instance.maxStorageTexturesPerShaderStage;
    encoder << instance.maxUniformBuffersPerShaderStage;
    encoder << instance.maxUniformBufferBindingSize;
    encoder << instance.maxStorageBufferBindingSize;
    encoder << instance.minUniformBufferOffsetAlignment;
    encoder << instance.minStorageBufferOffsetAlignment;
    encoder << instance.maxVertexBuffers;
    encoder << instance.maxBufferSize;
    encoder << instance.maxVertexAttributes;
    encoder << instance.maxVertexBufferArrayStride;
    encoder << instance.maxInterStageShaderComponents;
    encoder << instance.maxInterStageShaderVariables;
    encoder << instance.maxColorAttachments;
    encoder << instance.maxColorAttachmentBytesPerSample;
    encoder << instance.maxComputeWorkgroupStorageSize;
    encoder << instance.maxComputeInvocationsPerWorkgroup;
    encoder << instance.maxComputeWorkgroupSizeX;
    encoder << instance.maxComputeWorkgroupSizeY;
    encoder << instance.maxComputeWorkgroupSizeZ;
    encoder << instance.maxComputeWorkgroupsPerDimension;
    encoder << instance.maxStorageBuffersInFragmentStage;
    encoder << instance.maxStorageTexturesInFragmentStage;
    encoder << instance.maxStorageBuffersInVertexStage;
    encoder << instance.maxStorageTexturesInVertexStage;
}

void ArgumentCoder<WebKit::WebGPU::SupportedLimits>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::SupportedLimits& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxTextureDimension1D)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxTextureDimension2D)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxTextureDimension3D)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxTextureArrayLayers)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxBindGroups)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxBindGroupsPlusVertexBuffers)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxBindingsPerBindGroup)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxDynamicUniformBuffersPerPipelineLayout)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxDynamicStorageBuffersPerPipelineLayout)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxSampledTexturesPerShaderStage)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxSamplersPerShaderStage)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxStorageBuffersPerShaderStage)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxStorageTexturesPerShaderStage)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxUniformBuffersPerShaderStage)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxUniformBufferBindingSize)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxStorageBufferBindingSize)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.minUniformBufferOffsetAlignment)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.minStorageBufferOffsetAlignment)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxVertexBuffers)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxBufferSize)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxVertexAttributes)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxVertexBufferArrayStride)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxInterStageShaderComponents)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxInterStageShaderVariables)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxColorAttachments)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxColorAttachmentBytesPerSample)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxComputeWorkgroupStorageSize)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxComputeInvocationsPerWorkgroup)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxComputeWorkgroupSizeX)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxComputeWorkgroupSizeY)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxComputeWorkgroupSizeZ)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxComputeWorkgroupsPerDimension)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxStorageBuffersInFragmentStage)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxStorageTexturesInFragmentStage)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxStorageBuffersInVertexStage)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxStorageTexturesInVertexStage)>, uint32_t>);
    struct ShouldBeSameSizeAsSupportedLimits : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::SupportedLimits>, false> {
        uint32_t maxTextureDimension1D;
        uint32_t maxTextureDimension2D;
        uint32_t maxTextureDimension3D;
        uint32_t maxTextureArrayLayers;
        uint32_t maxBindGroups;
        uint32_t maxBindGroupsPlusVertexBuffers;
        uint32_t maxBindingsPerBindGroup;
        uint32_t maxDynamicUniformBuffersPerPipelineLayout;
        uint32_t maxDynamicStorageBuffersPerPipelineLayout;
        uint32_t maxSampledTexturesPerShaderStage;
        uint32_t maxSamplersPerShaderStage;
        uint32_t maxStorageBuffersPerShaderStage;
        uint32_t maxStorageTexturesPerShaderStage;
        uint32_t maxUniformBuffersPerShaderStage;
        uint64_t maxUniformBufferBindingSize;
        uint64_t maxStorageBufferBindingSize;
        uint32_t minUniformBufferOffsetAlignment;
        uint32_t minStorageBufferOffsetAlignment;
        uint32_t maxVertexBuffers;
        uint64_t maxBufferSize;
        uint32_t maxVertexAttributes;
        uint32_t maxVertexBufferArrayStride;
        uint32_t maxInterStageShaderComponents;
        uint32_t maxInterStageShaderVariables;
        uint32_t maxColorAttachments;
        uint32_t maxColorAttachmentBytesPerSample;
        uint32_t maxComputeWorkgroupStorageSize;
        uint32_t maxComputeInvocationsPerWorkgroup;
        uint32_t maxComputeWorkgroupSizeX;
        uint32_t maxComputeWorkgroupSizeY;
        uint32_t maxComputeWorkgroupSizeZ;
        uint32_t maxComputeWorkgroupsPerDimension;
        uint32_t maxStorageBuffersInFragmentStage;
        uint32_t maxStorageTexturesInFragmentStage;
        uint32_t maxStorageBuffersInVertexStage;
        uint32_t maxStorageTexturesInVertexStage;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSupportedLimits) == sizeof(WebKit::WebGPU::SupportedLimits));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::SupportedLimits, maxTextureDimension1D)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxTextureDimension2D)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxTextureDimension3D)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxTextureArrayLayers)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxBindGroups)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxBindGroupsPlusVertexBuffers)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxBindingsPerBindGroup)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxDynamicUniformBuffersPerPipelineLayout)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxDynamicStorageBuffersPerPipelineLayout)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxSampledTexturesPerShaderStage)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxSamplersPerShaderStage)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxStorageBuffersPerShaderStage)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxStorageTexturesPerShaderStage)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxUniformBuffersPerShaderStage)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxUniformBufferBindingSize)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxStorageBufferBindingSize)
        , offsetof(WebKit::WebGPU::SupportedLimits, minUniformBufferOffsetAlignment)
        , offsetof(WebKit::WebGPU::SupportedLimits, minStorageBufferOffsetAlignment)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxVertexBuffers)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxBufferSize)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxVertexAttributes)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxVertexBufferArrayStride)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxInterStageShaderComponents)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxInterStageShaderVariables)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxColorAttachments)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxColorAttachmentBytesPerSample)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxComputeWorkgroupStorageSize)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxComputeInvocationsPerWorkgroup)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxComputeWorkgroupSizeX)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxComputeWorkgroupSizeY)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxComputeWorkgroupSizeZ)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxComputeWorkgroupsPerDimension)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxStorageBuffersInFragmentStage)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxStorageTexturesInFragmentStage)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxStorageBuffersInVertexStage)
        , offsetof(WebKit::WebGPU::SupportedLimits, maxStorageTexturesInVertexStage)
    >::value);

    encoder << instance.maxTextureDimension1D;
    encoder << instance.maxTextureDimension2D;
    encoder << instance.maxTextureDimension3D;
    encoder << instance.maxTextureArrayLayers;
    encoder << instance.maxBindGroups;
    encoder << instance.maxBindGroupsPlusVertexBuffers;
    encoder << instance.maxBindingsPerBindGroup;
    encoder << instance.maxDynamicUniformBuffersPerPipelineLayout;
    encoder << instance.maxDynamicStorageBuffersPerPipelineLayout;
    encoder << instance.maxSampledTexturesPerShaderStage;
    encoder << instance.maxSamplersPerShaderStage;
    encoder << instance.maxStorageBuffersPerShaderStage;
    encoder << instance.maxStorageTexturesPerShaderStage;
    encoder << instance.maxUniformBuffersPerShaderStage;
    encoder << instance.maxUniformBufferBindingSize;
    encoder << instance.maxStorageBufferBindingSize;
    encoder << instance.minUniformBufferOffsetAlignment;
    encoder << instance.minStorageBufferOffsetAlignment;
    encoder << instance.maxVertexBuffers;
    encoder << instance.maxBufferSize;
    encoder << instance.maxVertexAttributes;
    encoder << instance.maxVertexBufferArrayStride;
    encoder << instance.maxInterStageShaderComponents;
    encoder << instance.maxInterStageShaderVariables;
    encoder << instance.maxColorAttachments;
    encoder << instance.maxColorAttachmentBytesPerSample;
    encoder << instance.maxComputeWorkgroupStorageSize;
    encoder << instance.maxComputeInvocationsPerWorkgroup;
    encoder << instance.maxComputeWorkgroupSizeX;
    encoder << instance.maxComputeWorkgroupSizeY;
    encoder << instance.maxComputeWorkgroupSizeZ;
    encoder << instance.maxComputeWorkgroupsPerDimension;
    encoder << instance.maxStorageBuffersInFragmentStage;
    encoder << instance.maxStorageTexturesInFragmentStage;
    encoder << instance.maxStorageBuffersInVertexStage;
    encoder << instance.maxStorageTexturesInVertexStage;
}

std::optional<WebKit::WebGPU::SupportedLimits> ArgumentCoder<WebKit::WebGPU::SupportedLimits>::decode(Decoder& decoder)
{
    auto maxTextureDimension1D = decoder.decode<uint32_t>();
    auto maxTextureDimension2D = decoder.decode<uint32_t>();
    auto maxTextureDimension3D = decoder.decode<uint32_t>();
    auto maxTextureArrayLayers = decoder.decode<uint32_t>();
    auto maxBindGroups = decoder.decode<uint32_t>();
    auto maxBindGroupsPlusVertexBuffers = decoder.decode<uint32_t>();
    auto maxBindingsPerBindGroup = decoder.decode<uint32_t>();
    auto maxDynamicUniformBuffersPerPipelineLayout = decoder.decode<uint32_t>();
    auto maxDynamicStorageBuffersPerPipelineLayout = decoder.decode<uint32_t>();
    auto maxSampledTexturesPerShaderStage = decoder.decode<uint32_t>();
    auto maxSamplersPerShaderStage = decoder.decode<uint32_t>();
    auto maxStorageBuffersPerShaderStage = decoder.decode<uint32_t>();
    auto maxStorageTexturesPerShaderStage = decoder.decode<uint32_t>();
    auto maxUniformBuffersPerShaderStage = decoder.decode<uint32_t>();
    auto maxUniformBufferBindingSize = decoder.decode<uint64_t>();
    auto maxStorageBufferBindingSize = decoder.decode<uint64_t>();
    auto minUniformBufferOffsetAlignment = decoder.decode<uint32_t>();
    auto minStorageBufferOffsetAlignment = decoder.decode<uint32_t>();
    auto maxVertexBuffers = decoder.decode<uint32_t>();
    auto maxBufferSize = decoder.decode<uint64_t>();
    auto maxVertexAttributes = decoder.decode<uint32_t>();
    auto maxVertexBufferArrayStride = decoder.decode<uint32_t>();
    auto maxInterStageShaderComponents = decoder.decode<uint32_t>();
    auto maxInterStageShaderVariables = decoder.decode<uint32_t>();
    auto maxColorAttachments = decoder.decode<uint32_t>();
    auto maxColorAttachmentBytesPerSample = decoder.decode<uint32_t>();
    auto maxComputeWorkgroupStorageSize = decoder.decode<uint32_t>();
    auto maxComputeInvocationsPerWorkgroup = decoder.decode<uint32_t>();
    auto maxComputeWorkgroupSizeX = decoder.decode<uint32_t>();
    auto maxComputeWorkgroupSizeY = decoder.decode<uint32_t>();
    auto maxComputeWorkgroupSizeZ = decoder.decode<uint32_t>();
    auto maxComputeWorkgroupsPerDimension = decoder.decode<uint32_t>();
    auto maxStorageBuffersInFragmentStage = decoder.decode<uint32_t>();
    auto maxStorageTexturesInFragmentStage = decoder.decode<uint32_t>();
    auto maxStorageBuffersInVertexStage = decoder.decode<uint32_t>();
    auto maxStorageTexturesInVertexStage = decoder.decode<uint32_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::SupportedLimits {
            WTFMove(*maxTextureDimension1D),
            WTFMove(*maxTextureDimension2D),
            WTFMove(*maxTextureDimension3D),
            WTFMove(*maxTextureArrayLayers),
            WTFMove(*maxBindGroups),
            WTFMove(*maxBindGroupsPlusVertexBuffers),
            WTFMove(*maxBindingsPerBindGroup),
            WTFMove(*maxDynamicUniformBuffersPerPipelineLayout),
            WTFMove(*maxDynamicStorageBuffersPerPipelineLayout),
            WTFMove(*maxSampledTexturesPerShaderStage),
            WTFMove(*maxSamplersPerShaderStage),
            WTFMove(*maxStorageBuffersPerShaderStage),
            WTFMove(*maxStorageTexturesPerShaderStage),
            WTFMove(*maxUniformBuffersPerShaderStage),
            WTFMove(*maxUniformBufferBindingSize),
            WTFMove(*maxStorageBufferBindingSize),
            WTFMove(*minUniformBufferOffsetAlignment),
            WTFMove(*minStorageBufferOffsetAlignment),
            WTFMove(*maxVertexBuffers),
            WTFMove(*maxBufferSize),
            WTFMove(*maxVertexAttributes),
            WTFMove(*maxVertexBufferArrayStride),
            WTFMove(*maxInterStageShaderComponents),
            WTFMove(*maxInterStageShaderVariables),
            WTFMove(*maxColorAttachments),
            WTFMove(*maxColorAttachmentBytesPerSample),
            WTFMove(*maxComputeWorkgroupStorageSize),
            WTFMove(*maxComputeInvocationsPerWorkgroup),
            WTFMove(*maxComputeWorkgroupSizeX),
            WTFMove(*maxComputeWorkgroupSizeY),
            WTFMove(*maxComputeWorkgroupSizeZ),
            WTFMove(*maxComputeWorkgroupsPerDimension),
            WTFMove(*maxStorageBuffersInFragmentStage),
            WTFMove(*maxStorageTexturesInFragmentStage),
            WTFMove(*maxStorageBuffersInVertexStage),
            WTFMove(*maxStorageTexturesInVertexStage)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::TextureBindingLayout>::encode(Encoder& encoder, const WebKit::WebGPU::TextureBindingLayout& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sampleType)>, WebCore::WebGPU::TextureSampleType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.viewDimension)>, WebCore::WebGPU::TextureViewDimension>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.multisampled)>, bool>);
    struct ShouldBeSameSizeAsTextureBindingLayout : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::TextureBindingLayout>, false> {
        WebCore::WebGPU::TextureSampleType sampleType;
        WebCore::WebGPU::TextureViewDimension viewDimension;
        bool multisampled;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTextureBindingLayout) == sizeof(WebKit::WebGPU::TextureBindingLayout));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::TextureBindingLayout, sampleType)
        , offsetof(WebKit::WebGPU::TextureBindingLayout, viewDimension)
        , offsetof(WebKit::WebGPU::TextureBindingLayout, multisampled)
    >::value);

    encoder << instance.sampleType;
    encoder << instance.viewDimension;
    encoder << instance.multisampled;
}

void ArgumentCoder<WebKit::WebGPU::TextureBindingLayout>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::TextureBindingLayout& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sampleType)>, WebCore::WebGPU::TextureSampleType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.viewDimension)>, WebCore::WebGPU::TextureViewDimension>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.multisampled)>, bool>);
    struct ShouldBeSameSizeAsTextureBindingLayout : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::TextureBindingLayout>, false> {
        WebCore::WebGPU::TextureSampleType sampleType;
        WebCore::WebGPU::TextureViewDimension viewDimension;
        bool multisampled;
    };
    static_assert(sizeof(ShouldBeSameSizeAsTextureBindingLayout) == sizeof(WebKit::WebGPU::TextureBindingLayout));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::TextureBindingLayout, sampleType)
        , offsetof(WebKit::WebGPU::TextureBindingLayout, viewDimension)
        , offsetof(WebKit::WebGPU::TextureBindingLayout, multisampled)
    >::value);

    encoder << instance.sampleType;
    encoder << instance.viewDimension;
    encoder << instance.multisampled;
}

std::optional<WebKit::WebGPU::TextureBindingLayout> ArgumentCoder<WebKit::WebGPU::TextureBindingLayout>::decode(Decoder& decoder)
{
    auto sampleType = decoder.decode<WebCore::WebGPU::TextureSampleType>();
    auto viewDimension = decoder.decode<WebCore::WebGPU::TextureViewDimension>();
    auto multisampled = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::TextureBindingLayout {
            WTFMove(*sampleType),
            WTFMove(*viewDimension),
            WTFMove(*multisampled)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::TextureDescriptor>::encode(Encoder& encoder, const WebKit::WebGPU::TextureDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size)>, WebKit::WebGPU::Extent3D>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mipLevelCount)>, WebCore::WebGPU::IntegerCoordinate>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sampleCount)>, WebCore::WebGPU::Size32>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dimension)>, WebCore::WebGPU::TextureDimension>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.format)>, WebCore::WebGPU::TextureFormat>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.usage)>, WebCore::WebGPU::TextureUsageFlags>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.viewFormats)>, Vector<WebCore::WebGPU::TextureFormat>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::TextureDescriptor, size)
        , offsetof(WebKit::WebGPU::TextureDescriptor, mipLevelCount)
        , offsetof(WebKit::WebGPU::TextureDescriptor, sampleCount)
        , offsetof(WebKit::WebGPU::TextureDescriptor, dimension)
        , offsetof(WebKit::WebGPU::TextureDescriptor, format)
        , offsetof(WebKit::WebGPU::TextureDescriptor, usage)
        , offsetof(WebKit::WebGPU::TextureDescriptor, viewFormats)
    >::value);

    encoder << instance.label;
    encoder << instance.size;
    encoder << instance.mipLevelCount;
    encoder << instance.sampleCount;
    encoder << instance.dimension;
    encoder << instance.format;
    encoder << instance.usage;
    encoder << instance.viewFormats;
}

void ArgumentCoder<WebKit::WebGPU::TextureDescriptor>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::TextureDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size)>, WebKit::WebGPU::Extent3D>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mipLevelCount)>, WebCore::WebGPU::IntegerCoordinate>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sampleCount)>, WebCore::WebGPU::Size32>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dimension)>, WebCore::WebGPU::TextureDimension>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.format)>, WebCore::WebGPU::TextureFormat>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.usage)>, WebCore::WebGPU::TextureUsageFlags>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.viewFormats)>, Vector<WebCore::WebGPU::TextureFormat>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::TextureDescriptor, size)
        , offsetof(WebKit::WebGPU::TextureDescriptor, mipLevelCount)
        , offsetof(WebKit::WebGPU::TextureDescriptor, sampleCount)
        , offsetof(WebKit::WebGPU::TextureDescriptor, dimension)
        , offsetof(WebKit::WebGPU::TextureDescriptor, format)
        , offsetof(WebKit::WebGPU::TextureDescriptor, usage)
        , offsetof(WebKit::WebGPU::TextureDescriptor, viewFormats)
    >::value);

    encoder << instance.label;
    encoder << instance.size;
    encoder << instance.mipLevelCount;
    encoder << instance.sampleCount;
    encoder << instance.dimension;
    encoder << instance.format;
    encoder << instance.usage;
    encoder << instance.viewFormats;
}

std::optional<WebKit::WebGPU::TextureDescriptor> ArgumentCoder<WebKit::WebGPU::TextureDescriptor>::decode(Decoder& decoder)
{
    auto label = decoder.decode<String>();
    auto size = decoder.decode<WebKit::WebGPU::Extent3D>();
    auto mipLevelCount = decoder.decode<WebCore::WebGPU::IntegerCoordinate>();
    auto sampleCount = decoder.decode<WebCore::WebGPU::Size32>();
    auto dimension = decoder.decode<WebCore::WebGPU::TextureDimension>();
    auto format = decoder.decode<WebCore::WebGPU::TextureFormat>();
    auto usage = decoder.decode<WebCore::WebGPU::TextureUsageFlags>();
    auto viewFormats = decoder.decode<Vector<WebCore::WebGPU::TextureFormat>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::TextureDescriptor {
            WebKit::WebGPU::ObjectDescriptorBase {
                WTFMove(*label)
            },
            WTFMove(*size),
            WTFMove(*mipLevelCount),
            WTFMove(*sampleCount),
            WTFMove(*dimension),
            WTFMove(*format),
            WTFMove(*usage),
            WTFMove(*viewFormats)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::TextureViewDescriptor>::encode(Encoder& encoder, const WebKit::WebGPU::TextureViewDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.format)>, std::optional<WebCore::WebGPU::TextureFormat>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dimension)>, std::optional<WebCore::WebGPU::TextureViewDimension>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.aspect)>, WebCore::WebGPU::TextureAspect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.baseMipLevel)>, WebCore::WebGPU::IntegerCoordinate>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mipLevelCount)>, std::optional<WebCore::WebGPU::IntegerCoordinate>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.baseArrayLayer)>, WebCore::WebGPU::IntegerCoordinate>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.arrayLayerCount)>, std::optional<WebCore::WebGPU::IntegerCoordinate>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::TextureViewDescriptor, format)
        , offsetof(WebKit::WebGPU::TextureViewDescriptor, dimension)
        , offsetof(WebKit::WebGPU::TextureViewDescriptor, aspect)
        , offsetof(WebKit::WebGPU::TextureViewDescriptor, baseMipLevel)
        , offsetof(WebKit::WebGPU::TextureViewDescriptor, mipLevelCount)
        , offsetof(WebKit::WebGPU::TextureViewDescriptor, baseArrayLayer)
        , offsetof(WebKit::WebGPU::TextureViewDescriptor, arrayLayerCount)
    >::value);

    encoder << instance.label;
    encoder << instance.format;
    encoder << instance.dimension;
    encoder << instance.aspect;
    encoder << instance.baseMipLevel;
    encoder << instance.mipLevelCount;
    encoder << instance.baseArrayLayer;
    encoder << instance.arrayLayerCount;
}

void ArgumentCoder<WebKit::WebGPU::TextureViewDescriptor>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::TextureViewDescriptor& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.label)>, String>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ObjectDescriptorBase, label)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.format)>, std::optional<WebCore::WebGPU::TextureFormat>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dimension)>, std::optional<WebCore::WebGPU::TextureViewDimension>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.aspect)>, WebCore::WebGPU::TextureAspect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.baseMipLevel)>, WebCore::WebGPU::IntegerCoordinate>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mipLevelCount)>, std::optional<WebCore::WebGPU::IntegerCoordinate>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.baseArrayLayer)>, WebCore::WebGPU::IntegerCoordinate>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.arrayLayerCount)>, std::optional<WebCore::WebGPU::IntegerCoordinate>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::TextureViewDescriptor, format)
        , offsetof(WebKit::WebGPU::TextureViewDescriptor, dimension)
        , offsetof(WebKit::WebGPU::TextureViewDescriptor, aspect)
        , offsetof(WebKit::WebGPU::TextureViewDescriptor, baseMipLevel)
        , offsetof(WebKit::WebGPU::TextureViewDescriptor, mipLevelCount)
        , offsetof(WebKit::WebGPU::TextureViewDescriptor, baseArrayLayer)
        , offsetof(WebKit::WebGPU::TextureViewDescriptor, arrayLayerCount)
    >::value);

    encoder << instance.label;
    encoder << instance.format;
    encoder << instance.dimension;
    encoder << instance.aspect;
    encoder << instance.baseMipLevel;
    encoder << instance.mipLevelCount;
    encoder << instance.baseArrayLayer;
    encoder << instance.arrayLayerCount;
}

std::optional<WebKit::WebGPU::TextureViewDescriptor> ArgumentCoder<WebKit::WebGPU::TextureViewDescriptor>::decode(Decoder& decoder)
{
    auto label = decoder.decode<String>();
    auto format = decoder.decode<std::optional<WebCore::WebGPU::TextureFormat>>();
    auto dimension = decoder.decode<std::optional<WebCore::WebGPU::TextureViewDimension>>();
    auto aspect = decoder.decode<WebCore::WebGPU::TextureAspect>();
    auto baseMipLevel = decoder.decode<WebCore::WebGPU::IntegerCoordinate>();
    auto mipLevelCount = decoder.decode<std::optional<WebCore::WebGPU::IntegerCoordinate>>();
    auto baseArrayLayer = decoder.decode<WebCore::WebGPU::IntegerCoordinate>();
    auto arrayLayerCount = decoder.decode<std::optional<WebCore::WebGPU::IntegerCoordinate>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::TextureViewDescriptor {
            WebKit::WebGPU::ObjectDescriptorBase {
                WTFMove(*label)
            },
            WTFMove(*format),
            WTFMove(*dimension),
            WTFMove(*aspect),
            WTFMove(*baseMipLevel),
            WTFMove(*mipLevelCount),
            WTFMove(*baseArrayLayer),
            WTFMove(*arrayLayerCount)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::ValidationError>::encode(Encoder& encoder, const WebKit::WebGPU::ValidationError& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.message)>, String>);
    struct ShouldBeSameSizeAsValidationError : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::ValidationError>, false> {
        String message;
    };
    static_assert(sizeof(ShouldBeSameSizeAsValidationError) == sizeof(WebKit::WebGPU::ValidationError));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ValidationError, message)
    >::value);

    encoder << instance.message;
}

void ArgumentCoder<WebKit::WebGPU::ValidationError>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::ValidationError& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.message)>, String>);
    struct ShouldBeSameSizeAsValidationError : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::ValidationError>, false> {
        String message;
    };
    static_assert(sizeof(ShouldBeSameSizeAsValidationError) == sizeof(WebKit::WebGPU::ValidationError));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ValidationError, message)
    >::value);

    encoder << instance.message;
}

std::optional<WebKit::WebGPU::ValidationError> ArgumentCoder<WebKit::WebGPU::ValidationError>::decode(Decoder& decoder)
{
    auto message = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::ValidationError {
            WTFMove(*message)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::VertexAttribute>::encode(Encoder& encoder, const WebKit::WebGPU::VertexAttribute& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.format)>, WebCore::WebGPU::VertexFormat>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, WebCore::WebGPU::Size64>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shaderLocation)>, WebCore::WebGPU::Index32>);
    struct ShouldBeSameSizeAsVertexAttribute : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::VertexAttribute>, false> {
        WebCore::WebGPU::VertexFormat format;
        WebCore::WebGPU::Size64 offset;
        WebCore::WebGPU::Index32 shaderLocation;
    };
    static_assert(sizeof(ShouldBeSameSizeAsVertexAttribute) == sizeof(WebKit::WebGPU::VertexAttribute));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::VertexAttribute, format)
        , offsetof(WebKit::WebGPU::VertexAttribute, offset)
        , offsetof(WebKit::WebGPU::VertexAttribute, shaderLocation)
    >::value);

    encoder << instance.format;
    encoder << instance.offset;
    encoder << instance.shaderLocation;
}

void ArgumentCoder<WebKit::WebGPU::VertexAttribute>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::VertexAttribute& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.format)>, WebCore::WebGPU::VertexFormat>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, WebCore::WebGPU::Size64>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shaderLocation)>, WebCore::WebGPU::Index32>);
    struct ShouldBeSameSizeAsVertexAttribute : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::VertexAttribute>, false> {
        WebCore::WebGPU::VertexFormat format;
        WebCore::WebGPU::Size64 offset;
        WebCore::WebGPU::Index32 shaderLocation;
    };
    static_assert(sizeof(ShouldBeSameSizeAsVertexAttribute) == sizeof(WebKit::WebGPU::VertexAttribute));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::VertexAttribute, format)
        , offsetof(WebKit::WebGPU::VertexAttribute, offset)
        , offsetof(WebKit::WebGPU::VertexAttribute, shaderLocation)
    >::value);

    encoder << instance.format;
    encoder << instance.offset;
    encoder << instance.shaderLocation;
}

std::optional<WebKit::WebGPU::VertexAttribute> ArgumentCoder<WebKit::WebGPU::VertexAttribute>::decode(Decoder& decoder)
{
    auto format = decoder.decode<WebCore::WebGPU::VertexFormat>();
    auto offset = decoder.decode<WebCore::WebGPU::Size64>();
    auto shaderLocation = decoder.decode<WebCore::WebGPU::Index32>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::VertexAttribute {
            WTFMove(*format),
            WTFMove(*offset),
            WTFMove(*shaderLocation)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::VertexBufferLayout>::encode(Encoder& encoder, const WebKit::WebGPU::VertexBufferLayout& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.arrayStride)>, WebCore::WebGPU::Size64>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stepMode)>, WebCore::WebGPU::VertexStepMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.attributes)>, Vector<WebKit::WebGPU::VertexAttribute>>);
    struct ShouldBeSameSizeAsVertexBufferLayout : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::VertexBufferLayout>, false> {
        WebCore::WebGPU::Size64 arrayStride;
        WebCore::WebGPU::VertexStepMode stepMode;
        Vector<WebKit::WebGPU::VertexAttribute> attributes;
    };
    static_assert(sizeof(ShouldBeSameSizeAsVertexBufferLayout) == sizeof(WebKit::WebGPU::VertexBufferLayout));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::VertexBufferLayout, arrayStride)
        , offsetof(WebKit::WebGPU::VertexBufferLayout, stepMode)
        , offsetof(WebKit::WebGPU::VertexBufferLayout, attributes)
    >::value);

    encoder << instance.arrayStride;
    encoder << instance.stepMode;
    encoder << instance.attributes;
}

void ArgumentCoder<WebKit::WebGPU::VertexBufferLayout>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::VertexBufferLayout& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.arrayStride)>, WebCore::WebGPU::Size64>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stepMode)>, WebCore::WebGPU::VertexStepMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.attributes)>, Vector<WebKit::WebGPU::VertexAttribute>>);
    struct ShouldBeSameSizeAsVertexBufferLayout : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebGPU::VertexBufferLayout>, false> {
        WebCore::WebGPU::Size64 arrayStride;
        WebCore::WebGPU::VertexStepMode stepMode;
        Vector<WebKit::WebGPU::VertexAttribute> attributes;
    };
    static_assert(sizeof(ShouldBeSameSizeAsVertexBufferLayout) == sizeof(WebKit::WebGPU::VertexBufferLayout));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::VertexBufferLayout, arrayStride)
        , offsetof(WebKit::WebGPU::VertexBufferLayout, stepMode)
        , offsetof(WebKit::WebGPU::VertexBufferLayout, attributes)
    >::value);

    encoder << instance.arrayStride;
    encoder << instance.stepMode;
    encoder << instance.attributes;
}

std::optional<WebKit::WebGPU::VertexBufferLayout> ArgumentCoder<WebKit::WebGPU::VertexBufferLayout>::decode(Decoder& decoder)
{
    auto arrayStride = decoder.decode<WebCore::WebGPU::Size64>();
    auto stepMode = decoder.decode<WebCore::WebGPU::VertexStepMode>();
    auto attributes = decoder.decode<Vector<WebKit::WebGPU::VertexAttribute>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::VertexBufferLayout {
            WTFMove(*arrayStride),
            WTFMove(*stepMode),
            WTFMove(*attributes)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::WebGPU::VertexState>::encode(Encoder& encoder, const WebKit::WebGPU::VertexState& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.module)>, WebKit::WebGPUIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.entryPoint)>, std::optional<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.constants)>, Vector<KeyValuePair<String, double>>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ProgrammableStage, module)
        , offsetof(WebKit::WebGPU::ProgrammableStage, entryPoint)
        , offsetof(WebKit::WebGPU::ProgrammableStage, constants)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.buffers)>, Vector<std::optional<WebKit::WebGPU::VertexBufferLayout>>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::VertexState, buffers)
    >::value);

    encoder << instance.module;
    encoder << instance.entryPoint;
    encoder << instance.constants;
    encoder << instance.buffers;
}

void ArgumentCoder<WebKit::WebGPU::VertexState>::encode(StreamConnectionEncoder& encoder, const WebKit::WebGPU::VertexState& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.module)>, WebKit::WebGPUIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.entryPoint)>, std::optional<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.constants)>, Vector<KeyValuePair<String, double>>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::ProgrammableStage, module)
        , offsetof(WebKit::WebGPU::ProgrammableStage, entryPoint)
        , offsetof(WebKit::WebGPU::ProgrammableStage, constants)
    >::value);

    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.buffers)>, Vector<std::optional<WebKit::WebGPU::VertexBufferLayout>>>);
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebGPU::VertexState, buffers)
    >::value);

    encoder << instance.module;
    encoder << instance.entryPoint;
    encoder << instance.constants;
    encoder << instance.buffers;
}

std::optional<WebKit::WebGPU::VertexState> ArgumentCoder<WebKit::WebGPU::VertexState>::decode(Decoder& decoder)
{
    auto module = decoder.decode<WebKit::WebGPUIdentifier>();
    auto entryPoint = decoder.decode<std::optional<String>>();
    auto constants = decoder.decode<Vector<KeyValuePair<String, double>>>();
    auto buffers = decoder.decode<Vector<std::optional<WebKit::WebGPU::VertexBufferLayout>>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebGPU::VertexState {
            WebKit::WebGPU::ProgrammableStage {
                WTFMove(*module),
                WTFMove(*entryPoint),
                WTFMove(*constants)
            },
            WTFMove(*buffers)
        }
    };
}

#endif

void ArgumentCoder<WebKit::WebsiteData::Entry>::encode(Encoder& encoder, const WebKit::WebsiteData::Entry& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.origin)>, WebCore::SecurityOriginData>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.typeAsOptionSet())>, OptionSet<WebKit::WebsiteDataType>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size)>, uint64_t>);

    encoder << instance.origin;
    encoder << instance.typeAsOptionSet();
    encoder << instance.size;
}

std::optional<WebKit::WebsiteData::Entry> ArgumentCoder<WebKit::WebsiteData::Entry>::decode(Decoder& decoder)
{
    auto origin = decoder.decode<WebCore::SecurityOriginData>();
    auto typeAsOptionSet = decoder.decode<OptionSet<WebKit::WebsiteDataType>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(typeAsOptionSet->hasExactlyOneBitSet()))
        return std::nullopt;
    auto size = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebsiteData::Entry {
            WTFMove(*origin),
            WTFMove(*typeAsOptionSet),
            WTFMove(*size)
        }
    };
}

void ArgumentCoder<WebKit::WebsiteData>::encode(Encoder& encoder, const WebKit::WebsiteData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.entries)>, Vector<WebKit::WebsiteData::Entry>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hostNamesWithCookies)>, HashSet<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hostNamesWithHSTSCache)>, HashSet<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.registrableDomainsWithResourceLoadStatistics)>, HashSet<WebCore::RegistrableDomain>>);
    struct ShouldBeSameSizeAsWebsiteData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebsiteData>, false> {
        Vector<WebKit::WebsiteData::Entry> entries;
        HashSet<String> hostNamesWithCookies;
        HashSet<String> hostNamesWithHSTSCache;
        HashSet<WebCore::RegistrableDomain> registrableDomainsWithResourceLoadStatistics;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebsiteData) == sizeof(WebKit::WebsiteData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebsiteData, entries)
        , offsetof(WebKit::WebsiteData, hostNamesWithCookies)
        , offsetof(WebKit::WebsiteData, hostNamesWithHSTSCache)
        , offsetof(WebKit::WebsiteData, registrableDomainsWithResourceLoadStatistics)
    >::value);

    encoder << instance.entries;
    encoder << instance.hostNamesWithCookies;
    encoder << instance.hostNamesWithHSTSCache;
    encoder << instance.registrableDomainsWithResourceLoadStatistics;
}

std::optional<WebKit::WebsiteData> ArgumentCoder<WebKit::WebsiteData>::decode(Decoder& decoder)
{
    auto entries = decoder.decode<Vector<WebKit::WebsiteData::Entry>>();
    auto hostNamesWithCookies = decoder.decode<HashSet<String>>();
    auto hostNamesWithHSTSCache = decoder.decode<HashSet<String>>();
    auto registrableDomainsWithResourceLoadStatistics = decoder.decode<HashSet<WebCore::RegistrableDomain>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebsiteData {
            WTFMove(*entries),
            WTFMove(*hostNamesWithCookies),
            WTFMove(*hostNamesWithHSTSCache),
            WTFMove(*registrableDomainsWithResourceLoadStatistics)
        }
    };
}

#if ENABLE(WEBXR)
void ArgumentCoder<PlatformXR::DepthRange>::encode(Encoder& encoder, const PlatformXR::DepthRange& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.near)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.far)>, float>);
    struct ShouldBeSameSizeAsDepthRange : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<PlatformXR::DepthRange>, false> {
        float near;
        float far;
    };
    static_assert(sizeof(ShouldBeSameSizeAsDepthRange) == sizeof(PlatformXR::DepthRange));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(PlatformXR::DepthRange, near)
        , offsetof(PlatformXR::DepthRange, far)
    >::value);

    encoder << instance.near;
    encoder << instance.far;
}

std::optional<PlatformXR::DepthRange> ArgumentCoder<PlatformXR::DepthRange>::decode(Decoder& decoder)
{
    auto near = decoder.decode<float>();
    auto far = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        PlatformXR::DepthRange {
            WTFMove(*near),
            WTFMove(*far)
        }
    };
}

#endif

#if ENABLE(WEBXR)
void ArgumentCoder<PlatformXR::RequestData>::encode(Encoder& encoder, const PlatformXR::RequestData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthRange)>, PlatformXR::DepthRange>);
    struct ShouldBeSameSizeAsRequestData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<PlatformXR::RequestData>, false> {
        PlatformXR::DepthRange depthRange;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRequestData) == sizeof(PlatformXR::RequestData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(PlatformXR::RequestData, depthRange)
    >::value);

    encoder << instance.depthRange;
}

std::optional<PlatformXR::RequestData> ArgumentCoder<PlatformXR::RequestData>::decode(Decoder& decoder)
{
    auto depthRange = decoder.decode<PlatformXR::DepthRange>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        PlatformXR::RequestData {
            WTFMove(*depthRange)
        }
    };
}

#endif

#if ENABLE(WEBXR)
void ArgumentCoder<PlatformXR::FrameData::FloatQuaternion>::encode(Encoder& encoder, const PlatformXR::FrameData::FloatQuaternion& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.x)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.y)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.z)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.w)>, float>);
    struct ShouldBeSameSizeAsFloatQuaternion : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<PlatformXR::FrameData::FloatQuaternion>, false> {
        float x;
        float y;
        float z;
        float w;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFloatQuaternion) == sizeof(PlatformXR::FrameData::FloatQuaternion));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(PlatformXR::FrameData::FloatQuaternion, x)
        , offsetof(PlatformXR::FrameData::FloatQuaternion, y)
        , offsetof(PlatformXR::FrameData::FloatQuaternion, z)
        , offsetof(PlatformXR::FrameData::FloatQuaternion, w)
    >::value);

    encoder << instance.x;
    encoder << instance.y;
    encoder << instance.z;
    encoder << instance.w;
}

std::optional<PlatformXR::FrameData::FloatQuaternion> ArgumentCoder<PlatformXR::FrameData::FloatQuaternion>::decode(Decoder& decoder)
{
    auto x = decoder.decode<float>();
    auto y = decoder.decode<float>();
    auto z = decoder.decode<float>();
    auto w = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        PlatformXR::FrameData::FloatQuaternion {
            WTFMove(*x),
            WTFMove(*y),
            WTFMove(*z),
            WTFMove(*w)
        }
    };
}

#endif

#if ENABLE(WEBXR)
void ArgumentCoder<PlatformXR::FrameData::Pose>::encode(Encoder& encoder, const PlatformXR::FrameData::Pose& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.position)>, WebCore::FloatPoint3D>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.orientation)>, PlatformXR::FrameData::FloatQuaternion>);
    struct ShouldBeSameSizeAsPose : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<PlatformXR::FrameData::Pose>, false> {
        WebCore::FloatPoint3D position;
        PlatformXR::FrameData::FloatQuaternion orientation;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPose) == sizeof(PlatformXR::FrameData::Pose));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(PlatformXR::FrameData::Pose, position)
        , offsetof(PlatformXR::FrameData::Pose, orientation)
    >::value);

    encoder << instance.position;
    encoder << instance.orientation;
}

std::optional<PlatformXR::FrameData::Pose> ArgumentCoder<PlatformXR::FrameData::Pose>::decode(Decoder& decoder)
{
    auto position = decoder.decode<WebCore::FloatPoint3D>();
    auto orientation = decoder.decode<PlatformXR::FrameData::FloatQuaternion>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        PlatformXR::FrameData::Pose {
            WTFMove(*position),
            WTFMove(*orientation)
        }
    };
}

#endif

#if ENABLE(WEBXR)
void ArgumentCoder<PlatformXR::FrameData::Fov>::encode(Encoder& encoder, const PlatformXR::FrameData::Fov& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.up)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.down)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.left)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.right)>, float>);
    struct ShouldBeSameSizeAsFov : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<PlatformXR::FrameData::Fov>, false> {
        float up;
        float down;
        float left;
        float right;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFov) == sizeof(PlatformXR::FrameData::Fov));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(PlatformXR::FrameData::Fov, up)
        , offsetof(PlatformXR::FrameData::Fov, down)
        , offsetof(PlatformXR::FrameData::Fov, left)
        , offsetof(PlatformXR::FrameData::Fov, right)
    >::value);

    encoder << instance.up;
    encoder << instance.down;
    encoder << instance.left;
    encoder << instance.right;
}

std::optional<PlatformXR::FrameData::Fov> ArgumentCoder<PlatformXR::FrameData::Fov>::decode(Decoder& decoder)
{
    auto up = decoder.decode<float>();
    auto down = decoder.decode<float>();
    auto left = decoder.decode<float>();
    auto right = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        PlatformXR::FrameData::Fov {
            WTFMove(*up),
            WTFMove(*down),
            WTFMove(*left),
            WTFMove(*right)
        }
    };
}

#endif

#if ENABLE(WEBXR)
void ArgumentCoder<PlatformXR::FrameData::View>::encode(Encoder& encoder, const PlatformXR::FrameData::View& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.offset)>, PlatformXR::FrameData::Pose>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.projection)>, PlatformXR::FrameData::Projection>);
    struct ShouldBeSameSizeAsView : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<PlatformXR::FrameData::View>, false> {
        PlatformXR::FrameData::Pose offset;
        PlatformXR::FrameData::Projection projection;
    };
    static_assert(sizeof(ShouldBeSameSizeAsView) == sizeof(PlatformXR::FrameData::View));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(PlatformXR::FrameData::View, offset)
        , offsetof(PlatformXR::FrameData::View, projection)
    >::value);

    encoder << instance.offset;
    encoder << instance.projection;
}

std::optional<PlatformXR::FrameData::View> ArgumentCoder<PlatformXR::FrameData::View>::decode(Decoder& decoder)
{
    auto offset = decoder.decode<PlatformXR::FrameData::Pose>();
    auto projection = decoder.decode<PlatformXR::FrameData::Projection>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        PlatformXR::FrameData::View {
            WTFMove(*offset),
            WTFMove(*projection)
        }
    };
}

#endif

#if ENABLE(WEBXR)
void ArgumentCoder<PlatformXR::FrameData::StageParameters>::encode(Encoder& encoder, const PlatformXR::FrameData::StageParameters& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.id)>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bounds)>, Vector<WebCore::FloatPoint>>);
    struct ShouldBeSameSizeAsStageParameters : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<PlatformXR::FrameData::StageParameters>, false> {
        int id;
        Vector<WebCore::FloatPoint> bounds;
    };
    static_assert(sizeof(ShouldBeSameSizeAsStageParameters) == sizeof(PlatformXR::FrameData::StageParameters));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(PlatformXR::FrameData::StageParameters, id)
        , offsetof(PlatformXR::FrameData::StageParameters, bounds)
    >::value);

    encoder << instance.id;
    encoder << instance.bounds;
}

std::optional<PlatformXR::FrameData::StageParameters> ArgumentCoder<PlatformXR::FrameData::StageParameters>::decode(Decoder& decoder)
{
    auto id = decoder.decode<int>();
    auto bounds = decoder.decode<Vector<WebCore::FloatPoint>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        PlatformXR::FrameData::StageParameters {
            WTFMove(*id),
            WTFMove(*bounds)
        }
    };
}

#endif

#if (ENABLE(WEBXR)) && (PLATFORM(COCOA))
void ArgumentCoder<PlatformXR::FrameData::RateMapDescription>::encode(Encoder& encoder, const PlatformXR::FrameData::RateMapDescription& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.screenSize)>, WebCore::IntSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.horizontalSamplesLeft)>, Vector<float>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.horizontalSamplesRight)>, Vector<float>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.verticalSamples)>, Vector<float>>);
    struct ShouldBeSameSizeAsRateMapDescription : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<PlatformXR::FrameData::RateMapDescription>, false> {
        WebCore::IntSize screenSize;
        Vector<float> horizontalSamplesLeft;
        Vector<float> horizontalSamplesRight;
        Vector<float> verticalSamples;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRateMapDescription) == sizeof(PlatformXR::FrameData::RateMapDescription));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(PlatformXR::FrameData::RateMapDescription, screenSize)
        , offsetof(PlatformXR::FrameData::RateMapDescription, horizontalSamplesLeft)
        , offsetof(PlatformXR::FrameData::RateMapDescription, horizontalSamplesRight)
        , offsetof(PlatformXR::FrameData::RateMapDescription, verticalSamples)
    >::value);

    encoder << instance.screenSize;
    encoder << instance.horizontalSamplesLeft;
    encoder << instance.horizontalSamplesRight;
    encoder << instance.verticalSamples;
}

std::optional<PlatformXR::FrameData::RateMapDescription> ArgumentCoder<PlatformXR::FrameData::RateMapDescription>::decode(Decoder& decoder)
{
    auto screenSize = decoder.decode<WebCore::IntSize>();
    auto horizontalSamplesLeft = decoder.decode<Vector<float>>();
    auto horizontalSamplesRight = decoder.decode<Vector<float>>();
    auto verticalSamples = decoder.decode<Vector<float>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        PlatformXR::FrameData::RateMapDescription {
            WTFMove(*screenSize),
            WTFMove(*horizontalSamplesLeft),
            WTFMove(*horizontalSamplesRight),
            WTFMove(*verticalSamples)
        }
    };
}

#endif

#if (ENABLE(WEBXR)) && (PLATFORM(COCOA))
void ArgumentCoder<PlatformXR::FrameData::LayerSetupData>::encode(Encoder& encoder, PlatformXR::FrameData::LayerSetupData&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.physicalSize)>, std::array<std::array<uint16_t, 2>, 2>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.viewports)>, std::array<WebCore::IntRect, 2>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.foveationRateMapDesc)>, PlatformXR::FrameData::RateMapDescription>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.completionSyncEvent)>, MachSendRight>);
    struct ShouldBeSameSizeAsLayerSetupData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<PlatformXR::FrameData::LayerSetupData>, false> {
        std::array<std::array<uint16_t, 2>, 2> physicalSize;
        std::array<WebCore::IntRect, 2> viewports;
        PlatformXR::FrameData::RateMapDescription foveationRateMapDesc;
        MachSendRight completionSyncEvent;
    };
    static_assert(sizeof(ShouldBeSameSizeAsLayerSetupData) == sizeof(PlatformXR::FrameData::LayerSetupData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(PlatformXR::FrameData::LayerSetupData, physicalSize)
        , offsetof(PlatformXR::FrameData::LayerSetupData, viewports)
        , offsetof(PlatformXR::FrameData::LayerSetupData, foveationRateMapDesc)
        , offsetof(PlatformXR::FrameData::LayerSetupData, completionSyncEvent)
    >::value);

    encoder << WTFMove(instance.physicalSize);
    encoder << WTFMove(instance.viewports);
    encoder << WTFMove(instance.foveationRateMapDesc);
    encoder << WTFMove(instance.completionSyncEvent);
}

std::optional<PlatformXR::FrameData::LayerSetupData> ArgumentCoder<PlatformXR::FrameData::LayerSetupData>::decode(Decoder& decoder)
{
    auto physicalSize = decoder.decode<std::array<std::array<uint16_t, 2>, 2>>();
    auto viewports = decoder.decode<std::array<WebCore::IntRect, 2>>();
    auto foveationRateMapDesc = decoder.decode<PlatformXR::FrameData::RateMapDescription>();
    auto completionSyncEvent = decoder.decode<MachSendRight>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        PlatformXR::FrameData::LayerSetupData {
            WTFMove(*physicalSize),
            WTFMove(*viewports),
            WTFMove(*foveationRateMapDesc),
            WTFMove(*completionSyncEvent)
        }
    };
}

#endif

#if (ENABLE(WEBXR)) && (PLATFORM(COCOA))
void ArgumentCoder<PlatformXR::FrameData::ExternalTexture>::encode(Encoder& encoder, PlatformXR::FrameData::ExternalTexture&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.handle)>, MachSendRight>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isSharedTexture)>, bool>);
    struct ShouldBeSameSizeAsExternalTexture : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<PlatformXR::FrameData::ExternalTexture>, false> {
        MachSendRight handle;
        bool isSharedTexture;
    };
    static_assert(sizeof(ShouldBeSameSizeAsExternalTexture) == sizeof(PlatformXR::FrameData::ExternalTexture));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(PlatformXR::FrameData::ExternalTexture, handle)
        , offsetof(PlatformXR::FrameData::ExternalTexture, isSharedTexture)
    >::value);

    encoder << WTFMove(instance.handle);
    encoder << WTFMove(instance.isSharedTexture);
}

std::optional<PlatformXR::FrameData::ExternalTexture> ArgumentCoder<PlatformXR::FrameData::ExternalTexture>::decode(Decoder& decoder)
{
    auto handle = decoder.decode<MachSendRight>();
    auto isSharedTexture = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        PlatformXR::FrameData::ExternalTexture {
            WTFMove(*handle),
            WTFMove(*isSharedTexture)
        }
    };
}

#endif

#if (ENABLE(WEBXR)) && (PLATFORM(COCOA))
void ArgumentCoder<PlatformXR::FrameData::ExternalTextureData>::encode(Encoder& encoder, PlatformXR::FrameData::ExternalTextureData&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.reusableTextureIndex)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorTexture)>, PlatformXR::FrameData::ExternalTexture>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.depthStencilBuffer)>, PlatformXR::FrameData::ExternalTexture>);
    struct ShouldBeSameSizeAsExternalTextureData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<PlatformXR::FrameData::ExternalTextureData>, false> {
        uint64_t reusableTextureIndex;
        PlatformXR::FrameData::ExternalTexture colorTexture;
        PlatformXR::FrameData::ExternalTexture depthStencilBuffer;
    };
    static_assert(sizeof(ShouldBeSameSizeAsExternalTextureData) == sizeof(PlatformXR::FrameData::ExternalTextureData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(PlatformXR::FrameData::ExternalTextureData, reusableTextureIndex)
        , offsetof(PlatformXR::FrameData::ExternalTextureData, colorTexture)
        , offsetof(PlatformXR::FrameData::ExternalTextureData, depthStencilBuffer)
    >::value);

    encoder << WTFMove(instance.reusableTextureIndex);
    encoder << WTFMove(instance.colorTexture);
    encoder << WTFMove(instance.depthStencilBuffer);
}

std::optional<PlatformXR::FrameData::ExternalTextureData> ArgumentCoder<PlatformXR::FrameData::ExternalTextureData>::decode(Decoder& decoder)
{
    auto reusableTextureIndex = decoder.decode<uint64_t>();
    auto colorTexture = decoder.decode<PlatformXR::FrameData::ExternalTexture>();
    auto depthStencilBuffer = decoder.decode<PlatformXR::FrameData::ExternalTexture>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        PlatformXR::FrameData::ExternalTextureData {
            WTFMove(*reusableTextureIndex),
            WTFMove(*colorTexture),
            WTFMove(*depthStencilBuffer)
        }
    };
}

#endif

#if ENABLE(WEBXR)
void ArgumentCoder<PlatformXR::FrameData::LayerData>::encode(Encoder& encoder, PlatformXR::FrameData::LayerData&& instance)
{
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.layerSetup)>, std::optional<PlatformXR::FrameData::LayerSetupData>>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.renderingFrameIndex)>, uint64_t>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.textureData)>, std::optional<PlatformXR::FrameData::ExternalTextureData>>);
#endif
#if PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requestDepth)>, bool>);
#endif
#if !(PLATFORM(COCOA))
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.framebufferSize)>, WebCore::IntSize>);
#endif
#if !(PLATFORM(COCOA))
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.opaqueTexture)>, PlatformGLObject>);
#endif
    struct ShouldBeSameSizeAsLayerData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<PlatformXR::FrameData::LayerData>, false> {
#if PLATFORM(COCOA)
        std::optional<PlatformXR::FrameData::LayerSetupData> layerSetup;
#endif
#if PLATFORM(COCOA)
        uint64_t renderingFrameIndex;
#endif
#if PLATFORM(COCOA)
        std::optional<PlatformXR::FrameData::ExternalTextureData> textureData;
#endif
#if PLATFORM(COCOA)
        bool requestDepth;
#endif
#if !(PLATFORM(COCOA))
        WebCore::IntSize framebufferSize;
#endif
#if !(PLATFORM(COCOA))
        PlatformGLObject opaqueTexture;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsLayerData) == sizeof(PlatformXR::FrameData::LayerData));
    static_assert(MembersInCorrectOrder < 0
#if PLATFORM(COCOA)
        , offsetof(PlatformXR::FrameData::LayerData, layerSetup)
#endif
#if PLATFORM(COCOA)
        , offsetof(PlatformXR::FrameData::LayerData, renderingFrameIndex)
#endif
#if PLATFORM(COCOA)
        , offsetof(PlatformXR::FrameData::LayerData, textureData)
#endif
#if PLATFORM(COCOA)
        , offsetof(PlatformXR::FrameData::LayerData, requestDepth)
#endif
#if !(PLATFORM(COCOA))
        , offsetof(PlatformXR::FrameData::LayerData, framebufferSize)
#endif
#if !(PLATFORM(COCOA))
        , offsetof(PlatformXR::FrameData::LayerData, opaqueTexture)
#endif
    >::value);

#if PLATFORM(COCOA)
    encoder << WTFMove(instance.layerSetup);
#endif
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.renderingFrameIndex);
#endif
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.textureData);
#endif
#if PLATFORM(COCOA)
    encoder << WTFMove(instance.requestDepth);
#endif
#if !(PLATFORM(COCOA))
    encoder << WTFMove(instance.framebufferSize);
#endif
#if !(PLATFORM(COCOA))
    encoder << WTFMove(instance.opaqueTexture);
#endif
}

std::optional<PlatformXR::FrameData::LayerData> ArgumentCoder<PlatformXR::FrameData::LayerData>::decode(Decoder& decoder)
{
#if PLATFORM(COCOA)
    auto layerSetup = decoder.decode<std::optional<PlatformXR::FrameData::LayerSetupData>>();
#endif
#if PLATFORM(COCOA)
    auto renderingFrameIndex = decoder.decode<uint64_t>();
#endif
#if PLATFORM(COCOA)
    auto textureData = decoder.decode<std::optional<PlatformXR::FrameData::ExternalTextureData>>();
#endif
#if PLATFORM(COCOA)
    auto requestDepth = decoder.decode<bool>();
#endif
#if !(PLATFORM(COCOA))
    auto framebufferSize = decoder.decode<WebCore::IntSize>();
#endif
#if !(PLATFORM(COCOA))
    auto opaqueTexture = decoder.decode<PlatformGLObject>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        PlatformXR::FrameData::LayerData {
#if PLATFORM(COCOA)
            WTFMove(*layerSetup),
#endif
#if PLATFORM(COCOA)
            WTFMove(*renderingFrameIndex),
#endif
#if PLATFORM(COCOA)
            WTFMove(*textureData),
#endif
#if PLATFORM(COCOA)
            WTFMove(*requestDepth),
#endif
#if !(PLATFORM(COCOA))
            WTFMove(*framebufferSize),
#endif
#if !(PLATFORM(COCOA))
            WTFMove(*opaqueTexture)
#endif
        }
    };
}

#endif

#if ENABLE(WEBXR)
void ArgumentCoder<PlatformXR::FrameData::InputSourceButton>::encode(Encoder& encoder, const PlatformXR::FrameData::InputSourceButton& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.touched)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pressed)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pressedValue)>, float>);
    struct ShouldBeSameSizeAsInputSourceButton : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<PlatformXR::FrameData::InputSourceButton>, false> {
        bool touched;
        bool pressed;
        float pressedValue;
    };
    static_assert(sizeof(ShouldBeSameSizeAsInputSourceButton) == sizeof(PlatformXR::FrameData::InputSourceButton));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(PlatformXR::FrameData::InputSourceButton, touched)
        , offsetof(PlatformXR::FrameData::InputSourceButton, pressed)
        , offsetof(PlatformXR::FrameData::InputSourceButton, pressedValue)
    >::value);

    encoder << instance.touched;
    encoder << instance.pressed;
    encoder << instance.pressedValue;
}

std::optional<PlatformXR::FrameData::InputSourceButton> ArgumentCoder<PlatformXR::FrameData::InputSourceButton>::decode(Decoder& decoder)
{
    auto touched = decoder.decode<bool>();
    auto pressed = decoder.decode<bool>();
    auto pressedValue = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        PlatformXR::FrameData::InputSourceButton {
            WTFMove(*touched),
            WTFMove(*pressed),
            WTFMove(*pressedValue)
        }
    };
}

#endif

#if ENABLE(WEBXR)
void ArgumentCoder<PlatformXR::FrameData::InputSourcePose>::encode(Encoder& encoder, const PlatformXR::FrameData::InputSourcePose& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pose)>, PlatformXR::FrameData::Pose>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isPositionEmulated)>, bool>);
    struct ShouldBeSameSizeAsInputSourcePose : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<PlatformXR::FrameData::InputSourcePose>, false> {
        PlatformXR::FrameData::Pose pose;
        bool isPositionEmulated;
    };
    static_assert(sizeof(ShouldBeSameSizeAsInputSourcePose) == sizeof(PlatformXR::FrameData::InputSourcePose));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(PlatformXR::FrameData::InputSourcePose, pose)
        , offsetof(PlatformXR::FrameData::InputSourcePose, isPositionEmulated)
    >::value);

    encoder << instance.pose;
    encoder << instance.isPositionEmulated;
}

std::optional<PlatformXR::FrameData::InputSourcePose> ArgumentCoder<PlatformXR::FrameData::InputSourcePose>::decode(Decoder& decoder)
{
    auto pose = decoder.decode<PlatformXR::FrameData::Pose>();
    auto isPositionEmulated = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        PlatformXR::FrameData::InputSourcePose {
            WTFMove(*pose),
            WTFMove(*isPositionEmulated)
        }
    };
}

#endif

#if ENABLE(WEBXR_HANDS)
void ArgumentCoder<PlatformXR::FrameData::InputSourceHandJoint>::encode(Encoder& encoder, const PlatformXR::FrameData::InputSourceHandJoint& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pose)>, PlatformXR::FrameData::InputSourcePose>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.radius)>, float>);
    struct ShouldBeSameSizeAsInputSourceHandJoint : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<PlatformXR::FrameData::InputSourceHandJoint>, false> {
        PlatformXR::FrameData::InputSourcePose pose;
        float radius;
    };
    static_assert(sizeof(ShouldBeSameSizeAsInputSourceHandJoint) == sizeof(PlatformXR::FrameData::InputSourceHandJoint));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(PlatformXR::FrameData::InputSourceHandJoint, pose)
        , offsetof(PlatformXR::FrameData::InputSourceHandJoint, radius)
    >::value);

    encoder << instance.pose;
    encoder << instance.radius;
}

std::optional<PlatformXR::FrameData::InputSourceHandJoint> ArgumentCoder<PlatformXR::FrameData::InputSourceHandJoint>::decode(Decoder& decoder)
{
    auto pose = decoder.decode<PlatformXR::FrameData::InputSourcePose>();
    auto radius = decoder.decode<float>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        PlatformXR::FrameData::InputSourceHandJoint {
            WTFMove(*pose),
            WTFMove(*radius)
        }
    };
}

#endif

#if ENABLE(WEBXR)
void ArgumentCoder<PlatformXR::FrameData::InputSource>::encode(Encoder& encoder, const PlatformXR::FrameData::InputSource& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.handle)>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.handedness)>, PlatformXR::XRHandedness>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.targetRayMode)>, PlatformXR::XRTargetRayMode>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.profiles)>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pointerOrigin)>, PlatformXR::FrameData::InputSourcePose>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.gripOrigin)>, std::optional<PlatformXR::FrameData::InputSourcePose>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.buttons)>, Vector<PlatformXR::FrameData::InputSourceButton>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.axes)>, Vector<float>>);
#if ENABLE(WEBXR_HANDS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.handJoints)>, std::optional<PlatformXR::FrameData::HandJointsVector>>);
#endif
    struct ShouldBeSameSizeAsInputSource : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<PlatformXR::FrameData::InputSource>, false> {
        int handle;
        PlatformXR::XRHandedness handedness;
        PlatformXR::XRTargetRayMode targetRayMode;
        Vector<String> profiles;
        PlatformXR::FrameData::InputSourcePose pointerOrigin;
        std::optional<PlatformXR::FrameData::InputSourcePose> gripOrigin;
        Vector<PlatformXR::FrameData::InputSourceButton> buttons;
        Vector<float> axes;
#if ENABLE(WEBXR_HANDS)
        std::optional<PlatformXR::FrameData::HandJointsVector> handJoints;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsInputSource) == sizeof(PlatformXR::FrameData::InputSource));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(PlatformXR::FrameData::InputSource, handle)
        , offsetof(PlatformXR::FrameData::InputSource, handedness)
        , offsetof(PlatformXR::FrameData::InputSource, targetRayMode)
        , offsetof(PlatformXR::FrameData::InputSource, profiles)
        , offsetof(PlatformXR::FrameData::InputSource, pointerOrigin)
        , offsetof(PlatformXR::FrameData::InputSource, gripOrigin)
        , offsetof(PlatformXR::FrameData::InputSource, buttons)
        , offsetof(PlatformXR::FrameData::InputSource, axes)
#if ENABLE(WEBXR_HANDS)
        , offsetof(PlatformXR::FrameData::InputSource, handJoints)
#endif
    >::value);

    encoder << instance.handle;
    encoder << instance.handedness;
    encoder << instance.targetRayMode;
    encoder << instance.profiles;
    encoder << instance.pointerOrigin;
    encoder << instance.gripOrigin;
    encoder << instance.buttons;
    encoder << instance.axes;
#if ENABLE(WEBXR_HANDS)
    encoder << instance.handJoints;
#endif
}

std::optional<PlatformXR::FrameData::InputSource> ArgumentCoder<PlatformXR::FrameData::InputSource>::decode(Decoder& decoder)
{
    auto handle = decoder.decode<int>();
    auto handedness = decoder.decode<PlatformXR::XRHandedness>();
    auto targetRayMode = decoder.decode<PlatformXR::XRTargetRayMode>();
    auto profiles = decoder.decode<Vector<String>>();
    auto pointerOrigin = decoder.decode<PlatformXR::FrameData::InputSourcePose>();
    auto gripOrigin = decoder.decode<std::optional<PlatformXR::FrameData::InputSourcePose>>();
    auto buttons = decoder.decode<Vector<PlatformXR::FrameData::InputSourceButton>>();
    auto axes = decoder.decode<Vector<float>>();
#if ENABLE(WEBXR_HANDS)
    auto handJoints = decoder.decode<std::optional<PlatformXR::FrameData::HandJointsVector>>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        PlatformXR::FrameData::InputSource {
            WTFMove(*handle),
            WTFMove(*handedness),
            WTFMove(*targetRayMode),
            WTFMove(*profiles),
            WTFMove(*pointerOrigin),
            WTFMove(*gripOrigin),
            WTFMove(*buttons),
            WTFMove(*axes),
#if ENABLE(WEBXR_HANDS)
            WTFMove(*handJoints)
#endif
        }
    };
}

#endif

#if ENABLE(WEBXR)
void ArgumentCoder<PlatformXR::FrameData>::encode(Encoder& encoder, PlatformXR::FrameData&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isTrackingValid)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isPositionValid)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isPositionEmulated)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldRender)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.predictedDisplayTime)>, long>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.origin)>, PlatformXR::FrameData::Pose>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.floorTransform)>, std::optional<PlatformXR::FrameData::Pose>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.stageParameters)>, PlatformXR::FrameData::StageParameters>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.views)>, Vector<PlatformXR::FrameData::View>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.layers)>, HashMap<PlatformXR::LayerHandle, UniqueRef<PlatformXR::FrameData::LayerData>>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.inputSources)>, Vector<PlatformXR::FrameData::InputSource>>);
    struct ShouldBeSameSizeAsFrameData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<PlatformXR::FrameData>, false> {
        bool isTrackingValid;
        bool isPositionValid;
        bool isPositionEmulated;
        bool shouldRender;
        long predictedDisplayTime;
        PlatformXR::FrameData::Pose origin;
        std::optional<PlatformXR::FrameData::Pose> floorTransform;
        PlatformXR::FrameData::StageParameters stageParameters;
        Vector<PlatformXR::FrameData::View> views;
        HashMap<PlatformXR::LayerHandle, UniqueRef<PlatformXR::FrameData::LayerData>> layers;
        Vector<PlatformXR::FrameData::InputSource> inputSources;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFrameData) == sizeof(PlatformXR::FrameData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(PlatformXR::FrameData, isTrackingValid)
        , offsetof(PlatformXR::FrameData, isPositionValid)
        , offsetof(PlatformXR::FrameData, isPositionEmulated)
        , offsetof(PlatformXR::FrameData, shouldRender)
        , offsetof(PlatformXR::FrameData, predictedDisplayTime)
        , offsetof(PlatformXR::FrameData, origin)
        , offsetof(PlatformXR::FrameData, floorTransform)
        , offsetof(PlatformXR::FrameData, stageParameters)
        , offsetof(PlatformXR::FrameData, views)
        , offsetof(PlatformXR::FrameData, layers)
        , offsetof(PlatformXR::FrameData, inputSources)
    >::value);

    encoder << WTFMove(instance.isTrackingValid);
    encoder << WTFMove(instance.isPositionValid);
    encoder << WTFMove(instance.isPositionEmulated);
    encoder << WTFMove(instance.shouldRender);
    encoder << WTFMove(instance.predictedDisplayTime);
    encoder << WTFMove(instance.origin);
    encoder << WTFMove(instance.floorTransform);
    encoder << WTFMove(instance.stageParameters);
    encoder << WTFMove(instance.views);
    encoder << WTFMove(instance.layers);
    encoder << WTFMove(instance.inputSources);
}

std::optional<PlatformXR::FrameData> ArgumentCoder<PlatformXR::FrameData>::decode(Decoder& decoder)
{
    auto isTrackingValid = decoder.decode<bool>();
    auto isPositionValid = decoder.decode<bool>();
    auto isPositionEmulated = decoder.decode<bool>();
    auto shouldRender = decoder.decode<bool>();
    auto predictedDisplayTime = decoder.decode<long>();
    auto origin = decoder.decode<PlatformXR::FrameData::Pose>();
    auto floorTransform = decoder.decode<std::optional<PlatformXR::FrameData::Pose>>();
    auto stageParameters = decoder.decode<PlatformXR::FrameData::StageParameters>();
    auto views = decoder.decode<Vector<PlatformXR::FrameData::View>>();
    auto layers = decoder.decode<HashMap<PlatformXR::LayerHandle, UniqueRef<PlatformXR::FrameData::LayerData>>>();
    auto inputSources = decoder.decode<Vector<PlatformXR::FrameData::InputSource>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        PlatformXR::FrameData {
            WTFMove(*isTrackingValid),
            WTFMove(*isPositionValid),
            WTFMove(*isPositionEmulated),
            WTFMove(*shouldRender),
            WTFMove(*predictedDisplayTime),
            WTFMove(*origin),
            WTFMove(*floorTransform),
            WTFMove(*stageParameters),
            WTFMove(*views),
            WTFMove(*layers),
            WTFMove(*inputSources)
        }
    };
}

#endif

#if (ENABLE(WEBXR)) && (USE(OPENXR))
void ArgumentCoder<PlatformXR::Device::LayerView>::encode(Encoder& encoder, const PlatformXR::Device::LayerView& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.eye)>, PlatformXR::Eye>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.viewport)>, WebCore::IntRect>);
    struct ShouldBeSameSizeAsLayerView : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<PlatformXR::Device::LayerView>, false> {
        PlatformXR::Eye eye;
        WebCore::IntRect viewport;
    };
    static_assert(sizeof(ShouldBeSameSizeAsLayerView) == sizeof(PlatformXR::Device::LayerView));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(PlatformXR::Device::LayerView, eye)
        , offsetof(PlatformXR::Device::LayerView, viewport)
    >::value);

    encoder << instance.eye;
    encoder << instance.viewport;
}

std::optional<PlatformXR::Device::LayerView> ArgumentCoder<PlatformXR::Device::LayerView>::decode(Decoder& decoder)
{
    auto eye = decoder.decode<PlatformXR::Eye>();
    auto viewport = decoder.decode<WebCore::IntRect>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        PlatformXR::Device::LayerView {
            WTFMove(*eye),
            WTFMove(*viewport)
        }
    };
}

#endif

#if ENABLE(WEBXR)
void ArgumentCoder<WebKit::XRDeviceInfo>::encode(Encoder& encoder, const WebKit::XRDeviceInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifier)>, WebKit::XRDeviceIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsOrientationTracking)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsStereoRendering)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.vrFeatures)>, PlatformXR::Device::FeatureList>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.arFeatures)>, PlatformXR::Device::FeatureList>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.recommendedResolution)>, WebCore::IntSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.minimumNearClipPlane)>, double>);
    struct ShouldBeSameSizeAsXRDeviceInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::XRDeviceInfo>, false> {
        WebKit::XRDeviceIdentifier identifier;
        bool supportsOrientationTracking;
        bool supportsStereoRendering;
        PlatformXR::Device::FeatureList vrFeatures;
        PlatformXR::Device::FeatureList arFeatures;
        WebCore::IntSize recommendedResolution;
        double minimumNearClipPlane;
    };
    static_assert(sizeof(ShouldBeSameSizeAsXRDeviceInfo) == sizeof(WebKit::XRDeviceInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::XRDeviceInfo, identifier)
        , offsetof(WebKit::XRDeviceInfo, supportsOrientationTracking)
        , offsetof(WebKit::XRDeviceInfo, supportsStereoRendering)
        , offsetof(WebKit::XRDeviceInfo, vrFeatures)
        , offsetof(WebKit::XRDeviceInfo, arFeatures)
        , offsetof(WebKit::XRDeviceInfo, recommendedResolution)
        , offsetof(WebKit::XRDeviceInfo, minimumNearClipPlane)
    >::value);

    encoder << instance.identifier;
    encoder << instance.supportsOrientationTracking;
    encoder << instance.supportsStereoRendering;
    encoder << instance.vrFeatures;
    encoder << instance.arFeatures;
    encoder << instance.recommendedResolution;
    encoder << instance.minimumNearClipPlane;
}

std::optional<WebKit::XRDeviceInfo> ArgumentCoder<WebKit::XRDeviceInfo>::decode(Decoder& decoder)
{
    auto identifier = decoder.decode<WebKit::XRDeviceIdentifier>();
    auto supportsOrientationTracking = decoder.decode<bool>();
    auto supportsStereoRendering = decoder.decode<bool>();
    auto vrFeatures = decoder.decode<PlatformXR::Device::FeatureList>();
    auto arFeatures = decoder.decode<PlatformXR::Device::FeatureList>();
    auto recommendedResolution = decoder.decode<WebCore::IntSize>();
    auto minimumNearClipPlane = decoder.decode<double>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::XRDeviceInfo {
            WTFMove(*identifier),
            WTFMove(*supportsOrientationTracking),
            WTFMove(*supportsStereoRendering),
            WTFMove(*vrFeatures),
            WTFMove(*arFeatures),
            WTFMove(*recommendedResolution),
            WTFMove(*minimumNearClipPlane)
        }
    };
}

#endif

#if (ENABLE(WEBXR)) && (USE(OPENXR))
void ArgumentCoder<WebKit::XRDeviceLayer>::encode(Encoder& encoder, const WebKit::XRDeviceLayer& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.handle)>, PlatformXR::LayerHandle>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.visible)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.views)>, Vector<PlatformXR::Device::LayerView>>);
    struct ShouldBeSameSizeAsXRDeviceLayer : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::XRDeviceLayer>, false> {
        PlatformXR::LayerHandle handle;
        bool visible;
        Vector<PlatformXR::Device::LayerView> views;
    };
    static_assert(sizeof(ShouldBeSameSizeAsXRDeviceLayer) == sizeof(WebKit::XRDeviceLayer));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::XRDeviceLayer, handle)
        , offsetof(WebKit::XRDeviceLayer, visible)
        , offsetof(WebKit::XRDeviceLayer, views)
    >::value);

    encoder << instance.handle;
    encoder << instance.visible;
    encoder << instance.views;
}

std::optional<WebKit::XRDeviceLayer> ArgumentCoder<WebKit::XRDeviceLayer>::decode(Decoder& decoder)
{
    auto handle = decoder.decode<PlatformXR::LayerHandle>();
    auto visible = decoder.decode<bool>();
    auto views = decoder.decode<Vector<PlatformXR::Device::LayerView>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::XRDeviceLayer {
            WTFMove(*handle),
            WTFMove(*visible),
            WTFMove(*views)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::GPUProcessConnectionInfo>::encode(Encoder& encoder, const WebKit::GPUProcessConnectionInfo& instance)
{
#if HAVE(AUDIT_TOKEN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.auditToken)>, std::optional<WebKit::CoreIPCAuditToken>>);
#endif
#if ENABLE(VP9)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasVP9HardwareDecoder)>, bool>);
#endif
#if ENABLE(AV1)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasAV1HardwareDecoder)>, bool>);
#endif
    struct ShouldBeSameSizeAsGPUProcessConnectionInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::GPUProcessConnectionInfo>, false> {
#if HAVE(AUDIT_TOKEN)
        std::optional<WebKit::CoreIPCAuditToken> auditToken;
#endif
#if ENABLE(VP9)
        bool hasVP9HardwareDecoder;
#endif
#if ENABLE(AV1)
        bool hasAV1HardwareDecoder;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsGPUProcessConnectionInfo) == sizeof(WebKit::GPUProcessConnectionInfo));
    static_assert(MembersInCorrectOrder < 0
#if HAVE(AUDIT_TOKEN)
        , offsetof(WebKit::GPUProcessConnectionInfo, auditToken)
#endif
#if ENABLE(VP9)
        , offsetof(WebKit::GPUProcessConnectionInfo, hasVP9HardwareDecoder)
#endif
#if ENABLE(AV1)
        , offsetof(WebKit::GPUProcessConnectionInfo, hasAV1HardwareDecoder)
#endif
    >::value);

#if HAVE(AUDIT_TOKEN)
    encoder << instance.auditToken;
#endif
#if ENABLE(VP9)
    encoder << instance.hasVP9HardwareDecoder;
#endif
#if ENABLE(AV1)
    encoder << instance.hasAV1HardwareDecoder;
#endif
}

std::optional<WebKit::GPUProcessConnectionInfo> ArgumentCoder<WebKit::GPUProcessConnectionInfo>::decode(Decoder& decoder)
{
#if HAVE(AUDIT_TOKEN)
    auto auditToken = decoder.decode<std::optional<WebKit::CoreIPCAuditToken>>();
#endif
#if ENABLE(VP9)
    auto hasVP9HardwareDecoder = decoder.decode<bool>();
#endif
#if ENABLE(AV1)
    auto hasAV1HardwareDecoder = decoder.decode<bool>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::GPUProcessConnectionInfo {
#if HAVE(AUDIT_TOKEN)
            WTFMove(*auditToken),
#endif
#if ENABLE(VP9)
            WTFMove(*hasVP9HardwareDecoder),
#endif
#if ENABLE(AV1)
            WTFMove(*hasAV1HardwareDecoder)
#endif
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::BufferIdentifierSet>::encode(Encoder& encoder, const WebKit::BufferIdentifierSet& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.front)>, std::optional<WebCore::RenderingResourceIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.back)>, std::optional<WebCore::RenderingResourceIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.secondaryBack)>, std::optional<WebCore::RenderingResourceIdentifier>>);
    struct ShouldBeSameSizeAsBufferIdentifierSet : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::BufferIdentifierSet>, false> {
        std::optional<WebCore::RenderingResourceIdentifier> front;
        std::optional<WebCore::RenderingResourceIdentifier> back;
        std::optional<WebCore::RenderingResourceIdentifier> secondaryBack;
    };
    static_assert(sizeof(ShouldBeSameSizeAsBufferIdentifierSet) == sizeof(WebKit::BufferIdentifierSet));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::BufferIdentifierSet, front)
        , offsetof(WebKit::BufferIdentifierSet, back)
        , offsetof(WebKit::BufferIdentifierSet, secondaryBack)
    >::value);

    encoder << instance.front;
    encoder << instance.back;
    encoder << instance.secondaryBack;
}

void ArgumentCoder<WebKit::BufferIdentifierSet>::encode(StreamConnectionEncoder& encoder, const WebKit::BufferIdentifierSet& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.front)>, std::optional<WebCore::RenderingResourceIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.back)>, std::optional<WebCore::RenderingResourceIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.secondaryBack)>, std::optional<WebCore::RenderingResourceIdentifier>>);
    struct ShouldBeSameSizeAsBufferIdentifierSet : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::BufferIdentifierSet>, false> {
        std::optional<WebCore::RenderingResourceIdentifier> front;
        std::optional<WebCore::RenderingResourceIdentifier> back;
        std::optional<WebCore::RenderingResourceIdentifier> secondaryBack;
    };
    static_assert(sizeof(ShouldBeSameSizeAsBufferIdentifierSet) == sizeof(WebKit::BufferIdentifierSet));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::BufferIdentifierSet, front)
        , offsetof(WebKit::BufferIdentifierSet, back)
        , offsetof(WebKit::BufferIdentifierSet, secondaryBack)
    >::value);

    encoder << instance.front;
    encoder << instance.back;
    encoder << instance.secondaryBack;
}

std::optional<WebKit::BufferIdentifierSet> ArgumentCoder<WebKit::BufferIdentifierSet>::decode(Decoder& decoder)
{
    auto front = decoder.decode<std::optional<WebCore::RenderingResourceIdentifier>>();
    auto back = decoder.decode<std::optional<WebCore::RenderingResourceIdentifier>>();
    auto secondaryBack = decoder.decode<std::optional<WebCore::RenderingResourceIdentifier>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::BufferIdentifierSet {
            WTFMove(*front),
            WTFMove(*back),
            WTFMove(*secondaryBack)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS) && PLATFORM(COCOA)
void ArgumentCoder<WebKit::ImageBufferSetPrepareBufferForDisplayInputData>::encode(Encoder& encoder, const WebKit::ImageBufferSetPrepareBufferForDisplayInputData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.remoteBufferSet)>, WebKit::RemoteImageBufferSetIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dirtyRegion)>, WebCore::Region>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsPartialRepaint)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasEmptyDirtyRegion)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requiresClearedPixels)>, bool>);
    struct ShouldBeSameSizeAsImageBufferSetPrepareBufferForDisplayInputData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::ImageBufferSetPrepareBufferForDisplayInputData>, false> {
        WebKit::RemoteImageBufferSetIdentifier remoteBufferSet;
        WebCore::Region dirtyRegion;
        bool supportsPartialRepaint;
        bool hasEmptyDirtyRegion;
        bool requiresClearedPixels;
    };
    static_assert(sizeof(ShouldBeSameSizeAsImageBufferSetPrepareBufferForDisplayInputData) == sizeof(WebKit::ImageBufferSetPrepareBufferForDisplayInputData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::ImageBufferSetPrepareBufferForDisplayInputData, remoteBufferSet)
        , offsetof(WebKit::ImageBufferSetPrepareBufferForDisplayInputData, dirtyRegion)
        , offsetof(WebKit::ImageBufferSetPrepareBufferForDisplayInputData, supportsPartialRepaint)
        , offsetof(WebKit::ImageBufferSetPrepareBufferForDisplayInputData, hasEmptyDirtyRegion)
        , offsetof(WebKit::ImageBufferSetPrepareBufferForDisplayInputData, requiresClearedPixels)
    >::value);

    encoder << instance.remoteBufferSet;
    encoder << instance.dirtyRegion;
    encoder << instance.supportsPartialRepaint;
    encoder << instance.hasEmptyDirtyRegion;
    encoder << instance.requiresClearedPixels;
}

void ArgumentCoder<WebKit::ImageBufferSetPrepareBufferForDisplayInputData>::encode(StreamConnectionEncoder& encoder, const WebKit::ImageBufferSetPrepareBufferForDisplayInputData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.remoteBufferSet)>, WebKit::RemoteImageBufferSetIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dirtyRegion)>, WebCore::Region>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsPartialRepaint)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasEmptyDirtyRegion)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.requiresClearedPixels)>, bool>);
    struct ShouldBeSameSizeAsImageBufferSetPrepareBufferForDisplayInputData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::ImageBufferSetPrepareBufferForDisplayInputData>, false> {
        WebKit::RemoteImageBufferSetIdentifier remoteBufferSet;
        WebCore::Region dirtyRegion;
        bool supportsPartialRepaint;
        bool hasEmptyDirtyRegion;
        bool requiresClearedPixels;
    };
    static_assert(sizeof(ShouldBeSameSizeAsImageBufferSetPrepareBufferForDisplayInputData) == sizeof(WebKit::ImageBufferSetPrepareBufferForDisplayInputData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::ImageBufferSetPrepareBufferForDisplayInputData, remoteBufferSet)
        , offsetof(WebKit::ImageBufferSetPrepareBufferForDisplayInputData, dirtyRegion)
        , offsetof(WebKit::ImageBufferSetPrepareBufferForDisplayInputData, supportsPartialRepaint)
        , offsetof(WebKit::ImageBufferSetPrepareBufferForDisplayInputData, hasEmptyDirtyRegion)
        , offsetof(WebKit::ImageBufferSetPrepareBufferForDisplayInputData, requiresClearedPixels)
    >::value);

    encoder << instance.remoteBufferSet;
    encoder << instance.dirtyRegion;
    encoder << instance.supportsPartialRepaint;
    encoder << instance.hasEmptyDirtyRegion;
    encoder << instance.requiresClearedPixels;
}

std::optional<WebKit::ImageBufferSetPrepareBufferForDisplayInputData> ArgumentCoder<WebKit::ImageBufferSetPrepareBufferForDisplayInputData>::decode(Decoder& decoder)
{
    auto remoteBufferSet = decoder.decode<WebKit::RemoteImageBufferSetIdentifier>();
    auto dirtyRegion = decoder.decode<WebCore::Region>();
    auto supportsPartialRepaint = decoder.decode<bool>();
    auto hasEmptyDirtyRegion = decoder.decode<bool>();
    auto requiresClearedPixels = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::ImageBufferSetPrepareBufferForDisplayInputData {
            WTFMove(*remoteBufferSet),
            WTFMove(*dirtyRegion),
            WTFMove(*supportsPartialRepaint),
            WTFMove(*hasEmptyDirtyRegion),
            WTFMove(*requiresClearedPixels)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS) && PLATFORM(COCOA)
void ArgumentCoder<WebKit::ImageBufferSetPrepareBufferForDisplayOutputData>::encode(Encoder& encoder, WebKit::ImageBufferSetPrepareBufferForDisplayOutputData&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.backendHandle)>, std::optional<WebKit::ImageBufferBackendHandle>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.displayRequirement)>, WebKit::SwapBuffersDisplayRequirement>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bufferCacheIdentifiers)>, WebKit::BufferIdentifierSet>);
    struct ShouldBeSameSizeAsImageBufferSetPrepareBufferForDisplayOutputData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::ImageBufferSetPrepareBufferForDisplayOutputData>, false> {
        std::optional<WebKit::ImageBufferBackendHandle> backendHandle;
        WebKit::SwapBuffersDisplayRequirement displayRequirement;
        WebKit::BufferIdentifierSet bufferCacheIdentifiers;
    };
    static_assert(sizeof(ShouldBeSameSizeAsImageBufferSetPrepareBufferForDisplayOutputData) == sizeof(WebKit::ImageBufferSetPrepareBufferForDisplayOutputData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::ImageBufferSetPrepareBufferForDisplayOutputData, backendHandle)
        , offsetof(WebKit::ImageBufferSetPrepareBufferForDisplayOutputData, displayRequirement)
        , offsetof(WebKit::ImageBufferSetPrepareBufferForDisplayOutputData, bufferCacheIdentifiers)
    >::value);

    encoder << WTFMove(instance.backendHandle);
    encoder << WTFMove(instance.displayRequirement);
    encoder << WTFMove(instance.bufferCacheIdentifiers);
}

std::optional<WebKit::ImageBufferSetPrepareBufferForDisplayOutputData> ArgumentCoder<WebKit::ImageBufferSetPrepareBufferForDisplayOutputData>::decode(Decoder& decoder)
{
    auto backendHandle = decoder.decode<std::optional<WebKit::ImageBufferBackendHandle>>();
    auto displayRequirement = decoder.decode<WebKit::SwapBuffersDisplayRequirement>();
    auto bufferCacheIdentifiers = decoder.decode<WebKit::BufferIdentifierSet>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::ImageBufferSetPrepareBufferForDisplayOutputData {
            WTFMove(*backendHandle),
            WTFMove(*displayRequirement),
            WTFMove(*bufferCacheIdentifiers)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::MediaOverridesForTesting>::encode(Encoder& encoder, const WebKit::MediaOverridesForTesting& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.systemHasAC)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.systemHasBattery)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.vp9HardwareDecoderDisabled)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.vp9DecoderDisabled)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.vp9ScreenSizeAndScale)>, std::optional<WebCore::ScreenDataOverrides>>);
    struct ShouldBeSameSizeAsMediaOverridesForTesting : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::MediaOverridesForTesting>, false> {
        std::optional<bool> systemHasAC;
        std::optional<bool> systemHasBattery;
        std::optional<bool> vp9HardwareDecoderDisabled;
        std::optional<bool> vp9DecoderDisabled;
        std::optional<WebCore::ScreenDataOverrides> vp9ScreenSizeAndScale;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMediaOverridesForTesting) == sizeof(WebKit::MediaOverridesForTesting));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::MediaOverridesForTesting, systemHasAC)
        , offsetof(WebKit::MediaOverridesForTesting, systemHasBattery)
        , offsetof(WebKit::MediaOverridesForTesting, vp9HardwareDecoderDisabled)
        , offsetof(WebKit::MediaOverridesForTesting, vp9DecoderDisabled)
        , offsetof(WebKit::MediaOverridesForTesting, vp9ScreenSizeAndScale)
    >::value);

    encoder << instance.systemHasAC;
    encoder << instance.systemHasBattery;
    encoder << instance.vp9HardwareDecoderDisabled;
    encoder << instance.vp9DecoderDisabled;
    encoder << instance.vp9ScreenSizeAndScale;
}

std::optional<WebKit::MediaOverridesForTesting> ArgumentCoder<WebKit::MediaOverridesForTesting>::decode(Decoder& decoder)
{
    auto systemHasAC = decoder.decode<std::optional<bool>>();
    auto systemHasBattery = decoder.decode<std::optional<bool>>();
    auto vp9HardwareDecoderDisabled = decoder.decode<std::optional<bool>>();
    auto vp9DecoderDisabled = decoder.decode<std::optional<bool>>();
    auto vp9ScreenSizeAndScale = decoder.decode<std::optional<WebCore::ScreenDataOverrides>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::MediaOverridesForTesting {
            WTFMove(*systemHasAC),
            WTFMove(*systemHasBattery),
            WTFMove(*vp9HardwareDecoderDisabled),
            WTFMove(*vp9DecoderDisabled),
            WTFMove(*vp9ScreenSizeAndScale)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS) && ENABLE(VIDEO)
void ArgumentCoder<WebKit::MediaTimeUpdateData>::encode(Encoder& encoder, const WebKit::MediaTimeUpdateData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.currentTime)>, MediaTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.timeIsProgressing)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.wallTime)>, MonotonicTime>);
    struct ShouldBeSameSizeAsMediaTimeUpdateData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::MediaTimeUpdateData>, false> {
        MediaTime currentTime;
        bool timeIsProgressing;
        MonotonicTime wallTime;
    };
    static_assert(sizeof(ShouldBeSameSizeAsMediaTimeUpdateData) == sizeof(WebKit::MediaTimeUpdateData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::MediaTimeUpdateData, currentTime)
        , offsetof(WebKit::MediaTimeUpdateData, timeIsProgressing)
        , offsetof(WebKit::MediaTimeUpdateData, wallTime)
    >::value);

    encoder << instance.currentTime;
    encoder << instance.timeIsProgressing;
    encoder << instance.wallTime;
}

std::optional<WebKit::MediaTimeUpdateData> ArgumentCoder<WebKit::MediaTimeUpdateData>::decode(Decoder& decoder)
{
    auto currentTime = decoder.decode<MediaTime>();
    auto timeIsProgressing = decoder.decode<bool>();
    auto wallTime = decoder.decode<MonotonicTime>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::MediaTimeUpdateData {
            WTFMove(*currentTime),
            WTFMove(*timeIsProgressing),
            WTFMove(*wallTime)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS) && USE(AUDIO_SESSION)
void ArgumentCoder<WebKit::RemoteAudioSessionConfiguration>::encode(Encoder& encoder, const WebKit::RemoteAudioSessionConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.routingContextUID)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sampleRate)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bufferSize)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.numberOfOutputChannels)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maximumNumberOfOutputChannels)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.preferredBufferSize)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.outputLatency)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isMuted)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isActive)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sceneIdentifier)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.soundStageSize)>, WebCore::AudioSessionSoundStageSize>);
    struct ShouldBeSameSizeAsRemoteAudioSessionConfiguration : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::RemoteAudioSessionConfiguration>, false> {
        String routingContextUID;
        float sampleRate;
        uint64_t bufferSize;
        uint64_t numberOfOutputChannels;
        uint64_t maximumNumberOfOutputChannels;
        uint64_t preferredBufferSize;
        uint64_t outputLatency;
        bool isMuted;
        bool isActive;
        String sceneIdentifier;
        WebCore::AudioSessionSoundStageSize soundStageSize;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRemoteAudioSessionConfiguration) == sizeof(WebKit::RemoteAudioSessionConfiguration));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::RemoteAudioSessionConfiguration, routingContextUID)
        , offsetof(WebKit::RemoteAudioSessionConfiguration, sampleRate)
        , offsetof(WebKit::RemoteAudioSessionConfiguration, bufferSize)
        , offsetof(WebKit::RemoteAudioSessionConfiguration, numberOfOutputChannels)
        , offsetof(WebKit::RemoteAudioSessionConfiguration, maximumNumberOfOutputChannels)
        , offsetof(WebKit::RemoteAudioSessionConfiguration, preferredBufferSize)
        , offsetof(WebKit::RemoteAudioSessionConfiguration, outputLatency)
        , offsetof(WebKit::RemoteAudioSessionConfiguration, isMuted)
        , offsetof(WebKit::RemoteAudioSessionConfiguration, isActive)
        , offsetof(WebKit::RemoteAudioSessionConfiguration, sceneIdentifier)
        , offsetof(WebKit::RemoteAudioSessionConfiguration, soundStageSize)
    >::value);

    encoder << instance.routingContextUID;
    encoder << instance.sampleRate;
    encoder << instance.bufferSize;
    encoder << instance.numberOfOutputChannels;
    encoder << instance.maximumNumberOfOutputChannels;
    encoder << instance.preferredBufferSize;
    encoder << instance.outputLatency;
    encoder << instance.isMuted;
    encoder << instance.isActive;
    encoder << instance.sceneIdentifier;
    encoder << instance.soundStageSize;
}

std::optional<WebKit::RemoteAudioSessionConfiguration> ArgumentCoder<WebKit::RemoteAudioSessionConfiguration>::decode(Decoder& decoder)
{
    auto routingContextUID = decoder.decode<String>();
    auto sampleRate = decoder.decode<float>();
    auto bufferSize = decoder.decode<uint64_t>();
    auto numberOfOutputChannels = decoder.decode<uint64_t>();
    auto maximumNumberOfOutputChannels = decoder.decode<uint64_t>();
    auto preferredBufferSize = decoder.decode<uint64_t>();
    auto outputLatency = decoder.decode<uint64_t>();
    auto isMuted = decoder.decode<bool>();
    auto isActive = decoder.decode<bool>();
    auto sceneIdentifier = decoder.decode<String>();
    auto soundStageSize = decoder.decode<WebCore::AudioSessionSoundStageSize>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::RemoteAudioSessionConfiguration {
            WTFMove(*routingContextUID),
            WTFMove(*sampleRate),
            WTFMove(*bufferSize),
            WTFMove(*numberOfOutputChannels),
            WTFMove(*maximumNumberOfOutputChannels),
            WTFMove(*preferredBufferSize),
            WTFMove(*outputLatency),
            WTFMove(*isMuted),
            WTFMove(*isActive),
            WTFMove(*sceneIdentifier),
            WTFMove(*soundStageSize)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS) && ENABLE(ENCRYPTED_MEDIA)
void ArgumentCoder<WebKit::RemoteCDMConfiguration>::encode(Encoder& encoder, const WebKit::RemoteCDMConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportedInitDataTypes)>, Vector<AtomString>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportedRobustnesses)>, Vector<AtomString>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsServerCertificates)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsSessions)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.logIdentifier)>, uint64_t>);
    struct ShouldBeSameSizeAsRemoteCDMConfiguration : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::RemoteCDMConfiguration>, false> {
        Vector<AtomString> supportedInitDataTypes;
        Vector<AtomString> supportedRobustnesses;
        bool supportsServerCertificates;
        bool supportsSessions;
        uint64_t logIdentifier;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRemoteCDMConfiguration) == sizeof(WebKit::RemoteCDMConfiguration));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::RemoteCDMConfiguration, supportedInitDataTypes)
        , offsetof(WebKit::RemoteCDMConfiguration, supportedRobustnesses)
        , offsetof(WebKit::RemoteCDMConfiguration, supportsServerCertificates)
        , offsetof(WebKit::RemoteCDMConfiguration, supportsSessions)
        , offsetof(WebKit::RemoteCDMConfiguration, logIdentifier)
    >::value);

    encoder << instance.supportedInitDataTypes;
    encoder << instance.supportedRobustnesses;
    encoder << instance.supportsServerCertificates;
    encoder << instance.supportsSessions;
    encoder << instance.logIdentifier;
}

std::optional<WebKit::RemoteCDMConfiguration> ArgumentCoder<WebKit::RemoteCDMConfiguration>::decode(Decoder& decoder)
{
    auto supportedInitDataTypes = decoder.decode<Vector<AtomString>>();
    auto supportedRobustnesses = decoder.decode<Vector<AtomString>>();
    auto supportsServerCertificates = decoder.decode<bool>();
    auto supportsSessions = decoder.decode<bool>();
    auto logIdentifier = decoder.decode<uint64_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::RemoteCDMConfiguration {
            WTFMove(*supportedInitDataTypes),
            WTFMove(*supportedRobustnesses),
            WTFMove(*supportsServerCertificates),
            WTFMove(*supportsSessions),
            WTFMove(*logIdentifier)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS) && ENABLE(ENCRYPTED_MEDIA)
void ArgumentCoder<WebKit::RemoteCDMInstanceConfiguration>::encode(Encoder& encoder, const WebKit::RemoteCDMInstanceConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.keySystem)>, String>);
    struct ShouldBeSameSizeAsRemoteCDMInstanceConfiguration : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::RemoteCDMInstanceConfiguration>, false> {
        String keySystem;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRemoteCDMInstanceConfiguration) == sizeof(WebKit::RemoteCDMInstanceConfiguration));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::RemoteCDMInstanceConfiguration, keySystem)
    >::value);

    encoder << instance.keySystem;
}

std::optional<WebKit::RemoteCDMInstanceConfiguration> ArgumentCoder<WebKit::RemoteCDMInstanceConfiguration>::decode(Decoder& decoder)
{
    auto keySystem = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::RemoteCDMInstanceConfiguration {
            WTFMove(*keySystem)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS)
void ArgumentCoder<WebKit::RemoteMediaPlayerConfiguration>::encode(Encoder& encoder, const WebKit::RemoteMediaPlayerConfiguration& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.engineDescription)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsScanning)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsFullscreen)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsPictureInPicture)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsAcceleratedRendering)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsPlayAtHostTime)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.supportsPauseAtHostTime)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.canPlayToWirelessPlaybackTarget)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shouldIgnoreIntrinsicSize)>, bool>);
    struct ShouldBeSameSizeAsRemoteMediaPlayerConfiguration : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::RemoteMediaPlayerConfiguration>, false> {
        String engineDescription;
        bool supportsScanning;
        bool supportsFullscreen;
        bool supportsPictureInPicture;
        bool supportsAcceleratedRendering;
        bool supportsPlayAtHostTime;
        bool supportsPauseAtHostTime;
        bool canPlayToWirelessPlaybackTarget;
        bool shouldIgnoreIntrinsicSize;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRemoteMediaPlayerConfiguration) == sizeof(WebKit::RemoteMediaPlayerConfiguration));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::RemoteMediaPlayerConfiguration, engineDescription)
        , offsetof(WebKit::RemoteMediaPlayerConfiguration, supportsScanning)
        , offsetof(WebKit::RemoteMediaPlayerConfiguration, supportsFullscreen)
        , offsetof(WebKit::RemoteMediaPlayerConfiguration, supportsPictureInPicture)
        , offsetof(WebKit::RemoteMediaPlayerConfiguration, supportsAcceleratedRendering)
        , offsetof(WebKit::RemoteMediaPlayerConfiguration, supportsPlayAtHostTime)
        , offsetof(WebKit::RemoteMediaPlayerConfiguration, supportsPauseAtHostTime)
        , offsetof(WebKit::RemoteMediaPlayerConfiguration, canPlayToWirelessPlaybackTarget)
        , offsetof(WebKit::RemoteMediaPlayerConfiguration, shouldIgnoreIntrinsicSize)
    >::value);

    encoder << instance.engineDescription;
    encoder << instance.supportsScanning;
    encoder << instance.supportsFullscreen;
    encoder << instance.supportsPictureInPicture;
    encoder << instance.supportsAcceleratedRendering;
    encoder << instance.supportsPlayAtHostTime;
    encoder << instance.supportsPauseAtHostTime;
    encoder << instance.canPlayToWirelessPlaybackTarget;
    encoder << instance.shouldIgnoreIntrinsicSize;
}

std::optional<WebKit::RemoteMediaPlayerConfiguration> ArgumentCoder<WebKit::RemoteMediaPlayerConfiguration>::decode(Decoder& decoder)
{
    auto engineDescription = decoder.decode<String>();
    auto supportsScanning = decoder.decode<bool>();
    auto supportsFullscreen = decoder.decode<bool>();
    auto supportsPictureInPicture = decoder.decode<bool>();
    auto supportsAcceleratedRendering = decoder.decode<bool>();
    auto supportsPlayAtHostTime = decoder.decode<bool>();
    auto supportsPauseAtHostTime = decoder.decode<bool>();
    auto canPlayToWirelessPlaybackTarget = decoder.decode<bool>();
    auto shouldIgnoreIntrinsicSize = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::RemoteMediaPlayerConfiguration {
            WTFMove(*engineDescription),
            WTFMove(*supportsScanning),
            WTFMove(*supportsFullscreen),
            WTFMove(*supportsPictureInPicture),
            WTFMove(*supportsAcceleratedRendering),
            WTFMove(*supportsPlayAtHostTime),
            WTFMove(*supportsPauseAtHostTime),
            WTFMove(*canPlayToWirelessPlaybackTarget),
            WTFMove(*shouldIgnoreIntrinsicSize)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS) && ENABLE(VIDEO)
void ArgumentCoder<WebKit::RemoteMediaPlayerState>::encode(Encoder& encoder, const WebKit::RemoteMediaPlayerState& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.duration)>, MediaTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.minTimeSeekable)>, MediaTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxTimeSeekable)>, MediaTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.startDate)>, MediaTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.startTime)>, MediaTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.languageOfPrimaryAudioTrack)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.wirelessPlaybackTargetName)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.bufferedRanges)>, std::optional<WebCore::PlatformTimeRanges>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.networkState)>, WebCore::MediaPlayerNetworkState>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.movieLoadType)>, WebCore::MediaPlayerMovieLoadType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.wirelessPlaybackTargetType)>, WebCore::MediaPlayerWirelessPlaybackTargetType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.naturalSize)>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maxFastForwardRate)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.minFastReverseRate)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.seekableTimeRangesLastModifiedTime)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.liveUpdateInterval)>, double>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.totalBytes)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.videoMetrics)>, std::optional<WebCore::VideoPlaybackQualityMetrics>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.documentIsCrossOrigin)>, std::optional<bool>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.paused)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.canSaveMediaData)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasAudio)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasVideo)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasClosedCaptions)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasAvailableVideoFrame)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.wirelessVideoPlaybackDisabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.didPassCORSAccessCheck)>, bool>);
    struct ShouldBeSameSizeAsRemoteMediaPlayerState : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::RemoteMediaPlayerState>, false> {
        MediaTime duration;
        MediaTime minTimeSeekable;
        MediaTime maxTimeSeekable;
        MediaTime startDate;
        MediaTime startTime;
        String languageOfPrimaryAudioTrack;
        String wirelessPlaybackTargetName;
        std::optional<WebCore::PlatformTimeRanges> bufferedRanges;
        WebCore::MediaPlayerNetworkState networkState;
        WebCore::MediaPlayerMovieLoadType movieLoadType;
        WebCore::MediaPlayerWirelessPlaybackTargetType wirelessPlaybackTargetType;
        WebCore::FloatSize naturalSize;
        double maxFastForwardRate;
        double minFastReverseRate;
        double seekableTimeRangesLastModifiedTime;
        double liveUpdateInterval;
        uint64_t totalBytes;
        std::optional<WebCore::VideoPlaybackQualityMetrics> videoMetrics;
        std::optional<bool> documentIsCrossOrigin;
        bool paused;
        bool canSaveMediaData;
        bool hasAudio;
        bool hasVideo;
        bool hasClosedCaptions;
        bool hasAvailableVideoFrame;
        bool wirelessVideoPlaybackDisabled;
        bool didPassCORSAccessCheck;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRemoteMediaPlayerState) == sizeof(WebKit::RemoteMediaPlayerState));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::RemoteMediaPlayerState, duration)
        , offsetof(WebKit::RemoteMediaPlayerState, minTimeSeekable)
        , offsetof(WebKit::RemoteMediaPlayerState, maxTimeSeekable)
        , offsetof(WebKit::RemoteMediaPlayerState, startDate)
        , offsetof(WebKit::RemoteMediaPlayerState, startTime)
        , offsetof(WebKit::RemoteMediaPlayerState, languageOfPrimaryAudioTrack)
        , offsetof(WebKit::RemoteMediaPlayerState, wirelessPlaybackTargetName)
        , offsetof(WebKit::RemoteMediaPlayerState, bufferedRanges)
        , offsetof(WebKit::RemoteMediaPlayerState, networkState)
        , offsetof(WebKit::RemoteMediaPlayerState, movieLoadType)
        , offsetof(WebKit::RemoteMediaPlayerState, wirelessPlaybackTargetType)
        , offsetof(WebKit::RemoteMediaPlayerState, naturalSize)
        , offsetof(WebKit::RemoteMediaPlayerState, maxFastForwardRate)
        , offsetof(WebKit::RemoteMediaPlayerState, minFastReverseRate)
        , offsetof(WebKit::RemoteMediaPlayerState, seekableTimeRangesLastModifiedTime)
        , offsetof(WebKit::RemoteMediaPlayerState, liveUpdateInterval)
        , offsetof(WebKit::RemoteMediaPlayerState, totalBytes)
        , offsetof(WebKit::RemoteMediaPlayerState, videoMetrics)
        , offsetof(WebKit::RemoteMediaPlayerState, documentIsCrossOrigin)
        , offsetof(WebKit::RemoteMediaPlayerState, paused)
        , offsetof(WebKit::RemoteMediaPlayerState, canSaveMediaData)
        , offsetof(WebKit::RemoteMediaPlayerState, hasAudio)
        , offsetof(WebKit::RemoteMediaPlayerState, hasVideo)
        , offsetof(WebKit::RemoteMediaPlayerState, hasClosedCaptions)
        , offsetof(WebKit::RemoteMediaPlayerState, hasAvailableVideoFrame)
        , offsetof(WebKit::RemoteMediaPlayerState, wirelessVideoPlaybackDisabled)
        , offsetof(WebKit::RemoteMediaPlayerState, didPassCORSAccessCheck)
    >::value);

    encoder << instance.duration;
    encoder << instance.minTimeSeekable;
    encoder << instance.maxTimeSeekable;
    encoder << instance.startDate;
    encoder << instance.startTime;
    encoder << instance.languageOfPrimaryAudioTrack;
    encoder << instance.wirelessPlaybackTargetName;
    encoder << instance.bufferedRanges;
    encoder << instance.networkState;
    encoder << instance.movieLoadType;
    encoder << instance.wirelessPlaybackTargetType;
    encoder << instance.naturalSize;
    encoder << instance.maxFastForwardRate;
    encoder << instance.minFastReverseRate;
    encoder << instance.seekableTimeRangesLastModifiedTime;
    encoder << instance.liveUpdateInterval;
    encoder << instance.totalBytes;
    encoder << instance.videoMetrics;
    encoder << instance.documentIsCrossOrigin;
    encoder << instance.paused;
    encoder << instance.canSaveMediaData;
    encoder << instance.hasAudio;
    encoder << instance.hasVideo;
    encoder << instance.hasClosedCaptions;
    encoder << instance.hasAvailableVideoFrame;
    encoder << instance.wirelessVideoPlaybackDisabled;
    encoder << instance.didPassCORSAccessCheck;
}

std::optional<WebKit::RemoteMediaPlayerState> ArgumentCoder<WebKit::RemoteMediaPlayerState>::decode(Decoder& decoder)
{
    auto duration = decoder.decode<MediaTime>();
    auto minTimeSeekable = decoder.decode<MediaTime>();
    auto maxTimeSeekable = decoder.decode<MediaTime>();
    auto startDate = decoder.decode<MediaTime>();
    auto startTime = decoder.decode<MediaTime>();
    auto languageOfPrimaryAudioTrack = decoder.decode<String>();
    auto wirelessPlaybackTargetName = decoder.decode<String>();
    auto bufferedRanges = decoder.decode<std::optional<WebCore::PlatformTimeRanges>>();
    auto networkState = decoder.decode<WebCore::MediaPlayerNetworkState>();
    auto movieLoadType = decoder.decode<WebCore::MediaPlayerMovieLoadType>();
    auto wirelessPlaybackTargetType = decoder.decode<WebCore::MediaPlayerWirelessPlaybackTargetType>();
    auto naturalSize = decoder.decode<WebCore::FloatSize>();
    auto maxFastForwardRate = decoder.decode<double>();
    auto minFastReverseRate = decoder.decode<double>();
    auto seekableTimeRangesLastModifiedTime = decoder.decode<double>();
    auto liveUpdateInterval = decoder.decode<double>();
    auto totalBytes = decoder.decode<uint64_t>();
    auto videoMetrics = decoder.decode<std::optional<WebCore::VideoPlaybackQualityMetrics>>();
    auto documentIsCrossOrigin = decoder.decode<std::optional<bool>>();
    auto paused = decoder.decode<bool>();
    auto canSaveMediaData = decoder.decode<bool>();
    auto hasAudio = decoder.decode<bool>();
    auto hasVideo = decoder.decode<bool>();
    auto hasClosedCaptions = decoder.decode<bool>();
    auto hasAvailableVideoFrame = decoder.decode<bool>();
    auto wirelessVideoPlaybackDisabled = decoder.decode<bool>();
    auto didPassCORSAccessCheck = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::RemoteMediaPlayerState {
            WTFMove(*duration),
            WTFMove(*minTimeSeekable),
            WTFMove(*maxTimeSeekable),
            WTFMove(*startDate),
            WTFMove(*startTime),
            WTFMove(*languageOfPrimaryAudioTrack),
            WTFMove(*wirelessPlaybackTargetName),
            WTFMove(*bufferedRanges),
            WTFMove(*networkState),
            WTFMove(*movieLoadType),
            WTFMove(*wirelessPlaybackTargetType),
            WTFMove(*naturalSize),
            WTFMove(*maxFastForwardRate),
            WTFMove(*minFastReverseRate),
            WTFMove(*seekableTimeRangesLastModifiedTime),
            WTFMove(*liveUpdateInterval),
            WTFMove(*totalBytes),
            WTFMove(*videoMetrics),
            WTFMove(*documentIsCrossOrigin),
            WTFMove(*paused),
            WTFMove(*canSaveMediaData),
            WTFMove(*hasAudio),
            WTFMove(*hasVideo),
            WTFMove(*hasClosedCaptions),
            WTFMove(*hasAvailableVideoFrame),
            WTFMove(*wirelessVideoPlaybackDisabled),
            WTFMove(*didPassCORSAccessCheck)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS) && ENABLE(VIDEO)
void ArgumentCoder<WebKit::RemoteVideoFrameProxyProperties>::encode(Encoder& encoder, const WebKit::RemoteVideoFrameProxyProperties& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.reference)>, WebKit::RemoteVideoFrameReference>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.presentationTime)>, MediaTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isMirrored)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rotation)>, WebCore::VideoFrameRotation>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size)>, WebCore::IntSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pixelFormat)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorSpace)>, WebCore::PlatformVideoColorSpace>);
    struct ShouldBeSameSizeAsRemoteVideoFrameProxyProperties : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::RemoteVideoFrameProxyProperties>, false> {
        WebKit::RemoteVideoFrameReference reference;
        MediaTime presentationTime;
        bool isMirrored;
        WebCore::VideoFrameRotation rotation;
        WebCore::IntSize size;
        uint32_t pixelFormat;
        WebCore::PlatformVideoColorSpace colorSpace;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRemoteVideoFrameProxyProperties) == sizeof(WebKit::RemoteVideoFrameProxyProperties));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::RemoteVideoFrameProxyProperties, reference)
        , offsetof(WebKit::RemoteVideoFrameProxyProperties, presentationTime)
        , offsetof(WebKit::RemoteVideoFrameProxyProperties, isMirrored)
        , offsetof(WebKit::RemoteVideoFrameProxyProperties, rotation)
        , offsetof(WebKit::RemoteVideoFrameProxyProperties, size)
        , offsetof(WebKit::RemoteVideoFrameProxyProperties, pixelFormat)
        , offsetof(WebKit::RemoteVideoFrameProxyProperties, colorSpace)
    >::value);

    encoder << instance.reference;
    encoder << instance.presentationTime;
    encoder << instance.isMirrored;
    encoder << instance.rotation;
    encoder << instance.size;
    encoder << instance.pixelFormat;
    encoder << instance.colorSpace;
}

void ArgumentCoder<WebKit::RemoteVideoFrameProxyProperties>::encode(StreamConnectionEncoder& encoder, const WebKit::RemoteVideoFrameProxyProperties& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.reference)>, WebKit::RemoteVideoFrameReference>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.presentationTime)>, MediaTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isMirrored)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rotation)>, WebCore::VideoFrameRotation>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size)>, WebCore::IntSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pixelFormat)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.colorSpace)>, WebCore::PlatformVideoColorSpace>);
    struct ShouldBeSameSizeAsRemoteVideoFrameProxyProperties : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::RemoteVideoFrameProxyProperties>, false> {
        WebKit::RemoteVideoFrameReference reference;
        MediaTime presentationTime;
        bool isMirrored;
        WebCore::VideoFrameRotation rotation;
        WebCore::IntSize size;
        uint32_t pixelFormat;
        WebCore::PlatformVideoColorSpace colorSpace;
    };
    static_assert(sizeof(ShouldBeSameSizeAsRemoteVideoFrameProxyProperties) == sizeof(WebKit::RemoteVideoFrameProxyProperties));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::RemoteVideoFrameProxyProperties, reference)
        , offsetof(WebKit::RemoteVideoFrameProxyProperties, presentationTime)
        , offsetof(WebKit::RemoteVideoFrameProxyProperties, isMirrored)
        , offsetof(WebKit::RemoteVideoFrameProxyProperties, rotation)
        , offsetof(WebKit::RemoteVideoFrameProxyProperties, size)
        , offsetof(WebKit::RemoteVideoFrameProxyProperties, pixelFormat)
        , offsetof(WebKit::RemoteVideoFrameProxyProperties, colorSpace)
    >::value);

    encoder << instance.reference;
    encoder << instance.presentationTime;
    encoder << instance.isMirrored;
    encoder << instance.rotation;
    encoder << instance.size;
    encoder << instance.pixelFormat;
    encoder << instance.colorSpace;
}

std::optional<WebKit::RemoteVideoFrameProxyProperties> ArgumentCoder<WebKit::RemoteVideoFrameProxyProperties>::decode(Decoder& decoder)
{
    auto reference = decoder.decode<WebKit::RemoteVideoFrameReference>();
    auto presentationTime = decoder.decode<MediaTime>();
    auto isMirrored = decoder.decode<bool>();
    auto rotation = decoder.decode<WebCore::VideoFrameRotation>();
    auto size = decoder.decode<WebCore::IntSize>();
    auto pixelFormat = decoder.decode<uint32_t>();
    auto colorSpace = decoder.decode<WebCore::PlatformVideoColorSpace>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::RemoteVideoFrameProxyProperties {
            WTFMove(*reference),
            WTFMove(*presentationTime),
            WTFMove(*isMirrored),
            WTFMove(*rotation),
            WTFMove(*size),
            WTFMove(*pixelFormat),
            WTFMove(*colorSpace)
        }
    };
}

#endif

#if ENABLE(GPU_PROCESS) && PLATFORM(COCOA) && ENABLE(VIDEO)
void ArgumentCoder<WebKit::SharedVideoFrame>::encode(Encoder& encoder, WebKit::SharedVideoFrame&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.time)>, MediaTime>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mirrored)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rotation)>, WebCore::VideoFrameRotation>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.buffer)>, WebKit::SharedVideoFrame::Buffer>);
    struct ShouldBeSameSizeAsSharedVideoFrame : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::SharedVideoFrame>, false> {
        MediaTime time;
        bool mirrored;
        WebCore::VideoFrameRotation rotation;
        WebKit::SharedVideoFrame::Buffer buffer;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSharedVideoFrame) == sizeof(WebKit::SharedVideoFrame));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::SharedVideoFrame, time)
        , offsetof(WebKit::SharedVideoFrame, mirrored)
        , offsetof(WebKit::SharedVideoFrame, rotation)
        , offsetof(WebKit::SharedVideoFrame, buffer)
    >::value);

    encoder << WTFMove(instance.time);
    encoder << WTFMove(instance.mirrored);
    encoder << WTFMove(instance.rotation);
    encoder << WTFMove(instance.buffer);
}

std::optional<WebKit::SharedVideoFrame> ArgumentCoder<WebKit::SharedVideoFrame>::decode(Decoder& decoder)
{
    auto time = decoder.decode<MediaTime>();
    auto mirrored = decoder.decode<bool>();
    auto rotation = decoder.decode<WebCore::VideoFrameRotation>();
    auto buffer = decoder.decode<WebKit::SharedVideoFrame::Buffer>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::SharedVideoFrame {
            WTFMove(*time),
            WTFMove(*mirrored),
            WTFMove(*rotation),
            WTFMove(*buffer)
        }
    };
}

#endif

#if ENABLE(MEDIA_STREAM)
void ArgumentCoder<WebKit::MediaDeviceSandboxExtensions>::encode(Encoder& encoder, WebKit::MediaDeviceSandboxExtensions&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.takeIDs())>, Vector<String>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.takeHandles())>, Vector<WebKit::SandboxExtensionHandle>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.takeMachBootstrapHandle())>, WebKit::SandboxExtensionHandle>);

    encoder << instance.takeIDs();
    encoder << instance.takeHandles();
    encoder << instance.takeMachBootstrapHandle();
}

std::optional<WebKit::MediaDeviceSandboxExtensions> ArgumentCoder<WebKit::MediaDeviceSandboxExtensions>::decode(Decoder& decoder)
{
    auto takeIDs = decoder.decode<Vector<String>>();
    auto takeHandles = decoder.decode<Vector<WebKit::SandboxExtensionHandle>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(takeIDs->size() == takeHandles->size()))
        return std::nullopt;
    auto takeMachBootstrapHandle = decoder.decode<WebKit::SandboxExtensionHandle>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::MediaDeviceSandboxExtensions {
            WTFMove(*takeIDs),
            WTFMove(*takeHandles),
            WTFMove(*takeMachBootstrapHandle)
        }
    };
}

#endif

#if ENABLE(MODEL_PROCESS)
void ArgumentCoder<WebKit::ModelProcessConnectionInfo>::encode(Encoder& encoder, const WebKit::ModelProcessConnectionInfo& instance)
{
#if HAVE(AUDIT_TOKEN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.auditToken)>, std::optional<WebKit::CoreIPCAuditToken>>);
#endif
    struct ShouldBeSameSizeAsModelProcessConnectionInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::ModelProcessConnectionInfo>, false> {
#if HAVE(AUDIT_TOKEN)
        std::optional<WebKit::CoreIPCAuditToken> auditToken;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsModelProcessConnectionInfo) == sizeof(WebKit::ModelProcessConnectionInfo));
    static_assert(MembersInCorrectOrder < 0
#if HAVE(AUDIT_TOKEN)
        , offsetof(WebKit::ModelProcessConnectionInfo, auditToken)
#endif
    >::value);

#if HAVE(AUDIT_TOKEN)
    encoder << instance.auditToken;
#endif
}

std::optional<WebKit::ModelProcessConnectionInfo> ArgumentCoder<WebKit::ModelProcessConnectionInfo>::decode(Decoder& decoder)
{
#if HAVE(AUDIT_TOKEN)
    auto auditToken = decoder.decode<std::optional<WebKit::CoreIPCAuditToken>>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::ModelProcessConnectionInfo {
#if HAVE(AUDIT_TOKEN)
            WTFMove(*auditToken)
#endif
        }
    };
}

#endif

void ArgumentCoder<WebKit::NetworkProcessConnectionInfo>::encode(Encoder& encoder, WebKit::NetworkProcessConnectionInfo&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.connection)>, IPC::ConnectionHandle>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cookieAcceptPolicy)>, WebCore::HTTPCookieAcceptPolicy>);
#if HAVE(AUDIT_TOKEN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.auditToken)>, std::optional<WebKit::CoreIPCAuditToken>>);
#endif
    struct ShouldBeSameSizeAsNetworkProcessConnectionInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::NetworkProcessConnectionInfo>, false> {
        IPC::ConnectionHandle connection;
        WebCore::HTTPCookieAcceptPolicy cookieAcceptPolicy;
#if HAVE(AUDIT_TOKEN)
        std::optional<WebKit::CoreIPCAuditToken> auditToken;
#endif
    };
    static_assert(sizeof(ShouldBeSameSizeAsNetworkProcessConnectionInfo) == sizeof(WebKit::NetworkProcessConnectionInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::NetworkProcessConnectionInfo, connection)
        , offsetof(WebKit::NetworkProcessConnectionInfo, cookieAcceptPolicy)
#if HAVE(AUDIT_TOKEN)
        , offsetof(WebKit::NetworkProcessConnectionInfo, auditToken)
#endif
    >::value);

    encoder << WTFMove(instance.connection);
    encoder << WTFMove(instance.cookieAcceptPolicy);
#if HAVE(AUDIT_TOKEN)
    encoder << WTFMove(instance.auditToken);
#endif
}

std::optional<WebKit::NetworkProcessConnectionInfo> ArgumentCoder<WebKit::NetworkProcessConnectionInfo>::decode(Decoder& decoder)
{
    auto connection = decoder.decode<IPC::ConnectionHandle>();
    auto cookieAcceptPolicy = decoder.decode<WebCore::HTTPCookieAcceptPolicy>();
#if HAVE(AUDIT_TOKEN)
    auto auditToken = decoder.decode<std::optional<WebKit::CoreIPCAuditToken>>();
#endif
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::NetworkProcessConnectionInfo {
            WTFMove(*connection),
            WTFMove(*cookieAcceptPolicy),
#if HAVE(AUDIT_TOKEN)
            WTFMove(*auditToken)
#endif
        }
    };
}

#if ENABLE(SPEECH_SYNTHESIS)
void ArgumentCoder<WebKit::WebSpeechSynthesisVoice>::encode(Encoder& encoder, const WebKit::WebSpeechSynthesisVoice& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.voiceURI)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.name)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lang)>, String>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.localService)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.defaultLang)>, bool>);
    struct ShouldBeSameSizeAsWebSpeechSynthesisVoice : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WebSpeechSynthesisVoice>, false> {
        String voiceURI;
        String name;
        String lang;
        bool localService;
        bool defaultLang;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWebSpeechSynthesisVoice) == sizeof(WebKit::WebSpeechSynthesisVoice));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WebSpeechSynthesisVoice, voiceURI)
        , offsetof(WebKit::WebSpeechSynthesisVoice, name)
        , offsetof(WebKit::WebSpeechSynthesisVoice, lang)
        , offsetof(WebKit::WebSpeechSynthesisVoice, localService)
        , offsetof(WebKit::WebSpeechSynthesisVoice, defaultLang)
    >::value);

    encoder << instance.voiceURI;
    encoder << instance.name;
    encoder << instance.lang;
    encoder << instance.localService;
    encoder << instance.defaultLang;
}

std::optional<WebKit::WebSpeechSynthesisVoice> ArgumentCoder<WebKit::WebSpeechSynthesisVoice>::decode(Decoder& decoder)
{
    auto voiceURI = decoder.decode<String>();
    auto name = decoder.decode<String>();
    auto lang = decoder.decode<String>();
    auto localService = decoder.decode<bool>();
    auto defaultLang = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WebSpeechSynthesisVoice {
            WTFMove(*voiceURI),
            WTFMove(*name),
            WTFMove(*lang),
            WTFMove(*localService),
            WTFMove(*defaultLang)
        }
    };
}

#endif

#if USE(CURL)
void ArgumentCoder<WebCore::CurlProxySettings>::encode(Encoder& encoder, const WebCore::CurlProxySettings& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.toIPCData())>, Variant<WebCore::CurlProxySettings::DefaultData, WebCore::CurlProxySettings::NoProxyData, WebCore::CurlProxySettings::CustomData>>);

    encoder << instance.toIPCData();
}

std::optional<WebCore::CurlProxySettings> ArgumentCoder<WebCore::CurlProxySettings>::decode(Decoder& decoder)
{
    auto toIPCData = decoder.decode<Variant<WebCore::CurlProxySettings::DefaultData, WebCore::CurlProxySettings::NoProxyData, WebCore::CurlProxySettings::CustomData>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CurlProxySettings::fromIPCData(
            WTFMove(*toIPCData)
        )
    };
}

#endif

#if USE(CURL)
void ArgumentCoder<WebCore::CurlProxySettings::DefaultData>::encode(Encoder& encoder, const WebCore::CurlProxySettings::DefaultData& instance)
{
    struct ShouldBeSameSizeAsDefaultData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::CurlProxySettings::DefaultData>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsDefaultData) == sizeof(WebCore::CurlProxySettings::DefaultData));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::CurlProxySettings::DefaultData> ArgumentCoder<WebCore::CurlProxySettings::DefaultData>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CurlProxySettings::DefaultData {
        }
    };
}

#endif

#if USE(CURL)
void ArgumentCoder<WebCore::CurlProxySettings::NoProxyData>::encode(Encoder& encoder, const WebCore::CurlProxySettings::NoProxyData& instance)
{
    struct ShouldBeSameSizeAsNoProxyData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::CurlProxySettings::NoProxyData>, false> {
    };
    static_assert(sizeof(ShouldBeSameSizeAsNoProxyData) == sizeof(WebCore::CurlProxySettings::NoProxyData));
    static_assert(MembersInCorrectOrder < 0
    >::value);

}

std::optional<WebCore::CurlProxySettings::NoProxyData> ArgumentCoder<WebCore::CurlProxySettings::NoProxyData>::decode(Decoder& decoder)
{
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CurlProxySettings::NoProxyData {
        }
    };
}

#endif

#if USE(CURL)
void ArgumentCoder<WebCore::CurlProxySettings::CustomData>::encode(Encoder& encoder, const WebCore::CurlProxySettings::CustomData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.url)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ignoreHosts)>, String>);
    struct ShouldBeSameSizeAsCustomData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::CurlProxySettings::CustomData>, false> {
        URL url;
        String ignoreHosts;
    };
    static_assert(sizeof(ShouldBeSameSizeAsCustomData) == sizeof(WebCore::CurlProxySettings::CustomData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::CurlProxySettings::CustomData, url)
        , offsetof(WebCore::CurlProxySettings::CustomData, ignoreHosts)
    >::value);

    encoder << instance.url;
    encoder << instance.ignoreHosts;
}

std::optional<WebCore::CurlProxySettings::CustomData> ArgumentCoder<WebCore::CurlProxySettings::CustomData>::decode(Decoder& decoder)
{
    auto url = decoder.decode<URL>();
    auto ignoreHosts = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::CurlProxySettings::CustomData {
            WTFMove(*url),
            WTFMove(*ignoreHosts)
        }
    };
}

#endif

#if USE(GRAPHICS_LAYER_WC)
void ArgumentCoder<WebKit::WCBackingStore>::encode(Encoder& encoder, const WebKit::WCBackingStore& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.handle())>, std::optional<WebKit::ImageBufferBackendHandle>>);

    encoder << instance.handle();
}

std::optional<WebKit::WCBackingStore> ArgumentCoder<WebKit::WCBackingStore>::decode(Decoder& decoder)
{
    auto handle = decoder.decode<std::optional<WebKit::ImageBufferBackendHandle>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WCBackingStore {
            WTFMove(*handle)
        }
    };
}

#endif

#if USE(GRAPHICS_LAYER_WC)
void ArgumentCoder<WebKit::WCTileUpdate>::encode(Encoder& encoder, const WebKit::WCTileUpdate& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.index)>, WebCore::TextureMapperSparseBackingStore::TileIndex>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.willRemove)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.backingStore)>, WebKit::WCBackingStore>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dirtyRect)>, WebCore::IntRect>);
    struct ShouldBeSameSizeAsWCTileUpdate : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WCTileUpdate>, false> {
        WebCore::TextureMapperSparseBackingStore::TileIndex index;
        bool willRemove;
        WebKit::WCBackingStore backingStore;
        WebCore::IntRect dirtyRect;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWCTileUpdate) == sizeof(WebKit::WCTileUpdate));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WCTileUpdate, index)
        , offsetof(WebKit::WCTileUpdate, willRemove)
        , offsetof(WebKit::WCTileUpdate, backingStore)
        , offsetof(WebKit::WCTileUpdate, dirtyRect)
    >::value);

    encoder << instance.index;
    encoder << instance.willRemove;
    encoder << instance.backingStore;
    encoder << instance.dirtyRect;
}

std::optional<WebKit::WCTileUpdate> ArgumentCoder<WebKit::WCTileUpdate>::decode(Decoder& decoder)
{
    auto index = decoder.decode<WebCore::TextureMapperSparseBackingStore::TileIndex>();
    auto willRemove = decoder.decode<bool>();
    auto backingStore = decoder.decode<WebKit::WCBackingStore>();
    auto dirtyRect = decoder.decode<WebCore::IntRect>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WCTileUpdate {
            WTFMove(*index),
            WTFMove(*willRemove),
            WTFMove(*backingStore),
            WTFMove(*dirtyRect)
        }
    };
}

#endif

#if USE(GRAPHICS_LAYER_WC)
void ArgumentCoder<WebKit::WCLayerUpdateInfo::BackgroundChanges>::encode(Encoder& encoder, const WebKit::WCLayerUpdateInfo::BackgroundChanges& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.color)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasBackingStore)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.backingStoreSize)>, WebCore::IntSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tileUpdates)>, Vector<WebKit::WCTileUpdate>>);
    struct ShouldBeSameSizeAsBackgroundChanges : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WCLayerUpdateInfo::BackgroundChanges>, false> {
        WebCore::Color color;
        bool hasBackingStore;
        WebCore::IntSize backingStoreSize;
        Vector<WebKit::WCTileUpdate> tileUpdates;
    };
    static_assert(sizeof(ShouldBeSameSizeAsBackgroundChanges) == sizeof(WebKit::WCLayerUpdateInfo::BackgroundChanges));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WCLayerUpdateInfo::BackgroundChanges, color)
        , offsetof(WebKit::WCLayerUpdateInfo::BackgroundChanges, hasBackingStore)
        , offsetof(WebKit::WCLayerUpdateInfo::BackgroundChanges, backingStoreSize)
        , offsetof(WebKit::WCLayerUpdateInfo::BackgroundChanges, tileUpdates)
    >::value);

    encoder << instance.color;
    encoder << instance.hasBackingStore;
    encoder << instance.backingStoreSize;
    encoder << instance.tileUpdates;
}

std::optional<WebKit::WCLayerUpdateInfo::BackgroundChanges> ArgumentCoder<WebKit::WCLayerUpdateInfo::BackgroundChanges>::decode(Decoder& decoder)
{
    auto color = decoder.decode<WebCore::Color>();
    auto hasBackingStore = decoder.decode<bool>();
    auto backingStoreSize = decoder.decode<WebCore::IntSize>();
    auto tileUpdates = decoder.decode<Vector<WebKit::WCTileUpdate>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WCLayerUpdateInfo::BackgroundChanges {
            WTFMove(*color),
            WTFMove(*hasBackingStore),
            WTFMove(*backingStoreSize),
            WTFMove(*tileUpdates)
        }
    };
}

#endif

#if USE(GRAPHICS_LAYER_WC)
void ArgumentCoder<WebKit::WCLayerUpdateInfo::PlatformLayerChanges>::encode(Encoder& encoder, const WebKit::WCLayerUpdateInfo::PlatformLayerChanges& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasLayer)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.identifiers)>, Vector<WebKit::WCContentBufferIdentifier>>);
    struct ShouldBeSameSizeAsPlatformLayerChanges : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WCLayerUpdateInfo::PlatformLayerChanges>, false> {
        bool hasLayer;
        Vector<WebKit::WCContentBufferIdentifier> identifiers;
    };
    static_assert(sizeof(ShouldBeSameSizeAsPlatformLayerChanges) == sizeof(WebKit::WCLayerUpdateInfo::PlatformLayerChanges));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WCLayerUpdateInfo::PlatformLayerChanges, hasLayer)
        , offsetof(WebKit::WCLayerUpdateInfo::PlatformLayerChanges, identifiers)
    >::value);

    encoder << instance.hasLayer;
    encoder << instance.identifiers;
}

std::optional<WebKit::WCLayerUpdateInfo::PlatformLayerChanges> ArgumentCoder<WebKit::WCLayerUpdateInfo::PlatformLayerChanges>::decode(Decoder& decoder)
{
    auto hasLayer = decoder.decode<bool>();
    auto identifiers = decoder.decode<Vector<WebKit::WCContentBufferIdentifier>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WCLayerUpdateInfo::PlatformLayerChanges {
            WTFMove(*hasLayer),
            WTFMove(*identifiers)
        }
    };
}

#endif

#if USE(GRAPHICS_LAYER_WC)
void ArgumentCoder<WebKit::WCLayerUpdateInfo>::encode(Encoder& encoder, const WebKit::WCLayerUpdateInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.id)>, WebCore::PlatformLayerIdentifier>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.changes)>, OptionSet<WebKit::WCLayerChange>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.children)>, Vector<WebCore::PlatformLayerIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.maskLayer)>, std::optional<WebCore::PlatformLayerIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.replicaLayer)>, std::optional<WebCore::PlatformLayerIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.position)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.anchorPoint)>, WebCore::FloatPoint3D>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.size)>, WebCore::FloatSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.boundsOrigin)>, WebCore::FloatPoint>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.masksToBounds)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentsRectClipsDescendants)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.showDebugBorder)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.showRepaintCounter)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentsVisible)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.backfaceVisibility)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.preserves3D)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.solidColor)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.debugBorderColor)>, WebCore::Color>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.opacity)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.debugBorderWidth)>, float>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.repaintCount)>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentsRect)>, WebCore::FloatRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.background)>, WebKit::WCLayerUpdateInfo::BackgroundChanges>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.transform)>, WebCore::TransformationMatrix>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.childrenTransform)>, WebCore::TransformationMatrix>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.filters)>, WebCore::FilterOperations>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.backdropFilters)>, WebCore::FilterOperations>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.backdropFiltersRect)>, WebCore::FloatRoundedRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contentsClippingRect)>, WebCore::FloatRoundedRect>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.platformLayer)>, WebKit::WCLayerUpdateInfo::PlatformLayerChanges>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hostIdentifier)>, Markable<WebCore::LayerHostingContextIdentifier>>);
    struct ShouldBeSameSizeAsWCLayerUpdateInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WCLayerUpdateInfo>, false> {
        WebCore::PlatformLayerIdentifier id;
        OptionSet<WebKit::WCLayerChange> changes;
        Vector<WebCore::PlatformLayerIdentifier> children;
        std::optional<WebCore::PlatformLayerIdentifier> maskLayer;
        std::optional<WebCore::PlatformLayerIdentifier> replicaLayer;
        WebCore::FloatPoint position;
        WebCore::FloatPoint3D anchorPoint;
        WebCore::FloatSize size;
        WebCore::FloatPoint boundsOrigin;
        bool masksToBounds;
        bool contentsRectClipsDescendants;
        bool showDebugBorder;
        bool showRepaintCounter;
        bool contentsVisible;
        bool backfaceVisibility;
        bool preserves3D;
        WebCore::Color solidColor;
        WebCore::Color debugBorderColor;
        float opacity;
        float debugBorderWidth;
        int repaintCount;
        WebCore::FloatRect contentsRect;
        WebKit::WCLayerUpdateInfo::BackgroundChanges background;
        WebCore::TransformationMatrix transform;
        WebCore::TransformationMatrix childrenTransform;
        WebCore::FilterOperations filters;
        WebCore::FilterOperations backdropFilters;
        WebCore::FloatRoundedRect backdropFiltersRect;
        WebCore::FloatRoundedRect contentsClippingRect;
        WebKit::WCLayerUpdateInfo::PlatformLayerChanges platformLayer;
        Markable<WebCore::LayerHostingContextIdentifier> hostIdentifier;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWCLayerUpdateInfo) == sizeof(WebKit::WCLayerUpdateInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WCLayerUpdateInfo, id)
        , offsetof(WebKit::WCLayerUpdateInfo, changes)
        , offsetof(WebKit::WCLayerUpdateInfo, children)
        , offsetof(WebKit::WCLayerUpdateInfo, maskLayer)
        , offsetof(WebKit::WCLayerUpdateInfo, replicaLayer)
        , offsetof(WebKit::WCLayerUpdateInfo, position)
        , offsetof(WebKit::WCLayerUpdateInfo, anchorPoint)
        , offsetof(WebKit::WCLayerUpdateInfo, size)
        , offsetof(WebKit::WCLayerUpdateInfo, boundsOrigin)
        , offsetof(WebKit::WCLayerUpdateInfo, masksToBounds)
        , offsetof(WebKit::WCLayerUpdateInfo, contentsRectClipsDescendants)
        , offsetof(WebKit::WCLayerUpdateInfo, showDebugBorder)
        , offsetof(WebKit::WCLayerUpdateInfo, showRepaintCounter)
        , offsetof(WebKit::WCLayerUpdateInfo, contentsVisible)
        , offsetof(WebKit::WCLayerUpdateInfo, backfaceVisibility)
        , offsetof(WebKit::WCLayerUpdateInfo, preserves3D)
        , offsetof(WebKit::WCLayerUpdateInfo, solidColor)
        , offsetof(WebKit::WCLayerUpdateInfo, debugBorderColor)
        , offsetof(WebKit::WCLayerUpdateInfo, opacity)
        , offsetof(WebKit::WCLayerUpdateInfo, debugBorderWidth)
        , offsetof(WebKit::WCLayerUpdateInfo, repaintCount)
        , offsetof(WebKit::WCLayerUpdateInfo, contentsRect)
        , offsetof(WebKit::WCLayerUpdateInfo, background)
        , offsetof(WebKit::WCLayerUpdateInfo, transform)
        , offsetof(WebKit::WCLayerUpdateInfo, childrenTransform)
        , offsetof(WebKit::WCLayerUpdateInfo, filters)
        , offsetof(WebKit::WCLayerUpdateInfo, backdropFilters)
        , offsetof(WebKit::WCLayerUpdateInfo, backdropFiltersRect)
        , offsetof(WebKit::WCLayerUpdateInfo, contentsClippingRect)
        , offsetof(WebKit::WCLayerUpdateInfo, platformLayer)
        , offsetof(WebKit::WCLayerUpdateInfo, hostIdentifier)
    >::value);
    static_assert(static_cast<uint64_t>(WebKit::WCLayerChange::Children) == 1);
    static_assert(BitsInIncreasingOrder<
        static_cast<uint64_t>(WebKit::WCLayerChange::Children)
        , static_cast<uint64_t>(WebKit::WCLayerChange::MaskLayer)
        , static_cast<uint64_t>(WebKit::WCLayerChange::ReplicaLayer)
        , static_cast<uint64_t>(WebKit::WCLayerChange::Position)
        , static_cast<uint64_t>(WebKit::WCLayerChange::AnchorPoint)
        , static_cast<uint64_t>(WebKit::WCLayerChange::Size)
        , static_cast<uint64_t>(WebKit::WCLayerChange::BoundsOrigin)
        , static_cast<uint64_t>(WebKit::WCLayerChange::MasksToBounds)
        , static_cast<uint64_t>(WebKit::WCLayerChange::ContentsRectClipsDescendants)
        , static_cast<uint64_t>(WebKit::WCLayerChange::ShowDebugBorder)
        , static_cast<uint64_t>(WebKit::WCLayerChange::ShowRepaintCounter)
        , static_cast<uint64_t>(WebKit::WCLayerChange::ContentsVisible)
        , static_cast<uint64_t>(WebKit::WCLayerChange::BackfaceVisibility)
        , static_cast<uint64_t>(WebKit::WCLayerChange::Preserves3D)
        , static_cast<uint64_t>(WebKit::WCLayerChange::SolidColor)
        , static_cast<uint64_t>(WebKit::WCLayerChange::DebugBorderColor)
        , static_cast<uint64_t>(WebKit::WCLayerChange::Opacity)
        , static_cast<uint64_t>(WebKit::WCLayerChange::DebugBorderWidth)
        , static_cast<uint64_t>(WebKit::WCLayerChange::RepaintCount)
        , static_cast<uint64_t>(WebKit::WCLayerChange::ContentsRect)
        , static_cast<uint64_t>(WebKit::WCLayerChange::Background)
        , static_cast<uint64_t>(WebKit::WCLayerChange::Transform)
        , static_cast<uint64_t>(WebKit::WCLayerChange::ChildrenTransform)
        , static_cast<uint64_t>(WebKit::WCLayerChange::Filters)
        , static_cast<uint64_t>(WebKit::WCLayerChange::BackdropFilters)
        , static_cast<uint64_t>(WebKit::WCLayerChange::BackdropFiltersRect)
        , static_cast<uint64_t>(WebKit::WCLayerChange::ContentsClippingRect)
        , static_cast<uint64_t>(WebKit::WCLayerChange::PlatformLayer)
        , static_cast<uint64_t>(WebKit::WCLayerChange::RemoteFrame)
    >::value);

    encoder << instance.id;
    encoder << instance.changes;
    if (instance.changes & WebKit::WCLayerChange::Children)
        encoder << instance.children;
    if (instance.changes & WebKit::WCLayerChange::MaskLayer)
        encoder << instance.maskLayer;
    if (instance.changes & WebKit::WCLayerChange::ReplicaLayer)
        encoder << instance.replicaLayer;
    if (instance.changes & WebKit::WCLayerChange::Position)
        encoder << instance.position;
    if (instance.changes & WebKit::WCLayerChange::AnchorPoint)
        encoder << instance.anchorPoint;
    if (instance.changes & WebKit::WCLayerChange::Size)
        encoder << instance.size;
    if (instance.changes & WebKit::WCLayerChange::BoundsOrigin)
        encoder << instance.boundsOrigin;
    if (instance.changes & WebKit::WCLayerChange::MasksToBounds)
        encoder << instance.masksToBounds;
    if (instance.changes & WebKit::WCLayerChange::ContentsRectClipsDescendants)
        encoder << instance.contentsRectClipsDescendants;
    if (instance.changes & WebKit::WCLayerChange::ShowDebugBorder)
        encoder << instance.showDebugBorder;
    if (instance.changes & WebKit::WCLayerChange::ShowRepaintCounter)
        encoder << instance.showRepaintCounter;
    if (instance.changes & WebKit::WCLayerChange::ContentsVisible)
        encoder << instance.contentsVisible;
    if (instance.changes & WebKit::WCLayerChange::BackfaceVisibility)
        encoder << instance.backfaceVisibility;
    if (instance.changes & WebKit::WCLayerChange::Preserves3D)
        encoder << instance.preserves3D;
    if (instance.changes & WebKit::WCLayerChange::SolidColor)
        encoder << instance.solidColor;
    if (instance.changes & WebKit::WCLayerChange::DebugBorderColor)
        encoder << instance.debugBorderColor;
    if (instance.changes & WebKit::WCLayerChange::Opacity)
        encoder << instance.opacity;
    if (instance.changes & WebKit::WCLayerChange::DebugBorderWidth)
        encoder << instance.debugBorderWidth;
    if (instance.changes & WebKit::WCLayerChange::RepaintCount)
        encoder << instance.repaintCount;
    if (instance.changes & WebKit::WCLayerChange::ContentsRect)
        encoder << instance.contentsRect;
    if (instance.changes & WebKit::WCLayerChange::Background)
        encoder << instance.background;
    if (instance.changes & WebKit::WCLayerChange::Transform)
        encoder << instance.transform;
    if (instance.changes & WebKit::WCLayerChange::ChildrenTransform)
        encoder << instance.childrenTransform;
    if (instance.changes & WebKit::WCLayerChange::Filters)
        encoder << instance.filters;
    if (instance.changes & WebKit::WCLayerChange::BackdropFilters)
        encoder << instance.backdropFilters;
    if (instance.changes & WebKit::WCLayerChange::BackdropFiltersRect)
        encoder << instance.backdropFiltersRect;
    if (instance.changes & WebKit::WCLayerChange::ContentsClippingRect)
        encoder << instance.contentsClippingRect;
    if (instance.changes & WebKit::WCLayerChange::PlatformLayer)
        encoder << instance.platformLayer;
    if (instance.changes & WebKit::WCLayerChange::RemoteFrame)
        encoder << instance.hostIdentifier;
}

std::optional<WebKit::WCLayerUpdateInfo> ArgumentCoder<WebKit::WCLayerUpdateInfo>::decode(Decoder& decoder)
{
    auto id = decoder.decode<WebCore::PlatformLayerIdentifier>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;

    if (!(id))
        return std::nullopt;
    auto changes = decoder.decode<OptionSet<WebKit::WCLayerChange>>();
    if (!changes)
        return std::nullopt;

    Vector<WebCore::PlatformLayerIdentifier> children { };
    if (*changes & WebKit::WCLayerChange::Children) {
        if (auto deserialized = decoder.decode<Vector<WebCore::PlatformLayerIdentifier>>())
            children = WTFMove(*deserialized);
        else
            return std::nullopt;
    }

    std::optional<WebCore::PlatformLayerIdentifier> maskLayer { };
    if (*changes & WebKit::WCLayerChange::MaskLayer) {
        if (auto deserialized = decoder.decode<std::optional<WebCore::PlatformLayerIdentifier>>())
            maskLayer = WTFMove(*deserialized);
        else
            return std::nullopt;
    }

    std::optional<WebCore::PlatformLayerIdentifier> replicaLayer { };
    if (*changes & WebKit::WCLayerChange::ReplicaLayer) {
        if (auto deserialized = decoder.decode<std::optional<WebCore::PlatformLayerIdentifier>>())
            replicaLayer = WTFMove(*deserialized);
        else
            return std::nullopt;
    }

    WebCore::FloatPoint position { };
    if (*changes & WebKit::WCLayerChange::Position) {
        if (auto deserialized = decoder.decode<WebCore::FloatPoint>())
            position = WTFMove(*deserialized);
        else
            return std::nullopt;
    }

    WebCore::FloatPoint3D anchorPoint { };
    if (*changes & WebKit::WCLayerChange::AnchorPoint) {
        if (auto deserialized = decoder.decode<WebCore::FloatPoint3D>())
            anchorPoint = WTFMove(*deserialized);
        else
            return std::nullopt;
    }

    WebCore::FloatSize size { };
    if (*changes & WebKit::WCLayerChange::Size) {
        if (auto deserialized = decoder.decode<WebCore::FloatSize>())
            size = WTFMove(*deserialized);
        else
            return std::nullopt;
    }

    WebCore::FloatPoint boundsOrigin { };
    if (*changes & WebKit::WCLayerChange::BoundsOrigin) {
        if (auto deserialized = decoder.decode<WebCore::FloatPoint>())
            boundsOrigin = WTFMove(*deserialized);
        else
            return std::nullopt;
    }

    bool masksToBounds { };
    if (*changes & WebKit::WCLayerChange::MasksToBounds) {
        if (auto deserialized = decoder.decode<bool>())
            masksToBounds = WTFMove(*deserialized);
        else
            return std::nullopt;
    }

    bool contentsRectClipsDescendants { };
    if (*changes & WebKit::WCLayerChange::ContentsRectClipsDescendants) {
        if (auto deserialized = decoder.decode<bool>())
            contentsRectClipsDescendants = WTFMove(*deserialized);
        else
            return std::nullopt;
    }

    bool showDebugBorder { };
    if (*changes & WebKit::WCLayerChange::ShowDebugBorder) {
        if (auto deserialized = decoder.decode<bool>())
            showDebugBorder = WTFMove(*deserialized);
        else
            return std::nullopt;
    }

    bool showRepaintCounter { };
    if (*changes & WebKit::WCLayerChange::ShowRepaintCounter) {
        if (auto deserialized = decoder.decode<bool>())
            showRepaintCounter = WTFMove(*deserialized);
        else
            return std::nullopt;
    }

    bool contentsVisible { };
    if (*changes & WebKit::WCLayerChange::ContentsVisible) {
        if (auto deserialized = decoder.decode<bool>())
            contentsVisible = WTFMove(*deserialized);
        else
            return std::nullopt;
    }

    bool backfaceVisibility { };
    if (*changes & WebKit::WCLayerChange::BackfaceVisibility) {
        if (auto deserialized = decoder.decode<bool>())
            backfaceVisibility = WTFMove(*deserialized);
        else
            return std::nullopt;
    }

    bool preserves3D { };
    if (*changes & WebKit::WCLayerChange::Preserves3D) {
        if (auto deserialized = decoder.decode<bool>())
            preserves3D = WTFMove(*deserialized);
        else
            return std::nullopt;
    }

    WebCore::Color solidColor { };
    if (*changes & WebKit::WCLayerChange::SolidColor) {
        if (auto deserialized = decoder.decode<WebCore::Color>())
            solidColor = WTFMove(*deserialized);
        else
            return std::nullopt;
    }

    WebCore::Color debugBorderColor { };
    if (*changes & WebKit::WCLayerChange::DebugBorderColor) {
        if (auto deserialized = decoder.decode<WebCore::Color>())
            debugBorderColor = WTFMove(*deserialized);
        else
            return std::nullopt;
    }

    float opacity { };
    if (*changes & WebKit::WCLayerChange::Opacity) {
        if (auto deserialized = decoder.decode<float>())
            opacity = WTFMove(*deserialized);
        else
            return std::nullopt;
    }

    float debugBorderWidth { };
    if (*changes & WebKit::WCLayerChange::DebugBorderWidth) {
        if (auto deserialized = decoder.decode<float>())
            debugBorderWidth = WTFMove(*deserialized);
        else
            return std::nullopt;
    }

    int repaintCount { };
    if (*changes & WebKit::WCLayerChange::RepaintCount) {
        if (auto deserialized = decoder.decode<int>())
            repaintCount = WTFMove(*deserialized);
        else
            return std::nullopt;
    }

    WebCore::FloatRect contentsRect { };
    if (*changes & WebKit::WCLayerChange::ContentsRect) {
        if (auto deserialized = decoder.decode<WebCore::FloatRect>())
            contentsRect = WTFMove(*deserialized);
        else
            return std::nullopt;
    }

    WebKit::WCLayerUpdateInfo::BackgroundChanges background { };
    if (*changes & WebKit::WCLayerChange::Background) {
        if (auto deserialized = decoder.decode<WebKit::WCLayerUpdateInfo::BackgroundChanges>())
            background = WTFMove(*deserialized);
        else
            return std::nullopt;
    }

    WebCore::TransformationMatrix transform { };
    if (*changes & WebKit::WCLayerChange::Transform) {
        if (auto deserialized = decoder.decode<WebCore::TransformationMatrix>())
            transform = WTFMove(*deserialized);
        else
            return std::nullopt;
    }

    WebCore::TransformationMatrix childrenTransform { };
    if (*changes & WebKit::WCLayerChange::ChildrenTransform) {
        if (auto deserialized = decoder.decode<WebCore::TransformationMatrix>())
            childrenTransform = WTFMove(*deserialized);
        else
            return std::nullopt;
    }

    WebCore::FilterOperations filters { };
    if (*changes & WebKit::WCLayerChange::Filters) {
        if (auto deserialized = decoder.decode<WebCore::FilterOperations>())
            filters = WTFMove(*deserialized);
        else
            return std::nullopt;
    }

    WebCore::FilterOperations backdropFilters { };
    if (*changes & WebKit::WCLayerChange::BackdropFilters) {
        if (auto deserialized = decoder.decode<WebCore::FilterOperations>())
            backdropFilters = WTFMove(*deserialized);
        else
            return std::nullopt;
    }

    WebCore::FloatRoundedRect backdropFiltersRect { };
    if (*changes & WebKit::WCLayerChange::BackdropFiltersRect) {
        if (auto deserialized = decoder.decode<WebCore::FloatRoundedRect>())
            backdropFiltersRect = WTFMove(*deserialized);
        else
            return std::nullopt;
    }

    WebCore::FloatRoundedRect contentsClippingRect { };
    if (*changes & WebKit::WCLayerChange::ContentsClippingRect) {
        if (auto deserialized = decoder.decode<WebCore::FloatRoundedRect>())
            contentsClippingRect = WTFMove(*deserialized);
        else
            return std::nullopt;
    }

    WebKit::WCLayerUpdateInfo::PlatformLayerChanges platformLayer { };
    if (*changes & WebKit::WCLayerChange::PlatformLayer) {
        if (auto deserialized = decoder.decode<WebKit::WCLayerUpdateInfo::PlatformLayerChanges>())
            platformLayer = WTFMove(*deserialized);
        else
            return std::nullopt;
    }

    Markable<WebCore::LayerHostingContextIdentifier> hostIdentifier { };
    if (*changes & WebKit::WCLayerChange::RemoteFrame) {
        if (auto deserialized = decoder.decode<Markable<WebCore::LayerHostingContextIdentifier>>())
            hostIdentifier = WTFMove(*deserialized);
        else
            return std::nullopt;
    }
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WCLayerUpdateInfo {
            WTFMove(*id),
            WTFMove(*changes),
            WTFMove(children),
            WTFMove(maskLayer),
            WTFMove(replicaLayer),
            WTFMove(position),
            WTFMove(anchorPoint),
            WTFMove(size),
            WTFMove(boundsOrigin),
            WTFMove(masksToBounds),
            WTFMove(contentsRectClipsDescendants),
            WTFMove(showDebugBorder),
            WTFMove(showRepaintCounter),
            WTFMove(contentsVisible),
            WTFMove(backfaceVisibility),
            WTFMove(preserves3D),
            WTFMove(solidColor),
            WTFMove(debugBorderColor),
            WTFMove(opacity),
            WTFMove(debugBorderWidth),
            WTFMove(repaintCount),
            WTFMove(contentsRect),
            WTFMove(background),
            WTFMove(transform),
            WTFMove(childrenTransform),
            WTFMove(filters),
            WTFMove(backdropFilters),
            WTFMove(backdropFiltersRect),
            WTFMove(contentsClippingRect),
            WTFMove(platformLayer),
            WTFMove(hostIdentifier)
        }
    };
}

#endif

#if USE(GRAPHICS_LAYER_WC)
void ArgumentCoder<WebKit::WCUpdateInfo>::encode(Encoder& encoder, const WebKit::WCUpdateInfo& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.viewport)>, WebCore::IntSize>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.remoteContextHostedIdentifier)>, Markable<WebCore::LayerHostingContextIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.rootLayer)>, Markable<WebCore::PlatformLayerIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.addedLayers)>, Vector<WebCore::PlatformLayerIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.removedLayers)>, Vector<WebCore::PlatformLayerIdentifier>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.changedLayers)>, Vector<WebKit::WCLayerUpdateInfo>>);
    struct ShouldBeSameSizeAsWCUpdateInfo : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::WCUpdateInfo>, false> {
        WebCore::IntSize viewport;
        Markable<WebCore::LayerHostingContextIdentifier> remoteContextHostedIdentifier;
        Markable<WebCore::PlatformLayerIdentifier> rootLayer;
        Vector<WebCore::PlatformLayerIdentifier> addedLayers;
        Vector<WebCore::PlatformLayerIdentifier> removedLayers;
        Vector<WebKit::WCLayerUpdateInfo> changedLayers;
    };
    static_assert(sizeof(ShouldBeSameSizeAsWCUpdateInfo) == sizeof(WebKit::WCUpdateInfo));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::WCUpdateInfo, viewport)
        , offsetof(WebKit::WCUpdateInfo, remoteContextHostedIdentifier)
        , offsetof(WebKit::WCUpdateInfo, rootLayer)
        , offsetof(WebKit::WCUpdateInfo, addedLayers)
        , offsetof(WebKit::WCUpdateInfo, removedLayers)
        , offsetof(WebKit::WCUpdateInfo, changedLayers)
    >::value);

    encoder << instance.viewport;
    encoder << instance.remoteContextHostedIdentifier;
    encoder << instance.rootLayer;
    encoder << instance.addedLayers;
    encoder << instance.removedLayers;
    encoder << instance.changedLayers;
}

std::optional<WebKit::WCUpdateInfo> ArgumentCoder<WebKit::WCUpdateInfo>::decode(Decoder& decoder)
{
    auto viewport = decoder.decode<WebCore::IntSize>();
    auto remoteContextHostedIdentifier = decoder.decode<Markable<WebCore::LayerHostingContextIdentifier>>();
    auto rootLayer = decoder.decode<Markable<WebCore::PlatformLayerIdentifier>>();
    auto addedLayers = decoder.decode<Vector<WebCore::PlatformLayerIdentifier>>();
    auto removedLayers = decoder.decode<Vector<WebCore::PlatformLayerIdentifier>>();
    auto changedLayers = decoder.decode<Vector<WebKit::WCLayerUpdateInfo>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::WCUpdateInfo {
            WTFMove(*viewport),
            WTFMove(*remoteContextHostedIdentifier),
            WTFMove(*rootLayer),
            WTFMove(*addedLayers),
            WTFMove(*removedLayers),
            WTFMove(*changedLayers)
        }
    };
}

#endif

void ArgumentCoder<WTF::Win32Handle>::encode(Encoder& encoder, WTF::Win32Handle&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.toIPCData())>, WTF::Win32Handle::IPCData>);

    encoder << instance.toIPCData();
}

std::optional<WTF::Win32Handle> ArgumentCoder<WTF::Win32Handle>::decode(Decoder& decoder)
{
    auto toIPCData = decoder.decode<WTF::Win32Handle::IPCData>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WTF::Win32Handle::createFromIPCData(
            WTFMove(*toIPCData)
        )
    };
}

void ArgumentCoder<WTF::Win32Handle::IPCData>::encode(Encoder& encoder, WTF::Win32Handle::IPCData&& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.handle)>, uintptr_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.processID)>, DWORD>);
    struct ShouldBeSameSizeAsIPCData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WTF::Win32Handle::IPCData>, false> {
        uintptr_t handle;
        DWORD processID;
    };
    static_assert(sizeof(ShouldBeSameSizeAsIPCData) == sizeof(WTF::Win32Handle::IPCData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WTF::Win32Handle::IPCData, handle)
        , offsetof(WTF::Win32Handle::IPCData, processID)
    >::value);

    encoder << WTFMove(instance.handle);
    encoder << WTFMove(instance.processID);
}

std::optional<WTF::Win32Handle::IPCData> ArgumentCoder<WTF::Win32Handle::IPCData>::decode(Decoder& decoder)
{
    auto handle = decoder.decode<uintptr_t>();
    auto processID = decoder.decode<DWORD>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WTF::Win32Handle::IPCData {
            WTFMove(*handle),
            WTFMove(*processID)
        }
    };
}

#if USE(SKIA)
void ArgumentCoder<hb_feature_t>::encode(Encoder& encoder, const hb_feature_t& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.tag)>, hb_tag_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, uint32_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.start)>, unsigned>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.end)>, unsigned>);
    struct ShouldBeSameSizeAshb_feature_t : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<hb_feature_t>, false> {
        hb_tag_t tag;
        uint32_t value;
        unsigned start;
        unsigned end;
    };
    static_assert(sizeof(ShouldBeSameSizeAshb_feature_t) == sizeof(hb_feature_t));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(hb_feature_t, tag)
        , offsetof(hb_feature_t, value)
        , offsetof(hb_feature_t, start)
        , offsetof(hb_feature_t, end)
    >::value);

    encoder << instance.tag;
    encoder << instance.value;
    encoder << instance.start;
    encoder << instance.end;
}

std::optional<hb_feature_t> ArgumentCoder<hb_feature_t>::decode(Decoder& decoder)
{
    auto tag = decoder.decode<hb_tag_t>();
    auto value = decoder.decode<uint32_t>();
    auto start = decoder.decode<unsigned>();
    auto end = decoder.decode<unsigned>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        hb_feature_t {
            WTFMove(*tag),
            WTFMove(*value),
            WTFMove(*start),
            WTFMove(*end)
        }
    };
}

#endif

#if USE(SKIA)
void ArgumentCoder<sk_sp<SkColorSpace>>::encode(Encoder& encoder, const sk_sp<SkColorSpace>& passedInstance)
{
    auto instance = WebKit::CoreIPCSkColorSpace(passedInstance);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dataReference())>, std::span<const uint8_t>>);

    encoder << instance.dataReference();
}

void ArgumentCoder<sk_sp<SkColorSpace>>::encode(StreamConnectionEncoder& encoder, const sk_sp<SkColorSpace>& passedInstance)
{
    auto instance = WebKit::CoreIPCSkColorSpace(passedInstance);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dataReference())>, std::span<const uint8_t>>);

    encoder << instance.dataReference();
}

std::optional<sk_sp<SkColorSpace>> ArgumentCoder<sk_sp<SkColorSpace>>::decode(Decoder& decoder)
{
    auto dataReference = decoder.decode<std::span<const uint8_t>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::CoreIPCSkColorSpace::create(
            WTFMove(*dataReference)
        )
    };
}

#endif

#if USE(SKIA)
void ArgumentCoder<sk_sp<SkData>>::encode(Encoder& encoder, const sk_sp<SkData>& passedInstance)
{
    auto instance = WebKit::CoreIPCSkData(passedInstance);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dataReference())>, std::span<const uint8_t>>);

    encoder << instance.dataReference();
}

void ArgumentCoder<sk_sp<SkData>>::encode(StreamConnectionEncoder& encoder, const sk_sp<SkData>& passedInstance)
{
    auto instance = WebKit::CoreIPCSkData(passedInstance);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dataReference())>, std::span<const uint8_t>>);

    encoder << instance.dataReference();
}

std::optional<sk_sp<SkData>> ArgumentCoder<sk_sp<SkData>>::decode(Decoder& decoder)
{
    auto dataReference = decoder.decode<std::span<const uint8_t>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::CoreIPCSkData::create(
            WTFMove(*dataReference)
        )
    };
}

#endif

#if USE(SKIA)
void ArgumentCoder<SkFontStyle::Slant>::encode(Encoder& encoder, const SkFontStyle::Slant& passedInstance)
{
    auto instance = WebKit::CoreIPCSkFontStyleSlant(passedInstance);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data())>, uint8_t>);

    encoder << instance.data();
}

std::optional<SkFontStyle::Slant> ArgumentCoder<SkFontStyle::Slant>::decode(Decoder& decoder)
{
    auto data = decoder.decode<uint8_t>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::CoreIPCSkFontStyleSlant::create(
            WTFMove(*data)
        )
    };
}

#endif

#if USE(SKIA)
void ArgumentCoder<SkString>::encode(Encoder& encoder, const SkString& passedInstance)
{
    auto instance = WebKit::CoreIPCSkString(passedInstance);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.data())>, std::span<const char>>);

    encoder << instance.data();
}

std::optional<SkString> ArgumentCoder<SkString>::decode(Decoder& decoder)
{
    auto data = decoder.decode<std::span<const char>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::CoreIPCSkString::create(
            WTFMove(*data)
        )
    };
}

#endif

void ArgumentCoder<SkFontStyle>::encode(Encoder& encoder, const SkFontStyle& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.weight())>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.width())>, int>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.slant())>, SkFontStyle::Slant>);

    encoder << instance.weight();
    encoder << instance.width();
    encoder << instance.slant();
}

std::optional<SkFontStyle> ArgumentCoder<SkFontStyle>::decode(Decoder& decoder)
{
    auto weight = decoder.decode<int>();
    auto width = decoder.decode<int>();
    auto slant = decoder.decode<SkFontStyle::Slant>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        SkFontStyle {
            WTFMove(*weight),
            WTFMove(*width),
            WTFMove(*slant)
        }
    };
}

#if USE(SKIA)
void ArgumentCoder<WebCore::FontPlatformSerializedCreationData>::encode(Encoder& encoder, const WebCore::FontPlatformSerializedCreationData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fontFaceData)>, Vector<uint8_t>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.itemInCollection)>, String>);
    struct ShouldBeSameSizeAsFontPlatformSerializedCreationData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FontPlatformSerializedCreationData>, false> {
        Vector<uint8_t> fontFaceData;
        String itemInCollection;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFontPlatformSerializedCreationData) == sizeof(WebCore::FontPlatformSerializedCreationData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FontPlatformSerializedCreationData, fontFaceData)
        , offsetof(WebCore::FontPlatformSerializedCreationData, itemInCollection)
    >::value);

    encoder << instance.fontFaceData;
    encoder << instance.itemInCollection;
}

std::optional<WebCore::FontPlatformSerializedCreationData> ArgumentCoder<WebCore::FontPlatformSerializedCreationData>::decode(Decoder& decoder)
{
    auto fontFaceData = decoder.decode<Vector<uint8_t>>();
    auto itemInCollection = decoder.decode<String>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FontPlatformSerializedCreationData {
            WTFMove(*fontFaceData),
            WTFMove(*itemInCollection)
        }
    };
}

#endif

#if USE(SKIA)
void ArgumentCoder<WebCore::FontPlatformSerializedData>::encode(Encoder& encoder, const WebCore::FontPlatformSerializedData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.typefaceData)>, sk_sp<SkData>>);
    struct ShouldBeSameSizeAsFontPlatformSerializedData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FontPlatformSerializedData>, false> {
        sk_sp<SkData> typefaceData;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFontPlatformSerializedData) == sizeof(WebCore::FontPlatformSerializedData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FontPlatformSerializedData, typefaceData)
    >::value);

    encoder << instance.typefaceData;
}

std::optional<WebCore::FontPlatformSerializedData> ArgumentCoder<WebCore::FontPlatformSerializedData>::decode(Decoder& decoder)
{
    auto typefaceData = decoder.decode<sk_sp<SkData>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FontPlatformSerializedData {
            WTFMove(*typefaceData)
        }
    };
}

#endif

void ArgumentCoder<WebCore::DocumentSyncData>::encode(Encoder& encoder, const WebCore::DocumentSyncData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isAutofocusProcessed)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.userDidInteractWithPage)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.isClosing)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.documentURL)>, URL>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.documentSecurityOrigin)>, RefPtr<WebCore::SecurityOrigin>>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.documentClasses)>, OptionSet<WebCore::DocumentClass>>);
#if ENABLE(DOM_AUDIO_SESSION)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.audioSessionType)>, WebCore::DOMAudioSessionType>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.hasInjectedUserScript)>, bool>);
    struct ShouldBeSameSizeAsDocumentSyncData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::DocumentSyncData>, true> {
        bool isAutofocusProcessed;
        bool userDidInteractWithPage;
        bool isClosing;
        URL documentURL;
        RefPtr<WebCore::SecurityOrigin> documentSecurityOrigin;
        OptionSet<WebCore::DocumentClass> documentClasses;
#if ENABLE(DOM_AUDIO_SESSION)
        WebCore::DOMAudioSessionType audioSessionType;
#endif
        bool hasInjectedUserScript;
    };
    static_assert(sizeof(ShouldBeSameSizeAsDocumentSyncData) == sizeof(WebCore::DocumentSyncData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::DocumentSyncData, isAutofocusProcessed)
        , offsetof(WebCore::DocumentSyncData, userDidInteractWithPage)
        , offsetof(WebCore::DocumentSyncData, isClosing)
        , offsetof(WebCore::DocumentSyncData, documentURL)
        , offsetof(WebCore::DocumentSyncData, documentSecurityOrigin)
        , offsetof(WebCore::DocumentSyncData, documentClasses)
#if ENABLE(DOM_AUDIO_SESSION)
        , offsetof(WebCore::DocumentSyncData, audioSessionType)
#endif
        , offsetof(WebCore::DocumentSyncData, hasInjectedUserScript)
    >::value);

    encoder << instance.isAutofocusProcessed;
    encoder << instance.userDidInteractWithPage;
    encoder << instance.isClosing;
    encoder << instance.documentURL;
    encoder << instance.documentSecurityOrigin;
    encoder << instance.documentClasses;
#if ENABLE(DOM_AUDIO_SESSION)
    encoder << instance.audioSessionType;
#endif
    encoder << instance.hasInjectedUserScript;
}

std::optional<Ref<WebCore::DocumentSyncData>> ArgumentCoder<WebCore::DocumentSyncData>::decode(Decoder& decoder)
{
    auto isAutofocusProcessed = decoder.decode<bool>();
    auto userDidInteractWithPage = decoder.decode<bool>();
    auto isClosing = decoder.decode<bool>();
    auto documentURL = decoder.decode<URL>();
    auto documentSecurityOrigin = decoder.decode<RefPtr<WebCore::SecurityOrigin>>();
    auto documentClasses = decoder.decode<OptionSet<WebCore::DocumentClass>>();
#if ENABLE(DOM_AUDIO_SESSION)
    auto audioSessionType = decoder.decode<WebCore::DOMAudioSessionType>();
#endif
    auto hasInjectedUserScript = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::DocumentSyncData::create(
            WTFMove(*isAutofocusProcessed),
            WTFMove(*userDidInteractWithPage),
            WTFMove(*isClosing),
            WTFMove(*documentURL),
            WTFMove(*documentSecurityOrigin),
            WTFMove(*documentClasses),
#if ENABLE(DOM_AUDIO_SESSION)
            WTFMove(*audioSessionType),
#endif
            WTFMove(*hasInjectedUserScript)
        )
    };
}

void ArgumentCoder<WebCore::FrameTreeSyncData>::encode(Encoder& encoder, const WebCore::FrameTreeSyncData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameCanCreatePaymentSession)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.frameDocumentSecurityOrigin)>, RefPtr<WebCore::SecurityOrigin>>);
    struct ShouldBeSameSizeAsFrameTreeSyncData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::FrameTreeSyncData>, true> {
        bool frameCanCreatePaymentSession;
        RefPtr<WebCore::SecurityOrigin> frameDocumentSecurityOrigin;
    };
    static_assert(sizeof(ShouldBeSameSizeAsFrameTreeSyncData) == sizeof(WebCore::FrameTreeSyncData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::FrameTreeSyncData, frameCanCreatePaymentSession)
        , offsetof(WebCore::FrameTreeSyncData, frameDocumentSecurityOrigin)
    >::value);

    encoder << instance.frameCanCreatePaymentSession;
    encoder << instance.frameDocumentSecurityOrigin;
}

std::optional<Ref<WebCore::FrameTreeSyncData>> ArgumentCoder<WebCore::FrameTreeSyncData>::decode(Decoder& decoder)
{
    auto frameCanCreatePaymentSession = decoder.decode<bool>();
    auto frameDocumentSecurityOrigin = decoder.decode<RefPtr<WebCore::SecurityOrigin>>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::FrameTreeSyncData::create(
            WTFMove(*frameCanCreatePaymentSession),
            WTFMove(*frameDocumentSecurityOrigin)
        )
    };
}

void ArgumentCoder<WebCore::ProcessSyncData>::encode(Encoder& encoder, const WebCore::ProcessSyncData& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.type)>, WebCore::ProcessSyncDataType>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.value)>, WebCore::ProcessSyncDataVariant>);
    struct ShouldBeSameSizeAsProcessSyncData : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebCore::ProcessSyncData>, false> {
        WebCore::ProcessSyncDataType type;
        WebCore::ProcessSyncDataVariant value;
    };
    static_assert(sizeof(ShouldBeSameSizeAsProcessSyncData) == sizeof(WebCore::ProcessSyncData));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebCore::ProcessSyncData, type)
        , offsetof(WebCore::ProcessSyncData, value)
    >::value);

    encoder << instance.type;
    encoder << instance.value;
}

std::optional<WebCore::ProcessSyncData> ArgumentCoder<WebCore::ProcessSyncData>::decode(Decoder& decoder)
{
    auto type = decoder.decode<WebCore::ProcessSyncDataType>();
    auto value = decoder.decode<WebCore::ProcessSyncDataVariant>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebCore::ProcessSyncData {
            WTFMove(*type),
            WTFMove(*value)
        }
    };
}

void ArgumentCoder<WebKit::SharedPreferencesForWebProcess>::encode(Encoder& encoder, const WebKit::SharedPreferencesForWebProcess& instance)
{
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.version)>, uint64_t>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowTestOnlyIPC)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webSocketEnabled)>, bool>);
#if ENABLE(APPLE_PAY)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.applePayEnabled)>, bool>);
#endif
#if ENABLE(WEB_AUDIO)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webAudioEnabled)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.videoPresentationModeAPIEnabled)>, bool>);
#if ENABLE(MEDIA_CONTROLS_CONTEXT_MENUS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaControlsContextMenusEnabled)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.videoPresentationManagerEnabled)>, bool>);
#if ENABLE(FULLSCREEN_API)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.videoFullscreenRequiresElementFullscreen)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.usesSingleWebProcess)>, bool>);
#if ENABLE(DEVICE_ORIENTATION)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.deviceOrientationEventEnabled)>, bool>);
#endif
#if ENABLE(DEVICE_ORIENTATION)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.deviceOrientationPermissionAPIEnabled)>, bool>);
#endif
#if USE(SYSTEM_PREVIEW)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.systemPreviewEnabled)>, bool>);
#endif
#if ENABLE(ENCRYPTED_MEDIA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.encryptedMediaAPIEnabled)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.allowPrivacySensitiveOperationsInNonPersistentDataStores)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.appBadgeEnabled)>, bool>);
#if ENABLE(ATTACHMENT_ELEMENT)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.attachmentElementEnabled)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.broadcastChannelEnabled)>, bool>);
#if ENABLE(WEB_PUSH_NOTIFICATIONS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.builtInNotificationsEnabled)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.canvasPixelFormatEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.inputTypeColorEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.contactPickerAPIEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cookieConsentAPIEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.cookieStoreManagerEnabled)>, bool>);
#if PLATFORM(MAC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.inputMethodUsesCorrectKeyEventOrder)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.dataListElementEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.inputTypeDateEnabled)>, bool>);
#if ENABLE(WEB_AUTHN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.digitalCredentialsEnabled)>, bool>);
#endif
#if ENABLE(RE_DYNAMIC_CONTENT_SCALING)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.useCGDisplayListsForDOMRendering)>, bool>);
#endif
#if ENABLE(LEGACY_ENCRYPTED_MEDIA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.legacyEncryptedMediaAPIEnabled)>, bool>);
#endif
#if ENABLE(MODEL_PROCESS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.modelProcessEnabled)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.backgroundFetchAPIEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.blobFileAccessEnforcementEnabled)>, bool>);
#if ENABLE(MEDIA_SESSION_COORDINATOR)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaSessionCoordinatorEnabled)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fileSystemEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fileSystemWritableStreamEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.forceLockdownFontParserEnabled)>, bool>);
#if ENABLE(FULLSCREEN_API)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.fullScreenEnabled)>, bool>);
#endif
#if ENABLE(GPU_PROCESS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.useGPUProcessForDOMRenderingEnabled)>, bool>);
#endif
#if ENABLE(GPU_PROCESS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.useGPUProcessForMediaEnabled)>, bool>);
#endif
#if ENABLE(GPU_PROCESS) && ENABLE(WEBGL)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.useGPUProcessForWebGLEnabled)>, bool>);
#endif
#if ENABLE(GAMEPAD)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.gamepadsEnabled)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.geolocationAPIEnabled)>, bool>);
#if ENABLE(MODEL_ELEMENT)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.modelElementEnabled)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.inputTypeColorEnhancementsEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.ignoreIframeEmbeddingProtectionsEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.indexedDBAPIEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.lockdownFontParserEnabled)>, bool>);
#if ENABLE(MEDIA_SOURCE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.managedMediaSourceEnabled)>, bool>);
#endif
#if ENABLE(EXTENSION_CAPABILITIES)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaCapabilityGrantsEnabled)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaPlaybackEnabled)>, bool>);
#if ENABLE(MEDIA_SESSION)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaSessionEnabled)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaSourceEnabled)>, bool>);
#if ENABLE(MEDIA_RECORDER_WEBM)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaRecorderEnabledWebM)>, bool>);
#endif
#if ENABLE(MEDIA_RECORDER)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaRecorderEnabled)>, bool>);
#endif
#if ENABLE(MEDIA_SOURCE) && USE(AVFOUNDATION)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.mediaSourcePrefersDecompressionSession)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.inputTypeMonthEnabled)>, bool>);
#if ENABLE(NOTIFICATION_EVENT)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.notificationEventEnabled)>, bool>);
#endif
#if ENABLE(NOTIFICATIONS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.notificationsEnabled)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.permissionsAPIEnabled)>, bool>);
#if HAVE(SPATIAL_AUDIO_EXPERIENCE)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.preferSpatialAudioExperience)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.pushAPIEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.remoteMediaSessionManagerEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.loginStatusAPIRequiresWebAuthnEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.screenOrientationAPIEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.serviceWorkerNavigationPreloadEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.serviceWorkersEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shapeDetection)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.siteIsolationSharedProcessEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.sharedWorkerEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.siteIsolationEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.speechRecognitionEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.speechSynthesisAPIEnabled)>, bool>);
#if ENABLE(IMAGE_ANALYSIS) && ENABLE(VIDEO)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.textRecognitionInVideosEnabled)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.inputTypeTimeEnabled)>, bool>);
#if HAVE(AVCAPTUREDEVICEROTATIONCOORDINATOR)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.useAVCaptureDeviceRotationCoordinatorAPI)>, bool>);
#endif
#if HAVE(WEBCONTENTRESTRICTIONS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.usesWebContentRestrictionsForFilter)>, bool>);
#endif
#if USE(MODERN_AVCONTENTKEYSESSION_WITH_VTDECOMPRESSIONSESSION)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.videoRendererProtectedFallbackDisabled)>, bool>);
#endif
#if USE(MODERN_AVCONTENTKEYSESSION_WITH_VTDECOMPRESSIONSESSION)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.videoRendererUseDecompressionSessionForProtected)>, bool>);
#endif
#if ENABLE(WEB_AUTHN)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webAuthenticationEnabled)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webLocksAPIEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webShareEnabled)>, bool>);
#if ENABLE(WEB_CODECS)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webCodecsVideoEnabled)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webGLEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webGPUHDREnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webXRWebGPUBindingsEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webGPUEnabled)>, bool>);
#if ENABLE(WEB_RTC)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.peerConnectionEnabled)>, bool>);
#endif
#if ENABLE(WEB_RTC) && PLATFORM(COCOA)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webRTCInterfaceMonitoringViaNWEnabled)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webTransportEnabled)>, bool>);
#if ENABLE(WEBXR)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webXREnabled)>, bool>);
#endif
#if ENABLE(WEB_PAGE_SPATIAL_BACKDROP)
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.webPageSpatialBackdropEnabled)>, bool>);
#endif
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.inputTypeWeekEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.inputTypeDateTimeLocalEnabled)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shadowRootReferenceTargetEnabledForAriaOwns)>, bool>);
    static_assert(std::is_same_v<std::remove_cvref_t<decltype(instance.shadowRootReferenceTargetEnabled)>, bool>);
    struct ShouldBeSameSizeAsSharedPreferencesForWebProcess : public VirtualTableAndRefCountOverhead<std::is_polymorphic_v<WebKit::SharedPreferencesForWebProcess>, false> {
        uint64_t version;
        bool allowTestOnlyIPC : 1;
        bool webSocketEnabled : 1;
#if ENABLE(APPLE_PAY)
        bool applePayEnabled : 1;
#endif
#if ENABLE(WEB_AUDIO)
        bool webAudioEnabled : 1;
#endif
        bool videoPresentationModeAPIEnabled : 1;
#if ENABLE(MEDIA_CONTROLS_CONTEXT_MENUS)
        bool mediaControlsContextMenusEnabled : 1;
#endif
        bool videoPresentationManagerEnabled : 1;
#if ENABLE(FULLSCREEN_API)
        bool videoFullscreenRequiresElementFullscreen : 1;
#endif
        bool usesSingleWebProcess : 1;
#if ENABLE(DEVICE_ORIENTATION)
        bool deviceOrientationEventEnabled : 1;
#endif
#if ENABLE(DEVICE_ORIENTATION)
        bool deviceOrientationPermissionAPIEnabled : 1;
#endif
#if USE(SYSTEM_PREVIEW)
        bool systemPreviewEnabled : 1;
#endif
#if ENABLE(ENCRYPTED_MEDIA)
        bool encryptedMediaAPIEnabled : 1;
#endif
        bool allowPrivacySensitiveOperationsInNonPersistentDataStores : 1;
        bool appBadgeEnabled : 1;
#if ENABLE(ATTACHMENT_ELEMENT)
        bool attachmentElementEnabled : 1;
#endif
        bool broadcastChannelEnabled : 1;
#if ENABLE(WEB_PUSH_NOTIFICATIONS)
        bool builtInNotificationsEnabled : 1;
#endif
        bool canvasPixelFormatEnabled : 1;
        bool inputTypeColorEnabled : 1;
        bool contactPickerAPIEnabled : 1;
        bool cookieConsentAPIEnabled : 1;
        bool cookieStoreManagerEnabled : 1;
#if PLATFORM(MAC)
        bool inputMethodUsesCorrectKeyEventOrder : 1;
#endif
        bool dataListElementEnabled : 1;
        bool inputTypeDateEnabled : 1;
#if ENABLE(WEB_AUTHN)
        bool digitalCredentialsEnabled : 1;
#endif
#if ENABLE(RE_DYNAMIC_CONTENT_SCALING)
        bool useCGDisplayListsForDOMRendering : 1;
#endif
#if ENABLE(LEGACY_ENCRYPTED_MEDIA)
        bool legacyEncryptedMediaAPIEnabled : 1;
#endif
#if ENABLE(MODEL_PROCESS)
        bool modelProcessEnabled : 1;
#endif
        bool backgroundFetchAPIEnabled : 1;
        bool blobFileAccessEnforcementEnabled : 1;
#if ENABLE(MEDIA_SESSION_COORDINATOR)
        bool mediaSessionCoordinatorEnabled : 1;
#endif
        bool fileSystemEnabled : 1;
        bool fileSystemWritableStreamEnabled : 1;
        bool forceLockdownFontParserEnabled : 1;
#if ENABLE(FULLSCREEN_API)
        bool fullScreenEnabled : 1;
#endif
#if ENABLE(GPU_PROCESS)
        bool useGPUProcessForDOMRenderingEnabled : 1;
#endif
#if ENABLE(GPU_PROCESS)
        bool useGPUProcessForMediaEnabled : 1;
#endif
#if ENABLE(GPU_PROCESS) && ENABLE(WEBGL)
        bool useGPUProcessForWebGLEnabled : 1;
#endif
#if ENABLE(GAMEPAD)
        bool gamepadsEnabled : 1;
#endif
        bool geolocationAPIEnabled : 1;
#if ENABLE(MODEL_ELEMENT)
        bool modelElementEnabled : 1;
#endif
        bool inputTypeColorEnhancementsEnabled : 1;
        bool ignoreIframeEmbeddingProtectionsEnabled : 1;
        bool indexedDBAPIEnabled : 1;
        bool lockdownFontParserEnabled : 1;
#if ENABLE(MEDIA_SOURCE)
        bool managedMediaSourceEnabled : 1;
#endif
#if ENABLE(EXTENSION_CAPABILITIES)
        bool mediaCapabilityGrantsEnabled : 1;
#endif
        bool mediaPlaybackEnabled : 1;
#if ENABLE(MEDIA_SESSION)
        bool mediaSessionEnabled : 1;
#endif
        bool mediaSourceEnabled : 1;
#if ENABLE(MEDIA_RECORDER_WEBM)
        bool mediaRecorderEnabledWebM : 1;
#endif
#if ENABLE(MEDIA_RECORDER)
        bool mediaRecorderEnabled : 1;
#endif
#if ENABLE(MEDIA_SOURCE) && USE(AVFOUNDATION)
        bool mediaSourcePrefersDecompressionSession : 1;
#endif
        bool inputTypeMonthEnabled : 1;
#if ENABLE(NOTIFICATION_EVENT)
        bool notificationEventEnabled : 1;
#endif
#if ENABLE(NOTIFICATIONS)
        bool notificationsEnabled : 1;
#endif
        bool permissionsAPIEnabled : 1;
#if HAVE(SPATIAL_AUDIO_EXPERIENCE)
        bool preferSpatialAudioExperience : 1;
#endif
        bool pushAPIEnabled : 1;
        bool remoteMediaSessionManagerEnabled : 1;
        bool loginStatusAPIRequiresWebAuthnEnabled : 1;
        bool screenOrientationAPIEnabled : 1;
        bool serviceWorkerNavigationPreloadEnabled : 1;
        bool serviceWorkersEnabled : 1;
        bool shapeDetection : 1;
        bool siteIsolationSharedProcessEnabled : 1;
        bool sharedWorkerEnabled : 1;
        bool siteIsolationEnabled : 1;
        bool speechRecognitionEnabled : 1;
        bool speechSynthesisAPIEnabled : 1;
#if ENABLE(IMAGE_ANALYSIS) && ENABLE(VIDEO)
        bool textRecognitionInVideosEnabled : 1;
#endif
        bool inputTypeTimeEnabled : 1;
#if HAVE(AVCAPTUREDEVICEROTATIONCOORDINATOR)
        bool useAVCaptureDeviceRotationCoordinatorAPI : 1;
#endif
#if HAVE(WEBCONTENTRESTRICTIONS)
        bool usesWebContentRestrictionsForFilter : 1;
#endif
#if USE(MODERN_AVCONTENTKEYSESSION_WITH_VTDECOMPRESSIONSESSION)
        bool videoRendererProtectedFallbackDisabled : 1;
#endif
#if USE(MODERN_AVCONTENTKEYSESSION_WITH_VTDECOMPRESSIONSESSION)
        bool videoRendererUseDecompressionSessionForProtected : 1;
#endif
#if ENABLE(WEB_AUTHN)
        bool webAuthenticationEnabled : 1;
#endif
        bool webLocksAPIEnabled : 1;
        bool webShareEnabled : 1;
#if ENABLE(WEB_CODECS)
        bool webCodecsVideoEnabled : 1;
#endif
        bool webGLEnabled : 1;
        bool webGPUHDREnabled : 1;
        bool webXRWebGPUBindingsEnabled : 1;
        bool webGPUEnabled : 1;
#if ENABLE(WEB_RTC)
        bool peerConnectionEnabled : 1;
#endif
#if ENABLE(WEB_RTC) && PLATFORM(COCOA)
        bool webRTCInterfaceMonitoringViaNWEnabled : 1;
#endif
        bool webTransportEnabled : 1;
#if ENABLE(WEBXR)
        bool webXREnabled : 1;
#endif
#if ENABLE(WEB_PAGE_SPATIAL_BACKDROP)
        bool webPageSpatialBackdropEnabled : 1;
#endif
        bool inputTypeWeekEnabled : 1;
        bool inputTypeDateTimeLocalEnabled : 1;
        bool shadowRootReferenceTargetEnabledForAriaOwns : 1;
        bool shadowRootReferenceTargetEnabled : 1;
    };
    static_assert(sizeof(ShouldBeSameSizeAsSharedPreferencesForWebProcess) == sizeof(WebKit::SharedPreferencesForWebProcess));
    static_assert(MembersInCorrectOrder < 0
        , offsetof(WebKit::SharedPreferencesForWebProcess, version)
    >::value);

    encoder << instance.version;
    encoder << instance.allowTestOnlyIPC;
    encoder << instance.webSocketEnabled;
#if ENABLE(APPLE_PAY)
    encoder << instance.applePayEnabled;
#endif
#if ENABLE(WEB_AUDIO)
    encoder << instance.webAudioEnabled;
#endif
    encoder << instance.videoPresentationModeAPIEnabled;
#if ENABLE(MEDIA_CONTROLS_CONTEXT_MENUS)
    encoder << instance.mediaControlsContextMenusEnabled;
#endif
    encoder << instance.videoPresentationManagerEnabled;
#if ENABLE(FULLSCREEN_API)
    encoder << instance.videoFullscreenRequiresElementFullscreen;
#endif
    encoder << instance.usesSingleWebProcess;
#if ENABLE(DEVICE_ORIENTATION)
    encoder << instance.deviceOrientationEventEnabled;
#endif
#if ENABLE(DEVICE_ORIENTATION)
    encoder << instance.deviceOrientationPermissionAPIEnabled;
#endif
#if USE(SYSTEM_PREVIEW)
    encoder << instance.systemPreviewEnabled;
#endif
#if ENABLE(ENCRYPTED_MEDIA)
    encoder << instance.encryptedMediaAPIEnabled;
#endif
    encoder << instance.allowPrivacySensitiveOperationsInNonPersistentDataStores;
    encoder << instance.appBadgeEnabled;
#if ENABLE(ATTACHMENT_ELEMENT)
    encoder << instance.attachmentElementEnabled;
#endif
    encoder << instance.broadcastChannelEnabled;
#if ENABLE(WEB_PUSH_NOTIFICATIONS)
    encoder << instance.builtInNotificationsEnabled;
#endif
    encoder << instance.canvasPixelFormatEnabled;
    encoder << instance.inputTypeColorEnabled;
    encoder << instance.contactPickerAPIEnabled;
    encoder << instance.cookieConsentAPIEnabled;
    encoder << instance.cookieStoreManagerEnabled;
#if PLATFORM(MAC)
    encoder << instance.inputMethodUsesCorrectKeyEventOrder;
#endif
    encoder << instance.dataListElementEnabled;
    encoder << instance.inputTypeDateEnabled;
#if ENABLE(WEB_AUTHN)
    encoder << instance.digitalCredentialsEnabled;
#endif
#if ENABLE(RE_DYNAMIC_CONTENT_SCALING)
    encoder << instance.useCGDisplayListsForDOMRendering;
#endif
#if ENABLE(LEGACY_ENCRYPTED_MEDIA)
    encoder << instance.legacyEncryptedMediaAPIEnabled;
#endif
#if ENABLE(MODEL_PROCESS)
    encoder << instance.modelProcessEnabled;
#endif
    encoder << instance.backgroundFetchAPIEnabled;
    encoder << instance.blobFileAccessEnforcementEnabled;
#if ENABLE(MEDIA_SESSION_COORDINATOR)
    encoder << instance.mediaSessionCoordinatorEnabled;
#endif
    encoder << instance.fileSystemEnabled;
    encoder << instance.fileSystemWritableStreamEnabled;
    encoder << instance.forceLockdownFontParserEnabled;
#if ENABLE(FULLSCREEN_API)
    encoder << instance.fullScreenEnabled;
#endif
#if ENABLE(GPU_PROCESS)
    encoder << instance.useGPUProcessForDOMRenderingEnabled;
#endif
#if ENABLE(GPU_PROCESS)
    encoder << instance.useGPUProcessForMediaEnabled;
#endif
#if ENABLE(GPU_PROCESS) && ENABLE(WEBGL)
    encoder << instance.useGPUProcessForWebGLEnabled;
#endif
#if ENABLE(GAMEPAD)
    encoder << instance.gamepadsEnabled;
#endif
    encoder << instance.geolocationAPIEnabled;
#if ENABLE(MODEL_ELEMENT)
    encoder << instance.modelElementEnabled;
#endif
    encoder << instance.inputTypeColorEnhancementsEnabled;
    encoder << instance.ignoreIframeEmbeddingProtectionsEnabled;
    encoder << instance.indexedDBAPIEnabled;
    encoder << instance.lockdownFontParserEnabled;
#if ENABLE(MEDIA_SOURCE)
    encoder << instance.managedMediaSourceEnabled;
#endif
#if ENABLE(EXTENSION_CAPABILITIES)
    encoder << instance.mediaCapabilityGrantsEnabled;
#endif
    encoder << instance.mediaPlaybackEnabled;
#if ENABLE(MEDIA_SESSION)
    encoder << instance.mediaSessionEnabled;
#endif
    encoder << instance.mediaSourceEnabled;
#if ENABLE(MEDIA_RECORDER_WEBM)
    encoder << instance.mediaRecorderEnabledWebM;
#endif
#if ENABLE(MEDIA_RECORDER)
    encoder << instance.mediaRecorderEnabled;
#endif
#if ENABLE(MEDIA_SOURCE) && USE(AVFOUNDATION)
    encoder << instance.mediaSourcePrefersDecompressionSession;
#endif
    encoder << instance.inputTypeMonthEnabled;
#if ENABLE(NOTIFICATION_EVENT)
    encoder << instance.notificationEventEnabled;
#endif
#if ENABLE(NOTIFICATIONS)
    encoder << instance.notificationsEnabled;
#endif
    encoder << instance.permissionsAPIEnabled;
#if HAVE(SPATIAL_AUDIO_EXPERIENCE)
    encoder << instance.preferSpatialAudioExperience;
#endif
    encoder << instance.pushAPIEnabled;
    encoder << instance.remoteMediaSessionManagerEnabled;
    encoder << instance.loginStatusAPIRequiresWebAuthnEnabled;
    encoder << instance.screenOrientationAPIEnabled;
    encoder << instance.serviceWorkerNavigationPreloadEnabled;
    encoder << instance.serviceWorkersEnabled;
    encoder << instance.shapeDetection;
    encoder << instance.siteIsolationSharedProcessEnabled;
    encoder << instance.sharedWorkerEnabled;
    encoder << instance.siteIsolationEnabled;
    encoder << instance.speechRecognitionEnabled;
    encoder << instance.speechSynthesisAPIEnabled;
#if ENABLE(IMAGE_ANALYSIS) && ENABLE(VIDEO)
    encoder << instance.textRecognitionInVideosEnabled;
#endif
    encoder << instance.inputTypeTimeEnabled;
#if HAVE(AVCAPTUREDEVICEROTATIONCOORDINATOR)
    encoder << instance.useAVCaptureDeviceRotationCoordinatorAPI;
#endif
#if HAVE(WEBCONTENTRESTRICTIONS)
    encoder << instance.usesWebContentRestrictionsForFilter;
#endif
#if USE(MODERN_AVCONTENTKEYSESSION_WITH_VTDECOMPRESSIONSESSION)
    encoder << instance.videoRendererProtectedFallbackDisabled;
#endif
#if USE(MODERN_AVCONTENTKEYSESSION_WITH_VTDECOMPRESSIONSESSION)
    encoder << instance.videoRendererUseDecompressionSessionForProtected;
#endif
#if ENABLE(WEB_AUTHN)
    encoder << instance.webAuthenticationEnabled;
#endif
    encoder << instance.webLocksAPIEnabled;
    encoder << instance.webShareEnabled;
#if ENABLE(WEB_CODECS)
    encoder << instance.webCodecsVideoEnabled;
#endif
    encoder << instance.webGLEnabled;
    encoder << instance.webGPUHDREnabled;
    encoder << instance.webXRWebGPUBindingsEnabled;
    encoder << instance.webGPUEnabled;
#if ENABLE(WEB_RTC)
    encoder << instance.peerConnectionEnabled;
#endif
#if ENABLE(WEB_RTC) && PLATFORM(COCOA)
    encoder << instance.webRTCInterfaceMonitoringViaNWEnabled;
#endif
    encoder << instance.webTransportEnabled;
#if ENABLE(WEBXR)
    encoder << instance.webXREnabled;
#endif
#if ENABLE(WEB_PAGE_SPATIAL_BACKDROP)
    encoder << instance.webPageSpatialBackdropEnabled;
#endif
    encoder << instance.inputTypeWeekEnabled;
    encoder << instance.inputTypeDateTimeLocalEnabled;
    encoder << instance.shadowRootReferenceTargetEnabledForAriaOwns;
    encoder << instance.shadowRootReferenceTargetEnabled;
}

std::optional<WebKit::SharedPreferencesForWebProcess> ArgumentCoder<WebKit::SharedPreferencesForWebProcess>::decode(Decoder& decoder)
{
    auto version = decoder.decode<uint64_t>();
    auto allowTestOnlyIPC = decoder.decode<bool>();
    auto webSocketEnabled = decoder.decode<bool>();
#if ENABLE(APPLE_PAY)
    auto applePayEnabled = decoder.decode<bool>();
#endif
#if ENABLE(WEB_AUDIO)
    auto webAudioEnabled = decoder.decode<bool>();
#endif
    auto videoPresentationModeAPIEnabled = decoder.decode<bool>();
#if ENABLE(MEDIA_CONTROLS_CONTEXT_MENUS)
    auto mediaControlsContextMenusEnabled = decoder.decode<bool>();
#endif
    auto videoPresentationManagerEnabled = decoder.decode<bool>();
#if ENABLE(FULLSCREEN_API)
    auto videoFullscreenRequiresElementFullscreen = decoder.decode<bool>();
#endif
    auto usesSingleWebProcess = decoder.decode<bool>();
#if ENABLE(DEVICE_ORIENTATION)
    auto deviceOrientationEventEnabled = decoder.decode<bool>();
#endif
#if ENABLE(DEVICE_ORIENTATION)
    auto deviceOrientationPermissionAPIEnabled = decoder.decode<bool>();
#endif
#if USE(SYSTEM_PREVIEW)
    auto systemPreviewEnabled = decoder.decode<bool>();
#endif
#if ENABLE(ENCRYPTED_MEDIA)
    auto encryptedMediaAPIEnabled = decoder.decode<bool>();
#endif
    auto allowPrivacySensitiveOperationsInNonPersistentDataStores = decoder.decode<bool>();
    auto appBadgeEnabled = decoder.decode<bool>();
#if ENABLE(ATTACHMENT_ELEMENT)
    auto attachmentElementEnabled = decoder.decode<bool>();
#endif
    auto broadcastChannelEnabled = decoder.decode<bool>();
#if ENABLE(WEB_PUSH_NOTIFICATIONS)
    auto builtInNotificationsEnabled = decoder.decode<bool>();
#endif
    auto canvasPixelFormatEnabled = decoder.decode<bool>();
    auto inputTypeColorEnabled = decoder.decode<bool>();
    auto contactPickerAPIEnabled = decoder.decode<bool>();
    auto cookieConsentAPIEnabled = decoder.decode<bool>();
    auto cookieStoreManagerEnabled = decoder.decode<bool>();
#if PLATFORM(MAC)
    auto inputMethodUsesCorrectKeyEventOrder = decoder.decode<bool>();
#endif
    auto dataListElementEnabled = decoder.decode<bool>();
    auto inputTypeDateEnabled = decoder.decode<bool>();
#if ENABLE(WEB_AUTHN)
    auto digitalCredentialsEnabled = decoder.decode<bool>();
#endif
#if ENABLE(RE_DYNAMIC_CONTENT_SCALING)
    auto useCGDisplayListsForDOMRendering = decoder.decode<bool>();
#endif
#if ENABLE(LEGACY_ENCRYPTED_MEDIA)
    auto legacyEncryptedMediaAPIEnabled = decoder.decode<bool>();
#endif
#if ENABLE(MODEL_PROCESS)
    auto modelProcessEnabled = decoder.decode<bool>();
#endif
    auto backgroundFetchAPIEnabled = decoder.decode<bool>();
    auto blobFileAccessEnforcementEnabled = decoder.decode<bool>();
#if ENABLE(MEDIA_SESSION_COORDINATOR)
    auto mediaSessionCoordinatorEnabled = decoder.decode<bool>();
#endif
    auto fileSystemEnabled = decoder.decode<bool>();
    auto fileSystemWritableStreamEnabled = decoder.decode<bool>();
    auto forceLockdownFontParserEnabled = decoder.decode<bool>();
#if ENABLE(FULLSCREEN_API)
    auto fullScreenEnabled = decoder.decode<bool>();
#endif
#if ENABLE(GPU_PROCESS)
    auto useGPUProcessForDOMRenderingEnabled = decoder.decode<bool>();
#endif
#if ENABLE(GPU_PROCESS)
    auto useGPUProcessForMediaEnabled = decoder.decode<bool>();
#endif
#if ENABLE(GPU_PROCESS) && ENABLE(WEBGL)
    auto useGPUProcessForWebGLEnabled = decoder.decode<bool>();
#endif
#if ENABLE(GAMEPAD)
    auto gamepadsEnabled = decoder.decode<bool>();
#endif
    auto geolocationAPIEnabled = decoder.decode<bool>();
#if ENABLE(MODEL_ELEMENT)
    auto modelElementEnabled = decoder.decode<bool>();
#endif
    auto inputTypeColorEnhancementsEnabled = decoder.decode<bool>();
    auto ignoreIframeEmbeddingProtectionsEnabled = decoder.decode<bool>();
    auto indexedDBAPIEnabled = decoder.decode<bool>();
    auto lockdownFontParserEnabled = decoder.decode<bool>();
#if ENABLE(MEDIA_SOURCE)
    auto managedMediaSourceEnabled = decoder.decode<bool>();
#endif
#if ENABLE(EXTENSION_CAPABILITIES)
    auto mediaCapabilityGrantsEnabled = decoder.decode<bool>();
#endif
    auto mediaPlaybackEnabled = decoder.decode<bool>();
#if ENABLE(MEDIA_SESSION)
    auto mediaSessionEnabled = decoder.decode<bool>();
#endif
    auto mediaSourceEnabled = decoder.decode<bool>();
#if ENABLE(MEDIA_RECORDER_WEBM)
    auto mediaRecorderEnabledWebM = decoder.decode<bool>();
#endif
#if ENABLE(MEDIA_RECORDER)
    auto mediaRecorderEnabled = decoder.decode<bool>();
#endif
#if ENABLE(MEDIA_SOURCE) && USE(AVFOUNDATION)
    auto mediaSourcePrefersDecompressionSession = decoder.decode<bool>();
#endif
    auto inputTypeMonthEnabled = decoder.decode<bool>();
#if ENABLE(NOTIFICATION_EVENT)
    auto notificationEventEnabled = decoder.decode<bool>();
#endif
#if ENABLE(NOTIFICATIONS)
    auto notificationsEnabled = decoder.decode<bool>();
#endif
    auto permissionsAPIEnabled = decoder.decode<bool>();
#if HAVE(SPATIAL_AUDIO_EXPERIENCE)
    auto preferSpatialAudioExperience = decoder.decode<bool>();
#endif
    auto pushAPIEnabled = decoder.decode<bool>();
    auto remoteMediaSessionManagerEnabled = decoder.decode<bool>();
    auto loginStatusAPIRequiresWebAuthnEnabled = decoder.decode<bool>();
    auto screenOrientationAPIEnabled = decoder.decode<bool>();
    auto serviceWorkerNavigationPreloadEnabled = decoder.decode<bool>();
    auto serviceWorkersEnabled = decoder.decode<bool>();
    auto shapeDetection = decoder.decode<bool>();
    auto siteIsolationSharedProcessEnabled = decoder.decode<bool>();
    auto sharedWorkerEnabled = decoder.decode<bool>();
    auto siteIsolationEnabled = decoder.decode<bool>();
    auto speechRecognitionEnabled = decoder.decode<bool>();
    auto speechSynthesisAPIEnabled = decoder.decode<bool>();
#if ENABLE(IMAGE_ANALYSIS) && ENABLE(VIDEO)
    auto textRecognitionInVideosEnabled = decoder.decode<bool>();
#endif
    auto inputTypeTimeEnabled = decoder.decode<bool>();
#if HAVE(AVCAPTUREDEVICEROTATIONCOORDINATOR)
    auto useAVCaptureDeviceRotationCoordinatorAPI = decoder.decode<bool>();
#endif
#if HAVE(WEBCONTENTRESTRICTIONS)
    auto usesWebContentRestrictionsForFilter = decoder.decode<bool>();
#endif
#if USE(MODERN_AVCONTENTKEYSESSION_WITH_VTDECOMPRESSIONSESSION)
    auto videoRendererProtectedFallbackDisabled = decoder.decode<bool>();
#endif
#if USE(MODERN_AVCONTENTKEYSESSION_WITH_VTDECOMPRESSIONSESSION)
    auto videoRendererUseDecompressionSessionForProtected = decoder.decode<bool>();
#endif
#if ENABLE(WEB_AUTHN)
    auto webAuthenticationEnabled = decoder.decode<bool>();
#endif
    auto webLocksAPIEnabled = decoder.decode<bool>();
    auto webShareEnabled = decoder.decode<bool>();
#if ENABLE(WEB_CODECS)
    auto webCodecsVideoEnabled = decoder.decode<bool>();
#endif
    auto webGLEnabled = decoder.decode<bool>();
    auto webGPUHDREnabled = decoder.decode<bool>();
    auto webXRWebGPUBindingsEnabled = decoder.decode<bool>();
    auto webGPUEnabled = decoder.decode<bool>();
#if ENABLE(WEB_RTC)
    auto peerConnectionEnabled = decoder.decode<bool>();
#endif
#if ENABLE(WEB_RTC) && PLATFORM(COCOA)
    auto webRTCInterfaceMonitoringViaNWEnabled = decoder.decode<bool>();
#endif
    auto webTransportEnabled = decoder.decode<bool>();
#if ENABLE(WEBXR)
    auto webXREnabled = decoder.decode<bool>();
#endif
#if ENABLE(WEB_PAGE_SPATIAL_BACKDROP)
    auto webPageSpatialBackdropEnabled = decoder.decode<bool>();
#endif
    auto inputTypeWeekEnabled = decoder.decode<bool>();
    auto inputTypeDateTimeLocalEnabled = decoder.decode<bool>();
    auto shadowRootReferenceTargetEnabledForAriaOwns = decoder.decode<bool>();
    auto shadowRootReferenceTargetEnabled = decoder.decode<bool>();
    if (!decoder.isValid()) [[unlikely]]
        return std::nullopt;
    return {
        WebKit::SharedPreferencesForWebProcess {
            WTFMove(*version),
            WTFMove(*allowTestOnlyIPC),
            WTFMove(*webSocketEnabled),
#if ENABLE(APPLE_PAY)
            WTFMove(*applePayEnabled),
#endif
#if ENABLE(WEB_AUDIO)
            WTFMove(*webAudioEnabled),
#endif
            WTFMove(*videoPresentationModeAPIEnabled),
#if ENABLE(MEDIA_CONTROLS_CONTEXT_MENUS)
            WTFMove(*mediaControlsContextMenusEnabled),
#endif
            WTFMove(*videoPresentationManagerEnabled),
#if ENABLE(FULLSCREEN_API)
            WTFMove(*videoFullscreenRequiresElementFullscreen),
#endif
            WTFMove(*usesSingleWebProcess),
#if ENABLE(DEVICE_ORIENTATION)
            WTFMove(*deviceOrientationEventEnabled),
#endif
#if ENABLE(DEVICE_ORIENTATION)
            WTFMove(*deviceOrientationPermissionAPIEnabled),
#endif
#if USE(SYSTEM_PREVIEW)
            WTFMove(*systemPreviewEnabled),
#endif
#if ENABLE(ENCRYPTED_MEDIA)
            WTFMove(*encryptedMediaAPIEnabled),
#endif
            WTFMove(*allowPrivacySensitiveOperationsInNonPersistentDataStores),
            WTFMove(*appBadgeEnabled),
#if ENABLE(ATTACHMENT_ELEMENT)
            WTFMove(*attachmentElementEnabled),
#endif
            WTFMove(*broadcastChannelEnabled),
#if ENABLE(WEB_PUSH_NOTIFICATIONS)
            WTFMove(*builtInNotificationsEnabled),
#endif
            WTFMove(*canvasPixelFormatEnabled),
            WTFMove(*inputTypeColorEnabled),
            WTFMove(*contactPickerAPIEnabled),
            WTFMove(*cookieConsentAPIEnabled),
            WTFMove(*cookieStoreManagerEnabled),
#if PLATFORM(MAC)
            WTFMove(*inputMethodUsesCorrectKeyEventOrder),
#endif
            WTFMove(*dataListElementEnabled),
            WTFMove(*inputTypeDateEnabled),
#if ENABLE(WEB_AUTHN)
            WTFMove(*digitalCredentialsEnabled),
#endif
#if ENABLE(RE_DYNAMIC_CONTENT_SCALING)
            WTFMove(*useCGDisplayListsForDOMRendering),
#endif
#if ENABLE(LEGACY_ENCRYPTED_MEDIA)
            WTFMove(*legacyEncryptedMediaAPIEnabled),
#endif
#if ENABLE(MODEL_PROCESS)
            WTFMove(*modelProcessEnabled),
#endif
            WTFMove(*backgroundFetchAPIEnabled),
            WTFMove(*blobFileAccessEnforcementEnabled),
#if ENABLE(MEDIA_SESSION_COORDINATOR)
            WTFMove(*mediaSessionCoordinatorEnabled),
#endif
            WTFMove(*fileSystemEnabled),
            WTFMove(*fileSystemWritableStreamEnabled),
            WTFMove(*forceLockdownFontParserEnabled),
#if ENABLE(FULLSCREEN_API)
            WTFMove(*fullScreenEnabled),
#endif
#if ENABLE(GPU_PROCESS)
            WTFMove(*useGPUProcessForDOMRenderingEnabled),
#endif
#if ENABLE(GPU_PROCESS)
            WTFMove(*useGPUProcessForMediaEnabled),
#endif
#if ENABLE(GPU_PROCESS) && ENABLE(WEBGL)
            WTFMove(*useGPUProcessForWebGLEnabled),
#endif
#if ENABLE(GAMEPAD)
            WTFMove(*gamepadsEnabled),
#endif
            WTFMove(*geolocationAPIEnabled),
#if ENABLE(MODEL_ELEMENT)
            WTFMove(*modelElementEnabled),
#endif
            WTFMove(*inputTypeColorEnhancementsEnabled),
            WTFMove(*ignoreIframeEmbeddingProtectionsEnabled),
            WTFMove(*indexedDBAPIEnabled),
            WTFMove(*lockdownFontParserEnabled),
#if ENABLE(MEDIA_SOURCE)
            WTFMove(*managedMediaSourceEnabled),
#endif
#if ENABLE(EXTENSION_CAPABILITIES)
            WTFMove(*mediaCapabilityGrantsEnabled),
#endif
            WTFMove(*mediaPlaybackEnabled),
#if ENABLE(MEDIA_SESSION)
            WTFMove(*mediaSessionEnabled),
#endif
            WTFMove(*mediaSourceEnabled),
#if ENABLE(MEDIA_RECORDER_WEBM)
            WTFMove(*mediaRecorderEnabledWebM),
#endif
#if ENABLE(MEDIA_RECORDER)
            WTFMove(*mediaRecorderEnabled),
#endif
#if ENABLE(MEDIA_SOURCE) && USE(AVFOUNDATION)
            WTFMove(*mediaSourcePrefersDecompressionSession),
#endif
            WTFMove(*inputTypeMonthEnabled),
#if ENABLE(NOTIFICATION_EVENT)
            WTFMove(*notificationEventEnabled),
#endif
#if ENABLE(NOTIFICATIONS)
            WTFMove(*notificationsEnabled),
#endif
            WTFMove(*permissionsAPIEnabled),
#if HAVE(SPATIAL_AUDIO_EXPERIENCE)
            WTFMove(*preferSpatialAudioExperience),
#endif
            WTFMove(*pushAPIEnabled),
            WTFMove(*remoteMediaSessionManagerEnabled),
            WTFMove(*loginStatusAPIRequiresWebAuthnEnabled),
            WTFMove(*screenOrientationAPIEnabled),
            WTFMove(*serviceWorkerNavigationPreloadEnabled),
            WTFMove(*serviceWorkersEnabled),
            WTFMove(*shapeDetection),
            WTFMove(*siteIsolationSharedProcessEnabled),
            WTFMove(*sharedWorkerEnabled),
            WTFMove(*siteIsolationEnabled),
            WTFMove(*speechRecognitionEnabled),
            WTFMove(*speechSynthesisAPIEnabled),
#if ENABLE(IMAGE_ANALYSIS) && ENABLE(VIDEO)
            WTFMove(*textRecognitionInVideosEnabled),
#endif
            WTFMove(*inputTypeTimeEnabled),
#if HAVE(AVCAPTUREDEVICEROTATIONCOORDINATOR)
            WTFMove(*useAVCaptureDeviceRotationCoordinatorAPI),
#endif
#if HAVE(WEBCONTENTRESTRICTIONS)
            WTFMove(*usesWebContentRestrictionsForFilter),
#endif
#if USE(MODERN_AVCONTENTKEYSESSION_WITH_VTDECOMPRESSIONSESSION)
            WTFMove(*videoRendererProtectedFallbackDisabled),
#endif
#if USE(MODERN_AVCONTENTKEYSESSION_WITH_VTDECOMPRESSIONSESSION)
            WTFMove(*videoRendererUseDecompressionSessionForProtected),
#endif
#if ENABLE(WEB_AUTHN)
            WTFMove(*webAuthenticationEnabled),
#endif
            WTFMove(*webLocksAPIEnabled),
            WTFMove(*webShareEnabled),
#if ENABLE(WEB_CODECS)
            WTFMove(*webCodecsVideoEnabled),
#endif
            WTFMove(*webGLEnabled),
            WTFMove(*webGPUHDREnabled),
            WTFMove(*webXRWebGPUBindingsEnabled),
            WTFMove(*webGPUEnabled),
#if ENABLE(WEB_RTC)
            WTFMove(*peerConnectionEnabled),
#endif
#if ENABLE(WEB_RTC) && PLATFORM(COCOA)
            WTFMove(*webRTCInterfaceMonitoringViaNWEnabled),
#endif
            WTFMove(*webTransportEnabled),
#if ENABLE(WEBXR)
            WTFMove(*webXREnabled),
#endif
#if ENABLE(WEB_PAGE_SPATIAL_BACKDROP)
            WTFMove(*webPageSpatialBackdropEnabled),
#endif
            WTFMove(*inputTypeWeekEnabled),
            WTFMove(*inputTypeDateTimeLocalEnabled),
            WTFMove(*shadowRootReferenceTargetEnabledForAriaOwns),
            WTFMove(*shadowRootReferenceTargetEnabled)
        }
    };
}

} // namespace IPC

namespace WTF {

template<> bool isValidEnum<IPC::WebCore_TimingFunction_Subclass>(IPC::EncodedVariantIndex value)
{
IGNORE_WARNINGS_BEGIN("switch-unreachable")
    switch (static_cast<IPC::WebCore_TimingFunction_Subclass>(value)) {
    case IPC::WebCore_TimingFunction_Subclass::LinearTimingFunction:
    case IPC::WebCore_TimingFunction_Subclass::CubicBezierTimingFunction:
    case IPC::WebCore_TimingFunction_Subclass::StepsTimingFunction:
    case IPC::WebCore_TimingFunction_Subclass::SpringTimingFunction:
        return true;
    }
IGNORE_WARNINGS_END
    return false;
}

template<> bool isValidEnum<IPC::WebCore_TransformOperation_Subclass>(IPC::EncodedVariantIndex value)
{
IGNORE_WARNINGS_BEGIN("switch-unreachable")
    switch (static_cast<IPC::WebCore_TransformOperation_Subclass>(value)) {
    case IPC::WebCore_TransformOperation_Subclass::TranslateTransformOperation:
    case IPC::WebCore_TransformOperation_Subclass::ScaleTransformOperation:
    case IPC::WebCore_TransformOperation_Subclass::RotateTransformOperation:
    case IPC::WebCore_TransformOperation_Subclass::SkewTransformOperation:
    case IPC::WebCore_TransformOperation_Subclass::MatrixTransformOperation:
    case IPC::WebCore_TransformOperation_Subclass::Matrix3DTransformOperation:
    case IPC::WebCore_TransformOperation_Subclass::PerspectiveTransformOperation:
    case IPC::WebCore_TransformOperation_Subclass::IdentityTransformOperation:
        return true;
    }
IGNORE_WARNINGS_END
    return false;
}

template<> bool isValidEnum<IPC::WebCore_PixelBuffer_Subclass>(IPC::EncodedVariantIndex value)
{
IGNORE_WARNINGS_BEGIN("switch-unreachable")
    switch (static_cast<IPC::WebCore_PixelBuffer_Subclass>(value)) {
    case IPC::WebCore_PixelBuffer_Subclass::ByteArrayPixelBuffer:
        return true;
    }
IGNORE_WARNINGS_END
    return false;
}

template<> bool isValidEnum<IPC::WebCore_PathOperation_Subclass>(IPC::EncodedVariantIndex value)
{
IGNORE_WARNINGS_BEGIN("switch-unreachable")
    switch (static_cast<IPC::WebCore_PathOperation_Subclass>(value)) {
    case IPC::WebCore_PathOperation_Subclass::ReferencePathOperation:
    case IPC::WebCore_PathOperation_Subclass::ShapePathOperation:
    case IPC::WebCore_PathOperation_Subclass::BoxPathOperation:
    case IPC::WebCore_PathOperation_Subclass::RayPathOperation:
        return true;
    }
IGNORE_WARNINGS_END
    return false;
}

template<> bool isValidEnum<IPC::WebCore_ControlPart_Subclass>(IPC::EncodedVariantIndex value)
{
IGNORE_WARNINGS_BEGIN("switch-unreachable")
    switch (static_cast<IPC::WebCore_ControlPart_Subclass>(value)) {
    case IPC::WebCore_ControlPart_Subclass::ButtonPart:
    case IPC::WebCore_ControlPart_Subclass::ColorWellPart:
    case IPC::WebCore_ControlPart_Subclass::InnerSpinButtonPart:
    case IPC::WebCore_ControlPart_Subclass::MenuListButtonPart:
    case IPC::WebCore_ControlPart_Subclass::MenuListPart:
    case IPC::WebCore_ControlPart_Subclass::MeterPart:
    case IPC::WebCore_ControlPart_Subclass::ProgressBarPart:
    case IPC::WebCore_ControlPart_Subclass::SearchFieldPart:
    case IPC::WebCore_ControlPart_Subclass::SearchFieldResultsPart:
    case IPC::WebCore_ControlPart_Subclass::SearchFieldCancelButtonPart:
    case IPC::WebCore_ControlPart_Subclass::SliderThumbPart:
    case IPC::WebCore_ControlPart_Subclass::SliderTrackPart:
    case IPC::WebCore_ControlPart_Subclass::SwitchThumbPart:
    case IPC::WebCore_ControlPart_Subclass::SwitchTrackPart:
    case IPC::WebCore_ControlPart_Subclass::TextAreaPart:
    case IPC::WebCore_ControlPart_Subclass::TextFieldPart:
    case IPC::WebCore_ControlPart_Subclass::ToggleButtonPart:
#if ENABLE(APPLE_PAY)
    case IPC::WebCore_ControlPart_Subclass::ApplePayButtonPart:
#endif
#if ENABLE(SERVICE_CONTROLS)
    case IPC::WebCore_ControlPart_Subclass::ImageControlsButtonPart:
#endif
        return true;
    }
IGNORE_WARNINGS_END
    return false;
}

template<> bool isValidEnum<IPC::WebCore_ReportBody_Subclass>(IPC::EncodedVariantIndex value)
{
IGNORE_WARNINGS_BEGIN("switch-unreachable")
    switch (static_cast<IPC::WebCore_ReportBody_Subclass>(value)) {
    case IPC::WebCore_ReportBody_Subclass::CSPViolationReportBody:
    case IPC::WebCore_ReportBody_Subclass::COEPInheritenceViolationReportBody:
    case IPC::WebCore_ReportBody_Subclass::CORPViolationReportBody:
    case IPC::WebCore_ReportBody_Subclass::DeprecationReportBody:
    case IPC::WebCore_ReportBody_Subclass::TestReportBody:
        return true;
    }
IGNORE_WARNINGS_END
    return false;
}

template<> bool isValidEnum<IPC::WebCore_Filter_Subclass>(IPC::EncodedVariantIndex value)
{
IGNORE_WARNINGS_BEGIN("switch-unreachable")
    switch (static_cast<IPC::WebCore_Filter_Subclass>(value)) {
    case IPC::WebCore_Filter_Subclass::CSSFilter:
    case IPC::WebCore_Filter_Subclass::SVGFilter:
        return true;
    }
IGNORE_WARNINGS_END
    return false;
}

template<> bool isValidEnum<IPC::WebCore_SystemImage_Subclass>(IPC::EncodedVariantIndex value)
{
IGNORE_WARNINGS_BEGIN("switch-unreachable")
    switch (static_cast<IPC::WebCore_SystemImage_Subclass>(value)) {
#if ENABLE(APPLE_PAY)
    case IPC::WebCore_SystemImage_Subclass::ApplePayLogoSystemImage:
#endif
#if USE(SYSTEM_PREVIEW)
    case IPC::WebCore_SystemImage_Subclass::ARKitBadgeSystemImage:
#endif
#if USE(APPKIT)
    case IPC::WebCore_SystemImage_Subclass::AppKitControlSystemImage:
#endif
        return true;
    }
IGNORE_WARNINGS_END
    return false;
}

#if !USE(COORDINATED_GRAPHICS)
template<> bool isValidEnum<IPC::WebCore_FilterOperation_Subclass>(IPC::EncodedVariantIndex value)
{
IGNORE_WARNINGS_BEGIN("switch-unreachable")
    switch (static_cast<IPC::WebCore_FilterOperation_Subclass>(value)) {
    case IPC::WebCore_FilterOperation_Subclass::BasicColorMatrixFilterOperation:
    case IPC::WebCore_FilterOperation_Subclass::BasicComponentTransferFilterOperation:
    case IPC::WebCore_FilterOperation_Subclass::BlurFilterOperation:
    case IPC::WebCore_FilterOperation_Subclass::DropShadowFilterOperation:
    case IPC::WebCore_FilterOperation_Subclass::DefaultFilterOperation:
    case IPC::WebCore_FilterOperation_Subclass::PassthroughFilterOperation:
        return true;
    }
IGNORE_WARNINGS_END
    return false;
}
#endif

template<> bool isValidEnum<IPC::WebCore_FilterEffect_Subclass>(IPC::EncodedVariantIndex value)
{
IGNORE_WARNINGS_BEGIN("switch-unreachable")
    switch (static_cast<IPC::WebCore_FilterEffect_Subclass>(value)) {
    case IPC::WebCore_FilterEffect_Subclass::FEBlend:
    case IPC::WebCore_FilterEffect_Subclass::FEColorMatrix:
    case IPC::WebCore_FilterEffect_Subclass::FEComponentTransfer:
    case IPC::WebCore_FilterEffect_Subclass::FEComposite:
    case IPC::WebCore_FilterEffect_Subclass::FEConvolveMatrix:
    case IPC::WebCore_FilterEffect_Subclass::FEDiffuseLighting:
    case IPC::WebCore_FilterEffect_Subclass::FEDisplacementMap:
    case IPC::WebCore_FilterEffect_Subclass::FEDropShadow:
    case IPC::WebCore_FilterEffect_Subclass::FEFlood:
    case IPC::WebCore_FilterEffect_Subclass::FEGaussianBlur:
    case IPC::WebCore_FilterEffect_Subclass::FEImage:
    case IPC::WebCore_FilterEffect_Subclass::FEMerge:
    case IPC::WebCore_FilterEffect_Subclass::FEMorphology:
    case IPC::WebCore_FilterEffect_Subclass::FEOffset:
    case IPC::WebCore_FilterEffect_Subclass::FETile:
    case IPC::WebCore_FilterEffect_Subclass::FESpecularLighting:
    case IPC::WebCore_FilterEffect_Subclass::FETurbulence:
    case IPC::WebCore_FilterEffect_Subclass::SourceAlpha:
    case IPC::WebCore_FilterEffect_Subclass::SourceGraphic:
        return true;
    }
IGNORE_WARNINGS_END
    return false;
}

template<> bool isValidEnum<IPC::WebCore_LightSource_Subclass>(IPC::EncodedVariantIndex value)
{
IGNORE_WARNINGS_BEGIN("switch-unreachable")
    switch (static_cast<IPC::WebCore_LightSource_Subclass>(value)) {
    case IPC::WebCore_LightSource_Subclass::DistantLightSource:
    case IPC::WebCore_LightSource_Subclass::PointLightSource:
    case IPC::WebCore_LightSource_Subclass::SpotLightSource:
        return true;
    }
IGNORE_WARNINGS_END
    return false;
}

template<> bool isValidEnum<IPC::WebCore_FilterFunction_Subclass>(IPC::EncodedVariantIndex value)
{
IGNORE_WARNINGS_BEGIN("switch-unreachable")
    switch (static_cast<IPC::WebCore_FilterFunction_Subclass>(value)) {
    case IPC::WebCore_FilterFunction_Subclass::SVGFilter:
    case IPC::WebCore_FilterFunction_Subclass::FEBlend:
    case IPC::WebCore_FilterFunction_Subclass::FEColorMatrix:
    case IPC::WebCore_FilterFunction_Subclass::FEComponentTransfer:
    case IPC::WebCore_FilterFunction_Subclass::FEComposite:
    case IPC::WebCore_FilterFunction_Subclass::FEConvolveMatrix:
    case IPC::WebCore_FilterFunction_Subclass::FEDiffuseLighting:
    case IPC::WebCore_FilterFunction_Subclass::FEDisplacementMap:
    case IPC::WebCore_FilterFunction_Subclass::FEDropShadow:
    case IPC::WebCore_FilterFunction_Subclass::FEFlood:
    case IPC::WebCore_FilterFunction_Subclass::FEGaussianBlur:
    case IPC::WebCore_FilterFunction_Subclass::FEImage:
    case IPC::WebCore_FilterFunction_Subclass::FEMerge:
    case IPC::WebCore_FilterFunction_Subclass::FEMorphology:
    case IPC::WebCore_FilterFunction_Subclass::FEOffset:
    case IPC::WebCore_FilterFunction_Subclass::FESpecularLighting:
    case IPC::WebCore_FilterFunction_Subclass::FETile:
    case IPC::WebCore_FilterFunction_Subclass::FETurbulence:
    case IPC::WebCore_FilterFunction_Subclass::SourceAlpha:
    case IPC::WebCore_FilterFunction_Subclass::SourceGraphic:
        return true;
    }
IGNORE_WARNINGS_END
    return false;
}

template<> bool isValidEnum<IPC::API_Object_Subclass>(IPC::EncodedVariantIndex value)
{
IGNORE_WARNINGS_BEGIN("switch-unreachable")
    switch (static_cast<IPC::API_Object_Subclass>(value)) {
    case IPC::API_Object_Subclass::Array:
    case IPC::API_Object_Subclass::Boolean:
    case IPC::API_Object_Subclass::Data:
    case IPC::API_Object_Subclass::Dictionary:
    case IPC::API_Object_Subclass::Double:
    case IPC::API_Object_Subclass::Error:
    case IPC::API_Object_Subclass::FrameHandle:
    case IPC::API_Object_Subclass::WebImage:
    case IPC::API_Object_Subclass::PageHandle:
    case IPC::API_Object_Subclass::Point:
    case IPC::API_Object_Subclass::Rect:
    case IPC::API_Object_Subclass::Size:
    case IPC::API_Object_Subclass::String:
    case IPC::API_Object_Subclass::URL:
    case IPC::API_Object_Subclass::URLRequest:
    case IPC::API_Object_Subclass::URLResponse:
    case IPC::API_Object_Subclass::UInt64:
    case IPC::API_Object_Subclass::Int64:
    case IPC::API_Object_Subclass::UserContentURLPattern:
        return true;
    }
IGNORE_WARNINGS_END
    return false;
}

template<> bool isValidEnum<WebCore::PathRoundedRect::Strategy>(uint8_t value)
{
    switch (static_cast<WebCore::PathRoundedRect::Strategy>(value)) {
    case WebCore::PathRoundedRect::Strategy::PreferNative:
    case WebCore::PathRoundedRect::Strategy::PreferBezier:
        return true;
    default:
        return false;
    }
}

#if ENABLE(GPU_PROCESS) && ENABLE(WEBGL)
template<> bool isValidEnum<WebCore::TextDrawingMode>(uint8_t value)
{
    switch (static_cast<WebCore::TextDrawingMode>(value)) {
    case WebCore::TextDrawingMode::Fill:
    case WebCore::TextDrawingMode::Stroke:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebKit::LoadedWebArchive>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::DidFilterKnownLinkDecoration>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::ShouldGrandfatherStatistics>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::PrivateRelayed>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::ContentAsStringIncludesChildFrames>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::CallDownloadDidStart>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::AllowOverwrite>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::UseDownloadPlaceholder>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::PreconnectOnly>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::NavigatingToAppBoundDomain>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::AllowsCellularAccess>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

#if USE(SOUP)
template<> bool isValidEnum<WebKit::SoupCookiePersistentStorageType>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebKit::StorageAccessStatus>(uint8_t value)
{
    switch (static_cast<WebKit::StorageAccessStatus>(value)) {
    case WebKit::StorageAccessStatus::CannotRequestAccess:
    case WebKit::StorageAccessStatus::RequiresUserPrompt:
    case WebKit::StorageAccessStatus::HasAccess:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::PCM::MessageType>(uint8_t value)
{
    switch (static_cast<WebKit::PCM::MessageType>(value)) {
    case WebKit::PCM::MessageType::StoreUnattributed:
    case WebKit::PCM::MessageType::HandleAttribution:
    case WebKit::PCM::MessageType::Clear:
    case WebKit::PCM::MessageType::ClearForRegistrableDomain:
    case WebKit::PCM::MessageType::MigratePrivateClickMeasurementFromLegacyStorage:
    case WebKit::PCM::MessageType::SetDebugModeIsEnabled:
    case WebKit::PCM::MessageType::ToStringForTesting:
    case WebKit::PCM::MessageType::SetOverrideTimerForTesting:
    case WebKit::PCM::MessageType::SetTokenPublicKeyURLForTesting:
    case WebKit::PCM::MessageType::SetTokenSignatureURLForTesting:
    case WebKit::PCM::MessageType::SetAttributionReportURLsForTesting:
    case WebKit::PCM::MessageType::MarkAllUnattributedAsExpiredForTesting:
    case WebKit::PCM::MessageType::MarkAttributedPrivateClickMeasurementsAsExpiredForTesting:
    case WebKit::PCM::MessageType::SetPCMFraudPreventionValuesForTesting:
    case WebKit::PCM::MessageType::StartTimerImmediatelyForTesting:
    case WebKit::PCM::MessageType::SetPrivateClickMeasurementAppBundleIDForTesting:
    case WebKit::PCM::MessageType::DestroyStoreForTesting:
    case WebKit::PCM::MessageType::AllowTLSCertificateChainForLocalPCMTesting:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::PrivateClickMeasurementAttributionType>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::FileSystemStorageError>(uint8_t value)
{
    switch (static_cast<WebKit::FileSystemStorageError>(value)) {
    case WebKit::FileSystemStorageError::AccessHandleActive:
    case WebKit::FileSystemStorageError::BackendNotSupported:
    case WebKit::FileSystemStorageError::FileNotFound:
    case WebKit::FileSystemStorageError::InvalidDataType:
    case WebKit::FileSystemStorageError::InvalidModification:
    case WebKit::FileSystemStorageError::InvalidName:
    case WebKit::FileSystemStorageError::InvalidState:
    case WebKit::FileSystemStorageError::MissingArgument:
    case WebKit::FileSystemStorageError::TypeMismatch:
    case WebKit::FileSystemStorageError::QuotaError:
    case WebKit::FileSystemStorageError::Unknown:
        return true;
    default:
        return false;
    }
}

#if HAVE(PER_APP_ACCESSIBILITY_PREFERENCES)
template<> bool isValidEnum<WebKit::WebKitAXValueState>(int value)
{
    switch (static_cast<WebKit::WebKitAXValueState>(value)) {
    case WebKit::WebKitAXValueState::AXValueStateInvalid:
    case WebKit::WebKitAXValueState::AXValueStateEmpty:
    case WebKit::WebKitAXValueState::AXValueStateOff:
    case WebKit::WebKitAXValueState::AXValueStateOn:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebKit::BackgroundFetchChange>(uint8_t value)
{
    switch (static_cast<WebKit::BackgroundFetchChange>(value)) {
    case WebKit::BackgroundFetchChange::Addition:
    case WebKit::BackgroundFetchChange::Removal:
    case WebKit::BackgroundFetchChange::Update:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::CacheModel>(uint8_t value)
{
    switch (static_cast<WebKit::CacheModel>(value)) {
    case WebKit::CacheModel::DocumentViewer:
    case WebKit::CacheModel::DocumentBrowser:
    case WebKit::CacheModel::PrimaryWebBrowser:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebKit::ContentWorldOption>(OptionSet<WebKit::ContentWorldOption> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebKit::ContentWorldOption::AllowAccessToClosedShadowRoots)
        | static_cast<uint8_t>(WebKit::ContentWorldOption::AllowAutofill)
        | static_cast<uint8_t>(WebKit::ContentWorldOption::AllowElementUserInfo)
        | static_cast<uint8_t>(WebKit::ContentWorldOption::DisableLegacyBuiltinOverrides)
        | static_cast<uint8_t>(WebKit::ContentWorldOption::AllowNodeInfo)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidEnum<WebKit::CoordinateSystem>(uint8_t value)
{
    switch (static_cast<WebKit::CoordinateSystem>(value)) {
    case WebKit::CoordinateSystem::Page:
    case WebKit::CoordinateSystem::LayoutViewport:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<Inspector::DebuggableType>(uint8_t value)
{
    switch (static_cast<Inspector::DebuggableType>(value)) {
    case Inspector::DebuggableType::ITML:
    case Inspector::DebuggableType::JavaScript:
    case Inspector::DebuggableType::Page:
    case Inspector::DebuggableType::ServiceWorker:
    case Inspector::DebuggableType::WebPage:
        return true;
    default:
        return false;
    }
}

#if PLATFORM(IOS_FAMILY)
template<> bool isValidEnum<WebKit::DocumentEditingContextRequest::Options>(uint8_t value)
{
    switch (static_cast<WebKit::DocumentEditingContextRequest::Options>(value)) {
    case WebKit::DocumentEditingContextRequest::Options::Text:
    case WebKit::DocumentEditingContextRequest::Options::AttributedText:
    case WebKit::DocumentEditingContextRequest::Options::Rects:
    case WebKit::DocumentEditingContextRequest::Options::Spatial:
    case WebKit::DocumentEditingContextRequest::Options::Annotation:
    case WebKit::DocumentEditingContextRequest::Options::MarkedTextRects:
    case WebKit::DocumentEditingContextRequest::Options::SpatialAndCurrentSelection:
    case WebKit::DocumentEditingContextRequest::Options::AutocorrectedRanges:
        return true;
    default:
        return false;
    }
}
#endif

#if PLATFORM(IOS_FAMILY)
template<> bool isValidOptionSet<WebKit::DocumentEditingContextRequest::Options>(OptionSet<WebKit::DocumentEditingContextRequest::Options> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebKit::DocumentEditingContextRequest::Options::Text)
        | static_cast<uint8_t>(WebKit::DocumentEditingContextRequest::Options::AttributedText)
        | static_cast<uint8_t>(WebKit::DocumentEditingContextRequest::Options::Rects)
        | static_cast<uint8_t>(WebKit::DocumentEditingContextRequest::Options::Spatial)
        | static_cast<uint8_t>(WebKit::DocumentEditingContextRequest::Options::Annotation)
        | static_cast<uint8_t>(WebKit::DocumentEditingContextRequest::Options::MarkedTextRects)
        | static_cast<uint8_t>(WebKit::DocumentEditingContextRequest::Options::SpatialAndCurrentSelection)
        | static_cast<uint8_t>(WebKit::DocumentEditingContextRequest::Options::AutocorrectedRanges)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}
#endif

template<> bool isValidEnum<WebKit::DragControllerAction>(uint8_t value)
{
    switch (static_cast<WebKit::DragControllerAction>(value)) {
    case WebKit::DragControllerAction::Entered:
    case WebKit::DragControllerAction::Updated:
    case WebKit::DragControllerAction::Exited:
    case WebKit::DragControllerAction::PerformDragOperation:
        return true;
    default:
        return false;
    }
}

#if ENABLE(TILED_CA_DRAWING_AREA)
template<> bool isValidEnum<WebKit::DrawingAreaType>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebKit::EditingRangeIsRelativeTo>(uint8_t value)
{
    switch (static_cast<WebKit::EditingRangeIsRelativeTo>(value)) {
    case WebKit::EditingRangeIsRelativeTo::EditableRoot:
    case WebKit::EditingRangeIsRelativeTo::Paragraph:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::ListType>(uint8_t value)
{
    switch (static_cast<WebKit::ListType>(value)) {
    case WebKit::ListType::None:
    case WebKit::ListType::OrderedList:
    case WebKit::ListType::UnorderedList:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::TextAlignment>(uint8_t value)
{
    switch (static_cast<WebKit::TextAlignment>(value)) {
    case WebKit::TextAlignment::Natural:
    case WebKit::TextAlignment::Left:
    case WebKit::TextAlignment::Right:
    case WebKit::TextAlignment::Center:
    case WebKit::TextAlignment::Justified:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebKit::TypingAttribute>(OptionSet<WebKit::TypingAttribute> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebKit::TypingAttribute::Bold)
        | static_cast<uint8_t>(WebKit::TypingAttribute::Italics)
        | static_cast<uint8_t>(WebKit::TypingAttribute::Underline)
        | static_cast<uint8_t>(WebKit::TypingAttribute::StrikeThrough)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidEnum<WebKit::InputType>(uint8_t value)
{
    switch (static_cast<WebKit::InputType>(value)) {
    case WebKit::InputType::None:
    case WebKit::InputType::ContentEditable:
    case WebKit::InputType::Text:
    case WebKit::InputType::Password:
    case WebKit::InputType::TextArea:
    case WebKit::InputType::Search:
    case WebKit::InputType::Email:
    case WebKit::InputType::URL:
    case WebKit::InputType::Phone:
    case WebKit::InputType::Number:
    case WebKit::InputType::NumberPad:
    case WebKit::InputType::Date:
    case WebKit::InputType::DateTimeLocal:
    case WebKit::InputType::Month:
    case WebKit::InputType::Week:
    case WebKit::InputType::Time:
    case WebKit::InputType::Select:
    case WebKit::InputType::Drawing:
    case WebKit::InputType::Color:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::ColorControlSupportsAlpha>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::FrameType>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::FullScreenMediaDetails::Type>(uint8_t value)
{
    switch (static_cast<WebKit::FullScreenMediaDetails::Type>(value)) {
    case WebKit::FullScreenMediaDetails::Type::None:
    case WebKit::FullScreenMediaDetails::Type::Video:
    case WebKit::FullScreenMediaDetails::Type::ElementWithVideo:
    case WebKit::FullScreenMediaDetails::Type::Image:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebKit::SnapshotOption>(OptionSet<WebKit::SnapshotOption> value)
{
    constexpr uint16_t allValidBitsValue = 0
        | static_cast<uint16_t>(WebKit::SnapshotOption::Shareable)
        | static_cast<uint16_t>(WebKit::SnapshotOption::ExcludeSelectionHighlighting)
        | static_cast<uint16_t>(WebKit::SnapshotOption::InViewCoordinates)
        | static_cast<uint16_t>(WebKit::SnapshotOption::PaintSelectionRectangle)
        | static_cast<uint16_t>(WebKit::SnapshotOption::ExcludeDeviceScaleFactor)
        | static_cast<uint16_t>(WebKit::SnapshotOption::ForceBlackText)
        | static_cast<uint16_t>(WebKit::SnapshotOption::ForceWhiteText)
        | static_cast<uint16_t>(WebKit::SnapshotOption::Printing)
        | static_cast<uint16_t>(WebKit::SnapshotOption::UseScreenColorSpace)
        | static_cast<uint16_t>(WebKit::SnapshotOption::VisibleContentRect)
        | static_cast<uint16_t>(WebKit::SnapshotOption::FullContentRect)
        | static_cast<uint16_t>(WebKit::SnapshotOption::TransparentBackground)
        | static_cast<uint16_t>(WebKit::SnapshotOption::Accelerated)
        | static_cast<uint16_t>(WebKit::SnapshotOption::AllowHDR)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

#if ENABLE(INSPECTOR_EXTENSIONS)
template<> bool isValidEnum<Inspector::ExtensionError>(uint8_t value)
{
    switch (static_cast<Inspector::ExtensionError>(value)) {
    case Inspector::ExtensionError::ContextDestroyed:
    case Inspector::ExtensionError::InternalError:
    case Inspector::ExtensionError::InvalidRequest:
    case Inspector::ExtensionError::RegistrationFailed:
    case Inspector::ExtensionError::NotImplemented:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(INSPECTOR_EXTENSIONS)
template<> bool isValidEnum<Inspector::ExtensionAppearance>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<JSC::MessageSource>(uint8_t value)
{
    switch (static_cast<JSC::MessageSource>(value)) {
    case JSC::MessageSource::XML:
    case JSC::MessageSource::JS:
    case JSC::MessageSource::Network:
    case JSC::MessageSource::ConsoleAPI:
    case JSC::MessageSource::Storage:
    case JSC::MessageSource::Rendering:
    case JSC::MessageSource::CSS:
    case JSC::MessageSource::Security:
    case JSC::MessageSource::ContentBlocker:
    case JSC::MessageSource::Media:
    case JSC::MessageSource::MediaSource:
    case JSC::MessageSource::WebRTC:
    case JSC::MessageSource::ITPDebug:
    case JSC::MessageSource::PrivateClickMeasurement:
    case JSC::MessageSource::PaymentRequest:
    case JSC::MessageSource::Other:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<JSC::MessageType>(uint8_t value)
{
    switch (static_cast<JSC::MessageType>(value)) {
    case JSC::MessageType::Log:
    case JSC::MessageType::Dir:
    case JSC::MessageType::DirXML:
    case JSC::MessageType::Table:
    case JSC::MessageType::Trace:
    case JSC::MessageType::StartGroup:
    case JSC::MessageType::StartGroupCollapsed:
    case JSC::MessageType::EndGroup:
    case JSC::MessageType::Clear:
    case JSC::MessageType::Assert:
    case JSC::MessageType::Timing:
    case JSC::MessageType::Profile:
    case JSC::MessageType::ProfileEnd:
    case JSC::MessageType::Image:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<JSC::MessageLevel>(uint8_t value)
{
    switch (static_cast<JSC::MessageLevel>(value)) {
    case JSC::MessageLevel::Log:
    case JSC::MessageLevel::Warning:
    case JSC::MessageLevel::Error:
    case JSC::MessageLevel::Debug:
    case JSC::MessageLevel::Info:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<JSC::SourceTaintedOrigin>(uint8_t value)
{
    switch (static_cast<JSC::SourceTaintedOrigin>(value)) {
    case JSC::SourceTaintedOrigin::Untainted:
    case JSC::SourceTaintedOrigin::IndirectlyTaintedByHistory:
    case JSC::SourceTaintedOrigin::IndirectlyTainted:
    case JSC::SourceTaintedOrigin::KnownTainted:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<Inspector::FrontendChannel::ConnectionType>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<Inspector::InspectorTargetType>(uint8_t value)
{
    switch (static_cast<Inspector::InspectorTargetType>(value)) {
    case Inspector::InspectorTargetType::Page:
    case Inspector::InspectorTargetType::DedicatedWorker:
    case Inspector::InspectorTargetType::ServiceWorker:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::JavaScriptEvaluationResult::EmptyType>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::LockHistory>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::LockBackForwardList>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::MediaPlaybackState>(uint8_t value)
{
    switch (static_cast<WebKit::MediaPlaybackState>(value)) {
    case WebKit::MediaPlaybackState::NoMediaPlayback:
    case WebKit::MediaPlaybackState::MediaPlaybackPaused:
    case WebKit::MediaPlaybackState::MediaPlaybackSuspended:
    case WebKit::MediaPlaybackState::MediaPlaybackPlaying:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::SafeBrowsingCheckOngoing>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

#if PLATFORM(GTK)
template<> bool isValidEnum<WebKit::PrintInfo::PrintMode>(uint8_t value)
{
    switch (static_cast<WebKit::PrintInfo::PrintMode>(value)) {
    case WebKit::PrintInfo::PrintMode::Async:
    case WebKit::PrintInfo::PrintMode::Sync:
        return true;
    default:
        return false;
    }
}
#endif

#if USE(LIBWEBRTC)
template<> bool isValidEnum<WebKit::WebRTCNetwork::EcnMarking>(int value)
{
    switch (static_cast<WebKit::WebRTCNetwork::EcnMarking>(value)) {
    case WebKit::WebRTCNetwork::EcnMarking::kNotEct:
    case WebKit::WebRTCNetwork::EcnMarking::kEct1:
    case WebKit::WebRTCNetwork::EcnMarking::kEct0:
    case WebKit::WebRTCNetwork::EcnMarking::kCe:
        return true;
    default:
        return false;
    }
}
#endif

#if (USE(LIBWEBRTC)) && (USE(LIBWEBRTC) && PLATFORM(COCOA))
template<> bool isValidEnum<webrtc::WebKitEncodedVideoRotation>(uint8_t value)
{
    switch (static_cast<webrtc::WebKitEncodedVideoRotation>(value)) {
    case webrtc::WebKitEncodedVideoRotation::kVideoRotation_0:
    case webrtc::WebKitEncodedVideoRotation::kVideoRotation_90:
    case webrtc::WebKitEncodedVideoRotation::kVideoRotation_180:
    case webrtc::WebKitEncodedVideoRotation::kVideoRotation_270:
        return true;
    default:
        return false;
    }
}
#endif

#if (USE(LIBWEBRTC)) && (USE(LIBWEBRTC) && PLATFORM(COCOA))
template<> bool isValidEnum<webrtc::VideoFrameType>(int value)
{
    switch (static_cast<webrtc::VideoFrameType>(value)) {
    case webrtc::VideoFrameType::kEmptyFrame:
    case webrtc::VideoFrameType::kVideoFrameKey:
    case webrtc::VideoFrameType::kVideoFrameDelta:
        return true;
    default:
        return false;
    }
}
#endif

#if (USE(LIBWEBRTC)) && (USE(LIBWEBRTC) && PLATFORM(COCOA))
template<> bool isValidEnum<webrtc::VideoContentType>(uint8_t value)
{
    switch (static_cast<webrtc::VideoContentType>(value)) {
    case webrtc::VideoContentType::UNSPECIFIED:
    case webrtc::VideoContentType::SCREENSHARE:
        return true;
    default:
        return false;
    }
}
#endif

#if USE(LIBWEBRTC)
template<> bool isValidEnum<WebKit::RTCPacketOptions::DifferentiatedServicesCodePoint>(int8_t value)
{
    switch (static_cast<WebKit::RTCPacketOptions::DifferentiatedServicesCodePoint>(value)) {
    case WebKit::RTCPacketOptions::DifferentiatedServicesCodePoint::NoChange:
    case WebKit::RTCPacketOptions::DifferentiatedServicesCodePoint::CS0:
    case WebKit::RTCPacketOptions::DifferentiatedServicesCodePoint::CS1:
    case WebKit::RTCPacketOptions::DifferentiatedServicesCodePoint::AF11:
    case WebKit::RTCPacketOptions::DifferentiatedServicesCodePoint::AF12:
    case WebKit::RTCPacketOptions::DifferentiatedServicesCodePoint::AF13:
    case WebKit::RTCPacketOptions::DifferentiatedServicesCodePoint::CS2:
    case WebKit::RTCPacketOptions::DifferentiatedServicesCodePoint::AF21:
    case WebKit::RTCPacketOptions::DifferentiatedServicesCodePoint::AF22:
    case WebKit::RTCPacketOptions::DifferentiatedServicesCodePoint::AF23:
    case WebKit::RTCPacketOptions::DifferentiatedServicesCodePoint::CS3:
    case WebKit::RTCPacketOptions::DifferentiatedServicesCodePoint::AF31:
    case WebKit::RTCPacketOptions::DifferentiatedServicesCodePoint::AF32:
    case WebKit::RTCPacketOptions::DifferentiatedServicesCodePoint::AF33:
    case WebKit::RTCPacketOptions::DifferentiatedServicesCodePoint::CS4:
    case WebKit::RTCPacketOptions::DifferentiatedServicesCodePoint::AF41:
    case WebKit::RTCPacketOptions::DifferentiatedServicesCodePoint::AF42:
    case WebKit::RTCPacketOptions::DifferentiatedServicesCodePoint::AF43:
    case WebKit::RTCPacketOptions::DifferentiatedServicesCodePoint::CS5:
    case WebKit::RTCPacketOptions::DifferentiatedServicesCodePoint::EF:
    case WebKit::RTCPacketOptions::DifferentiatedServicesCodePoint::CS6:
    case WebKit::RTCPacketOptions::DifferentiatedServicesCodePoint::CS7:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebKit::RemoteWorkerType>(uint8_t value)
{
    switch (static_cast<WebKit::RemoteWorkerType>(value)) {
    case WebKit::RemoteWorkerType::ServiceWorker:
    case WebKit::RemoteWorkerType::SharedWorker:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::ResourceLoadInfo::Type>(uint8_t value)
{
    switch (static_cast<WebKit::ResourceLoadInfo::Type>(value)) {
    case WebKit::ResourceLoadInfo::Type::ApplicationManifest:
    case WebKit::ResourceLoadInfo::Type::Beacon:
    case WebKit::ResourceLoadInfo::Type::CSPReport:
    case WebKit::ResourceLoadInfo::Type::Document:
    case WebKit::ResourceLoadInfo::Type::Fetch:
    case WebKit::ResourceLoadInfo::Type::Font:
    case WebKit::ResourceLoadInfo::Type::Image:
    case WebKit::ResourceLoadInfo::Type::Media:
    case WebKit::ResourceLoadInfo::Type::Object:
    case WebKit::ResourceLoadInfo::Type::Other:
    case WebKit::ResourceLoadInfo::Type::Ping:
    case WebKit::ResourceLoadInfo::Type::Script:
    case WebKit::ResourceLoadInfo::Type::Stylesheet:
    case WebKit::ResourceLoadInfo::Type::XMLHTTPRequest:
    case WebKit::ResourceLoadInfo::Type::XSLT:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::SameSiteStrictEnforcementEnabled>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::SameDocumentNavigationType>(uint8_t value)
{
    switch (static_cast<WebKit::SameDocumentNavigationType>(value)) {
    case WebKit::SameDocumentNavigationType::AnchorNavigation:
    case WebKit::SameDocumentNavigationType::SessionStatePush:
    case WebKit::SameDocumentNavigationType::SessionStateReplace:
    case WebKit::SameDocumentNavigationType::SessionStatePop:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ClonedDocumentType>(uint8_t value)
{
    switch (static_cast<WebCore::ClonedDocumentType>(value)) {
    case WebCore::ClonedDocumentType::XMLDocument:
    case WebCore::ClonedDocumentType::XHTMLDocument:
    case WebCore::ClonedDocumentType::HTMLDocument:
    case WebCore::ClonedDocumentType::SVGDocument:
    case WebCore::ClonedDocumentType::Document:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::SyntheticEditingCommandType>(uint8_t  value)
{
    switch (static_cast<WebKit::SyntheticEditingCommandType>(value)) {
    case WebKit::SyntheticEditingCommandType::Undo:
    case WebKit::SyntheticEditingCommandType::Redo:
    case WebKit::SyntheticEditingCommandType::ToggleBoldface:
    case WebKit::SyntheticEditingCommandType::ToggleItalic:
    case WebKit::SyntheticEditingCommandType::ToggleUnderline:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FontWidthVariant>(uint8_t value)
{
    switch (static_cast<WebCore::FontWidthVariant>(value)) {
    case WebCore::FontWidthVariant::RegularWidth:
    case WebCore::FontWidthVariant::HalfWidth:
    case WebCore::FontWidthVariant::ThirdWidth:
    case WebCore::FontWidthVariant::QuarterWidth:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::Kerning>(uint8_t value)
{
    switch (static_cast<WebCore::Kerning>(value)) {
    case WebCore::Kerning::Auto:
    case WebCore::Kerning::Normal:
    case WebCore::Kerning::NoShift:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FontOpticalSizing>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FontStyleAxis>(uint8_t value)
{
    switch (static_cast<WebCore::FontStyleAxis>(value)) {
    case WebCore::FontStyleAxis::slnt:
    case WebCore::FontStyleAxis::ital:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::AllowUserInstalledFonts>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FontVariantEastAsianVariant>(uint8_t value)
{
    switch (static_cast<WebCore::FontVariantEastAsianVariant>(value)) {
    case WebCore::FontVariantEastAsianVariant::Normal:
    case WebCore::FontVariantEastAsianVariant::Jis78:
    case WebCore::FontVariantEastAsianVariant::Jis83:
    case WebCore::FontVariantEastAsianVariant::Jis90:
    case WebCore::FontVariantEastAsianVariant::Jis04:
    case WebCore::FontVariantEastAsianVariant::Simplified:
    case WebCore::FontVariantEastAsianVariant::Traditional:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FontVariantEastAsianWidth>(uint8_t value)
{
    switch (static_cast<WebCore::FontVariantEastAsianWidth>(value)) {
    case WebCore::FontVariantEastAsianWidth::Normal:
    case WebCore::FontVariantEastAsianWidth::Full:
    case WebCore::FontVariantEastAsianWidth::Proportional:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FontVariantEastAsianRuby>(uint8_t value)
{
    switch (static_cast<WebCore::FontVariantEastAsianRuby>(value)) {
    case WebCore::FontVariantEastAsianRuby::Normal:
    case WebCore::FontVariantEastAsianRuby::Yes:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FontVariantLigatures>(uint8_t value)
{
    switch (static_cast<WebCore::FontVariantLigatures>(value)) {
    case WebCore::FontVariantLigatures::Normal:
    case WebCore::FontVariantLigatures::Yes:
    case WebCore::FontVariantLigatures::No:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FontVariantPosition>(uint8_t value)
{
    switch (static_cast<WebCore::FontVariantPosition>(value)) {
    case WebCore::FontVariantPosition::Normal:
    case WebCore::FontVariantPosition::Subscript:
    case WebCore::FontVariantPosition::Superscript:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FontVariantCaps>(uint8_t value)
{
    switch (static_cast<WebCore::FontVariantCaps>(value)) {
    case WebCore::FontVariantCaps::Normal:
    case WebCore::FontVariantCaps::Small:
    case WebCore::FontVariantCaps::AllSmall:
    case WebCore::FontVariantCaps::Petite:
    case WebCore::FontVariantCaps::AllPetite:
    case WebCore::FontVariantCaps::Unicase:
    case WebCore::FontVariantCaps::Titling:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FontVariantNumericFigure>(uint8_t value)
{
    switch (static_cast<WebCore::FontVariantNumericFigure>(value)) {
    case WebCore::FontVariantNumericFigure::Normal:
    case WebCore::FontVariantNumericFigure::LiningNumbers:
    case WebCore::FontVariantNumericFigure::OldStyleNumbers:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FontVariantNumericSpacing>(uint8_t value)
{
    switch (static_cast<WebCore::FontVariantNumericSpacing>(value)) {
    case WebCore::FontVariantNumericSpacing::Normal:
    case WebCore::FontVariantNumericSpacing::ProportionalNumbers:
    case WebCore::FontVariantNumericSpacing::TabularNumbers:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FontVariantNumericFraction>(uint8_t value)
{
    switch (static_cast<WebCore::FontVariantNumericFraction>(value)) {
    case WebCore::FontVariantNumericFraction::Normal:
    case WebCore::FontVariantNumericFraction::DiagonalFractions:
    case WebCore::FontVariantNumericFraction::StackedFractions:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::TextRenderingMode>(uint8_t value)
{
    switch (static_cast<WebCore::TextRenderingMode>(value)) {
    case WebCore::TextRenderingMode::AutoTextRendering:
    case WebCore::TextRenderingMode::OptimizeSpeed:
    case WebCore::TextRenderingMode::OptimizeLegibility:
    case WebCore::TextRenderingMode::GeometricPrecision:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FontSmoothingMode>(uint8_t value)
{
    switch (static_cast<WebCore::FontSmoothingMode>(value)) {
    case WebCore::FontSmoothingMode::AutoSmoothing:
    case WebCore::FontSmoothingMode::NoSmoothing:
    case WebCore::FontSmoothingMode::Antialiased:
    case WebCore::FontSmoothingMode::SubpixelAntialiased:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebKit::TextCheckerState>(OptionSet<WebKit::TextCheckerState> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebKit::TextCheckerState::ContinuousSpellCheckingEnabled)
        | static_cast<uint8_t>(WebKit::TextCheckerState::GrammarCheckingEnabled)
#if USE(APPKIT)
        | static_cast<uint8_t>(WebKit::TextCheckerState::AutomaticTextReplacementEnabled)
#endif
#if USE(APPKIT)
        | static_cast<uint8_t>(WebKit::TextCheckerState::AutomaticSpellingCorrectionEnabled)
#endif
#if USE(APPKIT)
        | static_cast<uint8_t>(WebKit::TextCheckerState::AutomaticQuoteSubstitutionEnabled)
#endif
#if USE(APPKIT)
        | static_cast<uint8_t>(WebKit::TextCheckerState::AutomaticDashSubstitutionEnabled)
#endif
#if USE(APPKIT)
        | static_cast<uint8_t>(WebKit::TextCheckerState::AutomaticLinkDetectionEnabled)
#endif
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidEnum<WebCore::FontOrientation>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::NonCJKGlyphOrientation>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FontVariantNumericOrdinal>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FontVariantNumericSlashedZero>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FontSynthesisLonghandValue>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FontSmallCaps>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

#if ENABLE(IMAGE_ANALYSIS)
template<> bool isValidEnum<WebKit::TextRecognitionUpdateResult>(uint8_t value)
{
    switch (static_cast<WebKit::TextRecognitionUpdateResult>(value)) {
    case WebKit::TextRecognitionUpdateResult::NoText:
    case WebKit::TextRecognitionUpdateResult::Text:
    case WebKit::TextRecognitionUpdateResult::DataDetector:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebKit::UndoOrRedo>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

#if ENABLE(UI_SIDE_COMPOSITING)
template<> bool isValidOptionSet<WebKit::ViewStabilityFlag>(OptionSet<WebKit::ViewStabilityFlag> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebKit::ViewStabilityFlag::ScrollViewInteracting)
        | static_cast<uint8_t>(WebKit::ViewStabilityFlag::ScrollViewAnimatedScrollOrZoom)
        | static_cast<uint8_t>(WebKit::ViewStabilityFlag::ScrollViewRubberBanding)
        | static_cast<uint8_t>(WebKit::ViewStabilityFlag::ChangingObscuredInsetsInteractively)
        | static_cast<uint8_t>(WebKit::ViewStabilityFlag::UnstableForTesting)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}
#endif

template<> bool isValidEnum<WTF::SystemMemoryPressureStatus>(uint8_t value)
{
    switch (static_cast<WTF::SystemMemoryPressureStatus>(value)) {
    case WTF::SystemMemoryPressureStatus::Normal:
    case WTF::SystemMemoryPressureStatus::Warning:
    case WTF::SystemMemoryPressureStatus::Critical:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WTFLogLevel>(uint8_t value)
{
    switch (static_cast<WTFLogLevel>(value)) {
    case WTFLogLevel::Always:
    case WTFLogLevel::Error:
    case WTFLogLevel::Warning:
    case WTFLogLevel::Info:
    case WTFLogLevel::Debug:
        return true;
    default:
        return false;
    }
}

#if ENABLE(APPLE_PAY)
template<> bool isValidEnum<WebCore::ApplePayFeature>(uint8_t value)
{
    switch (static_cast<WebCore::ApplePayFeature>(value)) {
#if ENABLE(APPLE_PAY_LATER)
    case WebCore::ApplePayFeature::ApplePayLater:
#endif
#if ENABLE(APPLE_PAY_LATER_AVAILABILITY)
    case WebCore::ApplePayFeature::ApplePayLaterAvailability:
#endif
#if ENABLE(APPLE_PAY_PAYMENT_ORDER_DETAILS)
    case WebCore::ApplePayFeature::AuthorizationResultOrderDetails:
#endif
    case WebCore::ApplePayFeature::LineItemPaymentTiming:
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_PAYMENTS)
    case WebCore::ApplePayFeature::PaymentRequestAutomaticReload:
#endif
#if ENABLE(APPLE_PAY_COUPON_CODE)
    case WebCore::ApplePayFeature::PaymentRequestCouponCode:
#endif
#if ENABLE(APPLE_PAY_MERCHANT_CATEGORY_CODE)
    case WebCore::ApplePayFeature::PaymentRequestMerchantCategoryCode:
#endif
#if ENABLE(APPLE_PAY_MULTI_MERCHANT_PAYMENTS)
    case WebCore::ApplePayFeature::PaymentRequestMultiTokenContexts:
#endif
#if ENABLE(APPLE_PAY_RECURRING_PAYMENTS)
    case WebCore::ApplePayFeature::PaymentRequestRecurring:
#endif
#if ENABLE(APPLE_PAY_SHIPPING_CONTACT_EDITING_MODE)
    case WebCore::ApplePayFeature::PaymentRequestShippingContactEditingMode:
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_LINE_ITEM)
    case WebCore::ApplePayFeature::PaymentTimingAutomaticReload:
#endif
#if ENABLE(APPLE_PAY_DEFERRED_PAYMENTS)
    case WebCore::ApplePayFeature::PaymentRequestDeferred:
#endif
#if ENABLE(APPLE_PAY_DEFERRED_LINE_ITEM)
    case WebCore::ApplePayFeature::PaymentTimingDeferred:
#endif
    case WebCore::ApplePayFeature::PaymentTimingImmediate:
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
    case WebCore::ApplePayFeature::PaymentTimingRecurring:
#endif
#if ENABLE(APPLE_PAY_SHIPPING_CONTACT_EDITING_MODE)
    case WebCore::ApplePayFeature::ShippingContactEditingModeEnabled:
#endif
#if ENABLE(APPLE_PAY_SHIPPING_CONTACT_EDITING_MODE)
    case WebCore::ApplePayFeature::ShippingContactEditingModeStorePickup:
#endif
#if ENABLE(APPLE_PAY_SHIPPING_METHOD_DATE_COMPONENTS_RANGE)
    case WebCore::ApplePayFeature::ShippingMethodDateComponentsRange:
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
    case WebCore::ApplePayFeature::PaymentRequestDisbursements:
#endif
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(APPLE_PAY)
template<> bool isValidEnum<WebCore::ApplePayPaymentTiming>(uint8_t value)
{
    switch (static_cast<WebCore::ApplePayPaymentTiming>(value)) {
    case WebCore::ApplePayPaymentTiming::Immediate:
#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
    case WebCore::ApplePayPaymentTiming::Recurring:
#endif
#if ENABLE(APPLE_PAY_DEFERRED_LINE_ITEM)
    case WebCore::ApplePayPaymentTiming::Deferred:
#endif
#if ENABLE(APPLE_PAY_AUTOMATIC_RELOAD_LINE_ITEM)
    case WebCore::ApplePayPaymentTiming::AutomaticReload:
#endif
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(APPLE_PAY_RECURRING_LINE_ITEM)
template<> bool isValidEnum<WebCore::ApplePayRecurringPaymentDateUnit>(uint8_t value)
{
    switch (static_cast<WebCore::ApplePayRecurringPaymentDateUnit>(value)) {
    case WebCore::ApplePayRecurringPaymentDateUnit::Year:
    case WebCore::ApplePayRecurringPaymentDateUnit::Month:
    case WebCore::ApplePayRecurringPaymentDateUnit::Day:
    case WebCore::ApplePayRecurringPaymentDateUnit::Hour:
    case WebCore::ApplePayRecurringPaymentDateUnit::Minute:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::ContactProperty>(uint8_t value)
{
    switch (static_cast<WebCore::ContactProperty>(value)) {
    case WebCore::ContactProperty::Email:
    case WebCore::ContactProperty::Name:
    case WebCore::ContactProperty::Tel:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::CookieConsentDecisionResult>(uint8_t value)
{
    switch (static_cast<WebCore::CookieConsentDecisionResult>(value)) {
    case WebCore::CookieConsentDecisionResult::NotSupported:
    case WebCore::CookieConsentDecisionResult::Consent:
    case WebCore::CookieConsentDecisionResult::Dissent:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::IDBResultType>(uint8_t value)
{
    switch (static_cast<WebCore::IDBResultType>(value)) {
    case WebCore::IDBResultType::Error:
    case WebCore::IDBResultType::OpenDatabaseSuccess:
    case WebCore::IDBResultType::OpenDatabaseUpgradeNeeded:
    case WebCore::IDBResultType::DeleteDatabaseSuccess:
    case WebCore::IDBResultType::CreateObjectStoreSuccess:
    case WebCore::IDBResultType::DeleteObjectStoreSuccess:
    case WebCore::IDBResultType::ClearObjectStoreSuccess:
    case WebCore::IDBResultType::PutOrAddSuccess:
    case WebCore::IDBResultType::GetRecordSuccess:
    case WebCore::IDBResultType::GetAllRecordsSuccess:
    case WebCore::IDBResultType::GetCountSuccess:
    case WebCore::IDBResultType::DeleteRecordSuccess:
    case WebCore::IDBResultType::CreateIndexSuccess:
    case WebCore::IDBResultType::DeleteIndexSuccess:
    case WebCore::IDBResultType::OpenCursorSuccess:
    case WebCore::IDBResultType::IterateCursorSuccess:
    case WebCore::IDBResultType::RenameObjectStoreSuccess:
    case WebCore::IDBResultType::RenameIndexSuccess:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::IDBTransactionDurability>(uint8_t value)
{
    switch (static_cast<WebCore::IDBTransactionDurability>(value)) {
    case WebCore::IDBTransactionDurability::Strict:
    case WebCore::IDBTransactionDurability::Relaxed:
    case WebCore::IDBTransactionDurability::Default:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::IDBTransactionMode>(uint8_t value)
{
    switch (static_cast<WebCore::IDBTransactionMode>(value)) {
    case WebCore::IDBTransactionMode::Readonly:
    case WebCore::IDBTransactionMode::Readwrite:
    case WebCore::IDBTransactionMode::Versionchange:
        return true;
    default:
        return false;
    }
}

#if ENABLE(MEDIA_SESSION)
template<> bool isValidEnum<WebCore::MediaSessionAction>(uint8_t value)
{
    switch (static_cast<WebCore::MediaSessionAction>(value)) {
    case WebCore::MediaSessionAction::Play:
    case WebCore::MediaSessionAction::Pause:
    case WebCore::MediaSessionAction::Seekbackward:
    case WebCore::MediaSessionAction::Seekforward:
    case WebCore::MediaSessionAction::Previoustrack:
    case WebCore::MediaSessionAction::Nexttrack:
    case WebCore::MediaSessionAction::Skipad:
    case WebCore::MediaSessionAction::Stop:
    case WebCore::MediaSessionAction::Seekto:
    case WebCore::MediaSessionAction::Settrack:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(MEDIA_SESSION)
template<> bool isValidEnum<WebCore::MediaSessionPlaybackState>(uint8_t value)
{
    switch (static_cast<WebCore::MediaSessionPlaybackState>(value)) {
    case WebCore::MediaSessionPlaybackState::None:
    case WebCore::MediaSessionPlaybackState::Paused:
    case WebCore::MediaSessionPlaybackState::Playing:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(MEDIA_SESSION_COORDINATOR)
template<> bool isValidEnum<WebCore::MediaSessionCoordinatorState>(uint8_t value)
{
    switch (static_cast<WebCore::MediaSessionCoordinatorState>(value)) {
    case WebCore::MediaSessionCoordinatorState::Waiting:
    case WebCore::MediaSessionCoordinatorState::Joined:
    case WebCore::MediaSessionCoordinatorState::Closed:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(MEDIA_SESSION_COORDINATOR)
template<> bool isValidEnum<WebCore::MediaSessionReadyState>(uint8_t value)
{
    switch (static_cast<WebCore::MediaSessionReadyState>(value)) {
    case WebCore::MediaSessionReadyState::Havenothing:
    case WebCore::MediaSessionReadyState::Havemetadata:
    case WebCore::MediaSessionReadyState::Havecurrentdata:
    case WebCore::MediaSessionReadyState::Havefuturedata:
    case WebCore::MediaSessionReadyState::Haveenoughdata:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::RTCErrorDetailType>(uint8_t value)
{
    switch (static_cast<WebCore::RTCErrorDetailType>(value)) {
    case WebCore::RTCErrorDetailType::DataChannelFailure:
    case WebCore::RTCErrorDetailType::DtlsFailure:
    case WebCore::RTCErrorDetailType::FingerprintFailure:
    case WebCore::RTCErrorDetailType::SctpFailure:
    case WebCore::RTCErrorDetailType::SdpSyntaxError:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::NotificationEventType>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::PermissionName>(uint8_t value)
{
    switch (static_cast<WebCore::PermissionName>(value)) {
    case WebCore::PermissionName::Accelerometer:
    case WebCore::PermissionName::BackgroundFetch:
    case WebCore::PermissionName::Bluetooth:
    case WebCore::PermissionName::Camera:
    case WebCore::PermissionName::DisplayCapture:
    case WebCore::PermissionName::Geolocation:
    case WebCore::PermissionName::Gyroscope:
    case WebCore::PermissionName::Magnetometer:
    case WebCore::PermissionName::Microphone:
    case WebCore::PermissionName::Midi:
    case WebCore::PermissionName::Nfc:
    case WebCore::PermissionName::Notifications:
    case WebCore::PermissionName::Push:
    case WebCore::PermissionName::ScreenWakeLock:
    case WebCore::PermissionName::SpeakerSelection:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::PermissionQuerySource>(uint8_t value)
{
    switch (static_cast<WebCore::PermissionQuerySource>(value)) {
    case WebCore::PermissionQuerySource::Window:
    case WebCore::PermissionQuerySource::DedicatedWorker:
    case WebCore::PermissionQuerySource::SharedWorker:
    case WebCore::PermissionQuerySource::ServiceWorker:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::PermissionState>(uint8_t value)
{
    switch (static_cast<WebCore::PermissionState>(value)) {
    case WebCore::PermissionState::Granted:
    case WebCore::PermissionState::Denied:
    case WebCore::PermissionState::Prompt:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::PushPermissionState>(uint8_t value)
{
    switch (static_cast<WebCore::PushPermissionState>(value)) {
    case WebCore::PushPermissionState::Denied:
    case WebCore::PushPermissionState::Granted:
    case WebCore::PushPermissionState::Prompt:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::AutofillFieldName>(uint8_t value)
{
    switch (static_cast<WebCore::AutofillFieldName>(value)) {
    case WebCore::AutofillFieldName::None:
    case WebCore::AutofillFieldName::Name:
    case WebCore::AutofillFieldName::HonorificPrefix:
    case WebCore::AutofillFieldName::GivenName:
    case WebCore::AutofillFieldName::AdditionalName:
    case WebCore::AutofillFieldName::FamilyName:
    case WebCore::AutofillFieldName::HonorificSuffix:
    case WebCore::AutofillFieldName::Nickname:
    case WebCore::AutofillFieldName::Username:
    case WebCore::AutofillFieldName::NewPassword:
    case WebCore::AutofillFieldName::CurrentPassword:
    case WebCore::AutofillFieldName::OrganizationTitle:
    case WebCore::AutofillFieldName::Organization:
    case WebCore::AutofillFieldName::StreetAddress:
    case WebCore::AutofillFieldName::AddressLine1:
    case WebCore::AutofillFieldName::AddressLine2:
    case WebCore::AutofillFieldName::AddressLine3:
    case WebCore::AutofillFieldName::AddressLevel4:
    case WebCore::AutofillFieldName::AddressLevel3:
    case WebCore::AutofillFieldName::AddressLevel2:
    case WebCore::AutofillFieldName::AddressLevel1:
    case WebCore::AutofillFieldName::Country:
    case WebCore::AutofillFieldName::CountryName:
    case WebCore::AutofillFieldName::PostalCode:
    case WebCore::AutofillFieldName::CcName:
    case WebCore::AutofillFieldName::CcGivenName:
    case WebCore::AutofillFieldName::CcAdditionalName:
    case WebCore::AutofillFieldName::CcFamilyName:
    case WebCore::AutofillFieldName::CcNumber:
    case WebCore::AutofillFieldName::CcExp:
    case WebCore::AutofillFieldName::CcExpMonth:
    case WebCore::AutofillFieldName::CcExpYear:
    case WebCore::AutofillFieldName::CcCsc:
    case WebCore::AutofillFieldName::CcType:
    case WebCore::AutofillFieldName::TransactionCurrency:
    case WebCore::AutofillFieldName::TransactionAmount:
    case WebCore::AutofillFieldName::Language:
    case WebCore::AutofillFieldName::Bday:
    case WebCore::AutofillFieldName::BdayDay:
    case WebCore::AutofillFieldName::BdayMonth:
    case WebCore::AutofillFieldName::BdayYear:
    case WebCore::AutofillFieldName::Sex:
    case WebCore::AutofillFieldName::URL:
    case WebCore::AutofillFieldName::Photo:
    case WebCore::AutofillFieldName::Tel:
    case WebCore::AutofillFieldName::TelCountryCode:
    case WebCore::AutofillFieldName::TelNational:
    case WebCore::AutofillFieldName::TelAreaCode:
    case WebCore::AutofillFieldName::TelLocal:
    case WebCore::AutofillFieldName::TelLocalPrefix:
    case WebCore::AutofillFieldName::TelLocalSuffix:
    case WebCore::AutofillFieldName::TelExtension:
    case WebCore::AutofillFieldName::Email:
    case WebCore::AutofillFieldName::Impp:
    case WebCore::AutofillFieldName::WebAuthn:
    case WebCore::AutofillFieldName::OneTimeCode:
    case WebCore::AutofillFieldName::DeviceEID:
    case WebCore::AutofillFieldName::DeviceIMEI:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::NonAutofillCredentialType>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::EnterKeyHint>(uint8_t value)
{
    switch (static_cast<WebCore::EnterKeyHint>(value)) {
    case WebCore::EnterKeyHint::Unspecified:
    case WebCore::EnterKeyHint::Enter:
    case WebCore::EnterKeyHint::Done:
    case WebCore::EnterKeyHint::Go:
    case WebCore::EnterKeyHint::Next:
    case WebCore::EnterKeyHint::Previous:
    case WebCore::EnterKeyHint::Search:
    case WebCore::EnterKeyHint::Send:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::DownloadableBinaryFontTrustedTypes>(uint8_t value)
{
    switch (static_cast<WebCore::DownloadableBinaryFontTrustedTypes>(value)) {
    case WebCore::DownloadableBinaryFontTrustedTypes::Any:
    case WebCore::DownloadableBinaryFontTrustedTypes::Restricted:
    case WebCore::DownloadableBinaryFontTrustedTypes::None:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::LoadSchedulingMode>(uint8_t value)
{
    switch (static_cast<WebCore::LoadSchedulingMode>(value)) {
    case WebCore::LoadSchedulingMode::Direct:
    case WebCore::LoadSchedulingMode::Prioritized:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ServiceWorkersMode>(uint8_t value)
{
    switch (static_cast<WebCore::ServiceWorkersMode>(value)) {
    case WebCore::ServiceWorkersMode::All:
    case WebCore::ServiceWorkersMode::None:
    case WebCore::ServiceWorkersMode::Only:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ShouldTreatAsContinuingLoad>(uint8_t value)
{
    switch (static_cast<WebCore::ShouldTreatAsContinuingLoad>(value)) {
    case WebCore::ShouldTreatAsContinuingLoad::No:
    case WebCore::ShouldTreatAsContinuingLoad::YesAfterNavigationPolicyDecision:
    case WebCore::ShouldTreatAsContinuingLoad::YesAfterProvisionalLoadStarted:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ContentSecurityPolicyModeForExtension>(uint8_t value)
{
    switch (static_cast<WebCore::ContentSecurityPolicyModeForExtension>(value)) {
    case WebCore::ContentSecurityPolicyModeForExtension::None:
    case WebCore::ContentSecurityPolicyModeForExtension::ManifestV2:
    case WebCore::ContentSecurityPolicyModeForExtension::ManifestV3:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::MediaProducerMediaCaptureKind>(uint8_t value)
{
    switch (static_cast<WebCore::MediaProducerMediaCaptureKind>(value)) {
    case WebCore::MediaProducerMediaCaptureKind::Microphone:
    case WebCore::MediaProducerMediaCaptureKind::Camera:
    case WebCore::MediaProducerMediaCaptureKind::Display:
    case WebCore::MediaProducerMediaCaptureKind::SystemAudio:
    case WebCore::MediaProducerMediaCaptureKind::EveryKind:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ScreenOrientationType>(uint8_t value)
{
    switch (static_cast<WebCore::ScreenOrientationType>(value)) {
    case WebCore::ScreenOrientationType::PortraitPrimary:
    case WebCore::ScreenOrientationType::PortraitSecondary:
    case WebCore::ScreenOrientationType::LandscapePrimary:
    case WebCore::ScreenOrientationType::LandscapeSecondary:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::StorageBlockingPolicy>(uint8_t value)
{
    switch (static_cast<WebCore::StorageBlockingPolicy>(value)) {
    case WebCore::StorageBlockingPolicy::AllowAll:
    case WebCore::StorageBlockingPolicy::BlockThirdParty:
    case WebCore::StorageBlockingPolicy::BlockAll:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::HTTPSByDefaultMode>(uint8_t value)
{
    switch (static_cast<WebCore::HTTPSByDefaultMode>(value)) {
    case WebCore::HTTPSByDefaultMode::Disabled:
    case WebCore::HTTPSByDefaultMode::UpgradeWithAutomaticFallback:
    case WebCore::HTTPSByDefaultMode::UpgradeWithUserMediatedFallback:
    case WebCore::HTTPSByDefaultMode::UpgradeAndNoFallback:
        return true;
    default:
        return false;
    }
}

#if HAVE(TRANSLATION_UI_SERVICES) && ENABLE(CONTEXT_MENUS)
template<> bool isValidEnum<WebCore::TranslationContextMenuMode>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if HAVE(TRANSLATION_UI_SERVICES) && ENABLE(CONTEXT_MENUS)
template<> bool isValidEnum<WebCore::TranslationContextMenuSource>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if USE(APPKIT)
template<> bool isValidEnum<WebCore::AppKitControlSystemImageType>(uint8_t value)
{
    switch (static_cast<WebCore::AppKitControlSystemImageType>(value)) {
    case WebCore::AppKitControlSystemImageType::ScrollbarTrackCorner:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::ScrollIsAnimated>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ScrollGranularity>(uint8_t value)
{
    switch (static_cast<WebCore::ScrollGranularity>(value)) {
    case WebCore::ScrollGranularity::Line:
    case WebCore::ScrollGranularity::Page:
    case WebCore::ScrollGranularity::Document:
    case WebCore::ScrollGranularity::Pixel:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::IDBGetRecordDataType>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::IndexedDB::KeyType>(int8_t value)
{
    switch (static_cast<WebCore::IndexedDB::KeyType>(value)) {
    case WebCore::IndexedDB::KeyType::Max:
    case WebCore::IndexedDB::KeyType::Invalid:
    case WebCore::IndexedDB::KeyType::Array:
    case WebCore::IndexedDB::KeyType::Binary:
    case WebCore::IndexedDB::KeyType::String:
    case WebCore::IndexedDB::KeyType::Date:
    case WebCore::IndexedDB::KeyType::Number:
    case WebCore::IndexedDB::KeyType::Min:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::IndexedDB::CursorDirection>(uint8_t value)
{
    switch (static_cast<WebCore::IndexedDB::CursorDirection>(value)) {
    case WebCore::IndexedDB::CursorDirection::Next:
    case WebCore::IndexedDB::CursorDirection::Nextunique:
    case WebCore::IndexedDB::CursorDirection::Prev:
    case WebCore::IndexedDB::CursorDirection::Prevunique:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::IndexedDB::ObjectStoreOverwriteMode>(uint8_t value)
{
    switch (static_cast<WebCore::IndexedDB::ObjectStoreOverwriteMode>(value)) {
    case WebCore::IndexedDB::ObjectStoreOverwriteMode::Overwrite:
    case WebCore::IndexedDB::ObjectStoreOverwriteMode::OverwriteForCursor:
    case WebCore::IndexedDB::ObjectStoreOverwriteMode::NoOverwrite:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::IndexedDB::RequestType>(uint8_t value)
{
    switch (static_cast<WebCore::IndexedDB::RequestType>(value)) {
    case WebCore::IndexedDB::RequestType::Open:
    case WebCore::IndexedDB::RequestType::Delete:
    case WebCore::IndexedDB::RequestType::Other:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::CubicBezierTimingFunction::TimingFunctionPreset>(uint8_t value)
{
    switch (static_cast<WebCore::CubicBezierTimingFunction::TimingFunctionPreset>(value)) {
    case WebCore::CubicBezierTimingFunction::TimingFunctionPreset::Ease:
    case WebCore::CubicBezierTimingFunction::TimingFunctionPreset::EaseIn:
    case WebCore::CubicBezierTimingFunction::TimingFunctionPreset::EaseOut:
    case WebCore::CubicBezierTimingFunction::TimingFunctionPreset::EaseInOut:
    case WebCore::CubicBezierTimingFunction::TimingFunctionPreset::Custom:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::StepsTimingFunction::StepPosition>(uint8_t value)
{
    switch (static_cast<WebCore::StepsTimingFunction::StepPosition>(value)) {
    case WebCore::StepsTimingFunction::StepPosition::JumpStart:
    case WebCore::StepsTimingFunction::StepPosition::JumpEnd:
    case WebCore::StepsTimingFunction::StepPosition::JumpNone:
    case WebCore::StepsTimingFunction::StepPosition::JumpBoth:
    case WebCore::StepsTimingFunction::StepPosition::Start:
    case WebCore::StepsTimingFunction::StepPosition::End:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebCore::NavigatorAPIsAccessed>(OptionSet<WebCore::NavigatorAPIsAccessed> value)
{
    constexpr uint64_t allValidBitsValue = 0
        | static_cast<uint64_t>(WebCore::NavigatorAPIsAccessed::AppVersion)
        | static_cast<uint64_t>(WebCore::NavigatorAPIsAccessed::UserAgent)
        | static_cast<uint64_t>(WebCore::NavigatorAPIsAccessed::Plugins)
        | static_cast<uint64_t>(WebCore::NavigatorAPIsAccessed::MimeTypes)
        | static_cast<uint64_t>(WebCore::NavigatorAPIsAccessed::CookieEnabled)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidOptionSet<WebCore::ScreenAPIsAccessed>(OptionSet<WebCore::ScreenAPIsAccessed> value)
{
    constexpr uint64_t allValidBitsValue = 0
        | static_cast<uint64_t>(WebCore::ScreenAPIsAccessed::Height)
        | static_cast<uint64_t>(WebCore::ScreenAPIsAccessed::Width)
        | static_cast<uint64_t>(WebCore::ScreenAPIsAccessed::ColorDepth)
        | static_cast<uint64_t>(WebCore::ScreenAPIsAccessed::AvailLeft)
        | static_cast<uint64_t>(WebCore::ScreenAPIsAccessed::AvailTop)
        | static_cast<uint64_t>(WebCore::ScreenAPIsAccessed::AvailHeight)
        | static_cast<uint64_t>(WebCore::ScreenAPIsAccessed::AvailWidth)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidOptionSet<WebCore::SandboxFlag>(OptionSet<WebCore::SandboxFlag> value)
{
    constexpr uint16_t allValidBitsValue = 0
        | static_cast<uint16_t>(WebCore::SandboxFlag::Navigation)
        | static_cast<uint16_t>(WebCore::SandboxFlag::Plugins)
        | static_cast<uint16_t>(WebCore::SandboxFlag::Origin)
        | static_cast<uint16_t>(WebCore::SandboxFlag::Forms)
        | static_cast<uint16_t>(WebCore::SandboxFlag::Scripts)
        | static_cast<uint16_t>(WebCore::SandboxFlag::TopNavigation)
        | static_cast<uint16_t>(WebCore::SandboxFlag::Popups)
        | static_cast<uint16_t>(WebCore::SandboxFlag::AutomaticFeatures)
        | static_cast<uint16_t>(WebCore::SandboxFlag::PointerLock)
        | static_cast<uint16_t>(WebCore::SandboxFlag::PropagatesToAuxiliaryBrowsingContexts)
        | static_cast<uint16_t>(WebCore::SandboxFlag::TopNavigationByUserActivation)
        | static_cast<uint16_t>(WebCore::SandboxFlag::DocumentDomain)
        | static_cast<uint16_t>(WebCore::SandboxFlag::Modals)
        | static_cast<uint16_t>(WebCore::SandboxFlag::StorageAccessByUserActivation)
        | static_cast<uint16_t>(WebCore::SandboxFlag::TopNavigationToCustomProtocols)
        | static_cast<uint16_t>(WebCore::SandboxFlag::Downloads)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidEnum<WebCore::ViewportFit>(uint8_t value)
{
    switch (static_cast<WebCore::ViewportFit>(value)) {
    case WebCore::ViewportFit::Auto:
    case WebCore::ViewportFit::Contain:
    case WebCore::ViewportFit::Cover:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ShareDataOriginator>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::PositionType>(uint8_t value)
{
    switch (static_cast<WebCore::PositionType>(value)) {
    case WebCore::PositionType::Static:
    case WebCore::PositionType::Relative:
    case WebCore::PositionType::Absolute:
    case WebCore::PositionType::Sticky:
    case WebCore::PositionType::Fixed:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::PCM::AttributionEphemeral>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::PCM::WasSent>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

#if ENABLE(APPLE_PAY)
template<> bool isValidEnum<WebCore::ApplePayLineItem::Type>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if (ENABLE(APPLE_PAY)) && (ENABLE(APPLE_PAY_DISBURSEMENTS))
template<> bool isValidEnum<WebCore::ApplePayLineItem::DisbursementLineItemType>(uint8_t value)
{
    switch (static_cast<WebCore::ApplePayLineItem::DisbursementLineItemType>(value)) {
    case WebCore::ApplePayLineItem::DisbursementLineItemType::Disbursement:
    case WebCore::ApplePayLineItem::DisbursementLineItemType::InstantFundsOutFee:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(APPLE_PAY)
template<> bool isValidEnum<WebCore::ApplePayError::Domain>(uint8_t value)
{
    switch (static_cast<WebCore::ApplePayError::Domain>(value)) {
    case WebCore::ApplePayError::Domain::Disbursement:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(APPLE_PAY)
template<> bool isValidEnum<WebCore::ApplePayLogoStyle>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(APPLE_PAY)
template<> bool isValidEnum<WebCore::ApplePayErrorContactField>(uint8_t value)
{
    switch (static_cast<WebCore::ApplePayErrorContactField>(value)) {
    case WebCore::ApplePayErrorContactField::PhoneNumber:
    case WebCore::ApplePayErrorContactField::EmailAddress:
    case WebCore::ApplePayErrorContactField::Name:
    case WebCore::ApplePayErrorContactField::PhoneticName:
    case WebCore::ApplePayErrorContactField::PostalAddress:
    case WebCore::ApplePayErrorContactField::AddressLines:
    case WebCore::ApplePayErrorContactField::SubLocality:
    case WebCore::ApplePayErrorContactField::Locality:
    case WebCore::ApplePayErrorContactField::PostalCode:
    case WebCore::ApplePayErrorContactField::SubAdministrativeArea:
    case WebCore::ApplePayErrorContactField::AdministrativeArea:
    case WebCore::ApplePayErrorContactField::Country:
    case WebCore::ApplePayErrorContactField::CountryCode:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(APPLE_PAY)
template<> bool isValidEnum<WebCore::ApplePayContactField>(uint8_t value)
{
    switch (static_cast<WebCore::ApplePayContactField>(value)) {
    case WebCore::ApplePayContactField::Email:
    case WebCore::ApplePayContactField::Name:
    case WebCore::ApplePayContactField::PhoneticName:
    case WebCore::ApplePayContactField::Phone:
    case WebCore::ApplePayContactField::PostalAddress:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(APPLE_PAY)
template<> bool isValidEnum<WebCore::ApplePayErrorCode>(uint8_t value)
{
    switch (static_cast<WebCore::ApplePayErrorCode>(value)) {
    case WebCore::ApplePayErrorCode::Unknown:
    case WebCore::ApplePayErrorCode::ShippingContactInvalid:
    case WebCore::ApplePayErrorCode::BillingContactInvalid:
    case WebCore::ApplePayErrorCode::AddressUnserviceable:
#if ENABLE(APPLE_PAY_COUPON_CODE)
    case WebCore::ApplePayErrorCode::CouponCodeInvalid:
#endif
#if ENABLE(APPLE_PAY_COUPON_CODE)
    case WebCore::ApplePayErrorCode::CouponCodeExpired:
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
    case WebCore::ApplePayErrorCode::UnsupportedCard:
#endif
#if ENABLE(APPLE_PAY_DISBURSEMENTS)
    case WebCore::ApplePayErrorCode::RecipientContactInvalid:
#endif
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(APPLE_PAY_INSTALLMENTS)
template<> bool isValidEnum<WebCore::ApplePaySetupFeatureType>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(APPLE_PAY_INSTALLMENTS)
template<> bool isValidEnum<WebCore::ApplePayInstallmentItemType>(uint8_t value)
{
    switch (static_cast<WebCore::ApplePayInstallmentItemType>(value)) {
    case WebCore::ApplePayInstallmentItemType::Generic:
    case WebCore::ApplePayInstallmentItemType::Phone:
    case WebCore::ApplePayInstallmentItemType::Pad:
    case WebCore::ApplePayInstallmentItemType::Watch:
    case WebCore::ApplePayInstallmentItemType::Mac:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(APPLE_PAY_INSTALLMENTS)
template<> bool isValidEnum<WebCore::ApplePayInstallmentRetailChannel>(uint8_t value)
{
    switch (static_cast<WebCore::ApplePayInstallmentRetailChannel>(value)) {
    case WebCore::ApplePayInstallmentRetailChannel::Unknown:
    case WebCore::ApplePayInstallmentRetailChannel::App:
    case WebCore::ApplePayInstallmentRetailChannel::Web:
    case WebCore::ApplePayInstallmentRetailChannel::InStore:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::ScreenOrientationLockType>(uint8_t value)
{
    switch (static_cast<WebCore::ScreenOrientationLockType>(value)) {
    case WebCore::ScreenOrientationLockType::Any:
    case WebCore::ScreenOrientationLockType::Natural:
    case WebCore::ScreenOrientationLockType::Landscape:
    case WebCore::ScreenOrientationLockType::Portrait:
    case WebCore::ScreenOrientationLockType::PortraitPrimary:
    case WebCore::ScreenOrientationLockType::PortraitSecondary:
    case WebCore::ScreenOrientationLockType::LandscapePrimary:
    case WebCore::ScreenOrientationLockType::LandscapeSecondary:
        return true;
    default:
        return false;
    }
}

#if ENABLE(APPLICATION_MANIFEST)
template<> bool isValidEnum<WebCore::ApplicationManifest::Direction>(uint8_t value)
{
    switch (static_cast<WebCore::ApplicationManifest::Direction>(value)) {
    case WebCore::ApplicationManifest::Direction::Auto:
    case WebCore::ApplicationManifest::Direction::LTR:
    case WebCore::ApplicationManifest::Direction::RTL:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(APPLICATION_MANIFEST)
template<> bool isValidEnum<WebCore::ApplicationManifest::Display>(uint8_t value)
{
    switch (static_cast<WebCore::ApplicationManifest::Display>(value)) {
    case WebCore::ApplicationManifest::Display::Browser:
    case WebCore::ApplicationManifest::Display::MinimalUI:
    case WebCore::ApplicationManifest::Display::Standalone:
    case WebCore::ApplicationManifest::Display::Fullscreen:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(APPLICATION_MANIFEST)
template<> bool isValidOptionSet<WebCore::ApplicationManifest::Icon::Purpose>(OptionSet<WebCore::ApplicationManifest::Icon::Purpose> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebCore::ApplicationManifest::Icon::Purpose::Any)
        | static_cast<uint8_t>(WebCore::ApplicationManifest::Icon::Purpose::Monochrome)
        | static_cast<uint8_t>(WebCore::ApplicationManifest::Icon::Purpose::Maskable)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}
#endif

template<> bool isValidEnum<WebCore::DOMCacheEngine::Error>(uint8_t value)
{
    switch (static_cast<WebCore::DOMCacheEngine::Error>(value)) {
    case WebCore::DOMCacheEngine::Error::NotImplemented:
    case WebCore::DOMCacheEngine::Error::ReadDisk:
    case WebCore::DOMCacheEngine::Error::WriteDisk:
    case WebCore::DOMCacheEngine::Error::QuotaExceeded:
    case WebCore::DOMCacheEngine::Error::Internal:
    case WebCore::DOMCacheEngine::Error::Stopped:
    case WebCore::DOMCacheEngine::Error::CORP:
        return true;
    default:
        return false;
    }
}

#if ENABLE(WEB_CODECS)
template<> bool isValidEnum<WebCore::WebCodecsEncodedVideoChunkType>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WEB_CODECS)
template<> bool isValidEnum<WebCore::WebCodecsEncodedAudioChunkType>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::VideoEncoderScalabilityMode>(uint8_t value)
{
    switch (static_cast<WebCore::VideoEncoderScalabilityMode>(value)) {
    case WebCore::VideoEncoderScalabilityMode::L1T1:
    case WebCore::VideoEncoderScalabilityMode::L1T2:
    case WebCore::VideoEncoderScalabilityMode::L1T3:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::SpeechRecognitionErrorType>(uint8_t value)
{
    switch (static_cast<WebCore::SpeechRecognitionErrorType>(value)) {
    case WebCore::SpeechRecognitionErrorType::NoSpeech:
    case WebCore::SpeechRecognitionErrorType::Aborted:
    case WebCore::SpeechRecognitionErrorType::AudioCapture:
    case WebCore::SpeechRecognitionErrorType::Network:
    case WebCore::SpeechRecognitionErrorType::NotAllowed:
    case WebCore::SpeechRecognitionErrorType::ServiceNotAllowed:
    case WebCore::SpeechRecognitionErrorType::BadGrammar:
    case WebCore::SpeechRecognitionErrorType::LanguageNotSupported:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebLockMode>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

#if ENABLE(WEB_AUTHN)
template<> bool isValidEnum<WebCore::AttestationConveyancePreference>(uint8_t value)
{
    switch (static_cast<WebCore::AttestationConveyancePreference>(value)) {
    case WebCore::AttestationConveyancePreference::None:
    case WebCore::AttestationConveyancePreference::Indirect:
    case WebCore::AttestationConveyancePreference::Direct:
    case WebCore::AttestationConveyancePreference::Enterprise:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::Cookie::SameSitePolicy>(uint8_t value)
{
    switch (static_cast<WebCore::Cookie::SameSitePolicy>(value)) {
    case WebCore::Cookie::SameSitePolicy::None:
    case WebCore::Cookie::SameSitePolicy::Lax:
    case WebCore::Cookie::SameSitePolicy::Strict:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ShouldPartitionCookie>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::RenderingMode>(uint8_t value)
{
    switch (static_cast<WebCore::RenderingMode>(value)) {
    case WebCore::RenderingMode::Unaccelerated:
    case WebCore::RenderingMode::Accelerated:
    case WebCore::RenderingMode::PDFDocument:
    case WebCore::RenderingMode::DisplayList:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::RenderingPurpose>(uint8_t value)
{
    switch (static_cast<WebCore::RenderingPurpose>(value)) {
    case WebCore::RenderingPurpose::Unspecified:
    case WebCore::RenderingPurpose::Canvas:
    case WebCore::RenderingPurpose::DOM:
    case WebCore::RenderingPurpose::LayerBacking:
    case WebCore::RenderingPurpose::Snapshot:
    case WebCore::RenderingPurpose::ShareableSnapshot:
    case WebCore::RenderingPurpose::ShareableLocalSnapshot:
    case WebCore::RenderingPurpose::MediaPainting:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ContentsFormat>(uint8_t value)
{
    switch (static_cast<WebCore::ContentsFormat>(value)) {
    case WebCore::ContentsFormat::RGBA8:
#if ENABLE(PIXEL_FORMAT_RGB10)
    case WebCore::ContentsFormat::RGBA10:
#endif
#if ENABLE(PIXEL_FORMAT_RGBA16F)
    case WebCore::ContentsFormat::RGBA16F:
#endif
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::RotationDirection>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

#if ENABLE(CONTENT_FILTERING)
template<> bool isValidEnum<WebCore::MockContentFilterSettings::DecisionPoint>(uint8_t value)
{
    switch (static_cast<WebCore::MockContentFilterSettings::DecisionPoint>(value)) {
    case WebCore::MockContentFilterSettings::DecisionPoint::AfterWillSendRequest:
    case WebCore::MockContentFilterSettings::DecisionPoint::AfterRedirect:
    case WebCore::MockContentFilterSettings::DecisionPoint::AfterResponse:
    case WebCore::MockContentFilterSettings::DecisionPoint::AfterAddData:
    case WebCore::MockContentFilterSettings::DecisionPoint::AfterFinishedAddingData:
    case WebCore::MockContentFilterSettings::DecisionPoint::Never:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(CONTENT_FILTERING)
template<> bool isValidEnum<WebCore::MockContentFilterSettings::Decision>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::IsLoggedIn>(uint8_t value)
{
    switch (static_cast<WebCore::IsLoggedIn>(value)) {
    case WebCore::IsLoggedIn::LoggedOut:
    case WebCore::IsLoggedIn::LoggedIn:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::LoginStatus::CredentialTokenType>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::LoginStatus::AuthenticationType>(uint8_t value)
{
    switch (static_cast<WebCore::LoginStatus::AuthenticationType>(value)) {
    case WebCore::LoginStatus::AuthenticationType::WebAuthn:
    case WebCore::LoginStatus::AuthenticationType::PasswordManager:
    case WebCore::LoginStatus::AuthenticationType::Unmanaged:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::AutoplayEvent>(uint8_t value)
{
    switch (static_cast<WebCore::AutoplayEvent>(value)) {
    case WebCore::AutoplayEvent::DidPreventMediaFromPlaying:
    case WebCore::AutoplayEvent::DidPlayMediaWithUserGesture:
    case WebCore::AutoplayEvent::DidAutoplayMediaPastThresholdWithoutUserInterference:
    case WebCore::AutoplayEvent::UserDidInterfereWithPlayback:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::InputMode>(uint8_t value)
{
    switch (static_cast<WebCore::InputMode>(value)) {
    case WebCore::InputMode::Unspecified:
    case WebCore::InputMode::None:
    case WebCore::InputMode::Text:
    case WebCore::InputMode::Telephone:
    case WebCore::InputMode::Url:
    case WebCore::InputMode::Email:
    case WebCore::InputMode::Numeric:
    case WebCore::InputMode::Decimal:
    case WebCore::InputMode::Search:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::IndexedDB::GetAllType>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WorkerType>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::StoredCredentialsPolicy>(uint8_t value)
{
    switch (static_cast<WebCore::StoredCredentialsPolicy>(value)) {
    case WebCore::StoredCredentialsPolicy::DoNotUse:
    case WebCore::StoredCredentialsPolicy::Use:
    case WebCore::StoredCredentialsPolicy::EphemeralStateless:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ContentSniffingPolicy>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ContentEncodingSniffingPolicy>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ClientCredentialPolicy>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ShouldRelaxThirdPartyCookieBlocking>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::PreflightPolicy>(uint8_t value)
{
    switch (static_cast<WebCore::PreflightPolicy>(value)) {
    case WebCore::PreflightPolicy::Consider:
    case WebCore::PreflightPolicy::Force:
    case WebCore::PreflightPolicy::Prevent:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WTFLogChannelState>(uint8_t value)
{
    switch (static_cast<WTFLogChannelState>(value)) {
    case WTFLogChannelState::Off:
    case WTFLogChannelState::On:
    case WTFLogChannelState::OnWithAccumulation:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ScrollSnapStrictness>(uint8_t value)
{
    switch (static_cast<WebCore::ScrollSnapStrictness>(value)) {
    case WebCore::ScrollSnapStrictness::None:
    case WebCore::ScrollSnapStrictness::Proximity:
    case WebCore::ScrollSnapStrictness::Mandatory:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::LengthType>(uint8_t value)
{
    switch (static_cast<WebCore::LengthType>(value)) {
    case WebCore::LengthType::Auto:
    case WebCore::LengthType::Normal:
    case WebCore::LengthType::Relative:
    case WebCore::LengthType::Percent:
    case WebCore::LengthType::Fixed:
    case WebCore::LengthType::Intrinsic:
    case WebCore::LengthType::MinIntrinsic:
    case WebCore::LengthType::MinContent:
    case WebCore::LengthType::MaxContent:
    case WebCore::LengthType::FillAvailable:
    case WebCore::LengthType::FitContent:
    case WebCore::LengthType::Calculated:
    case WebCore::LengthType::Undefined:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::OverscrollBehavior>(uint8_t value)
{
    switch (static_cast<WebCore::OverscrollBehavior>(value)) {
    case WebCore::OverscrollBehavior::Auto:
    case WebCore::OverscrollBehavior::Contain:
    case WebCore::OverscrollBehavior::None:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ScrollPinningBehavior>(uint8_t value)
{
    switch (static_cast<WebCore::ScrollPinningBehavior>(value)) {
    case WebCore::ScrollPinningBehavior::DoNotPin:
    case WebCore::ScrollPinningBehavior::PinToTop:
    case WebCore::ScrollPinningBehavior::PinToBottom:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WheelScrollGestureState>(uint8_t value)
{
    switch (static_cast<WebCore::WheelScrollGestureState>(value)) {
    case WebCore::WheelScrollGestureState::Blocking:
    case WebCore::WheelScrollGestureState::NonBlocking:
        return true;
    default:
        return false;
    }
}

#if ENABLE(META_VIEWPORT)
template<> bool isValidEnum<WebCore::ViewportArguments::Type>(uint8_t value)
{
    switch (static_cast<WebCore::ViewportArguments::Type>(value)) {
    case WebCore::ViewportArguments::Type::Implicit:
#if PLATFORM(IOS_FAMILY)
    case WebCore::ViewportArguments::Type::ImageDocument:
#endif
    case WebCore::ViewportArguments::Type::ViewportMeta:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::DiagnosticLoggingDomain>(uint8_t value)
{
    switch (static_cast<WebCore::DiagnosticLoggingDomain>(value)) {
    case WebCore::DiagnosticLoggingDomain::Media:
        return true;
    default:
        return false;
    }
}

#if (!(USE(CG))) && (!(USE(SKIA)))
template<> bool isValidEnum<WebCore::PlatformColorSpace::Name>(uint8_t value)
{
    switch (static_cast<WebCore::PlatformColorSpace::Name>(value)) {
    case WebCore::PlatformColorSpace::Name::SRGB:
    case WebCore::PlatformColorSpace::Name::LinearSRGB:
#if ENABLE(DESTINATION_COLOR_SPACE_DISPLAY_P3)
    case WebCore::PlatformColorSpace::Name::DisplayP3:
#endif
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::CompositionUnderlineColor>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::MediaCaptureType>(uint8_t value)
{
    switch (static_cast<WebCore::MediaCaptureType>(value)) {
    case WebCore::MediaCaptureType::MediaCaptureTypeNone:
    case WebCore::MediaCaptureType::MediaCaptureTypeUser:
    case WebCore::MediaCaptureType::MediaCaptureTypeEnvironment:
        return true;
    default:
        return false;
    }
}

#if ENABLE(ATTACHMENT_ELEMENT)
template<> bool isValidEnum<WebCore::AttachmentAssociatedElementType>(uint8_t value)
{
    switch (static_cast<WebCore::AttachmentAssociatedElementType>(value)) {
    case WebCore::AttachmentAssociatedElementType::None:
    case WebCore::AttachmentAssociatedElementType::Image:
    case WebCore::AttachmentAssociatedElementType::Source:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::TextCheckingProcessType>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::MediaStreamRequest::Type>(uint8_t value)
{
    switch (static_cast<WebCore::MediaStreamRequest::Type>(value)) {
    case WebCore::MediaStreamRequest::Type::UserMedia:
    case WebCore::MediaStreamRequest::Type::DisplayMedia:
    case WebCore::MediaStreamRequest::Type::DisplayMediaWithAudio:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::VideoCodecType>(uint8_t value)
{
    switch (static_cast<WebCore::VideoCodecType>(value)) {
    case WebCore::VideoCodecType::H264:
    case WebCore::VideoCodecType::H265:
    case WebCore::VideoCodecType::VP9:
    case WebCore::VideoCodecType::AV1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::NetworkTransactionInformation::Type>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

#if HAVE(SUPPORT_HDR_DISPLAY)
template<> bool isValidOptionSet<WebCore::ContentsFormat>(OptionSet<WebCore::ContentsFormat> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebCore::ContentsFormat::RGBA8)
#if ENABLE(PIXEL_FORMAT_RGB10)
        | static_cast<uint8_t>(WebCore::ContentsFormat::RGBA10)
#endif
#if ENABLE(PIXEL_FORMAT_RGBA16F)
        | static_cast<uint8_t>(WebCore::ContentsFormat::RGBA16F)
#endif
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}
#endif

#if ENABLE(WEB_AUTHN)
template<> bool isValidEnum<WebCore::AuthenticatorTransport>(uint8_t value)
{
    switch (static_cast<WebCore::AuthenticatorTransport>(value)) {
    case WebCore::AuthenticatorTransport::Usb:
    case WebCore::AuthenticatorTransport::Nfc:
    case WebCore::AuthenticatorTransport::Ble:
    case WebCore::AuthenticatorTransport::Internal:
    case WebCore::AuthenticatorTransport::Cable:
    case WebCore::AuthenticatorTransport::Hybrid:
    case WebCore::AuthenticatorTransport::SmartCard:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WEB_AUTHN)
template<> bool isValidEnum<WebCore::PublicKeyCredentialType>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if PLATFORM(IOS_FAMILY)
template<> bool isValidEnum<WebCore::SelectionRenderingBehavior>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::DataListSuggestionActivationType>(uint8_t value)
{
    switch (static_cast<WebCore::DataListSuggestionActivationType>(value)) {
    case WebCore::DataListSuggestionActivationType::ControlClicked:
    case WebCore::DataListSuggestionActivationType::IndicatorClicked:
    case WebCore::DataListSuggestionActivationType::TextChanged:
    case WebCore::DataListSuggestionActivationType::DataListMayHaveChanged:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::AlphaPremultiplication>(uint8_t value)
{
    switch (static_cast<WebCore::AlphaPremultiplication>(value)) {
    case WebCore::AlphaPremultiplication::Premultiplied:
    case WebCore::AlphaPremultiplication::Unpremultiplied:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::PixelFormat>(uint8_t value)
{
    switch (static_cast<WebCore::PixelFormat>(value)) {
    case WebCore::PixelFormat::RGBA8:
    case WebCore::PixelFormat::BGRX8:
    case WebCore::PixelFormat::BGRA8:
#if ENABLE(PIXEL_FORMAT_RGB10)
    case WebCore::PixelFormat::RGB10:
#endif
#if ENABLE(PIXEL_FORMAT_RGB10A8)
    case WebCore::PixelFormat::RGB10A8:
#endif
#if ENABLE(PIXEL_FORMAT_RGBA16F)
    case WebCore::PixelFormat::RGBA16F:
#endif
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::UseLosslessCompression>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ImageBufferPixelFormat>(uint8_t value)
{
    switch (static_cast<WebCore::ImageBufferPixelFormat>(value)) {
    case WebCore::ImageBufferPixelFormat::BGRX8:
    case WebCore::ImageBufferPixelFormat::BGRA8:
#if ENABLE(PIXEL_FORMAT_RGB10)
    case WebCore::ImageBufferPixelFormat::RGB10:
#endif
#if ENABLE(PIXEL_FORMAT_RGB10A8)
    case WebCore::ImageBufferPixelFormat::RGB10A8:
#endif
#if ENABLE(PIXEL_FORMAT_RGBA16F)
    case WebCore::ImageBufferPixelFormat::RGBA16F:
#endif
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::TextIndicatorLifetime>(uint8_t value)
{
    switch (static_cast<WebCore::TextIndicatorLifetime>(value)) {
    case WebCore::TextIndicatorLifetime::Permanent:
    case WebCore::TextIndicatorLifetime::Temporary:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::EventTrackingRegions::EventType>(uint8_t value)
{
    switch (static_cast<WebCore::EventTrackingRegions::EventType>(value)) {
    case WebCore::EventTrackingRegions::EventType::Mousedown:
    case WebCore::EventTrackingRegions::EventType::Mousemove:
    case WebCore::EventTrackingRegions::EventType::Mouseup:
    case WebCore::EventTrackingRegions::EventType::Mousewheel:
    case WebCore::EventTrackingRegions::EventType::Pointerdown:
    case WebCore::EventTrackingRegions::EventType::Pointerenter:
    case WebCore::EventTrackingRegions::EventType::Pointerleave:
    case WebCore::EventTrackingRegions::EventType::Pointermove:
    case WebCore::EventTrackingRegions::EventType::Pointerout:
    case WebCore::EventTrackingRegions::EventType::Pointerover:
    case WebCore::EventTrackingRegions::EventType::Pointerup:
    case WebCore::EventTrackingRegions::EventType::Touchend:
    case WebCore::EventTrackingRegions::EventType::Touchforcechange:
    case WebCore::EventTrackingRegions::EventType::Touchmove:
    case WebCore::EventTrackingRegions::EventType::Touchstart:
    case WebCore::EventTrackingRegions::EventType::Wheel:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::HasInsecureContent>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ScrollElasticity>(uint8_t value)
{
    switch (static_cast<WebCore::ScrollElasticity>(value)) {
    case WebCore::ScrollElasticity::Automatic:
    case WebCore::ScrollElasticity::None:
    case WebCore::ScrollElasticity::Allowed:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ScrollbarMode>(uint8_t value)
{
    switch (static_cast<WebCore::ScrollbarMode>(value)) {
    case WebCore::ScrollbarMode::Auto:
    case WebCore::ScrollbarMode::AlwaysOff:
    case WebCore::ScrollbarMode::AlwaysOn:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::NativeScrollbarVisibility>(uint8_t value)
{
    switch (static_cast<WebCore::NativeScrollbarVisibility>(value)) {
    case WebCore::NativeScrollbarVisibility::Visible:
    case WebCore::NativeScrollbarVisibility::HiddenByStyle:
    case WebCore::NativeScrollbarVisibility::ReplacedByCustomScrollbar:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ScrollUpdateType>(uint8_t value)
{
    switch (static_cast<WebCore::ScrollUpdateType>(value)) {
    case WebCore::ScrollUpdateType::PositionUpdate:
    case WebCore::ScrollUpdateType::AnimatedScrollWillStart:
    case WebCore::ScrollUpdateType::AnimatedScrollDidEnd:
    case WebCore::ScrollUpdateType::WheelEventScrollWillStart:
    case WebCore::ScrollUpdateType::WheelEventScrollDidEnd:
    case WebCore::ScrollUpdateType::ProgrammaticScrollDidEnd:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ScrollingLayerPositionAction>(uint8_t value)
{
    switch (static_cast<WebCore::ScrollingLayerPositionAction>(value)) {
    case WebCore::ScrollingLayerPositionAction::Set:
    case WebCore::ScrollingLayerPositionAction::SetApproximate:
    case WebCore::ScrollingLayerPositionAction::Sync:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebCore::WheelEventProcessingSteps>(OptionSet<WebCore::WheelEventProcessingSteps> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebCore::WheelEventProcessingSteps::AsyncScrolling)
        | static_cast<uint8_t>(WebCore::WheelEventProcessingSteps::SynchronousScrolling)
        | static_cast<uint8_t>(WebCore::WheelEventProcessingSteps::NonBlockingDOMEventDispatch)
        | static_cast<uint8_t>(WebCore::WheelEventProcessingSteps::BlockingDOMEventDispatch)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

#if ENABLE(GPU_PROCESS) && ENABLE(WEBGL)
template<> bool isValidEnum<WebCore::GraphicsContextGLPowerPreference>(uint8_t value)
{
    switch (static_cast<WebCore::GraphicsContextGLPowerPreference>(value)) {
    case WebCore::GraphicsContextGLPowerPreference::Default:
    case WebCore::GraphicsContextGLPowerPreference::LowPower:
    case WebCore::GraphicsContextGLPowerPreference::HighPerformance:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(GPU_PROCESS) && ENABLE(WEBGL)
template<> bool isValidEnum<WebCore::GraphicsContextGLSimulatedCreationFailure>(uint8_t value)
{
    switch (static_cast<WebCore::GraphicsContextGLSimulatedCreationFailure>(value)) {
    case WebCore::GraphicsContextGLSimulatedCreationFailure::None:
    case WebCore::GraphicsContextGLSimulatedCreationFailure::IPCBufferOOM:
    case WebCore::GraphicsContextGLSimulatedCreationFailure::CreationTimeout:
    case WebCore::GraphicsContextGLSimulatedCreationFailure::FailPlatformContextCreation:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(GPU_PROCESS) && ENABLE(WEBGL)
template<> bool isValidEnum<WebCore::GraphicsContextGLFlipY>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(GPU_PROCESS) && ENABLE(WEBGL)
template<> bool isValidEnum<WebCore::GraphicsContextGLSimulatedEventForTesting>(uint8_t value)
{
    switch (static_cast<WebCore::GraphicsContextGLSimulatedEventForTesting>(value)) {
    case WebCore::GraphicsContextGLSimulatedEventForTesting::GPUStatusFailure:
    case WebCore::GraphicsContextGLSimulatedEventForTesting::Timeout:
    case WebCore::GraphicsContextGLSimulatedEventForTesting::DisplayBufferAllocationFailure:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::CSSBoxType>(uint8_t value)
{
    switch (static_cast<WebCore::CSSBoxType>(value)) {
    case WebCore::CSSBoxType::BoxMissing:
    case WebCore::CSSBoxType::MarginBox:
    case WebCore::CSSBoxType::BorderBox:
    case WebCore::CSSBoxType::PaddingBox:
    case WebCore::CSSBoxType::ContentBox:
    case WebCore::CSSBoxType::FillBox:
    case WebCore::CSSBoxType::StrokeBox:
    case WebCore::CSSBoxType::ViewBox:
        return true;
    default:
        return false;
    }
}

#if ENABLE(WEB_AUTHN)
template<> bool isValidEnum<WebCore::UserVerificationRequirement>(uint8_t value)
{
    switch (static_cast<WebCore::UserVerificationRequirement>(value)) {
    case WebCore::UserVerificationRequirement::Required:
    case WebCore::UserVerificationRequirement::Preferred:
    case WebCore::UserVerificationRequirement::Discouraged:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WEB_AUTHN)
template<> bool isValidEnum<WebCore::ResidentKeyRequirement>(uint8_t value)
{
    switch (static_cast<WebCore::ResidentKeyRequirement>(value)) {
    case WebCore::ResidentKeyRequirement::Required:
    case WebCore::ResidentKeyRequirement::Preferred:
    case WebCore::ResidentKeyRequirement::Discouraged:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WEB_AUTHN)
template<> bool isValidEnum<WebCore::AuthenticatorAttachment>(uint8_t value)
{
    switch (static_cast<WebCore::AuthenticatorAttachment>(value)) {
    case WebCore::AuthenticatorAttachment::Platform:
    case WebCore::AuthenticatorAttachment::CrossPlatform:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::ResourceRequestCachePolicy>(uint8_t value)
{
    switch (static_cast<WebCore::ResourceRequestCachePolicy>(value)) {
    case WebCore::ResourceRequestCachePolicy::UseProtocolCachePolicy:
    case WebCore::ResourceRequestCachePolicy::ReloadIgnoringCacheData:
    case WebCore::ResourceRequestCachePolicy::ReturnCacheDataElseLoad:
    case WebCore::ResourceRequestCachePolicy::ReturnCacheDataDontLoad:
    case WebCore::ResourceRequestCachePolicy::DoNotUseAnyCache:
    case WebCore::ResourceRequestCachePolicy::RefreshAnyCacheData:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ResourceRequestBase::SameSiteDisposition>(uint8_t value)
{
    switch (static_cast<WebCore::ResourceRequestBase::SameSiteDisposition>(value)) {
    case WebCore::ResourceRequestBase::SameSiteDisposition::Unspecified:
    case WebCore::ResourceRequestBase::SameSiteDisposition::SameSite:
    case WebCore::ResourceRequestBase::SameSiteDisposition::CrossSite:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ResourceRequestRequester>(uint8_t value)
{
    switch (static_cast<WebCore::ResourceRequestRequester>(value)) {
    case WebCore::ResourceRequestRequester::Unspecified:
    case WebCore::ResourceRequestRequester::Main:
    case WebCore::ResourceRequestRequester::XHR:
    case WebCore::ResourceRequestRequester::Fetch:
    case WebCore::ResourceRequestRequester::Media:
    case WebCore::ResourceRequestRequester::Model:
    case WebCore::ResourceRequestRequester::ImportScripts:
    case WebCore::ResourceRequestRequester::Ping:
    case WebCore::ResourceRequestRequester::Beacon:
    case WebCore::ResourceRequestRequester::EventSource:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ResourceLoadPriority>(uint8_t value)
{
    switch (static_cast<WebCore::ResourceLoadPriority>(value)) {
    case WebCore::ResourceLoadPriority::VeryLow:
    case WebCore::ResourceLoadPriority::Low:
    case WebCore::ResourceLoadPriority::Medium:
    case WebCore::ResourceLoadPriority::High:
    case WebCore::ResourceLoadPriority::VeryHigh:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ResourceResponseBaseType>(uint8_t value)
{
    switch (static_cast<WebCore::ResourceResponseBaseType>(value)) {
    case WebCore::ResourceResponseBaseType::Basic:
    case WebCore::ResourceResponseBaseType::Cors:
    case WebCore::ResourceResponseBaseType::Default:
    case WebCore::ResourceResponseBaseType::Error:
    case WebCore::ResourceResponseBaseType::Opaque:
    case WebCore::ResourceResponseBaseType::Opaqueredirect:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ResourceResponseBaseTainting>(uint8_t value)
{
    switch (static_cast<WebCore::ResourceResponseBaseTainting>(value)) {
    case WebCore::ResourceResponseBaseTainting::Basic:
    case WebCore::ResourceResponseBaseTainting::Cors:
    case WebCore::ResourceResponseBaseTainting::Opaque:
    case WebCore::ResourceResponseBaseTainting::Opaqueredirect:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ResourceResponseSource>(uint8_t value)
{
    switch (static_cast<WebCore::ResourceResponseSource>(value)) {
    case WebCore::ResourceResponseSource::Unknown:
    case WebCore::ResourceResponseSource::Network:
    case WebCore::ResourceResponseSource::DiskCache:
    case WebCore::ResourceResponseSource::DiskCacheAfterValidation:
    case WebCore::ResourceResponseSource::MemoryCache:
    case WebCore::ResourceResponseSource::MemoryCacheAfterValidation:
    case WebCore::ResourceResponseSource::ServiceWorker:
    case WebCore::ResourceResponseSource::ApplicationCache:
    case WebCore::ResourceResponseSource::DOMCache:
    case WebCore::ResourceResponseSource::InspectorOverride:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::UsedLegacyTLS>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WasPrivateRelayed>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ReferrerPolicy>(uint8_t value)
{
    switch (static_cast<WebCore::ReferrerPolicy>(value)) {
    case WebCore::ReferrerPolicy::EmptyString:
    case WebCore::ReferrerPolicy::NoReferrer:
    case WebCore::ReferrerPolicy::NoReferrerWhenDowngrade:
    case WebCore::ReferrerPolicy::SameOrigin:
    case WebCore::ReferrerPolicy::Origin:
    case WebCore::ReferrerPolicy::StrictOrigin:
    case WebCore::ReferrerPolicy::OriginWhenCrossOrigin:
    case WebCore::ReferrerPolicy::StrictOriginWhenCrossOrigin:
    case WebCore::ReferrerPolicy::UnsafeUrl:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FetchOptionsDestination>(uint8_t value)
{
    switch (static_cast<WebCore::FetchOptionsDestination>(value)) {
    case WebCore::FetchOptionsDestination::EmptyString:
    case WebCore::FetchOptionsDestination::Audio:
    case WebCore::FetchOptionsDestination::Audioworklet:
    case WebCore::FetchOptionsDestination::Document:
    case WebCore::FetchOptionsDestination::Embed:
    case WebCore::FetchOptionsDestination::Environmentmap:
    case WebCore::FetchOptionsDestination::Font:
    case WebCore::FetchOptionsDestination::Image:
    case WebCore::FetchOptionsDestination::Iframe:
    case WebCore::FetchOptionsDestination::Manifest:
    case WebCore::FetchOptionsDestination::Model:
    case WebCore::FetchOptionsDestination::Object:
    case WebCore::FetchOptionsDestination::Paintworklet:
    case WebCore::FetchOptionsDestination::Report:
    case WebCore::FetchOptionsDestination::Script:
    case WebCore::FetchOptionsDestination::Serviceworker:
    case WebCore::FetchOptionsDestination::Sharedworker:
    case WebCore::FetchOptionsDestination::Style:
    case WebCore::FetchOptionsDestination::Track:
    case WebCore::FetchOptionsDestination::Video:
    case WebCore::FetchOptionsDestination::Worker:
    case WebCore::FetchOptionsDestination::Xslt:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FetchOptionsMode>(uint8_t value)
{
    switch (static_cast<WebCore::FetchOptionsMode>(value)) {
    case WebCore::FetchOptionsMode::Navigate:
    case WebCore::FetchOptionsMode::SameOrigin:
    case WebCore::FetchOptionsMode::NoCors:
    case WebCore::FetchOptionsMode::Cors:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FetchOptionsCredentials>(uint8_t value)
{
    switch (static_cast<WebCore::FetchOptionsCredentials>(value)) {
    case WebCore::FetchOptionsCredentials::Omit:
    case WebCore::FetchOptionsCredentials::SameOrigin:
    case WebCore::FetchOptionsCredentials::Include:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FetchOptionsCache>(uint8_t value)
{
    switch (static_cast<WebCore::FetchOptionsCache>(value)) {
    case WebCore::FetchOptionsCache::Default:
    case WebCore::FetchOptionsCache::NoStore:
    case WebCore::FetchOptionsCache::Reload:
    case WebCore::FetchOptionsCache::NoCache:
    case WebCore::FetchOptionsCache::ForceCache:
    case WebCore::FetchOptionsCache::OnlyIfCached:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FetchOptionsRedirect>(uint8_t value)
{
    switch (static_cast<WebCore::FetchOptionsRedirect>(value)) {
    case WebCore::FetchOptionsRedirect::Follow:
    case WebCore::FetchOptionsRedirect::Error:
    case WebCore::FetchOptionsRedirect::Manual:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FetchHeadersGuard>(uint8_t value)
{
    switch (static_cast<WebCore::FetchHeadersGuard>(value)) {
    case WebCore::FetchHeadersGuard::None:
    case WebCore::FetchHeadersGuard::Immutable:
    case WebCore::FetchHeadersGuard::Request:
    case WebCore::FetchHeadersGuard::RequestNoCors:
    case WebCore::FetchHeadersGuard::Response:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebCore::ControlStyle::State>(OptionSet<WebCore::ControlStyle::State> value)
{
    constexpr unsigned allValidBitsValue = 0
        | static_cast<unsigned>(WebCore::ControlStyle::State::Hovered)
        | static_cast<unsigned>(WebCore::ControlStyle::State::Pressed)
        | static_cast<unsigned>(WebCore::ControlStyle::State::Focused)
        | static_cast<unsigned>(WebCore::ControlStyle::State::Enabled)
        | static_cast<unsigned>(WebCore::ControlStyle::State::Checked)
        | static_cast<unsigned>(WebCore::ControlStyle::State::Default)
        | static_cast<unsigned>(WebCore::ControlStyle::State::WindowActive)
        | static_cast<unsigned>(WebCore::ControlStyle::State::Indeterminate)
        | static_cast<unsigned>(WebCore::ControlStyle::State::SpinUp)
        | static_cast<unsigned>(WebCore::ControlStyle::State::Presenting)
        | static_cast<unsigned>(WebCore::ControlStyle::State::FormSemanticContext)
        | static_cast<unsigned>(WebCore::ControlStyle::State::DarkAppearance)
        | static_cast<unsigned>(WebCore::ControlStyle::State::InlineFlippedWritingMode)
        | static_cast<unsigned>(WebCore::ControlStyle::State::LargeControls)
        | static_cast<unsigned>(WebCore::ControlStyle::State::ReadOnly)
        | static_cast<unsigned>(WebCore::ControlStyle::State::ListButton)
        | static_cast<unsigned>(WebCore::ControlStyle::State::ListButtonPressed)
        | static_cast<unsigned>(WebCore::ControlStyle::State::VerticalWritingMode)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidEnum<WebCore::StyleAppearance>(uint8_t value)
{
    switch (static_cast<WebCore::StyleAppearance>(value)) {
    case WebCore::StyleAppearance::None:
    case WebCore::StyleAppearance::Auto:
    case WebCore::StyleAppearance::Checkbox:
    case WebCore::StyleAppearance::Radio:
    case WebCore::StyleAppearance::PushButton:
    case WebCore::StyleAppearance::SquareButton:
    case WebCore::StyleAppearance::Button:
    case WebCore::StyleAppearance::DefaultButton:
    case WebCore::StyleAppearance::Listbox:
    case WebCore::StyleAppearance::Menulist:
    case WebCore::StyleAppearance::MenulistButton:
    case WebCore::StyleAppearance::Meter:
    case WebCore::StyleAppearance::ProgressBar:
    case WebCore::StyleAppearance::SliderHorizontal:
    case WebCore::StyleAppearance::SliderVertical:
    case WebCore::StyleAppearance::SearchField:
#if ENABLE(APPLE_PAY)
    case WebCore::StyleAppearance::ApplePayButton:
#endif
#if ENABLE(ATTACHMENT_ELEMENT)
    case WebCore::StyleAppearance::Attachment:
#endif
#if ENABLE(ATTACHMENT_ELEMENT)
    case WebCore::StyleAppearance::BorderlessAttachment:
#endif
    case WebCore::StyleAppearance::TextArea:
    case WebCore::StyleAppearance::TextField:
    case WebCore::StyleAppearance::ColorWell:
    case WebCore::StyleAppearance::ColorWellSwatch:
    case WebCore::StyleAppearance::ColorWellSwatchOverlay:
    case WebCore::StyleAppearance::ColorWellSwatchWrapper:
#if ENABLE(SERVICE_CONTROLS)
    case WebCore::StyleAppearance::ImageControlsButton:
#endif
    case WebCore::StyleAppearance::InnerSpinButton:
    case WebCore::StyleAppearance::ListButton:
    case WebCore::StyleAppearance::SearchFieldDecoration:
    case WebCore::StyleAppearance::SearchFieldResultsDecoration:
    case WebCore::StyleAppearance::SearchFieldResultsButton:
    case WebCore::StyleAppearance::SearchFieldCancelButton:
    case WebCore::StyleAppearance::SliderThumbHorizontal:
    case WebCore::StyleAppearance::SliderThumbVertical:
    case WebCore::StyleAppearance::Switch:
    case WebCore::StyleAppearance::SwitchThumb:
    case WebCore::StyleAppearance::SwitchTrack:
        return true;
    default:
        return false;
    }
}

#if ENABLE(APPLE_PAY)
template<> bool isValidEnum<WebCore::ApplePayButtonType>(uint8_t value)
{
    switch (static_cast<WebCore::ApplePayButtonType>(value)) {
    case WebCore::ApplePayButtonType::Plain:
    case WebCore::ApplePayButtonType::Buy:
    case WebCore::ApplePayButtonType::SetUp:
    case WebCore::ApplePayButtonType::Donate:
    case WebCore::ApplePayButtonType::CheckOut:
    case WebCore::ApplePayButtonType::Book:
    case WebCore::ApplePayButtonType::Subscribe:
#if ENABLE(APPLE_PAY_NEW_BUTTON_TYPES)
    case WebCore::ApplePayButtonType::Reload:
#endif
#if ENABLE(APPLE_PAY_NEW_BUTTON_TYPES)
    case WebCore::ApplePayButtonType::AddMoney:
#endif
#if ENABLE(APPLE_PAY_NEW_BUTTON_TYPES)
    case WebCore::ApplePayButtonType::TopUp:
#endif
#if ENABLE(APPLE_PAY_NEW_BUTTON_TYPES)
    case WebCore::ApplePayButtonType::Order:
#endif
#if ENABLE(APPLE_PAY_NEW_BUTTON_TYPES)
    case WebCore::ApplePayButtonType::Rent:
#endif
#if ENABLE(APPLE_PAY_NEW_BUTTON_TYPES)
    case WebCore::ApplePayButtonType::Support:
#endif
#if ENABLE(APPLE_PAY_NEW_BUTTON_TYPES)
    case WebCore::ApplePayButtonType::Contribute:
#endif
#if ENABLE(APPLE_PAY_NEW_BUTTON_TYPES)
    case WebCore::ApplePayButtonType::Tip:
#endif
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(APPLE_PAY)
template<> bool isValidEnum<WebCore::ApplePayButtonStyle>(uint8_t value)
{
    switch (static_cast<WebCore::ApplePayButtonStyle>(value)) {
    case WebCore::ApplePayButtonStyle::White:
    case WebCore::ApplePayButtonStyle::WhiteOutline:
    case WebCore::ApplePayButtonStyle::Black:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::MeterPart::GaugeRegion>(uint8_t value)
{
    switch (static_cast<WebCore::MeterPart::GaugeRegion>(value)) {
    case WebCore::MeterPart::GaugeRegion::Optimum:
    case WebCore::MeterPart::GaugeRegion::Suboptimal:
    case WebCore::MeterPart::GaugeRegion::EvenLessGood:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebCore::FilterEffectGeometry::Flags>(OptionSet<WebCore::FilterEffectGeometry::Flags> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebCore::FilterEffectGeometry::Flags::HasX)
        | static_cast<uint8_t>(WebCore::FilterEffectGeometry::Flags::HasY)
        | static_cast<uint8_t>(WebCore::FilterEffectGeometry::Flags::HasWidth)
        | static_cast<uint8_t>(WebCore::FilterEffectGeometry::Flags::HasHeight)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidEnum<WebCore::ModalContainerDecision>(uint8_t value)
{
    switch (static_cast<WebCore::ModalContainerDecision>(value)) {
    case WebCore::ModalContainerDecision::Show:
    case WebCore::ModalContainerDecision::HideAndIgnore:
    case WebCore::ModalContainerDecision::HideAndAllow:
    case WebCore::ModalContainerDecision::HideAndDisallow:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebCore::AutoplayEventFlags>(OptionSet<WebCore::AutoplayEventFlags> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebCore::AutoplayEventFlags::HasAudio)
        | static_cast<uint8_t>(WebCore::AutoplayEventFlags::PlaybackWasPrevented)
        | static_cast<uint8_t>(WebCore::AutoplayEventFlags::MediaIsMainContent)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidEnum<WebCore::FocusDirection>(uint8_t value)
{
    switch (static_cast<WebCore::FocusDirection>(value)) {
    case WebCore::FocusDirection::None:
    case WebCore::FocusDirection::Forward:
    case WebCore::FocusDirection::Backward:
    case WebCore::FocusDirection::Up:
    case WebCore::FocusDirection::Down:
    case WebCore::FocusDirection::Left:
    case WebCore::FocusDirection::Right:
        return true;
    default:
        return false;
    }
}

#if ENABLE(GAMEPAD)
template<> bool isValidEnum<WebCore::GamepadHapticEffectType>(uint8_t value)
{
    switch (static_cast<WebCore::GamepadHapticEffectType>(value)) {
    case WebCore::GamepadHapticEffectType::DualRumble:
    case WebCore::GamepadHapticEffectType::TriggerRumble:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::DOMPasteAccessCategory>(uint8_t value)
{
    switch (static_cast<WebCore::DOMPasteAccessCategory>(value)) {
    case WebCore::DOMPasteAccessCategory::General:
    case WebCore::DOMPasteAccessCategory::Fonts:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::DOMPasteAccessPolicy>(uint8_t value)
{
    switch (static_cast<WebCore::DOMPasteAccessPolicy>(value)) {
    case WebCore::DOMPasteAccessPolicy::NotRequestedYet:
    case WebCore::DOMPasteAccessPolicy::Denied:
    case WebCore::DOMPasteAccessPolicy::Granted:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::DOMPasteAccessResponse>(uint8_t value)
{
    switch (static_cast<WebCore::DOMPasteAccessResponse>(value)) {
    case WebCore::DOMPasteAccessResponse::DeniedForGesture:
    case WebCore::DOMPasteAccessResponse::GrantedForCommand:
    case WebCore::DOMPasteAccessResponse::GrantedForGesture:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::DeviceOrientationOrMotionPermissionState>(uint8_t value)
{
    switch (static_cast<WebCore::DeviceOrientationOrMotionPermissionState>(value)) {
    case WebCore::DeviceOrientationOrMotionPermissionState::Granted:
    case WebCore::DeviceOrientationOrMotionPermissionState::Denied:
    case WebCore::DeviceOrientationOrMotionPermissionState::Prompt:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ExceptionDetails::Type>(uint8_t value)
{
    switch (static_cast<WebCore::ExceptionDetails::Type>(value)) {
    case WebCore::ExceptionDetails::Type::Script:
    case WebCore::ExceptionDetails::Type::InvalidTargetFrame:
    case WebCore::ExceptionDetails::Type::AppBoundDomain:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::SecurityPolicyViolationEventDisposition>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::VerticalAlignChange>(uint8_t value)
{
    switch (static_cast<WebCore::VerticalAlignChange>(value)) {
    case WebCore::VerticalAlignChange::Superscript:
    case WebCore::VerticalAlignChange::Baseline:
    case WebCore::VerticalAlignChange::Subscript:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::TextGranularity>(uint8_t value)
{
    switch (static_cast<WebCore::TextGranularity>(value)) {
    case WebCore::TextGranularity::CharacterGranularity:
    case WebCore::TextGranularity::WordGranularity:
    case WebCore::TextGranularity::SentenceGranularity:
    case WebCore::TextGranularity::LineGranularity:
    case WebCore::TextGranularity::ParagraphGranularity:
    case WebCore::TextGranularity::DocumentGranularity:
    case WebCore::TextGranularity::SentenceBoundary:
    case WebCore::TextGranularity::LineBoundary:
    case WebCore::TextGranularity::ParagraphBoundary:
    case WebCore::TextGranularity::DocumentBoundary:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::RunAsAsyncFunction>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ForceUserGesture>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::RemoveTransientActivation>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FontAttributes::SubscriptOrSuperscript>(uint8_t value)
{
    switch (static_cast<WebCore::FontAttributes::SubscriptOrSuperscript>(value)) {
    case WebCore::FontAttributes::SubscriptOrSuperscript::None:
    case WebCore::FontAttributes::SubscriptOrSuperscript::Subscript:
    case WebCore::FontAttributes::SubscriptOrSuperscript::Superscript:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FontAttributes::HorizontalAlignment>(uint8_t value)
{
    switch (static_cast<WebCore::FontAttributes::HorizontalAlignment>(value)) {
    case WebCore::FontAttributes::HorizontalAlignment::Left:
    case WebCore::FontAttributes::HorizontalAlignment::Center:
    case WebCore::FontAttributes::HorizontalAlignment::Right:
    case WebCore::FontAttributes::HorizontalAlignment::Justify:
    case WebCore::FontAttributes::HorizontalAlignment::Natural:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WritingDirection>(uint8_t value)
{
    switch (static_cast<WebCore::WritingDirection>(value)) {
    case WebCore::WritingDirection::Natural:
    case WebCore::WritingDirection::LeftToRight:
    case WebCore::WritingDirection::RightToLeft:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::SelectionDirection>(uint8_t value)
{
    switch (static_cast<WebCore::SelectionDirection>(value)) {
    case WebCore::SelectionDirection::Forward:
    case WebCore::SelectionDirection::Backward:
    case WebCore::SelectionDirection::Right:
    case WebCore::SelectionDirection::Left:
        return true;
    default:
        return false;
    }
}

#if ENABLE(DATA_DETECTION)
template<> bool isValidOptionSet<WebCore::DataDetectorType>(OptionSet<WebCore::DataDetectorType> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebCore::DataDetectorType::PhoneNumber)
        | static_cast<uint8_t>(WebCore::DataDetectorType::Link)
        | static_cast<uint8_t>(WebCore::DataDetectorType::Address)
        | static_cast<uint8_t>(WebCore::DataDetectorType::CalendarEvent)
        | static_cast<uint8_t>(WebCore::DataDetectorType::TrackingNumber)
        | static_cast<uint8_t>(WebCore::DataDetectorType::FlightNumber)
        | static_cast<uint8_t>(WebCore::DataDetectorType::LookupSuggestion)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}
#endif

template<> bool isValidEnum<WebCore::AutocapitalizeType>(uint8_t value)
{
    switch (static_cast<WebCore::AutocapitalizeType>(value)) {
    case WebCore::AutocapitalizeType::Default:
    case WebCore::AutocapitalizeType::None:
    case WebCore::AutocapitalizeType::Words:
    case WebCore::AutocapitalizeType::Sentences:
    case WebCore::AutocapitalizeType::AllCharacters:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::CrossOriginEmbedderPolicyValue>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::IncludeSecureCookies>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

#if ENABLE(ASYNC_SCROLLING)
template<> bool isValidOptionSet<WebCore::ScrollingStateNodeProperty>(OptionSet<WebCore::ScrollingStateNodeProperty> value)
{
    constexpr uint64_t allValidBitsValue = 0
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::Layer)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::ChildNodes)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::ScrollableAreaSize)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::TotalContentsSize)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::ReachableContentsSize)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::ScrollPosition)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::ScrollOrigin)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::ScrollableAreaParams)
#if ENABLE(SCROLLING_THREAD)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::ReasonsForSynchronousScrolling)
#endif
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::RequestedScrollPosition)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::SnapOffsetsInfo)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::CurrentHorizontalSnapOffsetIndex)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::CurrentVerticalSnapOffsetIndex)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::IsMonitoringWheelEvents)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::ScrollContainerLayer)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::ScrolledContentsLayer)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::HorizontalScrollbarLayer)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::VerticalScrollbarLayer)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::PainterForScrollbar)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::ContentAreaHoverState)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::MouseActivityState)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::ScrollbarHoverState)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::ScrollbarEnabledState)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::ScrollbarLayoutDirection)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::ScrollbarWidth)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::UseDarkAppearanceForScrollbars)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::FrameScaleFactor)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::EventTrackingRegion)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::RootContentsLayer)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::CounterScrollingLayer)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::InsetClipLayer)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::ContentShadowLayer)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::HeaderHeight)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::FooterHeight)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::HeaderLayer)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::FooterLayer)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::BehaviorForFixedElements)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::ObscuredContentInsets)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::VisualViewportIsSmallerThanLayoutViewport)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::AsyncFrameOrOverflowScrollingEnabled)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::WheelEventGesturesBecomeNonBlocking)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::ScrollingPerformanceTestingEnabled)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::LayoutViewport)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::MinLayoutViewportOrigin)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::MaxLayoutViewportOrigin)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::OverrideVisualViewportSize)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::RelatedOverflowScrollingNodes)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::LayoutConstraintData)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::ViewportConstraints)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::ViewportAnchorLayer)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::OverflowScrollingNode)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::KeyboardScrollData)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::OverlayScrollbarsEnabled)
        | static_cast<uint64_t>(WebCore::ScrollingStateNodeProperty::LayerHostingContextIdentifier)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}
#endif

template<> bool isValidEnum<WebCore::ScrollClamping>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ScrollType>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ScrollSnapStop>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

#if ENABLE(ENCRYPTED_MEDIA)
template<> bool isValidEnum<WebCore::CDMEncryptionScheme>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(ENCRYPTED_MEDIA)
template<> bool isValidEnum<WebCore::CDMKeyGroupingStrategy>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(ENCRYPTED_MEDIA)
template<> bool isValidEnum<WebCore::CDMSessionType>(uint8_t value)
{
    switch (static_cast<WebCore::CDMSessionType>(value)) {
    case WebCore::CDMSessionType::Temporary:
    case WebCore::CDMSessionType::PersistentUsageRecord:
    case WebCore::CDMSessionType::PersistentLicense:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::MediaSelectionOption::MediaType>(uint8_t value)
{
    switch (static_cast<WebCore::MediaSelectionOption::MediaType>(value)) {
    case WebCore::MediaSelectionOption::MediaType::Unknown:
    case WebCore::MediaSelectionOption::MediaType::Audio:
    case WebCore::MediaSelectionOption::MediaType::Subtitles:
    case WebCore::MediaSelectionOption::MediaType::Captions:
    case WebCore::MediaSelectionOption::MediaType::Metadata:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::MediaSelectionOption::LegibleType>(uint8_t value)
{
    switch (static_cast<WebCore::MediaSelectionOption::LegibleType>(value)) {
    case WebCore::MediaSelectionOption::LegibleType::Regular:
    case WebCore::MediaSelectionOption::LegibleType::LegibleOff:
    case WebCore::MediaSelectionOption::LegibleType::LegibleAuto:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::MediaDecodingType>(uint8_t value)
{
    switch (static_cast<WebCore::MediaDecodingType>(value)) {
    case WebCore::MediaDecodingType::File:
    case WebCore::MediaDecodingType::MediaSource:
    case WebCore::MediaDecodingType::WebRTC:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::MediaEncodingType>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::TextManipulationControllerExclusionRule::Type>(uint8_t value)
{
    switch (static_cast<WebCore::TextManipulationControllerExclusionRule::Type>(value)) {
    case WebCore::TextManipulationControllerExclusionRule::Type::Exclude:
    case WebCore::TextManipulationControllerExclusionRule::Type::Include:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::TextManipulationControllerManipulationFailure::Type>(uint8_t value)
{
    switch (static_cast<WebCore::TextManipulationControllerManipulationFailure::Type>(value)) {
    case WebCore::TextManipulationControllerManipulationFailure::Type::NotAvailable:
    case WebCore::TextManipulationControllerManipulationFailure::Type::ContentChanged:
    case WebCore::TextManipulationControllerManipulationFailure::Type::InvalidItem:
    case WebCore::TextManipulationControllerManipulationFailure::Type::InvalidToken:
    case WebCore::TextManipulationControllerManipulationFailure::Type::ExclusionViolation:
        return true;
    default:
        return false;
    }
}

#if ENABLE(VIDEO)
template<> bool isValidOptionSet<WebCore::VideoMediaSampleRendererPreference>(OptionSet<WebCore::VideoMediaSampleRendererPreference> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebCore::VideoMediaSampleRendererPreference::PrefersDecompressionSession)
        | static_cast<uint8_t>(WebCore::VideoMediaSampleRendererPreference::ProtectedFallbackDisabled)
        | static_cast<uint8_t>(WebCore::VideoMediaSampleRendererPreference::UseDecompressionSessionForProtectedContent)
        | static_cast<uint8_t>(WebCore::VideoMediaSampleRendererPreference::UseStereoDecoding)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}
#endif

template<> bool isValidEnum<WebCore::MediaPlayerNetworkState>(uint8_t value)
{
    switch (static_cast<WebCore::MediaPlayerNetworkState>(value)) {
    case WebCore::MediaPlayerNetworkState::Empty:
    case WebCore::MediaPlayerNetworkState::Idle:
    case WebCore::MediaPlayerNetworkState::Loading:
    case WebCore::MediaPlayerNetworkState::Loaded:
    case WebCore::MediaPlayerNetworkState::FormatError:
    case WebCore::MediaPlayerNetworkState::NetworkError:
    case WebCore::MediaPlayerNetworkState::DecodeError:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::MediaPlayerReadyState>(uint8_t value)
{
    switch (static_cast<WebCore::MediaPlayerReadyState>(value)) {
    case WebCore::MediaPlayerReadyState::HaveNothing:
    case WebCore::MediaPlayerReadyState::HaveMetadata:
    case WebCore::MediaPlayerReadyState::HaveCurrentData:
    case WebCore::MediaPlayerReadyState::HaveFutureData:
    case WebCore::MediaPlayerReadyState::HaveEnoughData:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::MediaPlayerMovieLoadType>(uint8_t value)
{
    switch (static_cast<WebCore::MediaPlayerMovieLoadType>(value)) {
    case WebCore::MediaPlayerMovieLoadType::Unknown:
    case WebCore::MediaPlayerMovieLoadType::Download:
    case WebCore::MediaPlayerMovieLoadType::StoredStream:
    case WebCore::MediaPlayerMovieLoadType::LiveStream:
    case WebCore::MediaPlayerMovieLoadType::HttpLiveStream:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::MediaPlayerPreload>(uint8_t value)
{
    switch (static_cast<WebCore::MediaPlayerPreload>(value)) {
    case WebCore::MediaPlayerPreload::None:
    case WebCore::MediaPlayerPreload::MetaData:
    case WebCore::MediaPlayerPreload::Auto:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::MediaPlayerVideoGravity>(uint8_t value)
{
    switch (static_cast<WebCore::MediaPlayerVideoGravity>(value)) {
    case WebCore::MediaPlayerVideoGravity::Resize:
    case WebCore::MediaPlayerVideoGravity::ResizeAspect:
    case WebCore::MediaPlayerVideoGravity::ResizeAspectFill:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::MediaPlayerSupportsType>(uint8_t value)
{
    switch (static_cast<WebCore::MediaPlayerSupportsType>(value)) {
    case WebCore::MediaPlayerSupportsType::IsNotSupported:
    case WebCore::MediaPlayerSupportsType::IsSupported:
    case WebCore::MediaPlayerSupportsType::MayBeSupported:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::MediaPlayerBufferingPolicy>(uint8_t value)
{
    switch (static_cast<WebCore::MediaPlayerBufferingPolicy>(value)) {
    case WebCore::MediaPlayerBufferingPolicy::Default:
    case WebCore::MediaPlayerBufferingPolicy::LimitReadAhead:
    case WebCore::MediaPlayerBufferingPolicy::MakeResourcesPurgeable:
    case WebCore::MediaPlayerBufferingPolicy::PurgeResources:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::MediaPlayerMediaEngineIdentifier>(uint8_t value)
{
    switch (static_cast<WebCore::MediaPlayerMediaEngineIdentifier>(value)) {
    case WebCore::MediaPlayerMediaEngineIdentifier::AVFoundation:
    case WebCore::MediaPlayerMediaEngineIdentifier::AVFoundationMSE:
    case WebCore::MediaPlayerMediaEngineIdentifier::AVFoundationMediaStream:
    case WebCore::MediaPlayerMediaEngineIdentifier::AVFoundationCF:
    case WebCore::MediaPlayerMediaEngineIdentifier::GStreamer:
    case WebCore::MediaPlayerMediaEngineIdentifier::GStreamerMSE:
    case WebCore::MediaPlayerMediaEngineIdentifier::HolePunch:
    case WebCore::MediaPlayerMediaEngineIdentifier::MediaFoundation:
    case WebCore::MediaPlayerMediaEngineIdentifier::MockMSE:
    case WebCore::MediaPlayerMediaEngineIdentifier::CocoaWebM:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::MediaPlayerWirelessPlaybackTargetType>(uint8_t value)
{
    switch (static_cast<WebCore::MediaPlayerWirelessPlaybackTargetType>(value)) {
    case WebCore::MediaPlayerWirelessPlaybackTargetType::TargetTypeNone:
    case WebCore::MediaPlayerWirelessPlaybackTargetType::TargetTypeAirPlay:
    case WebCore::MediaPlayerWirelessPlaybackTargetType::TargetTypeTVOut:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::MediaPlayerPitchCorrectionAlgorithm>(uint8_t value)
{
    switch (static_cast<WebCore::MediaPlayerPitchCorrectionAlgorithm>(value)) {
    case WebCore::MediaPlayerPitchCorrectionAlgorithm::BestAllAround:
    case WebCore::MediaPlayerPitchCorrectionAlgorithm::BestForMusic:
    case WebCore::MediaPlayerPitchCorrectionAlgorithm::BestForSpeech:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::MediaPlayerSoundStageSize>(uint8_t value)
{
    switch (static_cast<WebCore::MediaPlayerSoundStageSize>(value)) {
    case WebCore::MediaPlayerSoundStageSize::Auto:
    case WebCore::MediaPlayerSoundStageSize::Small:
    case WebCore::MediaPlayerSoundStageSize::Medium:
    case WebCore::MediaPlayerSoundStageSize::Large:
        return true;
    default:
        return false;
    }
}

#if ENABLE(APP_HIGHLIGHTS)
template<> bool isValidEnum<WebCore::CreateNewGroupForHighlight>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(APP_HIGHLIGHTS)
template<> bool isValidEnum<WebCore::HighlightRequestOriginatedInApp>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::SpeechRecognitionUpdateType>(uint8_t value)
{
    switch (static_cast<WebCore::SpeechRecognitionUpdateType>(value)) {
    case WebCore::SpeechRecognitionUpdateType::Start:
    case WebCore::SpeechRecognitionUpdateType::AudioStart:
    case WebCore::SpeechRecognitionUpdateType::SoundStart:
    case WebCore::SpeechRecognitionUpdateType::SpeechStart:
    case WebCore::SpeechRecognitionUpdateType::SpeechEnd:
    case WebCore::SpeechRecognitionUpdateType::SoundEnd:
    case WebCore::SpeechRecognitionUpdateType::AudioEnd:
    case WebCore::SpeechRecognitionUpdateType::Result:
    case WebCore::SpeechRecognitionUpdateType::NoMatch:
    case WebCore::SpeechRecognitionUpdateType::Error:
    case WebCore::SpeechRecognitionUpdateType::End:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::CompositeOperator>(uint8_t value)
{
    switch (static_cast<WebCore::CompositeOperator>(value)) {
    case WebCore::CompositeOperator::Clear:
    case WebCore::CompositeOperator::Copy:
    case WebCore::CompositeOperator::SourceOver:
    case WebCore::CompositeOperator::SourceIn:
    case WebCore::CompositeOperator::SourceOut:
    case WebCore::CompositeOperator::SourceAtop:
    case WebCore::CompositeOperator::DestinationOver:
    case WebCore::CompositeOperator::DestinationIn:
    case WebCore::CompositeOperator::DestinationOut:
    case WebCore::CompositeOperator::DestinationAtop:
    case WebCore::CompositeOperator::XOR:
    case WebCore::CompositeOperator::PlusDarker:
    case WebCore::CompositeOperator::PlusLighter:
    case WebCore::CompositeOperator::Difference:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::BlendMode>(uint8_t value)
{
    switch (static_cast<WebCore::BlendMode>(value)) {
    case WebCore::BlendMode::Normal:
    case WebCore::BlendMode::Multiply:
    case WebCore::BlendMode::Screen:
    case WebCore::BlendMode::Darken:
    case WebCore::BlendMode::Lighten:
    case WebCore::BlendMode::Overlay:
    case WebCore::BlendMode::ColorDodge:
    case WebCore::BlendMode::ColorBurn:
    case WebCore::BlendMode::HardLight:
    case WebCore::BlendMode::SoftLight:
    case WebCore::BlendMode::Difference:
    case WebCore::BlendMode::Exclusion:
    case WebCore::BlendMode::Hue:
    case WebCore::BlendMode::Saturation:
    case WebCore::BlendMode::Color:
    case WebCore::BlendMode::Luminosity:
    case WebCore::BlendMode::PlusDarker:
    case WebCore::BlendMode::PlusLighter:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::GradientSpreadMethod>(uint8_t value)
{
    switch (static_cast<WebCore::GradientSpreadMethod>(value)) {
    case WebCore::GradientSpreadMethod::Pad:
    case WebCore::GradientSpreadMethod::Reflect:
    case WebCore::GradientSpreadMethod::Repeat:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::InterpolationQuality>(uint8_t value)
{
    switch (static_cast<WebCore::InterpolationQuality>(value)) {
    case WebCore::InterpolationQuality::Default:
    case WebCore::InterpolationQuality::DoNotInterpolate:
    case WebCore::InterpolationQuality::Low:
    case WebCore::InterpolationQuality::Medium:
    case WebCore::InterpolationQuality::High:
        return true;
    default:
        return false;
    }
}

#if ENABLE(VIDEO)
template<> bool isValidEnum<WebCore::VideoFrameRotation>(uint16_t value)
{
    switch (static_cast<WebCore::VideoFrameRotation>(value)) {
    case WebCore::VideoFrameRotation::None:
    case WebCore::VideoFrameRotation::UpsideDown:
    case WebCore::VideoFrameRotation::Right:
    case WebCore::VideoFrameRotation::Left:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::PreserveResolution>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ColorInterpolationColorSpace>(uint8_t value)
{
    switch (static_cast<WebCore::ColorInterpolationColorSpace>(value)) {
    case WebCore::ColorInterpolationColorSpace::HSL:
    case WebCore::ColorInterpolationColorSpace::HWB:
    case WebCore::ColorInterpolationColorSpace::LCH:
    case WebCore::ColorInterpolationColorSpace::Lab:
    case WebCore::ColorInterpolationColorSpace::OKLCH:
    case WebCore::ColorInterpolationColorSpace::OKLab:
    case WebCore::ColorInterpolationColorSpace::SRGB:
    case WebCore::ColorInterpolationColorSpace::SRGBLinear:
    case WebCore::ColorInterpolationColorSpace::DisplayP3:
    case WebCore::ColorInterpolationColorSpace::A98RGB:
    case WebCore::ColorInterpolationColorSpace::ProPhotoRGB:
    case WebCore::ColorInterpolationColorSpace::Rec2020:
    case WebCore::ColorInterpolationColorSpace::XYZD50:
    case WebCore::ColorInterpolationColorSpace::XYZD65:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::HueInterpolationMethod>(uint8_t value)
{
    switch (static_cast<WebCore::HueInterpolationMethod>(value)) {
    case WebCore::HueInterpolationMethod::Shorter:
    case WebCore::HueInterpolationMethod::Longer:
    case WebCore::HueInterpolationMethod::Increasing:
    case WebCore::HueInterpolationMethod::Decreasing:
        return true;
    default:
        return false;
    }
}

#if USE(AUDIO_SESSION)
template<> bool isValidEnum<WebCore::RouteSharingPolicy>(uint8_t value)
{
    switch (static_cast<WebCore::RouteSharingPolicy>(value)) {
    case WebCore::RouteSharingPolicy::Default:
    case WebCore::RouteSharingPolicy::LongFormAudio:
    case WebCore::RouteSharingPolicy::Independent:
    case WebCore::RouteSharingPolicy::LongFormVideo:
        return true;
    default:
        return false;
    }
}
#endif

#if USE(AUDIO_SESSION)
template<> bool isValidEnum<WebCore::AudioSessionCategory>(uint8_t value)
{
    switch (static_cast<WebCore::AudioSessionCategory>(value)) {
    case WebCore::AudioSessionCategory::None:
    case WebCore::AudioSessionCategory::AmbientSound:
    case WebCore::AudioSessionCategory::SoloAmbientSound:
    case WebCore::AudioSessionCategory::MediaPlayback:
    case WebCore::AudioSessionCategory::RecordAudio:
    case WebCore::AudioSessionCategory::PlayAndRecord:
    case WebCore::AudioSessionCategory::AudioProcessing:
        return true;
    default:
        return false;
    }
}
#endif

#if USE(AUDIO_SESSION)
template<> bool isValidEnum<WebCore::AudioSessionMode>(uint8_t value)
{
    switch (static_cast<WebCore::AudioSessionMode>(value)) {
    case WebCore::AudioSessionMode::Default:
    case WebCore::AudioSessionMode::VideoChat:
    case WebCore::AudioSessionMode::MoviePlayback:
        return true;
    default:
        return false;
    }
}
#endif

#if USE(AUDIO_SESSION)
template<> bool isValidEnum<WebCore::AudioSessionSoundStageSize>(uint8_t value)
{
    switch (static_cast<WebCore::AudioSessionSoundStageSize>(value)) {
    case WebCore::AudioSessionSoundStageSize::Automatic:
    case WebCore::AudioSessionSoundStageSize::Small:
    case WebCore::AudioSessionSoundStageSize::Medium:
    case WebCore::AudioSessionSoundStageSize::Large:
        return true;
    default:
        return false;
    }
}
#endif

#if USE(AUDIO_SESSION)
template<> bool isValidEnum<WebCore::AudioSessionMayResume>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if USE(AUDIO_SESSION)
template<> bool isValidEnum<WebCore::AudioSessionRoutingArbitrationError>(uint8_t value)
{
    switch (static_cast<WebCore::AudioSessionRoutingArbitrationError>(value)) {
    case WebCore::AudioSessionRoutingArbitrationError::None:
    case WebCore::AudioSessionRoutingArbitrationError::Failed:
    case WebCore::AudioSessionRoutingArbitrationError::Cancelled:
        return true;
    default:
        return false;
    }
}
#endif

#if USE(AUDIO_SESSION)
template<> bool isValidEnum<WebCore::AudioSessionRoutingArbitrationClient::DefaultRouteChanged>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(ENCRYPTED_MEDIA)
template<> bool isValidEnum<WebCore::CDMKeyStatus>(uint8_t value)
{
    switch (static_cast<WebCore::CDMKeyStatus>(value)) {
    case WebCore::CDMKeyStatus::Usable:
    case WebCore::CDMKeyStatus::Expired:
    case WebCore::CDMKeyStatus::Released:
    case WebCore::CDMKeyStatus::OutputRestricted:
    case WebCore::CDMKeyStatus::OutputDownscaled:
    case WebCore::CDMKeyStatus::StatusPending:
    case WebCore::CDMKeyStatus::InternalError:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(ENCRYPTED_MEDIA)
template<> bool isValidEnum<WebCore::CDMMessageType>(uint8_t value)
{
    switch (static_cast<WebCore::CDMMessageType>(value)) {
    case WebCore::CDMMessageType::LicenseRequest:
    case WebCore::CDMMessageType::LicenseRenewal:
    case WebCore::CDMMessageType::LicenseRelease:
    case WebCore::CDMMessageType::IndividualizationRequest:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(ENCRYPTED_MEDIA)
template<> bool isValidEnum<WebCore::CDMRequirement>(uint8_t value)
{
    switch (static_cast<WebCore::CDMRequirement>(value)) {
    case WebCore::CDMRequirement::Required:
    case WebCore::CDMRequirement::Optional:
    case WebCore::CDMRequirement::NotAllowed:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(ENCRYPTED_MEDIA)
template<> bool isValidEnum<WebCore::CDMInstanceSessionLoadFailure>(uint8_t value)
{
    switch (static_cast<WebCore::CDMInstanceSessionLoadFailure>(value)) {
    case WebCore::CDMInstanceSessionLoadFailure::None:
    case WebCore::CDMInstanceSessionLoadFailure::NoSessionData:
    case WebCore::CDMInstanceSessionLoadFailure::MismatchedSessionType:
    case WebCore::CDMInstanceSessionLoadFailure::QuotaExceeded:
    case WebCore::CDMInstanceSessionLoadFailure::Other:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(ENCRYPTED_MEDIA)
template<> bool isValidEnum<WebCore::CDMInstanceHDCPStatus>(uint8_t value)
{
    switch (static_cast<WebCore::CDMInstanceHDCPStatus>(value)) {
    case WebCore::CDMInstanceHDCPStatus::Unknown:
    case WebCore::CDMInstanceHDCPStatus::Valid:
    case WebCore::CDMInstanceHDCPStatus::OutputRestricted:
    case WebCore::CDMInstanceHDCPStatus::OutputDownscaled:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WEB_RTC)
template<> bool isValidEnum<WebCore::RTCDataChannelState>(uint8_t value)
{
    switch (static_cast<WebCore::RTCDataChannelState>(value)) {
    case WebCore::RTCDataChannelState::Connecting:
    case WebCore::RTCDataChannelState::Open:
    case WebCore::RTCDataChannelState::Closing:
    case WebCore::RTCDataChannelState::Closed:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WEB_RTC)
template<> bool isValidEnum<WebCore::RTCPriorityType>(uint8_t value)
{
    switch (static_cast<WebCore::RTCPriorityType>(value)) {
    case WebCore::RTCPriorityType::VeryLow:
    case WebCore::RTCPriorityType::Low:
    case WebCore::RTCPriorityType::Medium:
    case WebCore::RTCPriorityType::High:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::LineCap>(uint8_t value)
{
    switch (static_cast<WebCore::LineCap>(value)) {
    case WebCore::LineCap::Butt:
    case WebCore::LineCap::Round:
    case WebCore::LineCap::Square:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::LineJoin>(uint8_t value)
{
    switch (static_cast<WebCore::LineJoin>(value)) {
    case WebCore::LineJoin::Miter:
    case WebCore::LineJoin::Round:
    case WebCore::LineJoin::Bevel:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::StrokeStyle>(uint8_t value)
{
    switch (static_cast<WebCore::StrokeStyle>(value)) {
    case WebCore::StrokeStyle::NoStroke:
    case WebCore::StrokeStyle::SolidStroke:
    case WebCore::StrokeStyle::DottedStroke:
    case WebCore::StrokeStyle::DashedStroke:
    case WebCore::StrokeStyle::DoubleStroke:
    case WebCore::StrokeStyle::WavyStroke:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebCore::TextDrawingMode>(OptionSet<WebCore::TextDrawingMode> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebCore::TextDrawingMode::Fill)
        | static_cast<uint8_t>(WebCore::TextDrawingMode::Stroke)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidEnum<WebCore::DecodingMode>(uint8_t value)
{
    switch (static_cast<WebCore::DecodingMode>(value)) {
    case WebCore::DecodingMode::Auto:
    case WebCore::DecodingMode::Synchronous:
    case WebCore::DecodingMode::Asynchronous:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::DocumentMarkerLineStyleMode>(uint8_t value)
{
    switch (static_cast<WebCore::DocumentMarkerLineStyleMode>(value)) {
    case WebCore::DocumentMarkerLineStyleMode::TextCheckingDictationPhraseWithAlternatives:
    case WebCore::DocumentMarkerLineStyleMode::Spelling:
    case WebCore::DocumentMarkerLineStyleMode::Grammar:
    case WebCore::DocumentMarkerLineStyleMode::AutocorrectionReplacement:
    case WebCore::DocumentMarkerLineStyleMode::DictationAlternatives:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ShadowRadiusMode>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

#if ENABLE(VIDEO)
template<> bool isValidEnum<WebCore::GenericCueData::Alignment>(uint8_t value)
{
    switch (static_cast<WebCore::GenericCueData::Alignment>(value)) {
    case WebCore::GenericCueData::Alignment::None:
    case WebCore::GenericCueData::Alignment::Start:
    case WebCore::GenericCueData::Alignment::Middle:
    case WebCore::GenericCueData::Alignment::End:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(VIDEO)
template<> bool isValidEnum<WebCore::GenericCueData::Status>(uint8_t value)
{
    switch (static_cast<WebCore::GenericCueData::Status>(value)) {
    case WebCore::GenericCueData::Status::Uninitialized:
    case WebCore::GenericCueData::Status::Partial:
    case WebCore::GenericCueData::Status::Complete:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::ImageOrientation::Orientation>(uint8_t value)
{
    switch (static_cast<WebCore::ImageOrientation::Orientation>(value)) {
    case WebCore::ImageOrientation::Orientation::FromImage:
    case WebCore::ImageOrientation::Orientation::OriginTopLeft:
    case WebCore::ImageOrientation::Orientation::OriginTopRight:
    case WebCore::ImageOrientation::Orientation::OriginBottomRight:
    case WebCore::ImageOrientation::Orientation::OriginBottomLeft:
    case WebCore::ImageOrientation::Orientation::OriginLeftTop:
    case WebCore::ImageOrientation::Orientation::OriginRightTop:
    case WebCore::ImageOrientation::Orientation::OriginRightBottom:
    case WebCore::ImageOrientation::Orientation::OriginLeftBottom:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::DrawsHDRContent>(uint8_t value)
{
    switch (static_cast<WebCore::DrawsHDRContent>(value)) {
    case WebCore::DrawsHDRContent::No:
    case WebCore::DrawsHDRContent::Yes:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::CrossOriginOpenerPolicyValue>(uint8_t value)
{
    switch (static_cast<WebCore::CrossOriginOpenerPolicyValue>(value)) {
    case WebCore::CrossOriginOpenerPolicyValue::UnsafeNone:
    case WebCore::CrossOriginOpenerPolicyValue::SameOrigin:
    case WebCore::CrossOriginOpenerPolicyValue::SameOriginPlusCOEP:
    case WebCore::CrossOriginOpenerPolicyValue::SameOriginAllowPopups:
    case WebCore::CrossOriginOpenerPolicyValue::NoopenerAllowPopups:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::SubstituteData::SessionHistoryVisibility>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::HTTPCookieAcceptPolicy>(uint8_t value)
{
    switch (static_cast<WebCore::HTTPCookieAcceptPolicy>(value)) {
    case WebCore::HTTPCookieAcceptPolicy::AlwaysAccept:
    case WebCore::HTTPCookieAcceptPolicy::Never:
    case WebCore::HTTPCookieAcceptPolicy::OnlyFromMainDocumentDomain:
    case WebCore::HTTPCookieAcceptPolicy::ExclusivelyFromMainDocumentDomain:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::NetworkLoadPriority>(uint8_t value)
{
    switch (static_cast<WebCore::NetworkLoadPriority>(value)) {
    case WebCore::NetworkLoadPriority::Low:
    case WebCore::NetworkLoadPriority::Medium:
    case WebCore::NetworkLoadPriority::High:
    case WebCore::NetworkLoadPriority::Unknown:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::PrivacyStance>(uint8_t value)
{
    switch (static_cast<WebCore::PrivacyStance>(value)) {
    case WebCore::PrivacyStance::Unknown:
    case WebCore::PrivacyStance::NotEligible:
    case WebCore::PrivacyStance::Proxied:
    case WebCore::PrivacyStance::Failed:
    case WebCore::PrivacyStance::Direct:
    case WebCore::PrivacyStance::FailedUnreachable:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ThirdPartyCookieBlockingMode>(uint8_t value)
{
    switch (static_cast<WebCore::ThirdPartyCookieBlockingMode>(value)) {
    case WebCore::ThirdPartyCookieBlockingMode::All:
    case WebCore::ThirdPartyCookieBlockingMode::AllExceptBetweenAppBoundDomains:
    case WebCore::ThirdPartyCookieBlockingMode::AllExceptManagedDomains:
#if HAVE(ALLOW_ONLY_PARTITIONED_COOKIES)
    case WebCore::ThirdPartyCookieBlockingMode::AllExceptPartitioned:
#endif
    case WebCore::ThirdPartyCookieBlockingMode::AllOnSitesWithoutUserInteraction:
    case WebCore::ThirdPartyCookieBlockingMode::OnlyAccordingToPerDomainPolicy:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FirstPartyWebsiteDataRemovalMode>(uint8_t value)
{
    switch (static_cast<WebCore::FirstPartyWebsiteDataRemovalMode>(value)) {
    case WebCore::FirstPartyWebsiteDataRemovalMode::AllButCookies:
    case WebCore::FirstPartyWebsiteDataRemovalMode::None:
    case WebCore::FirstPartyWebsiteDataRemovalMode::AllButCookiesLiveOnTestingTimeout:
    case WebCore::FirstPartyWebsiteDataRemovalMode::AllButCookiesReproTestingTimeout:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebCore::DragApplicationFlags>(OptionSet<WebCore::DragApplicationFlags> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebCore::DragApplicationFlags::IsModal)
        | static_cast<uint8_t>(WebCore::DragApplicationFlags::IsSource)
        | static_cast<uint8_t>(WebCore::DragApplicationFlags::HasAttachedSheet)
        | static_cast<uint8_t>(WebCore::DragApplicationFlags::IsCopyKeyDown)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidOptionSet<WebCore::TextCheckingType>(OptionSet<WebCore::TextCheckingType> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebCore::TextCheckingType::None)
        | static_cast<uint8_t>(WebCore::TextCheckingType::Spelling)
        | static_cast<uint8_t>(WebCore::TextCheckingType::Grammar)
        | static_cast<uint8_t>(WebCore::TextCheckingType::Link)
        | static_cast<uint8_t>(WebCore::TextCheckingType::Quote)
        | static_cast<uint8_t>(WebCore::TextCheckingType::Dash)
        | static_cast<uint8_t>(WebCore::TextCheckingType::Replacement)
        | static_cast<uint8_t>(WebCore::TextCheckingType::Correction)
        | static_cast<uint8_t>(WebCore::TextCheckingType::ShowCorrectionPanel)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidEnum<WebCore::ServiceWorkerClientType>(uint8_t value)
{
    switch (static_cast<WebCore::ServiceWorkerClientType>(value)) {
    case WebCore::ServiceWorkerClientType::Window:
    case WebCore::ServiceWorkerClientType::Worker:
    case WebCore::ServiceWorkerClientType::Sharedworker:
    case WebCore::ServiceWorkerClientType::All:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ServiceWorkerJobType>(uint8_t value)
{
    switch (static_cast<WebCore::ServiceWorkerJobType>(value)) {
    case WebCore::ServiceWorkerJobType::Register:
    case WebCore::ServiceWorkerJobType::Unregister:
    case WebCore::ServiceWorkerJobType::Update:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ServiceWorkerRegistrationState>(uint8_t value)
{
    switch (static_cast<WebCore::ServiceWorkerRegistrationState>(value)) {
    case WebCore::ServiceWorkerRegistrationState::Installing:
    case WebCore::ServiceWorkerRegistrationState::Waiting:
    case WebCore::ServiceWorkerRegistrationState::Active:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ServiceWorkerState>(uint8_t value)
{
    switch (static_cast<WebCore::ServiceWorkerState>(value)) {
    case WebCore::ServiceWorkerState::Parsed:
    case WebCore::ServiceWorkerState::Installing:
    case WebCore::ServiceWorkerState::Installed:
    case WebCore::ServiceWorkerState::Activating:
    case WebCore::ServiceWorkerState::Activated:
    case WebCore::ServiceWorkerState::Redundant:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ServiceWorkerClientFrameType>(uint8_t value)
{
    switch (static_cast<WebCore::ServiceWorkerClientFrameType>(value)) {
    case WebCore::ServiceWorkerClientFrameType::Auxiliary:
    case WebCore::ServiceWorkerClientFrameType::TopLevel:
    case WebCore::ServiceWorkerClientFrameType::Nested:
    case WebCore::ServiceWorkerClientFrameType::None:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ServiceWorkerIsInspectable>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ShouldNotifyWhenResolved>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ServiceWorkerUpdateViaCache>(uint8_t value)
{
    switch (static_cast<WebCore::ServiceWorkerUpdateViaCache>(value)) {
    case WebCore::ServiceWorkerUpdateViaCache::Imports:
    case WebCore::ServiceWorkerUpdateViaCache::All:
    case WebCore::ServiceWorkerUpdateViaCache::None:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::LastNavigationWasAppInitiated>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::RouterSourceEnum>(uint8_t value)
{
    switch (static_cast<WebCore::RouterSourceEnum>(value)) {
    case WebCore::RouterSourceEnum::Cache:
    case WebCore::RouterSourceEnum::FetchEvent:
    case WebCore::RouterSourceEnum::Network:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::RunningStatus>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::StorageAccessWasGranted>(uint8_t value)
{
    switch (static_cast<WebCore::StorageAccessWasGranted>(value)) {
    case WebCore::StorageAccessWasGranted::No:
    case WebCore::StorageAccessWasGranted::Yes:
    case WebCore::StorageAccessWasGranted::YesWithException:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::StorageAccessPromptWasShown>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::StorageAccessScope>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::StorageAccessQuickResult>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

#if ENABLE(MEDIA_STREAM)
template<> bool isValidEnum<WebCore::MediaConstraint::DataType>(uint8_t value)
{
    switch (static_cast<WebCore::MediaConstraint::DataType>(value)) {
    case WebCore::MediaConstraint::DataType::Integer:
    case WebCore::MediaConstraint::DataType::Double:
    case WebCore::MediaConstraint::DataType::Boolean:
    case WebCore::MediaConstraint::DataType::String:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(MEDIA_STREAM)
template<> bool isValidEnum<WebCore::MediaConstraintType>(uint8_t value)
{
    switch (static_cast<WebCore::MediaConstraintType>(value)) {
    case WebCore::MediaConstraintType::Unknown:
    case WebCore::MediaConstraintType::Width:
    case WebCore::MediaConstraintType::Height:
    case WebCore::MediaConstraintType::AspectRatio:
    case WebCore::MediaConstraintType::FrameRate:
    case WebCore::MediaConstraintType::FacingMode:
    case WebCore::MediaConstraintType::Volume:
    case WebCore::MediaConstraintType::SampleRate:
    case WebCore::MediaConstraintType::SampleSize:
    case WebCore::MediaConstraintType::EchoCancellation:
    case WebCore::MediaConstraintType::DeviceId:
    case WebCore::MediaConstraintType::GroupId:
    case WebCore::MediaConstraintType::DisplaySurface:
    case WebCore::MediaConstraintType::LogicalSurface:
    case WebCore::MediaConstraintType::WhiteBalanceMode:
    case WebCore::MediaConstraintType::Zoom:
    case WebCore::MediaConstraintType::Torch:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(MEDIA_STREAM)
template<> bool isValidEnum<WebCore::RealtimeMediaSource::Type>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(MEDIA_STREAM)
template<> bool isValidEnum<WebCore::VideoFacingMode>(uint8_t value)
{
    switch (static_cast<WebCore::VideoFacingMode>(value)) {
    case WebCore::VideoFacingMode::Unknown:
    case WebCore::VideoFacingMode::User:
    case WebCore::VideoFacingMode::Environment:
    case WebCore::VideoFacingMode::Left:
    case WebCore::VideoFacingMode::Right:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(MEDIA_STREAM)
template<> bool isValidEnum<WebCore::DisplaySurfaceType>(uint8_t value)
{
    switch (static_cast<WebCore::DisplaySurfaceType>(value)) {
    case WebCore::DisplaySurfaceType::Monitor:
    case WebCore::DisplaySurfaceType::Window:
    case WebCore::DisplaySurfaceType::Application:
    case WebCore::DisplaySurfaceType::Browser:
    case WebCore::DisplaySurfaceType::Invalid:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(MEDIA_STREAM)
template<> bool isValidEnum<WebCore::MeteringMode>(uint8_t value)
{
    switch (static_cast<WebCore::MeteringMode>(value)) {
    case WebCore::MeteringMode::None:
    case WebCore::MeteringMode::Manual:
    case WebCore::MeteringMode::SingleShot:
    case WebCore::MeteringMode::Continuous:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(MEDIA_STREAM)
template<> bool isValidEnum<WebCore::CaptureDevice::DeviceType>(uint8_t value)
{
    switch (static_cast<WebCore::CaptureDevice::DeviceType>(value)) {
    case WebCore::CaptureDevice::DeviceType::Unknown:
    case WebCore::CaptureDevice::DeviceType::Microphone:
    case WebCore::CaptureDevice::DeviceType::Speaker:
    case WebCore::CaptureDevice::DeviceType::Camera:
    case WebCore::CaptureDevice::DeviceType::Screen:
    case WebCore::CaptureDevice::DeviceType::Window:
    case WebCore::CaptureDevice::DeviceType::SystemAudio:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(MEDIA_STREAM)
template<> bool isValidEnum<WebCore::RealtimeMediaSourceCapabilities::EchoCancellation>(uint8_t value)
{
    switch (static_cast<WebCore::RealtimeMediaSourceCapabilities::EchoCancellation>(value)) {
    case WebCore::RealtimeMediaSourceCapabilities::EchoCancellation::Off:
    case WebCore::RealtimeMediaSourceCapabilities::EchoCancellation::On:
    case WebCore::RealtimeMediaSourceCapabilities::EchoCancellation::OnOrOff:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(MEDIA_STREAM)
template<> bool isValidEnum<WebCore::RealtimeMediaSourceCapabilities::BackgroundBlur>(uint8_t value)
{
    switch (static_cast<WebCore::RealtimeMediaSourceCapabilities::BackgroundBlur>(value)) {
    case WebCore::RealtimeMediaSourceCapabilities::BackgroundBlur::Off:
    case WebCore::RealtimeMediaSourceCapabilities::BackgroundBlur::On:
    case WebCore::RealtimeMediaSourceCapabilities::BackgroundBlur::OnOff:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(MEDIA_STREAM)
template<> bool isValidOptionSet<WebCore::MockMediaDevice::Flag>(OptionSet<WebCore::MockMediaDevice::Flag> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebCore::MockMediaDevice::Flag::Ephemeral)
        | static_cast<uint8_t>(WebCore::MockMediaDevice::Flag::Invalid)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}
#endif

template<> bool isValidEnum<WebCore::PlatformVideoColorPrimaries>(uint8_t value)
{
    switch (static_cast<WebCore::PlatformVideoColorPrimaries>(value)) {
    case WebCore::PlatformVideoColorPrimaries::Bt709:
    case WebCore::PlatformVideoColorPrimaries::Bt470bg:
    case WebCore::PlatformVideoColorPrimaries::Smpte170m:
    case WebCore::PlatformVideoColorPrimaries::Bt470m:
    case WebCore::PlatformVideoColorPrimaries::Smpte240m:
    case WebCore::PlatformVideoColorPrimaries::Film:
    case WebCore::PlatformVideoColorPrimaries::Bt2020:
    case WebCore::PlatformVideoColorPrimaries::SmpteSt4281:
    case WebCore::PlatformVideoColorPrimaries::SmpteRp431:
    case WebCore::PlatformVideoColorPrimaries::SmpteEg432:
    case WebCore::PlatformVideoColorPrimaries::JedecP22Phosphors:
    case WebCore::PlatformVideoColorPrimaries::Unspecified:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::PlatformVideoTransferCharacteristics>(uint8_t value)
{
    switch (static_cast<WebCore::PlatformVideoTransferCharacteristics>(value)) {
    case WebCore::PlatformVideoTransferCharacteristics::Bt709:
    case WebCore::PlatformVideoTransferCharacteristics::Smpte170m:
    case WebCore::PlatformVideoTransferCharacteristics::Iec6196621:
    case WebCore::PlatformVideoTransferCharacteristics::Gamma22curve:
    case WebCore::PlatformVideoTransferCharacteristics::Gamma28curve:
    case WebCore::PlatformVideoTransferCharacteristics::Smpte240m:
    case WebCore::PlatformVideoTransferCharacteristics::Linear:
    case WebCore::PlatformVideoTransferCharacteristics::Log:
    case WebCore::PlatformVideoTransferCharacteristics::LogSqrt:
    case WebCore::PlatformVideoTransferCharacteristics::Iec6196624:
    case WebCore::PlatformVideoTransferCharacteristics::Bt1361ExtendedColourGamut:
    case WebCore::PlatformVideoTransferCharacteristics::Bt2020_10bit:
    case WebCore::PlatformVideoTransferCharacteristics::Bt2020_12bit:
    case WebCore::PlatformVideoTransferCharacteristics::SmpteSt2084:
    case WebCore::PlatformVideoTransferCharacteristics::SmpteSt4281:
    case WebCore::PlatformVideoTransferCharacteristics::AribStdB67Hlg:
    case WebCore::PlatformVideoTransferCharacteristics::Unspecified:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::PlatformVideoMatrixCoefficients>(uint8_t value)
{
    switch (static_cast<WebCore::PlatformVideoMatrixCoefficients>(value)) {
    case WebCore::PlatformVideoMatrixCoefficients::Rgb:
    case WebCore::PlatformVideoMatrixCoefficients::Bt709:
    case WebCore::PlatformVideoMatrixCoefficients::Bt470bg:
    case WebCore::PlatformVideoMatrixCoefficients::Smpte170m:
    case WebCore::PlatformVideoMatrixCoefficients::Smpte240m:
    case WebCore::PlatformVideoMatrixCoefficients::Fcc:
    case WebCore::PlatformVideoMatrixCoefficients::YCgCo:
    case WebCore::PlatformVideoMatrixCoefficients::Bt2020NonconstantLuminance:
    case WebCore::PlatformVideoMatrixCoefficients::Bt2020ConstantLuminance:
    case WebCore::PlatformVideoMatrixCoefficients::Unspecified:
        return true;
    default:
        return false;
    }
}

#if ENABLE(VIDEO)
template<> bool isValidEnum<WebCore::VideoProjectionMetadataKind>(uint8_t value)
{
    switch (static_cast<WebCore::VideoProjectionMetadataKind>(value)) {
    case WebCore::VideoProjectionMetadataKind::Unknown:
    case WebCore::VideoProjectionMetadataKind::Equirectangular:
    case WebCore::VideoProjectionMetadataKind::HalfEquirectangular:
    case WebCore::VideoProjectionMetadataKind::EquiAngularCubemap:
    case WebCore::VideoProjectionMetadataKind::Parametric:
    case WebCore::VideoProjectionMetadataKind::Pyramid:
    case WebCore::VideoProjectionMetadataKind::AppleImmersiveVideo:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::PolicyAction>(uint8_t value)
{
    switch (static_cast<WebCore::PolicyAction>(value)) {
    case WebCore::PolicyAction::Use:
    case WebCore::PolicyAction::Download:
    case WebCore::PolicyAction::Ignore:
    case WebCore::PolicyAction::LoadWillContinueInAnotherProcess:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebCore::ReloadOption>(OptionSet<WebCore::ReloadOption> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebCore::ReloadOption::ExpiredOnly)
        | static_cast<uint8_t>(WebCore::ReloadOption::FromOrigin)
        | static_cast<uint8_t>(WebCore::ReloadOption::DisableContentBlockers)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidEnum<WebCore::FrameLoadType>(uint8_t value)
{
    switch (static_cast<WebCore::FrameLoadType>(value)) {
    case WebCore::FrameLoadType::Standard:
    case WebCore::FrameLoadType::Back:
    case WebCore::FrameLoadType::Forward:
    case WebCore::FrameLoadType::IndexedBackForward:
    case WebCore::FrameLoadType::Reload:
    case WebCore::FrameLoadType::Same:
    case WebCore::FrameLoadType::RedirectWithLockedBackForwardList:
    case WebCore::FrameLoadType::Replace:
    case WebCore::FrameLoadType::ReloadFromOrigin:
    case WebCore::FrameLoadType::ReloadExpiredOnly:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::NavigationType>(uint8_t value)
{
    switch (static_cast<WebCore::NavigationType>(value)) {
    case WebCore::NavigationType::LinkClicked:
    case WebCore::NavigationType::FormSubmitted:
    case WebCore::NavigationType::BackForward:
    case WebCore::NavigationType::Reload:
    case WebCore::NavigationType::FormResubmitted:
    case WebCore::NavigationType::Other:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::BrowsingContextGroupSwitchDecision>(uint8_t value)
{
    switch (static_cast<WebCore::BrowsingContextGroupSwitchDecision>(value)) {
    case WebCore::BrowsingContextGroupSwitchDecision::StayInGroup:
    case WebCore::BrowsingContextGroupSwitchDecision::NewSharedGroup:
    case WebCore::BrowsingContextGroupSwitchDecision::NewIsolatedGroup:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ShouldOpenExternalURLsPolicy>(uint8_t value)
{
    switch (static_cast<WebCore::ShouldOpenExternalURLsPolicy>(value)) {
    case WebCore::ShouldOpenExternalURLsPolicy::ShouldNotAllow:
    case WebCore::ShouldOpenExternalURLsPolicy::ShouldAllowExternalSchemesButNotAppLinks:
    case WebCore::ShouldOpenExternalURLsPolicy::ShouldAllow:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ScheduleLocationChangeResult>(uint8_t value)
{
    switch (static_cast<WebCore::ScheduleLocationChangeResult>(value)) {
    case WebCore::ScheduleLocationChangeResult::Stopped:
    case WebCore::ScheduleLocationChangeResult::Completed:
    case WebCore::ScheduleLocationChangeResult::Started:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::MouseEventPolicy>(uint8_t value)
{
    switch (static_cast<WebCore::MouseEventPolicy>(value)) {
    case WebCore::MouseEventPolicy::Default:
#if ENABLE(IOS_TOUCH_EVENTS)
    case WebCore::MouseEventPolicy::SynthesizeTouchEvents:
#endif
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ColorSchemePreference>(uint8_t value)
{
    switch (static_cast<WebCore::ColorSchemePreference>(value)) {
    case WebCore::ColorSchemePreference::NoPreference:
    case WebCore::ColorSchemePreference::Light:
    case WebCore::ColorSchemePreference::Dark:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ModalContainerObservationPolicy>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::AllowsContentJavaScript>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebCore::AdvancedPrivacyProtections>(OptionSet<WebCore::AdvancedPrivacyProtections> value)
{
    constexpr uint16_t allValidBitsValue = 0
        | static_cast<uint16_t>(WebCore::AdvancedPrivacyProtections::BaselineProtections)
        | static_cast<uint16_t>(WebCore::AdvancedPrivacyProtections::HTTPSFirst)
        | static_cast<uint16_t>(WebCore::AdvancedPrivacyProtections::HTTPSOnly)
        | static_cast<uint16_t>(WebCore::AdvancedPrivacyProtections::HTTPSOnlyExplicitlyBypassedForDomain)
        | static_cast<uint16_t>(WebCore::AdvancedPrivacyProtections::FailClosedForUnreachableHosts)
        | static_cast<uint16_t>(WebCore::AdvancedPrivacyProtections::WebSearchContent)
        | static_cast<uint16_t>(WebCore::AdvancedPrivacyProtections::FingerprintingProtections)
        | static_cast<uint16_t>(WebCore::AdvancedPrivacyProtections::EnhancedNetworkPrivacy)
        | static_cast<uint16_t>(WebCore::AdvancedPrivacyProtections::LinkDecorationFiltering)
        | static_cast<uint16_t>(WebCore::AdvancedPrivacyProtections::ScriptTrackingPrivacy)
        | static_cast<uint16_t>(WebCore::AdvancedPrivacyProtections::FailClosedForAllHosts)
        | static_cast<uint16_t>(WebCore::AdvancedPrivacyProtections::StrictFailClosed)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidEnum<WebCore::ViolationReportType>(uint8_t value)
{
    switch (static_cast<WebCore::ViolationReportType>(value)) {
    case WebCore::ViolationReportType::COEPInheritenceViolation:
    case WebCore::ViolationReportType::CORPViolation:
    case WebCore::ViolationReportType::ContentSecurityPolicy:
    case WebCore::ViolationReportType::CrossOriginOpenerPolicy:
    case WebCore::ViolationReportType::Deprecation:
    case WebCore::ViolationReportType::StandardReportingAPIViolation:
    case WebCore::ViolationReportType::Test:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::COEPDisposition>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::LinkIconType>(uint8_t value)
{
    switch (static_cast<WebCore::LinkIconType>(value)) {
    case WebCore::LinkIconType::Favicon:
    case WebCore::LinkIconType::TouchIcon:
    case WebCore::LinkIconType::TouchPrecomposedIcon:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::PasteboardItemPresentationStyle>(uint8_t value)
{
    switch (static_cast<WebCore::PasteboardItemPresentationStyle>(value)) {
    case WebCore::PasteboardItemPresentationStyle::Unspecified:
    case WebCore::PasteboardItemPresentationStyle::Inline:
    case WebCore::PasteboardItemPresentationStyle::Attachment:
        return true;
    default:
        return false;
    }
}

#if HAVE(SCREEN_CAPTURE_KIT)
template<> bool isValidEnum<WebCore::DisplayCapturePromptType>(uint8_t value)
{
    switch (static_cast<WebCore::DisplayCapturePromptType>(value)) {
    case WebCore::DisplayCapturePromptType::Window:
    case WebCore::DisplayCapturePromptType::Screen:
    case WebCore::DisplayCapturePromptType::UserChoose:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::TextIndicatorPresentationTransition>(uint8_t value)
{
    switch (static_cast<WebCore::TextIndicatorPresentationTransition>(value)) {
    case WebCore::TextIndicatorPresentationTransition::None:
    case WebCore::TextIndicatorPresentationTransition::Bounce:
    case WebCore::TextIndicatorPresentationTransition::BounceAndCrossfade:
    case WebCore::TextIndicatorPresentationTransition::FadeIn:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebCore::TextIndicatorOption>(OptionSet<WebCore::TextIndicatorOption> value)
{
    constexpr uint16_t allValidBitsValue = 0
        | static_cast<uint16_t>(WebCore::TextIndicatorOption::RespectTextColor)
        | static_cast<uint16_t>(WebCore::TextIndicatorOption::PaintBackgrounds)
        | static_cast<uint16_t>(WebCore::TextIndicatorOption::PaintAllContent)
        | static_cast<uint16_t>(WebCore::TextIndicatorOption::IncludeSnapshotWithSelectionHighlight)
        | static_cast<uint16_t>(WebCore::TextIndicatorOption::TightlyFitContent)
        | static_cast<uint16_t>(WebCore::TextIndicatorOption::UseBoundingRectAndPaintAllContentForComplexRanges)
        | static_cast<uint16_t>(WebCore::TextIndicatorOption::IncludeMarginIfRangeMatchesSelection)
        | static_cast<uint16_t>(WebCore::TextIndicatorOption::ExpandClipBeyondVisibleRect)
        | static_cast<uint16_t>(WebCore::TextIndicatorOption::DoNotClipToVisibleRect)
        | static_cast<uint16_t>(WebCore::TextIndicatorOption::IncludeSnapshotOfAllVisibleContentWithoutSelection)
        | static_cast<uint16_t>(WebCore::TextIndicatorOption::UseSelectionRectForSizing)
        | static_cast<uint16_t>(WebCore::TextIndicatorOption::ComputeEstimatedBackgroundColor)
        | static_cast<uint16_t>(WebCore::TextIndicatorOption::UseUserSelectAllCommonAncestor)
        | static_cast<uint16_t>(WebCore::TextIndicatorOption::SkipReplacedContent)
        | static_cast<uint16_t>(WebCore::TextIndicatorOption::SnapshotContentAt3xBaseScale)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidEnum<WebCore::InteractionRegion::Type>(uint8_t value)
{
    switch (static_cast<WebCore::InteractionRegion::Type>(value)) {
    case WebCore::InteractionRegion::Type::Interaction:
    case WebCore::InteractionRegion::Type::Occlusion:
    case WebCore::InteractionRegion::Type::Guard:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebCore::InteractionRegion::CornerMask>(OptionSet<WebCore::InteractionRegion::CornerMask> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebCore::InteractionRegion::CornerMask::MinXMinYCorner)
        | static_cast<uint8_t>(WebCore::InteractionRegion::CornerMask::MaxXMinYCorner)
        | static_cast<uint8_t>(WebCore::InteractionRegion::CornerMask::MinXMaxYCorner)
        | static_cast<uint8_t>(WebCore::InteractionRegion::CornerMask::MaxXMaxYCorner)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidEnum<WebCore::InteractionRegion::ContentHint>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

#if ENABLE(WEB_AUTHN)
template<> bool isValidEnum<WebCore::MockWebAuthenticationConfiguration::UserVerification>(uint8_t value)
{
    switch (static_cast<WebCore::MockWebAuthenticationConfiguration::UserVerification>(value)) {
    case WebCore::MockWebAuthenticationConfiguration::UserVerification::No:
    case WebCore::MockWebAuthenticationConfiguration::UserVerification::Yes:
    case WebCore::MockWebAuthenticationConfiguration::UserVerification::Cancel:
    case WebCore::MockWebAuthenticationConfiguration::UserVerification::Presence:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WEB_AUTHN)
template<> bool isValidEnum<WebCore::MockWebAuthenticationConfiguration::HidStage>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WEB_AUTHN)
template<> bool isValidEnum<WebCore::MockWebAuthenticationConfiguration::HidSubStage>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WEB_AUTHN)
template<> bool isValidEnum<WebCore::MockWebAuthenticationConfiguration::HidError>(uint8_t value)
{
    switch (static_cast<WebCore::MockWebAuthenticationConfiguration::HidError>(value)) {
    case WebCore::MockWebAuthenticationConfiguration::HidError::Success:
    case WebCore::MockWebAuthenticationConfiguration::HidError::DataNotSent:
    case WebCore::MockWebAuthenticationConfiguration::HidError::EmptyReport:
    case WebCore::MockWebAuthenticationConfiguration::HidError::WrongChannelId:
    case WebCore::MockWebAuthenticationConfiguration::HidError::MaliciousPayload:
    case WebCore::MockWebAuthenticationConfiguration::HidError::UnsupportedOptions:
    case WebCore::MockWebAuthenticationConfiguration::HidError::WrongNonce:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WEB_AUTHN)
template<> bool isValidEnum<WebCore::MockWebAuthenticationConfiguration::NfcError>(uint8_t value)
{
    switch (static_cast<WebCore::MockWebAuthenticationConfiguration::NfcError>(value)) {
    case WebCore::MockWebAuthenticationConfiguration::NfcError::Success:
    case WebCore::MockWebAuthenticationConfiguration::NfcError::NoTags:
    case WebCore::MockWebAuthenticationConfiguration::NfcError::WrongTagType:
    case WebCore::MockWebAuthenticationConfiguration::NfcError::NoConnections:
    case WebCore::MockWebAuthenticationConfiguration::NfcError::MaliciousPayload:
        return true;
    default:
        return false;
    }
}
#endif

#if (ENABLE(WEB_AUTHN)) && (HAVE(DIGITAL_CREDENTIALS_UI))
template<> bool isValidEnum<WebCore::IdentityCredentialProtocol>(uint8_t value)
{
    switch (static_cast<WebCore::IdentityCredentialProtocol>(value)) {
    case WebCore::IdentityCredentialProtocol::Openid4vp:
    case WebCore::IdentityCredentialProtocol::OrgIsoMdoc:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(MEDIA_STREAM)
template<> bool isValidEnum<WebCore::MockMediaDevice::Flag>(uint8_t value)
{
    switch (static_cast<WebCore::MockMediaDevice::Flag>(value)) {
    case WebCore::MockMediaDevice::Flag::Ephemeral:
    case WebCore::MockMediaDevice::Flag::Invalid:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::StorageType>(uint8_t value)
{
    switch (static_cast<WebCore::StorageType>(value)) {
    case WebCore::StorageType::Session:
    case WebCore::StorageType::Local:
    case WebCore::StorageType::TransientLocal:
        return true;
    default:
        return false;
    }
}

#if ENABLE(THREADED_ANIMATION_RESOLUTION)
template<> bool isValidEnum<WebCore::TransformBox>(uint8_t value)
{
    switch (static_cast<WebCore::TransformBox>(value)) {
    case WebCore::TransformBox::StrokeBox:
    case WebCore::TransformBox::ContentBox:
    case WebCore::TransformBox::BorderBox:
    case WebCore::TransformBox::FillBox:
    case WebCore::TransformBox::ViewBox:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(THREADED_ANIMATION_RESOLUTION)
template<> bool isValidOptionSet<WebCore::AcceleratedEffectProperty>(OptionSet<WebCore::AcceleratedEffectProperty> value)
{
    constexpr uint16_t allValidBitsValue = 0
        | static_cast<uint16_t>(WebCore::AcceleratedEffectProperty::Opacity)
        | static_cast<uint16_t>(WebCore::AcceleratedEffectProperty::Transform)
        | static_cast<uint16_t>(WebCore::AcceleratedEffectProperty::Translate)
        | static_cast<uint16_t>(WebCore::AcceleratedEffectProperty::Rotate)
        | static_cast<uint16_t>(WebCore::AcceleratedEffectProperty::Scale)
        | static_cast<uint16_t>(WebCore::AcceleratedEffectProperty::OffsetPath)
        | static_cast<uint16_t>(WebCore::AcceleratedEffectProperty::OffsetDistance)
        | static_cast<uint16_t>(WebCore::AcceleratedEffectProperty::OffsetPosition)
        | static_cast<uint16_t>(WebCore::AcceleratedEffectProperty::OffsetAnchor)
        | static_cast<uint16_t>(WebCore::AcceleratedEffectProperty::OffsetRotate)
        | static_cast<uint16_t>(WebCore::AcceleratedEffectProperty::Filter)
        | static_cast<uint16_t>(WebCore::AcceleratedEffectProperty::BackdropFilter)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}
#endif

#if ENABLE(THREADED_ANIMATION_RESOLUTION)
template<> bool isValidEnum<WebCore::WebAnimationType>(uint8_t value)
{
    switch (static_cast<WebCore::WebAnimationType>(value)) {
    case WebCore::WebAnimationType::CSSAnimation:
    case WebCore::WebAnimationType::CSSTransition:
    case WebCore::WebAnimationType::WebAnimation:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(THREADED_ANIMATION_RESOLUTION)
template<> bool isValidEnum<WebCore::FillMode>(uint8_t value)
{
    switch (static_cast<WebCore::FillMode>(value)) {
    case WebCore::FillMode::None:
    case WebCore::FillMode::Forwards:
    case WebCore::FillMode::Backwards:
    case WebCore::FillMode::Both:
    case WebCore::FillMode::Auto:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(THREADED_ANIMATION_RESOLUTION)
template<> bool isValidEnum<WebCore::PlaybackDirection>(uint8_t value)
{
    switch (static_cast<WebCore::PlaybackDirection>(value)) {
    case WebCore::PlaybackDirection::Normal:
    case WebCore::PlaybackDirection::Reverse:
    case WebCore::PlaybackDirection::Alternate:
    case WebCore::PlaybackDirection::AlternateReverse:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(THREADED_ANIMATION_RESOLUTION)
template<> bool isValidEnum<WebCore::CompositeOperation>(uint8_t value)
{
    switch (static_cast<WebCore::CompositeOperation>(value)) {
    case WebCore::CompositeOperation::Replace:
    case WebCore::CompositeOperation::Add:
    case WebCore::CompositeOperation::Accumulate:
        return true;
    default:
        return false;
    }
}
#endif

#if PLATFORM(MAC)
template<> bool isValidEnum<WebCore::CaretAnimatorType>(uint8_t value)
{
    switch (static_cast<WebCore::CaretAnimatorType>(value)) {
    case WebCore::CaretAnimatorType::Default:
    case WebCore::CaretAnimatorType::Dictation:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(GPU_PROCESS)
template<> bool isValidEnum<WebCore::ShapeDetection::BarcodeFormat>(uint8_t value)
{
    switch (static_cast<WebCore::ShapeDetection::BarcodeFormat>(value)) {
    case WebCore::ShapeDetection::BarcodeFormat::Aztec:
    case WebCore::ShapeDetection::BarcodeFormat::Code_128:
    case WebCore::ShapeDetection::BarcodeFormat::Code_39:
    case WebCore::ShapeDetection::BarcodeFormat::Code_93:
    case WebCore::ShapeDetection::BarcodeFormat::Codabar:
    case WebCore::ShapeDetection::BarcodeFormat::Data_matrix:
    case WebCore::ShapeDetection::BarcodeFormat::Ean_13:
    case WebCore::ShapeDetection::BarcodeFormat::Ean_8:
    case WebCore::ShapeDetection::BarcodeFormat::Itf:
    case WebCore::ShapeDetection::BarcodeFormat::Pdf417:
    case WebCore::ShapeDetection::BarcodeFormat::Qr_code:
    case WebCore::ShapeDetection::BarcodeFormat::Unknown:
    case WebCore::ShapeDetection::BarcodeFormat::Upc_a:
    case WebCore::ShapeDetection::BarcodeFormat::Upc_e:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(GPU_PROCESS)
template<> bool isValidEnum<WebCore::ShapeDetection::LandmarkType>(uint8_t value)
{
    switch (static_cast<WebCore::ShapeDetection::LandmarkType>(value)) {
    case WebCore::ShapeDetection::LandmarkType::Mouth:
    case WebCore::ShapeDetection::LandmarkType::Eye:
    case WebCore::ShapeDetection::LandmarkType::Nose:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidOptionSet<WebCore::RenderAsTextFlag>(OptionSet<WebCore::RenderAsTextFlag> value)
{
    constexpr uint16_t allValidBitsValue = 0
        | static_cast<uint16_t>(WebCore::RenderAsTextFlag::ShowAllLayers)
        | static_cast<uint16_t>(WebCore::RenderAsTextFlag::ShowLayerNesting)
        | static_cast<uint16_t>(WebCore::RenderAsTextFlag::ShowCompositedLayers)
        | static_cast<uint16_t>(WebCore::RenderAsTextFlag::ShowOverflow)
        | static_cast<uint16_t>(WebCore::RenderAsTextFlag::ShowSVGGeometry)
        | static_cast<uint16_t>(WebCore::RenderAsTextFlag::ShowLayerFragments)
        | static_cast<uint16_t>(WebCore::RenderAsTextFlag::ShowAddresses)
        | static_cast<uint16_t>(WebCore::RenderAsTextFlag::ShowIDAndClass)
        | static_cast<uint16_t>(WebCore::RenderAsTextFlag::PrintingMode)
        | static_cast<uint16_t>(WebCore::RenderAsTextFlag::DontUpdateLayout)
        | static_cast<uint16_t>(WebCore::RenderAsTextFlag::ShowLayoutState)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidOptionSet<WebCore::LayerTreeAsTextOptions>(OptionSet<WebCore::LayerTreeAsTextOptions> value)
{
    constexpr uint16_t allValidBitsValue = 0
        | static_cast<uint16_t>(WebCore::LayerTreeAsTextOptions::Debug)
        | static_cast<uint16_t>(WebCore::LayerTreeAsTextOptions::IncludeVisibleRects)
        | static_cast<uint16_t>(WebCore::LayerTreeAsTextOptions::IncludeTileCaches)
        | static_cast<uint16_t>(WebCore::LayerTreeAsTextOptions::IncludeRepaintRects)
        | static_cast<uint16_t>(WebCore::LayerTreeAsTextOptions::IncludePaintingPhases)
        | static_cast<uint16_t>(WebCore::LayerTreeAsTextOptions::IncludeContentLayers)
        | static_cast<uint16_t>(WebCore::LayerTreeAsTextOptions::IncludePageOverlayLayers)
        | static_cast<uint16_t>(WebCore::LayerTreeAsTextOptions::IncludeAcceleratesDrawing)
        | static_cast<uint16_t>(WebCore::LayerTreeAsTextOptions::IncludeClipping)
        | static_cast<uint16_t>(WebCore::LayerTreeAsTextOptions::IncludeBackingStoreAttached)
        | static_cast<uint16_t>(WebCore::LayerTreeAsTextOptions::IncludeRootLayerProperties)
        | static_cast<uint16_t>(WebCore::LayerTreeAsTextOptions::IncludeEventRegion)
        | static_cast<uint16_t>(WebCore::LayerTreeAsTextOptions::IncludeExtendedColor)
        | static_cast<uint16_t>(WebCore::LayerTreeAsTextOptions::IncludeDeviceScale)
        | static_cast<uint16_t>(WebCore::LayerTreeAsTextOptions::IncludeRootLayers)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidEnum<WebCore::TextExtraction::ContainerType>(uint8_t value)
{
    switch (static_cast<WebCore::TextExtraction::ContainerType>(value)) {
    case WebCore::TextExtraction::ContainerType::Root:
    case WebCore::TextExtraction::ContainerType::ViewportConstrained:
    case WebCore::TextExtraction::ContainerType::List:
    case WebCore::TextExtraction::ContainerType::ListItem:
    case WebCore::TextExtraction::ContainerType::BlockQuote:
    case WebCore::TextExtraction::ContainerType::Article:
    case WebCore::TextExtraction::ContainerType::Section:
    case WebCore::TextExtraction::ContainerType::Nav:
    case WebCore::TextExtraction::ContainerType::Button:
        return true;
    default:
        return false;
    }
}

#if ENABLE(WRITING_TOOLS)
template<> bool isValidEnum<WebCore::WritingTools::Behavior>(uint8_t value)
{
    switch (static_cast<WebCore::WritingTools::Behavior>(value)) {
    case WebCore::WritingTools::Behavior::None:
    case WebCore::WritingTools::Behavior::Default:
    case WebCore::WritingTools::Behavior::Limited:
    case WebCore::WritingTools::Behavior::Complete:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WRITING_TOOLS)
template<> bool isValidEnum<WebCore::WritingTools::Action>(uint8_t value)
{
    switch (static_cast<WebCore::WritingTools::Action>(value)) {
    case WebCore::WritingTools::Action::ShowOriginal:
    case WebCore::WritingTools::Action::ShowRewritten:
    case WebCore::WritingTools::Action::Restart:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WRITING_TOOLS)
template<> bool isValidEnum<WebCore::WritingTools::SessionType>(uint8_t value)
{
    switch (static_cast<WebCore::WritingTools::SessionType>(value)) {
    case WebCore::WritingTools::SessionType::Proofreading:
    case WebCore::WritingTools::SessionType::Composition:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WRITING_TOOLS)
template<> bool isValidEnum<WebCore::WritingTools::SessionCompositionType>(uint8_t value)
{
    switch (static_cast<WebCore::WritingTools::SessionCompositionType>(value)) {
    case WebCore::WritingTools::SessionCompositionType::None:
    case WebCore::WritingTools::SessionCompositionType::Compose:
    case WebCore::WritingTools::SessionCompositionType::SmartReply:
    case WebCore::WritingTools::SessionCompositionType::Other:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WRITING_TOOLS)
template<> bool isValidEnum<WebCore::WritingTools::TextSuggestionState>(uint8_t value)
{
    switch (static_cast<WebCore::WritingTools::TextSuggestionState>(value)) {
    case WebCore::WritingTools::TextSuggestionState::Pending:
    case WebCore::WritingTools::TextSuggestionState::Reviewing:
    case WebCore::WritingTools::TextSuggestionState::Rejected:
    case WebCore::WritingTools::TextSuggestionState::Invalid:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::WebGPU::TextureFormat>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::TextureFormat>(value)) {
    case WebCore::WebGPU::TextureFormat::R8unorm:
    case WebCore::WebGPU::TextureFormat::R8snorm:
    case WebCore::WebGPU::TextureFormat::R8uint:
    case WebCore::WebGPU::TextureFormat::R8sint:
    case WebCore::WebGPU::TextureFormat::R16uint:
    case WebCore::WebGPU::TextureFormat::R16sint:
    case WebCore::WebGPU::TextureFormat::R16float:
    case WebCore::WebGPU::TextureFormat::Rg8unorm:
    case WebCore::WebGPU::TextureFormat::Rg8snorm:
    case WebCore::WebGPU::TextureFormat::Rg8uint:
    case WebCore::WebGPU::TextureFormat::Rg8sint:
    case WebCore::WebGPU::TextureFormat::R32uint:
    case WebCore::WebGPU::TextureFormat::R32sint:
    case WebCore::WebGPU::TextureFormat::R32float:
    case WebCore::WebGPU::TextureFormat::Rg16uint:
    case WebCore::WebGPU::TextureFormat::Rg16sint:
    case WebCore::WebGPU::TextureFormat::Rg16float:
    case WebCore::WebGPU::TextureFormat::Rgba8unorm:
    case WebCore::WebGPU::TextureFormat::Rgba8unormSRGB:
    case WebCore::WebGPU::TextureFormat::Rgba8snorm:
    case WebCore::WebGPU::TextureFormat::Rgba8uint:
    case WebCore::WebGPU::TextureFormat::Rgba8sint:
    case WebCore::WebGPU::TextureFormat::Bgra8unorm:
    case WebCore::WebGPU::TextureFormat::Bgra8unormSRGB:
    case WebCore::WebGPU::TextureFormat::Rgb9e5ufloat:
    case WebCore::WebGPU::TextureFormat::Rgb10a2uint:
    case WebCore::WebGPU::TextureFormat::Rgb10a2unorm:
    case WebCore::WebGPU::TextureFormat::Rg11b10ufloat:
    case WebCore::WebGPU::TextureFormat::Rg32uint:
    case WebCore::WebGPU::TextureFormat::Rg32sint:
    case WebCore::WebGPU::TextureFormat::Rg32float:
    case WebCore::WebGPU::TextureFormat::Rgba16uint:
    case WebCore::WebGPU::TextureFormat::Rgba16sint:
    case WebCore::WebGPU::TextureFormat::Rgba16float:
    case WebCore::WebGPU::TextureFormat::Rgba32uint:
    case WebCore::WebGPU::TextureFormat::Rgba32sint:
    case WebCore::WebGPU::TextureFormat::Rgba32float:
    case WebCore::WebGPU::TextureFormat::Stencil8:
    case WebCore::WebGPU::TextureFormat::Depth16unorm:
    case WebCore::WebGPU::TextureFormat::Depth24plus:
    case WebCore::WebGPU::TextureFormat::Depth24plusStencil8:
    case WebCore::WebGPU::TextureFormat::Depth32float:
    case WebCore::WebGPU::TextureFormat::Depth32floatStencil8:
    case WebCore::WebGPU::TextureFormat::Bc1RgbaUnorm:
    case WebCore::WebGPU::TextureFormat::Bc1RgbaUnormSRGB:
    case WebCore::WebGPU::TextureFormat::Bc2RgbaUnorm:
    case WebCore::WebGPU::TextureFormat::Bc2RgbaUnormSRGB:
    case WebCore::WebGPU::TextureFormat::Bc3RgbaUnorm:
    case WebCore::WebGPU::TextureFormat::Bc3RgbaUnormSRGB:
    case WebCore::WebGPU::TextureFormat::Bc4RUnorm:
    case WebCore::WebGPU::TextureFormat::Bc4RSnorm:
    case WebCore::WebGPU::TextureFormat::Bc5RgUnorm:
    case WebCore::WebGPU::TextureFormat::Bc5RgSnorm:
    case WebCore::WebGPU::TextureFormat::Bc6hRgbUfloat:
    case WebCore::WebGPU::TextureFormat::Bc6hRgbFloat:
    case WebCore::WebGPU::TextureFormat::Bc7RgbaUnorm:
    case WebCore::WebGPU::TextureFormat::Bc7RgbaUnormSRGB:
    case WebCore::WebGPU::TextureFormat::Etc2Rgb8unorm:
    case WebCore::WebGPU::TextureFormat::Etc2Rgb8unormSRGB:
    case WebCore::WebGPU::TextureFormat::Etc2Rgb8a1unorm:
    case WebCore::WebGPU::TextureFormat::Etc2Rgb8a1unormSRGB:
    case WebCore::WebGPU::TextureFormat::Etc2Rgba8unorm:
    case WebCore::WebGPU::TextureFormat::Etc2Rgba8unormSRGB:
    case WebCore::WebGPU::TextureFormat::EacR11unorm:
    case WebCore::WebGPU::TextureFormat::EacR11snorm:
    case WebCore::WebGPU::TextureFormat::EacRg11unorm:
    case WebCore::WebGPU::TextureFormat::EacRg11snorm:
    case WebCore::WebGPU::TextureFormat::Astc4x4Unorm:
    case WebCore::WebGPU::TextureFormat::Astc4x4UnormSRGB:
    case WebCore::WebGPU::TextureFormat::Astc5x4Unorm:
    case WebCore::WebGPU::TextureFormat::Astc5x4UnormSRGB:
    case WebCore::WebGPU::TextureFormat::Astc5x5Unorm:
    case WebCore::WebGPU::TextureFormat::Astc5x5UnormSRGB:
    case WebCore::WebGPU::TextureFormat::Astc6x5Unorm:
    case WebCore::WebGPU::TextureFormat::Astc6x5UnormSRGB:
    case WebCore::WebGPU::TextureFormat::Astc6x6Unorm:
    case WebCore::WebGPU::TextureFormat::Astc6x6UnormSRGB:
    case WebCore::WebGPU::TextureFormat::Astc8x5Unorm:
    case WebCore::WebGPU::TextureFormat::Astc8x5UnormSRGB:
    case WebCore::WebGPU::TextureFormat::Astc8x6Unorm:
    case WebCore::WebGPU::TextureFormat::Astc8x6UnormSRGB:
    case WebCore::WebGPU::TextureFormat::Astc8x8Unorm:
    case WebCore::WebGPU::TextureFormat::Astc8x8UnormSRGB:
    case WebCore::WebGPU::TextureFormat::Astc10x5Unorm:
    case WebCore::WebGPU::TextureFormat::Astc10x5UnormSRGB:
    case WebCore::WebGPU::TextureFormat::Astc10x6Unorm:
    case WebCore::WebGPU::TextureFormat::Astc10x6UnormSRGB:
    case WebCore::WebGPU::TextureFormat::Astc10x8Unorm:
    case WebCore::WebGPU::TextureFormat::Astc10x8UnormSRGB:
    case WebCore::WebGPU::TextureFormat::Astc10x10Unorm:
    case WebCore::WebGPU::TextureFormat::Astc10x10UnormSRGB:
    case WebCore::WebGPU::TextureFormat::Astc12x10Unorm:
    case WebCore::WebGPU::TextureFormat::Astc12x10UnormSRGB:
    case WebCore::WebGPU::TextureFormat::Astc12x12Unorm:
    case WebCore::WebGPU::TextureFormat::Astc12x12UnormSRGB:
        return true;
    default:
        return false;
    }
}

#if ENABLE(MEDIA_STREAM)
template<> bool isValidEnum<WebCore::MediaAccessDenialReason>(uint8_t value)
{
    switch (static_cast<WebCore::MediaAccessDenialReason>(value)) {
    case WebCore::MediaAccessDenialReason::NoReason:
    case WebCore::MediaAccessDenialReason::NoConstraints:
    case WebCore::MediaAccessDenialReason::UserMediaDisabled:
    case WebCore::MediaAccessDenialReason::NoCaptureDevices:
    case WebCore::MediaAccessDenialReason::InvalidConstraint:
    case WebCore::MediaAccessDenialReason::HardwareError:
    case WebCore::MediaAccessDenialReason::PermissionDenied:
    case WebCore::MediaAccessDenialReason::InvalidAccess:
    case WebCore::MediaAccessDenialReason::OtherFailure:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(MEDIA_STREAM)
template<> bool isValidEnum<WebCore::FillLightMode>(uint8_t value)
{
    switch (static_cast<WebCore::FillLightMode>(value)) {
    case WebCore::FillLightMode::Auto:
    case WebCore::FillLightMode::Off:
    case WebCore::FillLightMode::Flash:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(MEDIA_STREAM)
template<> bool isValidEnum<WebCore::RedEyeReduction>(uint8_t value)
{
    switch (static_cast<WebCore::RedEyeReduction>(value)) {
    case WebCore::RedEyeReduction::Never:
    case WebCore::RedEyeReduction::Always:
    case WebCore::RedEyeReduction::Controllable:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::WebGPU::TextureAspect>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::TextureAspect>(value)) {
    case WebCore::WebGPU::TextureAspect::All:
    case WebCore::WebGPU::TextureAspect::StencilOnly:
    case WebCore::WebGPU::TextureAspect::DepthOnly:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::PowerPreference>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::PredefinedColorSpace>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::PredefinedColorSpace>(value)) {
    case WebCore::WebGPU::PredefinedColorSpace::SRGB:
    case WebCore::WebGPU::PredefinedColorSpace::DisplayP3:
        return true;
    default:
        return false;
    }
}

#if ENABLE(MODEL_PROCESS)
template<> bool isValidEnum<WebCore::ModelContextDisablePortal>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if PLATFORM(IOS_FAMILY)
template<> bool isValidEnum<WebCore::InspectorOverlayLabel::Arrow::Direction>(uint8_t value)
{
    switch (static_cast<WebCore::InspectorOverlayLabel::Arrow::Direction>(value)) {
    case WebCore::InspectorOverlayLabel::Arrow::Direction::None:
    case WebCore::InspectorOverlayLabel::Arrow::Direction::Down:
    case WebCore::InspectorOverlayLabel::Arrow::Direction::Up:
    case WebCore::InspectorOverlayLabel::Arrow::Direction::Left:
    case WebCore::InspectorOverlayLabel::Arrow::Direction::Right:
        return true;
    default:
        return false;
    }
}
#endif

#if PLATFORM(IOS_FAMILY)
template<> bool isValidEnum<WebCore::InspectorOverlayLabel::Arrow::Alignment>(uint8_t value)
{
    switch (static_cast<WebCore::InspectorOverlayLabel::Arrow::Alignment>(value)) {
    case WebCore::InspectorOverlayLabel::Arrow::Alignment::None:
    case WebCore::InspectorOverlayLabel::Arrow::Alignment::Leading:
    case WebCore::InspectorOverlayLabel::Arrow::Alignment::Middle:
    case WebCore::InspectorOverlayLabel::Arrow::Alignment::Trailing:
        return true;
    default:
        return false;
    }
}
#endif

#if PLATFORM(IOS_FAMILY)
template<> bool isValidEnum<WebCore::InspectorOverlayLabel::Content::Decoration::Type>(uint8_t value)
{
    switch (static_cast<WebCore::InspectorOverlayLabel::Content::Decoration::Type>(value)) {
    case WebCore::InspectorOverlayLabel::Content::Decoration::Type::None:
    case WebCore::InspectorOverlayLabel::Content::Decoration::Type::Bordered:
        return true;
    default:
        return false;
    }
}
#endif

#if PLATFORM(IOS_FAMILY)
template<> bool isValidEnum<WebCore::InspectorOverlayHighlight::Type>(uint8_t value)
{
    switch (static_cast<WebCore::InspectorOverlayHighlight::Type>(value)) {
    case WebCore::InspectorOverlayHighlight::Type::None:
    case WebCore::InspectorOverlayHighlight::Type::Node:
    case WebCore::InspectorOverlayHighlight::Type::NodeList:
    case WebCore::InspectorOverlayHighlight::Type::Rects:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::InspectorFrontendClientAppearance>(uint8_t value)
{
    switch (static_cast<WebCore::InspectorFrontendClientAppearance>(value)) {
    case WebCore::InspectorFrontendClientAppearance::System:
    case WebCore::InspectorFrontendClientAppearance::Light:
    case WebCore::InspectorFrontendClientAppearance::Dark:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::InspectorFrontendClient::SaveMode>(uint8_t value)
{
    switch (static_cast<WebCore::InspectorFrontendClient::SaveMode>(value)) {
    case WebCore::InspectorFrontendClient::SaveMode::SingleFile:
    case WebCore::InspectorFrontendClient::SaveMode::FileVariants:
        return true;
    default:
        return false;
    }
}

#if ENABLE(VIDEO)
template<> bool isValidEnum<WebCore::PlatformTextTrackData::TrackKind>(uint8_t value)
{
    switch (static_cast<WebCore::PlatformTextTrackData::TrackKind>(value)) {
    case WebCore::PlatformTextTrackData::TrackKind::Subtitle:
    case WebCore::PlatformTextTrackData::TrackKind::Caption:
    case WebCore::PlatformTextTrackData::TrackKind::Description:
    case WebCore::PlatformTextTrackData::TrackKind::Chapter:
    case WebCore::PlatformTextTrackData::TrackKind::MetaData:
    case WebCore::PlatformTextTrackData::TrackKind::Forced:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(VIDEO)
template<> bool isValidEnum<WebCore::PlatformTextTrackData::TrackType>(uint8_t value)
{
    switch (static_cast<WebCore::PlatformTextTrackData::TrackType>(value)) {
    case WebCore::PlatformTextTrackData::TrackType::InBand:
    case WebCore::PlatformTextTrackData::TrackType::OutOfBand:
    case WebCore::PlatformTextTrackData::TrackType::Script:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(VIDEO)
template<> bool isValidEnum<WebCore::PlatformTextTrackData::TrackMode>(uint8_t value)
{
    switch (static_cast<WebCore::PlatformTextTrackData::TrackMode>(value)) {
    case WebCore::PlatformTextTrackData::TrackMode::Disabled:
    case WebCore::PlatformTextTrackData::TrackMode::Hidden:
    case WebCore::PlatformTextTrackData::TrackMode::Showing:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::UserScriptInjectionTime>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::UserContentInjectedFrames>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::UserContentMatchParentFrame>(uint8_t value)
{
    switch (static_cast<WebCore::UserContentMatchParentFrame>(value)) {
    case WebCore::UserContentMatchParentFrame::Never:
    case WebCore::UserContentMatchParentFrame::ForAboutBlank:
    case WebCore::UserContentMatchParentFrame::ForOpaqueOrigins:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WindRule>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ContentSecurityPolicyHeaderType>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::UserStyleLevel>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebCore::WheelEventTestMonitorDeferReason>(OptionSet<WebCore::WheelEventTestMonitorDeferReason> value)
{
    constexpr uint16_t allValidBitsValue = 0
        | static_cast<uint16_t>(WebCore::WheelEventTestMonitorDeferReason::None)
        | static_cast<uint16_t>(WebCore::WheelEventTestMonitorDeferReason::HandlingWheelEvent)
        | static_cast<uint16_t>(WebCore::WheelEventTestMonitorDeferReason::HandlingWheelEventOnMainThread)
        | static_cast<uint16_t>(WebCore::WheelEventTestMonitorDeferReason::PostMainThreadWheelEventHandling)
        | static_cast<uint16_t>(WebCore::WheelEventTestMonitorDeferReason::RubberbandInProgress)
        | static_cast<uint16_t>(WebCore::WheelEventTestMonitorDeferReason::ScrollSnapInProgress)
        | static_cast<uint16_t>(WebCore::WheelEventTestMonitorDeferReason::ScrollAnimationInProgress)
        | static_cast<uint16_t>(WebCore::WheelEventTestMonitorDeferReason::ScrollingThreadSyncNeeded)
        | static_cast<uint16_t>(WebCore::WheelEventTestMonitorDeferReason::ContentScrollInProgress)
        | static_cast<uint16_t>(WebCore::WheelEventTestMonitorDeferReason::RequestedScrollPosition)
        | static_cast<uint16_t>(WebCore::WheelEventTestMonitorDeferReason::CommittingTransientZoom)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidOptionSet<WebCore::HTTPHeadersToKeepFromCleaning>(OptionSet<WebCore::HTTPHeadersToKeepFromCleaning> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebCore::HTTPHeadersToKeepFromCleaning::AcceptEncoding)
        | static_cast<uint8_t>(WebCore::HTTPHeadersToKeepFromCleaning::CacheControl)
        | static_cast<uint8_t>(WebCore::HTTPHeadersToKeepFromCleaning::ContentType)
        | static_cast<uint8_t>(WebCore::HTTPHeadersToKeepFromCleaning::Origin)
        | static_cast<uint8_t>(WebCore::HTTPHeadersToKeepFromCleaning::Pragma)
        | static_cast<uint8_t>(WebCore::HTTPHeadersToKeepFromCleaning::Referer)
        | static_cast<uint8_t>(WebCore::HTTPHeadersToKeepFromCleaning::UserAgent)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidEnum<WebCore::ExceptionCode>(uint8_t value)
{
    switch (static_cast<WebCore::ExceptionCode>(value)) {
    case WebCore::ExceptionCode::IndexSizeError:
    case WebCore::ExceptionCode::HierarchyRequestError:
    case WebCore::ExceptionCode::WrongDocumentError:
    case WebCore::ExceptionCode::InvalidCharacterError:
    case WebCore::ExceptionCode::NoModificationAllowedError:
    case WebCore::ExceptionCode::NotFoundError:
    case WebCore::ExceptionCode::NotSupportedError:
    case WebCore::ExceptionCode::InUseAttributeError:
    case WebCore::ExceptionCode::InvalidStateError:
    case WebCore::ExceptionCode::SyntaxError:
    case WebCore::ExceptionCode::InvalidModificationError:
    case WebCore::ExceptionCode::NamespaceError:
    case WebCore::ExceptionCode::InvalidAccessError:
    case WebCore::ExceptionCode::TypeMismatchError:
    case WebCore::ExceptionCode::SecurityError:
    case WebCore::ExceptionCode::NetworkError:
    case WebCore::ExceptionCode::AbortError:
    case WebCore::ExceptionCode::URLMismatchError:
    case WebCore::ExceptionCode::QuotaExceededError:
    case WebCore::ExceptionCode::TimeoutError:
    case WebCore::ExceptionCode::InvalidNodeTypeError:
    case WebCore::ExceptionCode::DataCloneError:
    case WebCore::ExceptionCode::EncodingError:
    case WebCore::ExceptionCode::NotReadableError:
    case WebCore::ExceptionCode::UnknownError:
    case WebCore::ExceptionCode::ConstraintError:
    case WebCore::ExceptionCode::DataError:
    case WebCore::ExceptionCode::TransactionInactiveError:
    case WebCore::ExceptionCode::ReadonlyError:
    case WebCore::ExceptionCode::VersionError:
    case WebCore::ExceptionCode::OperationError:
    case WebCore::ExceptionCode::NotAllowedError:
    case WebCore::ExceptionCode::RangeError:
    case WebCore::ExceptionCode::TypeError:
    case WebCore::ExceptionCode::JSSyntaxError:
    case WebCore::ExceptionCode::StackOverflowError:
    case WebCore::ExceptionCode::OutOfMemoryError:
    case WebCore::ExceptionCode::ExistingExceptionError:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::BackgroundFetchFailureReason>(uint8_t value)
{
    switch (static_cast<WebCore::BackgroundFetchFailureReason>(value)) {
    case WebCore::BackgroundFetchFailureReason::EmptyString:
    case WebCore::BackgroundFetchFailureReason::Aborted:
    case WebCore::BackgroundFetchFailureReason::BadStatus:
    case WebCore::BackgroundFetchFailureReason::FetchError:
    case WebCore::BackgroundFetchFailureReason::QuotaExceeded:
    case WebCore::BackgroundFetchFailureReason::DownloadTotalExceeded:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::BackgroundFetchResult>(uint8_t value)
{
    switch (static_cast<WebCore::BackgroundFetchResult>(value)) {
    case WebCore::BackgroundFetchResult::EmptyString:
    case WebCore::BackgroundFetchResult::Success:
    case WebCore::BackgroundFetchResult::Failure:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ResourceErrorBaseType>(uint8_t value)
{
    switch (static_cast<WebCore::ResourceErrorBaseType>(value)) {
    case WebCore::ResourceErrorBaseType::Null:
    case WebCore::ResourceErrorBaseType::General:
    case WebCore::ResourceErrorBaseType::AccessControl:
    case WebCore::ResourceErrorBaseType::Cancellation:
    case WebCore::ResourceErrorBaseType::Timeout:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::CredentialPersistence>(uint8_t value)
{
    switch (static_cast<WebCore::CredentialPersistence>(value)) {
    case WebCore::CredentialPersistence::None:
    case WebCore::CredentialPersistence::ForSession:
    case WebCore::CredentialPersistence::Permanent:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::PaginationMode>(uint8_t value)
{
    switch (static_cast<WebCore::PaginationMode>(value)) {
    case WebCore::PaginationMode::Unpaginated:
    case WebCore::PaginationMode::LeftToRightPaginated:
    case WebCore::PaginationMode::RightToLeftPaginated:
    case WebCore::PaginationMode::TopToBottomPaginated:
    case WebCore::PaginationMode::BottomToTopPaginated:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::RepaintRectCalculation>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::HdrMetadataType>(uint8_t value)
{
    switch (static_cast<WebCore::HdrMetadataType>(value)) {
    case WebCore::HdrMetadataType::SmpteSt2086:
    case WebCore::HdrMetadataType::SmpteSt209410:
    case WebCore::HdrMetadataType::SmpteSt209440:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::TransferFunction>(uint8_t value)
{
    switch (static_cast<WebCore::TransferFunction>(value)) {
    case WebCore::TransferFunction::SRGB:
    case WebCore::TransferFunction::PQ:
    case WebCore::TransferFunction::HLG:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ColorGamut>(uint8_t value)
{
    switch (static_cast<WebCore::ColorGamut>(value)) {
    case WebCore::ColorGamut::SRGB:
    case WebCore::ColorGamut::P3:
    case WebCore::ColorGamut::Rec2020:
        return true;
    default:
        return false;
    }
}

#if ENABLE(WEB_AUTHN)
template<> bool isValidEnum<WebCore::MediationRequirement>(uint8_t value)
{
    switch (static_cast<WebCore::MediationRequirement>(value)) {
    case WebCore::MediationRequirement::Silent:
    case WebCore::MediationRequirement::Optional:
    case WebCore::MediationRequirement::Required:
    case WebCore::MediationRequirement::Conditional:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(VIDEO)
template<> bool isValidEnum<WebCore::VTTDirectionSetting>(uint8_t value)
{
    switch (static_cast<WebCore::VTTDirectionSetting>(value)) {
    case WebCore::VTTDirectionSetting::Horizontal:
    case WebCore::VTTDirectionSetting::VerticalGrowingLeft:
    case WebCore::VTTDirectionSetting::VerticalGrowingRight:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(VIDEO)
template<> bool isValidEnum<WebCore::VTTLineAlignSetting>(uint8_t value)
{
    switch (static_cast<WebCore::VTTLineAlignSetting>(value)) {
    case WebCore::VTTLineAlignSetting::Start:
    case WebCore::VTTLineAlignSetting::Center:
    case WebCore::VTTLineAlignSetting::End:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(VIDEO)
template<> bool isValidEnum<WebCore::VTTPositionAlignSetting>(uint8_t value)
{
    switch (static_cast<WebCore::VTTPositionAlignSetting>(value)) {
    case WebCore::VTTPositionAlignSetting::LineLeft:
    case WebCore::VTTPositionAlignSetting::Center:
    case WebCore::VTTPositionAlignSetting::LineRight:
    case WebCore::VTTPositionAlignSetting::Auto:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(VIDEO)
template<> bool isValidEnum<WebCore::VTTAlignSetting>(uint8_t value)
{
    switch (static_cast<WebCore::VTTAlignSetting>(value)) {
    case WebCore::VTTAlignSetting::Start:
    case WebCore::VTTAlignSetting::Center:
    case WebCore::VTTAlignSetting::End:
    case WebCore::VTTAlignSetting::Left:
    case WebCore::VTTAlignSetting::Right:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(CONTEXT_MENUS)
template<> bool isValidEnum<WebCore::ContextMenuContextType>(uint8_t value)
{
    switch (static_cast<WebCore::ContextMenuContextType>(value)) {
    case WebCore::ContextMenuContextType::ContextMenu:
#if ENABLE(SERVICE_CONTROLS)
    case WebCore::ContextMenuContextType::ServicesMenu:
#endif
#if ENABLE(MEDIA_CONTROLS_CONTEXT_MENUS)
    case WebCore::ContextMenuContextType::MediaControls:
#endif
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidOptionSet<WebCore::CrossSiteNavigationDataTransferFlag>(OptionSet<WebCore::CrossSiteNavigationDataTransferFlag> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebCore::CrossSiteNavigationDataTransferFlag::DestinationLinkDecoration)
        | static_cast<uint8_t>(WebCore::CrossSiteNavigationDataTransferFlag::ReferrerLinkDecoration)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidOptionSet<WebCore::SynchronousScrollingReason>(OptionSet<WebCore::SynchronousScrollingReason> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebCore::SynchronousScrollingReason::ForcedOnMainThread)
        | static_cast<uint8_t>(WebCore::SynchronousScrollingReason::HasViewportConstrainedObjectsWithoutSupportingFixedLayers)
        | static_cast<uint8_t>(WebCore::SynchronousScrollingReason::HasNonLayerViewportConstrainedObjects)
        | static_cast<uint8_t>(WebCore::SynchronousScrollingReason::IsImageDocument)
        | static_cast<uint8_t>(WebCore::SynchronousScrollingReason::HasSlowRepaintObjects)
        | static_cast<uint8_t>(WebCore::SynchronousScrollingReason::DescendantScrollersHaveSynchronousScrolling)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidEnum<WebCore::ScrollRequestType>(uint8_t value)
{
    switch (static_cast<WebCore::ScrollRequestType>(value)) {
    case WebCore::ScrollRequestType::PositionUpdate:
    case WebCore::ScrollRequestType::DeltaUpdate:
    case WebCore::ScrollRequestType::CancelAnimatedScroll:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::KeyboardScrollAction>(uint8_t value)
{
    switch (static_cast<WebCore::KeyboardScrollAction>(value)) {
    case WebCore::KeyboardScrollAction::StartAnimation:
    case WebCore::KeyboardScrollAction::StopWithAnimation:
    case WebCore::KeyboardScrollAction::StopImmediately:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FontOrigin>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FontIsInterstitial>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FontVisibility>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FontIsOrientationFallback>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

#if ENABLE(VIDEO)
template<> bool isValidEnum<WebCore::CaptionUserPreferencesDisplayMode>(uint8_t value)
{
    switch (static_cast<WebCore::CaptionUserPreferencesDisplayMode>(value)) {
    case WebCore::CaptionUserPreferencesDisplayMode::Automatic:
    case WebCore::CaptionUserPreferencesDisplayMode::ForcedOnly:
    case WebCore::CaptionUserPreferencesDisplayMode::AlwaysOn:
    case WebCore::CaptionUserPreferencesDisplayMode::Manual:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::InspectorBackendClientDeveloperPreference>(uint8_t value)
{
    switch (static_cast<WebCore::InspectorBackendClientDeveloperPreference>(value)) {
    case WebCore::InspectorBackendClientDeveloperPreference::PrivateClickMeasurementDebugModeEnabled:
    case WebCore::InspectorBackendClientDeveloperPreference::ITPDebugModeEnabled:
    case WebCore::InspectorBackendClientDeveloperPreference::MockCaptureDevicesEnabled:
    case WebCore::InspectorBackendClientDeveloperPreference::NeedsSiteSpecificQuirks:
        return true;
    default:
        return false;
    }
}

#if HAVE(CORE_MATERIAL)
template<> bool isValidEnum<WebCore::AppleVisualEffect>(uint8_t value)
{
    switch (static_cast<WebCore::AppleVisualEffect>(value)) {
    case WebCore::AppleVisualEffect::None:
    case WebCore::AppleVisualEffect::BlurUltraThinMaterial:
    case WebCore::AppleVisualEffect::BlurThinMaterial:
    case WebCore::AppleVisualEffect::BlurMaterial:
    case WebCore::AppleVisualEffect::BlurThickMaterial:
    case WebCore::AppleVisualEffect::BlurChromeMaterial:
#if HAVE(MATERIAL_HOSTING)
    case WebCore::AppleVisualEffect::GlassMaterial:
#endif
#if HAVE(MATERIAL_HOSTING)
    case WebCore::AppleVisualEffect::GlassSubduedMaterial:
#endif
#if HAVE(MATERIAL_HOSTING)
    case WebCore::AppleVisualEffect::GlassMediaControlsMaterial:
#endif
#if HAVE(MATERIAL_HOSTING)
    case WebCore::AppleVisualEffect::GlassSubduedMediaControlsMaterial:
#endif
    case WebCore::AppleVisualEffect::VibrancyLabel:
    case WebCore::AppleVisualEffect::VibrancySecondaryLabel:
    case WebCore::AppleVisualEffect::VibrancyTertiaryLabel:
    case WebCore::AppleVisualEffect::VibrancyQuaternaryLabel:
    case WebCore::AppleVisualEffect::VibrancyFill:
    case WebCore::AppleVisualEffect::VibrancySecondaryFill:
    case WebCore::AppleVisualEffect::VibrancyTertiaryFill:
    case WebCore::AppleVisualEffect::VibrancySeparator:
        return true;
    default:
        return false;
    }
}
#endif

#if HAVE(CORE_MATERIAL)
template<> bool isValidEnum<WebCore::AppleVisualEffectData::ColorScheme>(uint8_t value)
{
    switch (static_cast<WebCore::AppleVisualEffectData::ColorScheme>(value)) {
    case WebCore::AppleVisualEffectData::ColorScheme::Light:
    case WebCore::AppleVisualEffectData::ColorScheme::Dark:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(MEDIA_SOURCE)
template<> bool isValidEnum<WebCore::MediaSourcePrivateAddStatus>(uint8_t value)
{
    switch (static_cast<WebCore::MediaSourcePrivateAddStatus>(value)) {
    case WebCore::MediaSourcePrivateAddStatus::Ok:
    case WebCore::MediaSourcePrivateAddStatus::NotSupported:
    case WebCore::MediaSourcePrivateAddStatus::ReachedIdLimit:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(MEDIA_SOURCE)
template<> bool isValidEnum<WebCore::MediaSourcePrivateEndOfStreamStatus>(uint8_t value)
{
    switch (static_cast<WebCore::MediaSourcePrivateEndOfStreamStatus>(value)) {
    case WebCore::MediaSourcePrivateEndOfStreamStatus::NoError:
    case WebCore::MediaSourcePrivateEndOfStreamStatus::NetworkError:
    case WebCore::MediaSourcePrivateEndOfStreamStatus::DecodeError:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(MEDIA_SOURCE)
template<> bool isValidEnum<WebCore::SourceBufferAppendMode>(uint8_t value)
{
    switch (static_cast<WebCore::SourceBufferAppendMode>(value)) {
    case WebCore::SourceBufferAppendMode::Segments:
    case WebCore::SourceBufferAppendMode::Sequence:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::WindowProxyProperty>(uint8_t value)
{
    switch (static_cast<WebCore::WindowProxyProperty>(value)) {
    case WebCore::WindowProxyProperty::Other:
    case WebCore::WindowProxyProperty::Closed:
    case WebCore::WindowProxyProperty::PostMessage:
        return true;
    default:
        return false;
    }
}

#if ENABLE(RE_DYNAMIC_CONTENT_SCALING)
template<> bool isValidEnum<WebCore::IncludeDynamicContentScalingDisplayList>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::PlatformCursorType>(uint8_t value)
{
    switch (static_cast<WebCore::PlatformCursorType>(value)) {
    case WebCore::PlatformCursorType::Invalid:
    case WebCore::PlatformCursorType::Pointer:
    case WebCore::PlatformCursorType::Cross:
    case WebCore::PlatformCursorType::Hand:
    case WebCore::PlatformCursorType::IBeam:
    case WebCore::PlatformCursorType::Wait:
    case WebCore::PlatformCursorType::Help:
    case WebCore::PlatformCursorType::EastResize:
    case WebCore::PlatformCursorType::NorthResize:
    case WebCore::PlatformCursorType::NorthEastResize:
    case WebCore::PlatformCursorType::NorthWestResize:
    case WebCore::PlatformCursorType::SouthResize:
    case WebCore::PlatformCursorType::SouthEastResize:
    case WebCore::PlatformCursorType::SouthWestResize:
    case WebCore::PlatformCursorType::WestResize:
    case WebCore::PlatformCursorType::NorthSouthResize:
    case WebCore::PlatformCursorType::EastWestResize:
    case WebCore::PlatformCursorType::NorthEastSouthWestResize:
    case WebCore::PlatformCursorType::NorthWestSouthEastResize:
    case WebCore::PlatformCursorType::ColumnResize:
    case WebCore::PlatformCursorType::RowResize:
    case WebCore::PlatformCursorType::MiddlePanning:
    case WebCore::PlatformCursorType::EastPanning:
    case WebCore::PlatformCursorType::NorthPanning:
    case WebCore::PlatformCursorType::NorthEastPanning:
    case WebCore::PlatformCursorType::NorthWestPanning:
    case WebCore::PlatformCursorType::SouthPanning:
    case WebCore::PlatformCursorType::SouthEastPanning:
    case WebCore::PlatformCursorType::SouthWestPanning:
    case WebCore::PlatformCursorType::WestPanning:
    case WebCore::PlatformCursorType::Move:
    case WebCore::PlatformCursorType::VerticalText:
    case WebCore::PlatformCursorType::Cell:
    case WebCore::PlatformCursorType::ContextMenu:
    case WebCore::PlatformCursorType::Alias:
    case WebCore::PlatformCursorType::Progress:
    case WebCore::PlatformCursorType::NoDrop:
    case WebCore::PlatformCursorType::Copy:
    case WebCore::PlatformCursorType::None:
    case WebCore::PlatformCursorType::NotAllowed:
    case WebCore::PlatformCursorType::ZoomIn:
    case WebCore::PlatformCursorType::ZoomOut:
    case WebCore::PlatformCursorType::Grab:
    case WebCore::PlatformCursorType::Grabbing:
    case WebCore::PlatformCursorType::Custom:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ContextMenuItemType>(uint8_t value)
{
    switch (static_cast<WebCore::ContextMenuItemType>(value)) {
    case WebCore::ContextMenuItemType::Action:
    case WebCore::ContextMenuItemType::CheckableAction:
    case WebCore::ContextMenuItemType::Separator:
    case WebCore::ContextMenuItemType::Submenu:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::PopupMenuStyle::Size>(uint8_t value)
{
    switch (static_cast<WebCore::PopupMenuStyle::Size>(value)) {
    case WebCore::PopupMenuStyle::Size::Normal:
    case WebCore::PopupMenuStyle::Size::Small:
    case WebCore::PopupMenuStyle::Size::Mini:
    case WebCore::PopupMenuStyle::Size::Large:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::PredefinedColorSpace>(uint8_t value)
{
    switch (static_cast<WebCore::PredefinedColorSpace>(value)) {
    case WebCore::PredefinedColorSpace::SRGB:
#if ENABLE(PREDEFINED_COLOR_SPACE_DISPLAY_P3)
    case WebCore::PredefinedColorSpace::DisplayP3:
#endif
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::TransformOperationType>(uint8_t value)
{
    switch (static_cast<WebCore::TransformOperationType>(value)) {
    case WebCore::TransformOperationType::ScaleX:
    case WebCore::TransformOperationType::ScaleY:
    case WebCore::TransformOperationType::Scale:
    case WebCore::TransformOperationType::TranslateX:
    case WebCore::TransformOperationType::TranslateY:
    case WebCore::TransformOperationType::Translate:
    case WebCore::TransformOperationType::RotateX:
    case WebCore::TransformOperationType::RotateY:
    case WebCore::TransformOperationType::Rotate:
    case WebCore::TransformOperationType::SkewX:
    case WebCore::TransformOperationType::SkewY:
    case WebCore::TransformOperationType::Skew:
    case WebCore::TransformOperationType::Matrix:
    case WebCore::TransformOperationType::ScaleZ:
    case WebCore::TransformOperationType::Scale3D:
    case WebCore::TransformOperationType::TranslateZ:
    case WebCore::TransformOperationType::Translate3D:
    case WebCore::TransformOperationType::RotateZ:
    case WebCore::TransformOperationType::Rotate3D:
    case WebCore::TransformOperationType::Matrix3D:
    case WebCore::TransformOperationType::Perspective:
    case WebCore::TransformOperationType::Identity:
    case WebCore::TransformOperationType::None:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::GraphicsContextGLSurfaceBuffer>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::GraphicsLayer::CustomAppearance>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<GCGLErrorCode>(OptionSet<GCGLErrorCode> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(GCGLErrorCode::ContextLost)
        | static_cast<uint8_t>(GCGLErrorCode::InvalidFramebufferOperation)
        | static_cast<uint8_t>(GCGLErrorCode::OutOfMemory)
        | static_cast<uint8_t>(GCGLErrorCode::InvalidOperation)
        | static_cast<uint8_t>(GCGLErrorCode::InvalidValue)
        | static_cast<uint8_t>(GCGLErrorCode::InvalidEnum)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

#if ENABLE(VIDEO)
template<> bool isValidEnum<WebCore::AudioTrackPrivate::Kind>(uint8_t value)
{
    switch (static_cast<WebCore::AudioTrackPrivate::Kind>(value)) {
    case WebCore::AudioTrackPrivate::Kind::Alternative:
    case WebCore::AudioTrackPrivate::Kind::Description:
    case WebCore::AudioTrackPrivate::Kind::Main:
    case WebCore::AudioTrackPrivate::Kind::MainDesc:
    case WebCore::AudioTrackPrivate::Kind::Translation:
    case WebCore::AudioTrackPrivate::Kind::Commentary:
    case WebCore::AudioTrackPrivate::Kind::None:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(VIDEO)
template<> bool isValidEnum<WebCore::VideoTrackPrivate::Kind>(uint8_t value)
{
    switch (static_cast<WebCore::VideoTrackPrivate::Kind>(value)) {
    case WebCore::VideoTrackPrivate::Kind::Alternative:
    case WebCore::VideoTrackPrivate::Kind::Captions:
    case WebCore::VideoTrackPrivate::Kind::Main:
    case WebCore::VideoTrackPrivate::Kind::Sign:
    case WebCore::VideoTrackPrivate::Kind::Subtitles:
    case WebCore::VideoTrackPrivate::Kind::Commentary:
    case WebCore::VideoTrackPrivate::Kind::None:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::CompositeOperationType>(uint8_t value)
{
    switch (static_cast<WebCore::CompositeOperationType>(value)) {
    case WebCore::CompositeOperationType::FECOMPOSITE_OPERATOR_UNKNOWN:
    case WebCore::CompositeOperationType::FECOMPOSITE_OPERATOR_OVER:
    case WebCore::CompositeOperationType::FECOMPOSITE_OPERATOR_IN:
    case WebCore::CompositeOperationType::FECOMPOSITE_OPERATOR_OUT:
    case WebCore::CompositeOperationType::FECOMPOSITE_OPERATOR_ATOP:
    case WebCore::CompositeOperationType::FECOMPOSITE_OPERATOR_XOR:
    case WebCore::CompositeOperationType::FECOMPOSITE_OPERATOR_ARITHMETIC:
    case WebCore::CompositeOperationType::FECOMPOSITE_OPERATOR_LIGHTER:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ColorMatrixType>(uint8_t value)
{
    switch (static_cast<WebCore::ColorMatrixType>(value)) {
    case WebCore::ColorMatrixType::FECOLORMATRIX_TYPE_UNKNOWN:
    case WebCore::ColorMatrixType::FECOLORMATRIX_TYPE_MATRIX:
    case WebCore::ColorMatrixType::FECOLORMATRIX_TYPE_SATURATE:
    case WebCore::ColorMatrixType::FECOLORMATRIX_TYPE_HUEROTATE:
    case WebCore::ColorMatrixType::FECOLORMATRIX_TYPE_LUMINANCETOALPHA:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::TurbulenceType>(uint8_t value)
{
    switch (static_cast<WebCore::TurbulenceType>(value)) {
    case WebCore::TurbulenceType::Unknown:
    case WebCore::TurbulenceType::FractalNoise:
    case WebCore::TurbulenceType::Turbulence:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebCore::FilterRenderingMode>(OptionSet<WebCore::FilterRenderingMode> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebCore::FilterRenderingMode::Software)
        | static_cast<uint8_t>(WebCore::FilterRenderingMode::Accelerated)
        | static_cast<uint8_t>(WebCore::FilterRenderingMode::GraphicsContext)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidEnum<WebCore::LightType>(uint8_t value)
{
    switch (static_cast<WebCore::LightType>(value)) {
    case WebCore::LightType::LS_DISTANT:
    case WebCore::LightType::LS_POINT:
    case WebCore::LightType::LS_SPOT:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ComponentTransferType>(uint8_t value)
{
    switch (static_cast<WebCore::ComponentTransferType>(value)) {
    case WebCore::ComponentTransferType::FECOMPONENTTRANSFER_TYPE_UNKNOWN:
    case WebCore::ComponentTransferType::FECOMPONENTTRANSFER_TYPE_IDENTITY:
    case WebCore::ComponentTransferType::FECOMPONENTTRANSFER_TYPE_TABLE:
    case WebCore::ComponentTransferType::FECOMPONENTTRANSFER_TYPE_DISCRETE:
    case WebCore::ComponentTransferType::FECOMPONENTTRANSFER_TYPE_LINEAR:
    case WebCore::ComponentTransferType::FECOMPONENTTRANSFER_TYPE_GAMMA:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ComponentTransferChannel>(uint8_t value)
{
    switch (static_cast<WebCore::ComponentTransferChannel>(value)) {
    case WebCore::ComponentTransferChannel::Red:
    case WebCore::ComponentTransferChannel::Green:
    case WebCore::ComponentTransferChannel::Blue:
    case WebCore::ComponentTransferChannel::Alpha:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::MorphologyOperatorType>(uint8_t value)
{
    switch (static_cast<WebCore::MorphologyOperatorType>(value)) {
    case WebCore::MorphologyOperatorType::Unknown:
    case WebCore::MorphologyOperatorType::Erode:
    case WebCore::MorphologyOperatorType::Dilate:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ChannelSelectorType>(uint8_t value)
{
    switch (static_cast<WebCore::ChannelSelectorType>(value)) {
    case WebCore::ChannelSelectorType::CHANNEL_UNKNOWN:
    case WebCore::ChannelSelectorType::CHANNEL_R:
    case WebCore::ChannelSelectorType::CHANNEL_G:
    case WebCore::ChannelSelectorType::CHANNEL_B:
    case WebCore::ChannelSelectorType::CHANNEL_A:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::EdgeModeType>(uint8_t value)
{
    switch (static_cast<WebCore::EdgeModeType>(value)) {
    case WebCore::EdgeModeType::Unknown:
    case WebCore::EdgeModeType::Duplicate:
    case WebCore::EdgeModeType::Wrap:
    case WebCore::EdgeModeType::None:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FilterOperation::Type>(uint8_t value)
{
    switch (static_cast<WebCore::FilterOperation::Type>(value)) {
    case WebCore::FilterOperation::Type::Reference:
    case WebCore::FilterOperation::Type::Grayscale:
    case WebCore::FilterOperation::Type::Sepia:
    case WebCore::FilterOperation::Type::Saturate:
    case WebCore::FilterOperation::Type::HueRotate:
    case WebCore::FilterOperation::Type::Invert:
    case WebCore::FilterOperation::Type::AppleInvertLightness:
    case WebCore::FilterOperation::Type::Opacity:
    case WebCore::FilterOperation::Type::Brightness:
    case WebCore::FilterOperation::Type::Contrast:
    case WebCore::FilterOperation::Type::Blur:
    case WebCore::FilterOperation::Type::DropShadow:
    case WebCore::FilterOperation::Type::Passthrough:
    case WebCore::FilterOperation::Type::Default:
    case WebCore::FilterOperation::Type::None:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FilterFunction::Type>(uint8_t value)
{
    switch (static_cast<WebCore::FilterFunction::Type>(value)) {
    case WebCore::FilterFunction::Type::CSSFilter:
    case WebCore::FilterFunction::Type::SVGFilter:
    case WebCore::FilterFunction::Type::FEBlend:
    case WebCore::FilterFunction::Type::FEColorMatrix:
    case WebCore::FilterFunction::Type::FEComponentTransfer:
    case WebCore::FilterFunction::Type::FEComposite:
    case WebCore::FilterFunction::Type::FEConvolveMatrix:
    case WebCore::FilterFunction::Type::FEDiffuseLighting:
    case WebCore::FilterFunction::Type::FEDisplacementMap:
    case WebCore::FilterFunction::Type::FEDropShadow:
    case WebCore::FilterFunction::Type::FEFlood:
    case WebCore::FilterFunction::Type::FEGaussianBlur:
    case WebCore::FilterFunction::Type::FEImage:
    case WebCore::FilterFunction::Type::FEMerge:
    case WebCore::FilterFunction::Type::FEMorphology:
    case WebCore::FilterFunction::Type::FEOffset:
    case WebCore::FilterFunction::Type::FESpecularLighting:
    case WebCore::FilterFunction::Type::FETile:
    case WebCore::FilterFunction::Type::FETurbulence:
    case WebCore::FilterFunction::Type::SourceAlpha:
    case WebCore::FilterFunction::Type::SourceGraphic:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ResolvedEmojiPolicy>(uint8_t value)
{
    switch (static_cast<WebCore::ResolvedEmojiPolicy>(value)) {
    case WebCore::ResolvedEmojiPolicy::NoPreference:
    case WebCore::ResolvedEmojiPolicy::RequireText:
    case WebCore::ResolvedEmojiPolicy::RequireEmoji:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ScrollBehaviorForFixedElements>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ContentExtensionDefaultEnablement>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::RequiresClipToRect>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::HighlightVisibility>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::SVGPreserveAspectRatioValue::SVGPreserveAspectRatioType>(uint8_t value)
{
    switch (static_cast<WebCore::SVGPreserveAspectRatioValue::SVGPreserveAspectRatioType>(value)) {
    case WebCore::SVGPreserveAspectRatioValue::SVGPreserveAspectRatioType::SVG_PRESERVEASPECTRATIO_UNKNOWN:
    case WebCore::SVGPreserveAspectRatioValue::SVGPreserveAspectRatioType::SVG_PRESERVEASPECTRATIO_NONE:
    case WebCore::SVGPreserveAspectRatioValue::SVGPreserveAspectRatioType::SVG_PRESERVEASPECTRATIO_XMINYMIN:
    case WebCore::SVGPreserveAspectRatioValue::SVGPreserveAspectRatioType::SVG_PRESERVEASPECTRATIO_XMIDYMIN:
    case WebCore::SVGPreserveAspectRatioValue::SVGPreserveAspectRatioType::SVG_PRESERVEASPECTRATIO_XMAXYMIN:
    case WebCore::SVGPreserveAspectRatioValue::SVGPreserveAspectRatioType::SVG_PRESERVEASPECTRATIO_XMINYMID:
    case WebCore::SVGPreserveAspectRatioValue::SVGPreserveAspectRatioType::SVG_PRESERVEASPECTRATIO_XMIDYMID:
    case WebCore::SVGPreserveAspectRatioValue::SVGPreserveAspectRatioType::SVG_PRESERVEASPECTRATIO_XMAXYMID:
    case WebCore::SVGPreserveAspectRatioValue::SVGPreserveAspectRatioType::SVG_PRESERVEASPECTRATIO_XMINYMAX:
    case WebCore::SVGPreserveAspectRatioValue::SVGPreserveAspectRatioType::SVG_PRESERVEASPECTRATIO_XMIDYMAX:
    case WebCore::SVGPreserveAspectRatioValue::SVGPreserveAspectRatioType::SVG_PRESERVEASPECTRATIO_XMAXYMAX:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::SVGPreserveAspectRatioValue::SVGMeetOrSliceType>(uint8_t value)
{
    switch (static_cast<WebCore::SVGPreserveAspectRatioValue::SVGMeetOrSliceType>(value)) {
    case WebCore::SVGPreserveAspectRatioValue::SVGMeetOrSliceType::SVG_MEETORSLICE_UNKNOWN:
    case WebCore::SVGPreserveAspectRatioValue::SVGMeetOrSliceType::SVG_MEETORSLICE_MEET:
    case WebCore::SVGPreserveAspectRatioValue::SVGMeetOrSliceType::SVG_MEETORSLICE_SLICE:
        return true;
    default:
        return false;
    }
}

#if ENABLE(VIDEO)
template<> bool isValidEnum<WebCore::PlatformMediaError>(uint8_t value)
{
    switch (static_cast<WebCore::PlatformMediaError>(value)) {
    case WebCore::PlatformMediaError::AppendError:
    case WebCore::PlatformMediaError::ClientDisconnected:
    case WebCore::PlatformMediaError::BufferRemoved:
    case WebCore::PlatformMediaError::SourceRemoved:
    case WebCore::PlatformMediaError::IPCError:
    case WebCore::PlatformMediaError::ParsingError:
    case WebCore::PlatformMediaError::MemoryError:
    case WebCore::PlatformMediaError::Cancelled:
    case WebCore::PlatformMediaError::LogicError:
    case WebCore::PlatformMediaError::DecoderCreationError:
    case WebCore::PlatformMediaError::NotSupportedError:
    case WebCore::PlatformMediaError::NetworkError:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::SVGUnitTypes::SVGUnitType>(uint8_t value)
{
    switch (static_cast<WebCore::SVGUnitTypes::SVGUnitType>(value)) {
    case WebCore::SVGUnitTypes::SVGUnitType::SVG_UNIT_TYPE_UNKNOWN:
    case WebCore::SVGUnitTypes::SVGUnitType::SVG_UNIT_TYPE_USERSPACEONUSE:
    case WebCore::SVGUnitTypes::SVGUnitType::SVG_UNIT_TYPE_OBJECTBOUNDINGBOX:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::CrossOriginMode>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WorkerThreadMode>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WillContinueLoading>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

#if ENABLE(GPU_PROCESS) && ENABLE(ENCRYPTED_MEDIA)
template<> bool isValidEnum<WebCore::CDMPrivateLocalStorageAccess>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(GPU_PROCESS) && ENABLE(ENCRYPTED_MEDIA)
template<> bool isValidEnum<WebCore::CDMInstanceAllowPersistentState>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(GPU_PROCESS) && ENABLE(ENCRYPTED_MEDIA)
template<> bool isValidEnum<WebCore::CDMInstanceSuccessValue>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(GPU_PROCESS) && ENABLE(ENCRYPTED_MEDIA)
template<> bool isValidEnum<WebCore::CDMInstanceAllowDistinctiveIdentifiers>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(GPU_PROCESS) && ENABLE(VIDEO)
template<> bool isValidEnum<WebCore::ShouldContinuePolicyCheck>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(GAMEPAD)
template<> bool isValidEnum<WebCore::EventMakesGamepadsVisible>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if (ENABLE(GAMEPAD)) && (PLATFORM(VISION))
template<> bool isValidEnum<WebCore::ShouldRequireExplicitConsentForGamepadAccess>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::WillInternallyHandleFailure>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ApplyTrackingPrevention>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ShouldSample>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FromDownloadAttribute>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::RequiresScriptTrackingPrivacy>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::PermissionsPolicy::Feature>(uint8_t value)
{
    switch (static_cast<WebCore::PermissionsPolicy::Feature>(value)) {
    case WebCore::PermissionsPolicy::Feature::Camera:
    case WebCore::PermissionsPolicy::Feature::Microphone:
    case WebCore::PermissionsPolicy::Feature::SpeakerSelection:
    case WebCore::PermissionsPolicy::Feature::DisplayCapture:
    case WebCore::PermissionsPolicy::Feature::Gamepad:
    case WebCore::PermissionsPolicy::Feature::Geolocation:
    case WebCore::PermissionsPolicy::Feature::Payment:
    case WebCore::PermissionsPolicy::Feature::ScreenWakeLock:
    case WebCore::PermissionsPolicy::Feature::SyncXHR:
    case WebCore::PermissionsPolicy::Feature::Fullscreen:
    case WebCore::PermissionsPolicy::Feature::WebShare:
#if ENABLE(DEVICE_ORIENTATION)
    case WebCore::PermissionsPolicy::Feature::Gyroscope:
#endif
#if ENABLE(DEVICE_ORIENTATION)
    case WebCore::PermissionsPolicy::Feature::Accelerometer:
#endif
#if ENABLE(DEVICE_ORIENTATION)
    case WebCore::PermissionsPolicy::Feature::Magnetometer:
#endif
#if ENABLE(WEB_AUTHN)
    case WebCore::PermissionsPolicy::Feature::PublickeyCredentialsGetRule:
#endif
#if ENABLE(WEB_AUTHN)
    case WebCore::PermissionsPolicy::Feature::DigitalCredentialsGetRule:
#endif
#if ENABLE(WEBXR)
    case WebCore::PermissionsPolicy::Feature::XRSpatialTracking:
#endif
    case WebCore::PermissionsPolicy::Feature::PrivateToken:
    case WebCore::PermissionsPolicy::Feature::Invalid:
        return true;
    default:
        return false;
    }
}

#if PLATFORM(COCOA)
template<> bool isValidEnum<WebCore::ImageDecodingError>(uint8_t value)
{
    switch (static_cast<WebCore::ImageDecodingError>(value)) {
    case WebCore::ImageDecodingError::Internal:
    case WebCore::ImageDecodingError::BadData:
    case WebCore::ImageDecodingError::UnsupportedType:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::FileSystemWriteCommandType>(uint8_t value)
{
    switch (static_cast<WebCore::FileSystemWriteCommandType>(value)) {
    case WebCore::FileSystemWriteCommandType::Write:
    case WebCore::FileSystemWriteCommandType::Seek:
    case WebCore::FileSystemWriteCommandType::Truncate:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FileSystemWriteCloseReason>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::CryptoKeyUsage>(uint8_t value)
{
    switch (static_cast<WebCore::CryptoKeyUsage>(value)) {
    case WebCore::CryptoKeyUsage::Encrypt:
    case WebCore::CryptoKeyUsage::Decrypt:
    case WebCore::CryptoKeyUsage::Sign:
    case WebCore::CryptoKeyUsage::Verify:
    case WebCore::CryptoKeyUsage::DeriveKey:
    case WebCore::CryptoKeyUsage::DeriveBits:
    case WebCore::CryptoKeyUsage::WrapKey:
    case WebCore::CryptoKeyUsage::UnwrapKey:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::CryptoAlgorithmIdentifier>(uint8_t value)
{
    switch (static_cast<WebCore::CryptoAlgorithmIdentifier>(value)) {
    case WebCore::CryptoAlgorithmIdentifier::RSAES_PKCS1_v1_5:
    case WebCore::CryptoAlgorithmIdentifier::RSASSA_PKCS1_v1_5:
    case WebCore::CryptoAlgorithmIdentifier::RSA_PSS:
    case WebCore::CryptoAlgorithmIdentifier::RSA_OAEP:
    case WebCore::CryptoAlgorithmIdentifier::ECDSA:
    case WebCore::CryptoAlgorithmIdentifier::ECDH:
    case WebCore::CryptoAlgorithmIdentifier::AES_CTR:
    case WebCore::CryptoAlgorithmIdentifier::AES_CBC:
    case WebCore::CryptoAlgorithmIdentifier::AES_GCM:
    case WebCore::CryptoAlgorithmIdentifier::AES_CFB:
    case WebCore::CryptoAlgorithmIdentifier::AES_KW:
    case WebCore::CryptoAlgorithmIdentifier::HMAC:
    case WebCore::CryptoAlgorithmIdentifier::SHA_1:
    case WebCore::CryptoAlgorithmIdentifier::DEPRECATED_SHA_224:
    case WebCore::CryptoAlgorithmIdentifier::SHA_256:
    case WebCore::CryptoAlgorithmIdentifier::SHA_384:
    case WebCore::CryptoAlgorithmIdentifier::SHA_512:
    case WebCore::CryptoAlgorithmIdentifier::HKDF:
    case WebCore::CryptoAlgorithmIdentifier::PBKDF2:
    case WebCore::CryptoAlgorithmIdentifier::Ed25519:
    case WebCore::CryptoAlgorithmIdentifier::X25519:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::CryptoKeyClass>(uint8_t value)
{
    switch (static_cast<WebCore::CryptoKeyClass>(value)) {
    case WebCore::CryptoKeyClass::AES:
    case WebCore::CryptoKeyClass::EC:
    case WebCore::CryptoKeyClass::HMAC:
    case WebCore::CryptoKeyClass::OKP:
    case WebCore::CryptoKeyClass::RSA:
    case WebCore::CryptoKeyClass::Raw:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::CryptoKeyType>(uint8_t value)
{
    switch (static_cast<WebCore::CryptoKeyType>(value)) {
    case WebCore::CryptoKeyType::Public:
    case WebCore::CryptoKeyType::Private:
    case WebCore::CryptoKeyType::Secret:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ResourceError::IsSanitized>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

#if ENABLE(DOM_AUDIO_SESSION)
template<> bool isValidEnum<WebCore::DOMAudioSessionType>(uint8_t value)
{
    switch (static_cast<WebCore::DOMAudioSessionType>(value)) {
    case WebCore::DOMAudioSessionType::Auto:
    case WebCore::DOMAudioSessionType::Playback:
    case WebCore::DOMAudioSessionType::Transient:
    case WebCore::DOMAudioSessionType::TransientSolo:
    case WebCore::DOMAudioSessionType::Ambient:
    case WebCore::DOMAudioSessionType::PlayAndRecord:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::TrackInfo::TrackType>(uint8_t value)
{
    switch (static_cast<WebCore::TrackInfo::TrackType>(value)) {
    case WebCore::TrackInfo::TrackType::Unknown:
    case WebCore::TrackInfo::TrackType::Audio:
    case WebCore::TrackInfo::TrackType::Video:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebCore::DocumentClass>(OptionSet<WebCore::DocumentClass> value)
{
    constexpr uint16_t allValidBitsValue = 0
        | static_cast<uint16_t>(WebCore::DocumentClass::HTML)
        | static_cast<uint16_t>(WebCore::DocumentClass::XHTML)
        | static_cast<uint16_t>(WebCore::DocumentClass::Image)
        | static_cast<uint16_t>(WebCore::DocumentClass::Plugin)
        | static_cast<uint16_t>(WebCore::DocumentClass::Media)
        | static_cast<uint16_t>(WebCore::DocumentClass::SVG)
        | static_cast<uint16_t>(WebCore::DocumentClass::Text)
        | static_cast<uint16_t>(WebCore::DocumentClass::XML)
#if ENABLE(MODEL_ELEMENT)
        | static_cast<uint16_t>(WebCore::DocumentClass::Model)
#endif
        | static_cast<uint16_t>(WebCore::DocumentClass::PDF)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

#if ENABLE(MODEL_PROCESS)
template<> bool isValidEnum<WebCore::StageModeOperation>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::PredominantColorType>(uint8_t value)
{
    switch (static_cast<WebCore::PredominantColorType>(value)) {
    case WebCore::PredominantColorType::None:
    case WebCore::PredominantColorType::Multiple:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ShouldGoToHistoryItem>(uint8_t value)
{
    switch (static_cast<WebCore::ShouldGoToHistoryItem>(value)) {
    case WebCore::ShouldGoToHistoryItem::No:
    case WebCore::ShouldGoToHistoryItem::Yes:
    case WebCore::ShouldGoToHistoryItem::ItemUnknown:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ProcessSwapDisposition>(uint8_t value)
{
    switch (static_cast<WebCore::ProcessSwapDisposition>(value)) {
    case WebCore::ProcessSwapDisposition::None:
    case WebCore::ProcessSwapDisposition::COOP:
    case WebCore::ProcessSwapDisposition::Other:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::FoundElementInRemoteFrame>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebCore::ScriptTrackingPrivacyFlag>(OptionSet<WebCore::ScriptTrackingPrivacyFlag> value)
{
    constexpr uint16_t allValidBitsValue = 0
        | static_cast<uint16_t>(WebCore::ScriptTrackingPrivacyFlag::Audio)
        | static_cast<uint16_t>(WebCore::ScriptTrackingPrivacyFlag::Canvas)
        | static_cast<uint16_t>(WebCore::ScriptTrackingPrivacyFlag::Cookies)
        | static_cast<uint16_t>(WebCore::ScriptTrackingPrivacyFlag::HardwareConcurrency)
        | static_cast<uint16_t>(WebCore::ScriptTrackingPrivacyFlag::LocalStorage)
        | static_cast<uint16_t>(WebCore::ScriptTrackingPrivacyFlag::Payments)
        | static_cast<uint16_t>(WebCore::ScriptTrackingPrivacyFlag::QueryParameters)
        | static_cast<uint16_t>(WebCore::ScriptTrackingPrivacyFlag::Referrer)
        | static_cast<uint16_t>(WebCore::ScriptTrackingPrivacyFlag::ScreenOrViewport)
        | static_cast<uint16_t>(WebCore::ScriptTrackingPrivacyFlag::Speech)
        | static_cast<uint16_t>(WebCore::ScriptTrackingPrivacyFlag::FormControls)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidOptionSet<WebKit::WebEventModifier>(OptionSet<WebKit::WebEventModifier> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebKit::WebEventModifier::ShiftKey)
        | static_cast<uint8_t>(WebKit::WebEventModifier::ControlKey)
        | static_cast<uint8_t>(WebKit::WebEventModifier::AltKey)
        | static_cast<uint8_t>(WebKit::WebEventModifier::MetaKey)
        | static_cast<uint8_t>(WebKit::WebEventModifier::CapsLockKey)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidEnum<WebKit::WebEventType>(uint8_t value)
{
    switch (static_cast<WebKit::WebEventType>(value)) {
    case WebKit::WebEventType::MouseDown:
    case WebKit::WebEventType::MouseUp:
    case WebKit::WebEventType::MouseMove:
    case WebKit::WebEventType::MouseForceChanged:
    case WebKit::WebEventType::MouseForceDown:
    case WebKit::WebEventType::MouseForceUp:
    case WebKit::WebEventType::Wheel:
    case WebKit::WebEventType::KeyDown:
    case WebKit::WebEventType::KeyUp:
    case WebKit::WebEventType::RawKeyDown:
    case WebKit::WebEventType::Char:
#if ENABLE(TOUCH_EVENTS)
    case WebKit::WebEventType::TouchStart:
#endif
#if ENABLE(TOUCH_EVENTS)
    case WebKit::WebEventType::TouchMove:
#endif
#if ENABLE(TOUCH_EVENTS)
    case WebKit::WebEventType::TouchEnd:
#endif
#if ENABLE(TOUCH_EVENTS)
    case WebKit::WebEventType::TouchCancel:
#endif
#if ENABLE(MAC_GESTURE_EVENTS)
    case WebKit::WebEventType::GestureStart:
#endif
#if ENABLE(MAC_GESTURE_EVENTS)
    case WebKit::WebEventType::GestureChange:
#endif
#if ENABLE(MAC_GESTURE_EVENTS)
    case WebKit::WebEventType::GestureEnd:
#endif
        return true;
    default:
        return false;
    }
}

#if PLATFORM(IOS_FAMILY) && ENABLE(IOS_TOUCH_EVENTS)
template<> bool isValidEnum<WebKit::WebPlatformTouchPoint::TouchType>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(TOUCH_EVENTS)
template<> bool isValidEnum<WebKit::WebPlatformTouchPoint::State>(uint8_t value)
{
    switch (static_cast<WebKit::WebPlatformTouchPoint::State>(value)) {
    case WebKit::WebPlatformTouchPoint::State::Released:
    case WebKit::WebPlatformTouchPoint::State::Pressed:
    case WebKit::WebPlatformTouchPoint::State::Moved:
    case WebKit::WebPlatformTouchPoint::State::Stationary:
    case WebKit::WebPlatformTouchPoint::State::Cancelled:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebKit::WebMouseEventButton>(int8_t value)
{
    switch (static_cast<WebKit::WebMouseEventButton>(value)) {
    case WebKit::WebMouseEventButton::Left:
    case WebKit::WebMouseEventButton::Middle:
    case WebKit::WebMouseEventButton::Right:
    case WebKit::WebMouseEventButton::None:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::WebMouseEventSyntheticClickType>(uint8_t value)
{
    switch (static_cast<WebKit::WebMouseEventSyntheticClickType>(value)) {
    case WebKit::WebMouseEventSyntheticClickType::NoTap:
    case WebKit::WebMouseEventSyntheticClickType::OneFingerTap:
    case WebKit::WebMouseEventSyntheticClickType::TwoFingerTap:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::GestureWasCancelled>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

#if !PLATFORM(MAC) && PLATFORM(GTK)
template<> bool isValidEnum<WebCore::PlatformMouseEvent::IsTouch>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebKit::WebWheelEvent::Granularity>(uint8_t value)
{
    switch (static_cast<WebKit::WebWheelEvent::Granularity>(value)) {
    case WebKit::WebWheelEvent::Granularity::ScrollByPageWheelEvent:
    case WebKit::WebWheelEvent::Granularity::ScrollByPixelWheelEvent:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::WebWheelEvent::Phase>(uint32_t value)
{
    switch (static_cast<WebKit::WebWheelEvent::Phase>(value)) {
    case WebKit::WebWheelEvent::Phase::PhaseNone:
    case WebKit::WebWheelEvent::Phase::PhaseBegan:
    case WebKit::WebWheelEvent::Phase::PhaseStationary:
    case WebKit::WebWheelEvent::Phase::PhaseChanged:
    case WebKit::WebWheelEvent::Phase::PhaseEnded:
    case WebKit::WebWheelEvent::Phase::PhaseCancelled:
    case WebKit::WebWheelEvent::Phase::PhaseMayBegin:
    case WebKit::WebWheelEvent::Phase::PhaseWillBegin:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::WebWheelEvent::MomentumEndType>(uint8_t value)
{
    switch (static_cast<WebKit::WebWheelEvent::MomentumEndType>(value)) {
    case WebKit::WebWheelEvent::MomentumEndType::Unknown:
    case WebKit::WebWheelEvent::MomentumEndType::Interrupted:
    case WebKit::WebWheelEvent::MomentumEndType::Natural:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebKit::FindOptions>(OptionSet<WebKit::FindOptions> value)
{
    constexpr uint16_t allValidBitsValue = 0
        | static_cast<uint16_t>(WebKit::FindOptions::CaseInsensitive)
        | static_cast<uint16_t>(WebKit::FindOptions::AtWordStarts)
        | static_cast<uint16_t>(WebKit::FindOptions::TreatMedialCapitalAsWordStart)
        | static_cast<uint16_t>(WebKit::FindOptions::Backwards)
        | static_cast<uint16_t>(WebKit::FindOptions::WrapAround)
        | static_cast<uint16_t>(WebKit::FindOptions::ShowOverlay)
        | static_cast<uint16_t>(WebKit::FindOptions::ShowFindIndicator)
        | static_cast<uint16_t>(WebKit::FindOptions::ShowHighlight)
        | static_cast<uint16_t>(WebKit::FindOptions::DetermineMatchIndex)
        | static_cast<uint16_t>(WebKit::FindOptions::NoIndexChange)
        | static_cast<uint16_t>(WebKit::FindOptions::AtWordEnds)
        | static_cast<uint16_t>(WebKit::FindOptions::DoNotSetSelection)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidEnum<WebKit::FindDecorationStyle>(uint8_t value)
{
    switch (static_cast<WebKit::FindDecorationStyle>(value)) {
    case WebKit::FindDecorationStyle::Normal:
    case WebKit::FindDecorationStyle::Found:
    case WebKit::FindDecorationStyle::Highlighted:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::IsScrollable>(uint8_t value)
{
    switch (static_cast<WebKit::IsScrollable>(value)) {
    case WebKit::IsScrollable::No:
    case WebKit::IsScrollable::Yes:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::WebHitTestResultData::IsScrollbar>(uint8_t value)
{
    switch (static_cast<WebKit::WebHitTestResultData::IsScrollbar>(value)) {
    case WebKit::WebHitTestResultData::IsScrollbar::No:
    case WebKit::WebHitTestResultData::IsScrollbar::Vertical:
    case WebKit::WebHitTestResultData::IsScrollbar::Horizontal:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::WebHitTestResultData::ElementType>(uint8_t value)
{
    switch (static_cast<WebKit::WebHitTestResultData::ElementType>(value)) {
    case WebKit::WebHitTestResultData::ElementType::None:
    case WebKit::WebHitTestResultData::ElementType::Audio:
    case WebKit::WebHitTestResultData::ElementType::Video:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::UserInterfaceLayoutDirection>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::WebPopupItem::Type>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::TextDirection>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::WebsiteAutoplayPolicy>(uint8_t value)
{
    switch (static_cast<WebKit::WebsiteAutoplayPolicy>(value)) {
    case WebKit::WebsiteAutoplayPolicy::Default:
    case WebKit::WebsiteAutoplayPolicy::Allow:
    case WebKit::WebsiteAutoplayPolicy::AllowWithoutSound:
    case WebKit::WebsiteAutoplayPolicy::Deny:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebKit::WebsiteAutoplayQuirk>(OptionSet<WebKit::WebsiteAutoplayQuirk> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebKit::WebsiteAutoplayQuirk::SynthesizedPauseEvents)
        | static_cast<uint8_t>(WebKit::WebsiteAutoplayQuirk::InheritedUserGestures)
        | static_cast<uint8_t>(WebKit::WebsiteAutoplayQuirk::ArbitraryUserGestures)
        | static_cast<uint8_t>(WebKit::WebsiteAutoplayQuirk::PerDocumentAutoplayBehavior)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidEnum<WebKit::WebsiteMetaViewportPolicy>(uint8_t value)
{
    switch (static_cast<WebKit::WebsiteMetaViewportPolicy>(value)) {
    case WebKit::WebsiteMetaViewportPolicy::Default:
    case WebKit::WebsiteMetaViewportPolicy::Respect:
    case WebKit::WebsiteMetaViewportPolicy::Ignore:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::WebsiteMediaSourcePolicy>(uint8_t value)
{
    switch (static_cast<WebKit::WebsiteMediaSourcePolicy>(value)) {
    case WebKit::WebsiteMediaSourcePolicy::Default:
    case WebKit::WebsiteMediaSourcePolicy::Disable:
    case WebKit::WebsiteMediaSourcePolicy::Enable:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::WebsiteSimulatedMouseEventsDispatchPolicy>(uint8_t value)
{
    switch (static_cast<WebKit::WebsiteSimulatedMouseEventsDispatchPolicy>(value)) {
    case WebKit::WebsiteSimulatedMouseEventsDispatchPolicy::Default:
    case WebKit::WebsiteSimulatedMouseEventsDispatchPolicy::Allow:
    case WebKit::WebsiteSimulatedMouseEventsDispatchPolicy::Deny:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::WebsiteLegacyOverflowScrollingTouchPolicy>(uint8_t value)
{
    switch (static_cast<WebKit::WebsiteLegacyOverflowScrollingTouchPolicy>(value)) {
    case WebKit::WebsiteLegacyOverflowScrollingTouchPolicy::Default:
    case WebKit::WebsiteLegacyOverflowScrollingTouchPolicy::Disable:
    case WebKit::WebsiteLegacyOverflowScrollingTouchPolicy::Enable:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::WebContentMode>(uint8_t value)
{
    switch (static_cast<WebKit::WebContentMode>(value)) {
    case WebKit::WebContentMode::Recommended:
    case WebKit::WebContentMode::Mobile:
    case WebKit::WebContentMode::Desktop:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::WebsiteInlineMediaPlaybackPolicy>(uint8_t value)
{
    switch (static_cast<WebKit::WebsiteInlineMediaPlaybackPolicy>(value)) {
    case WebKit::WebsiteInlineMediaPlaybackPolicy::Default:
    case WebKit::WebsiteInlineMediaPlaybackPolicy::RequiresPlaysInlineAttribute:
    case WebKit::WebsiteInlineMediaPlaybackPolicy::DoesNotRequirePlaysInlineAttribute:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::WebsitePopUpPolicy>(uint8_t value)
{
    switch (static_cast<WebKit::WebsitePopUpPolicy>(value)) {
    case WebKit::WebsitePopUpPolicy::Default:
    case WebKit::WebsitePopUpPolicy::Allow:
    case WebKit::WebsitePopUpPolicy::Block:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::WebsitePushAndNotificationsEnabledPolicy>(uint8_t value)
{
    switch (static_cast<WebKit::WebsitePushAndNotificationsEnabledPolicy>(value)) {
    case WebKit::WebsitePushAndNotificationsEnabledPolicy::UseGlobalPolicy:
    case WebKit::WebsitePushAndNotificationsEnabledPolicy::No:
    case WebKit::WebsitePushAndNotificationsEnabledPolicy::Yes:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebKit::AuthenticationChallengeDisposition>(uint8_t value)
{
    switch (static_cast<WebKit::AuthenticationChallengeDisposition>(value)) {
    case WebKit::AuthenticationChallengeDisposition::UseCredential:
    case WebKit::AuthenticationChallengeDisposition::PerformDefaultHandling:
    case WebKit::AuthenticationChallengeDisposition::Cancel:
    case WebKit::AuthenticationChallengeDisposition::RejectProtectionSpaceAndContinue:
        return true;
    default:
        return false;
    }
}

#if ENABLE(WK_WEB_EXTENSIONS_SIDEBAR)
template<> bool isValidEnum<WebKit::WebExtensionActionClickBehavior>(uint8_t value)
{
    switch (static_cast<WebKit::WebExtensionActionClickBehavior>(value)) {
    case WebKit::WebExtensionActionClickBehavior::OpenPopup:
    case WebKit::WebExtensionActionClickBehavior::OpenSidebar:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WK_WEB_EXTENSIONS)
template<> bool isValidEnum<WebKit::WebExtensionContentWorldType>(uint8_t value)
{
    switch (static_cast<WebKit::WebExtensionContentWorldType>(value)) {
    case WebKit::WebExtensionContentWorldType::Main:
    case WebKit::WebExtensionContentWorldType::ContentScript:
    case WebKit::WebExtensionContentWorldType::Native:
    case WebKit::WebExtensionContentWorldType::WebPage:
#if ENABLE(INSPECTOR_EXTENSIONS)
    case WebKit::WebExtensionContentWorldType::Inspector:
#endif
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WK_WEB_EXTENSIONS)
template<> bool isValidEnum<WebKit::WebExtensionContextInstallReason>(uint8_t value)
{
    switch (static_cast<WebKit::WebExtensionContextInstallReason>(value)) {
    case WebKit::WebExtensionContextInstallReason::None:
    case WebKit::WebExtensionContextInstallReason::ExtensionInstall:
    case WebKit::WebExtensionContextInstallReason::ExtensionUpdate:
    case WebKit::WebExtensionContextInstallReason::BrowserUpdate:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WK_WEB_EXTENSIONS)
template<> bool isValidEnum<WebKit::WebExtensionContext::WindowIsClosing>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WK_WEB_EXTENSIONS)
template<> bool isValidEnum<WebKit::WebExtension::InjectionTime>(uint8_t value)
{
    switch (static_cast<WebKit::WebExtension::InjectionTime>(value)) {
    case WebKit::WebExtension::InjectionTime::DocumentIdle:
    case WebKit::WebExtension::InjectionTime::DocumentStart:
    case WebKit::WebExtension::InjectionTime::DocumentEnd:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WK_WEB_EXTENSIONS)
template<> bool isValidEnum<WebKit::WebExtensionEventListenerType>(uint8_t value)
{
    switch (static_cast<WebKit::WebExtensionEventListenerType>(value)) {
    case WebKit::WebExtensionEventListenerType::Unknown:
    case WebKit::WebExtensionEventListenerType::ActionOnClicked:
    case WebKit::WebExtensionEventListenerType::AlarmsOnAlarm:
    case WebKit::WebExtensionEventListenerType::CommandsOnChanged:
    case WebKit::WebExtensionEventListenerType::CommandsOnCommand:
    case WebKit::WebExtensionEventListenerType::CookiesOnChanged:
    case WebKit::WebExtensionEventListenerType::DevToolsElementsPanelOnSelectionChanged:
    case WebKit::WebExtensionEventListenerType::DevToolsExtensionPanelOnHidden:
    case WebKit::WebExtensionEventListenerType::DevToolsExtensionPanelOnSearch:
    case WebKit::WebExtensionEventListenerType::DevToolsExtensionPanelOnShown:
    case WebKit::WebExtensionEventListenerType::DevToolsExtensionSidebarPaneOnHidden:
    case WebKit::WebExtensionEventListenerType::DevToolsExtensionSidebarPaneOnShown:
    case WebKit::WebExtensionEventListenerType::DevToolsInspectedWindowOnResourceAdded:
    case WebKit::WebExtensionEventListenerType::DevToolsNetworkOnNavigated:
    case WebKit::WebExtensionEventListenerType::DevToolsNetworkOnRequestFinished:
    case WebKit::WebExtensionEventListenerType::DevToolsPanelsOnThemeChanged:
    case WebKit::WebExtensionEventListenerType::DownloadsOnChanged:
    case WebKit::WebExtensionEventListenerType::DownloadsOnCreated:
    case WebKit::WebExtensionEventListenerType::MenusOnClicked:
    case WebKit::WebExtensionEventListenerType::NotificationsOnButtonClicked:
    case WebKit::WebExtensionEventListenerType::NotificationsOnClicked:
    case WebKit::WebExtensionEventListenerType::PermissionsOnAdded:
    case WebKit::WebExtensionEventListenerType::PermissionsOnRemoved:
    case WebKit::WebExtensionEventListenerType::PortOnDisconnect:
    case WebKit::WebExtensionEventListenerType::PortOnMessage:
    case WebKit::WebExtensionEventListenerType::RuntimeOnConnect:
    case WebKit::WebExtensionEventListenerType::RuntimeOnConnectExternal:
    case WebKit::WebExtensionEventListenerType::RuntimeOnInstalled:
    case WebKit::WebExtensionEventListenerType::RuntimeOnMessage:
    case WebKit::WebExtensionEventListenerType::RuntimeOnMessageExternal:
    case WebKit::WebExtensionEventListenerType::RuntimeOnStartup:
    case WebKit::WebExtensionEventListenerType::StorageOnChanged:
    case WebKit::WebExtensionEventListenerType::TabsOnActivated:
    case WebKit::WebExtensionEventListenerType::TabsOnAttached:
    case WebKit::WebExtensionEventListenerType::TabsOnCreated:
    case WebKit::WebExtensionEventListenerType::TabsOnDetached:
    case WebKit::WebExtensionEventListenerType::TabsOnHighlighted:
    case WebKit::WebExtensionEventListenerType::TabsOnMoved:
    case WebKit::WebExtensionEventListenerType::TabsOnRemoved:
    case WebKit::WebExtensionEventListenerType::TabsOnReplaced:
    case WebKit::WebExtensionEventListenerType::TabsOnUpdated:
    case WebKit::WebExtensionEventListenerType::TestOnMessage:
    case WebKit::WebExtensionEventListenerType::TestOnTestStarted:
    case WebKit::WebExtensionEventListenerType::TestOnTestFinished:
    case WebKit::WebExtensionEventListenerType::WebNavigationOnBeforeNavigate:
    case WebKit::WebExtensionEventListenerType::WebNavigationOnCommitted:
    case WebKit::WebExtensionEventListenerType::WebNavigationOnCompleted:
    case WebKit::WebExtensionEventListenerType::WebNavigationOnDOMContentLoaded:
    case WebKit::WebExtensionEventListenerType::WebNavigationOnErrorOccurred:
    case WebKit::WebExtensionEventListenerType::WebRequestOnAuthRequired:
    case WebKit::WebExtensionEventListenerType::WebRequestOnBeforeRedirect:
    case WebKit::WebExtensionEventListenerType::WebRequestOnBeforeRequest:
    case WebKit::WebExtensionEventListenerType::WebRequestOnBeforeSendHeaders:
    case WebKit::WebExtensionEventListenerType::WebRequestOnCompleted:
    case WebKit::WebExtensionEventListenerType::WebRequestOnErrorOccurred:
    case WebKit::WebExtensionEventListenerType::WebRequestOnHeadersReceived:
    case WebKit::WebExtensionEventListenerType::WebRequestOnResponseStarted:
    case WebKit::WebExtensionEventListenerType::WebRequestOnSendHeaders:
    case WebKit::WebExtensionEventListenerType::WindowsOnCreated:
    case WebKit::WebExtensionEventListenerType::WindowsOnFocusChanged:
    case WebKit::WebExtensionEventListenerType::WindowsOnRemoved:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WK_WEB_EXTENSIONS)
template<> bool isValidEnum<WebKit::WebExtensionMenuItemType>(uint8_t value)
{
    switch (static_cast<WebKit::WebExtensionMenuItemType>(value)) {
    case WebKit::WebExtensionMenuItemType::Normal:
    case WebKit::WebExtensionMenuItemType::Checkbox:
    case WebKit::WebExtensionMenuItemType::Radio:
    case WebKit::WebExtensionMenuItemType::Separator:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WK_WEB_EXTENSIONS)
template<> bool isValidOptionSet<WebKit::WebExtensionMenuItemContextType>(OptionSet<WebKit::WebExtensionMenuItemContextType> value)
{
    constexpr uint16_t allValidBitsValue = 0
        | static_cast<uint16_t>(WebKit::WebExtensionMenuItemContextType::Action)
        | static_cast<uint16_t>(WebKit::WebExtensionMenuItemContextType::Audio)
        | static_cast<uint16_t>(WebKit::WebExtensionMenuItemContextType::Editable)
        | static_cast<uint16_t>(WebKit::WebExtensionMenuItemContextType::Frame)
        | static_cast<uint16_t>(WebKit::WebExtensionMenuItemContextType::Image)
        | static_cast<uint16_t>(WebKit::WebExtensionMenuItemContextType::Link)
        | static_cast<uint16_t>(WebKit::WebExtensionMenuItemContextType::Page)
        | static_cast<uint16_t>(WebKit::WebExtensionMenuItemContextType::Selection)
        | static_cast<uint16_t>(WebKit::WebExtensionMenuItemContextType::Tab)
        | static_cast<uint16_t>(WebKit::WebExtensionMenuItemContextType::Video)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}
#endif

#if ENABLE(WK_WEB_EXTENSIONS)
template<> bool isValidEnum<WebKit::WebExtensionStorageAccessLevel>(uint8_t value)
{
    switch (static_cast<WebKit::WebExtensionStorageAccessLevel>(value)) {
    case WebKit::WebExtensionStorageAccessLevel::TrustedContexts:
    case WebKit::WebExtensionStorageAccessLevel::TrustedAndUntrustedContexts:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WK_WEB_EXTENSIONS)
template<> bool isValidEnum<WebKit::WebExtensionDataType>(uint8_t value)
{
    switch (static_cast<WebKit::WebExtensionDataType>(value)) {
    case WebKit::WebExtensionDataType::Local:
    case WebKit::WebExtensionDataType::Session:
    case WebKit::WebExtensionDataType::Sync:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WK_WEB_EXTENSIONS)
template<> bool isValidEnum<WebKit::WebExtensionTabImageFormat>(uint8_t value)
{
    switch (static_cast<WebKit::WebExtensionTabImageFormat>(value)) {
    case WebKit::WebExtensionTabImageFormat::PNG:
    case WebKit::WebExtensionTabImageFormat::JPEG:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WK_WEB_EXTENSIONS)
template<> bool isValidEnum<WebKit::ReloadFromOrigin>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WK_WEB_EXTENSIONS)
template<> bool isValidEnum<WebKit::WebExtensionWindow::PopulateTabs>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WK_WEB_EXTENSIONS)
template<> bool isValidEnum<WebKit::WebExtensionWindow::Type>(uint8_t value)
{
    switch (static_cast<WebKit::WebExtensionWindow::Type>(value)) {
    case WebKit::WebExtensionWindow::Type::Normal:
    case WebKit::WebExtensionWindow::Type::Popup:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WK_WEB_EXTENSIONS)
template<> bool isValidOptionSet<WebKit::WebExtensionWindowTypeFilter>(OptionSet<WebKit::WebExtensionWindowTypeFilter> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebKit::WebExtensionWindowTypeFilter::Normal)
        | static_cast<uint8_t>(WebKit::WebExtensionWindowTypeFilter::Popup)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}
#endif

#if ENABLE(WK_WEB_EXTENSIONS)
template<> bool isValidEnum<WebKit::WebExtensionWindow::State>(uint8_t value)
{
    switch (static_cast<WebKit::WebExtensionWindow::State>(value)) {
    case WebKit::WebExtensionWindow::State::Normal:
    case WebKit::WebExtensionWindow::State::Minimized:
    case WebKit::WebExtensionWindow::State::Maximized:
    case WebKit::WebExtensionWindow::State::Fullscreen:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(GPU_PROCESS)
template<> bool isValidEnum<WebKit::WebGPU::BindingResourceType>(uint8_t value)
{
    switch (static_cast<WebKit::WebGPU::BindingResourceType>(value)) {
    case WebKit::WebGPU::BindingResourceType::Sampler:
    case WebKit::WebGPU::BindingResourceType::TextureView:
    case WebKit::WebGPU::BindingResourceType::BufferBinding:
    case WebKit::WebGPU::BindingResourceType::ExternalTexture:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(GPU_PROCESS)
template<> bool isValidEnum<WebCore::WebGPU::FeatureName>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::FeatureName>(value)) {
    case WebCore::WebGPU::FeatureName::DepthClipControl:
    case WebCore::WebGPU::FeatureName::Depth32floatStencil8:
    case WebCore::WebGPU::FeatureName::TextureCompressionBc:
    case WebCore::WebGPU::FeatureName::TextureCompressionBcSliced3d:
    case WebCore::WebGPU::FeatureName::TextureCompressionEtc2:
    case WebCore::WebGPU::FeatureName::TextureCompressionAstc:
    case WebCore::WebGPU::FeatureName::TextureCompressionAstcSliced3d:
    case WebCore::WebGPU::FeatureName::TimestampQuery:
    case WebCore::WebGPU::FeatureName::IndirectFirstInstance:
    case WebCore::WebGPU::FeatureName::ShaderF16:
    case WebCore::WebGPU::FeatureName::Rg11b10ufloatRenderable:
    case WebCore::WebGPU::FeatureName::Bgra8unormStorage:
    case WebCore::WebGPU::FeatureName::Float32Filterable:
    case WebCore::WebGPU::FeatureName::Float32Blendable:
    case WebCore::WebGPU::FeatureName::ClipDistances:
    case WebCore::WebGPU::FeatureName::DualSourceBlending:
    case WebCore::WebGPU::FeatureName::Float16Renderable:
    case WebCore::WebGPU::FeatureName::Float32Renderable:
    case WebCore::WebGPU::FeatureName::CoreFeaturesAndLimits:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebKit::UnifiedOriginStorageLevel>(uint8_t value)
{
    switch (static_cast<WebKit::UnifiedOriginStorageLevel>(value)) {
    case WebKit::UnifiedOriginStorageLevel::None:
    case WebKit::UnifiedOriginStorageLevel::Basic:
    case WebKit::UnifiedOriginStorageLevel::Standard:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebKit::WebsiteDataFetchOption>(OptionSet<WebKit::WebsiteDataFetchOption> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebKit::WebsiteDataFetchOption::ComputeSizes)
        | static_cast<uint8_t>(WebKit::WebsiteDataFetchOption::DoNotCreateProcesses)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidOptionSet<WebKit::WebsiteDataType>(OptionSet<WebKit::WebsiteDataType> value)
{
    constexpr uint32_t allValidBitsValue = 0
        | static_cast<uint32_t>(WebKit::WebsiteDataType::Cookies)
        | static_cast<uint32_t>(WebKit::WebsiteDataType::DiskCache)
        | static_cast<uint32_t>(WebKit::WebsiteDataType::MemoryCache)
        | static_cast<uint32_t>(WebKit::WebsiteDataType::OfflineWebApplicationCache)
        | static_cast<uint32_t>(WebKit::WebsiteDataType::SessionStorage)
        | static_cast<uint32_t>(WebKit::WebsiteDataType::LocalStorage)
        | static_cast<uint32_t>(WebKit::WebsiteDataType::WebSQLDatabases)
        | static_cast<uint32_t>(WebKit::WebsiteDataType::IndexedDBDatabases)
        | static_cast<uint32_t>(WebKit::WebsiteDataType::MediaKeys)
        | static_cast<uint32_t>(WebKit::WebsiteDataType::HSTSCache)
        | static_cast<uint32_t>(WebKit::WebsiteDataType::SearchFieldRecentSearches)
        | static_cast<uint32_t>(WebKit::WebsiteDataType::ResourceLoadStatistics)
        | static_cast<uint32_t>(WebKit::WebsiteDataType::Credentials)
        | static_cast<uint32_t>(WebKit::WebsiteDataType::ServiceWorkerRegistrations)
        | static_cast<uint32_t>(WebKit::WebsiteDataType::DOMCache)
        | static_cast<uint32_t>(WebKit::WebsiteDataType::DeviceIdHashSalt)
        | static_cast<uint32_t>(WebKit::WebsiteDataType::PrivateClickMeasurements)
#if HAVE(ALTERNATIVE_SERVICE)
        | static_cast<uint32_t>(WebKit::WebsiteDataType::AlternativeServices)
#endif
        | static_cast<uint32_t>(WebKit::WebsiteDataType::FileSystem)
        | static_cast<uint32_t>(WebKit::WebsiteDataType::BackgroundFetchStorage)
#if ENABLE(SCREEN_TIME)
        | static_cast<uint32_t>(WebKit::WebsiteDataType::ScreenTime)
#endif
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

#if ENABLE(WEBXR)
template<> bool isValidEnum<PlatformXR::Layout>(uint8_t value)
{
    switch (static_cast<PlatformXR::Layout>(value)) {
    case PlatformXR::Layout::Shared:
    case PlatformXR::Layout::Layered:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WEBXR)
template<> bool isValidEnum<PlatformXR::SessionFeature>(uint8_t value)
{
    switch (static_cast<PlatformXR::SessionFeature>(value)) {
    case PlatformXR::SessionFeature::ReferenceSpaceTypeViewer:
    case PlatformXR::SessionFeature::ReferenceSpaceTypeLocal:
    case PlatformXR::SessionFeature::ReferenceSpaceTypeLocalFloor:
    case PlatformXR::SessionFeature::ReferenceSpaceTypeBoundedFloor:
    case PlatformXR::SessionFeature::ReferenceSpaceTypeUnbounded:
#if ENABLE(WEBXR_HANDS)
    case PlatformXR::SessionFeature::HandTracking:
#endif
    case PlatformXR::SessionFeature::WebGPU:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WEBXR)
template<> bool isValidEnum<PlatformXR::SessionMode>(uint8_t value)
{
    switch (static_cast<PlatformXR::SessionMode>(value)) {
    case PlatformXR::SessionMode::Inline:
    case PlatformXR::SessionMode::ImmersiveVr:
    case PlatformXR::SessionMode::ImmersiveAr:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WEBXR)
template<> bool isValidEnum<PlatformXR::ReferenceSpaceType>(uint8_t value)
{
    switch (static_cast<PlatformXR::ReferenceSpaceType>(value)) {
    case PlatformXR::ReferenceSpaceType::Viewer:
    case PlatformXR::ReferenceSpaceType::Local:
    case PlatformXR::ReferenceSpaceType::LocalFloor:
    case PlatformXR::ReferenceSpaceType::BoundedFloor:
    case PlatformXR::ReferenceSpaceType::Unbounded:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WEBXR)
template<> bool isValidEnum<PlatformXR::VisibilityState>(uint8_t value)
{
    switch (static_cast<PlatformXR::VisibilityState>(value)) {
    case PlatformXR::VisibilityState::Visible:
    case PlatformXR::VisibilityState::VisibleBlurred:
    case PlatformXR::VisibilityState::Hidden:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WEBXR)
template<> bool isValidEnum<PlatformXR::XRHandedness>(uint8_t value)
{
    switch (static_cast<PlatformXR::XRHandedness>(value)) {
    case PlatformXR::XRHandedness::None:
    case PlatformXR::XRHandedness::Left:
    case PlatformXR::XRHandedness::Right:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WEBXR)
template<> bool isValidEnum<PlatformXR::XRTargetRayMode>(uint8_t value)
{
    switch (static_cast<PlatformXR::XRTargetRayMode>(value)) {
    case PlatformXR::XRTargetRayMode::Gaze:
    case PlatformXR::XRTargetRayMode::TrackedPointer:
    case PlatformXR::XRTargetRayMode::Screen:
    case PlatformXR::XRTargetRayMode::TransientPointer:
        return true;
    default:
        return false;
    }
}
#endif

#if (ENABLE(WEBXR)) && (USE(OPENXR))
template<> bool isValidEnum<PlatformXR::Eye>(uint8_t value)
{
    switch (static_cast<PlatformXR::Eye>(value)) {
    case PlatformXR::Eye::None:
    case PlatformXR::Eye::Left:
    case PlatformXR::Eye::Right:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WK_WEB_EXTENSIONS)
template<> bool isValidEnum<WebKit::WebExtension::ModifierFlags>(uint32_t value)
{
    switch (static_cast<WebKit::WebExtension::ModifierFlags>(value)) {
    case WebKit::WebExtension::ModifierFlags::Shift:
    case WebKit::WebExtension::ModifierFlags::Control:
    case WebKit::WebExtension::ModifierFlags::Option:
    case WebKit::WebExtension::ModifierFlags::Command:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WK_WEB_EXTENSIONS)
template<> bool isValidEnum<WebKit::WebExtensionTab::ChangedProperties>(uint16_t value)
{
    switch (static_cast<WebKit::WebExtensionTab::ChangedProperties>(value)) {
    case WebKit::WebExtensionTab::ChangedProperties::Loading:
    case WebKit::WebExtensionTab::ChangedProperties::Muted:
    case WebKit::WebExtensionTab::ChangedProperties::Pinned:
    case WebKit::WebExtensionTab::ChangedProperties::PlayingAudio:
    case WebKit::WebExtensionTab::ChangedProperties::ReaderMode:
    case WebKit::WebExtensionTab::ChangedProperties::Size:
    case WebKit::WebExtensionTab::ChangedProperties::Title:
    case WebKit::WebExtensionTab::ChangedProperties::URL:
    case WebKit::WebExtensionTab::ChangedProperties::ZoomFactor:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(WK_WEB_EXTENSIONS)
template<> bool isValidEnum<WebKit::WebExtensionWindowTypeFilter>(uint8_t value)
{
    switch (static_cast<WebKit::WebExtensionWindowTypeFilter>(value)) {
    case WebKit::WebExtensionWindowTypeFilter::Normal:
    case WebKit::WebExtensionWindowTypeFilter::Popup:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(GPU_PROCESS)
template<> bool isValidOptionSet<WebKit::BufferInSetType>(OptionSet<WebKit::BufferInSetType> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebKit::BufferInSetType::Front)
        | static_cast<uint8_t>(WebKit::BufferInSetType::Back)
        | static_cast<uint8_t>(WebKit::BufferInSetType::SecondaryBack)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}
#endif

#if ENABLE(GPU_PROCESS) && PLATFORM(IOS_FAMILY)
template<> bool isValidEnum<WebCore::ShouldPause>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(GPU_PROCESS) && PLATFORM(IOS_FAMILY)
template<> bool isValidEnum<WebCore::HasAvailableTargets>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(GPU_PROCESS) && PLATFORM(IOS_FAMILY)
template<> bool isValidEnum<WebCore::SupportsAirPlayVideo>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(GPU_PROCESS) && PLATFORM(IOS_FAMILY)
template<> bool isValidEnum<WebCore::PlayingToAutomotiveHeadUnit>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(GPU_PROCESS) && PLATFORM(IOS_FAMILY)
template<> bool isValidEnum<WebCore::SuspendedUnderLock>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(GPU_PROCESS) && PLATFORM(IOS_FAMILY)
template<> bool isValidEnum<WebCore::SupportsSpatialAudioPlayback>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(GPU_PROCESS) && PLATFORM(IOS_FAMILY)
template<> bool isValidEnum<WebKit::RespectSelectionAnchor>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebKit::InjectUserScriptImmediately>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

#if USE(GRAPHICS_LAYER_WC)
template<> bool isValidOptionSet<WebKit::WCLayerChange>(OptionSet<WebKit::WCLayerChange> value)
{
    constexpr uint32_t allValidBitsValue = 0
        | static_cast<uint32_t>(WebKit::WCLayerChange::Children)
        | static_cast<uint32_t>(WebKit::WCLayerChange::MaskLayer)
        | static_cast<uint32_t>(WebKit::WCLayerChange::ReplicaLayer)
        | static_cast<uint32_t>(WebKit::WCLayerChange::Position)
        | static_cast<uint32_t>(WebKit::WCLayerChange::AnchorPoint)
        | static_cast<uint32_t>(WebKit::WCLayerChange::Size)
        | static_cast<uint32_t>(WebKit::WCLayerChange::BoundsOrigin)
        | static_cast<uint32_t>(WebKit::WCLayerChange::MasksToBounds)
        | static_cast<uint32_t>(WebKit::WCLayerChange::ContentsRectClipsDescendants)
        | static_cast<uint32_t>(WebKit::WCLayerChange::ShowDebugBorder)
        | static_cast<uint32_t>(WebKit::WCLayerChange::ShowRepaintCounter)
        | static_cast<uint32_t>(WebKit::WCLayerChange::ContentsVisible)
        | static_cast<uint32_t>(WebKit::WCLayerChange::BackfaceVisibility)
        | static_cast<uint32_t>(WebKit::WCLayerChange::Preserves3D)
        | static_cast<uint32_t>(WebKit::WCLayerChange::SolidColor)
        | static_cast<uint32_t>(WebKit::WCLayerChange::DebugBorderColor)
        | static_cast<uint32_t>(WebKit::WCLayerChange::Opacity)
        | static_cast<uint32_t>(WebKit::WCLayerChange::DebugBorderWidth)
        | static_cast<uint32_t>(WebKit::WCLayerChange::RepaintCount)
        | static_cast<uint32_t>(WebKit::WCLayerChange::ContentsRect)
        | static_cast<uint32_t>(WebKit::WCLayerChange::Background)
        | static_cast<uint32_t>(WebKit::WCLayerChange::Transform)
        | static_cast<uint32_t>(WebKit::WCLayerChange::ChildrenTransform)
        | static_cast<uint32_t>(WebKit::WCLayerChange::Filters)
        | static_cast<uint32_t>(WebKit::WCLayerChange::BackdropFilters)
        | static_cast<uint32_t>(WebKit::WCLayerChange::BackdropFiltersRect)
        | static_cast<uint32_t>(WebKit::WCLayerChange::ContentsClippingRect)
        | static_cast<uint32_t>(WebKit::WCLayerChange::PlatformLayer)
        | static_cast<uint32_t>(WebKit::WCLayerChange::RemoteFrame)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}
#endif

template<> bool isValidEnum<WebCore::HTTPHeaderName>(uint16_t value)
{
    switch (static_cast<WebCore::HTTPHeaderName>(value)) {
    case WebCore::HTTPHeaderName::Accept:
    case WebCore::HTTPHeaderName::AcceptCharset:
    case WebCore::HTTPHeaderName::AcceptEncoding:
    case WebCore::HTTPHeaderName::AcceptLanguage:
    case WebCore::HTTPHeaderName::AcceptRanges:
    case WebCore::HTTPHeaderName::AccessControlAllowCredentials:
    case WebCore::HTTPHeaderName::AccessControlAllowHeaders:
    case WebCore::HTTPHeaderName::AccessControlAllowMethods:
    case WebCore::HTTPHeaderName::AccessControlAllowOrigin:
    case WebCore::HTTPHeaderName::AccessControlExposeHeaders:
    case WebCore::HTTPHeaderName::AccessControlMaxAge:
    case WebCore::HTTPHeaderName::AccessControlRequestHeaders:
    case WebCore::HTTPHeaderName::AccessControlRequestMethod:
    case WebCore::HTTPHeaderName::Age:
    case WebCore::HTTPHeaderName::Authorization:
    case WebCore::HTTPHeaderName::CacheControl:
    case WebCore::HTTPHeaderName::ClearSiteData:
    case WebCore::HTTPHeaderName::Connection:
    case WebCore::HTTPHeaderName::ContentDisposition:
    case WebCore::HTTPHeaderName::ContentEncoding:
    case WebCore::HTTPHeaderName::ContentLanguage:
    case WebCore::HTTPHeaderName::ContentLength:
    case WebCore::HTTPHeaderName::ContentLocation:
    case WebCore::HTTPHeaderName::ContentRange:
    case WebCore::HTTPHeaderName::ContentSecurityPolicy:
    case WebCore::HTTPHeaderName::ContentSecurityPolicyReportOnly:
    case WebCore::HTTPHeaderName::ContentType:
    case WebCore::HTTPHeaderName::Cookie:
    case WebCore::HTTPHeaderName::Cookie2:
    case WebCore::HTTPHeaderName::CrossOriginEmbedderPolicy:
    case WebCore::HTTPHeaderName::CrossOriginEmbedderPolicyReportOnly:
    case WebCore::HTTPHeaderName::CrossOriginOpenerPolicy:
    case WebCore::HTTPHeaderName::CrossOriginOpenerPolicyReportOnly:
    case WebCore::HTTPHeaderName::CrossOriginResourcePolicy:
    case WebCore::HTTPHeaderName::DNT:
    case WebCore::HTTPHeaderName::Date:
    case WebCore::HTTPHeaderName::DefaultStyle:
    case WebCore::HTTPHeaderName::ETag:
    case WebCore::HTTPHeaderName::Expect:
    case WebCore::HTTPHeaderName::Expires:
    case WebCore::HTTPHeaderName::Host:
    case WebCore::HTTPHeaderName::IcyMetaInt:
    case WebCore::HTTPHeaderName::IcyMetadata:
    case WebCore::HTTPHeaderName::IfMatch:
    case WebCore::HTTPHeaderName::IfModifiedSince:
    case WebCore::HTTPHeaderName::IfNoneMatch:
    case WebCore::HTTPHeaderName::IfRange:
    case WebCore::HTTPHeaderName::IfUnmodifiedSince:
    case WebCore::HTTPHeaderName::IntegrityPolicy:
    case WebCore::HTTPHeaderName::IntegrityPolicyReportOnly:
    case WebCore::HTTPHeaderName::KeepAlive:
    case WebCore::HTTPHeaderName::LastEventID:
    case WebCore::HTTPHeaderName::LastModified:
    case WebCore::HTTPHeaderName::Link:
    case WebCore::HTTPHeaderName::Location:
    case WebCore::HTTPHeaderName::Origin:
    case WebCore::HTTPHeaderName::PingFrom:
    case WebCore::HTTPHeaderName::PingTo:
    case WebCore::HTTPHeaderName::Pragma:
    case WebCore::HTTPHeaderName::ProxyAuthorization:
    case WebCore::HTTPHeaderName::Range:
    case WebCore::HTTPHeaderName::Referer:
    case WebCore::HTTPHeaderName::ReferrerPolicy:
    case WebCore::HTTPHeaderName::Refresh:
    case WebCore::HTTPHeaderName::ReportTo:
    case WebCore::HTTPHeaderName::ReportingEndpoints:
    case WebCore::HTTPHeaderName::SecFetchDest:
    case WebCore::HTTPHeaderName::SecFetchMode:
    case WebCore::HTTPHeaderName::SecFetchSite:
    case WebCore::HTTPHeaderName::SecPurpose:
    case WebCore::HTTPHeaderName::SecWebSocketAccept:
    case WebCore::HTTPHeaderName::SecWebSocketExtensions:
    case WebCore::HTTPHeaderName::SecWebSocketKey:
    case WebCore::HTTPHeaderName::SecWebSocketProtocol:
    case WebCore::HTTPHeaderName::SecWebSocketVersion:
    case WebCore::HTTPHeaderName::ServerTiming:
    case WebCore::HTTPHeaderName::ServiceWorker:
    case WebCore::HTTPHeaderName::ServiceWorkerAllowed:
    case WebCore::HTTPHeaderName::ServiceWorkerNavigationPreload:
    case WebCore::HTTPHeaderName::SetCookie:
    case WebCore::HTTPHeaderName::SetCookie2:
    case WebCore::HTTPHeaderName::SourceMap:
    case WebCore::HTTPHeaderName::TE:
    case WebCore::HTTPHeaderName::TimingAllowOrigin:
    case WebCore::HTTPHeaderName::Trailer:
    case WebCore::HTTPHeaderName::TransferEncoding:
    case WebCore::HTTPHeaderName::Upgrade:
    case WebCore::HTTPHeaderName::UpgradeInsecureRequests:
    case WebCore::HTTPHeaderName::UserAgent:
    case WebCore::HTTPHeaderName::Vary:
    case WebCore::HTTPHeaderName::Via:
    case WebCore::HTTPHeaderName::XContentTypeOptions:
    case WebCore::HTTPHeaderName::XFrameOptions:
    case WebCore::HTTPHeaderName::XSourceMap:
    case WebCore::HTTPHeaderName::XTempTablet:
    case WebCore::HTTPHeaderName::XXSSProtection:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebCore::ActivityState>(OptionSet<WebCore::ActivityState> value)
{
    constexpr uint16_t allValidBitsValue = 0
        | static_cast<uint16_t>(WebCore::ActivityState::WindowIsActive)
        | static_cast<uint16_t>(WebCore::ActivityState::IsFocused)
        | static_cast<uint16_t>(WebCore::ActivityState::IsVisible)
        | static_cast<uint16_t>(WebCore::ActivityState::IsVisibleOrOccluded)
        | static_cast<uint16_t>(WebCore::ActivityState::IsInWindow)
        | static_cast<uint16_t>(WebCore::ActivityState::IsVisuallyIdle)
        | static_cast<uint16_t>(WebCore::ActivityState::IsAudible)
        | static_cast<uint16_t>(WebCore::ActivityState::IsLoading)
        | static_cast<uint16_t>(WebCore::ActivityState::IsCapturingMedia)
        | static_cast<uint16_t>(WebCore::ActivityState::IsConnectedToHardwareConsole)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidOptionSet<WebCore::DragDestinationAction>(OptionSet<WebCore::DragDestinationAction> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebCore::DragDestinationAction::DHTML)
        | static_cast<uint8_t>(WebCore::DragDestinationAction::Edit)
        | static_cast<uint8_t>(WebCore::DragDestinationAction::Load)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidEnum<WebCore::DragHandlingMethod>(uint8_t value)
{
    switch (static_cast<WebCore::DragHandlingMethod>(value)) {
    case WebCore::DragHandlingMethod::None:
    case WebCore::DragHandlingMethod::EditPlainText:
    case WebCore::DragHandlingMethod::EditRichText:
    case WebCore::DragHandlingMethod::UploadFile:
    case WebCore::DragHandlingMethod::PageLoad:
    case WebCore::DragHandlingMethod::SetColor:
    case WebCore::DragHandlingMethod::NonDefault:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebCore::DragOperation>(OptionSet<WebCore::DragOperation> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebCore::DragOperation::Copy)
        | static_cast<uint8_t>(WebCore::DragOperation::Link)
        | static_cast<uint8_t>(WebCore::DragOperation::Generic)
        | static_cast<uint8_t>(WebCore::DragOperation::Private)
        | static_cast<uint8_t>(WebCore::DragOperation::Move)
        | static_cast<uint8_t>(WebCore::DragOperation::Delete)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidEnum<WebCore::DragOperation>(uint8_t value)
{
    switch (static_cast<WebCore::DragOperation>(value)) {
    case WebCore::DragOperation::Copy:
    case WebCore::DragOperation::Link:
    case WebCore::DragOperation::Generic:
    case WebCore::DragOperation::Private:
    case WebCore::DragOperation::Move:
    case WebCore::DragOperation::Delete:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::DragSourceAction>(uint8_t value)
{
    switch (static_cast<WebCore::DragSourceAction>(value)) {
    case WebCore::DragSourceAction::DHTML:
    case WebCore::DragSourceAction::Image:
    case WebCore::DragSourceAction::Link:
    case WebCore::DragSourceAction::Selection:
#if ENABLE(ATTACHMENT_ELEMENT)
    case WebCore::DragSourceAction::Attachment:
#endif
    case WebCore::DragSourceAction::Color:
#if ENABLE(MODEL_ELEMENT)
    case WebCore::DragSourceAction::Model:
#endif
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebCore::DragSourceAction>(OptionSet<WebCore::DragSourceAction> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebCore::DragSourceAction::DHTML)
        | static_cast<uint8_t>(WebCore::DragSourceAction::Image)
        | static_cast<uint8_t>(WebCore::DragSourceAction::Link)
        | static_cast<uint8_t>(WebCore::DragSourceAction::Selection)
#if ENABLE(ATTACHMENT_ELEMENT)
        | static_cast<uint8_t>(WebCore::DragSourceAction::Attachment)
#endif
        | static_cast<uint8_t>(WebCore::DragSourceAction::Color)
#if ENABLE(MODEL_ELEMENT)
        | static_cast<uint8_t>(WebCore::DragSourceAction::Model)
#endif
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

#if ENABLE(GPU_PROCESS) && ENABLE(VIDEO)
template<> bool isValidEnum<WebCore::InbandTextTrackPrivate::CueFormat>(uint8_t value)
{
    switch (static_cast<WebCore::InbandTextTrackPrivate::CueFormat>(value)) {
    case WebCore::InbandTextTrackPrivate::CueFormat::Data:
    case WebCore::InbandTextTrackPrivate::CueFormat::Generic:
    case WebCore::InbandTextTrackPrivate::CueFormat::WebVTT:
    case WebCore::InbandTextTrackPrivate::CueFormat::Unknown:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(GPU_PROCESS) && ENABLE(VIDEO)
template<> bool isValidEnum<WebCore::InbandTextTrackPrivateMode>(uint8_t value)
{
    switch (static_cast<WebCore::InbandTextTrackPrivateMode>(value)) {
    case WebCore::InbandTextTrackPrivateMode::Disabled:
    case WebCore::InbandTextTrackPrivateMode::Hidden:
    case WebCore::InbandTextTrackPrivateMode::Showing:
        return true;
    default:
        return false;
    }
}
#endif

#if ENABLE(GPU_PROCESS) && ENABLE(VIDEO)
template<> bool isValidEnum<WebCore::InbandTextTrackPrivate::Kind>(uint8_t value)
{
    switch (static_cast<WebCore::InbandTextTrackPrivate::Kind>(value)) {
    case WebCore::InbandTextTrackPrivate::Kind::Subtitles:
    case WebCore::InbandTextTrackPrivate::Kind::Captions:
    case WebCore::InbandTextTrackPrivate::Kind::Descriptions:
    case WebCore::InbandTextTrackPrivate::Kind::Chapters:
    case WebCore::InbandTextTrackPrivate::Kind::Metadata:
    case WebCore::InbandTextTrackPrivate::Kind::Forced:
    case WebCore::InbandTextTrackPrivate::Kind::None:
        return true;
    default:
        return false;
    }
}
#endif

template<> bool isValidEnum<WebCore::IndexedDB::IndexRecordType>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::IndexedDB::ConnectionClosedOnBehalfOfServer>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::IndexedDB::CursorIterateOption>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::IndexedDB::CursorSource>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::IndexedDB::CursorType>(bool value)
{
    switch (static_cast<uint8_t>(value)) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebCore::LayoutMilestone>(OptionSet<WebCore::LayoutMilestone> value)
{
    constexpr uint16_t allValidBitsValue = 0
        | static_cast<uint16_t>(WebCore::LayoutMilestone::DidFirstLayout)
        | static_cast<uint16_t>(WebCore::LayoutMilestone::DidFirstVisuallyNonEmptyLayout)
        | static_cast<uint16_t>(WebCore::LayoutMilestone::DidHitRelevantRepaintedObjectsAreaThreshold)
        | static_cast<uint16_t>(WebCore::LayoutMilestone::DidFirstLayoutAfterSuppressedIncrementalRendering)
        | static_cast<uint16_t>(WebCore::LayoutMilestone::DidFirstPaintAfterSuppressedIncrementalRendering)
        | static_cast<uint16_t>(WebCore::LayoutMilestone::ReachedSessionRestorationRenderTreeSizeThreshold)
        | static_cast<uint16_t>(WebCore::LayoutMilestone::DidRenderSignificantAmountOfText)
        | static_cast<uint16_t>(WebCore::LayoutMilestone::DidFirstMeaningfulPaint)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidEnum<WebCore::MDNSRegisterError>(uint8_t value)
{
    switch (static_cast<WebCore::MDNSRegisterError>(value)) {
    case WebCore::MDNSRegisterError::NotImplemented:
    case WebCore::MDNSRegisterError::BadParameter:
    case WebCore::MDNSRegisterError::DNSSD:
    case WebCore::MDNSRegisterError::Internal:
    case WebCore::MDNSRegisterError::Timeout:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebCore::MediaProducerMediaState>(OptionSet<WebCore::MediaProducerMediaState> value)
{
    constexpr uint32_t allValidBitsValue = 0
        | static_cast<uint32_t>(WebCore::MediaProducerMediaState::IsPlayingAudio)
        | static_cast<uint32_t>(WebCore::MediaProducerMediaState::IsPlayingVideo)
        | static_cast<uint32_t>(WebCore::MediaProducerMediaState::IsPlayingToExternalDevice)
        | static_cast<uint32_t>(WebCore::MediaProducerMediaState::RequiresPlaybackTargetMonitoring)
        | static_cast<uint32_t>(WebCore::MediaProducerMediaState::ExternalDeviceAutoPlayCandidate)
        | static_cast<uint32_t>(WebCore::MediaProducerMediaState::DidPlayToEnd)
        | static_cast<uint32_t>(WebCore::MediaProducerMediaState::IsSourceElementPlaying)
        | static_cast<uint32_t>(WebCore::MediaProducerMediaState::IsNextTrackControlEnabled)
        | static_cast<uint32_t>(WebCore::MediaProducerMediaState::IsPreviousTrackControlEnabled)
        | static_cast<uint32_t>(WebCore::MediaProducerMediaState::HasPlaybackTargetAvailabilityListener)
        | static_cast<uint32_t>(WebCore::MediaProducerMediaState::HasAudioOrVideo)
        | static_cast<uint32_t>(WebCore::MediaProducerMediaState::HasActiveAudioCaptureDevice)
        | static_cast<uint32_t>(WebCore::MediaProducerMediaState::HasActiveVideoCaptureDevice)
        | static_cast<uint32_t>(WebCore::MediaProducerMediaState::HasMutedAudioCaptureDevice)
        | static_cast<uint32_t>(WebCore::MediaProducerMediaState::HasMutedVideoCaptureDevice)
        | static_cast<uint32_t>(WebCore::MediaProducerMediaState::HasInterruptedAudioCaptureDevice)
        | static_cast<uint32_t>(WebCore::MediaProducerMediaState::HasInterruptedVideoCaptureDevice)
        | static_cast<uint32_t>(WebCore::MediaProducerMediaState::HasUserInteractedWithMediaElement)
        | static_cast<uint32_t>(WebCore::MediaProducerMediaState::HasActiveScreenCaptureDevice)
        | static_cast<uint32_t>(WebCore::MediaProducerMediaState::HasMutedScreenCaptureDevice)
        | static_cast<uint32_t>(WebCore::MediaProducerMediaState::HasInterruptedScreenCaptureDevice)
        | static_cast<uint32_t>(WebCore::MediaProducerMediaState::HasActiveWindowCaptureDevice)
        | static_cast<uint32_t>(WebCore::MediaProducerMediaState::HasMutedWindowCaptureDevice)
        | static_cast<uint32_t>(WebCore::MediaProducerMediaState::HasInterruptedWindowCaptureDevice)
        | static_cast<uint32_t>(WebCore::MediaProducerMediaState::HasActiveSystemAudioCaptureDevice)
        | static_cast<uint32_t>(WebCore::MediaProducerMediaState::HasMutedSystemAudioCaptureDevice)
        | static_cast<uint32_t>(WebCore::MediaProducerMediaState::HasInterruptedSystemAudioCaptureDevice)
        | static_cast<uint32_t>(WebCore::MediaProducerMediaState::HasStreamingActivity)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidOptionSet<WebCore::MediaProducerMutedState>(OptionSet<WebCore::MediaProducerMutedState> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebCore::MediaProducerMutedState::AudioIsMuted)
        | static_cast<uint8_t>(WebCore::MediaProducerMutedState::AudioCaptureIsMuted)
        | static_cast<uint8_t>(WebCore::MediaProducerMutedState::VideoCaptureIsMuted)
        | static_cast<uint8_t>(WebCore::MediaProducerMutedState::ScreenCaptureIsMuted)
        | static_cast<uint8_t>(WebCore::MediaProducerMutedState::WindowCaptureIsMuted)
        | static_cast<uint8_t>(WebCore::MediaProducerMutedState::SystemAudioCaptureIsMuted)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidOptionSet<WebCore::PlatformEventModifier>(OptionSet<WebCore::PlatformEventModifier> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebCore::PlatformEventModifier::AltKey)
        | static_cast<uint8_t>(WebCore::PlatformEventModifier::ControlKey)
        | static_cast<uint8_t>(WebCore::PlatformEventModifier::MetaKey)
        | static_cast<uint8_t>(WebCore::PlatformEventModifier::ShiftKey)
        | static_cast<uint8_t>(WebCore::PlatformEventModifier::CapsLockKey)
        | static_cast<uint8_t>(WebCore::PlatformEventModifier::AltGraphKey)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidEnum<WebCore::PlatformMediaSessionRemoteControlCommandType>(uint8_t value)
{
    switch (static_cast<WebCore::PlatformMediaSessionRemoteControlCommandType>(value)) {
    case WebCore::PlatformMediaSessionRemoteControlCommandType::NoCommand:
    case WebCore::PlatformMediaSessionRemoteControlCommandType::PlayCommand:
    case WebCore::PlatformMediaSessionRemoteControlCommandType::PauseCommand:
    case WebCore::PlatformMediaSessionRemoteControlCommandType::StopCommand:
    case WebCore::PlatformMediaSessionRemoteControlCommandType::TogglePlayPauseCommand:
    case WebCore::PlatformMediaSessionRemoteControlCommandType::BeginSeekingBackwardCommand:
    case WebCore::PlatformMediaSessionRemoteControlCommandType::EndSeekingBackwardCommand:
    case WebCore::PlatformMediaSessionRemoteControlCommandType::BeginSeekingForwardCommand:
    case WebCore::PlatformMediaSessionRemoteControlCommandType::EndSeekingForwardCommand:
    case WebCore::PlatformMediaSessionRemoteControlCommandType::SeekToPlaybackPositionCommand:
    case WebCore::PlatformMediaSessionRemoteControlCommandType::SkipForwardCommand:
    case WebCore::PlatformMediaSessionRemoteControlCommandType::SkipBackwardCommand:
    case WebCore::PlatformMediaSessionRemoteControlCommandType::NextTrackCommand:
    case WebCore::PlatformMediaSessionRemoteControlCommandType::PreviousTrackCommand:
    case WebCore::PlatformMediaSessionRemoteControlCommandType::BeginScrubbingCommand:
    case WebCore::PlatformMediaSessionRemoteControlCommandType::EndScrubbingCommand:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::PlatformMediaSessionMediaType>(uint8_t value)
{
    switch (static_cast<WebCore::PlatformMediaSessionMediaType>(value)) {
    case WebCore::PlatformMediaSessionMediaType::None:
    case WebCore::PlatformMediaSessionMediaType::Video:
    case WebCore::PlatformMediaSessionMediaType::VideoAudio:
    case WebCore::PlatformMediaSessionMediaType::Audio:
    case WebCore::PlatformMediaSessionMediaType::WebAudio:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::PlatformMediaSessionState>(uint8_t value)
{
    switch (static_cast<WebCore::PlatformMediaSessionState>(value)) {
    case WebCore::PlatformMediaSessionState::Idle:
    case WebCore::PlatformMediaSessionState::Autoplaying:
    case WebCore::PlatformMediaSessionState::Playing:
    case WebCore::PlatformMediaSessionState::Paused:
    case WebCore::PlatformMediaSessionState::Interrupted:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::PlatformMediaSessionInterruptionType>(uint8_t value)
{
    switch (static_cast<WebCore::PlatformMediaSessionInterruptionType>(value)) {
    case WebCore::PlatformMediaSessionInterruptionType::NoInterruption:
    case WebCore::PlatformMediaSessionInterruptionType::SystemSleep:
    case WebCore::PlatformMediaSessionInterruptionType::EnteringBackground:
    case WebCore::PlatformMediaSessionInterruptionType::SystemInterruption:
    case WebCore::PlatformMediaSessionInterruptionType::SuspendedUnderLock:
    case WebCore::PlatformMediaSessionInterruptionType::InvisibleAutoplay:
    case WebCore::PlatformMediaSessionInterruptionType::ProcessInactive:
    case WebCore::PlatformMediaSessionInterruptionType::PlaybackSuspended:
    case WebCore::PlatformMediaSessionInterruptionType::PageNotVisible:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebCore::PlatformMediaSessionEndInterruptionFlags>(OptionSet<WebCore::PlatformMediaSessionEndInterruptionFlags> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebCore::PlatformMediaSessionEndInterruptionFlags::NoFlags)
        | static_cast<uint8_t>(WebCore::PlatformMediaSessionEndInterruptionFlags::MayResumePlaying)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidEnum<WebCore::DynamicRangeMode>(uint8_t value)
{
    switch (static_cast<WebCore::DynamicRangeMode>(value)) {
    case WebCore::DynamicRangeMode::None:
    case WebCore::DynamicRangeMode::Standard:
    case WebCore::DynamicRangeMode::HLG:
    case WebCore::DynamicRangeMode::HDR10:
    case WebCore::DynamicRangeMode::DolbyVisionPQ:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::PlatformWheelEventPhase>(uint8_t value)
{
    switch (static_cast<WebCore::PlatformWheelEventPhase>(value)) {
    case WebCore::PlatformWheelEventPhase::None:
#if ENABLE(KINETIC_SCROLLING)
    case WebCore::PlatformWheelEventPhase::Began:
#endif
#if ENABLE(KINETIC_SCROLLING)
    case WebCore::PlatformWheelEventPhase::Stationary:
#endif
#if ENABLE(KINETIC_SCROLLING)
    case WebCore::PlatformWheelEventPhase::Changed:
#endif
#if ENABLE(KINETIC_SCROLLING)
    case WebCore::PlatformWheelEventPhase::Ended:
#endif
#if ENABLE(KINETIC_SCROLLING)
    case WebCore::PlatformWheelEventPhase::Cancelled:
#endif
#if ENABLE(KINETIC_SCROLLING)
    case WebCore::PlatformWheelEventPhase::MayBegin:
#endif
#if ENABLE(KINETIC_SCROLLING)
    case WebCore::PlatformWheelEventPhase::WillBegin:
#endif
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ProcessSyncDataType>(uint8_t value)
{
    switch (static_cast<WebCore::ProcessSyncDataType>(value)) {
#if ENABLE(DOM_AUDIO_SESSION)
    case WebCore::ProcessSyncDataType::AudioSessionType:
#endif
    case WebCore::ProcessSyncDataType::IsAutofocusProcessed:
    case WebCore::ProcessSyncDataType::UserDidInteractWithPage:
    case WebCore::ProcessSyncDataType::IsClosing:
    case WebCore::ProcessSyncDataType::DocumentURL:
    case WebCore::ProcessSyncDataType::DocumentSecurityOrigin:
    case WebCore::ProcessSyncDataType::DocumentClasses:
    case WebCore::ProcessSyncDataType::HasInjectedUserScript:
    case WebCore::ProcessSyncDataType::FrameCanCreatePaymentSession:
    case WebCore::ProcessSyncDataType::FrameDocumentSecurityOrigin:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ScrollDirection>(uint8_t value)
{
    switch (static_cast<WebCore::ScrollDirection>(value)) {
    case WebCore::ScrollDirection::ScrollUp:
    case WebCore::ScrollDirection::ScrollDown:
    case WebCore::ScrollDirection::ScrollLeft:
    case WebCore::ScrollDirection::ScrollRight:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ScrollbarOrientation>(uint8_t value)
{
    switch (static_cast<WebCore::ScrollbarOrientation>(value)) {
    case WebCore::ScrollbarOrientation::Horizontal:
    case WebCore::ScrollbarOrientation::Vertical:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ScrollbarWidth>(uint8_t value)
{
    switch (static_cast<WebCore::ScrollbarWidth>(value)) {
    case WebCore::ScrollbarWidth::Auto:
    case WebCore::ScrollbarWidth::Thin:
    case WebCore::ScrollbarWidth::None:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::RubberBandingBehavior>(uint8_t value)
{
    switch (static_cast<WebCore::RubberBandingBehavior>(value)) {
    case WebCore::RubberBandingBehavior::Always:
    case WebCore::RubberBandingBehavior::Never:
    case WebCore::RubberBandingBehavior::BasedOnSize:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::ScrollbarOverlayStyle>(uint8_t value)
{
    switch (static_cast<WebCore::ScrollbarOverlayStyle>(value)) {
    case WebCore::ScrollbarOverlayStyle::Default:
    case WebCore::ScrollbarOverlayStyle::Dark:
    case WebCore::ScrollbarOverlayStyle::Light:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::ErrorFilter>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::ErrorFilter>(value)) {
    case WebCore::WebGPU::ErrorFilter::OutOfMemory:
    case WebCore::WebGPU::ErrorFilter::Validation:
    case WebCore::WebGPU::ErrorFilter::Internal:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::IndexFormat>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::IndexFormat>(value)) {
    case WebCore::WebGPU::IndexFormat::Uint16:
    case WebCore::WebGPU::IndexFormat::Uint32:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebCore::WebGPU::MapMode>(OptionSet<WebCore::WebGPU::MapMode> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebCore::WebGPU::MapMode::Read)
        | static_cast<uint8_t>(WebCore::WebGPU::MapMode::Write)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidEnum<WebCore::WebGPU::MapMode>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::MapMode>(value)) {
    case WebCore::WebGPU::MapMode::Read:
    case WebCore::WebGPU::MapMode::Write:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::BlendFactor>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::BlendFactor>(value)) {
    case WebCore::WebGPU::BlendFactor::Zero:
    case WebCore::WebGPU::BlendFactor::One:
    case WebCore::WebGPU::BlendFactor::Src:
    case WebCore::WebGPU::BlendFactor::OneMinusSrc:
    case WebCore::WebGPU::BlendFactor::SrcAlpha:
    case WebCore::WebGPU::BlendFactor::OneMinusSrcAlpha:
    case WebCore::WebGPU::BlendFactor::Dst:
    case WebCore::WebGPU::BlendFactor::OneMinusDst:
    case WebCore::WebGPU::BlendFactor::DstAlpha:
    case WebCore::WebGPU::BlendFactor::OneMinusDstAlpha:
    case WebCore::WebGPU::BlendFactor::SrcAlphaSaturated:
    case WebCore::WebGPU::BlendFactor::Constant:
    case WebCore::WebGPU::BlendFactor::OneMinusConstant:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::TextureSampleType>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::TextureSampleType>(value)) {
    case WebCore::WebGPU::TextureSampleType::Float:
    case WebCore::WebGPU::TextureSampleType::UnfilterableFloat:
    case WebCore::WebGPU::TextureSampleType::Depth:
    case WebCore::WebGPU::TextureSampleType::Sint:
    case WebCore::WebGPU::TextureSampleType::Uint:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::BlendOperation>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::BlendOperation>(value)) {
    case WebCore::WebGPU::BlendOperation::Add:
    case WebCore::WebGPU::BlendOperation::Subtract:
    case WebCore::WebGPU::BlendOperation::ReverseSubtract:
    case WebCore::WebGPU::BlendOperation::Min:
    case WebCore::WebGPU::BlendOperation::Max:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::CanvasToneMappingMode>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::CanvasToneMappingMode>(value)) {
    case WebCore::WebGPU::CanvasToneMappingMode::Standard:
    case WebCore::WebGPU::CanvasToneMappingMode::Extended:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::CanvasAlphaMode>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::CanvasAlphaMode>(value)) {
    case WebCore::WebGPU::CanvasAlphaMode::Opaque:
    case WebCore::WebGPU::CanvasAlphaMode::Premultiplied:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::QueryType>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::QueryType>(value)) {
    case WebCore::WebGPU::QueryType::Occlusion:
    case WebCore::WebGPU::QueryType::Timestamp:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::CompareFunction>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::CompareFunction>(value)) {
    case WebCore::WebGPU::CompareFunction::Never:
    case WebCore::WebGPU::CompareFunction::Less:
    case WebCore::WebGPU::CompareFunction::Equal:
    case WebCore::WebGPU::CompareFunction::LessEqual:
    case WebCore::WebGPU::CompareFunction::Greater:
    case WebCore::WebGPU::CompareFunction::NotEqual:
    case WebCore::WebGPU::CompareFunction::GreaterEqual:
    case WebCore::WebGPU::CompareFunction::Always:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::FilterMode>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::FilterMode>(value)) {
    case WebCore::WebGPU::FilterMode::Nearest:
    case WebCore::WebGPU::FilterMode::Linear:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::MipmapFilterMode>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::MipmapFilterMode>(value)) {
    case WebCore::WebGPU::MipmapFilterMode::Nearest:
    case WebCore::WebGPU::MipmapFilterMode::Linear:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::TextureDimension>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::TextureDimension>(value)) {
    case WebCore::WebGPU::TextureDimension::_1d:
    case WebCore::WebGPU::TextureDimension::_2d:
    case WebCore::WebGPU::TextureDimension::_3d:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::VertexFormat>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::VertexFormat>(value)) {
    case WebCore::WebGPU::VertexFormat::Uint8x2:
    case WebCore::WebGPU::VertexFormat::Uint8x4:
    case WebCore::WebGPU::VertexFormat::Sint8x2:
    case WebCore::WebGPU::VertexFormat::Sint8x4:
    case WebCore::WebGPU::VertexFormat::Unorm8x2:
    case WebCore::WebGPU::VertexFormat::Unorm8x4:
    case WebCore::WebGPU::VertexFormat::Snorm8x2:
    case WebCore::WebGPU::VertexFormat::Snorm8x4:
    case WebCore::WebGPU::VertexFormat::Uint16x2:
    case WebCore::WebGPU::VertexFormat::Uint16x4:
    case WebCore::WebGPU::VertexFormat::Sint16x2:
    case WebCore::WebGPU::VertexFormat::Sint16x4:
    case WebCore::WebGPU::VertexFormat::Unorm16x2:
    case WebCore::WebGPU::VertexFormat::Unorm16x4:
    case WebCore::WebGPU::VertexFormat::Snorm16x2:
    case WebCore::WebGPU::VertexFormat::Snorm16x4:
    case WebCore::WebGPU::VertexFormat::Float16x2:
    case WebCore::WebGPU::VertexFormat::Float16x4:
    case WebCore::WebGPU::VertexFormat::Float32:
    case WebCore::WebGPU::VertexFormat::Float32x2:
    case WebCore::WebGPU::VertexFormat::Float32x3:
    case WebCore::WebGPU::VertexFormat::Float32x4:
    case WebCore::WebGPU::VertexFormat::Uint32:
    case WebCore::WebGPU::VertexFormat::Uint32x2:
    case WebCore::WebGPU::VertexFormat::Uint32x3:
    case WebCore::WebGPU::VertexFormat::Uint32x4:
    case WebCore::WebGPU::VertexFormat::Sint32:
    case WebCore::WebGPU::VertexFormat::Sint32x2:
    case WebCore::WebGPU::VertexFormat::Sint32x3:
    case WebCore::WebGPU::VertexFormat::Sint32x4:
    case WebCore::WebGPU::VertexFormat::Unorm10_10_10_2:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::ShaderStage>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::ShaderStage>(value)) {
    case WebCore::WebGPU::ShaderStage::Vertex:
    case WebCore::WebGPU::ShaderStage::Fragment:
    case WebCore::WebGPU::ShaderStage::Compute:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebCore::WebGPU::ShaderStage>(OptionSet<WebCore::WebGPU::ShaderStage> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebCore::WebGPU::ShaderStage::Vertex)
        | static_cast<uint8_t>(WebCore::WebGPU::ShaderStage::Fragment)
        | static_cast<uint8_t>(WebCore::WebGPU::ShaderStage::Compute)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

template<> bool isValidEnum<WebCore::WebGPU::CompilationMessageType>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::CompilationMessageType>(value)) {
    case WebCore::WebGPU::CompilationMessageType::Error:
    case WebCore::WebGPU::CompilationMessageType::Warning:
    case WebCore::WebGPU::CompilationMessageType::Info:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::StencilOperation>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::StencilOperation>(value)) {
    case WebCore::WebGPU::StencilOperation::Keep:
    case WebCore::WebGPU::StencilOperation::Zero:
    case WebCore::WebGPU::StencilOperation::Replace:
    case WebCore::WebGPU::StencilOperation::Invert:
    case WebCore::WebGPU::StencilOperation::IncrementClamp:
    case WebCore::WebGPU::StencilOperation::DecrementClamp:
    case WebCore::WebGPU::StencilOperation::IncrementWrap:
    case WebCore::WebGPU::StencilOperation::DecrementWrap:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::DeviceLostReason>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::DeviceLostReason>(value)) {
    case WebCore::WebGPU::DeviceLostReason::Destroyed:
    case WebCore::WebGPU::DeviceLostReason::Unknown:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::AddressMode>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::AddressMode>(value)) {
    case WebCore::WebGPU::AddressMode::ClampToEdge:
    case WebCore::WebGPU::AddressMode::Repeat:
    case WebCore::WebGPU::AddressMode::MirrorRepeat:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::BufferBindingType>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::BufferBindingType>(value)) {
    case WebCore::WebGPU::BufferBindingType::Uniform:
    case WebCore::WebGPU::BufferBindingType::Storage:
    case WebCore::WebGPU::BufferBindingType::ReadOnlyStorage:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::StorageTextureAccess>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::StorageTextureAccess>(value)) {
    case WebCore::WebGPU::StorageTextureAccess::WriteOnly:
    case WebCore::WebGPU::StorageTextureAccess::ReadOnly:
    case WebCore::WebGPU::StorageTextureAccess::ReadWrite:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::FrontFace>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::FrontFace>(value)) {
    case WebCore::WebGPU::FrontFace::CCW:
    case WebCore::WebGPU::FrontFace::CW:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::StoreOp>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::StoreOp>(value)) {
    case WebCore::WebGPU::StoreOp::Store:
    case WebCore::WebGPU::StoreOp::Discard:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::LoadOp>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::LoadOp>(value)) {
    case WebCore::WebGPU::LoadOp::Load:
    case WebCore::WebGPU::LoadOp::Clear:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::ColorWrite>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::ColorWrite>(value)) {
    case WebCore::WebGPU::ColorWrite::Red:
    case WebCore::WebGPU::ColorWrite::Green:
    case WebCore::WebGPU::ColorWrite::Blue:
    case WebCore::WebGPU::ColorWrite::Alpha:
    case WebCore::WebGPU::ColorWrite::All:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::SamplerBindingType>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::SamplerBindingType>(value)) {
    case WebCore::WebGPU::SamplerBindingType::Filtering:
    case WebCore::WebGPU::SamplerBindingType::NonFiltering:
    case WebCore::WebGPU::SamplerBindingType::Comparison:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::PrimitiveTopology>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::PrimitiveTopology>(value)) {
    case WebCore::WebGPU::PrimitiveTopology::PointList:
    case WebCore::WebGPU::PrimitiveTopology::LineList:
    case WebCore::WebGPU::PrimitiveTopology::LineStrip:
    case WebCore::WebGPU::PrimitiveTopology::TriangleList:
    case WebCore::WebGPU::PrimitiveTopology::TriangleStrip:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::CullMode>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::CullMode>(value)) {
    case WebCore::WebGPU::CullMode::None:
    case WebCore::WebGPU::CullMode::Front:
    case WebCore::WebGPU::CullMode::Back:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::TextureViewDimension>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::TextureViewDimension>(value)) {
    case WebCore::WebGPU::TextureViewDimension::_1d:
    case WebCore::WebGPU::TextureViewDimension::_2d:
    case WebCore::WebGPU::TextureViewDimension::_2dArray:
    case WebCore::WebGPU::TextureViewDimension::Cube:
    case WebCore::WebGPU::TextureViewDimension::CubeArray:
    case WebCore::WebGPU::TextureViewDimension::_3d:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::VertexStepMode>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::VertexStepMode>(value)) {
    case WebCore::WebGPU::VertexStepMode::Vertex:
    case WebCore::WebGPU::VertexStepMode::Instance:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::XREye>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::XREye>(value)) {
    case WebCore::WebGPU::XREye::None:
    case WebCore::WebGPU::XREye::Left:
    case WebCore::WebGPU::XREye::Right:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::BufferUsage>(uint16_t value)
{
    switch (static_cast<WebCore::WebGPU::BufferUsage>(value)) {
    case WebCore::WebGPU::BufferUsage::MapRead:
    case WebCore::WebGPU::BufferUsage::MapWrite:
    case WebCore::WebGPU::BufferUsage::CopySource:
    case WebCore::WebGPU::BufferUsage::CopyDestination:
    case WebCore::WebGPU::BufferUsage::Index:
    case WebCore::WebGPU::BufferUsage::Vertex:
    case WebCore::WebGPU::BufferUsage::Uniform:
    case WebCore::WebGPU::BufferUsage::Storage:
    case WebCore::WebGPU::BufferUsage::Indirect:
    case WebCore::WebGPU::BufferUsage::QueryResolve:
        return true;
    default:
        return false;
    }
}

template<> bool isValidEnum<WebCore::WebGPU::TextureUsage>(uint8_t value)
{
    switch (static_cast<WebCore::WebGPU::TextureUsage>(value)) {
    case WebCore::WebGPU::TextureUsage::CopySource:
    case WebCore::WebGPU::TextureUsage::CopyDestination:
    case WebCore::WebGPU::TextureUsage::TextureBinding:
    case WebCore::WebGPU::TextureUsage::StorageBinding:
    case WebCore::WebGPU::TextureUsage::RenderAttachment:
        return true;
    default:
        return false;
    }
}

template<> bool isValidOptionSet<WebCore::WebGPU::TextureUsage>(OptionSet<WebCore::WebGPU::TextureUsage> value)
{
    constexpr uint8_t allValidBitsValue = 0
        | static_cast<uint8_t>(WebCore::WebGPU::TextureUsage::CopySource)
        | static_cast<uint8_t>(WebCore::WebGPU::TextureUsage::CopyDestination)
        | static_cast<uint8_t>(WebCore::WebGPU::TextureUsage::TextureBinding)
        | static_cast<uint8_t>(WebCore::WebGPU::TextureUsage::StorageBinding)
        | static_cast<uint8_t>(WebCore::WebGPU::TextureUsage::RenderAttachment)
        | 0;
    return (value.toRaw() | allValidBitsValue) == allValidBitsValue;
}

} // namespace WTF

IGNORE_WARNINGS_END
