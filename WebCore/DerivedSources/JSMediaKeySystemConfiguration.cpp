/*
    This file is part of the WebKit open source project.
    This file has been generated by generate-bindings.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.
*/

#include "config.h"

#if ENABLE(ENCRYPTED_MEDIA)

#include "JSMediaKeySystemConfiguration.h"

#include "JSDOMConvertEnumeration.h"
#include "JSDOMConvertOptional.h"
#include "JSDOMConvertSequences.h"
#include "JSDOMConvertStrings.h"
#include "JSDOMGlobalObject.h"
#include "JSMediaKeySessionType.h"
#include "JSMediaKeySystemMediaCapability.h"
#include "JSMediaKeysRequirement.h"
#include <JavaScriptCore/JSArray.h>
#include <JavaScriptCore/JSCInlines.h>
#include <JavaScriptCore/ObjectConstructor.h>



namespace WebCore {
using namespace JSC;

#if ENABLE(ENCRYPTED_MEDIA)

template<> ConversionResult<IDLDictionary<MediaKeySystemConfiguration>> convertDictionary<MediaKeySystemConfiguration>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    bool isNullOrUndefined = value.isUndefinedOrNull();
    auto* object = isNullOrUndefined ? nullptr : value.getObject();
    if (!isNullOrUndefined && !object) [[unlikely]] {
        throwTypeError(&lexicalGlobalObject, throwScope);
        return ConversionResultException { };
    }
    MediaKeySystemConfiguration result;
    JSValue audioCapabilitiesValue;
    if (isNullOrUndefined)
        audioCapabilitiesValue = jsUndefined();
    else {
        audioCapabilitiesValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "audioCapabilities"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto audioCapabilitiesConversionResult = convertOptionalWithDefault<IDLSequence<IDLDictionary<MediaKeySystemMediaCapability>>>(lexicalGlobalObject, audioCapabilitiesValue, [&]() -> ConversionResult<IDLSequence<IDLDictionary<MediaKeySystemMediaCapability>>> { return Converter<IDLSequence<IDLDictionary<MediaKeySystemMediaCapability>>>::ReturnType { }; });
    if (audioCapabilitiesConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.audioCapabilities = audioCapabilitiesConversionResult.releaseReturnValue();
    JSValue distinctiveIdentifierValue;
    if (isNullOrUndefined)
        distinctiveIdentifierValue = jsUndefined();
    else {
        distinctiveIdentifierValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "distinctiveIdentifier"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto distinctiveIdentifierConversionResult = convertOptionalWithDefault<IDLEnumeration<MediaKeysRequirement>>(lexicalGlobalObject, distinctiveIdentifierValue, [&]() -> ConversionResult<IDLEnumeration<MediaKeysRequirement>> { return Converter<IDLEnumeration<MediaKeysRequirement>>::ReturnType { MediaKeysRequirement::Optional }; });
    if (distinctiveIdentifierConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.distinctiveIdentifier = distinctiveIdentifierConversionResult.releaseReturnValue();
    JSValue initDataTypesValue;
    if (isNullOrUndefined)
        initDataTypesValue = jsUndefined();
    else {
        initDataTypesValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "initDataTypes"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto initDataTypesConversionResult = convertOptionalWithDefault<IDLSequence<IDLAtomStringAdaptor<IDLDOMString>>>(lexicalGlobalObject, initDataTypesValue, [&]() -> ConversionResult<IDLSequence<IDLAtomStringAdaptor<IDLDOMString>>> { return Converter<IDLSequence<IDLAtomStringAdaptor<IDLDOMString>>>::ReturnType { }; });
    if (initDataTypesConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.initDataTypes = initDataTypesConversionResult.releaseReturnValue();
    JSValue labelValue;
    if (isNullOrUndefined)
        labelValue = jsUndefined();
    else {
        labelValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "label"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto labelConversionResult = convertOptionalWithDefault<IDLDOMString>(lexicalGlobalObject, labelValue, [&]() -> ConversionResult<IDLDOMString> { return Converter<IDLDOMString>::ReturnType { emptyString() }; });
    if (labelConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.label = labelConversionResult.releaseReturnValue();
    JSValue persistentStateValue;
    if (isNullOrUndefined)
        persistentStateValue = jsUndefined();
    else {
        persistentStateValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "persistentState"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto persistentStateConversionResult = convertOptionalWithDefault<IDLEnumeration<MediaKeysRequirement>>(lexicalGlobalObject, persistentStateValue, [&]() -> ConversionResult<IDLEnumeration<MediaKeysRequirement>> { return Converter<IDLEnumeration<MediaKeysRequirement>>::ReturnType { MediaKeysRequirement::Optional }; });
    if (persistentStateConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.persistentState = persistentStateConversionResult.releaseReturnValue();
    JSValue sessionTypesValue;
    if (isNullOrUndefined)
        sessionTypesValue = jsUndefined();
    else {
        sessionTypesValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "sessionTypes"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!sessionTypesValue.isUndefined()) {
        auto sessionTypesConversionResult = convert<IDLSequence<IDLEnumeration<MediaKeySessionType>>>(lexicalGlobalObject, sessionTypesValue);
        if (sessionTypesConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.sessionTypes = sessionTypesConversionResult.releaseReturnValue();
    }
    JSValue videoCapabilitiesValue;
    if (isNullOrUndefined)
        videoCapabilitiesValue = jsUndefined();
    else {
        videoCapabilitiesValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "videoCapabilities"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto videoCapabilitiesConversionResult = convertOptionalWithDefault<IDLSequence<IDLDictionary<MediaKeySystemMediaCapability>>>(lexicalGlobalObject, videoCapabilitiesValue, [&]() -> ConversionResult<IDLSequence<IDLDictionary<MediaKeySystemMediaCapability>>> { return Converter<IDLSequence<IDLDictionary<MediaKeySystemMediaCapability>>>::ReturnType { }; });
    if (videoCapabilitiesConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.videoCapabilities = videoCapabilitiesConversionResult.releaseReturnValue();
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const MediaKeySystemConfiguration& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    auto audioCapabilitiesValue = toJS<IDLSequence<IDLDictionary<MediaKeySystemMediaCapability>>>(lexicalGlobalObject, globalObject, throwScope, dictionary.audioCapabilities);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "audioCapabilities"_s), audioCapabilitiesValue);
    auto distinctiveIdentifierValue = toJS<IDLEnumeration<MediaKeysRequirement>>(lexicalGlobalObject, throwScope, dictionary.distinctiveIdentifier);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "distinctiveIdentifier"_s), distinctiveIdentifierValue);
    auto initDataTypesValue = toJS<IDLSequence<IDLAtomStringAdaptor<IDLDOMString>>>(lexicalGlobalObject, globalObject, throwScope, dictionary.initDataTypes);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "initDataTypes"_s), initDataTypesValue);
    auto labelValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.label);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "label"_s), labelValue);
    auto persistentStateValue = toJS<IDLEnumeration<MediaKeysRequirement>>(lexicalGlobalObject, throwScope, dictionary.persistentState);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "persistentState"_s), persistentStateValue);
    if (!IDLSequence<IDLEnumeration<MediaKeySessionType>>::isNullValue(dictionary.sessionTypes)) {
        auto sessionTypesValue = toJS<IDLSequence<IDLEnumeration<MediaKeySessionType>>>(lexicalGlobalObject, globalObject, throwScope, IDLSequence<IDLEnumeration<MediaKeySessionType>>::extractValueFromNullable(dictionary.sessionTypes));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "sessionTypes"_s), sessionTypesValue);
    }
    auto videoCapabilitiesValue = toJS<IDLSequence<IDLDictionary<MediaKeySystemMediaCapability>>>(lexicalGlobalObject, globalObject, throwScope, dictionary.videoCapabilities);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "videoCapabilities"_s), videoCapabilitiesValue);
    return result;
}

#endif

} // namespace WebCore


#endif // ENABLE(ENCRYPTED_MEDIA)
