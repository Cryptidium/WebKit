/*
    This file is part of the WebKit open source project.
    This file has been generated by generate-bindings.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.
*/

#include "config.h"

#if ENABLE(WEB_AUTHN)

#include "JSMockWebAuthenticationConfiguration.h"

#include "JSDOMConvertBoolean.h"
#include "JSDOMConvertNumbers.h"
#include "JSDOMConvertOptional.h"
#include "JSDOMConvertSequences.h"
#include "JSDOMConvertStrings.h"
#include <JavaScriptCore/JSArray.h>
#include <JavaScriptCore/JSCInlines.h>
#include <JavaScriptCore/JSString.h>
#include <wtf/NeverDestroyed.h>
#include <wtf/SortedArrayMap.h>



namespace WebCore {
using namespace JSC;

#if ENABLE(WEB_AUTHN)

template<> ConversionResult<IDLDictionary<MockWebAuthenticationConfiguration>> convertDictionary<MockWebAuthenticationConfiguration>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    bool isNullOrUndefined = value.isUndefinedOrNull();
    auto* object = isNullOrUndefined ? nullptr : value.getObject();
    if (!isNullOrUndefined && !object) [[unlikely]] {
        throwTypeError(&lexicalGlobalObject, throwScope);
        return ConversionResultException { };
    }
    MockWebAuthenticationConfiguration result;
    JSValue ccidValue;
    if (isNullOrUndefined)
        ccidValue = jsUndefined();
    else {
        ccidValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "ccid"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!ccidValue.isUndefined()) {
        auto ccidConversionResult = convert<IDLDictionary<MockWebAuthenticationConfiguration::CcidConfiguration>>(lexicalGlobalObject, ccidValue);
        if (ccidConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.ccid = ccidConversionResult.releaseReturnValue();
    }
    JSValue hidValue;
    if (isNullOrUndefined)
        hidValue = jsUndefined();
    else {
        hidValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "hid"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!hidValue.isUndefined()) {
        auto hidConversionResult = convert<IDLDictionary<MockWebAuthenticationConfiguration::HidConfiguration>>(lexicalGlobalObject, hidValue);
        if (hidConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.hid = hidConversionResult.releaseReturnValue();
    }
    JSValue localValue;
    if (isNullOrUndefined)
        localValue = jsUndefined();
    else {
        localValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "local"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!localValue.isUndefined()) {
        auto localConversionResult = convert<IDLDictionary<MockWebAuthenticationConfiguration::LocalConfiguration>>(lexicalGlobalObject, localValue);
        if (localConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.local = localConversionResult.releaseReturnValue();
    }
    JSValue nfcValue;
    if (isNullOrUndefined)
        nfcValue = jsUndefined();
    else {
        nfcValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "nfc"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!nfcValue.isUndefined()) {
        auto nfcConversionResult = convert<IDLDictionary<MockWebAuthenticationConfiguration::NfcConfiguration>>(lexicalGlobalObject, nfcValue);
        if (nfcConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.nfc = nfcConversionResult.releaseReturnValue();
    }
    JSValue silentFailureValue;
    if (isNullOrUndefined)
        silentFailureValue = jsUndefined();
    else {
        silentFailureValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "silentFailure"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto silentFailureConversionResult = convertOptionalWithDefault<IDLBoolean>(lexicalGlobalObject, silentFailureValue, [&]() -> ConversionResult<IDLBoolean> { return Converter<IDLBoolean>::ReturnType { false }; });
    if (silentFailureConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.silentFailure = silentFailureConversionResult.releaseReturnValue();
    return result;
}

#endif

#if ENABLE(WEB_AUTHN)

String convertEnumerationToString(MockWebAuthenticationConfiguration::HidStage enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 2> values {
        MAKE_STATIC_STRING_IMPL("info"),
        MAKE_STATIC_STRING_IMPL("request"),
    };
    static_assert(static_cast<size_t>(MockWebAuthenticationConfiguration::HidStage::Info) == 0, "MockWebAuthenticationConfiguration::HidStage::Info is not 0 as expected");
    static_assert(static_cast<size_t>(MockWebAuthenticationConfiguration::HidStage::Request) == 1, "MockWebAuthenticationConfiguration::HidStage::Request is not 1 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, MockWebAuthenticationConfiguration::HidStage enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<MockWebAuthenticationConfiguration::HidStage> parseEnumerationFromString<MockWebAuthenticationConfiguration::HidStage>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, MockWebAuthenticationConfiguration::HidStage>, 2> mappings {
        std::pair<ComparableASCIILiteral, MockWebAuthenticationConfiguration::HidStage> { "info"_s, MockWebAuthenticationConfiguration::HidStage::Info },
        std::pair<ComparableASCIILiteral, MockWebAuthenticationConfiguration::HidStage> { "request"_s, MockWebAuthenticationConfiguration::HidStage::Request },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<MockWebAuthenticationConfiguration::HidStage> parseEnumeration<MockWebAuthenticationConfiguration::HidStage>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<MockWebAuthenticationConfiguration::HidStage>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<MockWebAuthenticationConfiguration::HidStage>()
{
    return "\"info\", \"request\""_s;
}

#endif

#if ENABLE(WEB_AUTHN)

String convertEnumerationToString(MockWebAuthenticationConfiguration::HidSubStage enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 2> values {
        MAKE_STATIC_STRING_IMPL("init"),
        MAKE_STATIC_STRING_IMPL("msg"),
    };
    static_assert(static_cast<size_t>(MockWebAuthenticationConfiguration::HidSubStage::Init) == 0, "MockWebAuthenticationConfiguration::HidSubStage::Init is not 0 as expected");
    static_assert(static_cast<size_t>(MockWebAuthenticationConfiguration::HidSubStage::Msg) == 1, "MockWebAuthenticationConfiguration::HidSubStage::Msg is not 1 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, MockWebAuthenticationConfiguration::HidSubStage enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<MockWebAuthenticationConfiguration::HidSubStage> parseEnumerationFromString<MockWebAuthenticationConfiguration::HidSubStage>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, MockWebAuthenticationConfiguration::HidSubStage>, 2> mappings {
        std::pair<ComparableASCIILiteral, MockWebAuthenticationConfiguration::HidSubStage> { "init"_s, MockWebAuthenticationConfiguration::HidSubStage::Init },
        std::pair<ComparableASCIILiteral, MockWebAuthenticationConfiguration::HidSubStage> { "msg"_s, MockWebAuthenticationConfiguration::HidSubStage::Msg },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<MockWebAuthenticationConfiguration::HidSubStage> parseEnumeration<MockWebAuthenticationConfiguration::HidSubStage>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<MockWebAuthenticationConfiguration::HidSubStage>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<MockWebAuthenticationConfiguration::HidSubStage>()
{
    return "\"init\", \"msg\""_s;
}

#endif

#if ENABLE(WEB_AUTHN)

String convertEnumerationToString(MockWebAuthenticationConfiguration::HidError enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 7> values {
        MAKE_STATIC_STRING_IMPL("success"),
        MAKE_STATIC_STRING_IMPL("data-not-sent"),
        MAKE_STATIC_STRING_IMPL("empty-report"),
        MAKE_STATIC_STRING_IMPL("wrong-channel-id"),
        MAKE_STATIC_STRING_IMPL("malicious-payload"),
        MAKE_STATIC_STRING_IMPL("unsupported-options"),
        MAKE_STATIC_STRING_IMPL("wrong-nonce"),
    };
    static_assert(static_cast<size_t>(MockWebAuthenticationConfiguration::HidError::Success) == 0, "MockWebAuthenticationConfiguration::HidError::Success is not 0 as expected");
    static_assert(static_cast<size_t>(MockWebAuthenticationConfiguration::HidError::DataNotSent) == 1, "MockWebAuthenticationConfiguration::HidError::DataNotSent is not 1 as expected");
    static_assert(static_cast<size_t>(MockWebAuthenticationConfiguration::HidError::EmptyReport) == 2, "MockWebAuthenticationConfiguration::HidError::EmptyReport is not 2 as expected");
    static_assert(static_cast<size_t>(MockWebAuthenticationConfiguration::HidError::WrongChannelId) == 3, "MockWebAuthenticationConfiguration::HidError::WrongChannelId is not 3 as expected");
    static_assert(static_cast<size_t>(MockWebAuthenticationConfiguration::HidError::MaliciousPayload) == 4, "MockWebAuthenticationConfiguration::HidError::MaliciousPayload is not 4 as expected");
    static_assert(static_cast<size_t>(MockWebAuthenticationConfiguration::HidError::UnsupportedOptions) == 5, "MockWebAuthenticationConfiguration::HidError::UnsupportedOptions is not 5 as expected");
    static_assert(static_cast<size_t>(MockWebAuthenticationConfiguration::HidError::WrongNonce) == 6, "MockWebAuthenticationConfiguration::HidError::WrongNonce is not 6 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, MockWebAuthenticationConfiguration::HidError enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<MockWebAuthenticationConfiguration::HidError> parseEnumerationFromString<MockWebAuthenticationConfiguration::HidError>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, MockWebAuthenticationConfiguration::HidError>, 7> mappings {
        std::pair<ComparableASCIILiteral, MockWebAuthenticationConfiguration::HidError> { "data-not-sent"_s, MockWebAuthenticationConfiguration::HidError::DataNotSent },
        std::pair<ComparableASCIILiteral, MockWebAuthenticationConfiguration::HidError> { "empty-report"_s, MockWebAuthenticationConfiguration::HidError::EmptyReport },
        std::pair<ComparableASCIILiteral, MockWebAuthenticationConfiguration::HidError> { "malicious-payload"_s, MockWebAuthenticationConfiguration::HidError::MaliciousPayload },
        std::pair<ComparableASCIILiteral, MockWebAuthenticationConfiguration::HidError> { "success"_s, MockWebAuthenticationConfiguration::HidError::Success },
        std::pair<ComparableASCIILiteral, MockWebAuthenticationConfiguration::HidError> { "unsupported-options"_s, MockWebAuthenticationConfiguration::HidError::UnsupportedOptions },
        std::pair<ComparableASCIILiteral, MockWebAuthenticationConfiguration::HidError> { "wrong-channel-id"_s, MockWebAuthenticationConfiguration::HidError::WrongChannelId },
        std::pair<ComparableASCIILiteral, MockWebAuthenticationConfiguration::HidError> { "wrong-nonce"_s, MockWebAuthenticationConfiguration::HidError::WrongNonce },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<MockWebAuthenticationConfiguration::HidError> parseEnumeration<MockWebAuthenticationConfiguration::HidError>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<MockWebAuthenticationConfiguration::HidError>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<MockWebAuthenticationConfiguration::HidError>()
{
    return "\"success\", \"data-not-sent\", \"empty-report\", \"wrong-channel-id\", \"malicious-payload\", \"unsupported-options\", \"wrong-nonce\""_s;
}

#endif

#if ENABLE(WEB_AUTHN)

String convertEnumerationToString(MockWebAuthenticationConfiguration::NfcError enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 5> values {
        MAKE_STATIC_STRING_IMPL("success"),
        MAKE_STATIC_STRING_IMPL("no-tags"),
        MAKE_STATIC_STRING_IMPL("wrong-tag-type"),
        MAKE_STATIC_STRING_IMPL("no-connections"),
        MAKE_STATIC_STRING_IMPL("malicious-payload"),
    };
    static_assert(static_cast<size_t>(MockWebAuthenticationConfiguration::NfcError::Success) == 0, "MockWebAuthenticationConfiguration::NfcError::Success is not 0 as expected");
    static_assert(static_cast<size_t>(MockWebAuthenticationConfiguration::NfcError::NoTags) == 1, "MockWebAuthenticationConfiguration::NfcError::NoTags is not 1 as expected");
    static_assert(static_cast<size_t>(MockWebAuthenticationConfiguration::NfcError::WrongTagType) == 2, "MockWebAuthenticationConfiguration::NfcError::WrongTagType is not 2 as expected");
    static_assert(static_cast<size_t>(MockWebAuthenticationConfiguration::NfcError::NoConnections) == 3, "MockWebAuthenticationConfiguration::NfcError::NoConnections is not 3 as expected");
    static_assert(static_cast<size_t>(MockWebAuthenticationConfiguration::NfcError::MaliciousPayload) == 4, "MockWebAuthenticationConfiguration::NfcError::MaliciousPayload is not 4 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, MockWebAuthenticationConfiguration::NfcError enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<MockWebAuthenticationConfiguration::NfcError> parseEnumerationFromString<MockWebAuthenticationConfiguration::NfcError>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, MockWebAuthenticationConfiguration::NfcError>, 5> mappings {
        std::pair<ComparableASCIILiteral, MockWebAuthenticationConfiguration::NfcError> { "malicious-payload"_s, MockWebAuthenticationConfiguration::NfcError::MaliciousPayload },
        std::pair<ComparableASCIILiteral, MockWebAuthenticationConfiguration::NfcError> { "no-connections"_s, MockWebAuthenticationConfiguration::NfcError::NoConnections },
        std::pair<ComparableASCIILiteral, MockWebAuthenticationConfiguration::NfcError> { "no-tags"_s, MockWebAuthenticationConfiguration::NfcError::NoTags },
        std::pair<ComparableASCIILiteral, MockWebAuthenticationConfiguration::NfcError> { "success"_s, MockWebAuthenticationConfiguration::NfcError::Success },
        std::pair<ComparableASCIILiteral, MockWebAuthenticationConfiguration::NfcError> { "wrong-tag-type"_s, MockWebAuthenticationConfiguration::NfcError::WrongTagType },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<MockWebAuthenticationConfiguration::NfcError> parseEnumeration<MockWebAuthenticationConfiguration::NfcError>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<MockWebAuthenticationConfiguration::NfcError>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<MockWebAuthenticationConfiguration::NfcError>()
{
    return "\"success\", \"no-tags\", \"wrong-tag-type\", \"no-connections\", \"malicious-payload\""_s;
}

#endif

#if ENABLE(WEB_AUTHN)

String convertEnumerationToString(MockWebAuthenticationConfiguration::UserVerification enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 4> values {
        MAKE_STATIC_STRING_IMPL("no"),
        MAKE_STATIC_STRING_IMPL("yes"),
        MAKE_STATIC_STRING_IMPL("cancel"),
        MAKE_STATIC_STRING_IMPL("presence"),
    };
    static_assert(static_cast<size_t>(MockWebAuthenticationConfiguration::UserVerification::No) == 0, "MockWebAuthenticationConfiguration::UserVerification::No is not 0 as expected");
    static_assert(static_cast<size_t>(MockWebAuthenticationConfiguration::UserVerification::Yes) == 1, "MockWebAuthenticationConfiguration::UserVerification::Yes is not 1 as expected");
    static_assert(static_cast<size_t>(MockWebAuthenticationConfiguration::UserVerification::Cancel) == 2, "MockWebAuthenticationConfiguration::UserVerification::Cancel is not 2 as expected");
    static_assert(static_cast<size_t>(MockWebAuthenticationConfiguration::UserVerification::Presence) == 3, "MockWebAuthenticationConfiguration::UserVerification::Presence is not 3 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, MockWebAuthenticationConfiguration::UserVerification enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<MockWebAuthenticationConfiguration::UserVerification> parseEnumerationFromString<MockWebAuthenticationConfiguration::UserVerification>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, MockWebAuthenticationConfiguration::UserVerification>, 4> mappings {
        std::pair<ComparableASCIILiteral, MockWebAuthenticationConfiguration::UserVerification> { "cancel"_s, MockWebAuthenticationConfiguration::UserVerification::Cancel },
        std::pair<ComparableASCIILiteral, MockWebAuthenticationConfiguration::UserVerification> { "no"_s, MockWebAuthenticationConfiguration::UserVerification::No },
        std::pair<ComparableASCIILiteral, MockWebAuthenticationConfiguration::UserVerification> { "presence"_s, MockWebAuthenticationConfiguration::UserVerification::Presence },
        std::pair<ComparableASCIILiteral, MockWebAuthenticationConfiguration::UserVerification> { "yes"_s, MockWebAuthenticationConfiguration::UserVerification::Yes },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<MockWebAuthenticationConfiguration::UserVerification> parseEnumeration<MockWebAuthenticationConfiguration::UserVerification>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<MockWebAuthenticationConfiguration::UserVerification>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<MockWebAuthenticationConfiguration::UserVerification>()
{
    return "\"no\", \"yes\", \"cancel\", \"presence\""_s;
}

#endif

#if ENABLE(WEB_AUTHN)

template<> ConversionResult<IDLDictionary<MockWebAuthenticationConfiguration::LocalConfiguration>> convertDictionary<MockWebAuthenticationConfiguration::LocalConfiguration>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    bool isNullOrUndefined = value.isUndefinedOrNull();
    auto* object = isNullOrUndefined ? nullptr : value.getObject();
    if (!isNullOrUndefined && !object) [[unlikely]] {
        throwTypeError(&lexicalGlobalObject, throwScope);
        return ConversionResultException { };
    }
    MockWebAuthenticationConfiguration::LocalConfiguration result;
    JSValue acceptAttestationValue;
    if (isNullOrUndefined)
        acceptAttestationValue = jsUndefined();
    else {
        acceptAttestationValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "acceptAttestation"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto acceptAttestationConversionResult = convertOptionalWithDefault<IDLBoolean>(lexicalGlobalObject, acceptAttestationValue, [&]() -> ConversionResult<IDLBoolean> { return Converter<IDLBoolean>::ReturnType { false }; });
    if (acceptAttestationConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.acceptAttestation = acceptAttestationConversionResult.releaseReturnValue();
    JSValue intermediateCACertificateBase64Value;
    if (isNullOrUndefined)
        intermediateCACertificateBase64Value = jsUndefined();
    else {
        intermediateCACertificateBase64Value = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "intermediateCACertificateBase64"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!intermediateCACertificateBase64Value.isUndefined()) {
        auto intermediateCACertificateBase64ConversionResult = convert<IDLDOMString>(lexicalGlobalObject, intermediateCACertificateBase64Value);
        if (intermediateCACertificateBase64ConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.intermediateCACertificateBase64 = intermediateCACertificateBase64ConversionResult.releaseReturnValue();
    }
    JSValue preferredCredentialIdBase64Value;
    if (isNullOrUndefined)
        preferredCredentialIdBase64Value = jsUndefined();
    else {
        preferredCredentialIdBase64Value = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "preferredCredentialIdBase64"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!preferredCredentialIdBase64Value.isUndefined()) {
        auto preferredCredentialIdBase64ConversionResult = convert<IDLDOMString>(lexicalGlobalObject, preferredCredentialIdBase64Value);
        if (preferredCredentialIdBase64ConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.preferredCredentialIdBase64 = preferredCredentialIdBase64ConversionResult.releaseReturnValue();
    }
    JSValue privateKeyBase64Value;
    if (isNullOrUndefined)
        privateKeyBase64Value = jsUndefined();
    else {
        privateKeyBase64Value = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "privateKeyBase64"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!privateKeyBase64Value.isUndefined()) {
        auto privateKeyBase64ConversionResult = convert<IDLDOMString>(lexicalGlobalObject, privateKeyBase64Value);
        if (privateKeyBase64ConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.privateKeyBase64 = privateKeyBase64ConversionResult.releaseReturnValue();
    }
    JSValue userCertificateBase64Value;
    if (isNullOrUndefined)
        userCertificateBase64Value = jsUndefined();
    else {
        userCertificateBase64Value = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "userCertificateBase64"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!userCertificateBase64Value.isUndefined()) {
        auto userCertificateBase64ConversionResult = convert<IDLDOMString>(lexicalGlobalObject, userCertificateBase64Value);
        if (userCertificateBase64ConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.userCertificateBase64 = userCertificateBase64ConversionResult.releaseReturnValue();
    }
    JSValue userVerificationValue;
    if (isNullOrUndefined)
        userVerificationValue = jsUndefined();
    else {
        userVerificationValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "userVerification"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto userVerificationConversionResult = convertOptionalWithDefault<IDLEnumeration<MockWebAuthenticationConfiguration::UserVerification>>(lexicalGlobalObject, userVerificationValue, [&]() -> ConversionResult<IDLEnumeration<MockWebAuthenticationConfiguration::UserVerification>> { return Converter<IDLEnumeration<MockWebAuthenticationConfiguration::UserVerification>>::ReturnType { MockWebAuthenticationConfiguration::UserVerification::No }; });
    if (userVerificationConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.userVerification = userVerificationConversionResult.releaseReturnValue();
    return result;
}

#endif

#if ENABLE(WEB_AUTHN)

template<> ConversionResult<IDLDictionary<MockWebAuthenticationConfiguration::HidConfiguration>> convertDictionary<MockWebAuthenticationConfiguration::HidConfiguration>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    bool isNullOrUndefined = value.isUndefinedOrNull();
    auto* object = isNullOrUndefined ? nullptr : value.getObject();
    if (!isNullOrUndefined && !object) [[unlikely]] {
        throwTypeError(&lexicalGlobalObject, throwScope);
        return ConversionResultException { };
    }
    MockWebAuthenticationConfiguration::HidConfiguration result;
    JSValue canDowngradeValue;
    if (isNullOrUndefined)
        canDowngradeValue = jsUndefined();
    else {
        canDowngradeValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "canDowngrade"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto canDowngradeConversionResult = convertOptionalWithDefault<IDLBoolean>(lexicalGlobalObject, canDowngradeValue, [&]() -> ConversionResult<IDLBoolean> { return Converter<IDLBoolean>::ReturnType { false }; });
    if (canDowngradeConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.canDowngrade = canDowngradeConversionResult.releaseReturnValue();
    JSValue continueAfterErrorDataValue;
    if (isNullOrUndefined)
        continueAfterErrorDataValue = jsUndefined();
    else {
        continueAfterErrorDataValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "continueAfterErrorData"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto continueAfterErrorDataConversionResult = convertOptionalWithDefault<IDLBoolean>(lexicalGlobalObject, continueAfterErrorDataValue, [&]() -> ConversionResult<IDLBoolean> { return Converter<IDLBoolean>::ReturnType { false }; });
    if (continueAfterErrorDataConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.continueAfterErrorData = continueAfterErrorDataConversionResult.releaseReturnValue();
    JSValue errorValue;
    if (isNullOrUndefined)
        errorValue = jsUndefined();
    else {
        errorValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "error"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto errorConversionResult = convertOptionalWithDefault<IDLEnumeration<MockWebAuthenticationConfiguration::HidError>>(lexicalGlobalObject, errorValue, [&]() -> ConversionResult<IDLEnumeration<MockWebAuthenticationConfiguration::HidError>> { return Converter<IDLEnumeration<MockWebAuthenticationConfiguration::HidError>>::ReturnType { MockWebAuthenticationConfiguration::HidError::Success }; });
    if (errorConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.error = errorConversionResult.releaseReturnValue();
    JSValue expectCancelValue;
    if (isNullOrUndefined)
        expectCancelValue = jsUndefined();
    else {
        expectCancelValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "expectCancel"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto expectCancelConversionResult = convertOptionalWithDefault<IDLBoolean>(lexicalGlobalObject, expectCancelValue, [&]() -> ConversionResult<IDLBoolean> { return Converter<IDLBoolean>::ReturnType { false }; });
    if (expectCancelConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.expectCancel = expectCancelConversionResult.releaseReturnValue();
    JSValue fastDataArrivalValue;
    if (isNullOrUndefined)
        fastDataArrivalValue = jsUndefined();
    else {
        fastDataArrivalValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "fastDataArrival"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto fastDataArrivalConversionResult = convertOptionalWithDefault<IDLBoolean>(lexicalGlobalObject, fastDataArrivalValue, [&]() -> ConversionResult<IDLBoolean> { return Converter<IDLBoolean>::ReturnType { false }; });
    if (fastDataArrivalConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.fastDataArrival = fastDataArrivalConversionResult.releaseReturnValue();
    JSValue isU2fValue;
    if (isNullOrUndefined)
        isU2fValue = jsUndefined();
    else {
        isU2fValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "isU2f"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto isU2fConversionResult = convertOptionalWithDefault<IDLBoolean>(lexicalGlobalObject, isU2fValue, [&]() -> ConversionResult<IDLBoolean> { return Converter<IDLBoolean>::ReturnType { false }; });
    if (isU2fConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.isU2f = isU2fConversionResult.releaseReturnValue();
    JSValue keepAliveValue;
    if (isNullOrUndefined)
        keepAliveValue = jsUndefined();
    else {
        keepAliveValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "keepAlive"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto keepAliveConversionResult = convertOptionalWithDefault<IDLBoolean>(lexicalGlobalObject, keepAliveValue, [&]() -> ConversionResult<IDLBoolean> { return Converter<IDLBoolean>::ReturnType { false }; });
    if (keepAliveConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.keepAlive = keepAliveConversionResult.releaseReturnValue();
    JSValue maxCredentialCountInListValue;
    if (isNullOrUndefined)
        maxCredentialCountInListValue = jsUndefined();
    else {
        maxCredentialCountInListValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "maxCredentialCountInList"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto maxCredentialCountInListConversionResult = convertOptionalWithDefault<IDLLong>(lexicalGlobalObject, maxCredentialCountInListValue, [&]() -> ConversionResult<IDLLong> { return Converter<IDLLong>::ReturnType { 1 }; });
    if (maxCredentialCountInListConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.maxCredentialCountInList = maxCredentialCountInListConversionResult.releaseReturnValue();
    JSValue maxCredentialIdLengthValue;
    if (isNullOrUndefined)
        maxCredentialIdLengthValue = jsUndefined();
    else {
        maxCredentialIdLengthValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "maxCredentialIdLength"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto maxCredentialIdLengthConversionResult = convertOptionalWithDefault<IDLLong>(lexicalGlobalObject, maxCredentialIdLengthValue, [&]() -> ConversionResult<IDLLong> { return Converter<IDLLong>::ReturnType { 64 }; });
    if (maxCredentialIdLengthConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.maxCredentialIdLength = maxCredentialIdLengthConversionResult.releaseReturnValue();
    JSValue payloadBase64Value;
    if (isNullOrUndefined)
        payloadBase64Value = jsUndefined();
    else {
        payloadBase64Value = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "payloadBase64"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!payloadBase64Value.isUndefined()) {
        auto payloadBase64ConversionResult = convert<IDLSequence<IDLDOMString>>(lexicalGlobalObject, payloadBase64Value);
        if (payloadBase64ConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.payloadBase64 = payloadBase64ConversionResult.releaseReturnValue();
    }
    JSValue stageValue;
    if (isNullOrUndefined)
        stageValue = jsUndefined();
    else {
        stageValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "stage"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto stageConversionResult = convertOptionalWithDefault<IDLEnumeration<MockWebAuthenticationConfiguration::HidStage>>(lexicalGlobalObject, stageValue, [&]() -> ConversionResult<IDLEnumeration<MockWebAuthenticationConfiguration::HidStage>> { return Converter<IDLEnumeration<MockWebAuthenticationConfiguration::HidStage>>::ReturnType { MockWebAuthenticationConfiguration::HidStage::Info }; });
    if (stageConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.stage = stageConversionResult.releaseReturnValue();
    JSValue subStageValue;
    if (isNullOrUndefined)
        subStageValue = jsUndefined();
    else {
        subStageValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "subStage"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto subStageConversionResult = convertOptionalWithDefault<IDLEnumeration<MockWebAuthenticationConfiguration::HidSubStage>>(lexicalGlobalObject, subStageValue, [&]() -> ConversionResult<IDLEnumeration<MockWebAuthenticationConfiguration::HidSubStage>> { return Converter<IDLEnumeration<MockWebAuthenticationConfiguration::HidSubStage>>::ReturnType { MockWebAuthenticationConfiguration::HidSubStage::Init }; });
    if (subStageConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.subStage = subStageConversionResult.releaseReturnValue();
    JSValue supportClientPinValue;
    if (isNullOrUndefined)
        supportClientPinValue = jsUndefined();
    else {
        supportClientPinValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "supportClientPin"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto supportClientPinConversionResult = convertOptionalWithDefault<IDLBoolean>(lexicalGlobalObject, supportClientPinValue, [&]() -> ConversionResult<IDLBoolean> { return Converter<IDLBoolean>::ReturnType { false }; });
    if (supportClientPinConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.supportClientPin = supportClientPinConversionResult.releaseReturnValue();
    JSValue supportInternalUVValue;
    if (isNullOrUndefined)
        supportInternalUVValue = jsUndefined();
    else {
        supportInternalUVValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "supportInternalUV"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto supportInternalUVConversionResult = convertOptionalWithDefault<IDLBoolean>(lexicalGlobalObject, supportInternalUVValue, [&]() -> ConversionResult<IDLBoolean> { return Converter<IDLBoolean>::ReturnType { false }; });
    if (supportInternalUVConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.supportInternalUV = supportInternalUVConversionResult.releaseReturnValue();
    return result;
}

#endif

#if ENABLE(WEB_AUTHN)

template<> ConversionResult<IDLDictionary<MockWebAuthenticationConfiguration::NfcConfiguration>> convertDictionary<MockWebAuthenticationConfiguration::NfcConfiguration>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    bool isNullOrUndefined = value.isUndefinedOrNull();
    auto* object = isNullOrUndefined ? nullptr : value.getObject();
    if (!isNullOrUndefined && !object) [[unlikely]] {
        throwTypeError(&lexicalGlobalObject, throwScope);
        return ConversionResultException { };
    }
    MockWebAuthenticationConfiguration::NfcConfiguration result;
    JSValue errorValue;
    if (isNullOrUndefined)
        errorValue = jsUndefined();
    else {
        errorValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "error"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto errorConversionResult = convertOptionalWithDefault<IDLEnumeration<MockWebAuthenticationConfiguration::NfcError>>(lexicalGlobalObject, errorValue, [&]() -> ConversionResult<IDLEnumeration<MockWebAuthenticationConfiguration::NfcError>> { return Converter<IDLEnumeration<MockWebAuthenticationConfiguration::NfcError>>::ReturnType { MockWebAuthenticationConfiguration::NfcError::Success }; });
    if (errorConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.error = errorConversionResult.releaseReturnValue();
    JSValue multiplePhysicalTagsValue;
    if (isNullOrUndefined)
        multiplePhysicalTagsValue = jsUndefined();
    else {
        multiplePhysicalTagsValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "multiplePhysicalTags"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto multiplePhysicalTagsConversionResult = convertOptionalWithDefault<IDLBoolean>(lexicalGlobalObject, multiplePhysicalTagsValue, [&]() -> ConversionResult<IDLBoolean> { return Converter<IDLBoolean>::ReturnType { false }; });
    if (multiplePhysicalTagsConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.multiplePhysicalTags = multiplePhysicalTagsConversionResult.releaseReturnValue();
    JSValue multipleTagsValue;
    if (isNullOrUndefined)
        multipleTagsValue = jsUndefined();
    else {
        multipleTagsValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "multipleTags"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto multipleTagsConversionResult = convertOptionalWithDefault<IDLBoolean>(lexicalGlobalObject, multipleTagsValue, [&]() -> ConversionResult<IDLBoolean> { return Converter<IDLBoolean>::ReturnType { false }; });
    if (multipleTagsConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.multipleTags = multipleTagsConversionResult.releaseReturnValue();
    JSValue payloadBase64Value;
    if (isNullOrUndefined)
        payloadBase64Value = jsUndefined();
    else {
        payloadBase64Value = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "payloadBase64"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!payloadBase64Value.isUndefined()) {
        auto payloadBase64ConversionResult = convert<IDLSequence<IDLDOMString>>(lexicalGlobalObject, payloadBase64Value);
        if (payloadBase64ConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.payloadBase64 = payloadBase64ConversionResult.releaseReturnValue();
    }
    return result;
}

#endif

#if ENABLE(WEB_AUTHN)

template<> ConversionResult<IDLDictionary<MockWebAuthenticationConfiguration::CcidConfiguration>> convertDictionary<MockWebAuthenticationConfiguration::CcidConfiguration>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    bool isNullOrUndefined = value.isUndefinedOrNull();
    auto* object = isNullOrUndefined ? nullptr : value.getObject();
    if (!isNullOrUndefined && !object) [[unlikely]] {
        throwTypeError(&lexicalGlobalObject, throwScope);
        return ConversionResultException { };
    }
    MockWebAuthenticationConfiguration::CcidConfiguration result;
    JSValue payloadBase64Value;
    if (isNullOrUndefined)
        payloadBase64Value = jsUndefined();
    else {
        payloadBase64Value = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "payloadBase64"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!payloadBase64Value.isUndefined()) {
        auto payloadBase64ConversionResult = convert<IDLSequence<IDLDOMString>>(lexicalGlobalObject, payloadBase64Value);
        if (payloadBase64ConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.payloadBase64 = payloadBase64ConversionResult.releaseReturnValue();
    }
    return result;
}

#endif

} // namespace WebCore


#endif // ENABLE(WEB_AUTHN)
