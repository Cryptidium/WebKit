/*
    This file is part of the WebKit open source project.
    This file has been generated by generate-bindings.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.
*/

#include "config.h"

#if ENABLE(WEBGL)

#include "JSWebGLRenderingContext.h"

#include "ActiveDOMObject.h"
#include "ContextDestructionObserverInlines.h"
#include "ExtendedDOMClientIsoSubspaces.h"
#include "ExtendedDOMIsoSubspaces.h"
#include "InspectorCanvasCallTracer.h"
#include "JSDOMAttribute.h"
#include "JSDOMBinding.h"
#include "JSDOMConstructorNotConstructable.h"
#include "JSDOMExceptionHandling.h"
#include "JSDOMGlobalObjectInlines.h"
#include "JSDOMOperation.h"
#include "JSDOMWrapperCache.h"
#include "ScriptExecutionContext.h"
#include "Settings.h"
#include "WebCoreJSClientData.h"
#include "WebCoreOpaqueRootInlines.h"
#include <JavaScriptCore/FunctionPrototype.h>
#include <JavaScriptCore/HeapAnalyzer.h>
#include <JavaScriptCore/JSCInlines.h>
#include <JavaScriptCore/JSDestructibleObjectHeapCellType.h>
#include <JavaScriptCore/SlotVisitorMacros.h>
#include <JavaScriptCore/SubspaceInlines.h>
#include <wtf/GetPtr.h>
#include <wtf/PointerPreparations.h>
#include <wtf/URL.h>
#include <wtf/text/MakeString.h>

#if ENABLE(WEBGL)
#include "JSDOMConvertBoolean.h"
#include "JSDOMConvertBufferSource.h"
#include "JSDOMConvertDictionary.h"
#include "JSDOMConvertInterface.h"
#include "JSDOMConvertNullable.h"
#include "JSDOMConvertNumbers.h"
#include "JSDOMConvertSequences.h"
#include "JSDOMConvertStrings.h"
#include "JSDOMConvertUnion.h"
#include "JSDOMConvertWebGL.h"
#include "JSHTMLCanvasElement.h"
#include "JSHTMLImageElement.h"
#include "JSHTMLVideoElement.h"
#include "JSImageBitmap.h"
#include "JSImageData.h"
#include "JSWebGLActiveInfo.h"
#include "JSWebGLBuffer.h"
#include "JSWebGLContextAttributes.h"
#include "JSWebGLFramebuffer.h"
#include "JSWebGLProgram.h"
#include "JSWebGLRenderbuffer.h"
#include "JSWebGLShader.h"
#include "JSWebGLShaderPrecisionFormat.h"
#include "JSWebGLTexture.h"
#include "JSWebGLUniformLocation.h"
#include <JavaScriptCore/JSArray.h>
#include <wtf/Variant.h>
#endif

#if ENABLE(WEBGL) && ENABLE(WEBXR)
#include "DOMPromiseProxy.h"
#include "JSDOMConvertPromise.h"
#include "JSDOMOperationReturningPromise.h"
#endif

#if ENABLE(WEBGL) || (ENABLE(WEBGL) && ENABLE(WEBXR))
#include "IDLTypes.h"
#include "JSDOMConvertBase.h"
#include "JSDOMGlobalObject.h"
#endif

namespace WebCore {
using namespace JSC;

// Functions

#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_activeTexture);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_attachShader);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_bindAttribLocation);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_bindBuffer);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_bindFramebuffer);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_bindRenderbuffer);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_bindTexture);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_blendColor);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_blendEquation);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_blendEquationSeparate);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_blendFunc);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_blendFuncSeparate);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_bufferData);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_bufferSubData);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_checkFramebufferStatus);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_clear);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_clearColor);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_clearDepth);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_clearStencil);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_colorMask);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_compileShader);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_texImage2D);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_texSubImage2D);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_compressedTexImage2D);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_compressedTexSubImage2D);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_copyTexImage2D);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_copyTexSubImage2D);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_createBuffer);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_createFramebuffer);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_createProgram);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_createRenderbuffer);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_createShader);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_createTexture);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_cullFace);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_deleteBuffer);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_deleteFramebuffer);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_deleteProgram);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_deleteRenderbuffer);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_deleteShader);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_deleteTexture);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_depthFunc);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_depthMask);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_depthRange);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_detachShader);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_disable);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_disableVertexAttribArray);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_drawArrays);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_drawElements);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_enable);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_enableVertexAttribArray);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_finish);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_flush);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_framebufferRenderbuffer);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_framebufferTexture2D);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_frontFace);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_generateMipmap);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getActiveAttrib);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getActiveUniform);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getAttachedShaders);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getAttribLocation);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getBufferParameter);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getContextAttributes);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getError);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getSupportedExtensions);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getExtension);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getFramebufferAttachmentParameter);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getParameter);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getProgramParameter);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getProgramInfoLog);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getRenderbufferParameter);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getShaderParameter);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getShaderInfoLog);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getShaderPrecisionFormat);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getShaderSource);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getTexParameter);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getUniform);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getUniformLocation);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getVertexAttrib);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getVertexAttribOffset);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_hint);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_isBuffer);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_isContextLost);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_isEnabled);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_isFramebuffer);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_isProgram);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_isRenderbuffer);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_isShader);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_isTexture);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_lineWidth);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_linkProgram);
#endif
#if ENABLE(WEBGL) && ENABLE(WEBXR)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_makeXRCompatible);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_pixelStorei);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_polygonOffset);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_readPixels);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_renderbufferStorage);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_sampleCoverage);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_scissor);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_shaderSource);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_stencilFunc);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_stencilFuncSeparate);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_stencilMask);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_stencilMaskSeparate);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_stencilOp);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_stencilOpSeparate);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_texParameterf);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_texParameteri);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform1f);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform2f);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform3f);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform4f);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform1i);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform2i);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform3i);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform4i);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform1fv);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform2fv);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform3fv);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform4fv);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform1iv);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform2iv);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform3iv);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform4iv);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniformMatrix2fv);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniformMatrix3fv);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniformMatrix4fv);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_useProgram);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_validateProgram);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_vertexAttrib1f);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_vertexAttrib2f);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_vertexAttrib3f);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_vertexAttrib4f);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_vertexAttrib1fv);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_vertexAttrib2fv);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_vertexAttrib3fv);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_vertexAttrib4fv);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_vertexAttribPointer);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_viewport);
#endif

// Attributes

static JSC_DECLARE_CUSTOM_GETTER(jsWebGLRenderingContextConstructor);
#if ENABLE(WEBGL)
static JSC_DECLARE_CUSTOM_GETTER(jsWebGLRenderingContext_canvas);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_CUSTOM_GETTER(jsWebGLRenderingContext_drawingBufferWidth);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_CUSTOM_GETTER(jsWebGLRenderingContext_drawingBufferHeight);
#endif

class JSWebGLRenderingContextPrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;
    static JSWebGLRenderingContextPrototype* create(JSC::VM& vm, JSDOMGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSWebGLRenderingContextPrototype* ptr = new (NotNull, JSC::allocateCell<JSWebGLRenderingContextPrototype>(vm)) JSWebGLRenderingContextPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSWebGLRenderingContextPrototype, Base);
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSWebGLRenderingContextPrototype(JSC::VM& vm, JSC::JSGlobalObject*, JSC::Structure* structure)
        : JSC::JSNonFinalObject(vm, structure)
    {
    }

    void finishCreation(JSC::VM&);
};
STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSWebGLRenderingContextPrototype, JSWebGLRenderingContextPrototype::Base);

using JSWebGLRenderingContextDOMConstructor = JSDOMConstructorNotConstructable<JSWebGLRenderingContext>;

/* Hash table for constructor */

static const std::array<HashTableValue, 296> JSWebGLRenderingContextConstructorTableValues {
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_BUFFER_BIT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x00000100 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BUFFER_BIT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x00000400 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "COLOR_BUFFER_BIT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x00004000 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "POINTS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0000 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0001 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINE_LOOP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0002 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINE_STRIP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0003 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TRIANGLES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0004 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TRIANGLE_STRIP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0005 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TRIANGLE_FAN"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0006 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ZERO"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ONE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SRC_COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0300 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ONE_MINUS_SRC_COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0301 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SRC_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0302 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ONE_MINUS_SRC_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0303 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DST_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0304 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ONE_MINUS_DST_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0305 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DST_COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0306 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ONE_MINUS_DST_COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0307 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SRC_ALPHA_SATURATE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0308 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FUNC_ADD"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8006 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_EQUATION"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8009 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_EQUATION_RGB"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8009 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_EQUATION_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x883D } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FUNC_SUBTRACT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x800A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FUNC_REVERSE_SUBTRACT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x800B } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_DST_RGB"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80C8 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_SRC_RGB"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80C9 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_DST_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80CA } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_SRC_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80CB } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CONSTANT_COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8001 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ONE_MINUS_CONSTANT_COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8002 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CONSTANT_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8003 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ONE_MINUS_CONSTANT_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8004 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8005 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ARRAY_BUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8892 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ELEMENT_ARRAY_BUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8893 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ARRAY_BUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8894 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ELEMENT_ARRAY_BUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8895 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STREAM_DRAW"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88E0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STATIC_DRAW"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88E4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DYNAMIC_DRAW"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88E8 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BUFFER_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8764 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BUFFER_USAGE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8765 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CURRENT_VERTEX_ATTRIB"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8626 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRONT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0404 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BACK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0405 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRONT_AND_BACK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0408 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_2D"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0DE1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CULL_FACE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B44 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0BE2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DITHER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0BD0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_TEST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B90 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_TEST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B71 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SCISSOR_TEST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0C11 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "POLYGON_OFFSET_FILL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8037 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLE_ALPHA_TO_COVERAGE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x809E } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLE_COVERAGE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80A0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NO_ERROR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INVALID_ENUM"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0500 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INVALID_VALUE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0501 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INVALID_OPERATION"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0502 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "OUT_OF_MEMORY"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0505 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CW"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0900 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CCW"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0901 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINE_WIDTH"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B21 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ALIASED_POINT_SIZE_RANGE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x846D } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ALIASED_LINE_WIDTH_RANGE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x846E } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CULL_FACE_MODE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B45 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRONT_FACE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B46 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_RANGE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B70 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_WRITEMASK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B72 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_CLEAR_VALUE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B73 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_FUNC"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B74 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_CLEAR_VALUE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B91 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_FUNC"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B92 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_FAIL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B94 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_PASS_DEPTH_FAIL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B95 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_PASS_DEPTH_PASS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B96 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_REF"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B97 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_VALUE_MASK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B93 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_WRITEMASK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B98 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BACK_FUNC"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8800 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BACK_FAIL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8801 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BACK_PASS_DEPTH_FAIL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8802 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BACK_PASS_DEPTH_PASS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8803 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BACK_REF"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CA3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BACK_VALUE_MASK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CA4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BACK_WRITEMASK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CA5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VIEWPORT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0BA2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SCISSOR_BOX"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0C10 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "COLOR_CLEAR_VALUE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0C22 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "COLOR_WRITEMASK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0C23 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNPACK_ALIGNMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0CF5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "PACK_ALIGNMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D05 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_TEXTURE_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D33 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_VIEWPORT_DIMS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D3A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SUBPIXEL_BITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D50 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RED_BITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D52 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "GREEN_BITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D53 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLUE_BITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D54 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ALPHA_BITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D55 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_BITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D56 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D57 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "POLYGON_OFFSET_UNITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2A00 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "POLYGON_OFFSET_FACTOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8038 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_BINDING_2D"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8069 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLE_BUFFERS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80A8 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80A9 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLE_COVERAGE_VALUE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80AA } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLE_COVERAGE_INVERT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80AB } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "COMPRESSED_TEXTURE_FORMATS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x86A3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DONT_CARE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1100 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FASTEST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1101 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NICEST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1102 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "GENERATE_MIPMAP_HINT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8192 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BYTE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1400 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNSIGNED_BYTE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1401 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SHORT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1402 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNSIGNED_SHORT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1403 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1404 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNSIGNED_INT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1405 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FLOAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1406 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_COMPONENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1902 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1906 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RGB"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1907 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RGBA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1908 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LUMINANCE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1909 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LUMINANCE_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x190A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNSIGNED_SHORT_4_4_4_4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8033 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNSIGNED_SHORT_5_5_5_1"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8034 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNSIGNED_SHORT_5_6_5"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8363 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAGMENT_SHADER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B30 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_SHADER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B31 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_VERTEX_ATTRIBS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8869 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_VERTEX_UNIFORM_VECTORS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DFB } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_VARYING_VECTORS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DFC } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_COMBINED_TEXTURE_IMAGE_UNITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B4D } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_VERTEX_TEXTURE_IMAGE_UNITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B4C } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_TEXTURE_IMAGE_UNITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8872 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_FRAGMENT_UNIFORM_VECTORS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DFD } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SHADER_TYPE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B4F } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DELETE_STATUS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B80 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINK_STATUS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B82 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VALIDATE_STATUS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B83 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ATTACHED_SHADERS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B85 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ACTIVE_UNIFORMS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B86 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ACTIVE_ATTRIBUTES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B89 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SHADING_LANGUAGE_VERSION"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B8C } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CURRENT_PROGRAM"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B8D } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NEVER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0200 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LESS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0201 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "EQUAL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0202 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LEQUAL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0203 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "GREATER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0204 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NOTEQUAL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0205 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "GEQUAL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0206 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ALWAYS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0207 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "KEEP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1E00 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "REPLACE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1E01 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INCR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1E02 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DECR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1E03 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INVERT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x150A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INCR_WRAP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8507 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DECR_WRAP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8508 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VENDOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1F00 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1F01 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERSION"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1F02 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NEAREST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2600 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINEAR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2601 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NEAREST_MIPMAP_NEAREST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2700 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINEAR_MIPMAP_NEAREST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2701 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NEAREST_MIPMAP_LINEAR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2702 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINEAR_MIPMAP_LINEAR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2703 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_MAG_FILTER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2800 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_MIN_FILTER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2801 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_WRAP_S"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2802 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_WRAP_T"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2803 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1702 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_CUBE_MAP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8513 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_BINDING_CUBE_MAP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8514 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_CUBE_MAP_POSITIVE_X"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8515 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_CUBE_MAP_NEGATIVE_X"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8516 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_CUBE_MAP_POSITIVE_Y"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8517 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_CUBE_MAP_NEGATIVE_Y"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8518 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_CUBE_MAP_POSITIVE_Z"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8519 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_CUBE_MAP_NEGATIVE_Z"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x851A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_CUBE_MAP_TEXTURE_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x851C } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE0"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE1"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE3"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE5"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE6"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C6 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE7"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C7 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE8"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C8 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE9"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C9 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE10"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84CA } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE11"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84CB } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE12"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84CC } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE13"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84CD } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE14"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84CE } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE15"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84CF } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE16"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE17"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE18"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE19"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE20"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE21"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE22"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D6 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE23"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D7 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE24"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D8 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE25"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D9 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE26"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84DA } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE27"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84DB } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE28"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84DC } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE29"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84DD } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE30"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84DE } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE31"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84DF } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ACTIVE_TEXTURE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84E0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "REPEAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2901 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CLAMP_TO_EDGE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x812F } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MIRRORED_REPEAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8370 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FLOAT_VEC2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B50 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FLOAT_VEC3"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B51 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FLOAT_VEC4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B52 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INT_VEC2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B53 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INT_VEC3"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B54 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INT_VEC4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B55 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BOOL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B56 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BOOL_VEC2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B57 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BOOL_VEC3"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B58 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BOOL_VEC4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B59 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FLOAT_MAT2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B5A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FLOAT_MAT3"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B5B } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FLOAT_MAT4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B5C } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLER_2D"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B5E } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLER_CUBE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B60 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_ATTRIB_ARRAY_ENABLED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8622 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_ATTRIB_ARRAY_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8623 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_ATTRIB_ARRAY_STRIDE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8624 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_ATTRIB_ARRAY_TYPE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8625 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_ATTRIB_ARRAY_NORMALIZED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x886A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_ATTRIB_ARRAY_POINTER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8645 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x889F } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "IMPLEMENTATION_COLOR_READ_TYPE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B9A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "IMPLEMENTATION_COLOR_READ_FORMAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B9B } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "COMPILE_STATUS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B81 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LOW_FLOAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DF0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MEDIUM_FLOAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DF1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "HIGH_FLOAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DF2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LOW_INT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DF3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MEDIUM_INT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DF4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "HIGH_INT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DF5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D40 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D41 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RGBA4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8056 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RGB5_A1"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8057 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RGB565"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D62 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_COMPONENT16"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x81A5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_INDEX8"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D48 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_STENCIL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84F9 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_WIDTH"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D42 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_HEIGHT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D43 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_INTERNAL_FORMAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D44 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_RED_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D50 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_GREEN_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D51 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_BLUE_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D52 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_ALPHA_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D53 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_DEPTH_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D54 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_STENCIL_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D55 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "COLOR_ATTACHMENT0"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CE0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_ATTACHMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D00 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_ATTACHMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D20 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_STENCIL_ATTACHMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x821A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NONE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_COMPLETE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_INCOMPLETE_ATTACHMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD6 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD7 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_INCOMPLETE_DIMENSIONS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD9 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_UNSUPPORTED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CDD } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CA6 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CA7 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_RENDERBUFFER_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84E8 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INVALID_FRAMEBUFFER_OPERATION"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0506 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNPACK_FLIP_Y_WEBGL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9240 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNPACK_PREMULTIPLY_ALPHA_WEBGL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9241 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CONTEXT_LOST_WEBGL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9242 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNPACK_COLORSPACE_CONVERSION_WEBGL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9243 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BROWSER_DEFAULT_WEBGL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9244 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
};

template<> const ClassInfo JSWebGLRenderingContextDOMConstructor::s_info = { "WebGLRenderingContext"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSWebGLRenderingContextDOMConstructor) };

template<> JSValue JSWebGLRenderingContextDOMConstructor::prototypeForStructure(JSC::VM& vm, const JSDOMGlobalObject& globalObject)
{
    UNUSED_PARAM(vm);
    return globalObject.functionPrototype();
}

template<> void JSWebGLRenderingContextDOMConstructor::initializeProperties(VM& vm, JSDOMGlobalObject& globalObject)
{
    putDirect(vm, vm.propertyNames->length, jsNumber(0), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);
    JSString* nameString = jsNontrivialString(vm, "WebGLRenderingContext"_s);
    m_originalName.set(vm, this, nameString);
    putDirect(vm, vm.propertyNames->name, nameString, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);
    putDirect(vm, vm.propertyNames->prototype, JSWebGLRenderingContext::prototype(vm, globalObject), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::DontDelete);
    reifyStaticProperties(vm, JSWebGLRenderingContext::info(), JSWebGLRenderingContextConstructorTableValues, *this);
}

/* Hash table for prototype */

static const std::array<HashTableValue, 437> JSWebGLRenderingContextPrototypeTableValues {
    HashTableValue { "constructor"_s, static_cast<unsigned>(PropertyAttribute::DontEnum), NoIntrinsic, { HashTableValue::GetterSetterType, jsWebGLRenderingContextConstructor, 0 } },
#if ENABLE(WEBGL)
    HashTableValue { "canvas"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsWebGLRenderingContext_canvas, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "drawingBufferWidth"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsWebGLRenderingContext_drawingBufferWidth, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "drawingBufferHeight"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsWebGLRenderingContext_drawingBufferHeight, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "activeTexture"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_activeTexture, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "attachShader"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_attachShader, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "bindAttribLocation"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_bindAttribLocation, 3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "bindBuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_bindBuffer, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "bindFramebuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_bindFramebuffer, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "bindRenderbuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_bindRenderbuffer, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "bindTexture"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_bindTexture, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "blendColor"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_blendColor, 4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "blendEquation"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_blendEquation, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "blendEquationSeparate"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_blendEquationSeparate, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "blendFunc"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_blendFunc, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "blendFuncSeparate"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_blendFuncSeparate, 4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "bufferData"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_bufferData, 3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "bufferSubData"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_bufferSubData, 3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "checkFramebufferStatus"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_checkFramebufferStatus, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "clear"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_clear, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "clearColor"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_clearColor, 4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "clearDepth"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_clearDepth, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "clearStencil"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_clearStencil, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "colorMask"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_colorMask, 4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "compileShader"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_compileShader, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "texImage2D"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_texImage2D, 6 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "texSubImage2D"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_texSubImage2D, 7 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "compressedTexImage2D"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_compressedTexImage2D, 7 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "compressedTexSubImage2D"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_compressedTexSubImage2D, 8 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "copyTexImage2D"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_copyTexImage2D, 8 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "copyTexSubImage2D"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_copyTexSubImage2D, 8 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "createBuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_createBuffer, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "createFramebuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_createFramebuffer, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "createProgram"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_createProgram, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "createRenderbuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_createRenderbuffer, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "createShader"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_createShader, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "createTexture"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_createTexture, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "cullFace"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_cullFace, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "deleteBuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_deleteBuffer, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "deleteFramebuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_deleteFramebuffer, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "deleteProgram"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_deleteProgram, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "deleteRenderbuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_deleteRenderbuffer, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "deleteShader"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_deleteShader, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "deleteTexture"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_deleteTexture, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "depthFunc"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_depthFunc, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "depthMask"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_depthMask, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "depthRange"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_depthRange, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "detachShader"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_detachShader, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "disable"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_disable, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "disableVertexAttribArray"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_disableVertexAttribArray, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "drawArrays"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_drawArrays, 3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "drawElements"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_drawElements, 4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "enable"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_enable, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "enableVertexAttribArray"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_enableVertexAttribArray, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "finish"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_finish, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "flush"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_flush, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "framebufferRenderbuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_framebufferRenderbuffer, 4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "framebufferTexture2D"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_framebufferTexture2D, 5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "frontFace"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_frontFace, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "generateMipmap"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_generateMipmap, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getActiveAttrib"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_getActiveAttrib, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getActiveUniform"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_getActiveUniform, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getAttachedShaders"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_getAttachedShaders, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getAttribLocation"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_getAttribLocation, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getBufferParameter"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_getBufferParameter, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getContextAttributes"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_getContextAttributes, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getError"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_getError, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getSupportedExtensions"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_getSupportedExtensions, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getExtension"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_getExtension, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getFramebufferAttachmentParameter"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_getFramebufferAttachmentParameter, 3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getParameter"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_getParameter, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getProgramParameter"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_getProgramParameter, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getProgramInfoLog"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_getProgramInfoLog, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getRenderbufferParameter"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_getRenderbufferParameter, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getShaderParameter"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_getShaderParameter, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getShaderInfoLog"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_getShaderInfoLog, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getShaderPrecisionFormat"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_getShaderPrecisionFormat, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getShaderSource"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_getShaderSource, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getTexParameter"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_getTexParameter, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getUniform"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_getUniform, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getUniformLocation"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_getUniformLocation, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getVertexAttrib"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_getVertexAttrib, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getVertexAttribOffset"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_getVertexAttribOffset, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "hint"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_hint, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "isBuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_isBuffer, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "isContextLost"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_isContextLost, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "isEnabled"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_isEnabled, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "isFramebuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_isFramebuffer, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "isProgram"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_isProgram, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "isRenderbuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_isRenderbuffer, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "isShader"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_isShader, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "isTexture"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_isTexture, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "lineWidth"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_lineWidth, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "linkProgram"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_linkProgram, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL) && ENABLE(WEBXR)
    HashTableValue { "makeXRCompatible"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_makeXRCompatible, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "pixelStorei"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_pixelStorei, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "polygonOffset"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_polygonOffset, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "readPixels"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_readPixels, 7 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "renderbufferStorage"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_renderbufferStorage, 4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "sampleCoverage"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_sampleCoverage, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "scissor"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_scissor, 4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "shaderSource"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_shaderSource, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "stencilFunc"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_stencilFunc, 3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "stencilFuncSeparate"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_stencilFuncSeparate, 4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "stencilMask"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_stencilMask, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "stencilMaskSeparate"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_stencilMaskSeparate, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "stencilOp"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_stencilOp, 3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "stencilOpSeparate"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_stencilOpSeparate, 4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "texParameterf"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_texParameterf, 3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "texParameteri"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_texParameteri, 3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "uniform1f"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_uniform1f, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "uniform2f"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_uniform2f, 3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "uniform3f"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_uniform3f, 4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "uniform4f"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_uniform4f, 5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "uniform1i"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_uniform1i, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "uniform2i"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_uniform2i, 3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "uniform3i"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_uniform3i, 4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "uniform4i"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_uniform4i, 5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "uniform1fv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_uniform1fv, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "uniform2fv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_uniform2fv, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "uniform3fv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_uniform3fv, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "uniform4fv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_uniform4fv, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "uniform1iv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_uniform1iv, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "uniform2iv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_uniform2iv, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "uniform3iv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_uniform3iv, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "uniform4iv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_uniform4iv, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "uniformMatrix2fv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_uniformMatrix2fv, 3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "uniformMatrix3fv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_uniformMatrix3fv, 3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "uniformMatrix4fv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_uniformMatrix4fv, 3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "useProgram"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_useProgram, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "validateProgram"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_validateProgram, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "vertexAttrib1f"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_vertexAttrib1f, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "vertexAttrib2f"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_vertexAttrib2f, 3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "vertexAttrib3f"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_vertexAttrib3f, 4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "vertexAttrib4f"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_vertexAttrib4f, 5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "vertexAttrib1fv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_vertexAttrib1fv, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "vertexAttrib2fv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_vertexAttrib2fv, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "vertexAttrib3fv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_vertexAttrib3fv, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "vertexAttrib4fv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_vertexAttrib4fv, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "vertexAttribPointer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_vertexAttribPointer, 6 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "viewport"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGLRenderingContextPrototypeFunction_viewport, 4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_BUFFER_BIT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x00000100 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BUFFER_BIT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x00000400 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "COLOR_BUFFER_BIT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x00004000 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "POINTS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0000 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0001 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINE_LOOP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0002 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINE_STRIP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0003 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TRIANGLES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0004 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TRIANGLE_STRIP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0005 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TRIANGLE_FAN"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0006 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ZERO"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ONE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SRC_COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0300 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ONE_MINUS_SRC_COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0301 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SRC_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0302 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ONE_MINUS_SRC_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0303 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DST_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0304 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ONE_MINUS_DST_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0305 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DST_COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0306 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ONE_MINUS_DST_COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0307 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SRC_ALPHA_SATURATE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0308 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FUNC_ADD"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8006 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_EQUATION"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8009 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_EQUATION_RGB"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8009 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_EQUATION_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x883D } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FUNC_SUBTRACT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x800A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FUNC_REVERSE_SUBTRACT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x800B } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_DST_RGB"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80C8 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_SRC_RGB"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80C9 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_DST_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80CA } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_SRC_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80CB } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CONSTANT_COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8001 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ONE_MINUS_CONSTANT_COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8002 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CONSTANT_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8003 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ONE_MINUS_CONSTANT_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8004 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8005 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ARRAY_BUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8892 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ELEMENT_ARRAY_BUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8893 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ARRAY_BUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8894 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ELEMENT_ARRAY_BUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8895 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STREAM_DRAW"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88E0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STATIC_DRAW"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88E4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DYNAMIC_DRAW"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88E8 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BUFFER_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8764 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BUFFER_USAGE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8765 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CURRENT_VERTEX_ATTRIB"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8626 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRONT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0404 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BACK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0405 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRONT_AND_BACK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0408 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_2D"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0DE1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CULL_FACE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B44 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0BE2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DITHER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0BD0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_TEST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B90 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_TEST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B71 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SCISSOR_TEST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0C11 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "POLYGON_OFFSET_FILL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8037 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLE_ALPHA_TO_COVERAGE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x809E } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLE_COVERAGE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80A0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NO_ERROR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INVALID_ENUM"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0500 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INVALID_VALUE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0501 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INVALID_OPERATION"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0502 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "OUT_OF_MEMORY"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0505 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CW"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0900 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CCW"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0901 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINE_WIDTH"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B21 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ALIASED_POINT_SIZE_RANGE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x846D } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ALIASED_LINE_WIDTH_RANGE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x846E } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CULL_FACE_MODE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B45 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRONT_FACE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B46 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_RANGE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B70 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_WRITEMASK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B72 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_CLEAR_VALUE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B73 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_FUNC"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B74 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_CLEAR_VALUE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B91 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_FUNC"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B92 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_FAIL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B94 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_PASS_DEPTH_FAIL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B95 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_PASS_DEPTH_PASS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B96 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_REF"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B97 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_VALUE_MASK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B93 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_WRITEMASK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B98 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BACK_FUNC"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8800 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BACK_FAIL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8801 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BACK_PASS_DEPTH_FAIL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8802 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BACK_PASS_DEPTH_PASS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8803 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BACK_REF"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CA3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BACK_VALUE_MASK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CA4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BACK_WRITEMASK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CA5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VIEWPORT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0BA2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SCISSOR_BOX"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0C10 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "COLOR_CLEAR_VALUE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0C22 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "COLOR_WRITEMASK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0C23 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNPACK_ALIGNMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0CF5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "PACK_ALIGNMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D05 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_TEXTURE_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D33 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_VIEWPORT_DIMS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D3A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SUBPIXEL_BITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D50 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RED_BITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D52 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "GREEN_BITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D53 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLUE_BITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D54 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ALPHA_BITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D55 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_BITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D56 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D57 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "POLYGON_OFFSET_UNITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2A00 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "POLYGON_OFFSET_FACTOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8038 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_BINDING_2D"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8069 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLE_BUFFERS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80A8 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80A9 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLE_COVERAGE_VALUE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80AA } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLE_COVERAGE_INVERT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80AB } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "COMPRESSED_TEXTURE_FORMATS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x86A3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DONT_CARE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1100 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FASTEST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1101 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NICEST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1102 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "GENERATE_MIPMAP_HINT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8192 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BYTE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1400 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNSIGNED_BYTE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1401 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SHORT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1402 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNSIGNED_SHORT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1403 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1404 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNSIGNED_INT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1405 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FLOAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1406 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_COMPONENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1902 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1906 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RGB"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1907 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RGBA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1908 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LUMINANCE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1909 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LUMINANCE_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x190A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNSIGNED_SHORT_4_4_4_4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8033 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNSIGNED_SHORT_5_5_5_1"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8034 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNSIGNED_SHORT_5_6_5"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8363 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAGMENT_SHADER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B30 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_SHADER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B31 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_VERTEX_ATTRIBS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8869 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_VERTEX_UNIFORM_VECTORS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DFB } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_VARYING_VECTORS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DFC } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_COMBINED_TEXTURE_IMAGE_UNITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B4D } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_VERTEX_TEXTURE_IMAGE_UNITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B4C } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_TEXTURE_IMAGE_UNITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8872 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_FRAGMENT_UNIFORM_VECTORS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DFD } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SHADER_TYPE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B4F } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DELETE_STATUS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B80 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINK_STATUS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B82 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VALIDATE_STATUS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B83 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ATTACHED_SHADERS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B85 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ACTIVE_UNIFORMS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B86 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ACTIVE_ATTRIBUTES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B89 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SHADING_LANGUAGE_VERSION"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B8C } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CURRENT_PROGRAM"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B8D } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NEVER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0200 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LESS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0201 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "EQUAL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0202 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LEQUAL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0203 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "GREATER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0204 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NOTEQUAL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0205 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "GEQUAL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0206 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ALWAYS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0207 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "KEEP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1E00 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "REPLACE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1E01 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INCR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1E02 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DECR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1E03 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INVERT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x150A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INCR_WRAP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8507 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DECR_WRAP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8508 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VENDOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1F00 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1F01 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERSION"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1F02 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NEAREST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2600 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINEAR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2601 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NEAREST_MIPMAP_NEAREST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2700 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINEAR_MIPMAP_NEAREST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2701 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NEAREST_MIPMAP_LINEAR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2702 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINEAR_MIPMAP_LINEAR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2703 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_MAG_FILTER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2800 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_MIN_FILTER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2801 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_WRAP_S"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2802 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_WRAP_T"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2803 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1702 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_CUBE_MAP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8513 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_BINDING_CUBE_MAP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8514 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_CUBE_MAP_POSITIVE_X"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8515 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_CUBE_MAP_NEGATIVE_X"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8516 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_CUBE_MAP_POSITIVE_Y"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8517 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_CUBE_MAP_NEGATIVE_Y"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8518 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_CUBE_MAP_POSITIVE_Z"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8519 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_CUBE_MAP_NEGATIVE_Z"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x851A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_CUBE_MAP_TEXTURE_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x851C } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE0"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE1"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE3"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE5"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE6"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C6 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE7"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C7 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE8"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C8 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE9"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C9 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE10"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84CA } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE11"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84CB } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE12"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84CC } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE13"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84CD } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE14"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84CE } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE15"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84CF } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE16"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE17"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE18"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE19"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE20"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE21"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE22"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D6 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE23"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D7 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE24"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D8 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE25"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D9 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE26"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84DA } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE27"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84DB } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE28"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84DC } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE29"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84DD } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE30"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84DE } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE31"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84DF } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ACTIVE_TEXTURE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84E0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "REPEAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2901 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CLAMP_TO_EDGE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x812F } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MIRRORED_REPEAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8370 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FLOAT_VEC2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B50 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FLOAT_VEC3"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B51 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FLOAT_VEC4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B52 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INT_VEC2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B53 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INT_VEC3"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B54 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INT_VEC4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B55 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BOOL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B56 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BOOL_VEC2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B57 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BOOL_VEC3"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B58 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BOOL_VEC4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B59 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FLOAT_MAT2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B5A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FLOAT_MAT3"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B5B } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FLOAT_MAT4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B5C } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLER_2D"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B5E } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLER_CUBE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B60 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_ATTRIB_ARRAY_ENABLED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8622 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_ATTRIB_ARRAY_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8623 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_ATTRIB_ARRAY_STRIDE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8624 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_ATTRIB_ARRAY_TYPE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8625 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_ATTRIB_ARRAY_NORMALIZED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x886A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_ATTRIB_ARRAY_POINTER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8645 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x889F } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "IMPLEMENTATION_COLOR_READ_TYPE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B9A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "IMPLEMENTATION_COLOR_READ_FORMAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B9B } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "COMPILE_STATUS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B81 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LOW_FLOAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DF0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MEDIUM_FLOAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DF1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "HIGH_FLOAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DF2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LOW_INT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DF3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MEDIUM_INT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DF4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "HIGH_INT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DF5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D40 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D41 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RGBA4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8056 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RGB5_A1"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8057 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RGB565"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D62 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_COMPONENT16"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x81A5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_INDEX8"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D48 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_STENCIL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84F9 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_WIDTH"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D42 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_HEIGHT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D43 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_INTERNAL_FORMAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D44 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_RED_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D50 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_GREEN_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D51 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_BLUE_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D52 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_ALPHA_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D53 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_DEPTH_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D54 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_STENCIL_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D55 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "COLOR_ATTACHMENT0"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CE0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_ATTACHMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D00 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_ATTACHMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D20 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_STENCIL_ATTACHMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x821A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NONE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_COMPLETE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_INCOMPLETE_ATTACHMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD6 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD7 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_INCOMPLETE_DIMENSIONS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD9 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_UNSUPPORTED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CDD } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CA6 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CA7 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_RENDERBUFFER_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84E8 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INVALID_FRAMEBUFFER_OPERATION"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0506 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNPACK_FLIP_Y_WEBGL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9240 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNPACK_PREMULTIPLY_ALPHA_WEBGL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9241 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CONTEXT_LOST_WEBGL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9242 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNPACK_COLORSPACE_CONVERSION_WEBGL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9243 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BROWSER_DEFAULT_WEBGL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9244 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
};

const ClassInfo JSWebGLRenderingContextPrototype::s_info = { "WebGLRenderingContext"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSWebGLRenderingContextPrototype) };

void JSWebGLRenderingContextPrototype::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSWebGLRenderingContext::info(), JSWebGLRenderingContextPrototypeTableValues, *this);
    bool hasDisabledRuntimeProperties = false;
#if ENABLE(WEBGL) && ENABLE(WEBXR)
    if (!jsCast<JSDOMGlobalObject*>(globalObject())->scriptExecutionContext()->settingsValues().webXREnabled) {
        hasDisabledRuntimeProperties = true;
        auto propertyName = Identifier::fromString(vm, "makeXRCompatible"_s);
        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);
        DeletePropertySlot slot;
        JSObject::deleteProperty(this, globalObject(), propertyName, slot);
    }
#endif
    if (hasDisabledRuntimeProperties && structure()->isDictionary())
        flattenDictionaryObject(vm);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

const ClassInfo JSWebGLRenderingContext::s_info = { "WebGLRenderingContext"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSWebGLRenderingContext) };

JSWebGLRenderingContext::JSWebGLRenderingContext(Structure* structure, JSDOMGlobalObject& globalObject, Ref<WebGLRenderingContext>&& impl)
    : JSDOMWrapper<WebGLRenderingContext>(structure, globalObject, WTFMove(impl))
{
}

static_assert(std::is_base_of<ActiveDOMObject, WebGLRenderingContext>::value, "Interface is marked as [ActiveDOMObject] but implementation class does not subclass ActiveDOMObject.");

JSObject* JSWebGLRenderingContext::createPrototype(VM& vm, JSDOMGlobalObject& globalObject)
{
    auto* structure = JSWebGLRenderingContextPrototype::createStructure(vm, &globalObject, globalObject.objectPrototype());
    structure->setMayBePrototype(true);
    return JSWebGLRenderingContextPrototype::create(vm, &globalObject, structure);
}

JSObject* JSWebGLRenderingContext::prototype(VM& vm, JSDOMGlobalObject& globalObject)
{
    return getDOMPrototype<JSWebGLRenderingContext>(vm, globalObject);
}

JSValue JSWebGLRenderingContext::getConstructor(VM& vm, const JSGlobalObject* globalObject)
{
    return getDOMConstructor<JSWebGLRenderingContextDOMConstructor, DOMConstructorID::WebGLRenderingContext>(vm, *jsCast<const JSDOMGlobalObject*>(globalObject));
}

void JSWebGLRenderingContext::destroy(JSC::JSCell* cell)
{
    JSWebGLRenderingContext* thisObject = static_cast<JSWebGLRenderingContext*>(cell);
    thisObject->JSWebGLRenderingContext::~JSWebGLRenderingContext();
}

JSC_DEFINE_CUSTOM_GETTER(jsWebGLRenderingContextConstructor, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* prototype = jsDynamicCast<JSWebGLRenderingContextPrototype*>(JSValue::decode(thisValue));
    if (!prototype) [[unlikely]]
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(JSWebGLRenderingContext::getConstructor(vm, prototype->globalObject()));
}

#if ENABLE(WEBGL)
static inline JSValue jsWebGLRenderingContext_canvasGetter(JSGlobalObject& lexicalGlobalObject, JSWebGLRenderingContext& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLUnion<IDLInterface<HTMLCanvasElement>>>(lexicalGlobalObject, *thisObject.globalObject(), throwScope, impl.canvas())));
}

JSC_DEFINE_CUSTOM_GETTER(jsWebGLRenderingContext_canvas, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSWebGLRenderingContext>::get<jsWebGLRenderingContext_canvasGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

#endif

#if ENABLE(WEBGL)
static inline JSValue jsWebGLRenderingContext_drawingBufferWidthGetter(JSGlobalObject& lexicalGlobalObject, JSWebGLRenderingContext& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLLong>(lexicalGlobalObject, throwScope, impl.drawingBufferWidth())));
}

JSC_DEFINE_CUSTOM_GETTER(jsWebGLRenderingContext_drawingBufferWidth, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSWebGLRenderingContext>::get<jsWebGLRenderingContext_drawingBufferWidthGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

#endif

#if ENABLE(WEBGL)
static inline JSValue jsWebGLRenderingContext_drawingBufferHeightGetter(JSGlobalObject& lexicalGlobalObject, JSWebGLRenderingContext& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLLong>(lexicalGlobalObject, throwScope, impl.drawingBufferHeight())));
}

JSC_DEFINE_CUSTOM_GETTER(jsWebGLRenderingContext_drawingBufferHeight, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSWebGLRenderingContext>::get<jsWebGLRenderingContext_drawingBufferHeightGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_activeTextureBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto textureConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (textureConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "activeTexture"_s, { InspectorCanvasCallTracer::processArgument(impl, textureConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.activeTexture(textureConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_activeTexture, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_activeTextureBody>(*lexicalGlobalObject, *callFrame, "activeTexture");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_attachShaderBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGLRenderingContext"_s, "attachShader"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto shaderConversionResult = convert<IDLInterface<WebGLShader>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "shader"_s, "WebGLRenderingContext"_s, "attachShader"_s, "WebGLShader"_s); });
    if (shaderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "attachShader"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, shaderConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.attachShader(*programConversionResult.releaseReturnValue(), *shaderConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_attachShader, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_attachShaderBody>(*lexicalGlobalObject, *callFrame, "attachShader");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_bindAttribLocationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGLRenderingContext"_s, "bindAttribLocation"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto nameConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument2.value());
    if (nameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "bindAttribLocation"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, nameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.bindAttribLocation(*programConversionResult.releaseReturnValue(), indexConversionResult.releaseReturnValue(), nameConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_bindAttribLocation, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_bindAttribLocationBody>(*lexicalGlobalObject, *callFrame, "bindAttribLocation");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_bindBufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto bufferConversionResult = convert<IDLNullable<IDLInterface<WebGLBuffer>>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "buffer"_s, "WebGLRenderingContext"_s, "bindBuffer"_s, "WebGLBuffer"_s); });
    if (bufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "bindBuffer"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, bufferConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.bindBuffer(targetConversionResult.releaseReturnValue(), bufferConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_bindBuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_bindBufferBody>(*lexicalGlobalObject, *callFrame, "bindBuffer");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_bindFramebufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto framebufferConversionResult = convert<IDLNullable<IDLInterface<WebGLFramebuffer>>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "framebuffer"_s, "WebGLRenderingContext"_s, "bindFramebuffer"_s, "WebGLFramebuffer"_s); });
    if (framebufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "bindFramebuffer"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, framebufferConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.bindFramebuffer(targetConversionResult.releaseReturnValue(), framebufferConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_bindFramebuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_bindFramebufferBody>(*lexicalGlobalObject, *callFrame, "bindFramebuffer");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_bindRenderbufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto renderbufferConversionResult = convert<IDLNullable<IDLInterface<WebGLRenderbuffer>>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "renderbuffer"_s, "WebGLRenderingContext"_s, "bindRenderbuffer"_s, "WebGLRenderbuffer"_s); });
    if (renderbufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "bindRenderbuffer"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, renderbufferConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.bindRenderbuffer(targetConversionResult.releaseReturnValue(), renderbufferConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_bindRenderbuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_bindRenderbufferBody>(*lexicalGlobalObject, *callFrame, "bindRenderbuffer");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_bindTextureBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto textureConversionResult = convert<IDLNullable<IDLInterface<WebGLTexture>>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "texture"_s, "WebGLRenderingContext"_s, "bindTexture"_s, "WebGLTexture"_s); });
    if (textureConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "bindTexture"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, textureConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.bindTexture(targetConversionResult.releaseReturnValue(), textureConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_bindTexture, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_bindTextureBody>(*lexicalGlobalObject, *callFrame, "bindTexture");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_blendColorBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto redConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument0.value());
    if (redConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto greenConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument1.value());
    if (greenConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto blueConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument2.value());
    if (blueConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto alphaConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument3.value());
    if (alphaConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "blendColor"_s, { InspectorCanvasCallTracer::processArgument(impl, redConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, greenConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, blueConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, alphaConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.blendColor(redConversionResult.releaseReturnValue(), greenConversionResult.releaseReturnValue(), blueConversionResult.releaseReturnValue(), alphaConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_blendColor, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_blendColorBody>(*lexicalGlobalObject, *callFrame, "blendColor");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_blendEquationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto modeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (modeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "blendEquation"_s, { InspectorCanvasCallTracer::processArgument(impl, modeConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.blendEquation(modeConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_blendEquation, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_blendEquationBody>(*lexicalGlobalObject, *callFrame, "blendEquation");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_blendEquationSeparateBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto modeRGBConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (modeRGBConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto modeAlphaConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (modeAlphaConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "blendEquationSeparate"_s, { InspectorCanvasCallTracer::processArgument(impl, modeRGBConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, modeAlphaConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.blendEquationSeparate(modeRGBConversionResult.releaseReturnValue(), modeAlphaConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_blendEquationSeparate, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_blendEquationSeparateBody>(*lexicalGlobalObject, *callFrame, "blendEquationSeparate");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_blendFuncBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto sfactorConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (sfactorConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto dfactorConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (dfactorConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "blendFunc"_s, { InspectorCanvasCallTracer::processArgument(impl, sfactorConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dfactorConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.blendFunc(sfactorConversionResult.releaseReturnValue(), dfactorConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_blendFunc, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_blendFuncBody>(*lexicalGlobalObject, *callFrame, "blendFunc");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_blendFuncSeparateBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto srcRGBConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (srcRGBConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto dstRGBConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (dstRGBConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto srcAlphaConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (srcAlphaConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto dstAlphaConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (dstAlphaConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "blendFuncSeparate"_s, { InspectorCanvasCallTracer::processArgument(impl, srcRGBConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dstRGBConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcAlphaConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dstAlphaConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.blendFuncSeparate(srcRGBConversionResult.releaseReturnValue(), dstRGBConversionResult.releaseReturnValue(), srcAlphaConversionResult.releaseReturnValue(), dstAlphaConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_blendFuncSeparate, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_blendFuncSeparateBody>(*lexicalGlobalObject, *callFrame, "blendFuncSeparate");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_bufferData1Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto dataConversionResult = convert<IDLNullable<IDLUnion<IDLAllowSharedAdaptor<IDLArrayBuffer>, IDLAllowSharedAdaptor<IDLArrayBufferView>>>>(*lexicalGlobalObject, argument1.value());
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto usageConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (usageConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "bufferData"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, usageConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.bufferData(targetConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue(), usageConversionResult.releaseReturnValue()); })));
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_bufferData2Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto sizeConversionResult = convert<IDLLongLong>(*lexicalGlobalObject, argument1.value());
    if (sizeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto usageConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (usageConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "bufferData"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, sizeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, usageConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.bufferData(targetConversionResult.releaseReturnValue(), sizeConversionResult.releaseReturnValue(), usageConversionResult.releaseReturnValue()); })));
}

#endif

#if ENABLE(WEBGL)

static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_bufferDataOverloadDispatcher(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    size_t argsCount = std::min<size_t>(3, callFrame->argumentCount());
    if (argsCount == 3) {
        JSValue distinguishingArg = callFrame->uncheckedArgument(1);
#if ENABLE(WEBGL)
        if (distinguishingArg.isUndefinedOrNull())
            RELEASE_AND_RETURN(throwScope, (jsWebGLRenderingContextPrototypeFunction_bufferData1Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
#if ENABLE(WEBGL)
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSArrayBuffer>())
            RELEASE_AND_RETURN(throwScope, (jsWebGLRenderingContextPrototypeFunction_bufferData1Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
#if ENABLE(WEBGL)
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSArrayBufferView>())
            RELEASE_AND_RETURN(throwScope, (jsWebGLRenderingContextPrototypeFunction_bufferData1Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
#if ENABLE(WEBGL)
        if (distinguishingArg.isNumber())
            RELEASE_AND_RETURN(throwScope, (jsWebGLRenderingContextPrototypeFunction_bufferData2Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
#if ENABLE(WEBGL)
        RELEASE_AND_RETURN(throwScope, (jsWebGLRenderingContextPrototypeFunction_bufferData2Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
    }
    return argsCount < 3 ? throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject)) : throwVMTypeError(lexicalGlobalObject, throwScope);
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_bufferData, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_bufferDataOverloadDispatcher>(*lexicalGlobalObject, *callFrame, "bufferData");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_bufferSubDataBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto offsetConversionResult = convert<IDLLongLong>(*lexicalGlobalObject, argument1.value());
    if (offsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto dataConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLArrayBuffer>, IDLAllowSharedAdaptor<IDLArrayBufferView>>>(*lexicalGlobalObject, argument2.value());
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "bufferSubData"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, offsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dataConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.bufferSubData(targetConversionResult.releaseReturnValue(), offsetConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_bufferSubData, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_bufferSubDataBody>(*lexicalGlobalObject, *callFrame, "bufferSubData");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_checkFramebufferStatusBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "checkFramebufferStatus"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.checkFramebufferStatus(targetConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_checkFramebufferStatus, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_checkFramebufferStatusBody>(*lexicalGlobalObject, *callFrame, "checkFramebufferStatus");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_clearBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto maskConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (maskConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "clear"_s, { InspectorCanvasCallTracer::processArgument(impl, maskConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.clear(maskConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_clear, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_clearBody>(*lexicalGlobalObject, *callFrame, "clear");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_clearColorBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto redConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument0.value());
    if (redConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto greenConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument1.value());
    if (greenConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto blueConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument2.value());
    if (blueConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto alphaConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument3.value());
    if (alphaConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "clearColor"_s, { InspectorCanvasCallTracer::processArgument(impl, redConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, greenConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, blueConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, alphaConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.clearColor(redConversionResult.releaseReturnValue(), greenConversionResult.releaseReturnValue(), blueConversionResult.releaseReturnValue(), alphaConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_clearColor, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_clearColorBody>(*lexicalGlobalObject, *callFrame, "clearColor");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_clearDepthBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto depthConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument0.value());
    if (depthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "clearDepth"_s, { InspectorCanvasCallTracer::processArgument(impl, depthConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.clearDepth(depthConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_clearDepth, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_clearDepthBody>(*lexicalGlobalObject, *callFrame, "clearDepth");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_clearStencilBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto sConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument0.value());
    if (sConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "clearStencil"_s, { InspectorCanvasCallTracer::processArgument(impl, sConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.clearStencil(sConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_clearStencil, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_clearStencilBody>(*lexicalGlobalObject, *callFrame, "clearStencil");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_colorMaskBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto redConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (redConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto greenConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (greenConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto blueConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument2.value());
    if (blueConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto alphaConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument3.value());
    if (alphaConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "colorMask"_s, { InspectorCanvasCallTracer::processArgument(impl, redConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, greenConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, blueConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, alphaConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.colorMask(redConversionResult.releaseReturnValue(), greenConversionResult.releaseReturnValue(), blueConversionResult.releaseReturnValue(), alphaConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_colorMask, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_colorMaskBody>(*lexicalGlobalObject, *callFrame, "colorMask");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_compileShaderBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto shaderConversionResult = convert<IDLInterface<WebGLShader>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "shader"_s, "WebGLRenderingContext"_s, "compileShader"_s, "WebGLShader"_s); });
    if (shaderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "compileShader"_s, { InspectorCanvasCallTracer::processArgument(impl, shaderConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.compileShader(*shaderConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_compileShader, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_compileShaderBody>(*lexicalGlobalObject, *callFrame, "compileShader");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_texImage2D1Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto internalformatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (internalformatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto borderConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (borderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument6.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument7.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument8 = callFrame->uncheckedArgument(8);
    auto pixelsConversionResult = convert<IDLNullable<IDLAllowSharedAdaptor<IDLArrayBufferView>>>(*lexicalGlobalObject, argument8.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 8, "pixels"_s, "WebGLRenderingContext"_s, "texImage2D"_s, "ArrayBufferView"_s); });
    if (pixelsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "texImage2D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, internalformatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, borderConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pixelsConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.texImage2D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), internalformatConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), borderConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), pixelsConversionResult.releaseReturnValue()); })));
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_texImage2D2Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto internalformatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (internalformatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument4.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto sourceConversionResult = convert<IDLUnion<IDLInterface<ImageBitmap>, IDLInterface<ImageData>, IDLInterface<HTMLImageElement>, IDLInterface<HTMLCanvasElement>, IDLInterface<HTMLVideoElement>>>(*lexicalGlobalObject, argument5.value());
    if (sourceConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "texImage2D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, internalformatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, sourceConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.texImage2D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), internalformatConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), sourceConversionResult.releaseReturnValue()); })));
}

#endif

#if ENABLE(WEBGL)

static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_texImage2DOverloadDispatcher(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    size_t argsCount = std::min<size_t>(9, callFrame->argumentCount());
    if (argsCount == 6) {
#if ENABLE(WEBGL)
        RELEASE_AND_RETURN(throwScope, (jsWebGLRenderingContextPrototypeFunction_texImage2D2Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
    }
    if (argsCount == 9) {
#if ENABLE(WEBGL)
        RELEASE_AND_RETURN(throwScope, (jsWebGLRenderingContextPrototypeFunction_texImage2D1Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
    }
    return argsCount < 6 ? throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject)) : throwVMTypeError(lexicalGlobalObject, throwScope);
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_texImage2D, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_texImage2DOverloadDispatcher>(*lexicalGlobalObject, *callFrame, "texImage2D");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_texSubImage2D1Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto xoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (xoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto yoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (yoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument6.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument7.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument8 = callFrame->uncheckedArgument(8);
    auto pixelsConversionResult = convert<IDLNullable<IDLAllowSharedAdaptor<IDLArrayBufferView>>>(*lexicalGlobalObject, argument8.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 8, "pixels"_s, "WebGLRenderingContext"_s, "texSubImage2D"_s, "ArrayBufferView"_s); });
    if (pixelsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "texSubImage2D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pixelsConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.texSubImage2D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), xoffsetConversionResult.releaseReturnValue(), yoffsetConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), pixelsConversionResult.releaseReturnValue()); })));
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_texSubImage2D2Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto xoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (xoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto yoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (yoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument4.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument5.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto sourceConversionResult = convert<IDLUnion<IDLInterface<ImageBitmap>, IDLInterface<ImageData>, IDLInterface<HTMLImageElement>, IDLInterface<HTMLCanvasElement>, IDLInterface<HTMLVideoElement>>>(*lexicalGlobalObject, argument6.value());
    if (sourceConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "texSubImage2D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, sourceConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.texSubImage2D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), xoffsetConversionResult.releaseReturnValue(), yoffsetConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), sourceConversionResult.releaseReturnValue()); })));
}

#endif

#if ENABLE(WEBGL)

static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_texSubImage2DOverloadDispatcher(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    size_t argsCount = std::min<size_t>(9, callFrame->argumentCount());
    if (argsCount == 7) {
#if ENABLE(WEBGL)
        RELEASE_AND_RETURN(throwScope, (jsWebGLRenderingContextPrototypeFunction_texSubImage2D2Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
    }
    if (argsCount == 9) {
#if ENABLE(WEBGL)
        RELEASE_AND_RETURN(throwScope, (jsWebGLRenderingContextPrototypeFunction_texSubImage2D1Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
    }
    return argsCount < 7 ? throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject)) : throwVMTypeError(lexicalGlobalObject, throwScope);
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_texSubImage2D, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_texSubImage2DOverloadDispatcher>(*lexicalGlobalObject, *callFrame, "texSubImage2D");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_compressedTexImage2DBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 7) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto internalformatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (internalformatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto borderConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (borderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto dataConversionResult = convert<IDLAllowSharedAdaptor<IDLArrayBufferView>>(*lexicalGlobalObject, argument6.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 6, "data"_s, "WebGLRenderingContext"_s, "compressedTexImage2D"_s, "ArrayBufferView"_s); });
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "compressedTexImage2D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, internalformatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, borderConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dataConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.compressedTexImage2D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), internalformatConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), borderConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_compressedTexImage2D, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_compressedTexImage2DBody>(*lexicalGlobalObject, *callFrame, "compressedTexImage2D");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_compressedTexSubImage2DBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 8) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto xoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (xoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto yoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (yoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument6.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto dataConversionResult = convert<IDLAllowSharedAdaptor<IDLArrayBufferView>>(*lexicalGlobalObject, argument7.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 7, "data"_s, "WebGLRenderingContext"_s, "compressedTexSubImage2D"_s, "ArrayBufferView"_s); });
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "compressedTexSubImage2D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dataConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.compressedTexSubImage2D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), xoffsetConversionResult.releaseReturnValue(), yoffsetConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_compressedTexSubImage2D, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_compressedTexSubImage2DBody>(*lexicalGlobalObject, *callFrame, "compressedTexSubImage2D");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_copyTexImage2DBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 8) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto internalformatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (internalformatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto xConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto yConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument6.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto borderConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument7.value());
    if (borderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "copyTexImage2D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, internalformatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, borderConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.copyTexImage2D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), internalformatConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), borderConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_copyTexImage2D, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_copyTexImage2DBody>(*lexicalGlobalObject, *callFrame, "copyTexImage2D");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_copyTexSubImage2DBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 8) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto xoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (xoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto yoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (yoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto xConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto yConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument6.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument7.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "copyTexSubImage2D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.copyTexSubImage2D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), xoffsetConversionResult.releaseReturnValue(), yoffsetConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_copyTexSubImage2D, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_copyTexSubImage2DBody>(*lexicalGlobalObject, *callFrame, "copyTexSubImage2D");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_createBufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "createBuffer"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<WebGLBuffer>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.createBuffer())));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_createBuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_createBufferBody>(*lexicalGlobalObject, *callFrame, "createBuffer");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_createFramebufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "createFramebuffer"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<WebGLFramebuffer>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.createFramebuffer())));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_createFramebuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_createFramebufferBody>(*lexicalGlobalObject, *callFrame, "createFramebuffer");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_createProgramBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "createProgram"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.createProgram())));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_createProgram, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_createProgramBody>(*lexicalGlobalObject, *callFrame, "createProgram");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_createRenderbufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "createRenderbuffer"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<WebGLRenderbuffer>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.createRenderbuffer())));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_createRenderbuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_createRenderbufferBody>(*lexicalGlobalObject, *callFrame, "createRenderbuffer");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_createShaderBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "createShader"_s, { InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<WebGLShader>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.createShader(typeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_createShader, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_createShaderBody>(*lexicalGlobalObject, *callFrame, "createShader");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_createTextureBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "createTexture"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<WebGLTexture>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.createTexture())));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_createTexture, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_createTextureBody>(*lexicalGlobalObject, *callFrame, "createTexture");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_cullFaceBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto modeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (modeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "cullFace"_s, { InspectorCanvasCallTracer::processArgument(impl, modeConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.cullFace(modeConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_cullFace, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_cullFaceBody>(*lexicalGlobalObject, *callFrame, "cullFace");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_deleteBufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto bufferConversionResult = convert<IDLNullable<IDLInterface<WebGLBuffer>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "buffer"_s, "WebGLRenderingContext"_s, "deleteBuffer"_s, "WebGLBuffer"_s); });
    if (bufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "deleteBuffer"_s, { InspectorCanvasCallTracer::processArgument(impl, bufferConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.deleteBuffer(bufferConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_deleteBuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_deleteBufferBody>(*lexicalGlobalObject, *callFrame, "deleteBuffer");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_deleteFramebufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto framebufferConversionResult = convert<IDLNullable<IDLInterface<WebGLFramebuffer>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "framebuffer"_s, "WebGLRenderingContext"_s, "deleteFramebuffer"_s, "WebGLFramebuffer"_s); });
    if (framebufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "deleteFramebuffer"_s, { InspectorCanvasCallTracer::processArgument(impl, framebufferConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.deleteFramebuffer(framebufferConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_deleteFramebuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_deleteFramebufferBody>(*lexicalGlobalObject, *callFrame, "deleteFramebuffer");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_deleteProgramBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGLRenderingContext"_s, "deleteProgram"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "deleteProgram"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.deleteProgram(programConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_deleteProgram, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_deleteProgramBody>(*lexicalGlobalObject, *callFrame, "deleteProgram");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_deleteRenderbufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto renderbufferConversionResult = convert<IDLNullable<IDLInterface<WebGLRenderbuffer>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "renderbuffer"_s, "WebGLRenderingContext"_s, "deleteRenderbuffer"_s, "WebGLRenderbuffer"_s); });
    if (renderbufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "deleteRenderbuffer"_s, { InspectorCanvasCallTracer::processArgument(impl, renderbufferConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.deleteRenderbuffer(renderbufferConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_deleteRenderbuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_deleteRenderbufferBody>(*lexicalGlobalObject, *callFrame, "deleteRenderbuffer");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_deleteShaderBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto shaderConversionResult = convert<IDLNullable<IDLInterface<WebGLShader>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "shader"_s, "WebGLRenderingContext"_s, "deleteShader"_s, "WebGLShader"_s); });
    if (shaderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "deleteShader"_s, { InspectorCanvasCallTracer::processArgument(impl, shaderConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.deleteShader(shaderConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_deleteShader, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_deleteShaderBody>(*lexicalGlobalObject, *callFrame, "deleteShader");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_deleteTextureBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto textureConversionResult = convert<IDLNullable<IDLInterface<WebGLTexture>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "texture"_s, "WebGLRenderingContext"_s, "deleteTexture"_s, "WebGLTexture"_s); });
    if (textureConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "deleteTexture"_s, { InspectorCanvasCallTracer::processArgument(impl, textureConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.deleteTexture(textureConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_deleteTexture, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_deleteTextureBody>(*lexicalGlobalObject, *callFrame, "deleteTexture");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_depthFuncBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto funcConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (funcConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "depthFunc"_s, { InspectorCanvasCallTracer::processArgument(impl, funcConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.depthFunc(funcConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_depthFunc, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_depthFuncBody>(*lexicalGlobalObject, *callFrame, "depthFunc");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_depthMaskBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto flagConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (flagConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "depthMask"_s, { InspectorCanvasCallTracer::processArgument(impl, flagConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.depthMask(flagConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_depthMask, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_depthMaskBody>(*lexicalGlobalObject, *callFrame, "depthMask");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_depthRangeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto zNearConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument0.value());
    if (zNearConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto zFarConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument1.value());
    if (zFarConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "depthRange"_s, { InspectorCanvasCallTracer::processArgument(impl, zNearConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, zFarConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.depthRange(zNearConversionResult.releaseReturnValue(), zFarConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_depthRange, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_depthRangeBody>(*lexicalGlobalObject, *callFrame, "depthRange");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_detachShaderBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGLRenderingContext"_s, "detachShader"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto shaderConversionResult = convert<IDLInterface<WebGLShader>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "shader"_s, "WebGLRenderingContext"_s, "detachShader"_s, "WebGLShader"_s); });
    if (shaderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "detachShader"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, shaderConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.detachShader(*programConversionResult.releaseReturnValue(), *shaderConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_detachShader, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_detachShaderBody>(*lexicalGlobalObject, *callFrame, "detachShader");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_disableBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto capConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (capConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "disable"_s, { InspectorCanvasCallTracer::processArgument(impl, capConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.disable(capConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_disable, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_disableBody>(*lexicalGlobalObject, *callFrame, "disable");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_disableVertexAttribArrayBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "disableVertexAttribArray"_s, { InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.disableVertexAttribArray(indexConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_disableVertexAttribArray, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_disableVertexAttribArrayBody>(*lexicalGlobalObject, *callFrame, "disableVertexAttribArray");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_drawArraysBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto modeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (modeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto firstConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (firstConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto countConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (countConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "drawArrays"_s, { InspectorCanvasCallTracer::processArgument(impl, modeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, firstConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, countConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.drawArrays(modeConversionResult.releaseReturnValue(), firstConversionResult.releaseReturnValue(), countConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_drawArrays, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_drawArraysBody>(*lexicalGlobalObject, *callFrame, "drawArrays");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_drawElementsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto modeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (modeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto countConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (countConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto offsetConversionResult = convert<IDLLongLong>(*lexicalGlobalObject, argument3.value());
    if (offsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "drawElements"_s, { InspectorCanvasCallTracer::processArgument(impl, modeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, countConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, offsetConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.drawElements(modeConversionResult.releaseReturnValue(), countConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), offsetConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_drawElements, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_drawElementsBody>(*lexicalGlobalObject, *callFrame, "drawElements");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_enableBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto capConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (capConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "enable"_s, { InspectorCanvasCallTracer::processArgument(impl, capConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.enable(capConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_enable, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_enableBody>(*lexicalGlobalObject, *callFrame, "enable");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_enableVertexAttribArrayBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "enableVertexAttribArray"_s, { InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.enableVertexAttribArray(indexConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_enableVertexAttribArray, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_enableVertexAttribArrayBody>(*lexicalGlobalObject, *callFrame, "enableVertexAttribArray");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_finishBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "finish"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.finish(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_finish, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_finishBody>(*lexicalGlobalObject, *callFrame, "finish");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_flushBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "flush"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.flush(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_flush, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_flushBody>(*lexicalGlobalObject, *callFrame, "flush");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_framebufferRenderbufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto attachmentConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (attachmentConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto renderbuffertargetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (renderbuffertargetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto renderbufferConversionResult = convert<IDLNullable<IDLInterface<WebGLRenderbuffer>>>(*lexicalGlobalObject, argument3.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 3, "renderbuffer"_s, "WebGLRenderingContext"_s, "framebufferRenderbuffer"_s, "WebGLRenderbuffer"_s); });
    if (renderbufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "framebufferRenderbuffer"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, attachmentConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, renderbuffertargetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, renderbufferConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.framebufferRenderbuffer(targetConversionResult.releaseReturnValue(), attachmentConversionResult.releaseReturnValue(), renderbuffertargetConversionResult.releaseReturnValue(), renderbufferConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_framebufferRenderbuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_framebufferRenderbufferBody>(*lexicalGlobalObject, *callFrame, "framebufferRenderbuffer");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_framebufferTexture2DBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 5) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto attachmentConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (attachmentConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto textargetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (textargetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto textureConversionResult = convert<IDLNullable<IDLInterface<WebGLTexture>>>(*lexicalGlobalObject, argument3.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 3, "texture"_s, "WebGLRenderingContext"_s, "framebufferTexture2D"_s, "WebGLTexture"_s); });
    if (textureConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "framebufferTexture2D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, attachmentConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, textargetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, textureConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.framebufferTexture2D(targetConversionResult.releaseReturnValue(), attachmentConversionResult.releaseReturnValue(), textargetConversionResult.releaseReturnValue(), textureConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_framebufferTexture2D, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_framebufferTexture2DBody>(*lexicalGlobalObject, *callFrame, "framebufferTexture2D");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_frontFaceBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto modeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (modeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "frontFace"_s, { InspectorCanvasCallTracer::processArgument(impl, modeConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.frontFace(modeConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_frontFace, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_frontFaceBody>(*lexicalGlobalObject, *callFrame, "frontFace");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_generateMipmapBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "generateMipmap"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.generateMipmap(targetConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_generateMipmap, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_generateMipmapBody>(*lexicalGlobalObject, *callFrame, "generateMipmap");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_getActiveAttribBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGLRenderingContext"_s, "getActiveAttrib"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getActiveAttrib"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<WebGLActiveInfo>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getActiveAttrib(*programConversionResult.releaseReturnValue(), indexConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getActiveAttrib, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_getActiveAttribBody>(*lexicalGlobalObject, *callFrame, "getActiveAttrib");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_getActiveUniformBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGLRenderingContext"_s, "getActiveUniform"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getActiveUniform"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<WebGLActiveInfo>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getActiveUniform(*programConversionResult.releaseReturnValue(), indexConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getActiveUniform, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_getActiveUniformBody>(*lexicalGlobalObject, *callFrame, "getActiveUniform");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_getAttachedShadersBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGLRenderingContext"_s, "getAttachedShaders"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getAttachedShaders"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLSequence<IDLInterface<WebGLShader>>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getAttachedShaders(*programConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getAttachedShaders, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_getAttachedShadersBody>(*lexicalGlobalObject, *callFrame, "getAttachedShaders");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_getAttribLocationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGLRenderingContext"_s, "getAttribLocation"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto nameConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (nameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getAttribLocation"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, nameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLLong>(*lexicalGlobalObject, throwScope, impl.getAttribLocation(*programConversionResult.releaseReturnValue(), nameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getAttribLocation, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_getAttribLocationBody>(*lexicalGlobalObject, *callFrame, "getAttribLocation");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_getBufferParameterBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getBufferParameter"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLWebGLAny>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getBufferParameter(targetConversionResult.releaseReturnValue(), pnameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getBufferParameter, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_getBufferParameterBody>(*lexicalGlobalObject, *callFrame, "getBufferParameter");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_getContextAttributesBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getContextAttributes"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLDictionary<WebGLContextAttributes>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getContextAttributes())));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getContextAttributes, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_getContextAttributesBody>(*lexicalGlobalObject, *callFrame, "getContextAttributes");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_getErrorBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getError"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.getError())));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getError, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_getErrorBody>(*lexicalGlobalObject, *callFrame, "getError");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_getSupportedExtensionsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getSupportedExtensions"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLSequence<IDLDOMString>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getSupportedExtensions())));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getSupportedExtensions, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_getSupportedExtensionsBody>(*lexicalGlobalObject, *callFrame, "getSupportedExtensions");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_getExtensionBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto nameConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (nameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getExtension"_s, { InspectorCanvasCallTracer::processArgument(impl, nameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLWebGLExtensionAny>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getExtension(nameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getExtension, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_getExtensionBody>(*lexicalGlobalObject, *callFrame, "getExtension");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_getFramebufferAttachmentParameterBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto attachmentConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (attachmentConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getFramebufferAttachmentParameter"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, attachmentConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLWebGLAny>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getFramebufferAttachmentParameter(targetConversionResult.releaseReturnValue(), attachmentConversionResult.releaseReturnValue(), pnameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getFramebufferAttachmentParameter, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_getFramebufferAttachmentParameterBody>(*lexicalGlobalObject, *callFrame, "getFramebufferAttachmentParameter");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_getParameterBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getParameter"_s, { InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLWebGLAny>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getParameter(pnameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getParameter, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_getParameterBody>(*lexicalGlobalObject, *callFrame, "getParameter");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_getProgramParameterBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGLRenderingContext"_s, "getProgramParameter"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getProgramParameter"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLWebGLAny>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getProgramParameter(*programConversionResult.releaseReturnValue(), pnameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getProgramParameter, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_getProgramParameterBody>(*lexicalGlobalObject, *callFrame, "getProgramParameter");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_getProgramInfoLogBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGLRenderingContext"_s, "getProgramInfoLog"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getProgramInfoLog"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLDOMString>>(*lexicalGlobalObject, throwScope, impl.getProgramInfoLog(*programConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getProgramInfoLog, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_getProgramInfoLogBody>(*lexicalGlobalObject, *callFrame, "getProgramInfoLog");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_getRenderbufferParameterBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getRenderbufferParameter"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLWebGLAny>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getRenderbufferParameter(targetConversionResult.releaseReturnValue(), pnameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getRenderbufferParameter, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_getRenderbufferParameterBody>(*lexicalGlobalObject, *callFrame, "getRenderbufferParameter");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_getShaderParameterBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto shaderConversionResult = convert<IDLInterface<WebGLShader>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "shader"_s, "WebGLRenderingContext"_s, "getShaderParameter"_s, "WebGLShader"_s); });
    if (shaderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getShaderParameter"_s, { InspectorCanvasCallTracer::processArgument(impl, shaderConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLWebGLAny>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getShaderParameter(*shaderConversionResult.releaseReturnValue(), pnameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getShaderParameter, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_getShaderParameterBody>(*lexicalGlobalObject, *callFrame, "getShaderParameter");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_getShaderInfoLogBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto shaderConversionResult = convert<IDLInterface<WebGLShader>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "shader"_s, "WebGLRenderingContext"_s, "getShaderInfoLog"_s, "WebGLShader"_s); });
    if (shaderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getShaderInfoLog"_s, { InspectorCanvasCallTracer::processArgument(impl, shaderConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLDOMString>>(*lexicalGlobalObject, throwScope, impl.getShaderInfoLog(*shaderConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getShaderInfoLog, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_getShaderInfoLogBody>(*lexicalGlobalObject, *callFrame, "getShaderInfoLog");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_getShaderPrecisionFormatBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto shadertypeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (shadertypeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto precisiontypeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (precisiontypeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getShaderPrecisionFormat"_s, { InspectorCanvasCallTracer::processArgument(impl, shadertypeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, precisiontypeConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<WebGLShaderPrecisionFormat>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getShaderPrecisionFormat(shadertypeConversionResult.releaseReturnValue(), precisiontypeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getShaderPrecisionFormat, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_getShaderPrecisionFormatBody>(*lexicalGlobalObject, *callFrame, "getShaderPrecisionFormat");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_getShaderSourceBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto shaderConversionResult = convert<IDLInterface<WebGLShader>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "shader"_s, "WebGLRenderingContext"_s, "getShaderSource"_s, "WebGLShader"_s); });
    if (shaderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getShaderSource"_s, { InspectorCanvasCallTracer::processArgument(impl, shaderConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLDOMString>>(*lexicalGlobalObject, throwScope, impl.getShaderSource(*shaderConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getShaderSource, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_getShaderSourceBody>(*lexicalGlobalObject, *callFrame, "getShaderSource");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_getTexParameterBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getTexParameter"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLWebGLAny>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getTexParameter(targetConversionResult.releaseReturnValue(), pnameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getTexParameter, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_getTexParameterBody>(*lexicalGlobalObject, *callFrame, "getTexParameter");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_getUniformBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGLRenderingContext"_s, "getUniform"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto locationConversionResult = convert<IDLInterface<WebGLUniformLocation>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "location"_s, "WebGLRenderingContext"_s, "getUniform"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getUniform"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLWebGLAny>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getUniform(*programConversionResult.releaseReturnValue(), *locationConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getUniform, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_getUniformBody>(*lexicalGlobalObject, *callFrame, "getUniform");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_getUniformLocationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGLRenderingContext"_s, "getUniformLocation"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto nameConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (nameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getUniformLocation"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, nameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<WebGLUniformLocation>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getUniformLocation(*programConversionResult.releaseReturnValue(), nameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getUniformLocation, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_getUniformLocationBody>(*lexicalGlobalObject, *callFrame, "getUniformLocation");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_getVertexAttribBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getVertexAttrib"_s, { InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLWebGLAny>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getVertexAttrib(indexConversionResult.releaseReturnValue(), pnameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getVertexAttrib, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_getVertexAttribBody>(*lexicalGlobalObject, *callFrame, "getVertexAttrib");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_getVertexAttribOffsetBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getVertexAttribOffset"_s, { InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLLongLong>(*lexicalGlobalObject, throwScope, impl.getVertexAttribOffset(indexConversionResult.releaseReturnValue(), pnameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_getVertexAttribOffset, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_getVertexAttribOffsetBody>(*lexicalGlobalObject, *callFrame, "getVertexAttribOffset");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_hintBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto modeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (modeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "hint"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, modeConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.hint(targetConversionResult.releaseReturnValue(), modeConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_hint, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_hintBody>(*lexicalGlobalObject, *callFrame, "hint");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_isBufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto bufferConversionResult = convert<IDLNullable<IDLInterface<WebGLBuffer>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "buffer"_s, "WebGLRenderingContext"_s, "isBuffer"_s, "WebGLBuffer"_s); });
    if (bufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "isBuffer"_s, { InspectorCanvasCallTracer::processArgument(impl, bufferConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isBuffer(bufferConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_isBuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_isBufferBody>(*lexicalGlobalObject, *callFrame, "isBuffer");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_isContextLostBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "isContextLost"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isContextLost())));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_isContextLost, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_isContextLostBody>(*lexicalGlobalObject, *callFrame, "isContextLost");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_isEnabledBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto capConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (capConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "isEnabled"_s, { InspectorCanvasCallTracer::processArgument(impl, capConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isEnabled(capConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_isEnabled, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_isEnabledBody>(*lexicalGlobalObject, *callFrame, "isEnabled");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_isFramebufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto framebufferConversionResult = convert<IDLNullable<IDLInterface<WebGLFramebuffer>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "framebuffer"_s, "WebGLRenderingContext"_s, "isFramebuffer"_s, "WebGLFramebuffer"_s); });
    if (framebufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "isFramebuffer"_s, { InspectorCanvasCallTracer::processArgument(impl, framebufferConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isFramebuffer(framebufferConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_isFramebuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_isFramebufferBody>(*lexicalGlobalObject, *callFrame, "isFramebuffer");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_isProgramBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGLRenderingContext"_s, "isProgram"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "isProgram"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isProgram(programConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_isProgram, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_isProgramBody>(*lexicalGlobalObject, *callFrame, "isProgram");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_isRenderbufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto renderbufferConversionResult = convert<IDLNullable<IDLInterface<WebGLRenderbuffer>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "renderbuffer"_s, "WebGLRenderingContext"_s, "isRenderbuffer"_s, "WebGLRenderbuffer"_s); });
    if (renderbufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "isRenderbuffer"_s, { InspectorCanvasCallTracer::processArgument(impl, renderbufferConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isRenderbuffer(renderbufferConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_isRenderbuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_isRenderbufferBody>(*lexicalGlobalObject, *callFrame, "isRenderbuffer");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_isShaderBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto shaderConversionResult = convert<IDLNullable<IDLInterface<WebGLShader>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "shader"_s, "WebGLRenderingContext"_s, "isShader"_s, "WebGLShader"_s); });
    if (shaderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "isShader"_s, { InspectorCanvasCallTracer::processArgument(impl, shaderConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isShader(shaderConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_isShader, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_isShaderBody>(*lexicalGlobalObject, *callFrame, "isShader");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_isTextureBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto textureConversionResult = convert<IDLNullable<IDLInterface<WebGLTexture>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "texture"_s, "WebGLRenderingContext"_s, "isTexture"_s, "WebGLTexture"_s); });
    if (textureConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "isTexture"_s, { InspectorCanvasCallTracer::processArgument(impl, textureConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isTexture(textureConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_isTexture, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_isTextureBody>(*lexicalGlobalObject, *callFrame, "isTexture");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_lineWidthBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto widthConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument0.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "lineWidth"_s, { InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.lineWidth(widthConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_lineWidth, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_lineWidthBody>(*lexicalGlobalObject, *callFrame, "lineWidth");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_linkProgramBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGLRenderingContext"_s, "linkProgram"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "linkProgram"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.linkProgram(*programConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_linkProgram, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_linkProgramBody>(*lexicalGlobalObject, *callFrame, "linkProgram");
}

#endif

#if ENABLE(WEBGL) && ENABLE(WEBXR)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_makeXRCompatibleBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperationReturningPromise<JSWebGLRenderingContext>::ClassParameter castedThis, Ref<DeferredPromise>&& promise)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "makeXRCompatible"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJSNewlyCreated<IDLPromise<IDLUndefined>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, [&]() -> decltype(auto) { return impl.makeXRCompatible(WTFMove(promise)); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_makeXRCompatible, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperationReturningPromise<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_makeXRCompatibleBody>(*lexicalGlobalObject, *callFrame, "makeXRCompatible");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_pixelStoreiBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto paramConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (paramConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "pixelStorei"_s, { InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, paramConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.pixelStorei(pnameConversionResult.releaseReturnValue(), paramConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_pixelStorei, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_pixelStoreiBody>(*lexicalGlobalObject, *callFrame, "pixelStorei");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_polygonOffsetBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto factorConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument0.value());
    if (factorConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto unitsConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument1.value());
    if (unitsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "polygonOffset"_s, { InspectorCanvasCallTracer::processArgument(impl, factorConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, unitsConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.polygonOffset(factorConversionResult.releaseReturnValue(), unitsConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_polygonOffset, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_polygonOffsetBody>(*lexicalGlobalObject, *callFrame, "polygonOffset");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_readPixelsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 7) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto xConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument0.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto yConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument4.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument5.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto pixelsConversionResult = convert<IDLNullable<IDLAllowSharedAdaptor<IDLArrayBufferView>>>(*lexicalGlobalObject, argument6.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 6, "pixels"_s, "WebGLRenderingContext"_s, "readPixels"_s, "ArrayBufferView"_s); });
    if (pixelsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "readPixels"_s, { InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pixelsConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.readPixels(xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), pixelsConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_readPixels, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_readPixelsBody>(*lexicalGlobalObject, *callFrame, "readPixels");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_renderbufferStorageBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto internalformatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (internalformatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "renderbufferStorage"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, internalformatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.renderbufferStorage(targetConversionResult.releaseReturnValue(), internalformatConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_renderbufferStorage, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_renderbufferStorageBody>(*lexicalGlobalObject, *callFrame, "renderbufferStorage");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_sampleCoverageBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto valueConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument0.value());
    if (valueConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto invertConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (invertConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "sampleCoverage"_s, { InspectorCanvasCallTracer::processArgument(impl, valueConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, invertConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.sampleCoverage(valueConversionResult.releaseReturnValue(), invertConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_sampleCoverage, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_sampleCoverageBody>(*lexicalGlobalObject, *callFrame, "sampleCoverage");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_scissorBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto xConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument0.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto yConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "scissor"_s, { InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.scissor(xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_scissor, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_scissorBody>(*lexicalGlobalObject, *callFrame, "scissor");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_shaderSourceBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto shaderConversionResult = convert<IDLInterface<WebGLShader>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "shader"_s, "WebGLRenderingContext"_s, "shaderSource"_s, "WebGLShader"_s); });
    if (shaderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto stringConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (stringConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "shaderSource"_s, { InspectorCanvasCallTracer::processArgument(impl, shaderConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, stringConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.shaderSource(*shaderConversionResult.releaseReturnValue(), stringConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_shaderSource, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_shaderSourceBody>(*lexicalGlobalObject, *callFrame, "shaderSource");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_stencilFuncBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto funcConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (funcConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto refConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (refConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto maskConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (maskConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "stencilFunc"_s, { InspectorCanvasCallTracer::processArgument(impl, funcConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, refConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, maskConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.stencilFunc(funcConversionResult.releaseReturnValue(), refConversionResult.releaseReturnValue(), maskConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_stencilFunc, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_stencilFuncBody>(*lexicalGlobalObject, *callFrame, "stencilFunc");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_stencilFuncSeparateBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto faceConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (faceConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto funcConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (funcConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto refConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (refConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto maskConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (maskConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "stencilFuncSeparate"_s, { InspectorCanvasCallTracer::processArgument(impl, faceConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, funcConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, refConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, maskConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.stencilFuncSeparate(faceConversionResult.releaseReturnValue(), funcConversionResult.releaseReturnValue(), refConversionResult.releaseReturnValue(), maskConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_stencilFuncSeparate, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_stencilFuncSeparateBody>(*lexicalGlobalObject, *callFrame, "stencilFuncSeparate");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_stencilMaskBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto maskConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (maskConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "stencilMask"_s, { InspectorCanvasCallTracer::processArgument(impl, maskConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.stencilMask(maskConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_stencilMask, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_stencilMaskBody>(*lexicalGlobalObject, *callFrame, "stencilMask");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_stencilMaskSeparateBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto faceConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (faceConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto maskConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (maskConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "stencilMaskSeparate"_s, { InspectorCanvasCallTracer::processArgument(impl, faceConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, maskConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.stencilMaskSeparate(faceConversionResult.releaseReturnValue(), maskConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_stencilMaskSeparate, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_stencilMaskSeparateBody>(*lexicalGlobalObject, *callFrame, "stencilMaskSeparate");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_stencilOpBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto failConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (failConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto zfailConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (zfailConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto zpassConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (zpassConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "stencilOp"_s, { InspectorCanvasCallTracer::processArgument(impl, failConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, zfailConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, zpassConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.stencilOp(failConversionResult.releaseReturnValue(), zfailConversionResult.releaseReturnValue(), zpassConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_stencilOp, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_stencilOpBody>(*lexicalGlobalObject, *callFrame, "stencilOp");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_stencilOpSeparateBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto faceConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (faceConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto failConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (failConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto zfailConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (zfailConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto zpassConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (zpassConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "stencilOpSeparate"_s, { InspectorCanvasCallTracer::processArgument(impl, faceConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, failConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, zfailConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, zpassConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.stencilOpSeparate(faceConversionResult.releaseReturnValue(), failConversionResult.releaseReturnValue(), zfailConversionResult.releaseReturnValue(), zpassConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_stencilOpSeparate, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_stencilOpSeparateBody>(*lexicalGlobalObject, *callFrame, "stencilOpSeparate");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_texParameterfBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto paramConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument2.value());
    if (paramConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "texParameterf"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, paramConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.texParameterf(targetConversionResult.releaseReturnValue(), pnameConversionResult.releaseReturnValue(), paramConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_texParameterf, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_texParameterfBody>(*lexicalGlobalObject, *callFrame, "texParameterf");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_texParameteriBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto paramConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (paramConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "texParameteri"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, paramConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.texParameteri(targetConversionResult.releaseReturnValue(), pnameConversionResult.releaseReturnValue(), paramConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_texParameteri, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_texParameteriBody>(*lexicalGlobalObject, *callFrame, "texParameteri");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_uniform1fBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGLRenderingContext"_s, "uniform1f"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto xConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument1.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform1f"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform1f(locationConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform1f, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_uniform1fBody>(*lexicalGlobalObject, *callFrame, "uniform1f");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_uniform2fBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGLRenderingContext"_s, "uniform2f"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto xConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument1.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto yConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument2.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform2f"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform2f(locationConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform2f, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_uniform2fBody>(*lexicalGlobalObject, *callFrame, "uniform2f");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_uniform3fBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGLRenderingContext"_s, "uniform3f"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto xConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument1.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto yConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument2.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto zConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument3.value());
    if (zConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform3f"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, zConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform3f(locationConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), zConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform3f, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_uniform3fBody>(*lexicalGlobalObject, *callFrame, "uniform3f");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_uniform4fBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 5) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGLRenderingContext"_s, "uniform4f"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto xConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument1.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto yConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument2.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto zConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument3.value());
    if (zConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto wConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument4.value());
    if (wConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform4f"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, zConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, wConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform4f(locationConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), zConversionResult.releaseReturnValue(), wConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform4f, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_uniform4fBody>(*lexicalGlobalObject, *callFrame, "uniform4f");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_uniform1iBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGLRenderingContext"_s, "uniform1i"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto xConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform1i"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform1i(locationConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform1i, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_uniform1iBody>(*lexicalGlobalObject, *callFrame, "uniform1i");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_uniform2iBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGLRenderingContext"_s, "uniform2i"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto xConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto yConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform2i"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform2i(locationConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform2i, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_uniform2iBody>(*lexicalGlobalObject, *callFrame, "uniform2i");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_uniform3iBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGLRenderingContext"_s, "uniform3i"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto xConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto yConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto zConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (zConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform3i"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, zConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform3i(locationConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), zConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform3i, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_uniform3iBody>(*lexicalGlobalObject, *callFrame, "uniform3i");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_uniform4iBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 5) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGLRenderingContext"_s, "uniform4i"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto xConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto yConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto zConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (zConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto wConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (wConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform4i"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, zConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, wConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform4i(locationConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), zConversionResult.releaseReturnValue(), wConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform4i, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_uniform4iBody>(*lexicalGlobalObject, *callFrame, "uniform4i");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_uniform1fvBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGLRenderingContext"_s, "uniform1fv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto vConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument1.value());
    if (vConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform1fv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, vConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform1fv(locationConversionResult.releaseReturnValue(), vConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform1fv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_uniform1fvBody>(*lexicalGlobalObject, *callFrame, "uniform1fv");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_uniform2fvBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGLRenderingContext"_s, "uniform2fv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto vConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument1.value());
    if (vConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform2fv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, vConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform2fv(locationConversionResult.releaseReturnValue(), vConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform2fv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_uniform2fvBody>(*lexicalGlobalObject, *callFrame, "uniform2fv");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_uniform3fvBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGLRenderingContext"_s, "uniform3fv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto vConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument1.value());
    if (vConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform3fv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, vConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform3fv(locationConversionResult.releaseReturnValue(), vConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform3fv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_uniform3fvBody>(*lexicalGlobalObject, *callFrame, "uniform3fv");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_uniform4fvBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGLRenderingContext"_s, "uniform4fv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto vConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument1.value());
    if (vConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform4fv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, vConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform4fv(locationConversionResult.releaseReturnValue(), vConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform4fv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_uniform4fvBody>(*lexicalGlobalObject, *callFrame, "uniform4fv");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_uniform1ivBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGLRenderingContext"_s, "uniform1iv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto vConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLInt32Array>, IDLSequence<IDLLong>>>(*lexicalGlobalObject, argument1.value());
    if (vConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform1iv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, vConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform1iv(locationConversionResult.releaseReturnValue(), vConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform1iv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_uniform1ivBody>(*lexicalGlobalObject, *callFrame, "uniform1iv");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_uniform2ivBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGLRenderingContext"_s, "uniform2iv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto vConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLInt32Array>, IDLSequence<IDLLong>>>(*lexicalGlobalObject, argument1.value());
    if (vConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform2iv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, vConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform2iv(locationConversionResult.releaseReturnValue(), vConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform2iv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_uniform2ivBody>(*lexicalGlobalObject, *callFrame, "uniform2iv");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_uniform3ivBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGLRenderingContext"_s, "uniform3iv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto vConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLInt32Array>, IDLSequence<IDLLong>>>(*lexicalGlobalObject, argument1.value());
    if (vConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform3iv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, vConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform3iv(locationConversionResult.releaseReturnValue(), vConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform3iv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_uniform3ivBody>(*lexicalGlobalObject, *callFrame, "uniform3iv");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_uniform4ivBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGLRenderingContext"_s, "uniform4iv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto vConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLInt32Array>, IDLSequence<IDLLong>>>(*lexicalGlobalObject, argument1.value());
    if (vConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform4iv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, vConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform4iv(locationConversionResult.releaseReturnValue(), vConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniform4iv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_uniform4ivBody>(*lexicalGlobalObject, *callFrame, "uniform4iv");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_uniformMatrix2fvBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGLRenderingContext"_s, "uniformMatrix2fv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto transposeConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (transposeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto arrayConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument2.value());
    if (arrayConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniformMatrix2fv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, transposeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, arrayConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniformMatrix2fv(locationConversionResult.releaseReturnValue(), transposeConversionResult.releaseReturnValue(), arrayConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniformMatrix2fv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_uniformMatrix2fvBody>(*lexicalGlobalObject, *callFrame, "uniformMatrix2fv");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_uniformMatrix3fvBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGLRenderingContext"_s, "uniformMatrix3fv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto transposeConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (transposeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto arrayConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument2.value());
    if (arrayConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniformMatrix3fv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, transposeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, arrayConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniformMatrix3fv(locationConversionResult.releaseReturnValue(), transposeConversionResult.releaseReturnValue(), arrayConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniformMatrix3fv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_uniformMatrix3fvBody>(*lexicalGlobalObject, *callFrame, "uniformMatrix3fv");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_uniformMatrix4fvBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGLRenderingContext"_s, "uniformMatrix4fv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto transposeConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (transposeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto arrayConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument2.value());
    if (arrayConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniformMatrix4fv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, transposeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, arrayConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniformMatrix4fv(locationConversionResult.releaseReturnValue(), transposeConversionResult.releaseReturnValue(), arrayConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_uniformMatrix4fv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_uniformMatrix4fvBody>(*lexicalGlobalObject, *callFrame, "uniformMatrix4fv");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_useProgramBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGLRenderingContext"_s, "useProgram"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "useProgram"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.useProgram(programConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_useProgram, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_useProgramBody>(*lexicalGlobalObject, *callFrame, "useProgram");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_validateProgramBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGLRenderingContext"_s, "validateProgram"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "validateProgram"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.validateProgram(*programConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_validateProgram, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_validateProgramBody>(*lexicalGlobalObject, *callFrame, "validateProgram");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_vertexAttrib1fBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto xConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument1.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "vertexAttrib1f"_s, { InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.vertexAttrib1f(indexConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_vertexAttrib1f, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_vertexAttrib1fBody>(*lexicalGlobalObject, *callFrame, "vertexAttrib1f");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_vertexAttrib2fBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto xConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument1.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto yConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument2.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "vertexAttrib2f"_s, { InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.vertexAttrib2f(indexConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_vertexAttrib2f, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_vertexAttrib2fBody>(*lexicalGlobalObject, *callFrame, "vertexAttrib2f");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_vertexAttrib3fBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto xConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument1.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto yConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument2.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto zConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument3.value());
    if (zConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "vertexAttrib3f"_s, { InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, zConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.vertexAttrib3f(indexConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), zConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_vertexAttrib3f, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_vertexAttrib3fBody>(*lexicalGlobalObject, *callFrame, "vertexAttrib3f");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_vertexAttrib4fBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 5) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto xConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument1.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto yConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument2.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto zConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument3.value());
    if (zConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto wConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument4.value());
    if (wConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "vertexAttrib4f"_s, { InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, zConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, wConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.vertexAttrib4f(indexConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), zConversionResult.releaseReturnValue(), wConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_vertexAttrib4f, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_vertexAttrib4fBody>(*lexicalGlobalObject, *callFrame, "vertexAttrib4f");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_vertexAttrib1fvBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto valuesConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument1.value());
    if (valuesConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "vertexAttrib1fv"_s, { InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, valuesConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.vertexAttrib1fv(indexConversionResult.releaseReturnValue(), valuesConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_vertexAttrib1fv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_vertexAttrib1fvBody>(*lexicalGlobalObject, *callFrame, "vertexAttrib1fv");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_vertexAttrib2fvBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto valuesConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument1.value());
    if (valuesConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "vertexAttrib2fv"_s, { InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, valuesConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.vertexAttrib2fv(indexConversionResult.releaseReturnValue(), valuesConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_vertexAttrib2fv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_vertexAttrib2fvBody>(*lexicalGlobalObject, *callFrame, "vertexAttrib2fv");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_vertexAttrib3fvBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto valuesConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument1.value());
    if (valuesConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "vertexAttrib3fv"_s, { InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, valuesConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.vertexAttrib3fv(indexConversionResult.releaseReturnValue(), valuesConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_vertexAttrib3fv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_vertexAttrib3fvBody>(*lexicalGlobalObject, *callFrame, "vertexAttrib3fv");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_vertexAttrib4fvBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto valuesConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument1.value());
    if (valuesConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "vertexAttrib4fv"_s, { InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, valuesConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.vertexAttrib4fv(indexConversionResult.releaseReturnValue(), valuesConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_vertexAttrib4fv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_vertexAttrib4fvBody>(*lexicalGlobalObject, *callFrame, "vertexAttrib4fv");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_vertexAttribPointerBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 6) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indxConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indxConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto sizeConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (sizeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto normalizedConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument3.value());
    if (normalizedConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto strideConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (strideConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto offsetConversionResult = convert<IDLLongLong>(*lexicalGlobalObject, argument5.value());
    if (offsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "vertexAttribPointer"_s, { InspectorCanvasCallTracer::processArgument(impl, indxConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, sizeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, normalizedConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, strideConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, offsetConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.vertexAttribPointer(indxConversionResult.releaseReturnValue(), sizeConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), normalizedConversionResult.releaseReturnValue(), strideConversionResult.releaseReturnValue(), offsetConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_vertexAttribPointer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_vertexAttribPointerBody>(*lexicalGlobalObject, *callFrame, "vertexAttribPointer");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGLRenderingContextPrototypeFunction_viewportBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGLRenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto xConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument0.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto yConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "viewport"_s, { InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.viewport(xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGLRenderingContextPrototypeFunction_viewport, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGLRenderingContext>::call<jsWebGLRenderingContextPrototypeFunction_viewportBody>(*lexicalGlobalObject, *callFrame, "viewport");
}

#endif

JSC::GCClient::IsoSubspace* JSWebGLRenderingContext::subspaceForImpl(JSC::VM& vm)
{
    return WebCore::subspaceForImpl<JSWebGLRenderingContext, UseCustomHeapCellType::No>(vm, "JSWebGLRenderingContext"_s,
        [] (auto& spaces) { return spaces.m_clientSubspaceForWebGLRenderingContext.get(); },
        [] (auto& spaces, auto&& space) { spaces.m_clientSubspaceForWebGLRenderingContext = std::forward<decltype(space)>(space); },
        [] (auto& spaces) { return spaces.m_subspaceForWebGLRenderingContext.get(); },
        [] (auto& spaces, auto&& space) { spaces.m_subspaceForWebGLRenderingContext = std::forward<decltype(space)>(space); }
    );
}

template<typename Visitor>
void JSWebGLRenderingContext::visitChildrenImpl(JSCell* cell, Visitor& visitor)
{
    auto* thisObject = jsCast<JSWebGLRenderingContext*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);
    thisObject->visitAdditionalChildren(visitor);
}

DEFINE_VISIT_CHILDREN(JSWebGLRenderingContext);

template<typename Visitor>
void JSWebGLRenderingContext::visitOutputConstraints(JSCell* cell, Visitor& visitor)
{
    auto* thisObject = jsCast<JSWebGLRenderingContext*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitOutputConstraints(thisObject, visitor);
    thisObject->visitAdditionalChildren(visitor);
}

template void JSWebGLRenderingContext::visitOutputConstraints(JSCell*, AbstractSlotVisitor&);
template void JSWebGLRenderingContext::visitOutputConstraints(JSCell*, SlotVisitor&);
void JSWebGLRenderingContext::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSWebGLRenderingContext*>(cell);
    analyzer.setWrappedObjectForCell(cell, &thisObject->wrapped());
    if (RefPtr context = thisObject->scriptExecutionContext())
        analyzer.setLabelForCell(cell, makeString("url "_s, context->url().string()));
    Base::analyzeHeap(cell, analyzer);
}

bool JSWebGLRenderingContextOwner::isReachableFromOpaqueRoots(JSC::Handle<JSC::Unknown> handle, void*, AbstractSlotVisitor& visitor, ASCIILiteral* reason)
{
    SUPPRESS_UNCOUNTED_LOCAL auto* jsWebGLRenderingContext = jsCast<JSWebGLRenderingContext*>(handle.slot()->asCell());
    SUPPRESS_UNCOUNTED_LOCAL auto& wrapped = jsWebGLRenderingContext->wrapped();
    if (!wrapped.isContextStopped() && wrapped.hasPendingActivity()) {
        if (reason) [[unlikely]]
            *reason = "ActiveDOMObject with pending activity"_s;
        return true;
     }
    auto& owner = jsWebGLRenderingContext->wrapped().canvasBase();
    if (reason) [[unlikely]]
        *reason = "Reachable from CanvasBase"_s;
    return containsWebCoreOpaqueRoot(visitor, owner);
}

void JSWebGLRenderingContextOwner::finalize(JSC::Handle<JSC::Unknown> handle, void* context)
{
    auto* jsWebGLRenderingContext = static_cast<JSWebGLRenderingContext*>(handle.slot()->asCell());
    auto& world = *static_cast<DOMWrapperWorld*>(context);
    uncacheWrapper(world, jsWebGLRenderingContext->protectedWrapped().ptr(), jsWebGLRenderingContext);
}

WTF_ALLOW_UNSAFE_BUFFER_USAGE_BEGIN
#if ENABLE(BINDING_INTEGRITY)
#if PLATFORM(WIN)
#pragma warning(disable: 4483)
extern "C" { extern void (*const __identifier("??_7WebGLRenderingContext@WebCore@@6B@")[])(); }
#else
extern "C" { extern void* _ZTVN7WebCore21WebGLRenderingContextE[]; }
#endif
template<std::same_as<WebGLRenderingContext> T>
static inline void verifyVTable(WebGLRenderingContext* ptr) 
{
    if constexpr (std::is_polymorphic_v<T>) {
        const void* actualVTablePointer = getVTablePointer<T>(ptr);
#if PLATFORM(WIN)
        void* expectedVTablePointer = __identifier("??_7WebGLRenderingContext@WebCore@@6B@");
#else
        void* expectedVTablePointer = &_ZTVN7WebCore21WebGLRenderingContextE[2];
#endif

        // If you hit this assertion you either have a use after free bug, or
        // WebGLRenderingContext has subclasses. If WebGLRenderingContext has subclasses that get passed
        // to toJS() we currently require WebGLRenderingContext you to opt out of binding hardening
        // by adding the SkipVTableValidation attribute to the interface IDL definition
        RELEASE_ASSERT(actualVTablePointer == expectedVTablePointer);
    }
}
#endif
WTF_ALLOW_UNSAFE_BUFFER_USAGE_END

JSC::JSValue toJSNewlyCreated(JSC::JSGlobalObject*, JSDOMGlobalObject* globalObject, Ref<WebGLRenderingContext>&& impl)
{
#if ENABLE(BINDING_INTEGRITY)
    verifyVTable<WebGLRenderingContext>(impl.ptr());
#endif
    return createWrapper<WebGLRenderingContext>(globalObject, WTFMove(impl));
}

JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, WebGLRenderingContext& impl)
{
    return wrap(lexicalGlobalObject, globalObject, impl);
}

WebGLRenderingContext* JSWebGLRenderingContext::toWrapped(JSC::VM&, JSC::JSValue value)
{
    if (auto* wrapper = jsDynamicCast<JSWebGLRenderingContext*>(value))
        return &wrapper->wrapped();
    return nullptr;
}

}

#endif // ENABLE(WEBGL)
