/*
    This file is part of the WebKit open source project.
    This file has been generated by generate-bindings.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.
*/

#include "config.h"

#if ENABLE(WEB_RTC)

#include "JSRTCStatsReport.h"

#include "ActiveDOMObject.h"
#include "ContextDestructionObserverInlines.h"
#include "ExtendedDOMClientIsoSubspaces.h"
#include "ExtendedDOMIsoSubspaces.h"
#include "JSDOMAttribute.h"
#include "JSDOMBinding.h"
#include "JSDOMConstructorNotConstructable.h"
#include "JSDOMConvertAny.h"
#include "JSDOMConvertBoolean.h"
#include "JSDOMConvertNullable.h"
#include "JSDOMConvertNumbers.h"
#include "JSDOMConvertRecord.h"
#include "JSDOMConvertStrings.h"
#include "JSDOMExceptionHandling.h"
#include "JSDOMGlobalObject.h"
#include "JSDOMGlobalObjectInlines.h"
#include "JSDOMMapLike.h"
#include "JSDOMOperation.h"
#include "JSDOMWrapperCache.h"
#include "JSRTCDtlsTransportState.h"
#include "JSRTCIceCandidateType.h"
#include "JSRTCIceRole.h"
#include "JSRTCIceServerTransportProtocol.h"
#include "JSRTCIceTcpCandidateType.h"
#include "JSRTCIceTransportState.h"
#include "ScriptExecutionContext.h"
#include "WebCoreJSClientData.h"
#include <JavaScriptCore/BuiltinNames.h>
#include <JavaScriptCore/FunctionPrototype.h>
#include <JavaScriptCore/HeapAnalyzer.h>
#include <JavaScriptCore/JSCInlines.h>
#include <JavaScriptCore/JSDestructibleObjectHeapCellType.h>
#include <JavaScriptCore/JSString.h>
#include <JavaScriptCore/ObjectConstructor.h>
#include <JavaScriptCore/SlotVisitorMacros.h>
#include <JavaScriptCore/SubspaceInlines.h>
#include <wtf/GetPtr.h>
#include <wtf/PointerPreparations.h>
#include <wtf/SortedArrayMap.h>
#include <wtf/URL.h>
#include <wtf/Vector.h>
#include <wtf/text/MakeString.h>

namespace WebCore {
using namespace JSC;

String convertEnumerationToString(RTCStatsReport::Type enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 14> values {
        MAKE_STATIC_STRING_IMPL("codec"),
        MAKE_STATIC_STRING_IMPL("inbound-rtp"),
        MAKE_STATIC_STRING_IMPL("outbound-rtp"),
        MAKE_STATIC_STRING_IMPL("remote-inbound-rtp"),
        MAKE_STATIC_STRING_IMPL("remote-outbound-rtp"),
        MAKE_STATIC_STRING_IMPL("media-source"),
        MAKE_STATIC_STRING_IMPL("media-playout"),
        MAKE_STATIC_STRING_IMPL("peer-connection"),
        MAKE_STATIC_STRING_IMPL("data-channel"),
        MAKE_STATIC_STRING_IMPL("transport"),
        MAKE_STATIC_STRING_IMPL("candidate-pair"),
        MAKE_STATIC_STRING_IMPL("local-candidate"),
        MAKE_STATIC_STRING_IMPL("remote-candidate"),
        MAKE_STATIC_STRING_IMPL("certificate"),
    };
    static_assert(static_cast<size_t>(RTCStatsReport::Type::Codec) == 0, "RTCStatsReport::Type::Codec is not 0 as expected");
    static_assert(static_cast<size_t>(RTCStatsReport::Type::InboundRtp) == 1, "RTCStatsReport::Type::InboundRtp is not 1 as expected");
    static_assert(static_cast<size_t>(RTCStatsReport::Type::OutboundRtp) == 2, "RTCStatsReport::Type::OutboundRtp is not 2 as expected");
    static_assert(static_cast<size_t>(RTCStatsReport::Type::RemoteInboundRtp) == 3, "RTCStatsReport::Type::RemoteInboundRtp is not 3 as expected");
    static_assert(static_cast<size_t>(RTCStatsReport::Type::RemoteOutboundRtp) == 4, "RTCStatsReport::Type::RemoteOutboundRtp is not 4 as expected");
    static_assert(static_cast<size_t>(RTCStatsReport::Type::MediaSource) == 5, "RTCStatsReport::Type::MediaSource is not 5 as expected");
    static_assert(static_cast<size_t>(RTCStatsReport::Type::MediaPlayout) == 6, "RTCStatsReport::Type::MediaPlayout is not 6 as expected");
    static_assert(static_cast<size_t>(RTCStatsReport::Type::PeerConnection) == 7, "RTCStatsReport::Type::PeerConnection is not 7 as expected");
    static_assert(static_cast<size_t>(RTCStatsReport::Type::DataChannel) == 8, "RTCStatsReport::Type::DataChannel is not 8 as expected");
    static_assert(static_cast<size_t>(RTCStatsReport::Type::Transport) == 9, "RTCStatsReport::Type::Transport is not 9 as expected");
    static_assert(static_cast<size_t>(RTCStatsReport::Type::CandidatePair) == 10, "RTCStatsReport::Type::CandidatePair is not 10 as expected");
    static_assert(static_cast<size_t>(RTCStatsReport::Type::LocalCandidate) == 11, "RTCStatsReport::Type::LocalCandidate is not 11 as expected");
    static_assert(static_cast<size_t>(RTCStatsReport::Type::RemoteCandidate) == 12, "RTCStatsReport::Type::RemoteCandidate is not 12 as expected");
    static_assert(static_cast<size_t>(RTCStatsReport::Type::Certificate) == 13, "RTCStatsReport::Type::Certificate is not 13 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, RTCStatsReport::Type enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<RTCStatsReport::Type> parseEnumerationFromString<RTCStatsReport::Type>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, RTCStatsReport::Type>, 14> mappings {
        std::pair<ComparableASCIILiteral, RTCStatsReport::Type> { "candidate-pair"_s, RTCStatsReport::Type::CandidatePair },
        std::pair<ComparableASCIILiteral, RTCStatsReport::Type> { "certificate"_s, RTCStatsReport::Type::Certificate },
        std::pair<ComparableASCIILiteral, RTCStatsReport::Type> { "codec"_s, RTCStatsReport::Type::Codec },
        std::pair<ComparableASCIILiteral, RTCStatsReport::Type> { "data-channel"_s, RTCStatsReport::Type::DataChannel },
        std::pair<ComparableASCIILiteral, RTCStatsReport::Type> { "inbound-rtp"_s, RTCStatsReport::Type::InboundRtp },
        std::pair<ComparableASCIILiteral, RTCStatsReport::Type> { "local-candidate"_s, RTCStatsReport::Type::LocalCandidate },
        std::pair<ComparableASCIILiteral, RTCStatsReport::Type> { "media-playout"_s, RTCStatsReport::Type::MediaPlayout },
        std::pair<ComparableASCIILiteral, RTCStatsReport::Type> { "media-source"_s, RTCStatsReport::Type::MediaSource },
        std::pair<ComparableASCIILiteral, RTCStatsReport::Type> { "outbound-rtp"_s, RTCStatsReport::Type::OutboundRtp },
        std::pair<ComparableASCIILiteral, RTCStatsReport::Type> { "peer-connection"_s, RTCStatsReport::Type::PeerConnection },
        std::pair<ComparableASCIILiteral, RTCStatsReport::Type> { "remote-candidate"_s, RTCStatsReport::Type::RemoteCandidate },
        std::pair<ComparableASCIILiteral, RTCStatsReport::Type> { "remote-inbound-rtp"_s, RTCStatsReport::Type::RemoteInboundRtp },
        std::pair<ComparableASCIILiteral, RTCStatsReport::Type> { "remote-outbound-rtp"_s, RTCStatsReport::Type::RemoteOutboundRtp },
        std::pair<ComparableASCIILiteral, RTCStatsReport::Type> { "transport"_s, RTCStatsReport::Type::Transport },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<RTCStatsReport::Type> parseEnumeration<RTCStatsReport::Type>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<RTCStatsReport::Type>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<RTCStatsReport::Type>()
{
    return "\"codec\", \"inbound-rtp\", \"outbound-rtp\", \"remote-inbound-rtp\", \"remote-outbound-rtp\", \"media-source\", \"media-playout\", \"peer-connection\", \"data-channel\", \"transport\", \"candidate-pair\", \"local-candidate\", \"remote-candidate\", \"certificate\""_s;
}

String convertEnumerationToString(RTCStatsReport::QualityLimitationReason enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 4> values {
        MAKE_STATIC_STRING_IMPL("none"),
        MAKE_STATIC_STRING_IMPL("cpu"),
        MAKE_STATIC_STRING_IMPL("bandwidth"),
        MAKE_STATIC_STRING_IMPL("other"),
    };
    static_assert(static_cast<size_t>(RTCStatsReport::QualityLimitationReason::None) == 0, "RTCStatsReport::QualityLimitationReason::None is not 0 as expected");
    static_assert(static_cast<size_t>(RTCStatsReport::QualityLimitationReason::Cpu) == 1, "RTCStatsReport::QualityLimitationReason::Cpu is not 1 as expected");
    static_assert(static_cast<size_t>(RTCStatsReport::QualityLimitationReason::Bandwidth) == 2, "RTCStatsReport::QualityLimitationReason::Bandwidth is not 2 as expected");
    static_assert(static_cast<size_t>(RTCStatsReport::QualityLimitationReason::Other) == 3, "RTCStatsReport::QualityLimitationReason::Other is not 3 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, RTCStatsReport::QualityLimitationReason enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<RTCStatsReport::QualityLimitationReason> parseEnumerationFromString<RTCStatsReport::QualityLimitationReason>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, RTCStatsReport::QualityLimitationReason>, 4> mappings {
        std::pair<ComparableASCIILiteral, RTCStatsReport::QualityLimitationReason> { "bandwidth"_s, RTCStatsReport::QualityLimitationReason::Bandwidth },
        std::pair<ComparableASCIILiteral, RTCStatsReport::QualityLimitationReason> { "cpu"_s, RTCStatsReport::QualityLimitationReason::Cpu },
        std::pair<ComparableASCIILiteral, RTCStatsReport::QualityLimitationReason> { "none"_s, RTCStatsReport::QualityLimitationReason::None },
        std::pair<ComparableASCIILiteral, RTCStatsReport::QualityLimitationReason> { "other"_s, RTCStatsReport::QualityLimitationReason::Other },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<RTCStatsReport::QualityLimitationReason> parseEnumeration<RTCStatsReport::QualityLimitationReason>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<RTCStatsReport::QualityLimitationReason>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<RTCStatsReport::QualityLimitationReason>()
{
    return "\"none\", \"cpu\", \"bandwidth\", \"other\""_s;
}

String convertEnumerationToString(RTCStatsReport::CodecType enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 2> values {
        MAKE_STATIC_STRING_IMPL("encode"),
        MAKE_STATIC_STRING_IMPL("decode"),
    };
    static_assert(static_cast<size_t>(RTCStatsReport::CodecType::Encode) == 0, "RTCStatsReport::CodecType::Encode is not 0 as expected");
    static_assert(static_cast<size_t>(RTCStatsReport::CodecType::Decode) == 1, "RTCStatsReport::CodecType::Decode is not 1 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, RTCStatsReport::CodecType enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<RTCStatsReport::CodecType> parseEnumerationFromString<RTCStatsReport::CodecType>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, RTCStatsReport::CodecType>, 2> mappings {
        std::pair<ComparableASCIILiteral, RTCStatsReport::CodecType> { "decode"_s, RTCStatsReport::CodecType::Decode },
        std::pair<ComparableASCIILiteral, RTCStatsReport::CodecType> { "encode"_s, RTCStatsReport::CodecType::Encode },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<RTCStatsReport::CodecType> parseEnumeration<RTCStatsReport::CodecType>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<RTCStatsReport::CodecType>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<RTCStatsReport::CodecType>()
{
    return "\"encode\", \"decode\""_s;
}

String convertEnumerationToString(RTCStatsReport::DtlsRole enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 3> values {
        MAKE_STATIC_STRING_IMPL("client"),
        MAKE_STATIC_STRING_IMPL("server"),
        MAKE_STATIC_STRING_IMPL("unknown"),
    };
    static_assert(static_cast<size_t>(RTCStatsReport::DtlsRole::Client) == 0, "RTCStatsReport::DtlsRole::Client is not 0 as expected");
    static_assert(static_cast<size_t>(RTCStatsReport::DtlsRole::Server) == 1, "RTCStatsReport::DtlsRole::Server is not 1 as expected");
    static_assert(static_cast<size_t>(RTCStatsReport::DtlsRole::Unknown) == 2, "RTCStatsReport::DtlsRole::Unknown is not 2 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, RTCStatsReport::DtlsRole enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<RTCStatsReport::DtlsRole> parseEnumerationFromString<RTCStatsReport::DtlsRole>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, RTCStatsReport::DtlsRole>, 3> mappings {
        std::pair<ComparableASCIILiteral, RTCStatsReport::DtlsRole> { "client"_s, RTCStatsReport::DtlsRole::Client },
        std::pair<ComparableASCIILiteral, RTCStatsReport::DtlsRole> { "server"_s, RTCStatsReport::DtlsRole::Server },
        std::pair<ComparableASCIILiteral, RTCStatsReport::DtlsRole> { "unknown"_s, RTCStatsReport::DtlsRole::Unknown },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<RTCStatsReport::DtlsRole> parseEnumeration<RTCStatsReport::DtlsRole>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<RTCStatsReport::DtlsRole>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<RTCStatsReport::DtlsRole>()
{
    return "\"client\", \"server\", \"unknown\""_s;
}

String convertEnumerationToString(RTCStatsReport::IceCandidatePairState enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 5> values {
        MAKE_STATIC_STRING_IMPL("frozen"),
        MAKE_STATIC_STRING_IMPL("waiting"),
        MAKE_STATIC_STRING_IMPL("in-progress"),
        MAKE_STATIC_STRING_IMPL("failed"),
        MAKE_STATIC_STRING_IMPL("succeeded"),
    };
    static_assert(static_cast<size_t>(RTCStatsReport::IceCandidatePairState::Frozen) == 0, "RTCStatsReport::IceCandidatePairState::Frozen is not 0 as expected");
    static_assert(static_cast<size_t>(RTCStatsReport::IceCandidatePairState::Waiting) == 1, "RTCStatsReport::IceCandidatePairState::Waiting is not 1 as expected");
    static_assert(static_cast<size_t>(RTCStatsReport::IceCandidatePairState::InProgress) == 2, "RTCStatsReport::IceCandidatePairState::InProgress is not 2 as expected");
    static_assert(static_cast<size_t>(RTCStatsReport::IceCandidatePairState::Failed) == 3, "RTCStatsReport::IceCandidatePairState::Failed is not 3 as expected");
    static_assert(static_cast<size_t>(RTCStatsReport::IceCandidatePairState::Succeeded) == 4, "RTCStatsReport::IceCandidatePairState::Succeeded is not 4 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, RTCStatsReport::IceCandidatePairState enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<RTCStatsReport::IceCandidatePairState> parseEnumerationFromString<RTCStatsReport::IceCandidatePairState>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, RTCStatsReport::IceCandidatePairState>, 5> mappings {
        std::pair<ComparableASCIILiteral, RTCStatsReport::IceCandidatePairState> { "failed"_s, RTCStatsReport::IceCandidatePairState::Failed },
        std::pair<ComparableASCIILiteral, RTCStatsReport::IceCandidatePairState> { "frozen"_s, RTCStatsReport::IceCandidatePairState::Frozen },
        std::pair<ComparableASCIILiteral, RTCStatsReport::IceCandidatePairState> { "in-progress"_s, RTCStatsReport::IceCandidatePairState::InProgress },
        std::pair<ComparableASCIILiteral, RTCStatsReport::IceCandidatePairState> { "succeeded"_s, RTCStatsReport::IceCandidatePairState::Succeeded },
        std::pair<ComparableASCIILiteral, RTCStatsReport::IceCandidatePairState> { "waiting"_s, RTCStatsReport::IceCandidatePairState::Waiting },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<RTCStatsReport::IceCandidatePairState> parseEnumeration<RTCStatsReport::IceCandidatePairState>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<RTCStatsReport::IceCandidatePairState>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<RTCStatsReport::IceCandidatePairState>()
{
    return "\"frozen\", \"waiting\", \"in-progress\", \"failed\", \"succeeded\""_s;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const RTCStatsReport::Stats& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    auto idValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.id);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "id"_s), idValue);
    auto timestampValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, dictionary.timestamp);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "timestamp"_s), timestampValue);
    auto typeValue = toJS<IDLEnumeration<RTCStatsReport::Type>>(lexicalGlobalObject, throwScope, dictionary.type);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "type"_s), typeValue);
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const RTCStatsReport::RtpStreamStats& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    auto idValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.id);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "id"_s), idValue);
    auto timestampValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, dictionary.timestamp);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "timestamp"_s), timestampValue);
    auto typeValue = toJS<IDLEnumeration<RTCStatsReport::Type>>(lexicalGlobalObject, throwScope, dictionary.type);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "type"_s), typeValue);
    if (!IDLDOMString::isNullValue(dictionary.codecId)) {
        auto codecIdValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.codecId));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "codecId"_s), codecIdValue);
    }
    auto kindValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.kind);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "kind"_s), kindValue);
    auto ssrcValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, dictionary.ssrc);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "ssrc"_s), ssrcValue);
    if (!IDLDOMString::isNullValue(dictionary.transportId)) {
        auto transportIdValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.transportId));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "transportId"_s), transportIdValue);
    }
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const RTCStatsReport::ReceivedRtpStreamStats& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    auto idValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.id);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "id"_s), idValue);
    auto timestampValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, dictionary.timestamp);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "timestamp"_s), timestampValue);
    auto typeValue = toJS<IDLEnumeration<RTCStatsReport::Type>>(lexicalGlobalObject, throwScope, dictionary.type);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "type"_s), typeValue);
    if (!IDLDOMString::isNullValue(dictionary.codecId)) {
        auto codecIdValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.codecId));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "codecId"_s), codecIdValue);
    }
    auto kindValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.kind);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "kind"_s), kindValue);
    auto ssrcValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, dictionary.ssrc);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "ssrc"_s), ssrcValue);
    if (!IDLDOMString::isNullValue(dictionary.transportId)) {
        auto transportIdValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.transportId));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "transportId"_s), transportIdValue);
    }
    if (!IDLDouble::isNullValue(dictionary.jitter)) {
        auto jitterValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.jitter));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "jitter"_s), jitterValue);
    }
    if (!IDLLongLong::isNullValue(dictionary.packetsLost)) {
        auto packetsLostValue = toJS<IDLLongLong>(lexicalGlobalObject, throwScope, IDLLongLong::extractValueFromNullable(dictionary.packetsLost));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "packetsLost"_s), packetsLostValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.packetsReceived)) {
        auto packetsReceivedValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.packetsReceived));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "packetsReceived"_s), packetsReceivedValue);
    }
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const RTCStatsReport::InboundRtpStreamStats& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    auto idValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.id);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "id"_s), idValue);
    auto timestampValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, dictionary.timestamp);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "timestamp"_s), timestampValue);
    auto typeValue = toJS<IDLEnumeration<RTCStatsReport::Type>>(lexicalGlobalObject, throwScope, dictionary.type);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "type"_s), typeValue);
    if (!IDLDOMString::isNullValue(dictionary.codecId)) {
        auto codecIdValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.codecId));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "codecId"_s), codecIdValue);
    }
    auto kindValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.kind);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "kind"_s), kindValue);
    auto ssrcValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, dictionary.ssrc);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "ssrc"_s), ssrcValue);
    if (!IDLDOMString::isNullValue(dictionary.transportId)) {
        auto transportIdValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.transportId));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "transportId"_s), transportIdValue);
    }
    if (!IDLDouble::isNullValue(dictionary.jitter)) {
        auto jitterValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.jitter));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "jitter"_s), jitterValue);
    }
    if (!IDLLongLong::isNullValue(dictionary.packetsLost)) {
        auto packetsLostValue = toJS<IDLLongLong>(lexicalGlobalObject, throwScope, IDLLongLong::extractValueFromNullable(dictionary.packetsLost));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "packetsLost"_s), packetsLostValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.packetsReceived)) {
        auto packetsReceivedValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.packetsReceived));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "packetsReceived"_s), packetsReceivedValue);
    }
    if (!IDLDouble::isNullValue(dictionary.audioLevel)) {
        auto audioLevelValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.audioLevel));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "audioLevel"_s), audioLevelValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.bytesReceived)) {
        auto bytesReceivedValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.bytesReceived));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "bytesReceived"_s), bytesReceivedValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.concealedSamples)) {
        auto concealedSamplesValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.concealedSamples));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "concealedSamples"_s), concealedSamplesValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.concealmentEvents)) {
        auto concealmentEventsValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.concealmentEvents));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "concealmentEvents"_s), concealmentEventsValue);
    }
    if (!IDLDouble::isNullValue(dictionary.estimatedPlayoutTimestamp)) {
        auto estimatedPlayoutTimestampValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.estimatedPlayoutTimestamp));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "estimatedPlayoutTimestamp"_s), estimatedPlayoutTimestampValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.fecBytesReceived)) {
        auto fecBytesReceivedValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.fecBytesReceived));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "fecBytesReceived"_s), fecBytesReceivedValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.fecPacketsDiscarded)) {
        auto fecPacketsDiscardedValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.fecPacketsDiscarded));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "fecPacketsDiscarded"_s), fecPacketsDiscardedValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.fecPacketsReceived)) {
        auto fecPacketsReceivedValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.fecPacketsReceived));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "fecPacketsReceived"_s), fecPacketsReceivedValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.fecSsrc)) {
        auto fecSsrcValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.fecSsrc));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "fecSsrc"_s), fecSsrcValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.firCount)) {
        auto firCountValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.firCount));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "firCount"_s), firCountValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.frameHeight)) {
        auto frameHeightValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.frameHeight));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "frameHeight"_s), frameHeightValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.frameWidth)) {
        auto frameWidthValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.frameWidth));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "frameWidth"_s), frameWidthValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.framesAssembledFromMultiplePackets)) {
        auto framesAssembledFromMultiplePacketsValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.framesAssembledFromMultiplePackets));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "framesAssembledFromMultiplePackets"_s), framesAssembledFromMultiplePacketsValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.framesDecoded)) {
        auto framesDecodedValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.framesDecoded));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "framesDecoded"_s), framesDecodedValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.framesDropped)) {
        auto framesDroppedValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.framesDropped));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "framesDropped"_s), framesDroppedValue);
    }
    if (!IDLDouble::isNullValue(dictionary.framesPerSecond)) {
        auto framesPerSecondValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.framesPerSecond));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "framesPerSecond"_s), framesPerSecondValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.framesReceived)) {
        auto framesReceivedValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.framesReceived));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "framesReceived"_s), framesReceivedValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.framesRendered)) {
        auto framesRenderedValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.framesRendered));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "framesRendered"_s), framesRenderedValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.freezeCount)) {
        auto freezeCountValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.freezeCount));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "freezeCount"_s), freezeCountValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.headerBytesReceived)) {
        auto headerBytesReceivedValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.headerBytesReceived));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "headerBytesReceived"_s), headerBytesReceivedValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.insertedSamplesForDeceleration)) {
        auto insertedSamplesForDecelerationValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.insertedSamplesForDeceleration));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "insertedSamplesForDeceleration"_s), insertedSamplesForDecelerationValue);
    }
    if (!IDLDouble::isNullValue(dictionary.jitterBufferDelay)) {
        auto jitterBufferDelayValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.jitterBufferDelay));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "jitterBufferDelay"_s), jitterBufferDelayValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.jitterBufferEmittedCount)) {
        auto jitterBufferEmittedCountValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.jitterBufferEmittedCount));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "jitterBufferEmittedCount"_s), jitterBufferEmittedCountValue);
    }
    if (!IDLDouble::isNullValue(dictionary.jitterBufferMinimumDelay)) {
        auto jitterBufferMinimumDelayValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.jitterBufferMinimumDelay));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "jitterBufferMinimumDelay"_s), jitterBufferMinimumDelayValue);
    }
    if (!IDLDouble::isNullValue(dictionary.jitterBufferTargetDelay)) {
        auto jitterBufferTargetDelayValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.jitterBufferTargetDelay));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "jitterBufferTargetDelay"_s), jitterBufferTargetDelayValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.keyFramesDecoded)) {
        auto keyFramesDecodedValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.keyFramesDecoded));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "keyFramesDecoded"_s), keyFramesDecodedValue);
    }
    if (!IDLDouble::isNullValue(dictionary.lastPacketReceivedTimestamp)) {
        auto lastPacketReceivedTimestampValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.lastPacketReceivedTimestamp));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "lastPacketReceivedTimestamp"_s), lastPacketReceivedTimestampValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.mid)) {
        auto midValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.mid));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "mid"_s), midValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.nackCount)) {
        auto nackCountValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.nackCount));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "nackCount"_s), nackCountValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.packetsDiscarded)) {
        auto packetsDiscardedValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.packetsDiscarded));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "packetsDiscarded"_s), packetsDiscardedValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.pauseCount)) {
        auto pauseCountValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.pauseCount));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "pauseCount"_s), pauseCountValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.playoutId)) {
        auto playoutIdValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.playoutId));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "playoutId"_s), playoutIdValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.pliCount)) {
        auto pliCountValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.pliCount));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "pliCount"_s), pliCountValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.qpSum)) {
        auto qpSumValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.qpSum));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "qpSum"_s), qpSumValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.remoteId)) {
        auto remoteIdValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.remoteId));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "remoteId"_s), remoteIdValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.removedSamplesForAcceleration)) {
        auto removedSamplesForAccelerationValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.removedSamplesForAcceleration));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "removedSamplesForAcceleration"_s), removedSamplesForAccelerationValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.retransmittedBytesReceived)) {
        auto retransmittedBytesReceivedValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.retransmittedBytesReceived));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "retransmittedBytesReceived"_s), retransmittedBytesReceivedValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.retransmittedPacketsReceived)) {
        auto retransmittedPacketsReceivedValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.retransmittedPacketsReceived));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "retransmittedPacketsReceived"_s), retransmittedPacketsReceivedValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.rtxSsrc)) {
        auto rtxSsrcValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.rtxSsrc));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "rtxSsrc"_s), rtxSsrcValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.silentConcealedSamples)) {
        auto silentConcealedSamplesValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.silentConcealedSamples));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "silentConcealedSamples"_s), silentConcealedSamplesValue);
    }
    if (!IDLDouble::isNullValue(dictionary.totalAssemblyTime)) {
        auto totalAssemblyTimeValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.totalAssemblyTime));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "totalAssemblyTime"_s), totalAssemblyTimeValue);
    }
    if (!IDLDouble::isNullValue(dictionary.totalAudioEnergy)) {
        auto totalAudioEnergyValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.totalAudioEnergy));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "totalAudioEnergy"_s), totalAudioEnergyValue);
    }
    if (!IDLDouble::isNullValue(dictionary.totalDecodeTime)) {
        auto totalDecodeTimeValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.totalDecodeTime));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "totalDecodeTime"_s), totalDecodeTimeValue);
    }
    if (!IDLDouble::isNullValue(dictionary.totalFreezesDuration)) {
        auto totalFreezesDurationValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.totalFreezesDuration));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "totalFreezesDuration"_s), totalFreezesDurationValue);
    }
    if (!IDLDouble::isNullValue(dictionary.totalInterFrameDelay)) {
        auto totalInterFrameDelayValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.totalInterFrameDelay));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "totalInterFrameDelay"_s), totalInterFrameDelayValue);
    }
    if (!IDLDouble::isNullValue(dictionary.totalPausesDuration)) {
        auto totalPausesDurationValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.totalPausesDuration));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "totalPausesDuration"_s), totalPausesDurationValue);
    }
    if (!IDLDouble::isNullValue(dictionary.totalProcessingDelay)) {
        auto totalProcessingDelayValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.totalProcessingDelay));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "totalProcessingDelay"_s), totalProcessingDelayValue);
    }
    if (!IDLDouble::isNullValue(dictionary.totalSamplesDuration)) {
        auto totalSamplesDurationValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.totalSamplesDuration));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "totalSamplesDuration"_s), totalSamplesDurationValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.totalSamplesReceived)) {
        auto totalSamplesReceivedValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.totalSamplesReceived));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "totalSamplesReceived"_s), totalSamplesReceivedValue);
    }
    if (!IDLDouble::isNullValue(dictionary.totalSquaredInterFrameDelay)) {
        auto totalSquaredInterFrameDelayValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.totalSquaredInterFrameDelay));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "totalSquaredInterFrameDelay"_s), totalSquaredInterFrameDelayValue);
    }
    auto trackIdentifierValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.trackIdentifier);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "trackIdentifier"_s), trackIdentifierValue);
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const RTCStatsReport::RemoteInboundRtpStreamStats& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    auto idValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.id);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "id"_s), idValue);
    auto timestampValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, dictionary.timestamp);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "timestamp"_s), timestampValue);
    auto typeValue = toJS<IDLEnumeration<RTCStatsReport::Type>>(lexicalGlobalObject, throwScope, dictionary.type);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "type"_s), typeValue);
    if (!IDLDOMString::isNullValue(dictionary.codecId)) {
        auto codecIdValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.codecId));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "codecId"_s), codecIdValue);
    }
    auto kindValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.kind);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "kind"_s), kindValue);
    auto ssrcValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, dictionary.ssrc);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "ssrc"_s), ssrcValue);
    if (!IDLDOMString::isNullValue(dictionary.transportId)) {
        auto transportIdValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.transportId));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "transportId"_s), transportIdValue);
    }
    if (!IDLDouble::isNullValue(dictionary.jitter)) {
        auto jitterValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.jitter));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "jitter"_s), jitterValue);
    }
    if (!IDLLongLong::isNullValue(dictionary.packetsLost)) {
        auto packetsLostValue = toJS<IDLLongLong>(lexicalGlobalObject, throwScope, IDLLongLong::extractValueFromNullable(dictionary.packetsLost));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "packetsLost"_s), packetsLostValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.packetsReceived)) {
        auto packetsReceivedValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.packetsReceived));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "packetsReceived"_s), packetsReceivedValue);
    }
    if (!IDLDouble::isNullValue(dictionary.fractionLost)) {
        auto fractionLostValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.fractionLost));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "fractionLost"_s), fractionLostValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.localId)) {
        auto localIdValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.localId));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "localId"_s), localIdValue);
    }
    if (!IDLDouble::isNullValue(dictionary.roundTripTime)) {
        auto roundTripTimeValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.roundTripTime));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "roundTripTime"_s), roundTripTimeValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.roundTripTimeMeasurements)) {
        auto roundTripTimeMeasurementsValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.roundTripTimeMeasurements));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "roundTripTimeMeasurements"_s), roundTripTimeMeasurementsValue);
    }
    if (!IDLDouble::isNullValue(dictionary.totalRoundTripTime)) {
        auto totalRoundTripTimeValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.totalRoundTripTime));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "totalRoundTripTime"_s), totalRoundTripTimeValue);
    }
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const RTCStatsReport::SentRtpStreamStats& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    auto idValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.id);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "id"_s), idValue);
    auto timestampValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, dictionary.timestamp);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "timestamp"_s), timestampValue);
    auto typeValue = toJS<IDLEnumeration<RTCStatsReport::Type>>(lexicalGlobalObject, throwScope, dictionary.type);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "type"_s), typeValue);
    if (!IDLDOMString::isNullValue(dictionary.codecId)) {
        auto codecIdValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.codecId));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "codecId"_s), codecIdValue);
    }
    auto kindValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.kind);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "kind"_s), kindValue);
    auto ssrcValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, dictionary.ssrc);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "ssrc"_s), ssrcValue);
    if (!IDLDOMString::isNullValue(dictionary.transportId)) {
        auto transportIdValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.transportId));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "transportId"_s), transportIdValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.bytesSent)) {
        auto bytesSentValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.bytesSent));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "bytesSent"_s), bytesSentValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.packetsSent)) {
        auto packetsSentValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.packetsSent));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "packetsSent"_s), packetsSentValue);
    }
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const RTCStatsReport::OutboundRtpStreamStats& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    auto idValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.id);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "id"_s), idValue);
    auto timestampValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, dictionary.timestamp);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "timestamp"_s), timestampValue);
    auto typeValue = toJS<IDLEnumeration<RTCStatsReport::Type>>(lexicalGlobalObject, throwScope, dictionary.type);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "type"_s), typeValue);
    if (!IDLDOMString::isNullValue(dictionary.codecId)) {
        auto codecIdValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.codecId));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "codecId"_s), codecIdValue);
    }
    auto kindValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.kind);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "kind"_s), kindValue);
    auto ssrcValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, dictionary.ssrc);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "ssrc"_s), ssrcValue);
    if (!IDLDOMString::isNullValue(dictionary.transportId)) {
        auto transportIdValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.transportId));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "transportId"_s), transportIdValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.bytesSent)) {
        auto bytesSentValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.bytesSent));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "bytesSent"_s), bytesSentValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.packetsSent)) {
        auto packetsSentValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.packetsSent));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "packetsSent"_s), packetsSentValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.active)) {
        auto activeValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.active));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "active"_s), activeValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.firCount)) {
        auto firCountValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.firCount));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "firCount"_s), firCountValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.frameHeight)) {
        auto frameHeightValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.frameHeight));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "frameHeight"_s), frameHeightValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.frameWidth)) {
        auto frameWidthValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.frameWidth));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "frameWidth"_s), frameWidthValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.framesEncoded)) {
        auto framesEncodedValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.framesEncoded));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "framesEncoded"_s), framesEncodedValue);
    }
    if (!IDLDouble::isNullValue(dictionary.framesPerSecond)) {
        auto framesPerSecondValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.framesPerSecond));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "framesPerSecond"_s), framesPerSecondValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.framesSent)) {
        auto framesSentValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.framesSent));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "framesSent"_s), framesSentValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.headerBytesSent)) {
        auto headerBytesSentValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.headerBytesSent));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "headerBytesSent"_s), headerBytesSentValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.hugeFramesSent)) {
        auto hugeFramesSentValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.hugeFramesSent));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "hugeFramesSent"_s), hugeFramesSentValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.keyFramesEncoded)) {
        auto keyFramesEncodedValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.keyFramesEncoded));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "keyFramesEncoded"_s), keyFramesEncodedValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.mediaSourceId)) {
        auto mediaSourceIdValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.mediaSourceId));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "mediaSourceId"_s), mediaSourceIdValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.mid)) {
        auto midValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.mid));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "mid"_s), midValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.nackCount)) {
        auto nackCountValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.nackCount));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "nackCount"_s), nackCountValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.pliCount)) {
        auto pliCountValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.pliCount));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "pliCount"_s), pliCountValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.qpSum)) {
        auto qpSumValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.qpSum));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "qpSum"_s), qpSumValue);
    }
    if (!IDLRecord<IDLDOMString, IDLDouble>::isNullValue(dictionary.qualityLimitationDurations)) {
        auto qualityLimitationDurationsValue = toJS<IDLRecord<IDLDOMString, IDLDouble>>(lexicalGlobalObject, globalObject, throwScope, IDLRecord<IDLDOMString, IDLDouble>::extractValueFromNullable(dictionary.qualityLimitationDurations));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "qualityLimitationDurations"_s), qualityLimitationDurationsValue);
    }
    if (!IDLEnumeration<RTCStatsReport::QualityLimitationReason>::isNullValue(dictionary.qualityLimitationReason)) {
        auto qualityLimitationReasonValue = toJS<IDLEnumeration<RTCStatsReport::QualityLimitationReason>>(lexicalGlobalObject, throwScope, IDLEnumeration<RTCStatsReport::QualityLimitationReason>::extractValueFromNullable(dictionary.qualityLimitationReason));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "qualityLimitationReason"_s), qualityLimitationReasonValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.qualityLimitationResolutionChanges)) {
        auto qualityLimitationResolutionChangesValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.qualityLimitationResolutionChanges));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "qualityLimitationResolutionChanges"_s), qualityLimitationResolutionChangesValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.remoteId)) {
        auto remoteIdValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.remoteId));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "remoteId"_s), remoteIdValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.retransmittedBytesSent)) {
        auto retransmittedBytesSentValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.retransmittedBytesSent));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "retransmittedBytesSent"_s), retransmittedBytesSentValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.retransmittedPacketsSent)) {
        auto retransmittedPacketsSentValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.retransmittedPacketsSent));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "retransmittedPacketsSent"_s), retransmittedPacketsSentValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.rid)) {
        auto ridValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.rid));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "rid"_s), ridValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.rtxSsrc)) {
        auto rtxSsrcValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.rtxSsrc));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "rtxSsrc"_s), rtxSsrcValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.scalabilityMode)) {
        auto scalabilityModeValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.scalabilityMode));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "scalabilityMode"_s), scalabilityModeValue);
    }
    if (!IDLDouble::isNullValue(dictionary.targetBitrate)) {
        auto targetBitrateValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.targetBitrate));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "targetBitrate"_s), targetBitrateValue);
    }
    if (!IDLDouble::isNullValue(dictionary.totalEncodeTime)) {
        auto totalEncodeTimeValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.totalEncodeTime));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "totalEncodeTime"_s), totalEncodeTimeValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.totalEncodedBytesTarget)) {
        auto totalEncodedBytesTargetValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.totalEncodedBytesTarget));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "totalEncodedBytesTarget"_s), totalEncodedBytesTargetValue);
    }
    if (!IDLDouble::isNullValue(dictionary.totalPacketSendDelay)) {
        auto totalPacketSendDelayValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.totalPacketSendDelay));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "totalPacketSendDelay"_s), totalPacketSendDelayValue);
    }
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const RTCStatsReport::RemoteOutboundRtpStreamStats& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    auto idValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.id);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "id"_s), idValue);
    auto timestampValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, dictionary.timestamp);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "timestamp"_s), timestampValue);
    auto typeValue = toJS<IDLEnumeration<RTCStatsReport::Type>>(lexicalGlobalObject, throwScope, dictionary.type);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "type"_s), typeValue);
    if (!IDLDOMString::isNullValue(dictionary.codecId)) {
        auto codecIdValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.codecId));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "codecId"_s), codecIdValue);
    }
    auto kindValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.kind);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "kind"_s), kindValue);
    auto ssrcValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, dictionary.ssrc);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "ssrc"_s), ssrcValue);
    if (!IDLDOMString::isNullValue(dictionary.transportId)) {
        auto transportIdValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.transportId));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "transportId"_s), transportIdValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.bytesSent)) {
        auto bytesSentValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.bytesSent));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "bytesSent"_s), bytesSentValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.packetsSent)) {
        auto packetsSentValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.packetsSent));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "packetsSent"_s), packetsSentValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.localId)) {
        auto localIdValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.localId));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "localId"_s), localIdValue);
    }
    if (!IDLDouble::isNullValue(dictionary.remoteTimestamp)) {
        auto remoteTimestampValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.remoteTimestamp));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "remoteTimestamp"_s), remoteTimestampValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.reportsSent)) {
        auto reportsSentValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.reportsSent));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "reportsSent"_s), reportsSentValue);
    }
    if (!IDLDouble::isNullValue(dictionary.roundTripTime)) {
        auto roundTripTimeValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.roundTripTime));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "roundTripTime"_s), roundTripTimeValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.roundTripTimeMeasurements)) {
        auto roundTripTimeMeasurementsValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.roundTripTimeMeasurements));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "roundTripTimeMeasurements"_s), roundTripTimeMeasurementsValue);
    }
    if (!IDLDouble::isNullValue(dictionary.totalRoundTripTime)) {
        auto totalRoundTripTimeValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.totalRoundTripTime));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "totalRoundTripTime"_s), totalRoundTripTimeValue);
    }
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const RTCStatsReport::CodecStats& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    auto idValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.id);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "id"_s), idValue);
    auto timestampValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, dictionary.timestamp);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "timestamp"_s), timestampValue);
    auto typeValue = toJS<IDLEnumeration<RTCStatsReport::Type>>(lexicalGlobalObject, throwScope, dictionary.type);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "type"_s), typeValue);
    if (!IDLUnsignedLong::isNullValue(dictionary.channels)) {
        auto channelsValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.channels));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "channels"_s), channelsValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.clockRate)) {
        auto clockRateValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.clockRate));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "clockRate"_s), clockRateValue);
    }
    auto mimeTypeValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.mimeType);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "mimeType"_s), mimeTypeValue);
    auto payloadTypeValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, dictionary.payloadType);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "payloadType"_s), payloadTypeValue);
    if (!IDLDOMString::isNullValue(dictionary.sdpFmtpLine)) {
        auto sdpFmtpLineValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.sdpFmtpLine));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "sdpFmtpLine"_s), sdpFmtpLineValue);
    }
    auto transportIdValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.transportId);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "transportId"_s), transportIdValue);
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const RTCStatsReport::MediaSourceStats& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    auto idValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.id);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "id"_s), idValue);
    auto timestampValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, dictionary.timestamp);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "timestamp"_s), timestampValue);
    auto typeValue = toJS<IDLEnumeration<RTCStatsReport::Type>>(lexicalGlobalObject, throwScope, dictionary.type);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "type"_s), typeValue);
    auto kindValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.kind);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "kind"_s), kindValue);
    auto trackIdentifierValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.trackIdentifier);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "trackIdentifier"_s), trackIdentifierValue);
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const RTCStatsReport::AudioSourceStats& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    auto idValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.id);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "id"_s), idValue);
    auto timestampValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, dictionary.timestamp);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "timestamp"_s), timestampValue);
    auto typeValue = toJS<IDLEnumeration<RTCStatsReport::Type>>(lexicalGlobalObject, throwScope, dictionary.type);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "type"_s), typeValue);
    auto kindValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.kind);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "kind"_s), kindValue);
    auto trackIdentifierValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.trackIdentifier);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "trackIdentifier"_s), trackIdentifierValue);
    if (!IDLDouble::isNullValue(dictionary.audioLevel)) {
        auto audioLevelValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.audioLevel));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "audioLevel"_s), audioLevelValue);
    }
    if (!IDLDouble::isNullValue(dictionary.echoReturnLoss)) {
        auto echoReturnLossValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.echoReturnLoss));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "echoReturnLoss"_s), echoReturnLossValue);
    }
    if (!IDLDouble::isNullValue(dictionary.echoReturnLossEnhancement)) {
        auto echoReturnLossEnhancementValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.echoReturnLossEnhancement));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "echoReturnLossEnhancement"_s), echoReturnLossEnhancementValue);
    }
    if (!IDLDouble::isNullValue(dictionary.totalAudioEnergy)) {
        auto totalAudioEnergyValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.totalAudioEnergy));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "totalAudioEnergy"_s), totalAudioEnergyValue);
    }
    if (!IDLDouble::isNullValue(dictionary.totalSamplesDuration)) {
        auto totalSamplesDurationValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.totalSamplesDuration));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "totalSamplesDuration"_s), totalSamplesDurationValue);
    }
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const RTCStatsReport::VideoSourceStats& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    auto idValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.id);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "id"_s), idValue);
    auto timestampValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, dictionary.timestamp);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "timestamp"_s), timestampValue);
    auto typeValue = toJS<IDLEnumeration<RTCStatsReport::Type>>(lexicalGlobalObject, throwScope, dictionary.type);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "type"_s), typeValue);
    auto kindValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.kind);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "kind"_s), kindValue);
    auto trackIdentifierValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.trackIdentifier);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "trackIdentifier"_s), trackIdentifierValue);
    if (!IDLUnsignedLong::isNullValue(dictionary.frames)) {
        auto framesValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.frames));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "frames"_s), framesValue);
    }
    if (!IDLDouble::isNullValue(dictionary.framesPerSecond)) {
        auto framesPerSecondValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.framesPerSecond));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "framesPerSecond"_s), framesPerSecondValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.height)) {
        auto heightValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.height));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "height"_s), heightValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.width)) {
        auto widthValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.width));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "width"_s), widthValue);
    }
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const RTCStatsReport::AudioPlayoutStats& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    auto idValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.id);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "id"_s), idValue);
    auto timestampValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, dictionary.timestamp);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "timestamp"_s), timestampValue);
    auto typeValue = toJS<IDLEnumeration<RTCStatsReport::Type>>(lexicalGlobalObject, throwScope, dictionary.type);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "type"_s), typeValue);
    auto kindValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.kind);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "kind"_s), kindValue);
    if (!IDLDouble::isNullValue(dictionary.synthesizedSamplesDuration)) {
        auto synthesizedSamplesDurationValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.synthesizedSamplesDuration));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "synthesizedSamplesDuration"_s), synthesizedSamplesDurationValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.synthesizedSamplesEvents)) {
        auto synthesizedSamplesEventsValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.synthesizedSamplesEvents));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "synthesizedSamplesEvents"_s), synthesizedSamplesEventsValue);
    }
    if (!IDLDouble::isNullValue(dictionary.totalPlayoutDelay)) {
        auto totalPlayoutDelayValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.totalPlayoutDelay));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "totalPlayoutDelay"_s), totalPlayoutDelayValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.totalSamplesCount)) {
        auto totalSamplesCountValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.totalSamplesCount));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "totalSamplesCount"_s), totalSamplesCountValue);
    }
    if (!IDLDouble::isNullValue(dictionary.totalSamplesDuration)) {
        auto totalSamplesDurationValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.totalSamplesDuration));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "totalSamplesDuration"_s), totalSamplesDurationValue);
    }
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const RTCStatsReport::PeerConnectionStats& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    auto idValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.id);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "id"_s), idValue);
    auto timestampValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, dictionary.timestamp);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "timestamp"_s), timestampValue);
    auto typeValue = toJS<IDLEnumeration<RTCStatsReport::Type>>(lexicalGlobalObject, throwScope, dictionary.type);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "type"_s), typeValue);
    if (!IDLUnsignedLong::isNullValue(dictionary.dataChannelsClosed)) {
        auto dataChannelsClosedValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.dataChannelsClosed));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "dataChannelsClosed"_s), dataChannelsClosedValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.dataChannelsOpened)) {
        auto dataChannelsOpenedValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.dataChannelsOpened));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "dataChannelsOpened"_s), dataChannelsOpenedValue);
    }
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const RTCStatsReport::DataChannelStats& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    auto idValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.id);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "id"_s), idValue);
    auto timestampValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, dictionary.timestamp);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "timestamp"_s), timestampValue);
    auto typeValue = toJS<IDLEnumeration<RTCStatsReport::Type>>(lexicalGlobalObject, throwScope, dictionary.type);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "type"_s), typeValue);
    if (!IDLUnsignedLongLong::isNullValue(dictionary.bytesReceived)) {
        auto bytesReceivedValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.bytesReceived));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "bytesReceived"_s), bytesReceivedValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.bytesSent)) {
        auto bytesSentValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.bytesSent));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "bytesSent"_s), bytesSentValue);
    }
    if (!IDLLong::isNullValue(dictionary.dataChannelIdentifier)) {
        auto dataChannelIdentifierValue = toJS<IDLLong>(lexicalGlobalObject, throwScope, IDLLong::extractValueFromNullable(dictionary.dataChannelIdentifier));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "dataChannelIdentifier"_s), dataChannelIdentifierValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.label)) {
        auto labelValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.label));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "label"_s), labelValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.messagesReceived)) {
        auto messagesReceivedValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.messagesReceived));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "messagesReceived"_s), messagesReceivedValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.messagesSent)) {
        auto messagesSentValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.messagesSent));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "messagesSent"_s), messagesSentValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.protocol)) {
        auto protocolValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.protocol));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "protocol"_s), protocolValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.state)) {
        auto stateValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.state));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "state"_s), stateValue);
    }
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const RTCStatsReport::TransportStats& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    auto idValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.id);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "id"_s), idValue);
    auto timestampValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, dictionary.timestamp);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "timestamp"_s), timestampValue);
    auto typeValue = toJS<IDLEnumeration<RTCStatsReport::Type>>(lexicalGlobalObject, throwScope, dictionary.type);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "type"_s), typeValue);
    if (!IDLUnsignedLongLong::isNullValue(dictionary.bytesReceived)) {
        auto bytesReceivedValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.bytesReceived));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "bytesReceived"_s), bytesReceivedValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.bytesSent)) {
        auto bytesSentValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.bytesSent));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "bytesSent"_s), bytesSentValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.dtlsCipher)) {
        auto dtlsCipherValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.dtlsCipher));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "dtlsCipher"_s), dtlsCipherValue);
    }
    if (!IDLEnumeration<RTCStatsReport::DtlsRole>::isNullValue(dictionary.dtlsRole)) {
        auto dtlsRoleValue = toJS<IDLEnumeration<RTCStatsReport::DtlsRole>>(lexicalGlobalObject, throwScope, IDLEnumeration<RTCStatsReport::DtlsRole>::extractValueFromNullable(dictionary.dtlsRole));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "dtlsRole"_s), dtlsRoleValue);
    }
    auto dtlsStateValue = toJS<IDLEnumeration<RTCDtlsTransportState>>(lexicalGlobalObject, throwScope, dictionary.dtlsState);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "dtlsState"_s), dtlsStateValue);
    if (!IDLDOMString::isNullValue(dictionary.iceLocalUsernameFragment)) {
        auto iceLocalUsernameFragmentValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.iceLocalUsernameFragment));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "iceLocalUsernameFragment"_s), iceLocalUsernameFragmentValue);
    }
    if (!IDLEnumeration<RTCIceRole>::isNullValue(dictionary.iceRole)) {
        auto iceRoleValue = toJS<IDLEnumeration<RTCIceRole>>(lexicalGlobalObject, throwScope, IDLEnumeration<RTCIceRole>::extractValueFromNullable(dictionary.iceRole));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "iceRole"_s), iceRoleValue);
    }
    if (!IDLEnumeration<RTCIceTransportState>::isNullValue(dictionary.iceState)) {
        auto iceStateValue = toJS<IDLEnumeration<RTCIceTransportState>>(lexicalGlobalObject, throwScope, IDLEnumeration<RTCIceTransportState>::extractValueFromNullable(dictionary.iceState));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "iceState"_s), iceStateValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.localCertificateId)) {
        auto localCertificateIdValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.localCertificateId));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "localCertificateId"_s), localCertificateIdValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.packetsReceived)) {
        auto packetsReceivedValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.packetsReceived));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "packetsReceived"_s), packetsReceivedValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.packetsSent)) {
        auto packetsSentValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.packetsSent));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "packetsSent"_s), packetsSentValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.remoteCertificateId)) {
        auto remoteCertificateIdValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.remoteCertificateId));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "remoteCertificateId"_s), remoteCertificateIdValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.selectedCandidatePairChanges)) {
        auto selectedCandidatePairChangesValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.selectedCandidatePairChanges));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "selectedCandidatePairChanges"_s), selectedCandidatePairChangesValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.selectedCandidatePairId)) {
        auto selectedCandidatePairIdValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.selectedCandidatePairId));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "selectedCandidatePairId"_s), selectedCandidatePairIdValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.srtpCipher)) {
        auto srtpCipherValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.srtpCipher));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "srtpCipher"_s), srtpCipherValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.tlsVersion)) {
        auto tlsVersionValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.tlsVersion));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "tlsVersion"_s), tlsVersionValue);
    }
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const RTCStatsReport::IceCandidateStats& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    auto idValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.id);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "id"_s), idValue);
    auto timestampValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, dictionary.timestamp);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "timestamp"_s), timestampValue);
    auto typeValue = toJS<IDLEnumeration<RTCStatsReport::Type>>(lexicalGlobalObject, throwScope, dictionary.type);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "type"_s), typeValue);
    if (!IDLNullable<IDLDOMString>::isNullValue(dictionary.address)) {
        auto addressValue = toJS<IDLNullable<IDLDOMString>>(lexicalGlobalObject, throwScope, IDLNullable<IDLDOMString>::extractValueFromNullable(dictionary.address));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "address"_s), addressValue);
    }
    auto candidateTypeValue = toJS<IDLEnumeration<RTCIceCandidateType>>(lexicalGlobalObject, throwScope, dictionary.candidateType);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "candidateType"_s), candidateTypeValue);
    if (!IDLDOMString::isNullValue(dictionary.foundation)) {
        auto foundationValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.foundation));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "foundation"_s), foundationValue);
    }
    if (!IDLLong::isNullValue(dictionary.port)) {
        auto portValue = toJS<IDLLong>(lexicalGlobalObject, throwScope, IDLLong::extractValueFromNullable(dictionary.port));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "port"_s), portValue);
    }
    if (!IDLLong::isNullValue(dictionary.priority)) {
        auto priorityValue = toJS<IDLLong>(lexicalGlobalObject, throwScope, IDLLong::extractValueFromNullable(dictionary.priority));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "priority"_s), priorityValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.protocol)) {
        auto protocolValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.protocol));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "protocol"_s), protocolValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.relatedAddress)) {
        auto relatedAddressValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.relatedAddress));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "relatedAddress"_s), relatedAddressValue);
    }
    if (!IDLLong::isNullValue(dictionary.relatedPort)) {
        auto relatedPortValue = toJS<IDLLong>(lexicalGlobalObject, throwScope, IDLLong::extractValueFromNullable(dictionary.relatedPort));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "relatedPort"_s), relatedPortValue);
    }
    if (!IDLEnumeration<RTCIceServerTransportProtocol>::isNullValue(dictionary.relayProtocol)) {
        auto relayProtocolValue = toJS<IDLEnumeration<RTCIceServerTransportProtocol>>(lexicalGlobalObject, throwScope, IDLEnumeration<RTCIceServerTransportProtocol>::extractValueFromNullable(dictionary.relayProtocol));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "relayProtocol"_s), relayProtocolValue);
    }
    if (!IDLEnumeration<RTCIceTcpCandidateType>::isNullValue(dictionary.tcpType)) {
        auto tcpTypeValue = toJS<IDLEnumeration<RTCIceTcpCandidateType>>(lexicalGlobalObject, throwScope, IDLEnumeration<RTCIceTcpCandidateType>::extractValueFromNullable(dictionary.tcpType));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "tcpType"_s), tcpTypeValue);
    }
    auto transportIdValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.transportId);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "transportId"_s), transportIdValue);
    if (!IDLDOMString::isNullValue(dictionary.url)) {
        auto urlValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.url));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "url"_s), urlValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.usernameFragment)) {
        auto usernameFragmentValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.usernameFragment));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "usernameFragment"_s), usernameFragmentValue);
    }
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const RTCStatsReport::IceCandidatePairStats& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    auto idValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.id);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "id"_s), idValue);
    auto timestampValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, dictionary.timestamp);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "timestamp"_s), timestampValue);
    auto typeValue = toJS<IDLEnumeration<RTCStatsReport::Type>>(lexicalGlobalObject, throwScope, dictionary.type);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "type"_s), typeValue);
    if (!IDLDouble::isNullValue(dictionary.availableIncomingBitrate)) {
        auto availableIncomingBitrateValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.availableIncomingBitrate));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "availableIncomingBitrate"_s), availableIncomingBitrateValue);
    }
    if (!IDLDouble::isNullValue(dictionary.availableOutgoingBitrate)) {
        auto availableOutgoingBitrateValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.availableOutgoingBitrate));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "availableOutgoingBitrate"_s), availableOutgoingBitrateValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.bytesDiscardedOnSend)) {
        auto bytesDiscardedOnSendValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.bytesDiscardedOnSend));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "bytesDiscardedOnSend"_s), bytesDiscardedOnSendValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.bytesReceived)) {
        auto bytesReceivedValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.bytesReceived));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "bytesReceived"_s), bytesReceivedValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.bytesSent)) {
        auto bytesSentValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.bytesSent));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "bytesSent"_s), bytesSentValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.consentRequestsSent)) {
        auto consentRequestsSentValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.consentRequestsSent));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "consentRequestsSent"_s), consentRequestsSentValue);
    }
    if (!IDLDouble::isNullValue(dictionary.currentRoundTripTime)) {
        auto currentRoundTripTimeValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.currentRoundTripTime));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "currentRoundTripTime"_s), currentRoundTripTimeValue);
    }
    if (!IDLDouble::isNullValue(dictionary.lastPacketReceivedTimestamp)) {
        auto lastPacketReceivedTimestampValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.lastPacketReceivedTimestamp));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "lastPacketReceivedTimestamp"_s), lastPacketReceivedTimestampValue);
    }
    if (!IDLDouble::isNullValue(dictionary.lastPacketSentTimestamp)) {
        auto lastPacketSentTimestampValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.lastPacketSentTimestamp));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "lastPacketSentTimestamp"_s), lastPacketSentTimestampValue);
    }
    auto localCandidateIdValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.localCandidateId);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "localCandidateId"_s), localCandidateIdValue);
    if (!IDLBoolean::isNullValue(dictionary.nominated)) {
        auto nominatedValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.nominated));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "nominated"_s), nominatedValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.packetsDiscardedOnSend)) {
        auto packetsDiscardedOnSendValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.packetsDiscardedOnSend));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "packetsDiscardedOnSend"_s), packetsDiscardedOnSendValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.packetsReceived)) {
        auto packetsReceivedValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.packetsReceived));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "packetsReceived"_s), packetsReceivedValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.packetsSent)) {
        auto packetsSentValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.packetsSent));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "packetsSent"_s), packetsSentValue);
    }
    auto remoteCandidateIdValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.remoteCandidateId);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "remoteCandidateId"_s), remoteCandidateIdValue);
    if (!IDLUnsignedLongLong::isNullValue(dictionary.requestsReceived)) {
        auto requestsReceivedValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.requestsReceived));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "requestsReceived"_s), requestsReceivedValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.requestsSent)) {
        auto requestsSentValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.requestsSent));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "requestsSent"_s), requestsSentValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.responsesReceived)) {
        auto responsesReceivedValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.responsesReceived));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "responsesReceived"_s), responsesReceivedValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.responsesSent)) {
        auto responsesSentValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.responsesSent));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "responsesSent"_s), responsesSentValue);
    }
    auto stateValue = toJS<IDLEnumeration<RTCStatsReport::IceCandidatePairState>>(lexicalGlobalObject, throwScope, dictionary.state);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "state"_s), stateValue);
    if (!IDLDouble::isNullValue(dictionary.totalRoundTripTime)) {
        auto totalRoundTripTimeValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.totalRoundTripTime));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "totalRoundTripTime"_s), totalRoundTripTimeValue);
    }
    auto transportIdValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.transportId);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "transportId"_s), transportIdValue);
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const RTCStatsReport::CertificateStats& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    auto idValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.id);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "id"_s), idValue);
    auto timestampValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, dictionary.timestamp);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "timestamp"_s), timestampValue);
    auto typeValue = toJS<IDLEnumeration<RTCStatsReport::Type>>(lexicalGlobalObject, throwScope, dictionary.type);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "type"_s), typeValue);
    auto base64CertificateValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.base64Certificate);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "base64Certificate"_s), base64CertificateValue);
    auto fingerprintValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.fingerprint);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "fingerprint"_s), fingerprintValue);
    auto fingerprintAlgorithmValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.fingerprintAlgorithm);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "fingerprintAlgorithm"_s), fingerprintAlgorithmValue);
    if (!IDLDOMString::isNullValue(dictionary.issuerCertificateId)) {
        auto issuerCertificateIdValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.issuerCertificateId));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "issuerCertificateId"_s), issuerCertificateIdValue);
    }
    return result;
}

// Functions

static JSC_DECLARE_HOST_FUNCTION(jsRTCStatsReportPrototypeFunction_get);
static JSC_DECLARE_HOST_FUNCTION(jsRTCStatsReportPrototypeFunction_has);
static JSC_DECLARE_HOST_FUNCTION(jsRTCStatsReportPrototypeFunction_entries);
static JSC_DECLARE_HOST_FUNCTION(jsRTCStatsReportPrototypeFunction_keys);
static JSC_DECLARE_HOST_FUNCTION(jsRTCStatsReportPrototypeFunction_values);
static JSC_DECLARE_HOST_FUNCTION(jsRTCStatsReportPrototypeFunction_forEach);

// Attributes

static JSC_DECLARE_CUSTOM_GETTER(jsRTCStatsReportConstructor);
static JSC_DECLARE_CUSTOM_GETTER(jsRTCStatsReport_size);

class JSRTCStatsReportPrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;
    static JSRTCStatsReportPrototype* create(JSC::VM& vm, JSDOMGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSRTCStatsReportPrototype* ptr = new (NotNull, JSC::allocateCell<JSRTCStatsReportPrototype>(vm)) JSRTCStatsReportPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSRTCStatsReportPrototype, Base);
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSRTCStatsReportPrototype(JSC::VM& vm, JSC::JSGlobalObject*, JSC::Structure* structure)
        : JSC::JSNonFinalObject(vm, structure)
    {
    }

    void finishCreation(JSC::VM&);
};
STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSRTCStatsReportPrototype, JSRTCStatsReportPrototype::Base);

using JSRTCStatsReportDOMConstructor = JSDOMConstructorNotConstructable<JSRTCStatsReport>;

template<> const ClassInfo JSRTCStatsReportDOMConstructor::s_info = { "RTCStatsReport"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSRTCStatsReportDOMConstructor) };

template<> JSValue JSRTCStatsReportDOMConstructor::prototypeForStructure(JSC::VM& vm, const JSDOMGlobalObject& globalObject)
{
    UNUSED_PARAM(vm);
    return globalObject.functionPrototype();
}

template<> void JSRTCStatsReportDOMConstructor::initializeProperties(VM& vm, JSDOMGlobalObject& globalObject)
{
    putDirect(vm, vm.propertyNames->length, jsNumber(0), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);
    JSString* nameString = jsNontrivialString(vm, "RTCStatsReport"_s);
    m_originalName.set(vm, this, nameString);
    putDirect(vm, vm.propertyNames->name, nameString, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);
    putDirect(vm, vm.propertyNames->prototype, JSRTCStatsReport::prototype(vm, globalObject), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::DontDelete);
}

/* Hash table for prototype */

static const std::array<HashTableValue, 8> JSRTCStatsReportPrototypeTableValues {
    HashTableValue { "constructor"_s, static_cast<unsigned>(PropertyAttribute::DontEnum), NoIntrinsic, { HashTableValue::GetterSetterType, jsRTCStatsReportConstructor, 0 } },
    HashTableValue { "size"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor, NoIntrinsic, { HashTableValue::GetterSetterType, jsRTCStatsReport_size, 0 } },
    HashTableValue { "get"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsRTCStatsReportPrototypeFunction_get, 1 } },
    HashTableValue { "has"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsRTCStatsReportPrototypeFunction_has, 1 } },
    HashTableValue { "entries"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsRTCStatsReportPrototypeFunction_entries, 0 } },
    HashTableValue { "keys"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsRTCStatsReportPrototypeFunction_keys, 0 } },
    HashTableValue { "values"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsRTCStatsReportPrototypeFunction_values, 0 } },
    HashTableValue { "forEach"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsRTCStatsReportPrototypeFunction_forEach, 1 } },
};

const ClassInfo JSRTCStatsReportPrototype::s_info = { "RTCStatsReport"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSRTCStatsReportPrototype) };

void JSRTCStatsReportPrototype::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSRTCStatsReport::info(), JSRTCStatsReportPrototypeTableValues, *this);
    putDirect(vm, vm.propertyNames->iteratorSymbol, getDirect(vm, vm.propertyNames->builtinNames().entriesPublicName()), static_cast<unsigned>(JSC::PropertyAttribute::DontEnum));
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

const ClassInfo JSRTCStatsReport::s_info = { "RTCStatsReport"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSRTCStatsReport) };

JSRTCStatsReport::JSRTCStatsReport(Structure* structure, JSDOMGlobalObject& globalObject, Ref<RTCStatsReport>&& impl)
    : JSDOMWrapper<RTCStatsReport>(structure, globalObject, WTFMove(impl))
{
}

static_assert(!std::is_base_of<ActiveDOMObject, RTCStatsReport>::value, "Interface is not marked as [ActiveDOMObject] even though implementation class subclasses ActiveDOMObject.");

JSObject* JSRTCStatsReport::createPrototype(VM& vm, JSDOMGlobalObject& globalObject)
{
    auto* structure = JSRTCStatsReportPrototype::createStructure(vm, &globalObject, globalObject.objectPrototype());
    structure->setMayBePrototype(true);
    return JSRTCStatsReportPrototype::create(vm, &globalObject, structure);
}

JSObject* JSRTCStatsReport::prototype(VM& vm, JSDOMGlobalObject& globalObject)
{
    return getDOMPrototype<JSRTCStatsReport>(vm, globalObject);
}

JSValue JSRTCStatsReport::getConstructor(VM& vm, const JSGlobalObject* globalObject)
{
    return getDOMConstructor<JSRTCStatsReportDOMConstructor, DOMConstructorID::RTCStatsReport>(vm, *jsCast<const JSDOMGlobalObject*>(globalObject));
}

void JSRTCStatsReport::destroy(JSC::JSCell* cell)
{
    JSRTCStatsReport* thisObject = static_cast<JSRTCStatsReport*>(cell);
    thisObject->JSRTCStatsReport::~JSRTCStatsReport();
}

JSC_DEFINE_CUSTOM_GETTER(jsRTCStatsReportConstructor, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* prototype = jsDynamicCast<JSRTCStatsReportPrototype*>(JSValue::decode(thisValue));
    if (!prototype) [[unlikely]]
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(JSRTCStatsReport::getConstructor(vm, prototype->globalObject()));
}

static inline JSValue jsRTCStatsReport_sizeGetter(JSGlobalObject& lexicalGlobalObject, JSRTCStatsReport& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    RELEASE_AND_RETURN(throwScope, (toJS<IDLAny>(lexicalGlobalObject, throwScope, forwardSizeToMapLike(lexicalGlobalObject, thisObject))));
}

JSC_DEFINE_CUSTOM_GETTER(jsRTCStatsReport_size, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCStatsReport>::get<jsRTCStatsReport_sizeGetter>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline JSC::EncodedJSValue jsRTCStatsReportPrototypeFunction_getBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSRTCStatsReport>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto keyConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (keyConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLAny>(*lexicalGlobalObject, throwScope, forwardGetToMapLike(*lexicalGlobalObject, *callFrame, *castedThis, keyConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsRTCStatsReportPrototypeFunction_get, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSRTCStatsReport>::call<jsRTCStatsReportPrototypeFunction_getBody>(*lexicalGlobalObject, *callFrame, "get");
}

static inline JSC::EncodedJSValue jsRTCStatsReportPrototypeFunction_hasBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSRTCStatsReport>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto keyConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (keyConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLAny>(*lexicalGlobalObject, throwScope, forwardHasToMapLike(*lexicalGlobalObject, *callFrame, *castedThis, keyConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsRTCStatsReportPrototypeFunction_has, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSRTCStatsReport>::call<jsRTCStatsReportPrototypeFunction_hasBody>(*lexicalGlobalObject, *callFrame, "has");
}

static inline JSC::EncodedJSValue jsRTCStatsReportPrototypeFunction_entriesBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSRTCStatsReport>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLAny>(*lexicalGlobalObject, throwScope, forwardEntriesToMapLike(*lexicalGlobalObject, *callFrame, *castedThis))));
}

JSC_DEFINE_HOST_FUNCTION(jsRTCStatsReportPrototypeFunction_entries, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSRTCStatsReport>::call<jsRTCStatsReportPrototypeFunction_entriesBody>(*lexicalGlobalObject, *callFrame, "entries");
}

static inline JSC::EncodedJSValue jsRTCStatsReportPrototypeFunction_keysBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSRTCStatsReport>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLAny>(*lexicalGlobalObject, throwScope, forwardKeysToMapLike(*lexicalGlobalObject, *callFrame, *castedThis))));
}

JSC_DEFINE_HOST_FUNCTION(jsRTCStatsReportPrototypeFunction_keys, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSRTCStatsReport>::call<jsRTCStatsReportPrototypeFunction_keysBody>(*lexicalGlobalObject, *callFrame, "keys");
}

static inline JSC::EncodedJSValue jsRTCStatsReportPrototypeFunction_valuesBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSRTCStatsReport>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLAny>(*lexicalGlobalObject, throwScope, forwardValuesToMapLike(*lexicalGlobalObject, *callFrame, *castedThis))));
}

JSC_DEFINE_HOST_FUNCTION(jsRTCStatsReportPrototypeFunction_values, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSRTCStatsReport>::call<jsRTCStatsReportPrototypeFunction_valuesBody>(*lexicalGlobalObject, *callFrame, "values");
}

static inline JSC::EncodedJSValue jsRTCStatsReportPrototypeFunction_forEachBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSRTCStatsReport>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto callbackConversionResult = convert<IDLAny>(*lexicalGlobalObject, argument0.value());
    if (callbackConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLAny>(*lexicalGlobalObject, throwScope, forwardForEachToMapLike(*lexicalGlobalObject, *callFrame, *castedThis, callbackConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsRTCStatsReportPrototypeFunction_forEach, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSRTCStatsReport>::call<jsRTCStatsReportPrototypeFunction_forEachBody>(*lexicalGlobalObject, *callFrame, "forEach");
}

JSC::GCClient::IsoSubspace* JSRTCStatsReport::subspaceForImpl(JSC::VM& vm)
{
    return WebCore::subspaceForImpl<JSRTCStatsReport, UseCustomHeapCellType::No>(vm, "JSRTCStatsReport"_s,
        [] (auto& spaces) { return spaces.m_clientSubspaceForRTCStatsReport.get(); },
        [] (auto& spaces, auto&& space) { spaces.m_clientSubspaceForRTCStatsReport = std::forward<decltype(space)>(space); },
        [] (auto& spaces) { return spaces.m_subspaceForRTCStatsReport.get(); },
        [] (auto& spaces, auto&& space) { spaces.m_subspaceForRTCStatsReport = std::forward<decltype(space)>(space); }
    );
}

void JSRTCStatsReport::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSRTCStatsReport*>(cell);
    analyzer.setWrappedObjectForCell(cell, &thisObject->wrapped());
    if (RefPtr context = thisObject->scriptExecutionContext())
        analyzer.setLabelForCell(cell, makeString("url "_s, context->url().string()));
    Base::analyzeHeap(cell, analyzer);
}

bool JSRTCStatsReportOwner::isReachableFromOpaqueRoots(JSC::Handle<JSC::Unknown> handle, void*, AbstractSlotVisitor& visitor, ASCIILiteral* reason)
{
    UNUSED_PARAM(handle);
    UNUSED_PARAM(visitor);
    UNUSED_PARAM(reason);
    return false;
}

void JSRTCStatsReportOwner::finalize(JSC::Handle<JSC::Unknown> handle, void* context)
{
    auto* jsRTCStatsReport = static_cast<JSRTCStatsReport*>(handle.slot()->asCell());
    auto& world = *static_cast<DOMWrapperWorld*>(context);
    uncacheWrapper(world, jsRTCStatsReport->protectedWrapped().ptr(), jsRTCStatsReport);
}

WTF_ALLOW_UNSAFE_BUFFER_USAGE_BEGIN
#if ENABLE(BINDING_INTEGRITY)
#if PLATFORM(WIN)
#pragma warning(disable: 4483)
extern "C" { extern void (*const __identifier("??_7RTCStatsReport@WebCore@@6B@")[])(); }
#else
extern "C" { extern void* _ZTVN7WebCore14RTCStatsReportE[]; }
#endif
template<std::same_as<RTCStatsReport> T>
static inline void verifyVTable(RTCStatsReport* ptr) 
{
    if constexpr (std::is_polymorphic_v<T>) {
        const void* actualVTablePointer = getVTablePointer<T>(ptr);
#if PLATFORM(WIN)
        void* expectedVTablePointer = __identifier("??_7RTCStatsReport@WebCore@@6B@");
#else
        void* expectedVTablePointer = &_ZTVN7WebCore14RTCStatsReportE[2];
#endif

        // If you hit this assertion you either have a use after free bug, or
        // RTCStatsReport has subclasses. If RTCStatsReport has subclasses that get passed
        // to toJS() we currently require RTCStatsReport you to opt out of binding hardening
        // by adding the SkipVTableValidation attribute to the interface IDL definition
        RELEASE_ASSERT(actualVTablePointer == expectedVTablePointer);
    }
}
#endif
WTF_ALLOW_UNSAFE_BUFFER_USAGE_END

JSC::JSValue toJSNewlyCreated(JSC::JSGlobalObject*, JSDOMGlobalObject* globalObject, Ref<RTCStatsReport>&& impl)
{
#if ENABLE(BINDING_INTEGRITY)
    verifyVTable<RTCStatsReport>(impl.ptr());
#endif
    return createWrapper<RTCStatsReport>(globalObject, WTFMove(impl));
}

JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, RTCStatsReport& impl)
{
    return wrap(lexicalGlobalObject, globalObject, impl);
}

RTCStatsReport* JSRTCStatsReport::toWrapped(JSC::VM&, JSC::JSValue value)
{
    if (auto* wrapper = jsDynamicCast<JSRTCStatsReport*>(value))
        return &wrapper->wrapped();
    return nullptr;
}

}

#endif // ENABLE(WEB_RTC)
