/*
    This file is part of the WebKit open source project.
    This file has been generated by generate-bindings.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.
*/

#include "config.h"
#include "JSInternals.h"

#include "ActiveDOMObject.h"
#include "ContextDestructionObserverInlines.h"
#include "DOMPromiseProxy.h"
#include "Document.h"
#include "ExtendedDOMClientIsoSubspaces.h"
#include "ExtendedDOMIsoSubspaces.h"
#include "IDLTypes.h"
#include "JSAbstractRange.h"
#include "JSBlob.h"
#include "JSCSSStyleDeclaration.h"
#include "JSDOMAttribute.h"
#include "JSDOMBinding.h"
#include "JSDOMConvertAny.h"
#include "JSDOMConvertBase.h"
#include "JSDOMConvertBoolean.h"
#include "JSDOMConvertBufferSource.h"
#include "JSDOMConvertCallbacks.h"
#include "JSDOMConvertEventListener.h"
#include "JSDOMConvertInterface.h"
#include "JSDOMConvertNullable.h"
#include "JSDOMConvertNumbers.h"
#include "JSDOMConvertOptional.h"
#include "JSDOMConvertPromise.h"
#include "JSDOMConvertSequences.h"
#include "JSDOMConvertSerializedScriptValue.h"
#include "JSDOMConvertStrings.h"
#include "JSDOMConvertUnion.h"
#include "JSDOMExceptionHandling.h"
#include "JSDOMGlobalObject.h"
#include "JSDOMOperation.h"
#include "JSDOMOperationReturningPromise.h"
#include "JSDOMPointReadOnly.h"
#include "JSDOMRect.h"
#include "JSDOMRectList.h"
#include "JSDOMRectReadOnly.h"
#include "JSDOMURL.h"
#include "JSDOMWindow.h"
#include "JSDOMWrapperCache.h"
#include "JSDocument.h"
#include "JSElement.h"
#include "JSEventListener.h"
#include "JSFetchRequest.h"
#include "JSFetchResponse.h"
#include "JSFile.h"
#include "JSGCObservation.h"
#include "JSHTMLCanvasElement.h"
#include "JSHTMLImageElement.h"
#include "JSHTMLInputElement.h"
#include "JSHTMLLinkElement.h"
#include "JSHTMLSelectElement.h"
#include "JSImageData.h"
#include "JSInternalSettings.h"
#include "JSInternalsMapLike.h"
#include "JSInternalsSetLike.h"
#include "JSMallocStatistics.h"
#include "JSMemoryInfo.h"
#include "JSMessagePort.h"
#include "JSMockPageOverlay.h"
#include "JSNode.h"
#include "JSNodeList.h"
#include "JSPushSubscription.h"
#include "JSRange.h"
#include "JSReadableStream.h"
#include "JSSVGSVGElement.h"
#include "JSServiceWorker.h"
#include "JSStaticRange.h"
#include "JSStringCallback.h"
#include "JSTypeConversions.h"
#include "JSVideoConfiguration.h"
#include "JSVoidCallback.h"
#include "JSWebAnimation.h"
#include "JSWindowProxy.h"
#include "JSXMLHttpRequest.h"
#include "ScriptExecutionContext.h"
#include "SerializedScriptValue.h"
#include "WebCoreJSClientData.h"
#include <JavaScriptCore/HeapAnalyzer.h>
#include <JavaScriptCore/JSArray.h>
#include <JavaScriptCore/JSCInlines.h>
#include <JavaScriptCore/JSDestructibleObjectHeapCellType.h>
#include <JavaScriptCore/JSString.h>
#include <JavaScriptCore/ObjectConstructor.h>
#include <JavaScriptCore/SlotVisitorMacros.h>
#include <JavaScriptCore/SubspaceInlines.h>
#include <wtf/GetPtr.h>
#include <wtf/PointerPreparations.h>
#include <wtf/SortedArrayMap.h>
#include <wtf/URL.h>
#include <wtf/Variant.h>
#include <wtf/text/MakeString.h>

#if ENABLE(ARKIT_INLINE_PREVIEW_MAC) || ENABLE(MODEL_ELEMENT)
#include "JSHTMLModelElement.h"
#endif

#if ENABLE(CONTENT_FILTERING)
#include "JSMockContentFilterSettings.h"
#endif

#if ENABLE(ENCRYPTED_MEDIA)
#include "JSMediaKeySession.h"
#include "JSMediaKeys.h"
#include "JSMockCDMFactory.h"
#endif

#if ENABLE(MEDIA_SESSION)
#include "JSMediaSession.h"
#include "JSMediaSessionActionDetails.h"
#endif

#if ENABLE(MEDIA_SESSION) && ENABLE(WEB_CODECS)
#include "JSWebCodecsVideoFrame.h"
#endif

#if ENABLE(MEDIA_SOURCE)
#include "JSSourceBuffer.h"
#endif

#if ENABLE(MEDIA_STREAM)
#include "JSAudioTrack.h"
#include "JSMediaStream.h"
#include "JSMediaStreamTrack.h"
#endif

#if ENABLE(SPEECH_SYNTHESIS)
#include "JSSpeechSynthesisUtterance.h"
#include "JSVTTCue.h"
#endif

#if ENABLE(SPEECH_SYNTHESIS) || ENABLE(VIDEO)
#include "JSHTMLMediaElement.h"
#endif

#if ENABLE(VIDEO)
#include "JSEventTarget.h"
#include "JSHTMLVideoElement.h"
#include "JSTextTrack.h"
#include "JSTextTrackCueGeneric.h"
#include "JSTimeRanges.h"
#endif

#if ENABLE(WEBGL)
#include "JSWebGLRenderingContext.h"
#endif

#if ENABLE(WEB_AUDIO)
#include "JSAudioContext.h"
#include "JSBaseAudioContext.h"
#endif

#if ENABLE(WEB_AUTHN)
#include "JSMockWebAuthenticationConfiguration.h"
#endif

#if ENABLE(WEB_CODECS)
#include "JSWebCodecsVideoDecoder.h"
#endif

#if ENABLE(WEB_RTC)
#include "JSRTCPeerConnection.h"
#include "JSRTCRtpSFrameTransform.h"
#endif

namespace WebCore {
using namespace JSC;

String convertEnumerationToString(Internals::PageOverlayType enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 2> values {
        MAKE_STATIC_STRING_IMPL("view"),
        MAKE_STATIC_STRING_IMPL("document"),
    };
    static_assert(static_cast<size_t>(Internals::PageOverlayType::View) == 0, "Internals::PageOverlayType::View is not 0 as expected");
    static_assert(static_cast<size_t>(Internals::PageOverlayType::Document) == 1, "Internals::PageOverlayType::Document is not 1 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, Internals::PageOverlayType enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<Internals::PageOverlayType> parseEnumerationFromString<Internals::PageOverlayType>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, Internals::PageOverlayType>, 2> mappings {
        std::pair<ComparableASCIILiteral, Internals::PageOverlayType> { "document"_s, Internals::PageOverlayType::Document },
        std::pair<ComparableASCIILiteral, Internals::PageOverlayType> { "view"_s, Internals::PageOverlayType::View },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<Internals::PageOverlayType> parseEnumeration<Internals::PageOverlayType>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<Internals::PageOverlayType>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<Internals::PageOverlayType>()
{
    return "\"view\", \"document\""_s;
}

String convertEnumerationToString(Internals::CachePolicy enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 4> values {
        MAKE_STATIC_STRING_IMPL("UseProtocolCachePolicy"),
        MAKE_STATIC_STRING_IMPL("ReloadIgnoringCacheData"),
        MAKE_STATIC_STRING_IMPL("ReturnCacheDataElseLoad"),
        MAKE_STATIC_STRING_IMPL("ReturnCacheDataDontLoad"),
    };
    static_assert(static_cast<size_t>(Internals::CachePolicy::UseProtocolCachePolicy) == 0, "Internals::CachePolicy::UseProtocolCachePolicy is not 0 as expected");
    static_assert(static_cast<size_t>(Internals::CachePolicy::ReloadIgnoringCacheData) == 1, "Internals::CachePolicy::ReloadIgnoringCacheData is not 1 as expected");
    static_assert(static_cast<size_t>(Internals::CachePolicy::ReturnCacheDataElseLoad) == 2, "Internals::CachePolicy::ReturnCacheDataElseLoad is not 2 as expected");
    static_assert(static_cast<size_t>(Internals::CachePolicy::ReturnCacheDataDontLoad) == 3, "Internals::CachePolicy::ReturnCacheDataDontLoad is not 3 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, Internals::CachePolicy enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<Internals::CachePolicy> parseEnumerationFromString<Internals::CachePolicy>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, Internals::CachePolicy>, 4> mappings {
        std::pair<ComparableASCIILiteral, Internals::CachePolicy> { "ReloadIgnoringCacheData"_s, Internals::CachePolicy::ReloadIgnoringCacheData },
        std::pair<ComparableASCIILiteral, Internals::CachePolicy> { "ReturnCacheDataDontLoad"_s, Internals::CachePolicy::ReturnCacheDataDontLoad },
        std::pair<ComparableASCIILiteral, Internals::CachePolicy> { "ReturnCacheDataElseLoad"_s, Internals::CachePolicy::ReturnCacheDataElseLoad },
        std::pair<ComparableASCIILiteral, Internals::CachePolicy> { "UseProtocolCachePolicy"_s, Internals::CachePolicy::UseProtocolCachePolicy },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<Internals::CachePolicy> parseEnumeration<Internals::CachePolicy>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<Internals::CachePolicy>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<Internals::CachePolicy>()
{
    return "\"UseProtocolCachePolicy\", \"ReloadIgnoringCacheData\", \"ReturnCacheDataElseLoad\", \"ReturnCacheDataDontLoad\""_s;
}

String convertEnumerationToString(Internals::ResourceLoadPriority enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 5> values {
        MAKE_STATIC_STRING_IMPL("ResourceLoadPriorityVeryLow"),
        MAKE_STATIC_STRING_IMPL("ResourceLoadPriorityLow"),
        MAKE_STATIC_STRING_IMPL("ResourceLoadPriorityMedium"),
        MAKE_STATIC_STRING_IMPL("ResourceLoadPriorityHigh"),
        MAKE_STATIC_STRING_IMPL("ResourceLoadPriorityVeryHigh"),
    };
    static_assert(static_cast<size_t>(Internals::ResourceLoadPriority::ResourceLoadPriorityVeryLow) == 0, "Internals::ResourceLoadPriority::ResourceLoadPriorityVeryLow is not 0 as expected");
    static_assert(static_cast<size_t>(Internals::ResourceLoadPriority::ResourceLoadPriorityLow) == 1, "Internals::ResourceLoadPriority::ResourceLoadPriorityLow is not 1 as expected");
    static_assert(static_cast<size_t>(Internals::ResourceLoadPriority::ResourceLoadPriorityMedium) == 2, "Internals::ResourceLoadPriority::ResourceLoadPriorityMedium is not 2 as expected");
    static_assert(static_cast<size_t>(Internals::ResourceLoadPriority::ResourceLoadPriorityHigh) == 3, "Internals::ResourceLoadPriority::ResourceLoadPriorityHigh is not 3 as expected");
    static_assert(static_cast<size_t>(Internals::ResourceLoadPriority::ResourceLoadPriorityVeryHigh) == 4, "Internals::ResourceLoadPriority::ResourceLoadPriorityVeryHigh is not 4 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, Internals::ResourceLoadPriority enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<Internals::ResourceLoadPriority> parseEnumerationFromString<Internals::ResourceLoadPriority>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, Internals::ResourceLoadPriority>, 5> mappings {
        std::pair<ComparableASCIILiteral, Internals::ResourceLoadPriority> { "ResourceLoadPriorityHigh"_s, Internals::ResourceLoadPriority::ResourceLoadPriorityHigh },
        std::pair<ComparableASCIILiteral, Internals::ResourceLoadPriority> { "ResourceLoadPriorityLow"_s, Internals::ResourceLoadPriority::ResourceLoadPriorityLow },
        std::pair<ComparableASCIILiteral, Internals::ResourceLoadPriority> { "ResourceLoadPriorityMedium"_s, Internals::ResourceLoadPriority::ResourceLoadPriorityMedium },
        std::pair<ComparableASCIILiteral, Internals::ResourceLoadPriority> { "ResourceLoadPriorityVeryHigh"_s, Internals::ResourceLoadPriority::ResourceLoadPriorityVeryHigh },
        std::pair<ComparableASCIILiteral, Internals::ResourceLoadPriority> { "ResourceLoadPriorityVeryLow"_s, Internals::ResourceLoadPriority::ResourceLoadPriorityVeryLow },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<Internals::ResourceLoadPriority> parseEnumeration<Internals::ResourceLoadPriority>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<Internals::ResourceLoadPriority>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<Internals::ResourceLoadPriority>()
{
    return "\"ResourceLoadPriorityVeryLow\", \"ResourceLoadPriorityLow\", \"ResourceLoadPriorityMedium\", \"ResourceLoadPriorityHigh\", \"ResourceLoadPriorityVeryHigh\""_s;
}

String convertEnumerationToString(Internals::AutoFillButtonType enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 6> values {
        MAKE_STATIC_STRING_IMPL("None"),
        MAKE_STATIC_STRING_IMPL("Contacts"),
        MAKE_STATIC_STRING_IMPL("Credentials"),
        MAKE_STATIC_STRING_IMPL("StrongPassword"),
        MAKE_STATIC_STRING_IMPL("CreditCard"),
        MAKE_STATIC_STRING_IMPL("Loading"),
    };
    static_assert(static_cast<size_t>(Internals::AutoFillButtonType::None) == 0, "Internals::AutoFillButtonType::None is not 0 as expected");
    static_assert(static_cast<size_t>(Internals::AutoFillButtonType::Contacts) == 1, "Internals::AutoFillButtonType::Contacts is not 1 as expected");
    static_assert(static_cast<size_t>(Internals::AutoFillButtonType::Credentials) == 2, "Internals::AutoFillButtonType::Credentials is not 2 as expected");
    static_assert(static_cast<size_t>(Internals::AutoFillButtonType::StrongPassword) == 3, "Internals::AutoFillButtonType::StrongPassword is not 3 as expected");
    static_assert(static_cast<size_t>(Internals::AutoFillButtonType::CreditCard) == 4, "Internals::AutoFillButtonType::CreditCard is not 4 as expected");
    static_assert(static_cast<size_t>(Internals::AutoFillButtonType::Loading) == 5, "Internals::AutoFillButtonType::Loading is not 5 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, Internals::AutoFillButtonType enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<Internals::AutoFillButtonType> parseEnumerationFromString<Internals::AutoFillButtonType>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, Internals::AutoFillButtonType>, 6> mappings {
        std::pair<ComparableASCIILiteral, Internals::AutoFillButtonType> { "Contacts"_s, Internals::AutoFillButtonType::Contacts },
        std::pair<ComparableASCIILiteral, Internals::AutoFillButtonType> { "Credentials"_s, Internals::AutoFillButtonType::Credentials },
        std::pair<ComparableASCIILiteral, Internals::AutoFillButtonType> { "CreditCard"_s, Internals::AutoFillButtonType::CreditCard },
        std::pair<ComparableASCIILiteral, Internals::AutoFillButtonType> { "Loading"_s, Internals::AutoFillButtonType::Loading },
        std::pair<ComparableASCIILiteral, Internals::AutoFillButtonType> { "None"_s, Internals::AutoFillButtonType::None },
        std::pair<ComparableASCIILiteral, Internals::AutoFillButtonType> { "StrongPassword"_s, Internals::AutoFillButtonType::StrongPassword },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<Internals::AutoFillButtonType> parseEnumeration<Internals::AutoFillButtonType>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<Internals::AutoFillButtonType>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<Internals::AutoFillButtonType>()
{
    return "\"None\", \"Contacts\", \"Credentials\", \"StrongPassword\", \"CreditCard\", \"Loading\""_s;
}

String convertEnumerationToString(Internals::UserInterfaceLayoutDirection enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 2> values {
        MAKE_STATIC_STRING_IMPL("LTR"),
        MAKE_STATIC_STRING_IMPL("RTL"),
    };
    static_assert(static_cast<size_t>(Internals::UserInterfaceLayoutDirection::LTR) == 0, "Internals::UserInterfaceLayoutDirection::LTR is not 0 as expected");
    static_assert(static_cast<size_t>(Internals::UserInterfaceLayoutDirection::RTL) == 1, "Internals::UserInterfaceLayoutDirection::RTL is not 1 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, Internals::UserInterfaceLayoutDirection enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<Internals::UserInterfaceLayoutDirection> parseEnumerationFromString<Internals::UserInterfaceLayoutDirection>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, Internals::UserInterfaceLayoutDirection>, 2> mappings {
        std::pair<ComparableASCIILiteral, Internals::UserInterfaceLayoutDirection> { "LTR"_s, Internals::UserInterfaceLayoutDirection::LTR },
        std::pair<ComparableASCIILiteral, Internals::UserInterfaceLayoutDirection> { "RTL"_s, Internals::UserInterfaceLayoutDirection::RTL },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<Internals::UserInterfaceLayoutDirection> parseEnumeration<Internals::UserInterfaceLayoutDirection>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<Internals::UserInterfaceLayoutDirection>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<Internals::UserInterfaceLayoutDirection>()
{
    return "\"LTR\", \"RTL\""_s;
}

String convertEnumerationToString(Internals::BaseWritingDirection enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 3> values {
        MAKE_STATIC_STRING_IMPL("Natural"),
        MAKE_STATIC_STRING_IMPL("Ltr"),
        MAKE_STATIC_STRING_IMPL("Rtl"),
    };
    static_assert(static_cast<size_t>(Internals::BaseWritingDirection::Natural) == 0, "Internals::BaseWritingDirection::Natural is not 0 as expected");
    static_assert(static_cast<size_t>(Internals::BaseWritingDirection::Ltr) == 1, "Internals::BaseWritingDirection::Ltr is not 1 as expected");
    static_assert(static_cast<size_t>(Internals::BaseWritingDirection::Rtl) == 2, "Internals::BaseWritingDirection::Rtl is not 2 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, Internals::BaseWritingDirection enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<Internals::BaseWritingDirection> parseEnumerationFromString<Internals::BaseWritingDirection>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, Internals::BaseWritingDirection>, 3> mappings {
        std::pair<ComparableASCIILiteral, Internals::BaseWritingDirection> { "Ltr"_s, Internals::BaseWritingDirection::Ltr },
        std::pair<ComparableASCIILiteral, Internals::BaseWritingDirection> { "Natural"_s, Internals::BaseWritingDirection::Natural },
        std::pair<ComparableASCIILiteral, Internals::BaseWritingDirection> { "Rtl"_s, Internals::BaseWritingDirection::Rtl },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<Internals::BaseWritingDirection> parseEnumeration<Internals::BaseWritingDirection>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<Internals::BaseWritingDirection>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<Internals::BaseWritingDirection>()
{
    return "\"Natural\", \"Ltr\", \"Rtl\""_s;
}

String convertEnumerationToString(Internals::EventThrottlingBehavior enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 2> values {
        MAKE_STATIC_STRING_IMPL("responsive"),
        MAKE_STATIC_STRING_IMPL("unresponsive"),
    };
    static_assert(static_cast<size_t>(Internals::EventThrottlingBehavior::Responsive) == 0, "Internals::EventThrottlingBehavior::Responsive is not 0 as expected");
    static_assert(static_cast<size_t>(Internals::EventThrottlingBehavior::Unresponsive) == 1, "Internals::EventThrottlingBehavior::Unresponsive is not 1 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, Internals::EventThrottlingBehavior enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<Internals::EventThrottlingBehavior> parseEnumerationFromString<Internals::EventThrottlingBehavior>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, Internals::EventThrottlingBehavior>, 2> mappings {
        std::pair<ComparableASCIILiteral, Internals::EventThrottlingBehavior> { "responsive"_s, Internals::EventThrottlingBehavior::Responsive },
        std::pair<ComparableASCIILiteral, Internals::EventThrottlingBehavior> { "unresponsive"_s, Internals::EventThrottlingBehavior::Unresponsive },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<Internals::EventThrottlingBehavior> parseEnumeration<Internals::EventThrottlingBehavior>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<Internals::EventThrottlingBehavior>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<Internals::EventThrottlingBehavior>()
{
    return "\"responsive\", \"unresponsive\""_s;
}

String convertEnumerationToString(Internals::CompositingPolicy enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 2> values {
        MAKE_STATIC_STRING_IMPL("normal"),
        MAKE_STATIC_STRING_IMPL("conservative"),
    };
    static_assert(static_cast<size_t>(Internals::CompositingPolicy::Normal) == 0, "Internals::CompositingPolicy::Normal is not 0 as expected");
    static_assert(static_cast<size_t>(Internals::CompositingPolicy::Conservative) == 1, "Internals::CompositingPolicy::Conservative is not 1 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, Internals::CompositingPolicy enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<Internals::CompositingPolicy> parseEnumerationFromString<Internals::CompositingPolicy>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, Internals::CompositingPolicy>, 2> mappings {
        std::pair<ComparableASCIILiteral, Internals::CompositingPolicy> { "conservative"_s, Internals::CompositingPolicy::Conservative },
        std::pair<ComparableASCIILiteral, Internals::CompositingPolicy> { "normal"_s, Internals::CompositingPolicy::Normal },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<Internals::CompositingPolicy> parseEnumeration<Internals::CompositingPolicy>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<Internals::CompositingPolicy>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<Internals::CompositingPolicy>()
{
    return "\"normal\", \"conservative\""_s;
}

#if ENABLE(VIDEO)

String convertEnumerationToString(Internals::PlaybackControlsPurpose enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 2> values {
        MAKE_STATIC_STRING_IMPL("ControlsManager"),
        MAKE_STATIC_STRING_IMPL("NowPlaying"),
    };
    static_assert(static_cast<size_t>(Internals::PlaybackControlsPurpose::ControlsManager) == 0, "Internals::PlaybackControlsPurpose::ControlsManager is not 0 as expected");
    static_assert(static_cast<size_t>(Internals::PlaybackControlsPurpose::NowPlaying) == 1, "Internals::PlaybackControlsPurpose::NowPlaying is not 1 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, Internals::PlaybackControlsPurpose enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<Internals::PlaybackControlsPurpose> parseEnumerationFromString<Internals::PlaybackControlsPurpose>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, Internals::PlaybackControlsPurpose>, 2> mappings {
        std::pair<ComparableASCIILiteral, Internals::PlaybackControlsPurpose> { "ControlsManager"_s, Internals::PlaybackControlsPurpose::ControlsManager },
        std::pair<ComparableASCIILiteral, Internals::PlaybackControlsPurpose> { "NowPlaying"_s, Internals::PlaybackControlsPurpose::NowPlaying },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<Internals::PlaybackControlsPurpose> parseEnumeration<Internals::PlaybackControlsPurpose>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<Internals::PlaybackControlsPurpose>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<Internals::PlaybackControlsPurpose>()
{
    return "\"ControlsManager\", \"NowPlaying\""_s;
}

#endif

#if ENABLE(VIDEO)

String convertEnumerationToString(Internals::MediaSessionState enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 5> values {
        MAKE_STATIC_STRING_IMPL("Idle"),
        MAKE_STATIC_STRING_IMPL("Autoplaying"),
        MAKE_STATIC_STRING_IMPL("Playing"),
        MAKE_STATIC_STRING_IMPL("Paused"),
        MAKE_STATIC_STRING_IMPL("Interrupted"),
    };
    static_assert(static_cast<size_t>(Internals::MediaSessionState::Idle) == 0, "Internals::MediaSessionState::Idle is not 0 as expected");
    static_assert(static_cast<size_t>(Internals::MediaSessionState::Autoplaying) == 1, "Internals::MediaSessionState::Autoplaying is not 1 as expected");
    static_assert(static_cast<size_t>(Internals::MediaSessionState::Playing) == 2, "Internals::MediaSessionState::Playing is not 2 as expected");
    static_assert(static_cast<size_t>(Internals::MediaSessionState::Paused) == 3, "Internals::MediaSessionState::Paused is not 3 as expected");
    static_assert(static_cast<size_t>(Internals::MediaSessionState::Interrupted) == 4, "Internals::MediaSessionState::Interrupted is not 4 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, Internals::MediaSessionState enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<Internals::MediaSessionState> parseEnumerationFromString<Internals::MediaSessionState>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, Internals::MediaSessionState>, 5> mappings {
        std::pair<ComparableASCIILiteral, Internals::MediaSessionState> { "Autoplaying"_s, Internals::MediaSessionState::Autoplaying },
        std::pair<ComparableASCIILiteral, Internals::MediaSessionState> { "Idle"_s, Internals::MediaSessionState::Idle },
        std::pair<ComparableASCIILiteral, Internals::MediaSessionState> { "Interrupted"_s, Internals::MediaSessionState::Interrupted },
        std::pair<ComparableASCIILiteral, Internals::MediaSessionState> { "Paused"_s, Internals::MediaSessionState::Paused },
        std::pair<ComparableASCIILiteral, Internals::MediaSessionState> { "Playing"_s, Internals::MediaSessionState::Playing },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<Internals::MediaSessionState> parseEnumeration<Internals::MediaSessionState>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<Internals::MediaSessionState>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<Internals::MediaSessionState>()
{
    return "\"Idle\", \"Autoplaying\", \"Playing\", \"Paused\", \"Interrupted\""_s;
}

#endif

String convertEnumerationToString(Internals::ContentSizeCategory enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 2> values {
        MAKE_STATIC_STRING_IMPL("L"),
        MAKE_STATIC_STRING_IMPL("XXXL"),
    };
    static_assert(static_cast<size_t>(Internals::ContentSizeCategory::L) == 0, "Internals::ContentSizeCategory::L is not 0 as expected");
    static_assert(static_cast<size_t>(Internals::ContentSizeCategory::XXXL) == 1, "Internals::ContentSizeCategory::XXXL is not 1 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, Internals::ContentSizeCategory enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<Internals::ContentSizeCategory> parseEnumerationFromString<Internals::ContentSizeCategory>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, Internals::ContentSizeCategory>, 2> mappings {
        std::pair<ComparableASCIILiteral, Internals::ContentSizeCategory> { "L"_s, Internals::ContentSizeCategory::L },
        std::pair<ComparableASCIILiteral, Internals::ContentSizeCategory> { "XXXL"_s, Internals::ContentSizeCategory::XXXL },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<Internals::ContentSizeCategory> parseEnumeration<Internals::ContentSizeCategory>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<Internals::ContentSizeCategory>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<Internals::ContentSizeCategory>()
{
    return "\"L\", \"XXXL\""_s;
}

String convertEnumerationToString(Internals::TreeType enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 3> values {
        MAKE_STATIC_STRING_IMPL("Tree"),
        MAKE_STATIC_STRING_IMPL("ShadowIncludingTree"),
        MAKE_STATIC_STRING_IMPL("ComposedTree"),
    };
    static_assert(static_cast<size_t>(Internals::TreeType::Tree) == 0, "Internals::TreeType::Tree is not 0 as expected");
    static_assert(static_cast<size_t>(Internals::TreeType::ShadowIncludingTree) == 1, "Internals::TreeType::ShadowIncludingTree is not 1 as expected");
    static_assert(static_cast<size_t>(Internals::TreeType::ComposedTree) == 2, "Internals::TreeType::ComposedTree is not 2 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, Internals::TreeType enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<Internals::TreeType> parseEnumerationFromString<Internals::TreeType>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, Internals::TreeType>, 3> mappings {
        std::pair<ComparableASCIILiteral, Internals::TreeType> { "ComposedTree"_s, Internals::TreeType::ComposedTree },
        std::pair<ComparableASCIILiteral, Internals::TreeType> { "ShadowIncludingTree"_s, Internals::TreeType::ShadowIncludingTree },
        std::pair<ComparableASCIILiteral, Internals::TreeType> { "Tree"_s, Internals::TreeType::Tree },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<Internals::TreeType> parseEnumeration<Internals::TreeType>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<Internals::TreeType>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<Internals::TreeType>()
{
    return "\"Tree\", \"ShadowIncludingTree\", \"ComposedTree\""_s;
}

#if ENABLE(WEBGL)

String convertEnumerationToString(Internals::SimulatedWebGLContextEvent enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 2> values {
        MAKE_STATIC_STRING_IMPL("GPUStatusFailure"),
        MAKE_STATIC_STRING_IMPL("Timeout"),
    };
    static_assert(static_cast<size_t>(Internals::SimulatedWebGLContextEvent::GPUStatusFailure) == 0, "Internals::SimulatedWebGLContextEvent::GPUStatusFailure is not 0 as expected");
    static_assert(static_cast<size_t>(Internals::SimulatedWebGLContextEvent::Timeout) == 1, "Internals::SimulatedWebGLContextEvent::Timeout is not 1 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, Internals::SimulatedWebGLContextEvent enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<Internals::SimulatedWebGLContextEvent> parseEnumerationFromString<Internals::SimulatedWebGLContextEvent>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, Internals::SimulatedWebGLContextEvent>, 2> mappings {
        std::pair<ComparableASCIILiteral, Internals::SimulatedWebGLContextEvent> { "GPUStatusFailure"_s, Internals::SimulatedWebGLContextEvent::GPUStatusFailure },
        std::pair<ComparableASCIILiteral, Internals::SimulatedWebGLContextEvent> { "Timeout"_s, Internals::SimulatedWebGLContextEvent::Timeout },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<Internals::SimulatedWebGLContextEvent> parseEnumeration<Internals::SimulatedWebGLContextEvent>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<Internals::SimulatedWebGLContextEvent>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<Internals::SimulatedWebGLContextEvent>()
{
    return "\"GPUStatusFailure\", \"Timeout\""_s;
}

#endif

String convertEnumerationToString(Internals::AudioSessionCategory enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 7> values {
        MAKE_STATIC_STRING_IMPL("None"),
        MAKE_STATIC_STRING_IMPL("AmbientSound"),
        MAKE_STATIC_STRING_IMPL("SoloAmbientSound"),
        MAKE_STATIC_STRING_IMPL("MediaPlayback"),
        MAKE_STATIC_STRING_IMPL("RecordAudio"),
        MAKE_STATIC_STRING_IMPL("PlayAndRecord"),
        MAKE_STATIC_STRING_IMPL("AudioProcessing"),
    };
    static_assert(static_cast<size_t>(Internals::AudioSessionCategory::None) == 0, "Internals::AudioSessionCategory::None is not 0 as expected");
    static_assert(static_cast<size_t>(Internals::AudioSessionCategory::AmbientSound) == 1, "Internals::AudioSessionCategory::AmbientSound is not 1 as expected");
    static_assert(static_cast<size_t>(Internals::AudioSessionCategory::SoloAmbientSound) == 2, "Internals::AudioSessionCategory::SoloAmbientSound is not 2 as expected");
    static_assert(static_cast<size_t>(Internals::AudioSessionCategory::MediaPlayback) == 3, "Internals::AudioSessionCategory::MediaPlayback is not 3 as expected");
    static_assert(static_cast<size_t>(Internals::AudioSessionCategory::RecordAudio) == 4, "Internals::AudioSessionCategory::RecordAudio is not 4 as expected");
    static_assert(static_cast<size_t>(Internals::AudioSessionCategory::PlayAndRecord) == 5, "Internals::AudioSessionCategory::PlayAndRecord is not 5 as expected");
    static_assert(static_cast<size_t>(Internals::AudioSessionCategory::AudioProcessing) == 6, "Internals::AudioSessionCategory::AudioProcessing is not 6 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, Internals::AudioSessionCategory enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<Internals::AudioSessionCategory> parseEnumerationFromString<Internals::AudioSessionCategory>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, Internals::AudioSessionCategory>, 7> mappings {
        std::pair<ComparableASCIILiteral, Internals::AudioSessionCategory> { "AmbientSound"_s, Internals::AudioSessionCategory::AmbientSound },
        std::pair<ComparableASCIILiteral, Internals::AudioSessionCategory> { "AudioProcessing"_s, Internals::AudioSessionCategory::AudioProcessing },
        std::pair<ComparableASCIILiteral, Internals::AudioSessionCategory> { "MediaPlayback"_s, Internals::AudioSessionCategory::MediaPlayback },
        std::pair<ComparableASCIILiteral, Internals::AudioSessionCategory> { "None"_s, Internals::AudioSessionCategory::None },
        std::pair<ComparableASCIILiteral, Internals::AudioSessionCategory> { "PlayAndRecord"_s, Internals::AudioSessionCategory::PlayAndRecord },
        std::pair<ComparableASCIILiteral, Internals::AudioSessionCategory> { "RecordAudio"_s, Internals::AudioSessionCategory::RecordAudio },
        std::pair<ComparableASCIILiteral, Internals::AudioSessionCategory> { "SoloAmbientSound"_s, Internals::AudioSessionCategory::SoloAmbientSound },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<Internals::AudioSessionCategory> parseEnumeration<Internals::AudioSessionCategory>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<Internals::AudioSessionCategory>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<Internals::AudioSessionCategory>()
{
    return "\"None\", \"AmbientSound\", \"SoloAmbientSound\", \"MediaPlayback\", \"RecordAudio\", \"PlayAndRecord\", \"AudioProcessing\""_s;
}

String convertEnumerationToString(Internals::AudioSessionMode enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 3> values {
        MAKE_STATIC_STRING_IMPL("Default"),
        MAKE_STATIC_STRING_IMPL("VideoChat"),
        MAKE_STATIC_STRING_IMPL("MoviePlayback"),
    };
    static_assert(static_cast<size_t>(Internals::AudioSessionMode::Default) == 0, "Internals::AudioSessionMode::Default is not 0 as expected");
    static_assert(static_cast<size_t>(Internals::AudioSessionMode::VideoChat) == 1, "Internals::AudioSessionMode::VideoChat is not 1 as expected");
    static_assert(static_cast<size_t>(Internals::AudioSessionMode::MoviePlayback) == 2, "Internals::AudioSessionMode::MoviePlayback is not 2 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, Internals::AudioSessionMode enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<Internals::AudioSessionMode> parseEnumerationFromString<Internals::AudioSessionMode>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, Internals::AudioSessionMode>, 3> mappings {
        std::pair<ComparableASCIILiteral, Internals::AudioSessionMode> { "Default"_s, Internals::AudioSessionMode::Default },
        std::pair<ComparableASCIILiteral, Internals::AudioSessionMode> { "MoviePlayback"_s, Internals::AudioSessionMode::MoviePlayback },
        std::pair<ComparableASCIILiteral, Internals::AudioSessionMode> { "VideoChat"_s, Internals::AudioSessionMode::VideoChat },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<Internals::AudioSessionMode> parseEnumeration<Internals::AudioSessionMode>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<Internals::AudioSessionMode>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<Internals::AudioSessionMode>()
{
    return "\"Default\", \"VideoChat\", \"MoviePlayback\""_s;
}

String convertEnumerationToString(Internals::RouteSharingPolicy enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 4> values {
        MAKE_STATIC_STRING_IMPL("Default"),
        MAKE_STATIC_STRING_IMPL("LongFormAudio"),
        MAKE_STATIC_STRING_IMPL("Independent"),
        MAKE_STATIC_STRING_IMPL("LongFormVideo"),
    };
    static_assert(static_cast<size_t>(Internals::RouteSharingPolicy::Default) == 0, "Internals::RouteSharingPolicy::Default is not 0 as expected");
    static_assert(static_cast<size_t>(Internals::RouteSharingPolicy::LongFormAudio) == 1, "Internals::RouteSharingPolicy::LongFormAudio is not 1 as expected");
    static_assert(static_cast<size_t>(Internals::RouteSharingPolicy::Independent) == 2, "Internals::RouteSharingPolicy::Independent is not 2 as expected");
    static_assert(static_cast<size_t>(Internals::RouteSharingPolicy::LongFormVideo) == 3, "Internals::RouteSharingPolicy::LongFormVideo is not 3 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, Internals::RouteSharingPolicy enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<Internals::RouteSharingPolicy> parseEnumerationFromString<Internals::RouteSharingPolicy>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, Internals::RouteSharingPolicy>, 4> mappings {
        std::pair<ComparableASCIILiteral, Internals::RouteSharingPolicy> { "Default"_s, Internals::RouteSharingPolicy::Default },
        std::pair<ComparableASCIILiteral, Internals::RouteSharingPolicy> { "Independent"_s, Internals::RouteSharingPolicy::Independent },
        std::pair<ComparableASCIILiteral, Internals::RouteSharingPolicy> { "LongFormAudio"_s, Internals::RouteSharingPolicy::LongFormAudio },
        std::pair<ComparableASCIILiteral, Internals::RouteSharingPolicy> { "LongFormVideo"_s, Internals::RouteSharingPolicy::LongFormVideo },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<Internals::RouteSharingPolicy> parseEnumeration<Internals::RouteSharingPolicy>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<Internals::RouteSharingPolicy>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<Internals::RouteSharingPolicy>()
{
    return "\"Default\", \"LongFormAudio\", \"Independent\", \"LongFormVideo\""_s;
}

String convertEnumerationToString(Internals::AutoplayPolicy enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 4> values {
        MAKE_STATIC_STRING_IMPL("Default"),
        MAKE_STATIC_STRING_IMPL("Allow"),
        MAKE_STATIC_STRING_IMPL("AllowWithoutSound"),
        MAKE_STATIC_STRING_IMPL("Deny"),
    };
    static_assert(static_cast<size_t>(Internals::AutoplayPolicy::Default) == 0, "Internals::AutoplayPolicy::Default is not 0 as expected");
    static_assert(static_cast<size_t>(Internals::AutoplayPolicy::Allow) == 1, "Internals::AutoplayPolicy::Allow is not 1 as expected");
    static_assert(static_cast<size_t>(Internals::AutoplayPolicy::AllowWithoutSound) == 2, "Internals::AutoplayPolicy::AllowWithoutSound is not 2 as expected");
    static_assert(static_cast<size_t>(Internals::AutoplayPolicy::Deny) == 3, "Internals::AutoplayPolicy::Deny is not 3 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, Internals::AutoplayPolicy enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<Internals::AutoplayPolicy> parseEnumerationFromString<Internals::AutoplayPolicy>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, Internals::AutoplayPolicy>, 4> mappings {
        std::pair<ComparableASCIILiteral, Internals::AutoplayPolicy> { "Allow"_s, Internals::AutoplayPolicy::Allow },
        std::pair<ComparableASCIILiteral, Internals::AutoplayPolicy> { "AllowWithoutSound"_s, Internals::AutoplayPolicy::AllowWithoutSound },
        std::pair<ComparableASCIILiteral, Internals::AutoplayPolicy> { "Default"_s, Internals::AutoplayPolicy::Default },
        std::pair<ComparableASCIILiteral, Internals::AutoplayPolicy> { "Deny"_s, Internals::AutoplayPolicy::Deny },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<Internals::AutoplayPolicy> parseEnumeration<Internals::AutoplayPolicy>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<Internals::AutoplayPolicy>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<Internals::AutoplayPolicy>()
{
    return "\"Default\", \"Allow\", \"AllowWithoutSound\", \"Deny\""_s;
}

#if ENABLE(WEBGL)

String convertEnumerationToString(Internals::RequestedGPU enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 3> values {
        MAKE_STATIC_STRING_IMPL("default"),
        MAKE_STATIC_STRING_IMPL("low-power"),
        MAKE_STATIC_STRING_IMPL("high-performance"),
    };
    static_assert(static_cast<size_t>(Internals::RequestedGPU::Default) == 0, "Internals::RequestedGPU::Default is not 0 as expected");
    static_assert(static_cast<size_t>(Internals::RequestedGPU::LowPower) == 1, "Internals::RequestedGPU::LowPower is not 1 as expected");
    static_assert(static_cast<size_t>(Internals::RequestedGPU::HighPerformance) == 2, "Internals::RequestedGPU::HighPerformance is not 2 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, Internals::RequestedGPU enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<Internals::RequestedGPU> parseEnumerationFromString<Internals::RequestedGPU>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, Internals::RequestedGPU>, 3> mappings {
        std::pair<ComparableASCIILiteral, Internals::RequestedGPU> { "default"_s, Internals::RequestedGPU::Default },
        std::pair<ComparableASCIILiteral, Internals::RequestedGPU> { "high-performance"_s, Internals::RequestedGPU::HighPerformance },
        std::pair<ComparableASCIILiteral, Internals::RequestedGPU> { "low-power"_s, Internals::RequestedGPU::LowPower },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<Internals::RequestedGPU> parseEnumeration<Internals::RequestedGPU>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<Internals::RequestedGPU>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<Internals::RequestedGPU>()
{
    return "\"default\", \"low-power\", \"high-performance\""_s;
}

#endif

String convertEnumerationToString(Internals::HEVCParameterCodec enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 2> values {
        MAKE_STATIC_STRING_IMPL("hev1"),
        MAKE_STATIC_STRING_IMPL("hvc1"),
    };
    static_assert(static_cast<size_t>(Internals::HEVCParameterCodec::Hev1) == 0, "Internals::HEVCParameterCodec::Hev1 is not 0 as expected");
    static_assert(static_cast<size_t>(Internals::HEVCParameterCodec::Hvc1) == 1, "Internals::HEVCParameterCodec::Hvc1 is not 1 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, Internals::HEVCParameterCodec enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<Internals::HEVCParameterCodec> parseEnumerationFromString<Internals::HEVCParameterCodec>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, Internals::HEVCParameterCodec>, 2> mappings {
        std::pair<ComparableASCIILiteral, Internals::HEVCParameterCodec> { "hev1"_s, Internals::HEVCParameterCodec::Hev1 },
        std::pair<ComparableASCIILiteral, Internals::HEVCParameterCodec> { "hvc1"_s, Internals::HEVCParameterCodec::Hvc1 },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<Internals::HEVCParameterCodec> parseEnumeration<Internals::HEVCParameterCodec>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<Internals::HEVCParameterCodec>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<Internals::HEVCParameterCodec>()
{
    return "\"hev1\", \"hvc1\""_s;
}

String convertEnumerationToString(Internals::AV1ConfigurationProfile enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 3> values {
        MAKE_STATIC_STRING_IMPL("Main"),
        MAKE_STATIC_STRING_IMPL("High"),
        MAKE_STATIC_STRING_IMPL("Professional"),
    };
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationProfile::Main) == 0, "Internals::AV1ConfigurationProfile::Main is not 0 as expected");
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationProfile::High) == 1, "Internals::AV1ConfigurationProfile::High is not 1 as expected");
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationProfile::Professional) == 2, "Internals::AV1ConfigurationProfile::Professional is not 2 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, Internals::AV1ConfigurationProfile enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<Internals::AV1ConfigurationProfile> parseEnumerationFromString<Internals::AV1ConfigurationProfile>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationProfile>, 3> mappings {
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationProfile> { "High"_s, Internals::AV1ConfigurationProfile::High },
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationProfile> { "Main"_s, Internals::AV1ConfigurationProfile::Main },
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationProfile> { "Professional"_s, Internals::AV1ConfigurationProfile::Professional },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<Internals::AV1ConfigurationProfile> parseEnumeration<Internals::AV1ConfigurationProfile>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<Internals::AV1ConfigurationProfile>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<Internals::AV1ConfigurationProfile>()
{
    return "\"Main\", \"High\", \"Professional\""_s;
}

String convertEnumerationToString(Internals::AV1ConfigurationLevel enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 24> values {
        MAKE_STATIC_STRING_IMPL("Level_2_0"),
        MAKE_STATIC_STRING_IMPL("Level_2_1"),
        MAKE_STATIC_STRING_IMPL("Level_2_2"),
        MAKE_STATIC_STRING_IMPL("Level_2_3"),
        MAKE_STATIC_STRING_IMPL("Level_3_0"),
        MAKE_STATIC_STRING_IMPL("Level_3_1"),
        MAKE_STATIC_STRING_IMPL("Level_3_2"),
        MAKE_STATIC_STRING_IMPL("Level_3_3"),
        MAKE_STATIC_STRING_IMPL("Level_4_0"),
        MAKE_STATIC_STRING_IMPL("Level_4_1"),
        MAKE_STATIC_STRING_IMPL("Level_4_2"),
        MAKE_STATIC_STRING_IMPL("Level_4_3"),
        MAKE_STATIC_STRING_IMPL("Level_5_0"),
        MAKE_STATIC_STRING_IMPL("Level_5_1"),
        MAKE_STATIC_STRING_IMPL("Level_5_2"),
        MAKE_STATIC_STRING_IMPL("Level_5_3"),
        MAKE_STATIC_STRING_IMPL("Level_6_0"),
        MAKE_STATIC_STRING_IMPL("Level_6_1"),
        MAKE_STATIC_STRING_IMPL("Level_6_2"),
        MAKE_STATIC_STRING_IMPL("Level_6_3"),
        MAKE_STATIC_STRING_IMPL("Level_7_0"),
        MAKE_STATIC_STRING_IMPL("Level_7_1"),
        MAKE_STATIC_STRING_IMPL("Level_7_2"),
        MAKE_STATIC_STRING_IMPL("Level_7_3"),
    };
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationLevel::Level_2_0) == 0, "Internals::AV1ConfigurationLevel::Level_2_0 is not 0 as expected");
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationLevel::Level_2_1) == 1, "Internals::AV1ConfigurationLevel::Level_2_1 is not 1 as expected");
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationLevel::Level_2_2) == 2, "Internals::AV1ConfigurationLevel::Level_2_2 is not 2 as expected");
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationLevel::Level_2_3) == 3, "Internals::AV1ConfigurationLevel::Level_2_3 is not 3 as expected");
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationLevel::Level_3_0) == 4, "Internals::AV1ConfigurationLevel::Level_3_0 is not 4 as expected");
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationLevel::Level_3_1) == 5, "Internals::AV1ConfigurationLevel::Level_3_1 is not 5 as expected");
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationLevel::Level_3_2) == 6, "Internals::AV1ConfigurationLevel::Level_3_2 is not 6 as expected");
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationLevel::Level_3_3) == 7, "Internals::AV1ConfigurationLevel::Level_3_3 is not 7 as expected");
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationLevel::Level_4_0) == 8, "Internals::AV1ConfigurationLevel::Level_4_0 is not 8 as expected");
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationLevel::Level_4_1) == 9, "Internals::AV1ConfigurationLevel::Level_4_1 is not 9 as expected");
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationLevel::Level_4_2) == 10, "Internals::AV1ConfigurationLevel::Level_4_2 is not 10 as expected");
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationLevel::Level_4_3) == 11, "Internals::AV1ConfigurationLevel::Level_4_3 is not 11 as expected");
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationLevel::Level_5_0) == 12, "Internals::AV1ConfigurationLevel::Level_5_0 is not 12 as expected");
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationLevel::Level_5_1) == 13, "Internals::AV1ConfigurationLevel::Level_5_1 is not 13 as expected");
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationLevel::Level_5_2) == 14, "Internals::AV1ConfigurationLevel::Level_5_2 is not 14 as expected");
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationLevel::Level_5_3) == 15, "Internals::AV1ConfigurationLevel::Level_5_3 is not 15 as expected");
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationLevel::Level_6_0) == 16, "Internals::AV1ConfigurationLevel::Level_6_0 is not 16 as expected");
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationLevel::Level_6_1) == 17, "Internals::AV1ConfigurationLevel::Level_6_1 is not 17 as expected");
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationLevel::Level_6_2) == 18, "Internals::AV1ConfigurationLevel::Level_6_2 is not 18 as expected");
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationLevel::Level_6_3) == 19, "Internals::AV1ConfigurationLevel::Level_6_3 is not 19 as expected");
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationLevel::Level_7_0) == 20, "Internals::AV1ConfigurationLevel::Level_7_0 is not 20 as expected");
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationLevel::Level_7_1) == 21, "Internals::AV1ConfigurationLevel::Level_7_1 is not 21 as expected");
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationLevel::Level_7_2) == 22, "Internals::AV1ConfigurationLevel::Level_7_2 is not 22 as expected");
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationLevel::Level_7_3) == 23, "Internals::AV1ConfigurationLevel::Level_7_3 is not 23 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, Internals::AV1ConfigurationLevel enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<Internals::AV1ConfigurationLevel> parseEnumerationFromString<Internals::AV1ConfigurationLevel>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationLevel>, 24> mappings {
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationLevel> { "Level_2_0"_s, Internals::AV1ConfigurationLevel::Level_2_0 },
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationLevel> { "Level_2_1"_s, Internals::AV1ConfigurationLevel::Level_2_1 },
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationLevel> { "Level_2_2"_s, Internals::AV1ConfigurationLevel::Level_2_2 },
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationLevel> { "Level_2_3"_s, Internals::AV1ConfigurationLevel::Level_2_3 },
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationLevel> { "Level_3_0"_s, Internals::AV1ConfigurationLevel::Level_3_0 },
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationLevel> { "Level_3_1"_s, Internals::AV1ConfigurationLevel::Level_3_1 },
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationLevel> { "Level_3_2"_s, Internals::AV1ConfigurationLevel::Level_3_2 },
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationLevel> { "Level_3_3"_s, Internals::AV1ConfigurationLevel::Level_3_3 },
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationLevel> { "Level_4_0"_s, Internals::AV1ConfigurationLevel::Level_4_0 },
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationLevel> { "Level_4_1"_s, Internals::AV1ConfigurationLevel::Level_4_1 },
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationLevel> { "Level_4_2"_s, Internals::AV1ConfigurationLevel::Level_4_2 },
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationLevel> { "Level_4_3"_s, Internals::AV1ConfigurationLevel::Level_4_3 },
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationLevel> { "Level_5_0"_s, Internals::AV1ConfigurationLevel::Level_5_0 },
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationLevel> { "Level_5_1"_s, Internals::AV1ConfigurationLevel::Level_5_1 },
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationLevel> { "Level_5_2"_s, Internals::AV1ConfigurationLevel::Level_5_2 },
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationLevel> { "Level_5_3"_s, Internals::AV1ConfigurationLevel::Level_5_3 },
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationLevel> { "Level_6_0"_s, Internals::AV1ConfigurationLevel::Level_6_0 },
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationLevel> { "Level_6_1"_s, Internals::AV1ConfigurationLevel::Level_6_1 },
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationLevel> { "Level_6_2"_s, Internals::AV1ConfigurationLevel::Level_6_2 },
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationLevel> { "Level_6_3"_s, Internals::AV1ConfigurationLevel::Level_6_3 },
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationLevel> { "Level_7_0"_s, Internals::AV1ConfigurationLevel::Level_7_0 },
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationLevel> { "Level_7_1"_s, Internals::AV1ConfigurationLevel::Level_7_1 },
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationLevel> { "Level_7_2"_s, Internals::AV1ConfigurationLevel::Level_7_2 },
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationLevel> { "Level_7_3"_s, Internals::AV1ConfigurationLevel::Level_7_3 },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<Internals::AV1ConfigurationLevel> parseEnumeration<Internals::AV1ConfigurationLevel>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<Internals::AV1ConfigurationLevel>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<Internals::AV1ConfigurationLevel>()
{
    return "\"Level_2_0\", \"Level_2_1\", \"Level_2_2\", \"Level_2_3\", \"Level_3_0\", \"Level_3_1\", \"Level_3_2\", \"Level_3_3\", \"Level_4_0\", \"Level_4_1\", \"Level_4_2\", \"Level_4_3\", \"Level_5_0\", \"Level_5_1\", \"Level_5_2\", \"Level_5_3\", \"Level_6_0\", \"Level_6_1\", \"Level_6_2\", \"Level_6_3\", \"Level_7_0\", \"Level_7_1\", \"Level_7_2\", \"Level_7_3\""_s;
}

String convertEnumerationToString(Internals::AV1ConfigurationTier enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 2> values {
        MAKE_STATIC_STRING_IMPL("Main"),
        MAKE_STATIC_STRING_IMPL("High"),
    };
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationTier::Main) == 0, "Internals::AV1ConfigurationTier::Main is not 0 as expected");
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationTier::High) == 1, "Internals::AV1ConfigurationTier::High is not 1 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, Internals::AV1ConfigurationTier enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<Internals::AV1ConfigurationTier> parseEnumerationFromString<Internals::AV1ConfigurationTier>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationTier>, 2> mappings {
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationTier> { "High"_s, Internals::AV1ConfigurationTier::High },
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationTier> { "Main"_s, Internals::AV1ConfigurationTier::Main },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<Internals::AV1ConfigurationTier> parseEnumeration<Internals::AV1ConfigurationTier>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<Internals::AV1ConfigurationTier>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<Internals::AV1ConfigurationTier>()
{
    return "\"Main\", \"High\""_s;
}

String convertEnumerationToString(Internals::AV1ConfigurationRange enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 2> values {
        MAKE_STATIC_STRING_IMPL("VideoRange"),
        MAKE_STATIC_STRING_IMPL("FullRange"),
    };
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationRange::VideoRange) == 0, "Internals::AV1ConfigurationRange::VideoRange is not 0 as expected");
    static_assert(static_cast<size_t>(Internals::AV1ConfigurationRange::FullRange) == 1, "Internals::AV1ConfigurationRange::FullRange is not 1 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, Internals::AV1ConfigurationRange enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<Internals::AV1ConfigurationRange> parseEnumerationFromString<Internals::AV1ConfigurationRange>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationRange>, 2> mappings {
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationRange> { "FullRange"_s, Internals::AV1ConfigurationRange::FullRange },
        std::pair<ComparableASCIILiteral, Internals::AV1ConfigurationRange> { "VideoRange"_s, Internals::AV1ConfigurationRange::VideoRange },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<Internals::AV1ConfigurationRange> parseEnumeration<Internals::AV1ConfigurationRange>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<Internals::AV1ConfigurationRange>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<Internals::AV1ConfigurationRange>()
{
    return "\"VideoRange\", \"FullRange\""_s;
}

String convertEnumerationToString(Internals::RenderingMode enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 2> values {
        MAKE_STATIC_STRING_IMPL("Unaccelerated"),
        MAKE_STATIC_STRING_IMPL("Accelerated"),
    };
    static_assert(static_cast<size_t>(Internals::RenderingMode::Unaccelerated) == 0, "Internals::RenderingMode::Unaccelerated is not 0 as expected");
    static_assert(static_cast<size_t>(Internals::RenderingMode::Accelerated) == 1, "Internals::RenderingMode::Accelerated is not 1 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, Internals::RenderingMode enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<Internals::RenderingMode> parseEnumerationFromString<Internals::RenderingMode>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, Internals::RenderingMode>, 2> mappings {
        std::pair<ComparableASCIILiteral, Internals::RenderingMode> { "Accelerated"_s, Internals::RenderingMode::Accelerated },
        std::pair<ComparableASCIILiteral, Internals::RenderingMode> { "Unaccelerated"_s, Internals::RenderingMode::Unaccelerated },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<Internals::RenderingMode> parseEnumeration<Internals::RenderingMode>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<Internals::RenderingMode>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<Internals::RenderingMode>()
{
    return "\"Unaccelerated\", \"Accelerated\""_s;
}

String convertEnumerationToString(Internals::ContentsFormat enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 1> values {
        MAKE_STATIC_STRING_IMPL("RGBA8"),
    };
    static_assert(static_cast<size_t>(Internals::ContentsFormat::RGBA8) == 0, "Internals::ContentsFormat::RGBA8 is not 0 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, Internals::ContentsFormat enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<Internals::ContentsFormat> parseEnumerationFromString<Internals::ContentsFormat>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, Internals::ContentsFormat>, 1> mappings {
        std::pair<ComparableASCIILiteral, Internals::ContentsFormat> { "RGBA8"_s, Internals::ContentsFormat::RGBA8 },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<Internals::ContentsFormat> parseEnumeration<Internals::ContentsFormat>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<Internals::ContentsFormat>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<Internals::ContentsFormat>()
{
    return "\"RGBA8\""_s;
}

#if ENABLE(VIDEO)

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const Internals::NowPlayingState& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    if (!IDLUnrestrictedDouble::isNullValue(dictionary.duration)) {
        auto durationValue = toJS<IDLUnrestrictedDouble>(lexicalGlobalObject, throwScope, IDLUnrestrictedDouble::extractValueFromNullable(dictionary.duration));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "duration"_s), durationValue);
    }
    if (!IDLUnrestrictedDouble::isNullValue(dictionary.elapsedTime)) {
        auto elapsedTimeValue = toJS<IDLUnrestrictedDouble>(lexicalGlobalObject, throwScope, IDLUnrestrictedDouble::extractValueFromNullable(dictionary.elapsedTime));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "elapsedTime"_s), elapsedTimeValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.hasActiveSession)) {
        auto hasActiveSessionValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.hasActiveSession));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "hasActiveSession"_s), hasActiveSessionValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.haveEverRegisteredAsNowPlayingApplication)) {
        auto haveEverRegisteredAsNowPlayingApplicationValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.haveEverRegisteredAsNowPlayingApplication));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "haveEverRegisteredAsNowPlayingApplication"_s), haveEverRegisteredAsNowPlayingApplicationValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.registeredAsNowPlayingApplication)) {
        auto registeredAsNowPlayingApplicationValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.registeredAsNowPlayingApplication));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "registeredAsNowPlayingApplication"_s), registeredAsNowPlayingApplicationValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.title)) {
        auto titleValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.title));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "title"_s), titleValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.uniqueIdentifier)) {
        auto uniqueIdentifierValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.uniqueIdentifier));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "uniqueIdentifier"_s), uniqueIdentifierValue);
    }
    return result;
}

#endif

#if ENABLE(VIDEO)

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const Internals::NowPlayingInfoArtwork& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    if (!IDLDOMString::isNullValue(dictionary.mimeType)) {
        auto mimeTypeValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.mimeType));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "mimeType"_s), mimeTypeValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.src)) {
        auto srcValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.src));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "src"_s), srcValue);
    }
    return result;
}

#endif

#if ENABLE(VIDEO)

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const Internals::NowPlayingMetadata& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    if (!IDLDOMString::isNullValue(dictionary.album)) {
        auto albumValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.album));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "album"_s), albumValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.artist)) {
        auto artistValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.artist));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "artist"_s), artistValue);
    }
    if (!IDLNullable<IDLDictionary<Internals::NowPlayingInfoArtwork>>::isNullValue(dictionary.artwork)) {
        auto artworkValue = toJS<IDLNullable<IDLDictionary<Internals::NowPlayingInfoArtwork>>>(lexicalGlobalObject, globalObject, throwScope, IDLNullable<IDLDictionary<Internals::NowPlayingInfoArtwork>>::extractValueFromNullable(dictionary.artwork));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "artwork"_s), artworkValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.sourceApplicationIdentifier)) {
        auto sourceApplicationIdentifierValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.sourceApplicationIdentifier));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "sourceApplicationIdentifier"_s), sourceApplicationIdentifierValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.title)) {
        auto titleValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.title));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "title"_s), titleValue);
    }
    return result;
}

#endif

#if ENABLE(VIDEO)

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const Internals::MediaUsageState& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    if (!IDLBoolean::isNullValue(dictionary.audioElementWithUserGesture)) {
        auto audioElementWithUserGestureValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.audioElementWithUserGesture));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "audioElementWithUserGesture"_s), audioElementWithUserGestureValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.canShowControlsManager)) {
        auto canShowControlsManagerValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.canShowControlsManager));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "canShowControlsManager"_s), canShowControlsManagerValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.canShowNowPlayingControls)) {
        auto canShowNowPlayingControlsValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.canShowNowPlayingControls));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "canShowNowPlayingControls"_s), canShowNowPlayingControlsValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.hasAudio)) {
        auto hasAudioValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.hasAudio));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "hasAudio"_s), hasAudioValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.hasEverNotifiedAboutPlaying)) {
        auto hasEverNotifiedAboutPlayingValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.hasEverNotifiedAboutPlaying));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "hasEverNotifiedAboutPlaying"_s), hasEverNotifiedAboutPlayingValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.hasRenderer)) {
        auto hasRendererValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.hasRenderer));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "hasRenderer"_s), hasRendererValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.hasVideo)) {
        auto hasVideoValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.hasVideo));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "hasVideo"_s), hasVideoValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.isAudio)) {
        auto isAudioValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.isAudio));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "isAudio"_s), isAudioValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.isAudioAndRequiresUserGestureForAudioRateChange)) {
        auto isAudioAndRequiresUserGestureForAudioRateChangeValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.isAudioAndRequiresUserGestureForAudioRateChange));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "isAudioAndRequiresUserGestureForAudioRateChange"_s), isAudioAndRequiresUserGestureForAudioRateChangeValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.isElementRectMostlyInMainFrame)) {
        auto isElementRectMostlyInMainFrameValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.isElementRectMostlyInMainFrame));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "isElementRectMostlyInMainFrame"_s), isElementRectMostlyInMainFrameValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.isFullscreen)) {
        auto isFullscreenValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.isFullscreen));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "isFullscreen"_s), isFullscreenValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.isInActiveDocument)) {
        auto isInActiveDocumentValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.isInActiveDocument));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "isInActiveDocument"_s), isInActiveDocumentValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.isLargeEnoughForMainContent)) {
        auto isLargeEnoughForMainContentValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.isLargeEnoughForMainContent));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "isLargeEnoughForMainContent"_s), isLargeEnoughForMainContentValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.isMediaDocumentAndNotOwnerElement)) {
        auto isMediaDocumentAndNotOwnerElementValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.isMediaDocumentAndNotOwnerElement));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "isMediaDocumentAndNotOwnerElement"_s), isMediaDocumentAndNotOwnerElementValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.isMediaDocumentInMainFrame)) {
        auto isMediaDocumentInMainFrameValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.isMediaDocumentInMainFrame));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "isMediaDocumentInMainFrame"_s), isMediaDocumentInMainFrameValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.isMuted)) {
        auto isMutedValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.isMuted));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "isMuted"_s), isMutedValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.isPlaying)) {
        auto isPlayingValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.isPlaying));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "isPlaying"_s), isPlayingValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.isSuspended)) {
        auto isSuspendedValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.isSuspended));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "isSuspended"_s), isSuspendedValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.isVideo)) {
        auto isVideoValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.isVideo));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "isVideo"_s), isVideoValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.isVideoAndRequiresUserGestureForVideoDueToAggressiveThermalMitigation)) {
        auto isVideoAndRequiresUserGestureForVideoDueToAggressiveThermalMitigationValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.isVideoAndRequiresUserGestureForVideoDueToAggressiveThermalMitigation));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "isVideoAndRequiresUserGestureForVideoDueToAggressiveThermalMitigation"_s), isVideoAndRequiresUserGestureForVideoDueToAggressiveThermalMitigationValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.isVideoAndRequiresUserGestureForVideoDueToLowPowerMode)) {
        auto isVideoAndRequiresUserGestureForVideoDueToLowPowerModeValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.isVideoAndRequiresUserGestureForVideoDueToLowPowerMode));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "isVideoAndRequiresUserGestureForVideoDueToLowPowerMode"_s), isVideoAndRequiresUserGestureForVideoDueToLowPowerModeValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.isVideoAndRequiresUserGestureForVideoRateChange)) {
        auto isVideoAndRequiresUserGestureForVideoRateChangeValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.isVideoAndRequiresUserGestureForVideoRateChange));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "isVideoAndRequiresUserGestureForVideoRateChange"_s), isVideoAndRequiresUserGestureForVideoRateChangeValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.mediaURL)) {
        auto mediaURLValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.mediaURL));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "mediaURL"_s), mediaURLValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.noUserGestureRequired)) {
        auto noUserGestureRequiredValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.noUserGestureRequired));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "noUserGestureRequired"_s), noUserGestureRequiredValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.outsideOfFullscreen)) {
        auto outsideOfFullscreenValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.outsideOfFullscreen));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "outsideOfFullscreen"_s), outsideOfFullscreenValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.pageExplicitlyAllowsElementToAutoplayInline)) {
        auto pageExplicitlyAllowsElementToAutoplayInlineValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.pageExplicitlyAllowsElementToAutoplayInline));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "pageExplicitlyAllowsElementToAutoplayInline"_s), pageExplicitlyAllowsElementToAutoplayInlineValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.pageMediaPlaybackSuspended)) {
        auto pageMediaPlaybackSuspendedValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.pageMediaPlaybackSuspended));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "pageMediaPlaybackSuspended"_s), pageMediaPlaybackSuspendedValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.playbackPermitted)) {
        auto playbackPermittedValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.playbackPermitted));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "playbackPermitted"_s), playbackPermittedValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.requiresFullscreenForVideoPlaybackAndFullscreenNotPermitted)) {
        auto requiresFullscreenForVideoPlaybackAndFullscreenNotPermittedValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.requiresFullscreenForVideoPlaybackAndFullscreenNotPermitted));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "requiresFullscreenForVideoPlaybackAndFullscreenNotPermitted"_s), requiresFullscreenForVideoPlaybackAndFullscreenNotPermittedValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.requiresPlaybackAndIsNotPlaying)) {
        auto requiresPlaybackAndIsNotPlayingValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.requiresPlaybackAndIsNotPlaying));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "requiresPlaybackAndIsNotPlaying"_s), requiresPlaybackAndIsNotPlayingValue);
    }
    if (!IDLBoolean::isNullValue(dictionary.userHasPlayedAudioBefore)) {
        auto userHasPlayedAudioBeforeValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, IDLBoolean::extractValueFromNullable(dictionary.userHasPlayedAudioBefore));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "userHasPlayedAudioBefore"_s), userHasPlayedAudioBeforeValue);
    }
    return result;
}

#endif

template<> ConversionResult<IDLDictionary<Internals::FullscreenInsets>> convertDictionary<Internals::FullscreenInsets>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    bool isNullOrUndefined = value.isUndefinedOrNull();
    auto* object = isNullOrUndefined ? nullptr : value.getObject();
    if (!isNullOrUndefined && !object) [[unlikely]] {
        throwTypeError(&lexicalGlobalObject, throwScope);
        return ConversionResultException { };
    }
    Internals::FullscreenInsets result;
    JSValue bottomValue;
    if (isNullOrUndefined)
        bottomValue = jsUndefined();
    else {
        bottomValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "bottom"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!bottomValue.isUndefined()) {
        auto bottomConversionResult = convert<IDLDouble>(lexicalGlobalObject, bottomValue);
        if (bottomConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.bottom = bottomConversionResult.releaseReturnValue();
    }
    JSValue leftValue;
    if (isNullOrUndefined)
        leftValue = jsUndefined();
    else {
        leftValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "left"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!leftValue.isUndefined()) {
        auto leftConversionResult = convert<IDLDouble>(lexicalGlobalObject, leftValue);
        if (leftConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.left = leftConversionResult.releaseReturnValue();
    }
    JSValue rightValue;
    if (isNullOrUndefined)
        rightValue = jsUndefined();
    else {
        rightValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "right"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!rightValue.isUndefined()) {
        auto rightConversionResult = convert<IDLDouble>(lexicalGlobalObject, rightValue);
        if (rightConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.right = rightConversionResult.releaseReturnValue();
    }
    JSValue topValue;
    if (isNullOrUndefined)
        topValue = jsUndefined();
    else {
        topValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "top"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!topValue.isUndefined()) {
        auto topConversionResult = convert<IDLDouble>(lexicalGlobalObject, topValue);
        if (topConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.top = topConversionResult.releaseReturnValue();
    }
    return result;
}

template<> ConversionResult<IDLDictionary<Internals::HEVCParameterSet>> convertDictionary<Internals::HEVCParameterSet>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    bool isNullOrUndefined = value.isUndefinedOrNull();
    auto* object = isNullOrUndefined ? nullptr : value.getObject();
    if (!isNullOrUndefined && !object) [[unlikely]] {
        throwTypeError(&lexicalGlobalObject, throwScope);
        return ConversionResultException { };
    }
    Internals::HEVCParameterSet result;
    JSValue codecValue;
    if (isNullOrUndefined)
        codecValue = jsUndefined();
    else {
        codecValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "codec"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!codecValue.isUndefined()) {
        auto codecConversionResult = convert<IDLEnumeration<Internals::HEVCParameterCodec>>(lexicalGlobalObject, codecValue);
        if (codecConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.codec = codecConversionResult.releaseReturnValue();
    }
    JSValue generalConstraintIndicatorFlagsValue;
    if (isNullOrUndefined)
        generalConstraintIndicatorFlagsValue = jsUndefined();
    else {
        generalConstraintIndicatorFlagsValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "generalConstraintIndicatorFlags"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (generalConstraintIndicatorFlagsValue.isUndefined()) {
        throwRequiredMemberTypeError(lexicalGlobalObject, throwScope, "generalConstraintIndicatorFlags"_s, "HEVCParameterSet"_s, "FrozenArray"_s);
        return ConversionResultException { };
    }
    auto generalConstraintIndicatorFlagsConversionResult = convert<IDLFrozenArray<IDLOctet>>(lexicalGlobalObject, generalConstraintIndicatorFlagsValue);
    if (generalConstraintIndicatorFlagsConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.generalConstraintIndicatorFlags = generalConstraintIndicatorFlagsConversionResult.releaseReturnValue();
    JSValue generalLevelIDCValue;
    if (isNullOrUndefined)
        generalLevelIDCValue = jsUndefined();
    else {
        generalLevelIDCValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "generalLevelIDC"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!generalLevelIDCValue.isUndefined()) {
        auto generalLevelIDCConversionResult = convert<IDLUnsignedShort>(lexicalGlobalObject, generalLevelIDCValue);
        if (generalLevelIDCConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.generalLevelIDC = generalLevelIDCConversionResult.releaseReturnValue();
    }
    JSValue generalProfileCompatibilityFlagsValue;
    if (isNullOrUndefined)
        generalProfileCompatibilityFlagsValue = jsUndefined();
    else {
        generalProfileCompatibilityFlagsValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "generalProfileCompatibilityFlags"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!generalProfileCompatibilityFlagsValue.isUndefined()) {
        auto generalProfileCompatibilityFlagsConversionResult = convert<IDLUnsignedLong>(lexicalGlobalObject, generalProfileCompatibilityFlagsValue);
        if (generalProfileCompatibilityFlagsConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.generalProfileCompatibilityFlags = generalProfileCompatibilityFlagsConversionResult.releaseReturnValue();
    }
    JSValue generalProfileIDCValue;
    if (isNullOrUndefined)
        generalProfileIDCValue = jsUndefined();
    else {
        generalProfileIDCValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "generalProfileIDC"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!generalProfileIDCValue.isUndefined()) {
        auto generalProfileIDCConversionResult = convert<IDLUnsignedShort>(lexicalGlobalObject, generalProfileIDCValue);
        if (generalProfileIDCConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.generalProfileIDC = generalProfileIDCConversionResult.releaseReturnValue();
    }
    JSValue generalProfileSpaceValue;
    if (isNullOrUndefined)
        generalProfileSpaceValue = jsUndefined();
    else {
        generalProfileSpaceValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "generalProfileSpace"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!generalProfileSpaceValue.isUndefined()) {
        auto generalProfileSpaceConversionResult = convert<IDLUnsignedShort>(lexicalGlobalObject, generalProfileSpaceValue);
        if (generalProfileSpaceConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.generalProfileSpace = generalProfileSpaceConversionResult.releaseReturnValue();
    }
    JSValue generalTierFlagValue;
    if (isNullOrUndefined)
        generalTierFlagValue = jsUndefined();
    else {
        generalTierFlagValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "generalTierFlag"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!generalTierFlagValue.isUndefined()) {
        auto generalTierFlagConversionResult = convert<IDLOctet>(lexicalGlobalObject, generalTierFlagValue);
        if (generalTierFlagConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.generalTierFlag = generalTierFlagConversionResult.releaseReturnValue();
    }
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const Internals::HEVCParameterSet& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    if (!IDLEnumeration<Internals::HEVCParameterCodec>::isNullValue(dictionary.codec)) {
        auto codecValue = toJS<IDLEnumeration<Internals::HEVCParameterCodec>>(lexicalGlobalObject, throwScope, IDLEnumeration<Internals::HEVCParameterCodec>::extractValueFromNullable(dictionary.codec));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "codec"_s), codecValue);
    }
    auto generalConstraintIndicatorFlagsValue = toJS<IDLFrozenArray<IDLOctet>>(lexicalGlobalObject, globalObject, throwScope, dictionary.generalConstraintIndicatorFlags);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "generalConstraintIndicatorFlags"_s), generalConstraintIndicatorFlagsValue);
    if (!IDLUnsignedShort::isNullValue(dictionary.generalLevelIDC)) {
        auto generalLevelIDCValue = toJS<IDLUnsignedShort>(lexicalGlobalObject, throwScope, IDLUnsignedShort::extractValueFromNullable(dictionary.generalLevelIDC));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "generalLevelIDC"_s), generalLevelIDCValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.generalProfileCompatibilityFlags)) {
        auto generalProfileCompatibilityFlagsValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.generalProfileCompatibilityFlags));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "generalProfileCompatibilityFlags"_s), generalProfileCompatibilityFlagsValue);
    }
    if (!IDLUnsignedShort::isNullValue(dictionary.generalProfileIDC)) {
        auto generalProfileIDCValue = toJS<IDLUnsignedShort>(lexicalGlobalObject, throwScope, IDLUnsignedShort::extractValueFromNullable(dictionary.generalProfileIDC));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "generalProfileIDC"_s), generalProfileIDCValue);
    }
    if (!IDLUnsignedShort::isNullValue(dictionary.generalProfileSpace)) {
        auto generalProfileSpaceValue = toJS<IDLUnsignedShort>(lexicalGlobalObject, throwScope, IDLUnsignedShort::extractValueFromNullable(dictionary.generalProfileSpace));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "generalProfileSpace"_s), generalProfileSpaceValue);
    }
    if (!IDLOctet::isNullValue(dictionary.generalTierFlag)) {
        auto generalTierFlagValue = toJS<IDLOctet>(lexicalGlobalObject, throwScope, IDLOctet::extractValueFromNullable(dictionary.generalTierFlag));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "generalTierFlag"_s), generalTierFlagValue);
    }
    return result;
}

template<> ConversionResult<IDLDictionary<Internals::AV1CodecConfigurationRecord>> convertDictionary<Internals::AV1CodecConfigurationRecord>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    bool isNullOrUndefined = value.isUndefinedOrNull();
    auto* object = isNullOrUndefined ? nullptr : value.getObject();
    if (!isNullOrUndefined && !object) [[unlikely]] {
        throwTypeError(&lexicalGlobalObject, throwScope);
        return ConversionResultException { };
    }
    Internals::AV1CodecConfigurationRecord result;
    JSValue bitDepthValue;
    if (isNullOrUndefined)
        bitDepthValue = jsUndefined();
    else {
        bitDepthValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "bitDepth"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!bitDepthValue.isUndefined()) {
        auto bitDepthConversionResult = convert<IDLOctet>(lexicalGlobalObject, bitDepthValue);
        if (bitDepthConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.bitDepth = bitDepthConversionResult.releaseReturnValue();
    }
    JSValue chromaSubsamplingValue;
    if (isNullOrUndefined)
        chromaSubsamplingValue = jsUndefined();
    else {
        chromaSubsamplingValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "chromaSubsampling"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!chromaSubsamplingValue.isUndefined()) {
        auto chromaSubsamplingConversionResult = convert<IDLOctet>(lexicalGlobalObject, chromaSubsamplingValue);
        if (chromaSubsamplingConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.chromaSubsampling = chromaSubsamplingConversionResult.releaseReturnValue();
    }
    JSValue codecNameValue;
    if (isNullOrUndefined)
        codecNameValue = jsUndefined();
    else {
        codecNameValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "codecName"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!codecNameValue.isUndefined()) {
        auto codecNameConversionResult = convert<IDLDOMString>(lexicalGlobalObject, codecNameValue);
        if (codecNameConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.codecName = codecNameConversionResult.releaseReturnValue();
    }
    JSValue colorPrimariesValue;
    if (isNullOrUndefined)
        colorPrimariesValue = jsUndefined();
    else {
        colorPrimariesValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "colorPrimaries"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!colorPrimariesValue.isUndefined()) {
        auto colorPrimariesConversionResult = convert<IDLOctet>(lexicalGlobalObject, colorPrimariesValue);
        if (colorPrimariesConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.colorPrimaries = colorPrimariesConversionResult.releaseReturnValue();
    }
    JSValue levelValue;
    if (isNullOrUndefined)
        levelValue = jsUndefined();
    else {
        levelValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "level"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!levelValue.isUndefined()) {
        auto levelConversionResult = convert<IDLEnumeration<Internals::AV1ConfigurationLevel>>(lexicalGlobalObject, levelValue);
        if (levelConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.level = levelConversionResult.releaseReturnValue();
    }
    JSValue matrixCoefficientsValue;
    if (isNullOrUndefined)
        matrixCoefficientsValue = jsUndefined();
    else {
        matrixCoefficientsValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "matrixCoefficients"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!matrixCoefficientsValue.isUndefined()) {
        auto matrixCoefficientsConversionResult = convert<IDLOctet>(lexicalGlobalObject, matrixCoefficientsValue);
        if (matrixCoefficientsConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.matrixCoefficients = matrixCoefficientsConversionResult.releaseReturnValue();
    }
    JSValue monochromeValue;
    if (isNullOrUndefined)
        monochromeValue = jsUndefined();
    else {
        monochromeValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "monochrome"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!monochromeValue.isUndefined()) {
        auto monochromeConversionResult = convert<IDLOctet>(lexicalGlobalObject, monochromeValue);
        if (monochromeConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.monochrome = monochromeConversionResult.releaseReturnValue();
    }
    JSValue profileValue;
    if (isNullOrUndefined)
        profileValue = jsUndefined();
    else {
        profileValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "profile"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!profileValue.isUndefined()) {
        auto profileConversionResult = convert<IDLEnumeration<Internals::AV1ConfigurationProfile>>(lexicalGlobalObject, profileValue);
        if (profileConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.profile = profileConversionResult.releaseReturnValue();
    }
    JSValue tierValue;
    if (isNullOrUndefined)
        tierValue = jsUndefined();
    else {
        tierValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "tier"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!tierValue.isUndefined()) {
        auto tierConversionResult = convert<IDLEnumeration<Internals::AV1ConfigurationTier>>(lexicalGlobalObject, tierValue);
        if (tierConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.tier = tierConversionResult.releaseReturnValue();
    }
    JSValue transferCharacteristicsValue;
    if (isNullOrUndefined)
        transferCharacteristicsValue = jsUndefined();
    else {
        transferCharacteristicsValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "transferCharacteristics"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!transferCharacteristicsValue.isUndefined()) {
        auto transferCharacteristicsConversionResult = convert<IDLOctet>(lexicalGlobalObject, transferCharacteristicsValue);
        if (transferCharacteristicsConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.transferCharacteristics = transferCharacteristicsConversionResult.releaseReturnValue();
    }
    JSValue videoFullRangeFlagValue;
    if (isNullOrUndefined)
        videoFullRangeFlagValue = jsUndefined();
    else {
        videoFullRangeFlagValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "videoFullRangeFlag"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!videoFullRangeFlagValue.isUndefined()) {
        auto videoFullRangeFlagConversionResult = convert<IDLEnumeration<Internals::AV1ConfigurationRange>>(lexicalGlobalObject, videoFullRangeFlagValue);
        if (videoFullRangeFlagConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.videoFullRangeFlag = videoFullRangeFlagConversionResult.releaseReturnValue();
    }
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const Internals::AV1CodecConfigurationRecord& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    if (!IDLOctet::isNullValue(dictionary.bitDepth)) {
        auto bitDepthValue = toJS<IDLOctet>(lexicalGlobalObject, throwScope, IDLOctet::extractValueFromNullable(dictionary.bitDepth));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "bitDepth"_s), bitDepthValue);
    }
    if (!IDLOctet::isNullValue(dictionary.chromaSubsampling)) {
        auto chromaSubsamplingValue = toJS<IDLOctet>(lexicalGlobalObject, throwScope, IDLOctet::extractValueFromNullable(dictionary.chromaSubsampling));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "chromaSubsampling"_s), chromaSubsamplingValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.codecName)) {
        auto codecNameValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.codecName));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "codecName"_s), codecNameValue);
    }
    if (!IDLOctet::isNullValue(dictionary.colorPrimaries)) {
        auto colorPrimariesValue = toJS<IDLOctet>(lexicalGlobalObject, throwScope, IDLOctet::extractValueFromNullable(dictionary.colorPrimaries));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "colorPrimaries"_s), colorPrimariesValue);
    }
    if (!IDLEnumeration<Internals::AV1ConfigurationLevel>::isNullValue(dictionary.level)) {
        auto levelValue = toJS<IDLEnumeration<Internals::AV1ConfigurationLevel>>(lexicalGlobalObject, throwScope, IDLEnumeration<Internals::AV1ConfigurationLevel>::extractValueFromNullable(dictionary.level));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "level"_s), levelValue);
    }
    if (!IDLOctet::isNullValue(dictionary.matrixCoefficients)) {
        auto matrixCoefficientsValue = toJS<IDLOctet>(lexicalGlobalObject, throwScope, IDLOctet::extractValueFromNullable(dictionary.matrixCoefficients));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "matrixCoefficients"_s), matrixCoefficientsValue);
    }
    if (!IDLOctet::isNullValue(dictionary.monochrome)) {
        auto monochromeValue = toJS<IDLOctet>(lexicalGlobalObject, throwScope, IDLOctet::extractValueFromNullable(dictionary.monochrome));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "monochrome"_s), monochromeValue);
    }
    if (!IDLEnumeration<Internals::AV1ConfigurationProfile>::isNullValue(dictionary.profile)) {
        auto profileValue = toJS<IDLEnumeration<Internals::AV1ConfigurationProfile>>(lexicalGlobalObject, throwScope, IDLEnumeration<Internals::AV1ConfigurationProfile>::extractValueFromNullable(dictionary.profile));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "profile"_s), profileValue);
    }
    if (!IDLEnumeration<Internals::AV1ConfigurationTier>::isNullValue(dictionary.tier)) {
        auto tierValue = toJS<IDLEnumeration<Internals::AV1ConfigurationTier>>(lexicalGlobalObject, throwScope, IDLEnumeration<Internals::AV1ConfigurationTier>::extractValueFromNullable(dictionary.tier));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "tier"_s), tierValue);
    }
    if (!IDLOctet::isNullValue(dictionary.transferCharacteristics)) {
        auto transferCharacteristicsValue = toJS<IDLOctet>(lexicalGlobalObject, throwScope, IDLOctet::extractValueFromNullable(dictionary.transferCharacteristics));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "transferCharacteristics"_s), transferCharacteristicsValue);
    }
    if (!IDLEnumeration<Internals::AV1ConfigurationRange>::isNullValue(dictionary.videoFullRangeFlag)) {
        auto videoFullRangeFlagValue = toJS<IDLEnumeration<Internals::AV1ConfigurationRange>>(lexicalGlobalObject, throwScope, IDLEnumeration<Internals::AV1ConfigurationRange>::extractValueFromNullable(dictionary.videoFullRangeFlag));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "videoFullRangeFlag"_s), videoFullRangeFlagValue);
    }
    return result;
}

template<> ConversionResult<IDLDictionary<Internals::DoViParameterSet>> convertDictionary<Internals::DoViParameterSet>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    bool isNullOrUndefined = value.isUndefinedOrNull();
    auto* object = isNullOrUndefined ? nullptr : value.getObject();
    if (!isNullOrUndefined && !object) [[unlikely]] {
        throwTypeError(&lexicalGlobalObject, throwScope);
        return ConversionResultException { };
    }
    Internals::DoViParameterSet result;
    JSValue bitstreamLevelIDValue;
    if (isNullOrUndefined)
        bitstreamLevelIDValue = jsUndefined();
    else {
        bitstreamLevelIDValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "bitstreamLevelID"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!bitstreamLevelIDValue.isUndefined()) {
        auto bitstreamLevelIDConversionResult = convert<IDLUnsignedShort>(lexicalGlobalObject, bitstreamLevelIDValue);
        if (bitstreamLevelIDConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.bitstreamLevelID = bitstreamLevelIDConversionResult.releaseReturnValue();
    }
    JSValue bitstreamProfileIDValue;
    if (isNullOrUndefined)
        bitstreamProfileIDValue = jsUndefined();
    else {
        bitstreamProfileIDValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "bitstreamProfileID"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!bitstreamProfileIDValue.isUndefined()) {
        auto bitstreamProfileIDConversionResult = convert<IDLUnsignedShort>(lexicalGlobalObject, bitstreamProfileIDValue);
        if (bitstreamProfileIDConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.bitstreamProfileID = bitstreamProfileIDConversionResult.releaseReturnValue();
    }
    JSValue codecNameValue;
    if (isNullOrUndefined)
        codecNameValue = jsUndefined();
    else {
        codecNameValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "codecName"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!codecNameValue.isUndefined()) {
        auto codecNameConversionResult = convert<IDLDOMString>(lexicalGlobalObject, codecNameValue);
        if (codecNameConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.codecName = codecNameConversionResult.releaseReturnValue();
    }
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const Internals::DoViParameterSet& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    if (!IDLUnsignedShort::isNullValue(dictionary.bitstreamLevelID)) {
        auto bitstreamLevelIDValue = toJS<IDLUnsignedShort>(lexicalGlobalObject, throwScope, IDLUnsignedShort::extractValueFromNullable(dictionary.bitstreamLevelID));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "bitstreamLevelID"_s), bitstreamLevelIDValue);
    }
    if (!IDLUnsignedShort::isNullValue(dictionary.bitstreamProfileID)) {
        auto bitstreamProfileIDValue = toJS<IDLUnsignedShort>(lexicalGlobalObject, throwScope, IDLUnsignedShort::extractValueFromNullable(dictionary.bitstreamProfileID));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "bitstreamProfileID"_s), bitstreamProfileIDValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.codecName)) {
        auto codecNameValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.codecName));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "codecName"_s), codecNameValue);
    }
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const Internals::VPCodecConfigurationRecord& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    if (!IDLOctet::isNullValue(dictionary.bitDepth)) {
        auto bitDepthValue = toJS<IDLOctet>(lexicalGlobalObject, throwScope, IDLOctet::extractValueFromNullable(dictionary.bitDepth));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "bitDepth"_s), bitDepthValue);
    }
    if (!IDLOctet::isNullValue(dictionary.chromaSubsampling)) {
        auto chromaSubsamplingValue = toJS<IDLOctet>(lexicalGlobalObject, throwScope, IDLOctet::extractValueFromNullable(dictionary.chromaSubsampling));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "chromaSubsampling"_s), chromaSubsamplingValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.codecName)) {
        auto codecNameValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.codecName));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "codecName"_s), codecNameValue);
    }
    if (!IDLOctet::isNullValue(dictionary.colorPrimaries)) {
        auto colorPrimariesValue = toJS<IDLOctet>(lexicalGlobalObject, throwScope, IDLOctet::extractValueFromNullable(dictionary.colorPrimaries));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "colorPrimaries"_s), colorPrimariesValue);
    }
    if (!IDLOctet::isNullValue(dictionary.level)) {
        auto levelValue = toJS<IDLOctet>(lexicalGlobalObject, throwScope, IDLOctet::extractValueFromNullable(dictionary.level));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "level"_s), levelValue);
    }
    if (!IDLOctet::isNullValue(dictionary.matrixCoefficients)) {
        auto matrixCoefficientsValue = toJS<IDLOctet>(lexicalGlobalObject, throwScope, IDLOctet::extractValueFromNullable(dictionary.matrixCoefficients));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "matrixCoefficients"_s), matrixCoefficientsValue);
    }
    if (!IDLOctet::isNullValue(dictionary.profile)) {
        auto profileValue = toJS<IDLOctet>(lexicalGlobalObject, throwScope, IDLOctet::extractValueFromNullable(dictionary.profile));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "profile"_s), profileValue);
    }
    if (!IDLOctet::isNullValue(dictionary.transferCharacteristics)) {
        auto transferCharacteristicsValue = toJS<IDLOctet>(lexicalGlobalObject, throwScope, IDLOctet::extractValueFromNullable(dictionary.transferCharacteristics));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "transferCharacteristics"_s), transferCharacteristicsValue);
    }
    if (!IDLOctet::isNullValue(dictionary.videoFullRangeFlag)) {
        auto videoFullRangeFlagValue = toJS<IDLOctet>(lexicalGlobalObject, throwScope, IDLOctet::extractValueFromNullable(dictionary.videoFullRangeFlag));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "videoFullRangeFlag"_s), videoFullRangeFlagValue);
    }
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const Internals::AcceleratedAnimation& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    if (!IDLDOMString::isNullValue(dictionary.property)) {
        auto propertyValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.property));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "property"_s), propertyValue);
    }
    if (!IDLDouble::isNullValue(dictionary.speed)) {
        auto speedValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.speed));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "speed"_s), speedValue);
    }
    return result;
}

template<> ConversionResult<IDLDictionary<Internals::CookieData>> convertDictionary<Internals::CookieData>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    bool isNullOrUndefined = value.isUndefinedOrNull();
    auto* object = isNullOrUndefined ? nullptr : value.getObject();
    if (!isNullOrUndefined && !object) [[unlikely]] {
        throwTypeError(&lexicalGlobalObject, throwScope);
        return ConversionResultException { };
    }
    Internals::CookieData result;
    JSValue domainValue;
    if (isNullOrUndefined)
        domainValue = jsUndefined();
    else {
        domainValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "domain"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto domainConversionResult = convertOptionalWithDefault<IDLDOMString>(lexicalGlobalObject, domainValue, [&]() -> ConversionResult<IDLDOMString> { return Converter<IDLDOMString>::ReturnType { emptyString() }; });
    if (domainConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.domain = domainConversionResult.releaseReturnValue();
    JSValue expiresValue;
    if (isNullOrUndefined)
        expiresValue = jsUndefined();
    else {
        expiresValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "expires"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto expiresConversionResult = convertOptionalWithDefault<IDLNullable<IDLDouble>>(lexicalGlobalObject, expiresValue, [&]() -> ConversionResult<IDLNullable<IDLDouble>> { return typename Converter<IDLNullable<IDLDouble>>::ReturnType { std::nullopt }; });
    if (expiresConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.expires = expiresConversionResult.releaseReturnValue();
    JSValue isHttpOnlyValue;
    if (isNullOrUndefined)
        isHttpOnlyValue = jsUndefined();
    else {
        isHttpOnlyValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "isHttpOnly"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto isHttpOnlyConversionResult = convertOptionalWithDefault<IDLBoolean>(lexicalGlobalObject, isHttpOnlyValue, [&]() -> ConversionResult<IDLBoolean> { return Converter<IDLBoolean>::ReturnType { false }; });
    if (isHttpOnlyConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.isHttpOnly = isHttpOnlyConversionResult.releaseReturnValue();
    JSValue isSameSiteLaxValue;
    if (isNullOrUndefined)
        isSameSiteLaxValue = jsUndefined();
    else {
        isSameSiteLaxValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "isSameSiteLax"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto isSameSiteLaxConversionResult = convertOptionalWithDefault<IDLBoolean>(lexicalGlobalObject, isSameSiteLaxValue, [&]() -> ConversionResult<IDLBoolean> { return Converter<IDLBoolean>::ReturnType { false }; });
    if (isSameSiteLaxConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.isSameSiteLax = isSameSiteLaxConversionResult.releaseReturnValue();
    JSValue isSameSiteStrictValue;
    if (isNullOrUndefined)
        isSameSiteStrictValue = jsUndefined();
    else {
        isSameSiteStrictValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "isSameSiteStrict"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto isSameSiteStrictConversionResult = convertOptionalWithDefault<IDLBoolean>(lexicalGlobalObject, isSameSiteStrictValue, [&]() -> ConversionResult<IDLBoolean> { return Converter<IDLBoolean>::ReturnType { false }; });
    if (isSameSiteStrictConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.isSameSiteStrict = isSameSiteStrictConversionResult.releaseReturnValue();
    JSValue isSecureValue;
    if (isNullOrUndefined)
        isSecureValue = jsUndefined();
    else {
        isSecureValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "isSecure"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto isSecureConversionResult = convertOptionalWithDefault<IDLBoolean>(lexicalGlobalObject, isSecureValue, [&]() -> ConversionResult<IDLBoolean> { return Converter<IDLBoolean>::ReturnType { false }; });
    if (isSecureConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.isSecure = isSecureConversionResult.releaseReturnValue();
    JSValue isSessionValue;
    if (isNullOrUndefined)
        isSessionValue = jsUndefined();
    else {
        isSessionValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "isSession"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto isSessionConversionResult = convertOptionalWithDefault<IDLBoolean>(lexicalGlobalObject, isSessionValue, [&]() -> ConversionResult<IDLBoolean> { return Converter<IDLBoolean>::ReturnType { false }; });
    if (isSessionConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.isSession = isSessionConversionResult.releaseReturnValue();
    JSValue nameValue;
    if (isNullOrUndefined)
        nameValue = jsUndefined();
    else {
        nameValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "name"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!nameValue.isUndefined()) {
        auto nameConversionResult = convert<IDLDOMString>(lexicalGlobalObject, nameValue);
        if (nameConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.name = nameConversionResult.releaseReturnValue();
    }
    JSValue pathValue;
    if (isNullOrUndefined)
        pathValue = jsUndefined();
    else {
        pathValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "path"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto pathConversionResult = convertOptionalWithDefault<IDLDOMString>(lexicalGlobalObject, pathValue, [&]() -> ConversionResult<IDLDOMString> { return Converter<IDLDOMString>::ReturnType { emptyString() }; });
    if (pathConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.path = pathConversionResult.releaseReturnValue();
    JSValue valueValue;
    if (isNullOrUndefined)
        valueValue = jsUndefined();
    else {
        valueValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "value"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!valueValue.isUndefined()) {
        auto valueConversionResult = convert<IDLDOMString>(lexicalGlobalObject, valueValue);
        if (valueConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.value = valueConversionResult.releaseReturnValue();
    }
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const Internals::CookieData& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    auto domainValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.domain);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "domain"_s), domainValue);
    auto expiresValue = toJS<IDLNullable<IDLDouble>>(lexicalGlobalObject, throwScope, dictionary.expires);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "expires"_s), expiresValue);
    auto isHttpOnlyValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, dictionary.isHttpOnly);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "isHttpOnly"_s), isHttpOnlyValue);
    auto isSameSiteLaxValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, dictionary.isSameSiteLax);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "isSameSiteLax"_s), isSameSiteLaxValue);
    auto isSameSiteStrictValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, dictionary.isSameSiteStrict);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "isSameSiteStrict"_s), isSameSiteStrictValue);
    auto isSecureValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, dictionary.isSecure);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "isSecure"_s), isSecureValue);
    auto isSessionValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, dictionary.isSession);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "isSession"_s), isSessionValue);
    if (!IDLDOMString::isNullValue(dictionary.name)) {
        auto nameValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.name));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "name"_s), nameValue);
    }
    auto pathValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, dictionary.path);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "path"_s), pathValue);
    if (!IDLDOMString::isNullValue(dictionary.value)) {
        auto valueValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.value));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "value"_s), valueValue);
    }
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const Internals::TextIndicatorInfo& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    if (!IDLInterface<DOMRectReadOnly>::isNullValue(dictionary.textBoundingRectInRootViewCoordinates)) {
        auto textBoundingRectInRootViewCoordinatesValue = toJS<IDLInterface<DOMRectReadOnly>>(lexicalGlobalObject, globalObject, throwScope, IDLInterface<DOMRectReadOnly>::extractValueFromNullable(dictionary.textBoundingRectInRootViewCoordinates));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "textBoundingRectInRootViewCoordinates"_s), textBoundingRectInRootViewCoordinatesValue);
    }
    if (!IDLInterface<DOMRectList>::isNullValue(dictionary.textRectsInBoundingRectCoordinates)) {
        auto textRectsInBoundingRectCoordinatesValue = toJS<IDLInterface<DOMRectList>>(lexicalGlobalObject, globalObject, throwScope, IDLInterface<DOMRectList>::extractValueFromNullable(dictionary.textRectsInBoundingRectCoordinates));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "textRectsInBoundingRectCoordinates"_s), textRectsInBoundingRectCoordinatesValue);
    }
    return result;
}

template<> ConversionResult<IDLDictionary<Internals::TextIndicatorOptions>> convertDictionary<Internals::TextIndicatorOptions>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    bool isNullOrUndefined = value.isUndefinedOrNull();
    auto* object = isNullOrUndefined ? nullptr : value.getObject();
    if (!isNullOrUndefined && !object) [[unlikely]] {
        throwTypeError(&lexicalGlobalObject, throwScope);
        return ConversionResultException { };
    }
    Internals::TextIndicatorOptions result;
    JSValue computeEstimatedBackgroundColorValue;
    if (isNullOrUndefined)
        computeEstimatedBackgroundColorValue = jsUndefined();
    else {
        computeEstimatedBackgroundColorValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "computeEstimatedBackgroundColor"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto computeEstimatedBackgroundColorConversionResult = convertOptionalWithDefault<IDLBoolean>(lexicalGlobalObject, computeEstimatedBackgroundColorValue, [&]() -> ConversionResult<IDLBoolean> { return Converter<IDLBoolean>::ReturnType { false }; });
    if (computeEstimatedBackgroundColorConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.computeEstimatedBackgroundColor = computeEstimatedBackgroundColorConversionResult.releaseReturnValue();
    JSValue respectTextColorValue;
    if (isNullOrUndefined)
        respectTextColorValue = jsUndefined();
    else {
        respectTextColorValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "respectTextColor"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto respectTextColorConversionResult = convertOptionalWithDefault<IDLBoolean>(lexicalGlobalObject, respectTextColorValue, [&]() -> ConversionResult<IDLBoolean> { return Converter<IDLBoolean>::ReturnType { false }; });
    if (respectTextColorConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.respectTextColor = respectTextColorConversionResult.releaseReturnValue();
    JSValue useBoundingRectAndPaintAllContentForComplexRangesValue;
    if (isNullOrUndefined)
        useBoundingRectAndPaintAllContentForComplexRangesValue = jsUndefined();
    else {
        useBoundingRectAndPaintAllContentForComplexRangesValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "useBoundingRectAndPaintAllContentForComplexRanges"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto useBoundingRectAndPaintAllContentForComplexRangesConversionResult = convertOptionalWithDefault<IDLBoolean>(lexicalGlobalObject, useBoundingRectAndPaintAllContentForComplexRangesValue, [&]() -> ConversionResult<IDLBoolean> { return Converter<IDLBoolean>::ReturnType { false }; });
    if (useBoundingRectAndPaintAllContentForComplexRangesConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.useBoundingRectAndPaintAllContentForComplexRanges = useBoundingRectAndPaintAllContentForComplexRangesConversionResult.releaseReturnValue();
    JSValue useUserSelectAllCommonAncestorValue;
    if (isNullOrUndefined)
        useUserSelectAllCommonAncestorValue = jsUndefined();
    else {
        useUserSelectAllCommonAncestorValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "useUserSelectAllCommonAncestor"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto useUserSelectAllCommonAncestorConversionResult = convertOptionalWithDefault<IDLBoolean>(lexicalGlobalObject, useUserSelectAllCommonAncestorValue, [&]() -> ConversionResult<IDLBoolean> { return Converter<IDLBoolean>::ReturnType { false }; });
    if (useUserSelectAllCommonAncestorConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.useUserSelectAllCommonAncestor = useUserSelectAllCommonAncestorConversionResult.releaseReturnValue();
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const Internals::TextIteratorState& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    if (!IDLInterface<Range>::isNullValue(dictionary.range)) {
        auto rangeValue = toJS<IDLInterface<Range>>(lexicalGlobalObject, globalObject, throwScope, IDLInterface<Range>::extractValueFromNullable(dictionary.range));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "range"_s), rangeValue);
    }
    if (!IDLDOMString::isNullValue(dictionary.text)) {
        auto textValue = toJS<IDLDOMString>(lexicalGlobalObject, throwScope, IDLDOMString::extractValueFromNullable(dictionary.text));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "text"_s), textValue);
    }
    return result;
}

template<> ConversionResult<IDLDictionary<Internals::ImageOverlayText>> convertDictionary<Internals::ImageOverlayText>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    bool isNullOrUndefined = value.isUndefinedOrNull();
    auto* object = isNullOrUndefined ? nullptr : value.getObject();
    if (!isNullOrUndefined && !object) [[unlikely]] {
        throwTypeError(&lexicalGlobalObject, throwScope);
        return ConversionResultException { };
    }
    Internals::ImageOverlayText result;
    JSValue bottomLeftValue;
    if (isNullOrUndefined)
        bottomLeftValue = jsUndefined();
    else {
        bottomLeftValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "bottomLeft"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (bottomLeftValue.isUndefined()) {
        throwRequiredMemberTypeError(lexicalGlobalObject, throwScope, "bottomLeft"_s, "ImageOverlayText"_s, "DOMPointReadOnly"_s);
        return ConversionResultException { };
    }
    auto bottomLeftConversionResult = convert<IDLInterface<DOMPointReadOnly>>(lexicalGlobalObject, bottomLeftValue);
    if (bottomLeftConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.bottomLeft = bottomLeftConversionResult.releaseReturnValue();
    JSValue bottomRightValue;
    if (isNullOrUndefined)
        bottomRightValue = jsUndefined();
    else {
        bottomRightValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "bottomRight"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (bottomRightValue.isUndefined()) {
        throwRequiredMemberTypeError(lexicalGlobalObject, throwScope, "bottomRight"_s, "ImageOverlayText"_s, "DOMPointReadOnly"_s);
        return ConversionResultException { };
    }
    auto bottomRightConversionResult = convert<IDLInterface<DOMPointReadOnly>>(lexicalGlobalObject, bottomRightValue);
    if (bottomRightConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.bottomRight = bottomRightConversionResult.releaseReturnValue();
    JSValue hasLeadingWhitespaceValue;
    if (isNullOrUndefined)
        hasLeadingWhitespaceValue = jsUndefined();
    else {
        hasLeadingWhitespaceValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "hasLeadingWhitespace"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto hasLeadingWhitespaceConversionResult = convertOptionalWithDefault<IDLBoolean>(lexicalGlobalObject, hasLeadingWhitespaceValue, [&]() -> ConversionResult<IDLBoolean> { return Converter<IDLBoolean>::ReturnType { true }; });
    if (hasLeadingWhitespaceConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.hasLeadingWhitespace = hasLeadingWhitespaceConversionResult.releaseReturnValue();
    JSValue textValue;
    if (isNullOrUndefined)
        textValue = jsUndefined();
    else {
        textValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "text"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (textValue.isUndefined()) {
        throwRequiredMemberTypeError(lexicalGlobalObject, throwScope, "text"_s, "ImageOverlayText"_s, "DOMString"_s);
        return ConversionResultException { };
    }
    auto textConversionResult = convert<IDLDOMString>(lexicalGlobalObject, textValue);
    if (textConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.text = textConversionResult.releaseReturnValue();
    JSValue topLeftValue;
    if (isNullOrUndefined)
        topLeftValue = jsUndefined();
    else {
        topLeftValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "topLeft"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (topLeftValue.isUndefined()) {
        throwRequiredMemberTypeError(lexicalGlobalObject, throwScope, "topLeft"_s, "ImageOverlayText"_s, "DOMPointReadOnly"_s);
        return ConversionResultException { };
    }
    auto topLeftConversionResult = convert<IDLInterface<DOMPointReadOnly>>(lexicalGlobalObject, topLeftValue);
    if (topLeftConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.topLeft = topLeftConversionResult.releaseReturnValue();
    JSValue topRightValue;
    if (isNullOrUndefined)
        topRightValue = jsUndefined();
    else {
        topRightValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "topRight"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (topRightValue.isUndefined()) {
        throwRequiredMemberTypeError(lexicalGlobalObject, throwScope, "topRight"_s, "ImageOverlayText"_s, "DOMPointReadOnly"_s);
        return ConversionResultException { };
    }
    auto topRightConversionResult = convert<IDLInterface<DOMPointReadOnly>>(lexicalGlobalObject, topRightValue);
    if (topRightConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.topRight = topRightConversionResult.releaseReturnValue();
    return result;
}

template<> ConversionResult<IDLDictionary<Internals::ImageOverlayLine>> convertDictionary<Internals::ImageOverlayLine>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    bool isNullOrUndefined = value.isUndefinedOrNull();
    auto* object = isNullOrUndefined ? nullptr : value.getObject();
    if (!isNullOrUndefined && !object) [[unlikely]] {
        throwTypeError(&lexicalGlobalObject, throwScope);
        return ConversionResultException { };
    }
    Internals::ImageOverlayLine result;
    JSValue bottomLeftValue;
    if (isNullOrUndefined)
        bottomLeftValue = jsUndefined();
    else {
        bottomLeftValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "bottomLeft"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (bottomLeftValue.isUndefined()) {
        throwRequiredMemberTypeError(lexicalGlobalObject, throwScope, "bottomLeft"_s, "ImageOverlayLine"_s, "DOMPointReadOnly"_s);
        return ConversionResultException { };
    }
    auto bottomLeftConversionResult = convert<IDLInterface<DOMPointReadOnly>>(lexicalGlobalObject, bottomLeftValue);
    if (bottomLeftConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.bottomLeft = bottomLeftConversionResult.releaseReturnValue();
    JSValue bottomRightValue;
    if (isNullOrUndefined)
        bottomRightValue = jsUndefined();
    else {
        bottomRightValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "bottomRight"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (bottomRightValue.isUndefined()) {
        throwRequiredMemberTypeError(lexicalGlobalObject, throwScope, "bottomRight"_s, "ImageOverlayLine"_s, "DOMPointReadOnly"_s);
        return ConversionResultException { };
    }
    auto bottomRightConversionResult = convert<IDLInterface<DOMPointReadOnly>>(lexicalGlobalObject, bottomRightValue);
    if (bottomRightConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.bottomRight = bottomRightConversionResult.releaseReturnValue();
    JSValue childrenValue;
    if (isNullOrUndefined)
        childrenValue = jsUndefined();
    else {
        childrenValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "children"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!childrenValue.isUndefined()) {
        auto childrenConversionResult = convert<IDLSequence<IDLDictionary<Internals::ImageOverlayText>>>(lexicalGlobalObject, childrenValue);
        if (childrenConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.children = childrenConversionResult.releaseReturnValue();
    }
    JSValue hasTrailingNewlineValue;
    if (isNullOrUndefined)
        hasTrailingNewlineValue = jsUndefined();
    else {
        hasTrailingNewlineValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "hasTrailingNewline"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto hasTrailingNewlineConversionResult = convertOptionalWithDefault<IDLBoolean>(lexicalGlobalObject, hasTrailingNewlineValue, [&]() -> ConversionResult<IDLBoolean> { return Converter<IDLBoolean>::ReturnType { true }; });
    if (hasTrailingNewlineConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.hasTrailingNewline = hasTrailingNewlineConversionResult.releaseReturnValue();
    JSValue isVerticalValue;
    if (isNullOrUndefined)
        isVerticalValue = jsUndefined();
    else {
        isVerticalValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "isVertical"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto isVerticalConversionResult = convertOptionalWithDefault<IDLBoolean>(lexicalGlobalObject, isVerticalValue, [&]() -> ConversionResult<IDLBoolean> { return Converter<IDLBoolean>::ReturnType { false }; });
    if (isVerticalConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.isVertical = isVerticalConversionResult.releaseReturnValue();
    JSValue topLeftValue;
    if (isNullOrUndefined)
        topLeftValue = jsUndefined();
    else {
        topLeftValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "topLeft"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (topLeftValue.isUndefined()) {
        throwRequiredMemberTypeError(lexicalGlobalObject, throwScope, "topLeft"_s, "ImageOverlayLine"_s, "DOMPointReadOnly"_s);
        return ConversionResultException { };
    }
    auto topLeftConversionResult = convert<IDLInterface<DOMPointReadOnly>>(lexicalGlobalObject, topLeftValue);
    if (topLeftConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.topLeft = topLeftConversionResult.releaseReturnValue();
    JSValue topRightValue;
    if (isNullOrUndefined)
        topRightValue = jsUndefined();
    else {
        topRightValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "topRight"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (topRightValue.isUndefined()) {
        throwRequiredMemberTypeError(lexicalGlobalObject, throwScope, "topRight"_s, "ImageOverlayLine"_s, "DOMPointReadOnly"_s);
        return ConversionResultException { };
    }
    auto topRightConversionResult = convert<IDLInterface<DOMPointReadOnly>>(lexicalGlobalObject, topRightValue);
    if (topRightConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.topRight = topRightConversionResult.releaseReturnValue();
    return result;
}

template<> ConversionResult<IDLDictionary<Internals::ImageOverlayBlock>> convertDictionary<Internals::ImageOverlayBlock>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    bool isNullOrUndefined = value.isUndefinedOrNull();
    auto* object = isNullOrUndefined ? nullptr : value.getObject();
    if (!isNullOrUndefined && !object) [[unlikely]] {
        throwTypeError(&lexicalGlobalObject, throwScope);
        return ConversionResultException { };
    }
    Internals::ImageOverlayBlock result;
    JSValue bottomLeftValue;
    if (isNullOrUndefined)
        bottomLeftValue = jsUndefined();
    else {
        bottomLeftValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "bottomLeft"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (bottomLeftValue.isUndefined()) {
        throwRequiredMemberTypeError(lexicalGlobalObject, throwScope, "bottomLeft"_s, "ImageOverlayBlock"_s, "DOMPointReadOnly"_s);
        return ConversionResultException { };
    }
    auto bottomLeftConversionResult = convert<IDLInterface<DOMPointReadOnly>>(lexicalGlobalObject, bottomLeftValue);
    if (bottomLeftConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.bottomLeft = bottomLeftConversionResult.releaseReturnValue();
    JSValue bottomRightValue;
    if (isNullOrUndefined)
        bottomRightValue = jsUndefined();
    else {
        bottomRightValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "bottomRight"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (bottomRightValue.isUndefined()) {
        throwRequiredMemberTypeError(lexicalGlobalObject, throwScope, "bottomRight"_s, "ImageOverlayBlock"_s, "DOMPointReadOnly"_s);
        return ConversionResultException { };
    }
    auto bottomRightConversionResult = convert<IDLInterface<DOMPointReadOnly>>(lexicalGlobalObject, bottomRightValue);
    if (bottomRightConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.bottomRight = bottomRightConversionResult.releaseReturnValue();
    JSValue textValue;
    if (isNullOrUndefined)
        textValue = jsUndefined();
    else {
        textValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "text"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (textValue.isUndefined()) {
        throwRequiredMemberTypeError(lexicalGlobalObject, throwScope, "text"_s, "ImageOverlayBlock"_s, "DOMString"_s);
        return ConversionResultException { };
    }
    auto textConversionResult = convert<IDLDOMString>(lexicalGlobalObject, textValue);
    if (textConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.text = textConversionResult.releaseReturnValue();
    JSValue topLeftValue;
    if (isNullOrUndefined)
        topLeftValue = jsUndefined();
    else {
        topLeftValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "topLeft"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (topLeftValue.isUndefined()) {
        throwRequiredMemberTypeError(lexicalGlobalObject, throwScope, "topLeft"_s, "ImageOverlayBlock"_s, "DOMPointReadOnly"_s);
        return ConversionResultException { };
    }
    auto topLeftConversionResult = convert<IDLInterface<DOMPointReadOnly>>(lexicalGlobalObject, topLeftValue);
    if (topLeftConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.topLeft = topLeftConversionResult.releaseReturnValue();
    JSValue topRightValue;
    if (isNullOrUndefined)
        topRightValue = jsUndefined();
    else {
        topRightValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "topRight"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (topRightValue.isUndefined()) {
        throwRequiredMemberTypeError(lexicalGlobalObject, throwScope, "topRight"_s, "ImageOverlayBlock"_s, "DOMPointReadOnly"_s);
        return ConversionResultException { };
    }
    auto topRightConversionResult = convert<IDLInterface<DOMPointReadOnly>>(lexicalGlobalObject, topRightValue);
    if (topRightConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.topRight = topRightConversionResult.releaseReturnValue();
    return result;
}

template<> ConversionResult<IDLDictionary<Internals::ImageOverlayDataDetector>> convertDictionary<Internals::ImageOverlayDataDetector>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    bool isNullOrUndefined = value.isUndefinedOrNull();
    auto* object = isNullOrUndefined ? nullptr : value.getObject();
    if (!isNullOrUndefined && !object) [[unlikely]] {
        throwTypeError(&lexicalGlobalObject, throwScope);
        return ConversionResultException { };
    }
    Internals::ImageOverlayDataDetector result;
    JSValue bottomLeftValue;
    if (isNullOrUndefined)
        bottomLeftValue = jsUndefined();
    else {
        bottomLeftValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "bottomLeft"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (bottomLeftValue.isUndefined()) {
        throwRequiredMemberTypeError(lexicalGlobalObject, throwScope, "bottomLeft"_s, "ImageOverlayDataDetector"_s, "DOMPointReadOnly"_s);
        return ConversionResultException { };
    }
    auto bottomLeftConversionResult = convert<IDLInterface<DOMPointReadOnly>>(lexicalGlobalObject, bottomLeftValue);
    if (bottomLeftConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.bottomLeft = bottomLeftConversionResult.releaseReturnValue();
    JSValue bottomRightValue;
    if (isNullOrUndefined)
        bottomRightValue = jsUndefined();
    else {
        bottomRightValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "bottomRight"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (bottomRightValue.isUndefined()) {
        throwRequiredMemberTypeError(lexicalGlobalObject, throwScope, "bottomRight"_s, "ImageOverlayDataDetector"_s, "DOMPointReadOnly"_s);
        return ConversionResultException { };
    }
    auto bottomRightConversionResult = convert<IDLInterface<DOMPointReadOnly>>(lexicalGlobalObject, bottomRightValue);
    if (bottomRightConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.bottomRight = bottomRightConversionResult.releaseReturnValue();
    JSValue topLeftValue;
    if (isNullOrUndefined)
        topLeftValue = jsUndefined();
    else {
        topLeftValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "topLeft"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (topLeftValue.isUndefined()) {
        throwRequiredMemberTypeError(lexicalGlobalObject, throwScope, "topLeft"_s, "ImageOverlayDataDetector"_s, "DOMPointReadOnly"_s);
        return ConversionResultException { };
    }
    auto topLeftConversionResult = convert<IDLInterface<DOMPointReadOnly>>(lexicalGlobalObject, topLeftValue);
    if (topLeftConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.topLeft = topLeftConversionResult.releaseReturnValue();
    JSValue topRightValue;
    if (isNullOrUndefined)
        topRightValue = jsUndefined();
    else {
        topRightValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "topRight"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (topRightValue.isUndefined()) {
        throwRequiredMemberTypeError(lexicalGlobalObject, throwScope, "topRight"_s, "ImageOverlayDataDetector"_s, "DOMPointReadOnly"_s);
        return ConversionResultException { };
    }
    auto topRightConversionResult = convert<IDLInterface<DOMPointReadOnly>>(lexicalGlobalObject, topRightValue);
    if (topRightConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.topRight = topRightConversionResult.releaseReturnValue();
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const Internals::SelectorFilterHashCounts& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    if (!IDLUnsignedLong::isNullValue(dictionary.attributes)) {
        auto attributesValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.attributes));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "attributes"_s), attributesValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.classes)) {
        auto classesValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.classes));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "classes"_s), classesValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.ids)) {
        auto idsValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.ids));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "ids"_s), idsValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.tags)) {
        auto tagsValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.tags));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "tags"_s), tagsValue);
    }
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const Internals::PDFAnnotationRect& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    if (!IDLDouble::isNullValue(dictionary.height)) {
        auto heightValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.height));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "height"_s), heightValue);
    }
    if (!IDLDouble::isNullValue(dictionary.width)) {
        auto widthValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.width));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "width"_s), widthValue);
    }
    if (!IDLDouble::isNullValue(dictionary.x)) {
        auto xValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.x));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "x"_s), xValue);
    }
    if (!IDLDouble::isNullValue(dictionary.y)) {
        auto yValue = toJS<IDLDouble>(lexicalGlobalObject, throwScope, IDLDouble::extractValueFromNullable(dictionary.y));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "y"_s), yValue);
    }
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const Internals::ImageBufferResourceLimits& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    if (!IDLUnsignedLongLong::isNullValue(dictionary.acceleratedImageBufferForCanvasCount)) {
        auto acceleratedImageBufferForCanvasCountValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.acceleratedImageBufferForCanvasCount));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "acceleratedImageBufferForCanvasCount"_s), acceleratedImageBufferForCanvasCountValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.acceleratedImageBufferForCanvasLimit)) {
        auto acceleratedImageBufferForCanvasLimitValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.acceleratedImageBufferForCanvasLimit));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "acceleratedImageBufferForCanvasLimit"_s), acceleratedImageBufferForCanvasLimitValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.globalAcceleratedImageBufferCount)) {
        auto globalAcceleratedImageBufferCountValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.globalAcceleratedImageBufferCount));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "globalAcceleratedImageBufferCount"_s), globalAcceleratedImageBufferCountValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.globalAcceleratedImageBufferLimit)) {
        auto globalAcceleratedImageBufferLimitValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.globalAcceleratedImageBufferLimit));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "globalAcceleratedImageBufferLimit"_s), globalAcceleratedImageBufferLimitValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.globalImageBufferForCanvasCount)) {
        auto globalImageBufferForCanvasCountValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.globalImageBufferForCanvasCount));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "globalImageBufferForCanvasCount"_s), globalImageBufferForCanvasCountValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.globalImageBufferForCanvasLimit)) {
        auto globalImageBufferForCanvasLimitValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.globalImageBufferForCanvasLimit));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "globalImageBufferForCanvasLimit"_s), globalImageBufferForCanvasLimitValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.imageBufferForCanvasCount)) {
        auto imageBufferForCanvasCountValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.imageBufferForCanvasCount));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "imageBufferForCanvasCount"_s), imageBufferForCanvasCountValue);
    }
    if (!IDLUnsignedLongLong::isNullValue(dictionary.imageBufferForCanvasLimit)) {
        auto imageBufferForCanvasLimitValue = toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, IDLUnsignedLongLong::extractValueFromNullable(dictionary.imageBufferForCanvasLimit));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "imageBufferForCanvasLimit"_s), imageBufferForCanvasLimitValue);
    }
    return result;
}

#if ENABLE(DAMAGE_TRACKING)

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const Internals::FrameDamage& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    if (!IDLInterface<DOMRectReadOnly>::isNullValue(dictionary.bounds)) {
        auto boundsValue = toJS<IDLInterface<DOMRectReadOnly>>(lexicalGlobalObject, globalObject, throwScope, IDLInterface<DOMRectReadOnly>::extractValueFromNullable(dictionary.bounds));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "bounds"_s), boundsValue);
    }
    if (!IDLSequence<IDLInterface<DOMRectReadOnly>>::isNullValue(dictionary.rects)) {
        auto rectsValue = toJS<IDLSequence<IDLInterface<DOMRectReadOnly>>>(lexicalGlobalObject, globalObject, throwScope, IDLSequence<IDLInterface<DOMRectReadOnly>>::extractValueFromNullable(dictionary.rects));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "rects"_s), rectsValue);
    }
    if (!IDLUnsignedLong::isNullValue(dictionary.sequenceId)) {
        auto sequenceIdValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, IDLUnsignedLong::extractValueFromNullable(dictionary.sequenceId));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "sequenceId"_s), sequenceIdValue);
    }
    return result;
}

#endif

// Functions

static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_address);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_nodeNeedsStyleRecalc);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_styleChangeType);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_description);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_log);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasPausedImageAnimations);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_markFrontBufferVolatile);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isFullyActive);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isPaintingFrequently);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_incrementFrequentPaintCounter);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_purgeFrontBuffer);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_purgeBackBuffer);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_elementRenderTreeAsText);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isPreloaded);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isLoadingFromMemoryCache);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_fetchResponseSource);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_xhrResponseSource);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isSharingStyleSheetContents);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isStyleSheetLoadingSubresources);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_clearMemoryCache);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_pruneMemoryCacheToSize);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_destroyDecodedDataForAllImages);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_memoryCacheSize);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setOverrideCachePolicy);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setOverrideResourceLoadPriority);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setStrictRawResourceValidationPolicyDisabled);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_getResourcePriority);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isFetchObjectContextStopped);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_clearBackForwardCache);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_backForwardCacheSize);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_preventDocumentFromEnteringBackForwardCache);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_computedStyleIncludingVisitedInfo);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_ensureUserAgentShadowRoot);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_shadowRoot);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_shadowRootType);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_userAgentPart);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setUserAgentPart);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_treeScopeRootNode);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_parentTreeScope);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_lastSpatialNavigationCandidateCount);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_animationWithIdExists);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_numberOfActiveAnimations);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_suspendAnimations);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_resumeAnimations);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_animationsAreSuspended);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_acceleratedAnimationsForElement);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_numberOfAnimationTimelineInvalidations);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_timeToNextAnimationTick);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_pseudoElement);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_preferredRenderingUpdateInterval);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_visiblePlaceholder);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_selectColorInColorChooser);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_formControlStateOfPreviousHistoryItem);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setFormControlStateOfPreviousHistoryItem);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_absoluteLineRectFromPoint);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_absoluteCaretBounds);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isCaretVisible);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isCaretBlinkingSuspended);
#if ENABLE(ACCESSIBILITY_NON_BLINKING_CURSOR)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPrefersNonBlinkingCursor);
#endif
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_boundingBox);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_inspectorGridOverlayCount);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_inspectorFlexOverlayCount);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_inspectorHighlightRects);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_inspectorPaintRectCount);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_markerCountForNode);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_markerRangeForNode);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_markerDescriptionForNode);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_dumpMarkerRects);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMarkedTextMatchesAreHighlighted);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_snapshotNode);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_invalidateFontCache);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setScrollViewPosition);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_unconstrainedScrollTo);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_scrollBySimulatingWheelEvent);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_layoutViewportRect);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_visualViewportRect);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setViewIsTransparent);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_viewBaseBackgroundColor);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setViewBaseBackgroundColor);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setUnderPageBackgroundColorOverride);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_documentBackgroundColor);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_displayP3Available);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPagination);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_lineIndexAfterPageBreak);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_configurationForViewport);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_wasLastChangeUserEdit);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_elementShouldAutoComplete);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setAutofilled);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setAutofilledAndViewable);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setAutofilledAndObscured);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setAutofillButtonType);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_autofillButtonType);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_lastAutofillButtonType);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_recentSearches);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setCanShowPlaceholder);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_insertTextPlaceholder);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_removeTextPlaceholder);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_rangeOfString);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_countMatchesForText);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_countFindMatches);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_autofillFieldName);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isSpellcheckDisabledExceptTextReplacement);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_invalidateControlTints);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_scrollElementToRect);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_rangeFromLocationAndLength);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_locationFromRange);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_lengthFromRange);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_rangeAsText);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_rangeAsTextUsingBackwardsTextIterator);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_subrange);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_rangeForDictionaryLookupAtLocation);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_rangeOfStringNearLocation);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_statesOfTextIterator);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_textFragmentDirectiveForRange);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setDelegatesScrolling);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_lastSpellCheckRequestSequence);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_lastSpellCheckProcessedSequence);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_advanceToNextMisspelling);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_userPreferredLanguages);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setUserPreferredLanguages);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_userPreferredAudioCharacteristics);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setUserPreferredAudioCharacteristic);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_wheelEventHandlerCount);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_touchEventHandlerCount);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_touchEventRectsForEvent);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_passiveTouchEventListenerRects);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_nodesFromRect);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_parserMetaData);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_updateEditorUINowIfScheduled);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasSpellingMarker);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasGrammarMarker);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasAutocorrectedMarker);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasDictationAlternativesMarker);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasCorrectionIndicatorMarker);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasTransparentContentMarker);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setContinuousSpellCheckingEnabled);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setAutomaticQuoteSubstitutionEnabled);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setAutomaticLinkDetectionEnabled);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setAutomaticDashSubstitutionEnabled);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setAutomaticTextReplacementEnabled);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setAutomaticSpellingCorrectionEnabled);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMarkerFor);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_handleAcceptedCandidate);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_changeSelectionListType);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_changeBackToReplacedString);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isOverwriteModeEnabled);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_toggleOverwriteModeEnabled);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_numberOfScrollableAreas);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isPageBoxVisible);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_imageFrameIndex);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_imageFrameCount);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_imageFrameDurationAtIndex);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setImageFrameDecodingDuration);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_resetImageAnimation);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isImageAnimating);
#if ENABLE(ACCESSIBILITY_ANIMATION_CONTROL)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setImageAnimationEnabled);
#endif
#if ENABLE(ACCESSIBILITY_ANIMATION_CONTROL)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_resumeImageAnimation);
#endif
#if ENABLE(ACCESSIBILITY_ANIMATION_CONTROL)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_pauseImageAnimation);
#endif
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_imagePendingDecodePromisesCountForTesting);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setClearDecoderAfterAsyncFrameRequestForTesting);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_imageDecodeCount);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_imageBlankDrawCount);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_imageLastDecodingOptions);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_imageCachedSubimageCreateCount);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_remoteImagesCountForTesting);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setAsyncDecodingEnabledForTesting);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setForceUpdateImageDataEnabledForTesting);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setHasHDRContentForTesting);
#if ENABLE(WEB_CODECS)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasPendingActivity);
#endif
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setGridMaxTracksLimit);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_svgAnimationsInterval);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_allSVGSVGElements);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_testProcessIncomingSyncMessagesWhenWaitingForSyncReply);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setResourceCachingDisabledByWebInspector);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_lowerAllFrameMemoryMonitorLimits);
#if ENABLE(DAMAGE_TRACKING)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_getFrameDamageHistory);
#endif
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_layerTreeAsText);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_layerIDForElement);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_horizontalScrollbarLayerID);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_verticalScrollbarLayerID);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_scrollingNodeIDForNode);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_platformLayerTreeAsText);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_scrollbarOverlayStyle);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_scrollbarUsingDarkAppearance);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_horizontalScrollbarState);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_verticalScrollbarState);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_scrollbarsControllerTypeForNode);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_scrollingStateTreeAsText);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_scrollingTreeAsText);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_haveScrollingTree);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_synchronousScrollingReasons);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_nonFastScrollableRects);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_repaintRectsAsText);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setElementUsesDisplayListDrawing);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setElementTracksDisplayListReplay);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_displayListForElement);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_replayDisplayListForElement);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setForceUseGlyphDisplayListForTesting);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_cachedGlyphDisplayListsForTextNode);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_clearGlyphDisplayListCacheForTesting);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_garbageCollectDocumentResources);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_insertAuthorCSS);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_insertUserCSS);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_beginSimulatedMemoryWarning);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_endSimulatedMemoryWarning);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_beginSimulatedMemoryPressure);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_endSimulatedMemoryPressure);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_numberOfIDBTransactions);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_scrollableAreaWidth);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_numberOfLiveNodes);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_numberOfLiveDocuments);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_referencingNodeCount);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_executeOpportunisticallyScheduledTasks);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_numberOfIntersectionObservers);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_numberOfResizeObservers);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_openDummyInspectorFrontend);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_closeDummyInspectorFrontend);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setInspectorIsUnderTest);
#if ENABLE(WEB_AUDIO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_baseAudioContextIdentifier);
#endif
#if ENABLE(WEB_AUDIO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isBaseAudioContextAlive);
#endif
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_counterValue);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_pageNumber);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_shortcutIconURLs);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_numberOfPages);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_pageProperty);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_pageSizeAndMarginsInPixels);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_pageScaleFactor);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPageZoomFactor);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setTextZoomFactor);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setUseFixedLayout);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setFixedLayoutSize);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPrinting);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setViewExposedRect);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setHeaderHeight);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setFooterHeight);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setFullscreenInsets);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setFullscreenAutoHideDuration);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setScreenContentsFormatsForTesting);
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isChangingPresentationMode);
#endif
#if ENABLE(VIDEO_PRESENTATION_MODE)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMockVideoPresentationModeEnabled);
#endif
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setApplicationCacheOriginQuota);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_registerURLSchemeAsBypassingContentSecurityPolicy);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_removeURLSchemeRegisteredAsBypassingContentSecurityPolicy);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_registerDefaultPortForProtocol);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_mallocStatistics);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_typeConversions);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_memoryInfo);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_getReferencedFilePaths);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_startTrackingRepaints);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_stopTrackingRepaints);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_startTrackingLayerFlushes);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_layerFlushCount);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setCanvasNoiseInjectionSalt);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_doesCanvasHavePendingCanvasNoiseInjection);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isTimerThrottled);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_requestAnimationFrameThrottlingReasons);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_areTimersThrottled);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setLowPowerModeEnabled);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setAggressiveThermalMitigationEnabled);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setOutsideViewportThrottlingEnabled);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_startTrackingStyleRecalcs);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_styleRecalcCount);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_startTrackingLayoutUpdates);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_layoutUpdateCount);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_startTrackingRenderLayerPositionUpdates);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_renderLayerPositionUpdateCount);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_startTrackingCompositingUpdates);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_compositingUpdateCount);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_startTrackingRenderingUpdates);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_renderingUpdateCount);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_updateLayoutAndStyleForAllFrames);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasks);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_getCurrentCursorInfo);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_markerTextForListItem);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_toolTipFromElement);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_deserializeBuffer);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_serializeObject);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isFromCurrentWorld);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_evaluateInWorldIgnoringException);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setUsesOverlayScrollbars);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_forceAXObjectCacheUpdate);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_forceReload);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_reloadExpiredOnly);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_enableFixedWidthAutoSizeMode);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_enableSizeToContentAutoSizeMode);
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_mediaResponseSources);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_mediaResponseContentRanges);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_simulateAudioInterruption);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_mediaElementHasCharacteristic);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_beginSimulatedHDCPError);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_endSimulatedHDCPError);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_mediaPlayerRenderingCanBeAccelerated);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_elementShouldBufferData);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_elementBufferingPolicy);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMediaElementBufferingPolicy);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_privatePlayerVolume);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_privatePlayerMuted);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isMediaElementHidden);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setOverridePreferredDynamicRangeMode);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_elementEffectivePlaybackRate);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_enableGStreamerHolePunching);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_effectiveDynamicRangeLimitValue);
#endif
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_getContextEffectiveDynamicRangeLimitValue);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPageShouldSuppressHDR);
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_enterViewerMode);
#endif
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setIsPlayingToBluetoothOverride);
#if ENABLE(LEGACY_ENCRYPTED_MEDIA)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_initializeMockCDM);
#endif
#if ENABLE(ENCRYPTED_MEDIA)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_registerMockCDM);
#endif
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_enableMockMediaCapabilities);
#if ENABLE(SPEECH_SYNTHESIS)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_enableMockSpeechSynthesizer);
#endif
#if ENABLE(SPEECH_SYNTHESIS)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_simulateSpeechSynthesizerVoiceListChange);
#endif
#if ENABLE(SPEECH_SYNTHESIS)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_enableMockSpeechSynthesizerForMediaElement);
#endif
#if ENABLE(SPEECH_SYNTHESIS)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setSpeechUtteranceDuration);
#endif
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_getImageSourceURL);
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_captionsStyleSheetOverride);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setCaptionsStyleSheetOverride);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPrimaryAudioTrackLanguageOverride);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setCaptionDisplayMode);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_createGenericCue);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_textTrackBCP47Language);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_createTimeRanges);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_closestTimeToTimeRanges);
#endif
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isSelectPopupVisible);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_selectionBounds);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_selectedRange);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setSelectionWithoutValidation);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setSelectionFromNone);
#if ENABLE(MEDIA_SOURCE)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_initializeMockMediaSource);
#endif
#if ENABLE(MEDIA_SOURCE)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_bufferedSamplesForTrackId);
#endif
#if ENABLE(MEDIA_SOURCE)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMaximumSourceBufferSize);
#endif
#if ENABLE(MEDIA_SOURCE)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_enqueuedSamplesForTrackID);
#endif
#if ENABLE(MEDIA_SOURCE)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setShouldGenerateTimestamps);
#endif
#if ENABLE(MEDIA_SOURCE)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_minimumUpcomingPresentationTimeForTrackID);
#endif
#if ENABLE(MEDIA_SOURCE)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMaximumQueueDepthForTrackID);
#endif
#if ENABLE(MEDIA_SOURCE)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_evictableSize);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_beginMediaSessionInterruption);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_endMediaSessionInterruption);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_applicationWillBecomeInactive);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_applicationDidBecomeActive);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_applicationWillEnterForeground);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_applicationDidEnterBackground);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMediaSessionRestrictions);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_mediaSessionRestrictions);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMediaElementRestrictions);
#endif
#if ENABLE(WEB_AUDIO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setAudioContextRestrictions);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_postRemoteControlCommand);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_activeAudioRouteDidChange);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_beginAudioSessionInterruption);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_endAudioSessionInterruption);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_clearAudioSessionInterruptionFlag);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_suspendAllMediaBuffering);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_suspendAllMediaPlayback);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_resumeAllMediaPlayback);
#endif
#if ENABLE(WIRELESS_PLAYBACK_TARGET)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMockMediaPlaybackTargetPickerEnabled);
#endif
#if ENABLE(WIRELESS_PLAYBACK_TARGET)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMockMediaPlaybackTargetPickerState);
#endif
#if ENABLE(WIRELESS_PLAYBACK_TARGET)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_mockMediaPlaybackTargetPickerDismissPopup);
#endif
#if ENABLE(MEDIA_RECORDER)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setCustomPrivateRecorderCreator);
#endif
#if ENABLE(WEB_AUDIO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_useMockAudioDestinationCocoa);
#endif
#if ENABLE(WEB_RTC)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_emulateRTCPeerConnectionPlatformEvent);
#endif
#if ENABLE(WEB_RTC)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_useMockRTCPeerConnectionFactory);
#endif
#if ENABLE(WEB_RTC)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setICECandidateFiltering);
#endif
#if ENABLE(WEB_RTC)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setEnumeratingAllNetworkInterfacesEnabled);
#endif
#if ENABLE(WEB_RTC)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_stopPeerConnection);
#endif
#if ENABLE(WEB_RTC)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_clearPeerConnectionFactory);
#endif
#if ENABLE(WEB_RTC)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setEnableWebRTCEncryption);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_simulateSystemSleep);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_simulateSystemWake);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_elementIsBlockingDisplaySleep);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isPlayerVisibleInViewport);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isPlayerMuted);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isPlayerPaused);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_forceStereoDecoding);
#endif
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_installMockPageOverlay);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_pageOverlayLayerTreeAsText);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPageMuted);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_pageMediaState);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPageDefersLoading);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_pageDefersLoading);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_grantUniversalAccess);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_disableCORSForURL);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_createFile);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_asyncCreateFile);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_createTemporaryFile);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_queueMicroTask);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_testPreloaderSettingViewport);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_scrollSnapOffsets);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isScrollSnapInProgress);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPlatformMomentumScrollingPredictionEnabled);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_pathStringWithShrinkWrappedRects);
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_getCurrentMediaControlsStatusForElement);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMediaControlsMaximumRightContainerButtonCountOverride);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMediaControlsHidePlaybackRates);
#endif
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_userVisibleString);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_pageMediaVolume);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPageMediaVolume);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setShowAllPlugins);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_cloneArrayBuffer);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isReadableStreamDisturbed);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_resourceLoadStatisticsForURL);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setTrackingPreventionEnabled);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setCanShowModalDialogOverride);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_composedTreeAsText);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isProcessingUserGesture);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_lastHandledUserGestureTimestamp);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_withUserGesture);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_withoutUserGesture);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_userIsInteracting);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasTransientActivation);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasHistoryActionActivation);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_observeGC);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setUserInterfaceLayoutDirection);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setBaseWritingDirection);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_userPrefersContrast);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_userPrefersReducedMotion);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_reportBacktrace);
#if ENABLE(POINTER_LOCK)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_pageHasPendingPointerLock);
#endif
#if ENABLE(POINTER_LOCK)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_pageHasPointerLock);
#endif
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_accessKeyModifiers);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setQuickLookPassword);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setAsRunningUserScripts);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_disableTileSizeUpdateDelay);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setSpeculativeTilingDelayDisabledForTesting);
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_simulateEventForWebGLContext);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_requestedGPU);
#endif
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPageVisibility);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPageIsFocused);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPageIsFocusedAndActive);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPageIsInWindow);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isPageActive);
#if ENABLE(WEB_RTC)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_applyRotationForOutgoingVideoSources);
#endif
#if ENABLE(WEB_RTC)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setWebRTCH265Support);
#endif
#if ENABLE(WEB_RTC)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setWebRTCVP9Support);
#endif
#if ENABLE(WEB_RTC)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_disableWebRTCHardwareVP9);
#endif
#if ENABLE(WEB_RTC)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isSupportingVP9HardwareDecoder);
#endif
#if ENABLE(WEB_RTC)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isVP9HardwareDecoderUsed);
#endif
#if ENABLE(WEB_RTC)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setSFrameCounter);
#endif
#if ENABLE(WEB_RTC)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_sframeCounter);
#endif
#if ENABLE(WEB_RTC)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_sframeKeyId);
#endif
#if ENABLE(MEDIA_STREAM)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMockAudioTrackChannelNumber);
#endif
#if ENABLE(MEDIA_STREAM)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setShouldInterruptAudioOnPageVisibilityChange);
#endif
#if ENABLE(MEDIA_STREAM)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setCameraMediaStreamTrackOrientation);
#endif
#if ENABLE(MEDIA_STREAM)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_observeMediaStreamTrack);
#endif
#if ENABLE(MEDIA_STREAM)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_mediaStreamTrackVideoFrameRotation);
#endif
#if ENABLE(MEDIA_STREAM)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_delayMediaStreamTrackSamples);
#endif
#if ENABLE(MEDIA_STREAM)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMediaStreamTrackMuted);
#endif
#if ENABLE(MEDIA_STREAM)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_removeMediaStreamTrack);
#endif
#if ENABLE(MEDIA_STREAM)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_simulateMediaStreamTrackCaptureSourceFailure);
#endif
#if ENABLE(MEDIA_STREAM)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMediaStreamTrackIdentifier);
#endif
#if ENABLE(MEDIA_STREAM)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMediaStreamSourceInterrupted);
#endif
#if ENABLE(MEDIA_STREAM)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isMediaStreamSourceInterrupted);
#endif
#if ENABLE(MEDIA_STREAM)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isMediaStreamSourceEnded);
#endif
#if ENABLE(MEDIA_STREAM)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isMockRealtimeMediaSourceCenterEnabled);
#endif
#if ENABLE(MEDIA_STREAM)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_shouldAudioTrackPlay);
#endif
#if ENABLE(MEDIA_STREAM)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_mediaStreamTrackPersistentId);
#endif
#if ENABLE(MEDIA_STREAM)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_audioCaptureSourceCount);
#endif
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isHardwareVP9DecoderExpected);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_documentIdentifier);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isDocumentAlive);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_messagePortIdentifier);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isMessagePortAlive);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_elementIdentifier);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isElementAlive);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_pageIdentifier);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isAnyWorkletGlobalScopeAlive);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_serviceWorkerClientInternalIdentifier);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_storeRegistrationsOnDisk);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_sendH2Ping);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_clearCacheStorageMemoryRepresentation);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_cacheStorageEngineRepresentation);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setResponseSizeWithPadding);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_responseSizeWithPadding);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_responseNetworkLoadMetricsProtocol);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_blobInternalURL);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isBlobInternalURLRegistered);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_updateQuotaBasedOnSpaceUsage);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setConsoleMessageListener);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_audioSessionCategory);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_audioSessionMode);
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_categoryAtMostRecentPlayback);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_modeAtMostRecentPlayback);
#endif
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_routeSharingPolicy);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_preferredAudioBufferSize);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_currentAudioBufferSize);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_audioSessionActive);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasServiceWorkerRegistration);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_terminateServiceWorker);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_whenServiceWorkerIsTerminated);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_terminateWebContentProcess);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isSystemPreviewLink);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isSystemPreviewImage);
#if ENABLE(IMAGE_ANALYSIS)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_requestTextRecognition);
#endif
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_installImageOverlay);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_usingAppleInternalSDK);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_usingGStreamer);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_postTask);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_queueTask);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_queueTaskToQueueMicrotask);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasSameEventLoopAs);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_windowLocationHost);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_markContextAsInsecure);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMaxCanvasArea);
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_elementIsActiveNowPlayingSession);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_bestMediaElementForRemoteControls);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_mediaSessionState);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_mediaUsageState);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_elementShouldDisplayPosterImage);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMediaElementVolumeLocked);
#endif
#if ENABLE(SPEECH_SYNTHESIS)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_speechSynthesisUtteranceForCue);
#endif
#if ENABLE(SPEECH_SYNTHESIS)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_mediaElementCurrentlySpokenCue);
#endif
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_ongoingLoadsDescriptions);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setCaptureExtraNetworkLoadMetricsEnabled);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_reloadWithoutContentExtensions);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_disableContentExtensionsChecks);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_pluginCount);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_pluginScrollPositionX);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_pluginScrollPositionY);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_notifyResourceLoadObserver);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_primaryScreenDisplayID);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_capsLockIsOn);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_parseHEVCCodecParameters);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_createHEVCCodecParametersString);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_parseDoViCodecParameters);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_createDoViCodecParametersString);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_parseVPCodecParameters);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_parseAV1CodecParameters);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_createAV1CodecParametersString);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_validateAV1ConfigurationRecord);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_validateAV1PerLevelConstraints);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setCookie);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_getCookies);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setAlwaysAllowLocalWebarchive);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_processWillSuspend);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_processDidResume);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_testDictionaryLogging);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMaximumIntervalForUserGestureForwardingForFetch);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setTransientActivationDuration);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setIsPlayingToAutomotiveHeadUnit);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_textIndicatorForRange);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_addPrefetchLoadEventListener);
#if ENABLE(WEB_AUTHN)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMockWebAuthenticationConfiguration);
#endif
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_createInternalsMapLike);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_createInternalsSetLike);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_highlightPseudoElementColor);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasSandboxMachLookupAccessToGlobalName);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasSandboxMachLookupAccessToXPCServiceName);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasSandboxIOKitOpenAccessToClass);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasSandboxUnixSyscallAccess);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_systemColorForCSSValue);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_focusRingColor);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_systemHasBattery);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setSystemHasBatteryForTesting);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setSystemHasACForTesting);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setHardwareVP9DecoderDisabledForTesting);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setVP9DecoderDisabledForTesting);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setVP9ScreenSizeAndScaleForTesting);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_readPreferenceInteger);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_encodedPreferenceValue);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_supportsPictureInPicture);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isRemoteUIAppForAccessibility);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_createSleepDisabler);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_destroySleepDisabler);
#if ENABLE(APP_HIGHLIGHTS)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_numberOfAppHighlights);
#endif
#if ENABLE(ENCRYPTED_MEDIA)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_mediaKeysInternalInstanceObjectRefCount);
#endif
#if ENABLE(ENCRYPTED_MEDIA)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_mediaKeySessionInternalInstanceSessionObjectRefCount);
#endif
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setContentSizeCategory);
#if ENABLE(SERVICE_CONTROLS)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasImageControls);
#endif
#if ENABLE(MEDIA_SESSION)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_currentMediaSessionPosition);
#endif
#if ENABLE(MEDIA_SESSION)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_sendMediaSessionAction);
#endif
#if ENABLE(MEDIA_SESSION) && ENABLE(WEB_CODECS)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_loadArtworkImage);
#endif
#if ENABLE(MEDIA_SESSION)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_platformSupportedCommands);
#endif
#if ENABLE(MEDIA_SESSION_COORDINATOR)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_registerMockMediaSessionCoordinator);
#endif
#if ENABLE(MEDIA_SESSION_COORDINATOR)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMockMediaSessionCoordinatorCommandsShouldFail);
#endif
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_treeOrder);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_treeOrderBoundaryPoints);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_rangeContainsNode);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_rangeContainsRange);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_rangeContainsBoundaryPoint);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_rangeIntersectsNode);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_rangeIntersectsRange);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_systemBeep);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_dumpStyleResolvers);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setDocumentAutoplayPolicy);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_retainTextIteratorForDocumentContent);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_createPushSubscription);
#if ENABLE(ARKIT_INLINE_PREVIEW_MAC)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_modelInlinePreviewUUIDs);
#endif
#if ENABLE(ARKIT_INLINE_PREVIEW_MAC)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_modelInlinePreviewUUIDForModelElement);
#endif
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasSleepDisabler);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_acceptTypedArrays);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_consumeTransientActivation);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_consumeHistoryActionUserActivation);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_selectorFilterHashCounts);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setHistoryTotalStateObjectPayloadLimitOverride);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isUsingUISideCompositing);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_getComputedLabel);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_getComputedRole);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_pdfAnnotationRectsForTesting);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPDFTextAnnotationValueForTesting);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_registerPDFTest);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPDFDisplayModeForTesting);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_unlockPDFDocumentForTesting);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_sendEditingCommandToPDFForTesting);
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isEffectivelyMuted);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_addInternalEventTarget);
#endif
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_getEffectiveRenderingModeOfNewlyCreatedAcceleratedImageBuffer);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_getImageBufferResourceLimits);
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_setTopDocumentURLForQuirks);
#if ENABLE(MODEL_ELEMENT)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_disableModelLoadDelaysForTesting);
#endif
#if ENABLE(MODEL_ELEMENT)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_modelElementState);
#endif
#if ENABLE(MODEL_ELEMENT)
static JSC_DECLARE_HOST_FUNCTION(jsInternalsPrototypeFunction_isModelElementIntersectingViewport);
#endif

// Attributes

static JSC_DECLARE_CUSTOM_GETTER(jsInternals_inflightBeaconsCount);
static JSC_DECLARE_CUSTOM_GETTER(jsInternals_animationsInterval);
static JSC_DECLARE_CUSTOM_GETTER(jsInternals_sentenceRetroCorrectionEnabled);
static JSC_DECLARE_CUSTOM_GETTER(jsInternals_settings);
static JSC_DECLARE_CUSTOM_GETTER(jsInternals_workerThreadCount);
static JSC_DECLARE_CUSTOM_GETTER(jsInternals_areSVGAnimationsPaused);
static JSC_DECLARE_CUSTOM_GETTER(jsInternals_isUnderMemoryWarning);
static JSC_DECLARE_CUSTOM_GETTER(jsInternals_isUnderMemoryPressure);
static JSC_DECLARE_CUSTOM_GETTER(jsInternals_requestAnimationFrameInterval);
static JSC_DECLARE_CUSTOM_GETTER(jsInternals_scriptedAnimationsAreSuspended);
static JSC_DECLARE_CUSTOM_GETTER(jsInternals_eventThrottlingBehaviorOverride);
static JSC_DECLARE_CUSTOM_SETTER(setJSInternals_eventThrottlingBehaviorOverride);
static JSC_DECLARE_CUSTOM_GETTER(jsInternals_lastStyleUpdateSize);
static JSC_DECLARE_CUSTOM_GETTER(jsInternals_compositingPolicyOverride);
static JSC_DECLARE_CUSTOM_SETTER(setJSInternals_compositingPolicyOverride);
#if ENABLE(SPEECH_SYNTHESIS)
static JSC_DECLARE_CUSTOM_GETTER(jsInternals_minimumExpectedVoiceCount);
#endif
static JSC_DECLARE_CUSTOM_GETTER(jsInternals_isMonitoringWirelessRoutes);
#if ENABLE(CONTENT_FILTERING)
static JSC_DECLARE_CUSTOM_GETTER(jsInternals_mockContentFilterSettings);
#endif
#if ENABLE(MEDIA_STREAM)
static JSC_DECLARE_CUSTOM_GETTER(jsInternals_trackAudioSampleCount);
#endif
#if ENABLE(MEDIA_STREAM)
static JSC_DECLARE_CUSTOM_GETTER(jsInternals_trackVideoSampleCount);
#endif
#if ENABLE(WEB_RTC)
static JSC_DECLARE_CUSTOM_GETTER(jsInternals_rtcNetworkInterfaceName);
#endif
static JSC_DECLARE_CUSTOM_GETTER(jsInternals_storageAreaMapCount);
static JSC_DECLARE_CUSTOM_GETTER(jsInternals_processIdentifier);
static JSC_DECLARE_CUSTOM_GETTER(jsInternals_supportsAudioSession);
#if ENABLE(IMAGE_ANALYSIS)
static JSC_DECLARE_CUSTOM_GETTER(jsInternals_textRecognitionCandidate);
#endif
static JSC_DECLARE_CUSTOM_GETTER(jsInternals_hasActiveDataDetectorHighlight);
#if ENABLE(VIDEO)
static JSC_DECLARE_CUSTOM_GETTER(jsInternals_nowPlayingMetadata);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_CUSTOM_GETTER(jsInternals_nowPlayingState);
#endif
#if ENABLE(VIDEO)
static JSC_DECLARE_CUSTOM_GETTER(jsInternals_mediaElementCount);
#endif
#if ENABLE(APP_HIGHLIGHTS)
static JSC_DECLARE_CUSTOM_GETTER(jsInternals_appHighlightContextMenuItemTitles);
#endif
static JSC_DECLARE_CUSTOM_GETTER(jsInternals_isVisuallyNonEmpty);
static JSC_DECLARE_CUSTOM_GETTER(jsInternals_hasScopeBreakingHasSelectors);
static JSC_DECLARE_CUSTOM_GETTER(jsInternals_defaultSpatialTrackingLabel);

class JSInternalsPrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;
    static JSInternalsPrototype* create(JSC::VM& vm, JSDOMGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSInternalsPrototype* ptr = new (NotNull, JSC::allocateCell<JSInternalsPrototype>(vm)) JSInternalsPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSInternalsPrototype, Base);
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSInternalsPrototype(JSC::VM& vm, JSC::JSGlobalObject*, JSC::Structure* structure)
        : JSC::JSNonFinalObject(vm, structure)
    {
    }

    void finishCreation(JSC::VM&);
};
STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSInternalsPrototype, JSInternalsPrototype::Base);

/* Hash table for prototype */

static const std::array<HashTableValue, 657> JSInternalsPrototypeTableValues {
    HashTableValue { "inflightBeaconsCount"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_inflightBeaconsCount, 0 } },
    HashTableValue { "animationsInterval"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_animationsInterval, 0 } },
    HashTableValue { "sentenceRetroCorrectionEnabled"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_sentenceRetroCorrectionEnabled, 0 } },
    HashTableValue { "settings"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_settings, 0 } },
    HashTableValue { "workerThreadCount"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_workerThreadCount, 0 } },
    HashTableValue { "areSVGAnimationsPaused"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_areSVGAnimationsPaused, 0 } },
    HashTableValue { "isUnderMemoryWarning"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_isUnderMemoryWarning, 0 } },
    HashTableValue { "isUnderMemoryPressure"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_isUnderMemoryPressure, 0 } },
    HashTableValue { "requestAnimationFrameInterval"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_requestAnimationFrameInterval, 0 } },
    HashTableValue { "scriptedAnimationsAreSuspended"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_scriptedAnimationsAreSuspended, 0 } },
    HashTableValue { "eventThrottlingBehaviorOverride"_s, JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_eventThrottlingBehaviorOverride, setJSInternals_eventThrottlingBehaviorOverride } },
    HashTableValue { "lastStyleUpdateSize"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_lastStyleUpdateSize, 0 } },
    HashTableValue { "compositingPolicyOverride"_s, JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_compositingPolicyOverride, setJSInternals_compositingPolicyOverride } },
#if ENABLE(SPEECH_SYNTHESIS)
    HashTableValue { "minimumExpectedVoiceCount"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_minimumExpectedVoiceCount, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "isMonitoringWirelessRoutes"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_isMonitoringWirelessRoutes, 0 } },
#if ENABLE(CONTENT_FILTERING)
    HashTableValue { "mockContentFilterSettings"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_mockContentFilterSettings, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_STREAM)
    HashTableValue { "trackAudioSampleCount"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_trackAudioSampleCount, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_STREAM)
    HashTableValue { "trackVideoSampleCount"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_trackVideoSampleCount, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEB_RTC)
    HashTableValue { "rtcNetworkInterfaceName"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_rtcNetworkInterfaceName, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "storageAreaMapCount"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_storageAreaMapCount, 0 } },
    HashTableValue { "processIdentifier"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_processIdentifier, 0 } },
    HashTableValue { "supportsAudioSession"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_supportsAudioSession, 0 } },
#if ENABLE(IMAGE_ANALYSIS)
    HashTableValue { "textRecognitionCandidate"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_textRecognitionCandidate, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "hasActiveDataDetectorHighlight"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_hasActiveDataDetectorHighlight, 0 } },
#if ENABLE(VIDEO)
    HashTableValue { "nowPlayingMetadata"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_nowPlayingMetadata, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "nowPlayingState"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_nowPlayingState, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "mediaElementCount"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_mediaElementCount, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(APP_HIGHLIGHTS)
    HashTableValue { "appHighlightContextMenuItemTitles"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_appHighlightContextMenuItemTitles, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "isVisuallyNonEmpty"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_isVisuallyNonEmpty, 0 } },
    HashTableValue { "hasScopeBreakingHasSelectors"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_hasScopeBreakingHasSelectors, 0 } },
    HashTableValue { "defaultSpatialTrackingLabel"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsInternals_defaultSpatialTrackingLabel, 0 } },
    HashTableValue { "address"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_address, 1 } },
    HashTableValue { "nodeNeedsStyleRecalc"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_nodeNeedsStyleRecalc, 1 } },
    HashTableValue { "styleChangeType"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_styleChangeType, 1 } },
    HashTableValue { "description"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_description, 1 } },
    HashTableValue { "log"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_log, 1 } },
    HashTableValue { "hasPausedImageAnimations"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_hasPausedImageAnimations, 1 } },
    HashTableValue { "markFrontBufferVolatile"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_markFrontBufferVolatile, 1 } },
    HashTableValue { "isFullyActive"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isFullyActive, 1 } },
    HashTableValue { "isPaintingFrequently"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isPaintingFrequently, 1 } },
    HashTableValue { "incrementFrequentPaintCounter"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_incrementFrequentPaintCounter, 1 } },
    HashTableValue { "purgeFrontBuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_purgeFrontBuffer, 1 } },
    HashTableValue { "purgeBackBuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_purgeBackBuffer, 1 } },
    HashTableValue { "elementRenderTreeAsText"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_elementRenderTreeAsText, 1 } },
    HashTableValue { "isPreloaded"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isPreloaded, 1 } },
    HashTableValue { "isLoadingFromMemoryCache"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isLoadingFromMemoryCache, 1 } },
    HashTableValue { "fetchResponseSource"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_fetchResponseSource, 1 } },
    HashTableValue { "xhrResponseSource"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_xhrResponseSource, 1 } },
    HashTableValue { "isSharingStyleSheetContents"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isSharingStyleSheetContents, 2 } },
    HashTableValue { "isStyleSheetLoadingSubresources"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isStyleSheetLoadingSubresources, 1 } },
    HashTableValue { "clearMemoryCache"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_clearMemoryCache, 0 } },
    HashTableValue { "pruneMemoryCacheToSize"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_pruneMemoryCacheToSize, 1 } },
    HashTableValue { "destroyDecodedDataForAllImages"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_destroyDecodedDataForAllImages, 0 } },
    HashTableValue { "memoryCacheSize"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_memoryCacheSize, 0 } },
    HashTableValue { "setOverrideCachePolicy"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setOverrideCachePolicy, 1 } },
    HashTableValue { "setOverrideResourceLoadPriority"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setOverrideResourceLoadPriority, 1 } },
    HashTableValue { "setStrictRawResourceValidationPolicyDisabled"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setStrictRawResourceValidationPolicyDisabled, 1 } },
    HashTableValue { "getResourcePriority"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_getResourcePriority, 1 } },
    HashTableValue { "isFetchObjectContextStopped"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isFetchObjectContextStopped, 1 } },
    HashTableValue { "clearBackForwardCache"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_clearBackForwardCache, 0 } },
    HashTableValue { "backForwardCacheSize"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_backForwardCacheSize, 0 } },
    HashTableValue { "preventDocumentFromEnteringBackForwardCache"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_preventDocumentFromEnteringBackForwardCache, 0 } },
    HashTableValue { "computedStyleIncludingVisitedInfo"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_computedStyleIncludingVisitedInfo, 1 } },
    HashTableValue { "ensureUserAgentShadowRoot"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_ensureUserAgentShadowRoot, 1 } },
    HashTableValue { "shadowRoot"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_shadowRoot, 1 } },
    HashTableValue { "shadowRootType"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_shadowRootType, 1 } },
    HashTableValue { "userAgentPart"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_userAgentPart, 1 } },
    HashTableValue { "setUserAgentPart"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setUserAgentPart, 2 } },
    HashTableValue { "treeScopeRootNode"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_treeScopeRootNode, 1 } },
    HashTableValue { "parentTreeScope"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_parentTreeScope, 1 } },
    HashTableValue { "lastSpatialNavigationCandidateCount"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_lastSpatialNavigationCandidateCount, 0 } },
    HashTableValue { "animationWithIdExists"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_animationWithIdExists, 1 } },
    HashTableValue { "numberOfActiveAnimations"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_numberOfActiveAnimations, 0 } },
    HashTableValue { "suspendAnimations"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_suspendAnimations, 0 } },
    HashTableValue { "resumeAnimations"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_resumeAnimations, 0 } },
    HashTableValue { "animationsAreSuspended"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_animationsAreSuspended, 0 } },
    HashTableValue { "acceleratedAnimationsForElement"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_acceleratedAnimationsForElement, 1 } },
    HashTableValue { "numberOfAnimationTimelineInvalidations"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_numberOfAnimationTimelineInvalidations, 0 } },
    HashTableValue { "timeToNextAnimationTick"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_timeToNextAnimationTick, 1 } },
    HashTableValue { "pseudoElement"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_pseudoElement, 2 } },
    HashTableValue { "preferredRenderingUpdateInterval"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_preferredRenderingUpdateInterval, 0 } },
    HashTableValue { "visiblePlaceholder"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_visiblePlaceholder, 1 } },
    HashTableValue { "selectColorInColorChooser"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_selectColorInColorChooser, 2 } },
    HashTableValue { "formControlStateOfPreviousHistoryItem"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_formControlStateOfPreviousHistoryItem, 0 } },
    HashTableValue { "setFormControlStateOfPreviousHistoryItem"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setFormControlStateOfPreviousHistoryItem, 1 } },
    HashTableValue { "absoluteLineRectFromPoint"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_absoluteLineRectFromPoint, 2 } },
    HashTableValue { "absoluteCaretBounds"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_absoluteCaretBounds, 0 } },
    HashTableValue { "isCaretVisible"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isCaretVisible, 0 } },
    HashTableValue { "isCaretBlinkingSuspended"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isCaretBlinkingSuspended, 0 } },
#if ENABLE(ACCESSIBILITY_NON_BLINKING_CURSOR)
    HashTableValue { "setPrefersNonBlinkingCursor"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setPrefersNonBlinkingCursor, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "boundingBox"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_boundingBox, 1 } },
    HashTableValue { "inspectorGridOverlayCount"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_inspectorGridOverlayCount, 0 } },
    HashTableValue { "inspectorFlexOverlayCount"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_inspectorFlexOverlayCount, 0 } },
    HashTableValue { "inspectorHighlightRects"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_inspectorHighlightRects, 0 } },
    HashTableValue { "inspectorPaintRectCount"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_inspectorPaintRectCount, 0 } },
    HashTableValue { "markerCountForNode"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_markerCountForNode, 2 } },
    HashTableValue { "markerRangeForNode"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_markerRangeForNode, 3 } },
    HashTableValue { "markerDescriptionForNode"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_markerDescriptionForNode, 3 } },
    HashTableValue { "dumpMarkerRects"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_dumpMarkerRects, 1 } },
    HashTableValue { "setMarkedTextMatchesAreHighlighted"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setMarkedTextMatchesAreHighlighted, 1 } },
    HashTableValue { "snapshotNode"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_snapshotNode, 1 } },
    HashTableValue { "invalidateFontCache"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_invalidateFontCache, 0 } },
    HashTableValue { "setScrollViewPosition"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setScrollViewPosition, 2 } },
    HashTableValue { "unconstrainedScrollTo"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_unconstrainedScrollTo, 3 } },
    HashTableValue { "scrollBySimulatingWheelEvent"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_scrollBySimulatingWheelEvent, 3 } },
    HashTableValue { "layoutViewportRect"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_layoutViewportRect, 0 } },
    HashTableValue { "visualViewportRect"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_visualViewportRect, 0 } },
    HashTableValue { "setViewIsTransparent"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setViewIsTransparent, 1 } },
    HashTableValue { "viewBaseBackgroundColor"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_viewBaseBackgroundColor, 0 } },
    HashTableValue { "setViewBaseBackgroundColor"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setViewBaseBackgroundColor, 1 } },
    HashTableValue { "setUnderPageBackgroundColorOverride"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setUnderPageBackgroundColorOverride, 1 } },
    HashTableValue { "documentBackgroundColor"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_documentBackgroundColor, 0 } },
    HashTableValue { "displayP3Available"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_displayP3Available, 0 } },
    HashTableValue { "setPagination"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setPagination, 2 } },
    HashTableValue { "lineIndexAfterPageBreak"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_lineIndexAfterPageBreak, 1 } },
    HashTableValue { "configurationForViewport"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_configurationForViewport, 5 } },
    HashTableValue { "wasLastChangeUserEdit"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_wasLastChangeUserEdit, 1 } },
    HashTableValue { "elementShouldAutoComplete"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_elementShouldAutoComplete, 1 } },
    HashTableValue { "setAutofilled"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setAutofilled, 2 } },
    HashTableValue { "setAutofilledAndViewable"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setAutofilledAndViewable, 2 } },
    HashTableValue { "setAutofilledAndObscured"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setAutofilledAndObscured, 2 } },
    HashTableValue { "setAutofillButtonType"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setAutofillButtonType, 2 } },
    HashTableValue { "autofillButtonType"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_autofillButtonType, 1 } },
    HashTableValue { "lastAutofillButtonType"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_lastAutofillButtonType, 1 } },
    HashTableValue { "recentSearches"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_recentSearches, 1 } },
    HashTableValue { "setCanShowPlaceholder"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setCanShowPlaceholder, 2 } },
    HashTableValue { "insertTextPlaceholder"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_insertTextPlaceholder, 2 } },
    HashTableValue { "removeTextPlaceholder"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_removeTextPlaceholder, 1 } },
    HashTableValue { "rangeOfString"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_rangeOfString, 3 } },
    HashTableValue { "countMatchesForText"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_countMatchesForText, 3 } },
    HashTableValue { "countFindMatches"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_countFindMatches, 2 } },
    HashTableValue { "autofillFieldName"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_autofillFieldName, 1 } },
    HashTableValue { "isSpellcheckDisabledExceptTextReplacement"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isSpellcheckDisabledExceptTextReplacement, 1 } },
    HashTableValue { "invalidateControlTints"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_invalidateControlTints, 0 } },
    HashTableValue { "scrollElementToRect"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_scrollElementToRect, 5 } },
    HashTableValue { "rangeFromLocationAndLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_rangeFromLocationAndLength, 3 } },
    HashTableValue { "locationFromRange"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_locationFromRange, 2 } },
    HashTableValue { "lengthFromRange"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_lengthFromRange, 2 } },
    HashTableValue { "rangeAsText"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_rangeAsText, 1 } },
    HashTableValue { "rangeAsTextUsingBackwardsTextIterator"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_rangeAsTextUsingBackwardsTextIterator, 1 } },
    HashTableValue { "subrange"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_subrange, 3 } },
    HashTableValue { "rangeForDictionaryLookupAtLocation"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_rangeForDictionaryLookupAtLocation, 2 } },
    HashTableValue { "rangeOfStringNearLocation"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_rangeOfStringNearLocation, 3 } },
    HashTableValue { "statesOfTextIterator"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_statesOfTextIterator, 1 } },
    HashTableValue { "textFragmentDirectiveForRange"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_textFragmentDirectiveForRange, 1 } },
    HashTableValue { "setDelegatesScrolling"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setDelegatesScrolling, 1 } },
    HashTableValue { "lastSpellCheckRequestSequence"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_lastSpellCheckRequestSequence, 0 } },
    HashTableValue { "lastSpellCheckProcessedSequence"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_lastSpellCheckProcessedSequence, 0 } },
    HashTableValue { "advanceToNextMisspelling"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_advanceToNextMisspelling, 0 } },
    HashTableValue { "userPreferredLanguages"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_userPreferredLanguages, 0 } },
    HashTableValue { "setUserPreferredLanguages"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setUserPreferredLanguages, 1 } },
    HashTableValue { "userPreferredAudioCharacteristics"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_userPreferredAudioCharacteristics, 0 } },
    HashTableValue { "setUserPreferredAudioCharacteristic"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setUserPreferredAudioCharacteristic, 1 } },
    HashTableValue { "wheelEventHandlerCount"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_wheelEventHandlerCount, 0 } },
    HashTableValue { "touchEventHandlerCount"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_touchEventHandlerCount, 0 } },
    HashTableValue { "touchEventRectsForEvent"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_touchEventRectsForEvent, 1 } },
    HashTableValue { "passiveTouchEventListenerRects"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_passiveTouchEventListenerRects, 0 } },
    HashTableValue { "nodesFromRect"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_nodesFromRect, 10 } },
    HashTableValue { "parserMetaData"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_parserMetaData, 0 } },
    HashTableValue { "updateEditorUINowIfScheduled"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_updateEditorUINowIfScheduled, 0 } },
    HashTableValue { "hasSpellingMarker"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_hasSpellingMarker, 2 } },
    HashTableValue { "hasGrammarMarker"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_hasGrammarMarker, 2 } },
    HashTableValue { "hasAutocorrectedMarker"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_hasAutocorrectedMarker, 2 } },
    HashTableValue { "hasDictationAlternativesMarker"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_hasDictationAlternativesMarker, 2 } },
    HashTableValue { "hasCorrectionIndicatorMarker"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_hasCorrectionIndicatorMarker, 2 } },
    HashTableValue { "hasTransparentContentMarker"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_hasTransparentContentMarker, 2 } },
    HashTableValue { "setContinuousSpellCheckingEnabled"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setContinuousSpellCheckingEnabled, 1 } },
    HashTableValue { "setAutomaticQuoteSubstitutionEnabled"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setAutomaticQuoteSubstitutionEnabled, 1 } },
    HashTableValue { "setAutomaticLinkDetectionEnabled"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setAutomaticLinkDetectionEnabled, 1 } },
    HashTableValue { "setAutomaticDashSubstitutionEnabled"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setAutomaticDashSubstitutionEnabled, 1 } },
    HashTableValue { "setAutomaticTextReplacementEnabled"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setAutomaticTextReplacementEnabled, 1 } },
    HashTableValue { "setAutomaticSpellingCorrectionEnabled"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setAutomaticSpellingCorrectionEnabled, 1 } },
    HashTableValue { "setMarkerFor"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setMarkerFor, 4 } },
    HashTableValue { "handleAcceptedCandidate"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_handleAcceptedCandidate, 3 } },
    HashTableValue { "changeSelectionListType"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_changeSelectionListType, 0 } },
    HashTableValue { "changeBackToReplacedString"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_changeBackToReplacedString, 1 } },
    HashTableValue { "isOverwriteModeEnabled"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isOverwriteModeEnabled, 0 } },
    HashTableValue { "toggleOverwriteModeEnabled"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_toggleOverwriteModeEnabled, 0 } },
    HashTableValue { "numberOfScrollableAreas"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_numberOfScrollableAreas, 0 } },
    HashTableValue { "isPageBoxVisible"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isPageBoxVisible, 1 } },
    HashTableValue { "imageFrameIndex"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_imageFrameIndex, 1 } },
    HashTableValue { "imageFrameCount"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_imageFrameCount, 1 } },
    HashTableValue { "imageFrameDurationAtIndex"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_imageFrameDurationAtIndex, 2 } },
    HashTableValue { "setImageFrameDecodingDuration"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setImageFrameDecodingDuration, 2 } },
    HashTableValue { "resetImageAnimation"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_resetImageAnimation, 1 } },
    HashTableValue { "isImageAnimating"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isImageAnimating, 1 } },
#if ENABLE(ACCESSIBILITY_ANIMATION_CONTROL)
    HashTableValue { "setImageAnimationEnabled"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setImageAnimationEnabled, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(ACCESSIBILITY_ANIMATION_CONTROL)
    HashTableValue { "resumeImageAnimation"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_resumeImageAnimation, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(ACCESSIBILITY_ANIMATION_CONTROL)
    HashTableValue { "pauseImageAnimation"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_pauseImageAnimation, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "imagePendingDecodePromisesCountForTesting"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_imagePendingDecodePromisesCountForTesting, 1 } },
    HashTableValue { "setClearDecoderAfterAsyncFrameRequestForTesting"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setClearDecoderAfterAsyncFrameRequestForTesting, 2 } },
    HashTableValue { "imageDecodeCount"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_imageDecodeCount, 1 } },
    HashTableValue { "imageBlankDrawCount"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_imageBlankDrawCount, 1 } },
    HashTableValue { "imageLastDecodingOptions"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_imageLastDecodingOptions, 1 } },
    HashTableValue { "imageCachedSubimageCreateCount"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_imageCachedSubimageCreateCount, 1 } },
    HashTableValue { "remoteImagesCountForTesting"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_remoteImagesCountForTesting, 0 } },
    HashTableValue { "setAsyncDecodingEnabledForTesting"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setAsyncDecodingEnabledForTesting, 2 } },
    HashTableValue { "setForceUpdateImageDataEnabledForTesting"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setForceUpdateImageDataEnabledForTesting, 2 } },
    HashTableValue { "setHasHDRContentForTesting"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setHasHDRContentForTesting, 1 } },
#if ENABLE(WEB_CODECS)
    HashTableValue { "hasPendingActivity"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_hasPendingActivity, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "setGridMaxTracksLimit"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setGridMaxTracksLimit, 1 } },
    HashTableValue { "svgAnimationsInterval"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_svgAnimationsInterval, 1 } },
    HashTableValue { "allSVGSVGElements"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_allSVGSVGElements, 0 } },
    HashTableValue { "testProcessIncomingSyncMessagesWhenWaitingForSyncReply"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_testProcessIncomingSyncMessagesWhenWaitingForSyncReply, 0 } },
    HashTableValue { "setResourceCachingDisabledByWebInspector"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setResourceCachingDisabledByWebInspector, 1 } },
    HashTableValue { "lowerAllFrameMemoryMonitorLimits"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_lowerAllFrameMemoryMonitorLimits, 0 } },
#if ENABLE(DAMAGE_TRACKING)
    HashTableValue { "getFrameDamageHistory"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_getFrameDamageHistory, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "layerTreeAsText"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_layerTreeAsText, 1 } },
    HashTableValue { "layerIDForElement"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_layerIDForElement, 1 } },
    HashTableValue { "horizontalScrollbarLayerID"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_horizontalScrollbarLayerID, 0 } },
    HashTableValue { "verticalScrollbarLayerID"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_verticalScrollbarLayerID, 0 } },
    HashTableValue { "scrollingNodeIDForNode"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_scrollingNodeIDForNode, 0 } },
    HashTableValue { "platformLayerTreeAsText"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_platformLayerTreeAsText, 1 } },
    HashTableValue { "scrollbarOverlayStyle"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_scrollbarOverlayStyle, 0 } },
    HashTableValue { "scrollbarUsingDarkAppearance"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_scrollbarUsingDarkAppearance, 0 } },
    HashTableValue { "horizontalScrollbarState"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_horizontalScrollbarState, 0 } },
    HashTableValue { "verticalScrollbarState"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_verticalScrollbarState, 0 } },
    HashTableValue { "scrollbarsControllerTypeForNode"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_scrollbarsControllerTypeForNode, 0 } },
    HashTableValue { "scrollingStateTreeAsText"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_scrollingStateTreeAsText, 0 } },
    HashTableValue { "scrollingTreeAsText"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_scrollingTreeAsText, 0 } },
    HashTableValue { "haveScrollingTree"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_haveScrollingTree, 0 } },
    HashTableValue { "synchronousScrollingReasons"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_synchronousScrollingReasons, 0 } },
    HashTableValue { "nonFastScrollableRects"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_nonFastScrollableRects, 0 } },
    HashTableValue { "repaintRectsAsText"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_repaintRectsAsText, 0 } },
    HashTableValue { "setElementUsesDisplayListDrawing"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setElementUsesDisplayListDrawing, 2 } },
    HashTableValue { "setElementTracksDisplayListReplay"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setElementTracksDisplayListReplay, 2 } },
    HashTableValue { "displayListForElement"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_displayListForElement, 1 } },
    HashTableValue { "replayDisplayListForElement"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_replayDisplayListForElement, 1 } },
    HashTableValue { "setForceUseGlyphDisplayListForTesting"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setForceUseGlyphDisplayListForTesting, 1 } },
    HashTableValue { "cachedGlyphDisplayListsForTextNode"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_cachedGlyphDisplayListsForTextNode, 1 } },
    HashTableValue { "clearGlyphDisplayListCacheForTesting"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_clearGlyphDisplayListCacheForTesting, 0 } },
    HashTableValue { "garbageCollectDocumentResources"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_garbageCollectDocumentResources, 0 } },
    HashTableValue { "insertAuthorCSS"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_insertAuthorCSS, 1 } },
    HashTableValue { "insertUserCSS"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_insertUserCSS, 1 } },
    HashTableValue { "beginSimulatedMemoryWarning"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_beginSimulatedMemoryWarning, 0 } },
    HashTableValue { "endSimulatedMemoryWarning"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_endSimulatedMemoryWarning, 0 } },
    HashTableValue { "beginSimulatedMemoryPressure"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_beginSimulatedMemoryPressure, 0 } },
    HashTableValue { "endSimulatedMemoryPressure"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_endSimulatedMemoryPressure, 0 } },
    HashTableValue { "numberOfIDBTransactions"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_numberOfIDBTransactions, 0 } },
    HashTableValue { "scrollableAreaWidth"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_scrollableAreaWidth, 1 } },
    HashTableValue { "numberOfLiveNodes"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_numberOfLiveNodes, 0 } },
    HashTableValue { "numberOfLiveDocuments"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_numberOfLiveDocuments, 0 } },
    HashTableValue { "referencingNodeCount"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_referencingNodeCount, 1 } },
    HashTableValue { "executeOpportunisticallyScheduledTasks"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_executeOpportunisticallyScheduledTasks, 0 } },
    HashTableValue { "numberOfIntersectionObservers"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_numberOfIntersectionObservers, 1 } },
    HashTableValue { "numberOfResizeObservers"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_numberOfResizeObservers, 1 } },
    HashTableValue { "openDummyInspectorFrontend"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_openDummyInspectorFrontend, 1 } },
    HashTableValue { "closeDummyInspectorFrontend"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_closeDummyInspectorFrontend, 0 } },
    HashTableValue { "setInspectorIsUnderTest"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setInspectorIsUnderTest, 1 } },
#if ENABLE(WEB_AUDIO)
    HashTableValue { "baseAudioContextIdentifier"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_baseAudioContextIdentifier, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEB_AUDIO)
    HashTableValue { "isBaseAudioContextAlive"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isBaseAudioContextAlive, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "counterValue"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_counterValue, 1 } },
    HashTableValue { "pageNumber"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_pageNumber, 1 } },
    HashTableValue { "shortcutIconURLs"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_shortcutIconURLs, 0 } },
    HashTableValue { "numberOfPages"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_numberOfPages, 0 } },
    HashTableValue { "pageProperty"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_pageProperty, 2 } },
    HashTableValue { "pageSizeAndMarginsInPixels"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_pageSizeAndMarginsInPixels, 7 } },
    HashTableValue { "pageScaleFactor"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_pageScaleFactor, 0 } },
    HashTableValue { "setPageZoomFactor"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setPageZoomFactor, 1 } },
    HashTableValue { "setTextZoomFactor"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setTextZoomFactor, 1 } },
    HashTableValue { "setUseFixedLayout"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setUseFixedLayout, 1 } },
    HashTableValue { "setFixedLayoutSize"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setFixedLayoutSize, 2 } },
    HashTableValue { "setPrinting"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setPrinting, 2 } },
    HashTableValue { "setViewExposedRect"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setViewExposedRect, 4 } },
    HashTableValue { "setHeaderHeight"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setHeaderHeight, 1 } },
    HashTableValue { "setFooterHeight"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setFooterHeight, 1 } },
    HashTableValue { "setFullscreenInsets"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setFullscreenInsets, 1 } },
    HashTableValue { "setFullscreenAutoHideDuration"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setFullscreenAutoHideDuration, 1 } },
    HashTableValue { "setScreenContentsFormatsForTesting"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setScreenContentsFormatsForTesting, 1 } },
#if ENABLE(VIDEO)
    HashTableValue { "isChangingPresentationMode"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isChangingPresentationMode, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO_PRESENTATION_MODE)
    HashTableValue { "setMockVideoPresentationModeEnabled"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setMockVideoPresentationModeEnabled, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "setApplicationCacheOriginQuota"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setApplicationCacheOriginQuota, 1 } },
    HashTableValue { "registerURLSchemeAsBypassingContentSecurityPolicy"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_registerURLSchemeAsBypassingContentSecurityPolicy, 1 } },
    HashTableValue { "removeURLSchemeRegisteredAsBypassingContentSecurityPolicy"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_removeURLSchemeRegisteredAsBypassingContentSecurityPolicy, 1 } },
    HashTableValue { "registerDefaultPortForProtocol"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_registerDefaultPortForProtocol, 2 } },
    HashTableValue { "mallocStatistics"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_mallocStatistics, 0 } },
    HashTableValue { "typeConversions"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_typeConversions, 0 } },
    HashTableValue { "memoryInfo"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_memoryInfo, 0 } },
    HashTableValue { "getReferencedFilePaths"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_getReferencedFilePaths, 0 } },
    HashTableValue { "startTrackingRepaints"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_startTrackingRepaints, 0 } },
    HashTableValue { "stopTrackingRepaints"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_stopTrackingRepaints, 0 } },
    HashTableValue { "startTrackingLayerFlushes"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_startTrackingLayerFlushes, 0 } },
    HashTableValue { "layerFlushCount"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_layerFlushCount, 0 } },
    HashTableValue { "setCanvasNoiseInjectionSalt"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setCanvasNoiseInjectionSalt, 2 } },
    HashTableValue { "doesCanvasHavePendingCanvasNoiseInjection"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_doesCanvasHavePendingCanvasNoiseInjection, 1 } },
    HashTableValue { "isTimerThrottled"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isTimerThrottled, 1 } },
    HashTableValue { "requestAnimationFrameThrottlingReasons"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_requestAnimationFrameThrottlingReasons, 0 } },
    HashTableValue { "areTimersThrottled"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_areTimersThrottled, 0 } },
    HashTableValue { "setLowPowerModeEnabled"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setLowPowerModeEnabled, 1 } },
    HashTableValue { "setAggressiveThermalMitigationEnabled"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setAggressiveThermalMitigationEnabled, 1 } },
    HashTableValue { "setOutsideViewportThrottlingEnabled"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setOutsideViewportThrottlingEnabled, 1 } },
    HashTableValue { "startTrackingStyleRecalcs"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_startTrackingStyleRecalcs, 0 } },
    HashTableValue { "styleRecalcCount"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_styleRecalcCount, 0 } },
    HashTableValue { "startTrackingLayoutUpdates"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_startTrackingLayoutUpdates, 0 } },
    HashTableValue { "layoutUpdateCount"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_layoutUpdateCount, 0 } },
    HashTableValue { "startTrackingRenderLayerPositionUpdates"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_startTrackingRenderLayerPositionUpdates, 0 } },
    HashTableValue { "renderLayerPositionUpdateCount"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_renderLayerPositionUpdateCount, 0 } },
    HashTableValue { "startTrackingCompositingUpdates"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_startTrackingCompositingUpdates, 0 } },
    HashTableValue { "compositingUpdateCount"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_compositingUpdateCount, 0 } },
    HashTableValue { "startTrackingRenderingUpdates"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_startTrackingRenderingUpdates, 0 } },
    HashTableValue { "renderingUpdateCount"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_renderingUpdateCount, 0 } },
    HashTableValue { "updateLayoutAndStyleForAllFrames"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_updateLayoutAndStyleForAllFrames, 0 } },
    HashTableValue { "updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasks"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasks, 0 } },
    HashTableValue { "getCurrentCursorInfo"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_getCurrentCursorInfo, 0 } },
    HashTableValue { "markerTextForListItem"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_markerTextForListItem, 1 } },
    HashTableValue { "toolTipFromElement"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_toolTipFromElement, 1 } },
    HashTableValue { "deserializeBuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_deserializeBuffer, 1 } },
    HashTableValue { "serializeObject"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_serializeObject, 1 } },
    HashTableValue { "isFromCurrentWorld"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isFromCurrentWorld, 1 } },
    HashTableValue { "evaluateInWorldIgnoringException"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_evaluateInWorldIgnoringException, 2 } },
    HashTableValue { "setUsesOverlayScrollbars"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setUsesOverlayScrollbars, 1 } },
    HashTableValue { "forceAXObjectCacheUpdate"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_forceAXObjectCacheUpdate, 0 } },
    HashTableValue { "forceReload"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_forceReload, 1 } },
    HashTableValue { "reloadExpiredOnly"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_reloadExpiredOnly, 0 } },
    HashTableValue { "enableFixedWidthAutoSizeMode"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_enableFixedWidthAutoSizeMode, 3 } },
    HashTableValue { "enableSizeToContentAutoSizeMode"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_enableSizeToContentAutoSizeMode, 3 } },
#if ENABLE(VIDEO)
    HashTableValue { "mediaResponseSources"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_mediaResponseSources, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "mediaResponseContentRanges"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_mediaResponseContentRanges, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "simulateAudioInterruption"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_simulateAudioInterruption, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "mediaElementHasCharacteristic"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_mediaElementHasCharacteristic, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "beginSimulatedHDCPError"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_beginSimulatedHDCPError, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "endSimulatedHDCPError"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_endSimulatedHDCPError, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "mediaPlayerRenderingCanBeAccelerated"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_mediaPlayerRenderingCanBeAccelerated, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "elementShouldBufferData"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_elementShouldBufferData, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "elementBufferingPolicy"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_elementBufferingPolicy, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "setMediaElementBufferingPolicy"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setMediaElementBufferingPolicy, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "privatePlayerVolume"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_privatePlayerVolume, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "privatePlayerMuted"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_privatePlayerMuted, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "isMediaElementHidden"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isMediaElementHidden, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "setOverridePreferredDynamicRangeMode"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setOverridePreferredDynamicRangeMode, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "elementEffectivePlaybackRate"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_elementEffectivePlaybackRate, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "enableGStreamerHolePunching"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_enableGStreamerHolePunching, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "effectiveDynamicRangeLimitValue"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_effectiveDynamicRangeLimitValue, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "getContextEffectiveDynamicRangeLimitValue"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_getContextEffectiveDynamicRangeLimitValue, 1 } },
    HashTableValue { "setPageShouldSuppressHDR"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setPageShouldSuppressHDR, 1 } },
#if ENABLE(VIDEO)
    HashTableValue { "enterViewerMode"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_enterViewerMode, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "setIsPlayingToBluetoothOverride"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setIsPlayingToBluetoothOverride, 0 } },
#if ENABLE(LEGACY_ENCRYPTED_MEDIA)
    HashTableValue { "initializeMockCDM"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_initializeMockCDM, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(ENCRYPTED_MEDIA)
    HashTableValue { "registerMockCDM"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_registerMockCDM, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "enableMockMediaCapabilities"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_enableMockMediaCapabilities, 0 } },
#if ENABLE(SPEECH_SYNTHESIS)
    HashTableValue { "enableMockSpeechSynthesizer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_enableMockSpeechSynthesizer, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(SPEECH_SYNTHESIS)
    HashTableValue { "simulateSpeechSynthesizerVoiceListChange"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_simulateSpeechSynthesizerVoiceListChange, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(SPEECH_SYNTHESIS)
    HashTableValue { "enableMockSpeechSynthesizerForMediaElement"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_enableMockSpeechSynthesizerForMediaElement, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(SPEECH_SYNTHESIS)
    HashTableValue { "setSpeechUtteranceDuration"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setSpeechUtteranceDuration, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "getImageSourceURL"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_getImageSourceURL, 1 } },
#if ENABLE(VIDEO)
    HashTableValue { "captionsStyleSheetOverride"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_captionsStyleSheetOverride, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "setCaptionsStyleSheetOverride"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setCaptionsStyleSheetOverride, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "setPrimaryAudioTrackLanguageOverride"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setPrimaryAudioTrackLanguageOverride, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "setCaptionDisplayMode"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setCaptionDisplayMode, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "createGenericCue"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_createGenericCue, 3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "textTrackBCP47Language"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_textTrackBCP47Language, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "createTimeRanges"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_createTimeRanges, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "closestTimeToTimeRanges"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_closestTimeToTimeRanges, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "isSelectPopupVisible"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isSelectPopupVisible, 1 } },
    HashTableValue { "selectionBounds"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_selectionBounds, 0 } },
    HashTableValue { "selectedRange"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_selectedRange, 0 } },
    HashTableValue { "setSelectionWithoutValidation"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setSelectionWithoutValidation, 4 } },
    HashTableValue { "setSelectionFromNone"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setSelectionFromNone, 0 } },
#if ENABLE(MEDIA_SOURCE)
    HashTableValue { "initializeMockMediaSource"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_initializeMockMediaSource, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_SOURCE)
    HashTableValue { "bufferedSamplesForTrackId"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_bufferedSamplesForTrackId, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_SOURCE)
    HashTableValue { "setMaximumSourceBufferSize"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setMaximumSourceBufferSize, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_SOURCE)
    HashTableValue { "enqueuedSamplesForTrackID"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_enqueuedSamplesForTrackID, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_SOURCE)
    HashTableValue { "setShouldGenerateTimestamps"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setShouldGenerateTimestamps, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_SOURCE)
    HashTableValue { "minimumUpcomingPresentationTimeForTrackID"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_minimumUpcomingPresentationTimeForTrackID, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_SOURCE)
    HashTableValue { "setMaximumQueueDepthForTrackID"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setMaximumQueueDepthForTrackID, 3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_SOURCE)
    HashTableValue { "evictableSize"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_evictableSize, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "beginMediaSessionInterruption"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_beginMediaSessionInterruption, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "endMediaSessionInterruption"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_endMediaSessionInterruption, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "applicationWillBecomeInactive"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_applicationWillBecomeInactive, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "applicationDidBecomeActive"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_applicationDidBecomeActive, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "applicationWillEnterForeground"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_applicationWillEnterForeground, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "applicationDidEnterBackground"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_applicationDidEnterBackground, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "setMediaSessionRestrictions"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setMediaSessionRestrictions, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "mediaSessionRestrictions"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_mediaSessionRestrictions, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "setMediaElementRestrictions"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setMediaElementRestrictions, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEB_AUDIO)
    HashTableValue { "setAudioContextRestrictions"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setAudioContextRestrictions, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "postRemoteControlCommand"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_postRemoteControlCommand, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "activeAudioRouteDidChange"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_activeAudioRouteDidChange, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "beginAudioSessionInterruption"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_beginAudioSessionInterruption, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "endAudioSessionInterruption"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_endAudioSessionInterruption, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "clearAudioSessionInterruptionFlag"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_clearAudioSessionInterruptionFlag, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "suspendAllMediaBuffering"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_suspendAllMediaBuffering, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "suspendAllMediaPlayback"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_suspendAllMediaPlayback, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "resumeAllMediaPlayback"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_resumeAllMediaPlayback, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WIRELESS_PLAYBACK_TARGET)
    HashTableValue { "setMockMediaPlaybackTargetPickerEnabled"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setMockMediaPlaybackTargetPickerEnabled, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WIRELESS_PLAYBACK_TARGET)
    HashTableValue { "setMockMediaPlaybackTargetPickerState"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setMockMediaPlaybackTargetPickerState, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WIRELESS_PLAYBACK_TARGET)
    HashTableValue { "mockMediaPlaybackTargetPickerDismissPopup"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_mockMediaPlaybackTargetPickerDismissPopup, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_RECORDER)
    HashTableValue { "setCustomPrivateRecorderCreator"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setCustomPrivateRecorderCreator, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEB_AUDIO)
    HashTableValue { "useMockAudioDestinationCocoa"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_useMockAudioDestinationCocoa, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEB_RTC)
    HashTableValue { "emulateRTCPeerConnectionPlatformEvent"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_emulateRTCPeerConnectionPlatformEvent, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEB_RTC)
    HashTableValue { "useMockRTCPeerConnectionFactory"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_useMockRTCPeerConnectionFactory, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEB_RTC)
    HashTableValue { "setICECandidateFiltering"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setICECandidateFiltering, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEB_RTC)
    HashTableValue { "setEnumeratingAllNetworkInterfacesEnabled"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setEnumeratingAllNetworkInterfacesEnabled, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEB_RTC)
    HashTableValue { "stopPeerConnection"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_stopPeerConnection, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEB_RTC)
    HashTableValue { "clearPeerConnectionFactory"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_clearPeerConnectionFactory, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEB_RTC)
    HashTableValue { "setEnableWebRTCEncryption"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setEnableWebRTCEncryption, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "simulateSystemSleep"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_simulateSystemSleep, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "simulateSystemWake"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_simulateSystemWake, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "elementIsBlockingDisplaySleep"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_elementIsBlockingDisplaySleep, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "isPlayerVisibleInViewport"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isPlayerVisibleInViewport, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "isPlayerMuted"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isPlayerMuted, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "isPlayerPaused"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isPlayerPaused, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "forceStereoDecoding"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_forceStereoDecoding, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "installMockPageOverlay"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_installMockPageOverlay, 1 } },
    HashTableValue { "pageOverlayLayerTreeAsText"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_pageOverlayLayerTreeAsText, 0 } },
    HashTableValue { "setPageMuted"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setPageMuted, 1 } },
    HashTableValue { "pageMediaState"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_pageMediaState, 0 } },
    HashTableValue { "setPageDefersLoading"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setPageDefersLoading, 1 } },
    HashTableValue { "pageDefersLoading"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_pageDefersLoading, 0 } },
    HashTableValue { "grantUniversalAccess"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_grantUniversalAccess, 0 } },
    HashTableValue { "disableCORSForURL"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_disableCORSForURL, 1 } },
    HashTableValue { "createFile"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_createFile, 1 } },
    HashTableValue { "asyncCreateFile"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_asyncCreateFile, 1 } },
    HashTableValue { "createTemporaryFile"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_createTemporaryFile, 2 } },
    HashTableValue { "queueMicroTask"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_queueMicroTask, 1 } },
    HashTableValue { "testPreloaderSettingViewport"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_testPreloaderSettingViewport, 0 } },
    HashTableValue { "scrollSnapOffsets"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_scrollSnapOffsets, 1 } },
    HashTableValue { "isScrollSnapInProgress"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isScrollSnapInProgress, 1 } },
    HashTableValue { "setPlatformMomentumScrollingPredictionEnabled"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setPlatformMomentumScrollingPredictionEnabled, 1 } },
    HashTableValue { "pathStringWithShrinkWrappedRects"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_pathStringWithShrinkWrappedRects, 2 } },
#if ENABLE(VIDEO)
    HashTableValue { "getCurrentMediaControlsStatusForElement"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_getCurrentMediaControlsStatusForElement, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "setMediaControlsMaximumRightContainerButtonCountOverride"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setMediaControlsMaximumRightContainerButtonCountOverride, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "setMediaControlsHidePlaybackRates"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setMediaControlsHidePlaybackRates, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "userVisibleString"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_userVisibleString, 1 } },
    HashTableValue { "pageMediaVolume"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_pageMediaVolume, 0 } },
    HashTableValue { "setPageMediaVolume"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setPageMediaVolume, 1 } },
    HashTableValue { "setShowAllPlugins"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setShowAllPlugins, 1 } },
    HashTableValue { "cloneArrayBuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_cloneArrayBuffer, 3 } },
    HashTableValue { "isReadableStreamDisturbed"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isReadableStreamDisturbed, 1 } },
    HashTableValue { "resourceLoadStatisticsForURL"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_resourceLoadStatisticsForURL, 1 } },
    HashTableValue { "setTrackingPreventionEnabled"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setTrackingPreventionEnabled, 1 } },
    HashTableValue { "setCanShowModalDialogOverride"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setCanShowModalDialogOverride, 1 } },
    HashTableValue { "composedTreeAsText"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_composedTreeAsText, 1 } },
    HashTableValue { "isProcessingUserGesture"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isProcessingUserGesture, 0 } },
    HashTableValue { "lastHandledUserGestureTimestamp"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_lastHandledUserGestureTimestamp, 0 } },
    HashTableValue { "withUserGesture"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_withUserGesture, 1 } },
    HashTableValue { "withoutUserGesture"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_withoutUserGesture, 1 } },
    HashTableValue { "userIsInteracting"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_userIsInteracting, 0 } },
    HashTableValue { "hasTransientActivation"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_hasTransientActivation, 0 } },
    HashTableValue { "hasHistoryActionActivation"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_hasHistoryActionActivation, 0 } },
    HashTableValue { "observeGC"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_observeGC, 1 } },
    HashTableValue { "setUserInterfaceLayoutDirection"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setUserInterfaceLayoutDirection, 1 } },
    HashTableValue { "setBaseWritingDirection"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setBaseWritingDirection, 1 } },
    HashTableValue { "userPrefersContrast"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_userPrefersContrast, 0 } },
    HashTableValue { "userPrefersReducedMotion"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_userPrefersReducedMotion, 0 } },
    HashTableValue { "reportBacktrace"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_reportBacktrace, 0 } },
#if ENABLE(POINTER_LOCK)
    HashTableValue { "pageHasPendingPointerLock"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_pageHasPendingPointerLock, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(POINTER_LOCK)
    HashTableValue { "pageHasPointerLock"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_pageHasPointerLock, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "accessKeyModifiers"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_accessKeyModifiers, 0 } },
    HashTableValue { "setQuickLookPassword"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setQuickLookPassword, 1 } },
    HashTableValue { "setAsRunningUserScripts"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setAsRunningUserScripts, 0 } },
    HashTableValue { "disableTileSizeUpdateDelay"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_disableTileSizeUpdateDelay, 0 } },
    HashTableValue { "setSpeculativeTilingDelayDisabledForTesting"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setSpeculativeTilingDelayDisabledForTesting, 1 } },
#if ENABLE(WEBGL)
    HashTableValue { "simulateEventForWebGLContext"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_simulateEventForWebGLContext, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "requestedGPU"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_requestedGPU, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "setPageVisibility"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setPageVisibility, 1 } },
    HashTableValue { "setPageIsFocused"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setPageIsFocused, 1 } },
    HashTableValue { "setPageIsFocusedAndActive"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setPageIsFocusedAndActive, 1 } },
    HashTableValue { "setPageIsInWindow"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setPageIsInWindow, 1 } },
    HashTableValue { "isPageActive"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isPageActive, 0 } },
#if ENABLE(WEB_RTC)
    HashTableValue { "applyRotationForOutgoingVideoSources"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_applyRotationForOutgoingVideoSources, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEB_RTC)
    HashTableValue { "setWebRTCH265Support"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setWebRTCH265Support, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEB_RTC)
    HashTableValue { "setWebRTCVP9Support"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setWebRTCVP9Support, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEB_RTC)
    HashTableValue { "disableWebRTCHardwareVP9"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_disableWebRTCHardwareVP9, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEB_RTC)
    HashTableValue { "isSupportingVP9HardwareDecoder"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isSupportingVP9HardwareDecoder, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEB_RTC)
    HashTableValue { "isVP9HardwareDecoderUsed"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isVP9HardwareDecoderUsed, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEB_RTC)
    HashTableValue { "setSFrameCounter"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setSFrameCounter, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEB_RTC)
    HashTableValue { "sframeCounter"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_sframeCounter, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEB_RTC)
    HashTableValue { "sframeKeyId"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_sframeKeyId, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_STREAM)
    HashTableValue { "setMockAudioTrackChannelNumber"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setMockAudioTrackChannelNumber, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_STREAM)
    HashTableValue { "setShouldInterruptAudioOnPageVisibilityChange"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setShouldInterruptAudioOnPageVisibilityChange, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_STREAM)
    HashTableValue { "setCameraMediaStreamTrackOrientation"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setCameraMediaStreamTrackOrientation, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_STREAM)
    HashTableValue { "observeMediaStreamTrack"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_observeMediaStreamTrack, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_STREAM)
    HashTableValue { "mediaStreamTrackVideoFrameRotation"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_mediaStreamTrackVideoFrameRotation, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_STREAM)
    HashTableValue { "delayMediaStreamTrackSamples"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_delayMediaStreamTrackSamples, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_STREAM)
    HashTableValue { "setMediaStreamTrackMuted"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setMediaStreamTrackMuted, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_STREAM)
    HashTableValue { "removeMediaStreamTrack"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_removeMediaStreamTrack, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_STREAM)
    HashTableValue { "simulateMediaStreamTrackCaptureSourceFailure"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_simulateMediaStreamTrackCaptureSourceFailure, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_STREAM)
    HashTableValue { "setMediaStreamTrackIdentifier"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setMediaStreamTrackIdentifier, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_STREAM)
    HashTableValue { "setMediaStreamSourceInterrupted"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setMediaStreamSourceInterrupted, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_STREAM)
    HashTableValue { "isMediaStreamSourceInterrupted"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isMediaStreamSourceInterrupted, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_STREAM)
    HashTableValue { "isMediaStreamSourceEnded"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isMediaStreamSourceEnded, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_STREAM)
    HashTableValue { "isMockRealtimeMediaSourceCenterEnabled"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isMockRealtimeMediaSourceCenterEnabled, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_STREAM)
    HashTableValue { "shouldAudioTrackPlay"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_shouldAudioTrackPlay, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_STREAM)
    HashTableValue { "mediaStreamTrackPersistentId"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_mediaStreamTrackPersistentId, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_STREAM)
    HashTableValue { "audioCaptureSourceCount"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_audioCaptureSourceCount, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "isHardwareVP9DecoderExpected"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isHardwareVP9DecoderExpected, 0 } },
    HashTableValue { "documentIdentifier"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_documentIdentifier, 1 } },
    HashTableValue { "isDocumentAlive"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isDocumentAlive, 1 } },
    HashTableValue { "messagePortIdentifier"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_messagePortIdentifier, 1 } },
    HashTableValue { "isMessagePortAlive"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isMessagePortAlive, 1 } },
    HashTableValue { "elementIdentifier"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_elementIdentifier, 1 } },
    HashTableValue { "isElementAlive"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isElementAlive, 1 } },
    HashTableValue { "pageIdentifier"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_pageIdentifier, 1 } },
    HashTableValue { "isAnyWorkletGlobalScopeAlive"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isAnyWorkletGlobalScopeAlive, 0 } },
    HashTableValue { "serviceWorkerClientInternalIdentifier"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_serviceWorkerClientInternalIdentifier, 1 } },
    HashTableValue { "storeRegistrationsOnDisk"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_storeRegistrationsOnDisk, 0 } },
    HashTableValue { "sendH2Ping"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_sendH2Ping, 1 } },
    HashTableValue { "clearCacheStorageMemoryRepresentation"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_clearCacheStorageMemoryRepresentation, 0 } },
    HashTableValue { "cacheStorageEngineRepresentation"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_cacheStorageEngineRepresentation, 0 } },
    HashTableValue { "setResponseSizeWithPadding"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setResponseSizeWithPadding, 2 } },
    HashTableValue { "responseSizeWithPadding"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_responseSizeWithPadding, 1 } },
    HashTableValue { "responseNetworkLoadMetricsProtocol"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_responseNetworkLoadMetricsProtocol, 1 } },
    HashTableValue { "blobInternalURL"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_blobInternalURL, 1 } },
    HashTableValue { "isBlobInternalURLRegistered"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isBlobInternalURLRegistered, 1 } },
    HashTableValue { "updateQuotaBasedOnSpaceUsage"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_updateQuotaBasedOnSpaceUsage, 0 } },
    HashTableValue { "setConsoleMessageListener"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setConsoleMessageListener, 1 } },
    HashTableValue { "audioSessionCategory"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_audioSessionCategory, 0 } },
    HashTableValue { "audioSessionMode"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_audioSessionMode, 0 } },
#if ENABLE(VIDEO)
    HashTableValue { "categoryAtMostRecentPlayback"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_categoryAtMostRecentPlayback, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "modeAtMostRecentPlayback"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_modeAtMostRecentPlayback, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "routeSharingPolicy"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_routeSharingPolicy, 0 } },
    HashTableValue { "preferredAudioBufferSize"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_preferredAudioBufferSize, 0 } },
    HashTableValue { "currentAudioBufferSize"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_currentAudioBufferSize, 0 } },
    HashTableValue { "audioSessionActive"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_audioSessionActive, 0 } },
    HashTableValue { "hasServiceWorkerRegistration"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_hasServiceWorkerRegistration, 1 } },
    HashTableValue { "terminateServiceWorker"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_terminateServiceWorker, 1 } },
    HashTableValue { "whenServiceWorkerIsTerminated"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_whenServiceWorkerIsTerminated, 1 } },
    HashTableValue { "terminateWebContentProcess"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_terminateWebContentProcess, 0 } },
    HashTableValue { "isSystemPreviewLink"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isSystemPreviewLink, 1 } },
    HashTableValue { "isSystemPreviewImage"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isSystemPreviewImage, 1 } },
#if ENABLE(IMAGE_ANALYSIS)
    HashTableValue { "requestTextRecognition"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_requestTextRecognition, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "installImageOverlay"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_installImageOverlay, 2 } },
    HashTableValue { "usingAppleInternalSDK"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_usingAppleInternalSDK, 0 } },
    HashTableValue { "usingGStreamer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_usingGStreamer, 0 } },
    HashTableValue { "postTask"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_postTask, 1 } },
    HashTableValue { "queueTask"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_queueTask, 2 } },
    HashTableValue { "queueTaskToQueueMicrotask"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_queueTaskToQueueMicrotask, 2 } },
    HashTableValue { "hasSameEventLoopAs"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_hasSameEventLoopAs, 1 } },
    HashTableValue { "windowLocationHost"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_windowLocationHost, 1 } },
    HashTableValue { "markContextAsInsecure"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_markContextAsInsecure, 0 } },
    HashTableValue { "setMaxCanvasArea"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setMaxCanvasArea, 1 } },
#if ENABLE(VIDEO)
    HashTableValue { "elementIsActiveNowPlayingSession"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_elementIsActiveNowPlayingSession, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "bestMediaElementForRemoteControls"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_bestMediaElementForRemoteControls, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "mediaSessionState"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_mediaSessionState, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "mediaUsageState"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_mediaUsageState, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "elementShouldDisplayPosterImage"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_elementShouldDisplayPosterImage, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "setMediaElementVolumeLocked"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setMediaElementVolumeLocked, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(SPEECH_SYNTHESIS)
    HashTableValue { "speechSynthesisUtteranceForCue"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_speechSynthesisUtteranceForCue, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(SPEECH_SYNTHESIS)
    HashTableValue { "mediaElementCurrentlySpokenCue"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_mediaElementCurrentlySpokenCue, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "ongoingLoadsDescriptions"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_ongoingLoadsDescriptions, 0 } },
    HashTableValue { "setCaptureExtraNetworkLoadMetricsEnabled"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setCaptureExtraNetworkLoadMetricsEnabled, 1 } },
    HashTableValue { "reloadWithoutContentExtensions"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_reloadWithoutContentExtensions, 0 } },
    HashTableValue { "disableContentExtensionsChecks"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_disableContentExtensionsChecks, 0 } },
    HashTableValue { "pluginCount"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_pluginCount, 0 } },
    HashTableValue { "pluginScrollPositionX"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_pluginScrollPositionX, 1 } },
    HashTableValue { "pluginScrollPositionY"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_pluginScrollPositionY, 1 } },
    HashTableValue { "notifyResourceLoadObserver"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_notifyResourceLoadObserver, 0 } },
    HashTableValue { "primaryScreenDisplayID"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_primaryScreenDisplayID, 0 } },
    HashTableValue { "capsLockIsOn"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_capsLockIsOn, 0 } },
    HashTableValue { "parseHEVCCodecParameters"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_parseHEVCCodecParameters, 1 } },
    HashTableValue { "createHEVCCodecParametersString"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_createHEVCCodecParametersString, 1 } },
    HashTableValue { "parseDoViCodecParameters"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_parseDoViCodecParameters, 1 } },
    HashTableValue { "createDoViCodecParametersString"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_createDoViCodecParametersString, 1 } },
    HashTableValue { "parseVPCodecParameters"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_parseVPCodecParameters, 1 } },
    HashTableValue { "parseAV1CodecParameters"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_parseAV1CodecParameters, 1 } },
    HashTableValue { "createAV1CodecParametersString"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_createAV1CodecParametersString, 1 } },
    HashTableValue { "validateAV1ConfigurationRecord"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_validateAV1ConfigurationRecord, 1 } },
    HashTableValue { "validateAV1PerLevelConstraints"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_validateAV1PerLevelConstraints, 2 } },
    HashTableValue { "setCookie"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setCookie, 1 } },
    HashTableValue { "getCookies"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_getCookies, 0 } },
    HashTableValue { "setAlwaysAllowLocalWebarchive"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setAlwaysAllowLocalWebarchive, 1 } },
    HashTableValue { "processWillSuspend"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_processWillSuspend, 0 } },
    HashTableValue { "processDidResume"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_processDidResume, 0 } },
    HashTableValue { "testDictionaryLogging"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_testDictionaryLogging, 0 } },
    HashTableValue { "setMaximumIntervalForUserGestureForwardingForFetch"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setMaximumIntervalForUserGestureForwardingForFetch, 1 } },
    HashTableValue { "setTransientActivationDuration"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setTransientActivationDuration, 1 } },
    HashTableValue { "setIsPlayingToAutomotiveHeadUnit"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setIsPlayingToAutomotiveHeadUnit, 1 } },
    HashTableValue { "textIndicatorForRange"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_textIndicatorForRange, 2 } },
    HashTableValue { "addPrefetchLoadEventListener"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_addPrefetchLoadEventListener, 2 } },
#if ENABLE(WEB_AUTHN)
    HashTableValue { "setMockWebAuthenticationConfiguration"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setMockWebAuthenticationConfiguration, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "createInternalsMapLike"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_createInternalsMapLike, 0 } },
    HashTableValue { "createInternalsSetLike"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_createInternalsSetLike, 0 } },
    HashTableValue { "highlightPseudoElementColor"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_highlightPseudoElementColor, 2 } },
    HashTableValue { "hasSandboxMachLookupAccessToGlobalName"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_hasSandboxMachLookupAccessToGlobalName, 2 } },
    HashTableValue { "hasSandboxMachLookupAccessToXPCServiceName"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_hasSandboxMachLookupAccessToXPCServiceName, 2 } },
    HashTableValue { "hasSandboxIOKitOpenAccessToClass"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_hasSandboxIOKitOpenAccessToClass, 2 } },
    HashTableValue { "hasSandboxUnixSyscallAccess"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_hasSandboxUnixSyscallAccess, 2 } },
    HashTableValue { "systemColorForCSSValue"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_systemColorForCSSValue, 3 } },
    HashTableValue { "focusRingColor"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_focusRingColor, 0 } },
    HashTableValue { "systemHasBattery"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_systemHasBattery, 0 } },
    HashTableValue { "setSystemHasBatteryForTesting"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setSystemHasBatteryForTesting, 1 } },
    HashTableValue { "setSystemHasACForTesting"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setSystemHasACForTesting, 1 } },
    HashTableValue { "setHardwareVP9DecoderDisabledForTesting"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setHardwareVP9DecoderDisabledForTesting, 1 } },
    HashTableValue { "setVP9DecoderDisabledForTesting"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setVP9DecoderDisabledForTesting, 1 } },
    HashTableValue { "setVP9ScreenSizeAndScaleForTesting"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setVP9ScreenSizeAndScaleForTesting, 3 } },
    HashTableValue { "readPreferenceInteger"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_readPreferenceInteger, 2 } },
    HashTableValue { "encodedPreferenceValue"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_encodedPreferenceValue, 2 } },
    HashTableValue { "supportsPictureInPicture"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_supportsPictureInPicture, 0 } },
    HashTableValue { "isRemoteUIAppForAccessibility"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isRemoteUIAppForAccessibility, 0 } },
    HashTableValue { "createSleepDisabler"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_createSleepDisabler, 2 } },
    HashTableValue { "destroySleepDisabler"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_destroySleepDisabler, 1 } },
#if ENABLE(APP_HIGHLIGHTS)
    HashTableValue { "numberOfAppHighlights"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_numberOfAppHighlights, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(ENCRYPTED_MEDIA)
    HashTableValue { "mediaKeysInternalInstanceObjectRefCount"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_mediaKeysInternalInstanceObjectRefCount, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(ENCRYPTED_MEDIA)
    HashTableValue { "mediaKeySessionInternalInstanceSessionObjectRefCount"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_mediaKeySessionInternalInstanceSessionObjectRefCount, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "setContentSizeCategory"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setContentSizeCategory, 1 } },
#if ENABLE(SERVICE_CONTROLS)
    HashTableValue { "hasImageControls"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_hasImageControls, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_SESSION)
    HashTableValue { "currentMediaSessionPosition"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_currentMediaSessionPosition, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_SESSION)
    HashTableValue { "sendMediaSessionAction"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_sendMediaSessionAction, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_SESSION) && ENABLE(WEB_CODECS)
    HashTableValue { "loadArtworkImage"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_loadArtworkImage, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_SESSION)
    HashTableValue { "platformSupportedCommands"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_platformSupportedCommands, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_SESSION_COORDINATOR)
    HashTableValue { "registerMockMediaSessionCoordinator"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_registerMockMediaSessionCoordinator, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MEDIA_SESSION_COORDINATOR)
    HashTableValue { "setMockMediaSessionCoordinatorCommandsShouldFail"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setMockMediaSessionCoordinatorCommandsShouldFail, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "treeOrder"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_treeOrder, 2 } },
    HashTableValue { "treeOrderBoundaryPoints"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_treeOrderBoundaryPoints, 4 } },
    HashTableValue { "rangeContainsNode"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_rangeContainsNode, 2 } },
    HashTableValue { "rangeContainsRange"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_rangeContainsRange, 2 } },
    HashTableValue { "rangeContainsBoundaryPoint"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_rangeContainsBoundaryPoint, 3 } },
    HashTableValue { "rangeIntersectsNode"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_rangeIntersectsNode, 2 } },
    HashTableValue { "rangeIntersectsRange"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_rangeIntersectsRange, 2 } },
    HashTableValue { "systemBeep"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_systemBeep, 0 } },
    HashTableValue { "dumpStyleResolvers"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_dumpStyleResolvers, 0 } },
    HashTableValue { "setDocumentAutoplayPolicy"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setDocumentAutoplayPolicy, 2 } },
    HashTableValue { "retainTextIteratorForDocumentContent"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_retainTextIteratorForDocumentContent, 0 } },
    HashTableValue { "createPushSubscription"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_createPushSubscription, 5 } },
#if ENABLE(ARKIT_INLINE_PREVIEW_MAC)
    HashTableValue { "modelInlinePreviewUUIDs"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_modelInlinePreviewUUIDs, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(ARKIT_INLINE_PREVIEW_MAC)
    HashTableValue { "modelInlinePreviewUUIDForModelElement"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_modelInlinePreviewUUIDForModelElement, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "hasSleepDisabler"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_hasSleepDisabler, 0 } },
    HashTableValue { "acceptTypedArrays"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_acceptTypedArrays, 1 } },
    HashTableValue { "consumeTransientActivation"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_consumeTransientActivation, 0 } },
    HashTableValue { "consumeHistoryActionUserActivation"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_consumeHistoryActionUserActivation, 0 } },
    HashTableValue { "selectorFilterHashCounts"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_selectorFilterHashCounts, 1 } },
    HashTableValue { "setHistoryTotalStateObjectPayloadLimitOverride"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setHistoryTotalStateObjectPayloadLimitOverride, 1 } },
    HashTableValue { "isUsingUISideCompositing"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isUsingUISideCompositing, 0 } },
    HashTableValue { "getComputedLabel"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_getComputedLabel, 1 } },
    HashTableValue { "getComputedRole"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_getComputedRole, 1 } },
    HashTableValue { "pdfAnnotationRectsForTesting"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_pdfAnnotationRectsForTesting, 1 } },
    HashTableValue { "setPDFTextAnnotationValueForTesting"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setPDFTextAnnotationValueForTesting, 4 } },
    HashTableValue { "registerPDFTest"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_registerPDFTest, 2 } },
    HashTableValue { "setPDFDisplayModeForTesting"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setPDFDisplayModeForTesting, 2 } },
    HashTableValue { "unlockPDFDocumentForTesting"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_unlockPDFDocumentForTesting, 2 } },
    HashTableValue { "sendEditingCommandToPDFForTesting"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_sendEditingCommandToPDFForTesting, 2 } },
#if ENABLE(VIDEO)
    HashTableValue { "isEffectivelyMuted"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isEffectivelyMuted, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(VIDEO)
    HashTableValue { "addInternalEventTarget"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_addInternalEventTarget, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "getEffectiveRenderingModeOfNewlyCreatedAcceleratedImageBuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_getEffectiveRenderingModeOfNewlyCreatedAcceleratedImageBuffer, 0 } },
    HashTableValue { "getImageBufferResourceLimits"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_getImageBufferResourceLimits, 0 } },
    HashTableValue { "setTopDocumentURLForQuirks"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_setTopDocumentURLForQuirks, 1 } },
#if ENABLE(MODEL_ELEMENT)
    HashTableValue { "disableModelLoadDelaysForTesting"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_disableModelLoadDelaysForTesting, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MODEL_ELEMENT)
    HashTableValue { "modelElementState"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_modelElementState, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(MODEL_ELEMENT)
    HashTableValue { "isModelElementIntersectingViewport"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsInternalsPrototypeFunction_isModelElementIntersectingViewport, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "LAYER_TREE_INCLUDES_VISIBLE_RECTS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 1 } },
    HashTableValue { "LAYER_TREE_INCLUDES_TILE_CACHES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 2 } },
    HashTableValue { "LAYER_TREE_INCLUDES_REPAINT_RECTS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 4 } },
    HashTableValue { "LAYER_TREE_INCLUDES_PAINTING_PHASES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 8 } },
    HashTableValue { "LAYER_TREE_INCLUDES_CONTENT_LAYERS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 16 } },
    HashTableValue { "LAYER_TREE_INCLUDES_ACCELERATES_DRAWING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 32 } },
    HashTableValue { "LAYER_TREE_INCLUDES_CLIPPING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 64 } },
    HashTableValue { "LAYER_TREE_INCLUDES_BACKING_STORE_ATTACHED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 128 } },
    HashTableValue { "LAYER_TREE_INCLUDES_ROOT_LAYER_PROPERTIES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 256 } },
    HashTableValue { "LAYER_TREE_INCLUDES_EVENT_REGION"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 512 } },
    HashTableValue { "LAYER_TREE_INCLUDES_EXTENDED_COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 1024 } },
    HashTableValue { "LAYER_TREE_INCLUDES_DEVICE_SCALE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 2048 } },
    HashTableValue { "PLATFORM_LAYER_TREE_DEBUG"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 1 } },
    HashTableValue { "PLATFORM_LAYER_TREE_IGNORES_CHILDREN"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 2 } },
    HashTableValue { "PLATFORM_LAYER_TREE_INCLUDE_MODELS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 4 } },
    HashTableValue { "DISPLAY_LIST_INCLUDE_PLATFORM_OPERATIONS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 1 } },
    HashTableValue { "DISPLAY_LIST_INCLUDE_RESOURCE_IDENTIFIERS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 2 } },
};

const ClassInfo JSInternalsPrototype::s_info = { "Internals"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSInternalsPrototype) };

void JSInternalsPrototype::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSInternals::info(), JSInternalsPrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

const ClassInfo JSInternals::s_info = { "Internals"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSInternals) };

JSInternals::JSInternals(Structure* structure, JSDOMGlobalObject& globalObject, Ref<Internals>&& impl)
    : JSDOMWrapper<Internals>(structure, globalObject, WTFMove(impl))
{
}

static_assert(!std::is_base_of<ActiveDOMObject, Internals>::value, "Interface is not marked as [ActiveDOMObject] even though implementation class subclasses ActiveDOMObject.");

JSObject* JSInternals::createPrototype(VM& vm, JSDOMGlobalObject& globalObject)
{
    auto* structure = JSInternalsPrototype::createStructure(vm, &globalObject, globalObject.objectPrototype());
    structure->setMayBePrototype(true);
    return JSInternalsPrototype::create(vm, &globalObject, structure);
}

JSObject* JSInternals::prototype(VM& vm, JSDOMGlobalObject& globalObject)
{
    return getDOMPrototype<JSInternals>(vm, globalObject);
}

void JSInternals::destroy(JSC::JSCell* cell)
{
    JSInternals* thisObject = static_cast<JSInternals*>(cell);
    thisObject->JSInternals::~JSInternals();
}

static inline JSValue jsInternals_inflightBeaconsCountGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, impl.inflightBeaconsCount())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_inflightBeaconsCount, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_inflightBeaconsCountGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline JSValue jsInternals_animationsIntervalGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLDouble>(lexicalGlobalObject, throwScope, impl.animationsInterval())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_animationsInterval, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_animationsIntervalGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline JSValue jsInternals_sentenceRetroCorrectionEnabledGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLBoolean>(lexicalGlobalObject, throwScope, impl.sentenceRetroCorrectionEnabled())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_sentenceRetroCorrectionEnabled, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_sentenceRetroCorrectionEnabledGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline JSValue jsInternals_settingsGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLInterface<InternalSettings>>(lexicalGlobalObject, *thisObject.globalObject(), throwScope, impl.settings())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_settings, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_settingsGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline JSValue jsInternals_workerThreadCountGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, impl.workerThreadCount())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_workerThreadCount, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_workerThreadCountGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline JSValue jsInternals_areSVGAnimationsPausedGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLBoolean>(lexicalGlobalObject, throwScope, impl.areSVGAnimationsPaused())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_areSVGAnimationsPaused, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_areSVGAnimationsPausedGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline JSValue jsInternals_isUnderMemoryWarningGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLBoolean>(lexicalGlobalObject, throwScope, impl.isUnderMemoryWarning())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_isUnderMemoryWarning, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_isUnderMemoryWarningGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline JSValue jsInternals_isUnderMemoryPressureGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLBoolean>(lexicalGlobalObject, throwScope, impl.isUnderMemoryPressure())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_isUnderMemoryPressure, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_isUnderMemoryPressureGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline JSValue jsInternals_requestAnimationFrameIntervalGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLDouble>(lexicalGlobalObject, throwScope, impl.requestAnimationFrameInterval())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_requestAnimationFrameInterval, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_requestAnimationFrameIntervalGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline JSValue jsInternals_scriptedAnimationsAreSuspendedGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLBoolean>(lexicalGlobalObject, throwScope, impl.scriptedAnimationsAreSuspended())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_scriptedAnimationsAreSuspended, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_scriptedAnimationsAreSuspendedGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline JSValue jsInternals_eventThrottlingBehaviorOverrideGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLNullable<IDLEnumeration<Internals::EventThrottlingBehavior>>>(lexicalGlobalObject, throwScope, impl.eventThrottlingBehaviorOverride())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_eventThrottlingBehaviorOverride, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_eventThrottlingBehaviorOverrideGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline bool setJSInternals_eventThrottlingBehaviorOverrideSetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    UNUSED_PARAM(vm);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    if (value.isUndefinedOrNull()) {
        invokeFunctorPropagatingExceptionIfNecessary(lexicalGlobalObject, throwScope, [&] {
            return impl.setEventThrottlingBehaviorOverride(std::nullopt);
        });
        return true;
    }

    auto optionalNativeValue = parseEnumeration<Internals::EventThrottlingBehavior>(lexicalGlobalObject, value);
    RETURN_IF_EXCEPTION(throwScope, false);
    if (!optionalNativeValue) [[unlikely]]
        return false;
    invokeFunctorPropagatingExceptionIfNecessary(lexicalGlobalObject, throwScope, [&] {
        return impl.setEventThrottlingBehaviorOverride(optionalNativeValue.value());
    });
    return true;
}

JSC_DEFINE_CUSTOM_SETTER(setJSInternals_eventThrottlingBehaviorOverride, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, EncodedJSValue encodedValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::set<setJSInternals_eventThrottlingBehaviorOverrideSetter>(*lexicalGlobalObject, thisValue, encodedValue, attributeName);
}

static inline JSValue jsInternals_lastStyleUpdateSizeGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, impl.lastStyleUpdateSize())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_lastStyleUpdateSize, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_lastStyleUpdateSizeGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline JSValue jsInternals_compositingPolicyOverrideGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLNullable<IDLEnumeration<Internals::CompositingPolicy>>>(lexicalGlobalObject, throwScope, impl.compositingPolicyOverride())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_compositingPolicyOverride, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_compositingPolicyOverrideGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline bool setJSInternals_compositingPolicyOverrideSetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    UNUSED_PARAM(vm);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    if (value.isUndefinedOrNull()) {
        invokeFunctorPropagatingExceptionIfNecessary(lexicalGlobalObject, throwScope, [&] {
            return impl.setCompositingPolicyOverride(std::nullopt);
        });
        return true;
    }

    auto optionalNativeValue = parseEnumeration<Internals::CompositingPolicy>(lexicalGlobalObject, value);
    RETURN_IF_EXCEPTION(throwScope, false);
    if (!optionalNativeValue) [[unlikely]]
        return false;
    invokeFunctorPropagatingExceptionIfNecessary(lexicalGlobalObject, throwScope, [&] {
        return impl.setCompositingPolicyOverride(optionalNativeValue.value());
    });
    return true;
}

JSC_DEFINE_CUSTOM_SETTER(setJSInternals_compositingPolicyOverride, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, EncodedJSValue encodedValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::set<setJSInternals_compositingPolicyOverrideSetter>(*lexicalGlobalObject, thisValue, encodedValue, attributeName);
}

#if ENABLE(SPEECH_SYNTHESIS)
static inline JSValue jsInternals_minimumExpectedVoiceCountGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, impl.minimumExpectedVoiceCount())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_minimumExpectedVoiceCount, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_minimumExpectedVoiceCountGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

#endif

static inline JSValue jsInternals_isMonitoringWirelessRoutesGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLBoolean>(lexicalGlobalObject, throwScope, impl.isMonitoringWirelessRoutes())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_isMonitoringWirelessRoutes, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_isMonitoringWirelessRoutesGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

#if ENABLE(CONTENT_FILTERING)
static inline JSValue jsInternals_mockContentFilterSettingsGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLInterface<MockContentFilterSettings>>(lexicalGlobalObject, *thisObject.globalObject(), throwScope, impl.mockContentFilterSettings())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_mockContentFilterSettings, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_mockContentFilterSettingsGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

#endif

#if ENABLE(MEDIA_STREAM)
static inline JSValue jsInternals_trackAudioSampleCountGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, impl.trackAudioSampleCount())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_trackAudioSampleCount, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_trackAudioSampleCountGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

#endif

#if ENABLE(MEDIA_STREAM)
static inline JSValue jsInternals_trackVideoSampleCountGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, impl.trackVideoSampleCount())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_trackVideoSampleCount, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_trackVideoSampleCountGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

#endif

#if ENABLE(WEB_RTC)
static inline JSValue jsInternals_rtcNetworkInterfaceNameGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLDOMString>(lexicalGlobalObject, throwScope, impl.rtcNetworkInterfaceName())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_rtcNetworkInterfaceName, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_rtcNetworkInterfaceNameGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

#endif

static inline JSValue jsInternals_storageAreaMapCountGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLUnsignedLongLong>(lexicalGlobalObject, throwScope, impl.storageAreaMapCount())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_storageAreaMapCount, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_storageAreaMapCountGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline JSValue jsInternals_processIdentifierGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLLong>(lexicalGlobalObject, throwScope, impl.processIdentifier())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_processIdentifier, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_processIdentifierGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline JSValue jsInternals_supportsAudioSessionGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLBoolean>(lexicalGlobalObject, throwScope, impl.supportsAudioSession())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_supportsAudioSession, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_supportsAudioSessionGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

#if ENABLE(IMAGE_ANALYSIS)
static inline JSValue jsInternals_textRecognitionCandidateGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLNullable<IDLInterface<Element>>>(lexicalGlobalObject, *thisObject.globalObject(), throwScope, impl.textRecognitionCandidate())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_textRecognitionCandidate, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_textRecognitionCandidateGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

#endif

static inline JSValue jsInternals_hasActiveDataDetectorHighlightGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLBoolean>(lexicalGlobalObject, throwScope, impl.hasActiveDataDetectorHighlight())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_hasActiveDataDetectorHighlight, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_hasActiveDataDetectorHighlightGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

#if ENABLE(VIDEO)
static inline JSValue jsInternals_nowPlayingMetadataGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLNullable<IDLDictionary<Internals::NowPlayingMetadata>>>(lexicalGlobalObject, *thisObject.globalObject(), throwScope, impl.nowPlayingMetadata())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_nowPlayingMetadata, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_nowPlayingMetadataGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

#endif

#if ENABLE(VIDEO)
static inline JSValue jsInternals_nowPlayingStateGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLDictionary<Internals::NowPlayingState>>(lexicalGlobalObject, *thisObject.globalObject(), throwScope, impl.nowPlayingState())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_nowPlayingState, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_nowPlayingStateGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

#endif

#if ENABLE(VIDEO)
static inline JSValue jsInternals_mediaElementCountGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, impl.mediaElementCount())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_mediaElementCount, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_mediaElementCountGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

#endif

#if ENABLE(APP_HIGHLIGHTS)
static inline JSValue jsInternals_appHighlightContextMenuItemTitlesGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLSequence<IDLDOMString>>(lexicalGlobalObject, *thisObject.globalObject(), throwScope, impl.appHighlightContextMenuItemTitles())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_appHighlightContextMenuItemTitles, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_appHighlightContextMenuItemTitlesGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

#endif

static inline JSValue jsInternals_isVisuallyNonEmptyGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLBoolean>(lexicalGlobalObject, throwScope, impl.isVisuallyNonEmpty())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_isVisuallyNonEmpty, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_isVisuallyNonEmptyGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline JSValue jsInternals_hasScopeBreakingHasSelectorsGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLBoolean>(lexicalGlobalObject, throwScope, impl.hasScopeBreakingHasSelectors())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_hasScopeBreakingHasSelectors, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_hasScopeBreakingHasSelectorsGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline JSValue jsInternals_defaultSpatialTrackingLabelGetter(JSGlobalObject& lexicalGlobalObject, JSInternals& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLDOMString>(lexicalGlobalObject, throwScope, impl.defaultSpatialTrackingLabel())));
}

JSC_DEFINE_CUSTOM_GETTER(jsInternals_defaultSpatialTrackingLabel, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSInternals>::get<jsInternals_defaultSpatialTrackingLabelGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_addressBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto nodeConversionResult = convert<IDLInterface<Node>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "node"_s, "Internals"_s, "address"_s, "Node"_s); });
    if (nodeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.address(*nodeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_address, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_addressBody>(*lexicalGlobalObject, *callFrame, "address");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_nodeNeedsStyleRecalcBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto nodeConversionResult = convert<IDLInterface<Node>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "node"_s, "Internals"_s, "nodeNeedsStyleRecalc"_s, "Node"_s); });
    if (nodeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.nodeNeedsStyleRecalc(*nodeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_nodeNeedsStyleRecalc, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_nodeNeedsStyleRecalcBody>(*lexicalGlobalObject, *callFrame, "nodeNeedsStyleRecalc");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_styleChangeTypeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto nodeConversionResult = convert<IDLInterface<Node>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "node"_s, "Internals"_s, "styleChangeType"_s, "Node"_s); });
    if (nodeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.styleChangeType(*nodeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_styleChangeType, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_styleChangeTypeBody>(*lexicalGlobalObject, *callFrame, "styleChangeType");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_descriptionBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto valueConversionResult = convert<IDLAny>(*lexicalGlobalObject, argument0.value());
    if (valueConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.description(valueConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_description, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_descriptionBody>(*lexicalGlobalObject, *callFrame, "description");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_logBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto valueConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (valueConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.log(valueConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_log, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_logBody>(*lexicalGlobalObject, *callFrame, "log");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_hasPausedImageAnimationsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "hasPausedImageAnimations"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.hasPausedImageAnimations(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasPausedImageAnimations, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_hasPausedImageAnimationsBody>(*lexicalGlobalObject, *callFrame, "hasPausedImageAnimations");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_markFrontBufferVolatileBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "markFrontBufferVolatile"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.markFrontBufferVolatile(*elementConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_markFrontBufferVolatile, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_markFrontBufferVolatileBody>(*lexicalGlobalObject, *callFrame, "markFrontBufferVolatile");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isFullyActiveBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto documentConversionResult = convert<IDLInterface<Document>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "document"_s, "Internals"_s, "isFullyActive"_s, "Document"_s); });
    if (documentConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isFullyActive(*documentConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isFullyActive, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isFullyActiveBody>(*lexicalGlobalObject, *callFrame, "isFullyActive");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isPaintingFrequentlyBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "isPaintingFrequently"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isPaintingFrequently(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isPaintingFrequently, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isPaintingFrequentlyBody>(*lexicalGlobalObject, *callFrame, "isPaintingFrequently");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_incrementFrequentPaintCounterBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "incrementFrequentPaintCounter"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.incrementFrequentPaintCounter(*elementConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_incrementFrequentPaintCounter, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_incrementFrequentPaintCounterBody>(*lexicalGlobalObject, *callFrame, "incrementFrequentPaintCounter");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_purgeFrontBufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "purgeFrontBuffer"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.purgeFrontBuffer(*elementConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_purgeFrontBuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_purgeFrontBufferBody>(*lexicalGlobalObject, *callFrame, "purgeFrontBuffer");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_purgeBackBufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "purgeBackBuffer"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.purgeBackBuffer(*elementConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_purgeBackBuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_purgeBackBufferBody>(*lexicalGlobalObject, *callFrame, "purgeBackBuffer");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_elementRenderTreeAsTextBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "elementRenderTreeAsText"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.elementRenderTreeAsText(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_elementRenderTreeAsText, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_elementRenderTreeAsTextBody>(*lexicalGlobalObject, *callFrame, "elementRenderTreeAsText");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isPreloadedBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto urlConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (urlConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isPreloaded(urlConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isPreloaded, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isPreloadedBody>(*lexicalGlobalObject, *callFrame, "isPreloaded");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isLoadingFromMemoryCacheBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto urlConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (urlConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isLoadingFromMemoryCache(urlConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isLoadingFromMemoryCache, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isLoadingFromMemoryCacheBody>(*lexicalGlobalObject, *callFrame, "isLoadingFromMemoryCache");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_fetchResponseSourceBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto responseConversionResult = convert<IDLInterface<FetchResponse>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "response"_s, "Internals"_s, "fetchResponseSource"_s, "FetchResponse"_s); });
    if (responseConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.fetchResponseSource(*responseConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_fetchResponseSource, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_fetchResponseSourceBody>(*lexicalGlobalObject, *callFrame, "fetchResponseSource");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_xhrResponseSourceBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto xhrConversionResult = convert<IDLInterface<XMLHttpRequest>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "xhr"_s, "Internals"_s, "xhrResponseSource"_s, "XMLHttpRequest"_s); });
    if (xhrConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.xhrResponseSource(*xhrConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_xhrResponseSource, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_xhrResponseSourceBody>(*lexicalGlobalObject, *callFrame, "xhrResponseSource");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isSharingStyleSheetContentsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto aConversionResult = convert<IDLInterface<HTMLLinkElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "a"_s, "Internals"_s, "isSharingStyleSheetContents"_s, "HTMLLinkElement"_s); });
    if (aConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto bConversionResult = convert<IDLInterface<HTMLLinkElement>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "b"_s, "Internals"_s, "isSharingStyleSheetContents"_s, "HTMLLinkElement"_s); });
    if (bConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isSharingStyleSheetContents(*aConversionResult.releaseReturnValue(), *bConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isSharingStyleSheetContents, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isSharingStyleSheetContentsBody>(*lexicalGlobalObject, *callFrame, "isSharingStyleSheetContents");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isStyleSheetLoadingSubresourcesBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto linkConversionResult = convert<IDLInterface<HTMLLinkElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "link"_s, "Internals"_s, "isStyleSheetLoadingSubresources"_s, "HTMLLinkElement"_s); });
    if (linkConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isStyleSheetLoadingSubresources(*linkConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isStyleSheetLoadingSubresources, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isStyleSheetLoadingSubresourcesBody>(*lexicalGlobalObject, *callFrame, "isStyleSheetLoadingSubresources");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_clearMemoryCacheBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.clearMemoryCache(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_clearMemoryCache, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_clearMemoryCacheBody>(*lexicalGlobalObject, *callFrame, "clearMemoryCache");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_pruneMemoryCacheToSizeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto sizeConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument0.value());
    if (sizeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.pruneMemoryCacheToSize(sizeConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_pruneMemoryCacheToSize, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_pruneMemoryCacheToSizeBody>(*lexicalGlobalObject, *callFrame, "pruneMemoryCacheToSize");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_destroyDecodedDataForAllImagesBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.destroyDecodedDataForAllImages(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_destroyDecodedDataForAllImages, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_destroyDecodedDataForAllImagesBody>(*lexicalGlobalObject, *callFrame, "destroyDecodedDataForAllImages");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_memoryCacheSizeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLLong>(*lexicalGlobalObject, throwScope, impl.memoryCacheSize())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_memoryCacheSize, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_memoryCacheSizeBody>(*lexicalGlobalObject, *callFrame, "memoryCacheSize");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setOverrideCachePolicyBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto policyConversionResult = convert<IDLEnumeration<Internals::CachePolicy>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentMustBeEnumError(lexicalGlobalObject, scope, 0, "policy"_s, "Internals"_s, "setOverrideCachePolicy"_s, expectedEnumerationValues<Internals::CachePolicy>()); });
    if (policyConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setOverrideCachePolicy(policyConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setOverrideCachePolicy, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setOverrideCachePolicyBody>(*lexicalGlobalObject, *callFrame, "setOverrideCachePolicy");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setOverrideResourceLoadPriorityBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto priorityConversionResult = convert<IDLEnumeration<Internals::ResourceLoadPriority>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentMustBeEnumError(lexicalGlobalObject, scope, 0, "priority"_s, "Internals"_s, "setOverrideResourceLoadPriority"_s, expectedEnumerationValues<Internals::ResourceLoadPriority>()); });
    if (priorityConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setOverrideResourceLoadPriority(priorityConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setOverrideResourceLoadPriority, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setOverrideResourceLoadPriorityBody>(*lexicalGlobalObject, *callFrame, "setOverrideResourceLoadPriority");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setStrictRawResourceValidationPolicyDisabledBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto disabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (disabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setStrictRawResourceValidationPolicyDisabled(disabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setStrictRawResourceValidationPolicyDisabled, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setStrictRawResourceValidationPolicyDisabledBody>(*lexicalGlobalObject, *callFrame, "setStrictRawResourceValidationPolicyDisabled");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_getResourcePriorityBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto urlConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (urlConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLEnumeration<Internals::ResourceLoadPriority>>>(*lexicalGlobalObject, throwScope, impl.getResourcePriority(urlConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_getResourcePriority, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_getResourcePriorityBody>(*lexicalGlobalObject, *callFrame, "getResourcePriority");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isFetchObjectContextStoppedBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto objectConversionResult = convert<IDLUnion<IDLInterface<FetchRequest>, IDLInterface<FetchResponse>>>(*lexicalGlobalObject, argument0.value());
    if (objectConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isFetchObjectContextStopped(objectConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isFetchObjectContextStopped, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isFetchObjectContextStoppedBody>(*lexicalGlobalObject, *callFrame, "isFetchObjectContextStopped");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_clearBackForwardCacheBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.clearBackForwardCache(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_clearBackForwardCache, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_clearBackForwardCacheBody>(*lexicalGlobalObject, *callFrame, "clearBackForwardCache");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_backForwardCacheSizeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.backForwardCacheSize())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_backForwardCacheSize, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_backForwardCacheSizeBody>(*lexicalGlobalObject, *callFrame, "backForwardCacheSize");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_preventDocumentFromEnteringBackForwardCacheBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.preventDocumentFromEnteringBackForwardCache(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_preventDocumentFromEnteringBackForwardCache, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_preventDocumentFromEnteringBackForwardCacheBody>(*lexicalGlobalObject, *callFrame, "preventDocumentFromEnteringBackForwardCache");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_computedStyleIncludingVisitedInfoBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "computedStyleIncludingVisitedInfo"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<CSSStyleDeclaration>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.computedStyleIncludingVisitedInfo(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_computedStyleIncludingVisitedInfo, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_computedStyleIncludingVisitedInfoBody>(*lexicalGlobalObject, *callFrame, "computedStyleIncludingVisitedInfo");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_ensureUserAgentShadowRootBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto hostConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "host"_s, "Internals"_s, "ensureUserAgentShadowRoot"_s, "Element"_s); });
    if (hostConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<Node>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.ensureUserAgentShadowRoot(*hostConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_ensureUserAgentShadowRoot, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_ensureUserAgentShadowRootBody>(*lexicalGlobalObject, *callFrame, "ensureUserAgentShadowRoot");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_shadowRootBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto hostConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "host"_s, "Internals"_s, "shadowRoot"_s, "Element"_s); });
    if (hostConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<Node>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.shadowRoot(*hostConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_shadowRoot, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_shadowRootBody>(*lexicalGlobalObject, *callFrame, "shadowRoot");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_shadowRootTypeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto rootConversionResult = convert<IDLInterface<Node>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "root"_s, "Internals"_s, "shadowRootType"_s, "Node"_s); });
    if (rootConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.shadowRootType(*rootConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_shadowRootType, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_shadowRootTypeBody>(*lexicalGlobalObject, *callFrame, "shadowRootType");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_userAgentPartBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "userAgentPart"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.userAgentPart(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_userAgentPart, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_userAgentPartBody>(*lexicalGlobalObject, *callFrame, "userAgentPart");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setUserAgentPartBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "setUserAgentPart"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto partConversionResult = convert<IDLAtomStringAdaptor<IDLDOMString>>(*lexicalGlobalObject, argument1.value());
    if (partConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setUserAgentPart(*elementConversionResult.releaseReturnValue(), partConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setUserAgentPart, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setUserAgentPartBody>(*lexicalGlobalObject, *callFrame, "setUserAgentPart");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_treeScopeRootNodeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto nodeConversionResult = convert<IDLInterface<Node>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "node"_s, "Internals"_s, "treeScopeRootNode"_s, "Node"_s); });
    if (nodeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<Node>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.treeScopeRootNode(*nodeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_treeScopeRootNode, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_treeScopeRootNodeBody>(*lexicalGlobalObject, *callFrame, "treeScopeRootNode");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_parentTreeScopeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto nodeConversionResult = convert<IDLInterface<Node>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "node"_s, "Internals"_s, "parentTreeScope"_s, "Node"_s); });
    if (nodeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<Node>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.parentTreeScope(*nodeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_parentTreeScope, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_parentTreeScopeBody>(*lexicalGlobalObject, *callFrame, "parentTreeScope");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_lastSpatialNavigationCandidateCountBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.lastSpatialNavigationCandidateCount())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_lastSpatialNavigationCandidateCount, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_lastSpatialNavigationCandidateCountBody>(*lexicalGlobalObject, *callFrame, "lastSpatialNavigationCandidateCount");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_animationWithIdExistsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto idConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (idConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.animationWithIdExists(idConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_animationWithIdExists, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_animationWithIdExistsBody>(*lexicalGlobalObject, *callFrame, "animationWithIdExists");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_numberOfActiveAnimationsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.numberOfActiveAnimations())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_numberOfActiveAnimations, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_numberOfActiveAnimationsBody>(*lexicalGlobalObject, *callFrame, "numberOfActiveAnimations");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_suspendAnimationsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.suspendAnimations(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_suspendAnimations, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_suspendAnimationsBody>(*lexicalGlobalObject, *callFrame, "suspendAnimations");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_resumeAnimationsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.resumeAnimations(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_resumeAnimations, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_resumeAnimationsBody>(*lexicalGlobalObject, *callFrame, "resumeAnimations");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_animationsAreSuspendedBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.animationsAreSuspended())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_animationsAreSuspended, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_animationsAreSuspendedBody>(*lexicalGlobalObject, *callFrame, "animationsAreSuspended");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_acceleratedAnimationsForElementBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "acceleratedAnimationsForElement"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLSequence<IDLDictionary<Internals::AcceleratedAnimation>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.acceleratedAnimationsForElement(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_acceleratedAnimationsForElement, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_acceleratedAnimationsForElementBody>(*lexicalGlobalObject, *callFrame, "acceleratedAnimationsForElement");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_numberOfAnimationTimelineInvalidationsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.numberOfAnimationTimelineInvalidations())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_numberOfAnimationTimelineInvalidations, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_numberOfAnimationTimelineInvalidationsBody>(*lexicalGlobalObject, *callFrame, "numberOfAnimationTimelineInvalidations");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_timeToNextAnimationTickBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto animationConversionResult = convert<IDLInterface<WebAnimation>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "animation"_s, "Internals"_s, "timeToNextAnimationTick"_s, "WebAnimation"_s); });
    if (animationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDouble>(*lexicalGlobalObject, throwScope, impl.timeToNextAnimationTick(*animationConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_timeToNextAnimationTick, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_timeToNextAnimationTickBody>(*lexicalGlobalObject, *callFrame, "timeToNextAnimationTick");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_pseudoElementBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "pseudoElement"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto pseudoIdConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (pseudoIdConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLInterface<Element>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.pseudoElement(*elementConversionResult.releaseReturnValue(), pseudoIdConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_pseudoElement, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_pseudoElementBody>(*lexicalGlobalObject, *callFrame, "pseudoElement");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_preferredRenderingUpdateIntervalBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDouble>(*lexicalGlobalObject, throwScope, impl.preferredRenderingUpdateInterval())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_preferredRenderingUpdateInterval, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_preferredRenderingUpdateIntervalBody>(*lexicalGlobalObject, *callFrame, "preferredRenderingUpdateInterval");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_visiblePlaceholderBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "visiblePlaceholder"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.visiblePlaceholder(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_visiblePlaceholder, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_visiblePlaceholderBody>(*lexicalGlobalObject, *callFrame, "visiblePlaceholder");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_selectColorInColorChooserBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLInputElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "selectColorInColorChooser"_s, "HTMLInputElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto colorValueConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (colorValueConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.selectColorInColorChooser(*elementConversionResult.releaseReturnValue(), colorValueConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_selectColorInColorChooser, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_selectColorInColorChooserBody>(*lexicalGlobalObject, *callFrame, "selectColorInColorChooser");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_formControlStateOfPreviousHistoryItemBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLSequence<IDLAtomStringAdaptor<IDLDOMString>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.formControlStateOfPreviousHistoryItem())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_formControlStateOfPreviousHistoryItem, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_formControlStateOfPreviousHistoryItemBody>(*lexicalGlobalObject, *callFrame, "formControlStateOfPreviousHistoryItem");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setFormControlStateOfPreviousHistoryItemBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto valuesConversionResult = convert<IDLSequence<IDLAtomStringAdaptor<IDLDOMString>>>(*lexicalGlobalObject, argument0.value());
    if (valuesConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setFormControlStateOfPreviousHistoryItem(valuesConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setFormControlStateOfPreviousHistoryItem, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setFormControlStateOfPreviousHistoryItemBody>(*lexicalGlobalObject, *callFrame, "setFormControlStateOfPreviousHistoryItem");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_absoluteLineRectFromPointBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto xConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument0.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto yConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<DOMRect>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.absoluteLineRectFromPoint(xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_absoluteLineRectFromPoint, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_absoluteLineRectFromPointBody>(*lexicalGlobalObject, *callFrame, "absoluteLineRectFromPoint");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_absoluteCaretBoundsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<DOMRect>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.absoluteCaretBounds())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_absoluteCaretBounds, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_absoluteCaretBoundsBody>(*lexicalGlobalObject, *callFrame, "absoluteCaretBounds");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isCaretVisibleBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isCaretVisible())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isCaretVisible, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isCaretVisibleBody>(*lexicalGlobalObject, *callFrame, "isCaretVisible");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isCaretBlinkingSuspended1Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isCaretBlinkingSuspended())));
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isCaretBlinkingSuspended2Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto documentConversionResult = convert<IDLInterface<Document>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "document"_s, "Internals"_s, "isCaretBlinkingSuspended"_s, "Document"_s); });
    if (documentConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isCaretBlinkingSuspended(*documentConversionResult.releaseReturnValue()))));
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isCaretBlinkingSuspendedOverloadDispatcher(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    size_t argsCount = std::min<size_t>(1, callFrame->argumentCount());
    if (argsCount == 0) {
        RELEASE_AND_RETURN(throwScope, (jsInternalsPrototypeFunction_isCaretBlinkingSuspended1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    if (argsCount == 1) {
        RELEASE_AND_RETURN(throwScope, (jsInternalsPrototypeFunction_isCaretBlinkingSuspended2Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    return throwVMTypeError(lexicalGlobalObject, throwScope);
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isCaretBlinkingSuspended, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isCaretBlinkingSuspendedOverloadDispatcher>(*lexicalGlobalObject, *callFrame, "isCaretBlinkingSuspended");
}

#if ENABLE(ACCESSIBILITY_NON_BLINKING_CURSOR)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setPrefersNonBlinkingCursorBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto enabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (enabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setPrefersNonBlinkingCursor(enabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPrefersNonBlinkingCursor, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setPrefersNonBlinkingCursorBody>(*lexicalGlobalObject, *callFrame, "setPrefersNonBlinkingCursor");
}

#endif

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_boundingBoxBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "boundingBox"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<DOMRect>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.boundingBox(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_boundingBox, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_boundingBoxBody>(*lexicalGlobalObject, *callFrame, "boundingBox");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_inspectorGridOverlayCountBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.inspectorGridOverlayCount())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_inspectorGridOverlayCount, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_inspectorGridOverlayCountBody>(*lexicalGlobalObject, *callFrame, "inspectorGridOverlayCount");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_inspectorFlexOverlayCountBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.inspectorFlexOverlayCount())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_inspectorFlexOverlayCount, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_inspectorFlexOverlayCountBody>(*lexicalGlobalObject, *callFrame, "inspectorFlexOverlayCount");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_inspectorHighlightRectsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<DOMRectList>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.inspectorHighlightRects())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_inspectorHighlightRects, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_inspectorHighlightRectsBody>(*lexicalGlobalObject, *callFrame, "inspectorHighlightRects");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_inspectorPaintRectCountBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.inspectorPaintRectCount())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_inspectorPaintRectCount, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_inspectorPaintRectCountBody>(*lexicalGlobalObject, *callFrame, "inspectorPaintRectCount");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_markerCountForNodeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto nodeConversionResult = convert<IDLInterface<Node>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "node"_s, "Internals"_s, "markerCountForNode"_s, "Node"_s); });
    if (nodeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto markerTypeConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (markerTypeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.markerCountForNode(*nodeConversionResult.releaseReturnValue(), markerTypeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_markerCountForNode, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_markerCountForNodeBody>(*lexicalGlobalObject, *callFrame, "markerCountForNode");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_markerRangeForNodeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto nodeConversionResult = convert<IDLInterface<Node>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "node"_s, "Internals"_s, "markerRangeForNode"_s, "Node"_s); });
    if (nodeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto markerTypeConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (markerTypeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLInterface<Range>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.markerRangeForNode(*nodeConversionResult.releaseReturnValue(), markerTypeConversionResult.releaseReturnValue(), indexConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_markerRangeForNode, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_markerRangeForNodeBody>(*lexicalGlobalObject, *callFrame, "markerRangeForNode");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_markerDescriptionForNodeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto nodeConversionResult = convert<IDLInterface<Node>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "node"_s, "Internals"_s, "markerDescriptionForNode"_s, "Node"_s); });
    if (nodeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto markerTypeConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (markerTypeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.markerDescriptionForNode(*nodeConversionResult.releaseReturnValue(), markerTypeConversionResult.releaseReturnValue(), indexConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_markerDescriptionForNode, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_markerDescriptionForNodeBody>(*lexicalGlobalObject, *callFrame, "markerDescriptionForNode");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_dumpMarkerRectsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto markerTypeConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (markerTypeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.dumpMarkerRects(markerTypeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_dumpMarkerRects, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_dumpMarkerRectsBody>(*lexicalGlobalObject, *callFrame, "dumpMarkerRects");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setMarkedTextMatchesAreHighlightedBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto flagConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (flagConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setMarkedTextMatchesAreHighlighted(flagConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMarkedTextMatchesAreHighlighted, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setMarkedTextMatchesAreHighlightedBody>(*lexicalGlobalObject, *callFrame, "setMarkedTextMatchesAreHighlighted");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_snapshotNodeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto nodeConversionResult = convert<IDLInterface<Node>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "node"_s, "Internals"_s, "snapshotNode"_s, "Node"_s); });
    if (nodeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<ImageData>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.snapshotNode(*nodeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_snapshotNode, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_snapshotNodeBody>(*lexicalGlobalObject, *callFrame, "snapshotNode");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_invalidateFontCacheBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.invalidateFontCache(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_invalidateFontCache, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_invalidateFontCacheBody>(*lexicalGlobalObject, *callFrame, "invalidateFontCache");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setScrollViewPositionBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto xConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument0.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto yConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setScrollViewPosition(xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setScrollViewPosition, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setScrollViewPositionBody>(*lexicalGlobalObject, *callFrame, "setScrollViewPosition");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_unconstrainedScrollToBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "unconstrainedScrollTo"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto xConversionResult = convert<IDLUnrestrictedDouble>(*lexicalGlobalObject, argument1.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto yConversionResult = convert<IDLUnrestrictedDouble>(*lexicalGlobalObject, argument2.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.unconstrainedScrollTo(*elementConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_unconstrainedScrollTo, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_unconstrainedScrollToBody>(*lexicalGlobalObject, *callFrame, "unconstrainedScrollTo");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_scrollBySimulatingWheelEventBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "scrollBySimulatingWheelEvent"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto deltaXConversionResult = convert<IDLUnrestrictedDouble>(*lexicalGlobalObject, argument1.value());
    if (deltaXConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto deltaYConversionResult = convert<IDLUnrestrictedDouble>(*lexicalGlobalObject, argument2.value());
    if (deltaYConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.scrollBySimulatingWheelEvent(*elementConversionResult.releaseReturnValue(), deltaXConversionResult.releaseReturnValue(), deltaYConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_scrollBySimulatingWheelEvent, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_scrollBySimulatingWheelEventBody>(*lexicalGlobalObject, *callFrame, "scrollBySimulatingWheelEvent");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_layoutViewportRectBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<DOMRect>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.layoutViewportRect())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_layoutViewportRect, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_layoutViewportRectBody>(*lexicalGlobalObject, *callFrame, "layoutViewportRect");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_visualViewportRectBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<DOMRect>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.visualViewportRect())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_visualViewportRect, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_visualViewportRectBody>(*lexicalGlobalObject, *callFrame, "visualViewportRect");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setViewIsTransparentBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto trnasparentConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (trnasparentConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setViewIsTransparent(trnasparentConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setViewIsTransparent, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setViewIsTransparentBody>(*lexicalGlobalObject, *callFrame, "setViewIsTransparent");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_viewBaseBackgroundColorBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.viewBaseBackgroundColor())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_viewBaseBackgroundColor, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_viewBaseBackgroundColorBody>(*lexicalGlobalObject, *callFrame, "viewBaseBackgroundColor");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setViewBaseBackgroundColorBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto colorValueConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (colorValueConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setViewBaseBackgroundColor(colorValueConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setViewBaseBackgroundColor, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setViewBaseBackgroundColorBody>(*lexicalGlobalObject, *callFrame, "setViewBaseBackgroundColor");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setUnderPageBackgroundColorOverrideBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto colorValueConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (colorValueConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setUnderPageBackgroundColorOverride(colorValueConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setUnderPageBackgroundColorOverride, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setUnderPageBackgroundColorOverrideBody>(*lexicalGlobalObject, *callFrame, "setUnderPageBackgroundColorOverride");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_documentBackgroundColorBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.documentBackgroundColor())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_documentBackgroundColor, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_documentBackgroundColorBody>(*lexicalGlobalObject, *callFrame, "documentBackgroundColor");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_displayP3AvailableBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.displayP3Available())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_displayP3Available, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_displayP3AvailableBody>(*lexicalGlobalObject, *callFrame, "displayP3Available");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setPaginationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto modeConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (modeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto gapConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (gapConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->argument(2);
    auto pageLengthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (pageLengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setPagination(modeConversionResult.releaseReturnValue(), gapConversionResult.releaseReturnValue(), pageLengthConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPagination, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setPaginationBody>(*lexicalGlobalObject, *callFrame, "setPagination");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_lineIndexAfterPageBreakBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "lineIndexAfterPageBreak"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLongLong>(*lexicalGlobalObject, throwScope, impl.lineIndexAfterPageBreak(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_lineIndexAfterPageBreak, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_lineIndexAfterPageBreakBody>(*lexicalGlobalObject, *callFrame, "lineIndexAfterPageBreak");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_configurationForViewportBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 5) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto devicePixelRatioConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument0.value());
    if (devicePixelRatioConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto deviceWidthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (deviceWidthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto deviceHeightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (deviceHeightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto availableWidthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (availableWidthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto availableHeightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (availableHeightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.configurationForViewport(devicePixelRatioConversionResult.releaseReturnValue(), deviceWidthConversionResult.releaseReturnValue(), deviceHeightConversionResult.releaseReturnValue(), availableWidthConversionResult.releaseReturnValue(), availableHeightConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_configurationForViewport, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_configurationForViewportBody>(*lexicalGlobalObject, *callFrame, "configurationForViewport");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_wasLastChangeUserEditBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto textFieldConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "textField"_s, "Internals"_s, "wasLastChangeUserEdit"_s, "Element"_s); });
    if (textFieldConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.wasLastChangeUserEdit(*textFieldConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_wasLastChangeUserEdit, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_wasLastChangeUserEditBody>(*lexicalGlobalObject, *callFrame, "wasLastChangeUserEdit");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_elementShouldAutoCompleteBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto inputElementConversionResult = convert<IDLInterface<HTMLInputElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "inputElement"_s, "Internals"_s, "elementShouldAutoComplete"_s, "HTMLInputElement"_s); });
    if (inputElementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.elementShouldAutoComplete(*inputElementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_elementShouldAutoComplete, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_elementShouldAutoCompleteBody>(*lexicalGlobalObject, *callFrame, "elementShouldAutoComplete");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setAutofilledBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto inputElementConversionResult = convert<IDLInterface<HTMLInputElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "inputElement"_s, "Internals"_s, "setAutofilled"_s, "HTMLInputElement"_s); });
    if (inputElementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto enabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (enabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setAutofilled(*inputElementConversionResult.releaseReturnValue(), enabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setAutofilled, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setAutofilledBody>(*lexicalGlobalObject, *callFrame, "setAutofilled");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setAutofilledAndViewableBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto inputElementConversionResult = convert<IDLInterface<HTMLInputElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "inputElement"_s, "Internals"_s, "setAutofilledAndViewable"_s, "HTMLInputElement"_s); });
    if (inputElementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto enabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (enabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setAutofilledAndViewable(*inputElementConversionResult.releaseReturnValue(), enabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setAutofilledAndViewable, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setAutofilledAndViewableBody>(*lexicalGlobalObject, *callFrame, "setAutofilledAndViewable");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setAutofilledAndObscuredBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto inputElementConversionResult = convert<IDLInterface<HTMLInputElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "inputElement"_s, "Internals"_s, "setAutofilledAndObscured"_s, "HTMLInputElement"_s); });
    if (inputElementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto enabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (enabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setAutofilledAndObscured(*inputElementConversionResult.releaseReturnValue(), enabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setAutofilledAndObscured, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setAutofilledAndObscuredBody>(*lexicalGlobalObject, *callFrame, "setAutofilledAndObscured");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setAutofillButtonTypeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto inputElementConversionResult = convert<IDLInterface<HTMLInputElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "inputElement"_s, "Internals"_s, "setAutofillButtonType"_s, "HTMLInputElement"_s); });
    if (inputElementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto autoFillButtonTypeConversionResult = convert<IDLEnumeration<Internals::AutoFillButtonType>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentMustBeEnumError(lexicalGlobalObject, scope, 1, "autoFillButtonType"_s, "Internals"_s, "setAutofillButtonType"_s, expectedEnumerationValues<Internals::AutoFillButtonType>()); });
    if (autoFillButtonTypeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setAutofillButtonType(*inputElementConversionResult.releaseReturnValue(), autoFillButtonTypeConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setAutofillButtonType, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setAutofillButtonTypeBody>(*lexicalGlobalObject, *callFrame, "setAutofillButtonType");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_autofillButtonTypeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto inputElementConversionResult = convert<IDLInterface<HTMLInputElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "inputElement"_s, "Internals"_s, "autofillButtonType"_s, "HTMLInputElement"_s); });
    if (inputElementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLEnumeration<Internals::AutoFillButtonType>>(*lexicalGlobalObject, throwScope, impl.autofillButtonType(*inputElementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_autofillButtonType, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_autofillButtonTypeBody>(*lexicalGlobalObject, *callFrame, "autofillButtonType");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_lastAutofillButtonTypeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto inputElementConversionResult = convert<IDLInterface<HTMLInputElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "inputElement"_s, "Internals"_s, "lastAutofillButtonType"_s, "HTMLInputElement"_s); });
    if (inputElementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLEnumeration<Internals::AutoFillButtonType>>(*lexicalGlobalObject, throwScope, impl.lastAutofillButtonType(*inputElementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_lastAutofillButtonType, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_lastAutofillButtonTypeBody>(*lexicalGlobalObject, *callFrame, "lastAutofillButtonType");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_recentSearchesBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto inputElementConversionResult = convert<IDLInterface<HTMLInputElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "inputElement"_s, "Internals"_s, "recentSearches"_s, "HTMLInputElement"_s); });
    if (inputElementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLSequence<IDLDOMString>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.recentSearches(*inputElementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_recentSearches, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_recentSearchesBody>(*lexicalGlobalObject, *callFrame, "recentSearches");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setCanShowPlaceholderBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "setCanShowPlaceholder"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto canShowPlaceholderConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (canShowPlaceholderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setCanShowPlaceholder(*elementConversionResult.releaseReturnValue(), canShowPlaceholderConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setCanShowPlaceholder, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setCanShowPlaceholderBody>(*lexicalGlobalObject, *callFrame, "setCanShowPlaceholder");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_insertTextPlaceholderBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument0.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<Element>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.insertTextPlaceholder(widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_insertTextPlaceholder, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_insertTextPlaceholderBody>(*lexicalGlobalObject, *callFrame, "insertTextPlaceholder");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_removeTextPlaceholderBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "removeTextPlaceholder"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.removeTextPlaceholder(*elementConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_removeTextPlaceholder, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_removeTextPlaceholderBody>(*lexicalGlobalObject, *callFrame, "removeTextPlaceholder");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_rangeOfStringBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto textConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (textConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto referenceRangeConversionResult = convert<IDLNullable<IDLInterface<Range>>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "referenceRange"_s, "Internals"_s, "rangeOfString"_s, "Range"_s); });
    if (referenceRangeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto findOptionsConversionResult = convert<IDLSequence<IDLDOMString>>(*lexicalGlobalObject, argument2.value());
    if (findOptionsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLInterface<Range>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.rangeOfString(textConversionResult.releaseReturnValue(), referenceRangeConversionResult.releaseReturnValue(), findOptionsConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_rangeOfString, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_rangeOfStringBody>(*lexicalGlobalObject, *callFrame, "rangeOfString");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_countMatchesForTextBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto textConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (textConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto findOptionsConversionResult = convert<IDLSequence<IDLDOMString>>(*lexicalGlobalObject, argument1.value());
    if (findOptionsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto markMatchesConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument2.value());
    if (markMatchesConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.countMatchesForText(textConversionResult.releaseReturnValue(), findOptionsConversionResult.releaseReturnValue(), markMatchesConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_countMatchesForText, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_countMatchesForTextBody>(*lexicalGlobalObject, *callFrame, "countMatchesForText");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_countFindMatchesBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto textConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (textConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto findOptionsConversionResult = convert<IDLSequence<IDLDOMString>>(*lexicalGlobalObject, argument1.value());
    if (findOptionsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.countFindMatches(textConversionResult.releaseReturnValue(), findOptionsConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_countFindMatches, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_countFindMatchesBody>(*lexicalGlobalObject, *callFrame, "countFindMatches");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_autofillFieldNameBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto formControlElementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "formControlElement"_s, "Internals"_s, "autofillFieldName"_s, "Element"_s); });
    if (formControlElementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.autofillFieldName(*formControlElementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_autofillFieldName, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_autofillFieldNameBody>(*lexicalGlobalObject, *callFrame, "autofillFieldName");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isSpellcheckDisabledExceptTextReplacementBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto inputElementConversionResult = convert<IDLInterface<HTMLInputElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "inputElement"_s, "Internals"_s, "isSpellcheckDisabledExceptTextReplacement"_s, "HTMLInputElement"_s); });
    if (inputElementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isSpellcheckDisabledExceptTextReplacement(*inputElementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isSpellcheckDisabledExceptTextReplacement, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isSpellcheckDisabledExceptTextReplacementBody>(*lexicalGlobalObject, *callFrame, "isSpellcheckDisabledExceptTextReplacement");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_invalidateControlTintsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.invalidateControlTints(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_invalidateControlTints, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_invalidateControlTintsBody>(*lexicalGlobalObject, *callFrame, "invalidateControlTints");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_scrollElementToRectBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 5) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "scrollElementToRect"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto xConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto yConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto wConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (wConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto hConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (hConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.scrollElementToRect(*elementConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), wConversionResult.releaseReturnValue(), hConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_scrollElementToRect, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_scrollElementToRectBody>(*lexicalGlobalObject, *callFrame, "scrollElementToRect");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_rangeFromLocationAndLengthBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto scopeConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "scope"_s, "Internals"_s, "rangeFromLocationAndLength"_s, "Element"_s); });
    if (scopeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto rangeLocationConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (rangeLocationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto rangeLengthConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (rangeLengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLInterface<Range>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.rangeFromLocationAndLength(*scopeConversionResult.releaseReturnValue(), rangeLocationConversionResult.releaseReturnValue(), rangeLengthConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_rangeFromLocationAndLength, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_rangeFromLocationAndLengthBody>(*lexicalGlobalObject, *callFrame, "rangeFromLocationAndLength");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_locationFromRangeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto scopeConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "scope"_s, "Internals"_s, "locationFromRange"_s, "Element"_s); });
    if (scopeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto rangeConversionResult = convert<IDLInterface<Range>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "range"_s, "Internals"_s, "locationFromRange"_s, "Range"_s); });
    if (rangeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.locationFromRange(*scopeConversionResult.releaseReturnValue(), *rangeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_locationFromRange, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_locationFromRangeBody>(*lexicalGlobalObject, *callFrame, "locationFromRange");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_lengthFromRangeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto scopeConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "scope"_s, "Internals"_s, "lengthFromRange"_s, "Element"_s); });
    if (scopeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto rangeConversionResult = convert<IDLInterface<Range>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "range"_s, "Internals"_s, "lengthFromRange"_s, "Range"_s); });
    if (rangeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.lengthFromRange(*scopeConversionResult.releaseReturnValue(), *rangeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_lengthFromRange, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_lengthFromRangeBody>(*lexicalGlobalObject, *callFrame, "lengthFromRange");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_rangeAsTextBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto rangeConversionResult = convert<IDLInterface<Range>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "range"_s, "Internals"_s, "rangeAsText"_s, "Range"_s); });
    if (rangeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.rangeAsText(*rangeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_rangeAsText, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_rangeAsTextBody>(*lexicalGlobalObject, *callFrame, "rangeAsText");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_rangeAsTextUsingBackwardsTextIteratorBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto rangeConversionResult = convert<IDLInterface<Range>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "range"_s, "Internals"_s, "rangeAsTextUsingBackwardsTextIterator"_s, "Range"_s); });
    if (rangeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.rangeAsTextUsingBackwardsTextIterator(*rangeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_rangeAsTextUsingBackwardsTextIterator, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_rangeAsTextUsingBackwardsTextIteratorBody>(*lexicalGlobalObject, *callFrame, "rangeAsTextUsingBackwardsTextIterator");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_subrangeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto rangeConversionResult = convert<IDLInterface<Range>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "range"_s, "Internals"_s, "subrange"_s, "Range"_s); });
    if (rangeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto rangeLocationConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (rangeLocationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto rangeLengthConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (rangeLengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<Range>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.subrange(*rangeConversionResult.releaseReturnValue(), rangeLocationConversionResult.releaseReturnValue(), rangeLengthConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_subrange, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_subrangeBody>(*lexicalGlobalObject, *callFrame, "subrange");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_rangeForDictionaryLookupAtLocationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto xConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument0.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto yConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLInterface<Range>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.rangeForDictionaryLookupAtLocation(xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_rangeForDictionaryLookupAtLocation, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_rangeForDictionaryLookupAtLocationBody>(*lexicalGlobalObject, *callFrame, "rangeForDictionaryLookupAtLocation");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_rangeOfStringNearLocationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto rangeConversionResult = convert<IDLInterface<Range>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "range"_s, "Internals"_s, "rangeOfStringNearLocation"_s, "Range"_s); });
    if (rangeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto textConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (textConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto targetOffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (targetOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLInterface<Range>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.rangeOfStringNearLocation(*rangeConversionResult.releaseReturnValue(), textConversionResult.releaseReturnValue(), targetOffsetConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_rangeOfStringNearLocation, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_rangeOfStringNearLocationBody>(*lexicalGlobalObject, *callFrame, "rangeOfStringNearLocation");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_statesOfTextIteratorBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto rangeConversionResult = convert<IDLInterface<Range>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "range"_s, "Internals"_s, "statesOfTextIterator"_s, "Range"_s); });
    if (rangeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLSequence<IDLDictionary<Internals::TextIteratorState>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.statesOfTextIterator(*rangeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_statesOfTextIterator, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_statesOfTextIteratorBody>(*lexicalGlobalObject, *callFrame, "statesOfTextIterator");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_textFragmentDirectiveForRangeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto rangeConversionResult = convert<IDLInterface<Range>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "range"_s, "Internals"_s, "textFragmentDirectiveForRange"_s, "Range"_s); });
    if (rangeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.textFragmentDirectiveForRange(*rangeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_textFragmentDirectiveForRange, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_textFragmentDirectiveForRangeBody>(*lexicalGlobalObject, *callFrame, "textFragmentDirectiveForRange");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setDelegatesScrollingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto enabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (enabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setDelegatesScrolling(enabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setDelegatesScrolling, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setDelegatesScrollingBody>(*lexicalGlobalObject, *callFrame, "setDelegatesScrolling");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_lastSpellCheckRequestSequenceBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLongLong>(*lexicalGlobalObject, throwScope, impl.lastSpellCheckRequestSequence())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_lastSpellCheckRequestSequence, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_lastSpellCheckRequestSequenceBody>(*lexicalGlobalObject, *callFrame, "lastSpellCheckRequestSequence");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_lastSpellCheckProcessedSequenceBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLongLong>(*lexicalGlobalObject, throwScope, impl.lastSpellCheckProcessedSequence())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_lastSpellCheckProcessedSequence, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_lastSpellCheckProcessedSequenceBody>(*lexicalGlobalObject, *callFrame, "lastSpellCheckProcessedSequence");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_advanceToNextMisspellingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.advanceToNextMisspelling(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_advanceToNextMisspelling, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_advanceToNextMisspellingBody>(*lexicalGlobalObject, *callFrame, "advanceToNextMisspelling");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_userPreferredLanguagesBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLSequence<IDLDOMString>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.userPreferredLanguages())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_userPreferredLanguages, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_userPreferredLanguagesBody>(*lexicalGlobalObject, *callFrame, "userPreferredLanguages");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setUserPreferredLanguagesBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto languagesConversionResult = convert<IDLSequence<IDLDOMString>>(*lexicalGlobalObject, argument0.value());
    if (languagesConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setUserPreferredLanguages(languagesConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setUserPreferredLanguages, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setUserPreferredLanguagesBody>(*lexicalGlobalObject, *callFrame, "setUserPreferredLanguages");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_userPreferredAudioCharacteristicsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLSequence<IDLDOMString>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.userPreferredAudioCharacteristics())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_userPreferredAudioCharacteristics, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_userPreferredAudioCharacteristicsBody>(*lexicalGlobalObject, *callFrame, "userPreferredAudioCharacteristics");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setUserPreferredAudioCharacteristicBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto characteristicConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (characteristicConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setUserPreferredAudioCharacteristic(characteristicConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setUserPreferredAudioCharacteristic, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setUserPreferredAudioCharacteristicBody>(*lexicalGlobalObject, *callFrame, "setUserPreferredAudioCharacteristic");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_wheelEventHandlerCountBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.wheelEventHandlerCount())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_wheelEventHandlerCount, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_wheelEventHandlerCountBody>(*lexicalGlobalObject, *callFrame, "wheelEventHandlerCount");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_touchEventHandlerCountBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.touchEventHandlerCount())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_touchEventHandlerCount, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_touchEventHandlerCountBody>(*lexicalGlobalObject, *callFrame, "touchEventHandlerCount");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_touchEventRectsForEventBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto eventNameConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (eventNameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<DOMRectList>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.touchEventRectsForEvent(eventNameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_touchEventRectsForEvent, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_touchEventRectsForEventBody>(*lexicalGlobalObject, *callFrame, "touchEventRectsForEvent");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_passiveTouchEventListenerRectsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<DOMRectList>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.passiveTouchEventListenerRects())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_passiveTouchEventListenerRects, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_passiveTouchEventListenerRectsBody>(*lexicalGlobalObject, *callFrame, "passiveTouchEventListenerRects");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_nodesFromRectBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 10) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto documentConversionResult = convert<IDLInterface<Document>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "document"_s, "Internals"_s, "nodesFromRect"_s, "Document"_s); });
    if (documentConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto xConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto yConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto topPaddingConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (topPaddingConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto rightPaddingConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument4.value());
    if (rightPaddingConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto bottomPaddingConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument5.value());
    if (bottomPaddingConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto leftPaddingConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument6.value());
    if (leftPaddingConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto ignoreClippingConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument7.value());
    if (ignoreClippingConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument8 = callFrame->uncheckedArgument(8);
    auto allowShadowContentConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument8.value());
    if (allowShadowContentConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument9 = callFrame->uncheckedArgument(9);
    auto allowChildFrameContentConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument9.value());
    if (allowChildFrameContentConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLInterface<NodeList>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.nodesFromRect(*documentConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), topPaddingConversionResult.releaseReturnValue(), rightPaddingConversionResult.releaseReturnValue(), bottomPaddingConversionResult.releaseReturnValue(), leftPaddingConversionResult.releaseReturnValue(), ignoreClippingConversionResult.releaseReturnValue(), allowShadowContentConversionResult.releaseReturnValue(), allowChildFrameContentConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_nodesFromRect, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_nodesFromRectBody>(*lexicalGlobalObject, *callFrame, "nodesFromRect");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_parserMetaDataBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->argument(0);
    auto funcConversionResult = convert<IDLAny>(*lexicalGlobalObject, argument0.value());
    if (funcConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.parserMetaData(funcConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_parserMetaData, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_parserMetaDataBody>(*lexicalGlobalObject, *callFrame, "parserMetaData");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_updateEditorUINowIfScheduledBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.updateEditorUINowIfScheduled(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_updateEditorUINowIfScheduled, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_updateEditorUINowIfScheduledBody>(*lexicalGlobalObject, *callFrame, "updateEditorUINowIfScheduled");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_hasSpellingMarkerBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto fromConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument0.value());
    if (fromConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto lengthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (lengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.hasSpellingMarker(fromConversionResult.releaseReturnValue(), lengthConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasSpellingMarker, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_hasSpellingMarkerBody>(*lexicalGlobalObject, *callFrame, "hasSpellingMarker");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_hasGrammarMarkerBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto fromConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument0.value());
    if (fromConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto lengthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (lengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.hasGrammarMarker(fromConversionResult.releaseReturnValue(), lengthConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasGrammarMarker, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_hasGrammarMarkerBody>(*lexicalGlobalObject, *callFrame, "hasGrammarMarker");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_hasAutocorrectedMarkerBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto fromConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument0.value());
    if (fromConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto lengthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (lengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.hasAutocorrectedMarker(fromConversionResult.releaseReturnValue(), lengthConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasAutocorrectedMarker, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_hasAutocorrectedMarkerBody>(*lexicalGlobalObject, *callFrame, "hasAutocorrectedMarker");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_hasDictationAlternativesMarkerBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto fromConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument0.value());
    if (fromConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto lengthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (lengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.hasDictationAlternativesMarker(fromConversionResult.releaseReturnValue(), lengthConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasDictationAlternativesMarker, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_hasDictationAlternativesMarkerBody>(*lexicalGlobalObject, *callFrame, "hasDictationAlternativesMarker");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_hasCorrectionIndicatorMarkerBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto fromConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument0.value());
    if (fromConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto lengthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (lengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.hasCorrectionIndicatorMarker(fromConversionResult.releaseReturnValue(), lengthConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasCorrectionIndicatorMarker, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_hasCorrectionIndicatorMarkerBody>(*lexicalGlobalObject, *callFrame, "hasCorrectionIndicatorMarker");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_hasTransparentContentMarkerBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto fromConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument0.value());
    if (fromConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto lengthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (lengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.hasTransparentContentMarker(fromConversionResult.releaseReturnValue(), lengthConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasTransparentContentMarker, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_hasTransparentContentMarkerBody>(*lexicalGlobalObject, *callFrame, "hasTransparentContentMarker");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setContinuousSpellCheckingEnabledBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto enabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (enabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setContinuousSpellCheckingEnabled(enabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setContinuousSpellCheckingEnabled, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setContinuousSpellCheckingEnabledBody>(*lexicalGlobalObject, *callFrame, "setContinuousSpellCheckingEnabled");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setAutomaticQuoteSubstitutionEnabledBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto enabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (enabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setAutomaticQuoteSubstitutionEnabled(enabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setAutomaticQuoteSubstitutionEnabled, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setAutomaticQuoteSubstitutionEnabledBody>(*lexicalGlobalObject, *callFrame, "setAutomaticQuoteSubstitutionEnabled");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setAutomaticLinkDetectionEnabledBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto enabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (enabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setAutomaticLinkDetectionEnabled(enabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setAutomaticLinkDetectionEnabled, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setAutomaticLinkDetectionEnabledBody>(*lexicalGlobalObject, *callFrame, "setAutomaticLinkDetectionEnabled");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setAutomaticDashSubstitutionEnabledBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto enabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (enabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setAutomaticDashSubstitutionEnabled(enabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setAutomaticDashSubstitutionEnabled, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setAutomaticDashSubstitutionEnabledBody>(*lexicalGlobalObject, *callFrame, "setAutomaticDashSubstitutionEnabled");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setAutomaticTextReplacementEnabledBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto enabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (enabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setAutomaticTextReplacementEnabled(enabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setAutomaticTextReplacementEnabled, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setAutomaticTextReplacementEnabledBody>(*lexicalGlobalObject, *callFrame, "setAutomaticTextReplacementEnabled");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setAutomaticSpellingCorrectionEnabledBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto enabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (enabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setAutomaticSpellingCorrectionEnabled(enabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setAutomaticSpellingCorrectionEnabled, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setAutomaticSpellingCorrectionEnabledBody>(*lexicalGlobalObject, *callFrame, "setAutomaticSpellingCorrectionEnabled");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setMarkerForBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto markerTypeStringConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (markerTypeStringConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto fromConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (fromConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto lengthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (lengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto dataConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument3.value());
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setMarkerFor(markerTypeStringConversionResult.releaseReturnValue(), fromConversionResult.releaseReturnValue(), lengthConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMarkerFor, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setMarkerForBody>(*lexicalGlobalObject, *callFrame, "setMarkerFor");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_handleAcceptedCandidateBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto candidateConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (candidateConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto locationConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto lengthConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (lengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.handleAcceptedCandidate(candidateConversionResult.releaseReturnValue(), locationConversionResult.releaseReturnValue(), lengthConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_handleAcceptedCandidate, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_handleAcceptedCandidateBody>(*lexicalGlobalObject, *callFrame, "handleAcceptedCandidate");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_changeSelectionListTypeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.changeSelectionListType(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_changeSelectionListType, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_changeSelectionListTypeBody>(*lexicalGlobalObject, *callFrame, "changeSelectionListType");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_changeBackToReplacedStringBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto replacedStringConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (replacedStringConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.changeBackToReplacedString(replacedStringConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_changeBackToReplacedString, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_changeBackToReplacedStringBody>(*lexicalGlobalObject, *callFrame, "changeBackToReplacedString");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isOverwriteModeEnabledBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isOverwriteModeEnabled())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isOverwriteModeEnabled, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isOverwriteModeEnabledBody>(*lexicalGlobalObject, *callFrame, "isOverwriteModeEnabled");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_toggleOverwriteModeEnabledBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.toggleOverwriteModeEnabled(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_toggleOverwriteModeEnabled, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_toggleOverwriteModeEnabledBody>(*lexicalGlobalObject, *callFrame, "toggleOverwriteModeEnabled");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_numberOfScrollableAreasBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.numberOfScrollableAreas())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_numberOfScrollableAreas, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_numberOfScrollableAreasBody>(*lexicalGlobalObject, *callFrame, "numberOfScrollableAreas");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isPageBoxVisibleBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto pageNumberConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument0.value());
    if (pageNumberConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isPageBoxVisible(pageNumberConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isPageBoxVisible, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isPageBoxVisibleBody>(*lexicalGlobalObject, *callFrame, "isPageBoxVisible");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_imageFrameIndexBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLImageElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "imageFrameIndex"_s, "HTMLImageElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.imageFrameIndex(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_imageFrameIndex, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_imageFrameIndexBody>(*lexicalGlobalObject, *callFrame, "imageFrameIndex");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_imageFrameCountBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLImageElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "imageFrameCount"_s, "HTMLImageElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.imageFrameCount(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_imageFrameCount, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_imageFrameCountBody>(*lexicalGlobalObject, *callFrame, "imageFrameCount");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_imageFrameDurationAtIndexBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLImageElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "imageFrameDurationAtIndex"_s, "HTMLImageElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLFloat>(*lexicalGlobalObject, throwScope, impl.imageFrameDurationAtIndex(*elementConversionResult.releaseReturnValue(), indexConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_imageFrameDurationAtIndex, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_imageFrameDurationAtIndexBody>(*lexicalGlobalObject, *callFrame, "imageFrameDurationAtIndex");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setImageFrameDecodingDurationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLImageElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "setImageFrameDecodingDuration"_s, "HTMLImageElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto durationConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument1.value());
    if (durationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setImageFrameDecodingDuration(*elementConversionResult.releaseReturnValue(), durationConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setImageFrameDecodingDuration, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setImageFrameDecodingDurationBody>(*lexicalGlobalObject, *callFrame, "setImageFrameDecodingDuration");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_resetImageAnimationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLImageElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "resetImageAnimation"_s, "HTMLImageElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.resetImageAnimation(*elementConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_resetImageAnimation, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_resetImageAnimationBody>(*lexicalGlobalObject, *callFrame, "resetImageAnimation");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isImageAnimatingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLImageElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "isImageAnimating"_s, "HTMLImageElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isImageAnimating(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isImageAnimating, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isImageAnimatingBody>(*lexicalGlobalObject, *callFrame, "isImageAnimating");
}

#if ENABLE(ACCESSIBILITY_ANIMATION_CONTROL)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setImageAnimationEnabledBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto enabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (enabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setImageAnimationEnabled(enabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setImageAnimationEnabled, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setImageAnimationEnabledBody>(*lexicalGlobalObject, *callFrame, "setImageAnimationEnabled");
}

#endif

#if ENABLE(ACCESSIBILITY_ANIMATION_CONTROL)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_resumeImageAnimationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLImageElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "resumeImageAnimation"_s, "HTMLImageElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.resumeImageAnimation(*elementConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_resumeImageAnimation, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_resumeImageAnimationBody>(*lexicalGlobalObject, *callFrame, "resumeImageAnimation");
}

#endif

#if ENABLE(ACCESSIBILITY_ANIMATION_CONTROL)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_pauseImageAnimationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLImageElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "pauseImageAnimation"_s, "HTMLImageElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.pauseImageAnimation(*elementConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_pauseImageAnimation, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_pauseImageAnimationBody>(*lexicalGlobalObject, *callFrame, "pauseImageAnimation");
}

#endif

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_imagePendingDecodePromisesCountForTestingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLImageElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "imagePendingDecodePromisesCountForTesting"_s, "HTMLImageElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.imagePendingDecodePromisesCountForTesting(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_imagePendingDecodePromisesCountForTesting, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_imagePendingDecodePromisesCountForTestingBody>(*lexicalGlobalObject, *callFrame, "imagePendingDecodePromisesCountForTesting");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setClearDecoderAfterAsyncFrameRequestForTestingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLImageElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "setClearDecoderAfterAsyncFrameRequestForTesting"_s, "HTMLImageElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto enabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (enabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setClearDecoderAfterAsyncFrameRequestForTesting(*elementConversionResult.releaseReturnValue(), enabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setClearDecoderAfterAsyncFrameRequestForTesting, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setClearDecoderAfterAsyncFrameRequestForTestingBody>(*lexicalGlobalObject, *callFrame, "setClearDecoderAfterAsyncFrameRequestForTesting");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_imageDecodeCountBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLImageElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "imageDecodeCount"_s, "HTMLImageElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.imageDecodeCount(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_imageDecodeCount, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_imageDecodeCountBody>(*lexicalGlobalObject, *callFrame, "imageDecodeCount");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_imageBlankDrawCountBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLImageElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "imageBlankDrawCount"_s, "HTMLImageElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.imageBlankDrawCount(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_imageBlankDrawCount, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_imageBlankDrawCountBody>(*lexicalGlobalObject, *callFrame, "imageBlankDrawCount");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_imageLastDecodingOptionsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLImageElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "imageLastDecodingOptions"_s, "HTMLImageElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.imageLastDecodingOptions(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_imageLastDecodingOptions, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_imageLastDecodingOptionsBody>(*lexicalGlobalObject, *callFrame, "imageLastDecodingOptions");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_imageCachedSubimageCreateCountBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLImageElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "imageCachedSubimageCreateCount"_s, "HTMLImageElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.imageCachedSubimageCreateCount(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_imageCachedSubimageCreateCount, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_imageCachedSubimageCreateCountBody>(*lexicalGlobalObject, *callFrame, "imageCachedSubimageCreateCount");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_remoteImagesCountForTestingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.remoteImagesCountForTesting())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_remoteImagesCountForTesting, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_remoteImagesCountForTestingBody>(*lexicalGlobalObject, *callFrame, "remoteImagesCountForTesting");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setAsyncDecodingEnabledForTestingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLImageElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "setAsyncDecodingEnabledForTesting"_s, "HTMLImageElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto enabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (enabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setAsyncDecodingEnabledForTesting(*elementConversionResult.releaseReturnValue(), enabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setAsyncDecodingEnabledForTesting, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setAsyncDecodingEnabledForTestingBody>(*lexicalGlobalObject, *callFrame, "setAsyncDecodingEnabledForTesting");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setForceUpdateImageDataEnabledForTestingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLImageElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "setForceUpdateImageDataEnabledForTesting"_s, "HTMLImageElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto enabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (enabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setForceUpdateImageDataEnabledForTesting(*elementConversionResult.releaseReturnValue(), enabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setForceUpdateImageDataEnabledForTesting, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setForceUpdateImageDataEnabledForTestingBody>(*lexicalGlobalObject, *callFrame, "setForceUpdateImageDataEnabledForTesting");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setHasHDRContentForTestingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLImageElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "setHasHDRContentForTesting"_s, "HTMLImageElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setHasHDRContentForTesting(*elementConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setHasHDRContentForTesting, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setHasHDRContentForTestingBody>(*lexicalGlobalObject, *callFrame, "setHasHDRContentForTesting");
}

#if ENABLE(WEB_CODECS)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_hasPendingActivityBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto decoderConversionResult = convert<IDLInterface<WebCodecsVideoDecoder>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "decoder"_s, "Internals"_s, "hasPendingActivity"_s, "WebCodecsVideoDecoder"_s); });
    if (decoderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.hasPendingActivity(*decoderConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasPendingActivity, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_hasPendingActivityBody>(*lexicalGlobalObject, *callFrame, "hasPendingActivity");
}

#endif

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setGridMaxTracksLimitBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto maxTracksLimitConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (maxTracksLimitConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setGridMaxTracksLimit(maxTracksLimitConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setGridMaxTracksLimit, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setGridMaxTracksLimitBody>(*lexicalGlobalObject, *callFrame, "setGridMaxTracksLimit");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_svgAnimationsIntervalBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<SVGSVGElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "svgAnimationsInterval"_s, "SVGSVGElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDouble>(*lexicalGlobalObject, throwScope, impl.svgAnimationsInterval(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_svgAnimationsInterval, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_svgAnimationsIntervalBody>(*lexicalGlobalObject, *callFrame, "svgAnimationsInterval");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_allSVGSVGElementsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLSequence<IDLInterface<SVGSVGElement>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.allSVGSVGElements())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_allSVGSVGElements, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_allSVGSVGElementsBody>(*lexicalGlobalObject, *callFrame, "allSVGSVGElements");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_testProcessIncomingSyncMessagesWhenWaitingForSyncReplyBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.testProcessIncomingSyncMessagesWhenWaitingForSyncReply())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_testProcessIncomingSyncMessagesWhenWaitingForSyncReply, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_testProcessIncomingSyncMessagesWhenWaitingForSyncReplyBody>(*lexicalGlobalObject, *callFrame, "testProcessIncomingSyncMessagesWhenWaitingForSyncReply");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setResourceCachingDisabledByWebInspectorBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto disabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (disabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setResourceCachingDisabledByWebInspector(disabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setResourceCachingDisabledByWebInspector, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setResourceCachingDisabledByWebInspectorBody>(*lexicalGlobalObject, *callFrame, "setResourceCachingDisabledByWebInspector");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_lowerAllFrameMemoryMonitorLimitsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.lowerAllFrameMemoryMonitorLimits(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_lowerAllFrameMemoryMonitorLimits, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_lowerAllFrameMemoryMonitorLimitsBody>(*lexicalGlobalObject, *callFrame, "lowerAllFrameMemoryMonitorLimits");
}

#if ENABLE(DAMAGE_TRACKING)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_getFrameDamageHistoryBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLSequence<IDLDictionary<Internals::FrameDamage>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getFrameDamageHistory())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_getFrameDamageHistory, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_getFrameDamageHistoryBody>(*lexicalGlobalObject, *callFrame, "getFrameDamageHistory");
}

#endif

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_layerTreeAsTextBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto documentConversionResult = convert<IDLInterface<Document>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "document"_s, "Internals"_s, "layerTreeAsText"_s, "Document"_s); });
    if (documentConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->argument(1);
    auto flagsConversionResult = convert<IDLUnsignedShort>(*lexicalGlobalObject, argument1.value());
    if (flagsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.layerTreeAsText(*documentConversionResult.releaseReturnValue(), flagsConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_layerTreeAsText, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_layerTreeAsTextBody>(*lexicalGlobalObject, *callFrame, "layerTreeAsText");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_layerIDForElementBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "layerIDForElement"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLongLong>(*lexicalGlobalObject, throwScope, impl.layerIDForElement(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_layerIDForElement, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_layerIDForElementBody>(*lexicalGlobalObject, *callFrame, "layerIDForElement");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_horizontalScrollbarLayerIDBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->argument(0);
    auto nodeConversionResult = convert<IDLNullable<IDLInterface<Node>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "node"_s, "Internals"_s, "horizontalScrollbarLayerID"_s, "Node"_s); });
    if (nodeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLongLong>(*lexicalGlobalObject, throwScope, impl.horizontalScrollbarLayerID(nodeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_horizontalScrollbarLayerID, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_horizontalScrollbarLayerIDBody>(*lexicalGlobalObject, *callFrame, "horizontalScrollbarLayerID");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_verticalScrollbarLayerIDBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->argument(0);
    auto nodeConversionResult = convert<IDLNullable<IDLInterface<Node>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "node"_s, "Internals"_s, "verticalScrollbarLayerID"_s, "Node"_s); });
    if (nodeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLongLong>(*lexicalGlobalObject, throwScope, impl.verticalScrollbarLayerID(nodeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_verticalScrollbarLayerID, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_verticalScrollbarLayerIDBody>(*lexicalGlobalObject, *callFrame, "verticalScrollbarLayerID");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_scrollingNodeIDForNodeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->argument(0);
    auto nodeConversionResult = convert<IDLNullable<IDLInterface<Node>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "node"_s, "Internals"_s, "scrollingNodeIDForNode"_s, "Node"_s); });
    if (nodeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLSequence<IDLUnsignedLongLong>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.scrollingNodeIDForNode(nodeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_scrollingNodeIDForNode, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_scrollingNodeIDForNodeBody>(*lexicalGlobalObject, *callFrame, "scrollingNodeIDForNode");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_platformLayerTreeAsTextBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "platformLayerTreeAsText"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->argument(1);
    auto flagsConversionResult = convert<IDLUnsignedShort>(*lexicalGlobalObject, argument1.value());
    if (flagsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.platformLayerTreeAsText(*elementConversionResult.releaseReturnValue(), flagsConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_platformLayerTreeAsText, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_platformLayerTreeAsTextBody>(*lexicalGlobalObject, *callFrame, "platformLayerTreeAsText");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_scrollbarOverlayStyleBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->argument(0);
    auto nodeConversionResult = convert<IDLNullable<IDLInterface<Node>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "node"_s, "Internals"_s, "scrollbarOverlayStyle"_s, "Node"_s); });
    if (nodeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.scrollbarOverlayStyle(nodeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_scrollbarOverlayStyle, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_scrollbarOverlayStyleBody>(*lexicalGlobalObject, *callFrame, "scrollbarOverlayStyle");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_scrollbarUsingDarkAppearanceBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->argument(0);
    auto nodeConversionResult = convert<IDLNullable<IDLInterface<Node>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "node"_s, "Internals"_s, "scrollbarUsingDarkAppearance"_s, "Node"_s); });
    if (nodeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.scrollbarUsingDarkAppearance(nodeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_scrollbarUsingDarkAppearance, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_scrollbarUsingDarkAppearanceBody>(*lexicalGlobalObject, *callFrame, "scrollbarUsingDarkAppearance");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_horizontalScrollbarStateBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->argument(0);
    auto nodeConversionResult = convert<IDLNullable<IDLInterface<Node>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "node"_s, "Internals"_s, "horizontalScrollbarState"_s, "Node"_s); });
    if (nodeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.horizontalScrollbarState(nodeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_horizontalScrollbarState, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_horizontalScrollbarStateBody>(*lexicalGlobalObject, *callFrame, "horizontalScrollbarState");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_verticalScrollbarStateBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->argument(0);
    auto nodeConversionResult = convert<IDLNullable<IDLInterface<Node>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "node"_s, "Internals"_s, "verticalScrollbarState"_s, "Node"_s); });
    if (nodeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.verticalScrollbarState(nodeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_verticalScrollbarState, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_verticalScrollbarStateBody>(*lexicalGlobalObject, *callFrame, "verticalScrollbarState");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_scrollbarsControllerTypeForNodeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->argument(0);
    auto nodeConversionResult = convert<IDLNullable<IDLInterface<Node>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "node"_s, "Internals"_s, "scrollbarsControllerTypeForNode"_s, "Node"_s); });
    if (nodeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.scrollbarsControllerTypeForNode(nodeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_scrollbarsControllerTypeForNode, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_scrollbarsControllerTypeForNodeBody>(*lexicalGlobalObject, *callFrame, "scrollbarsControllerTypeForNode");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_scrollingStateTreeAsTextBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.scrollingStateTreeAsText())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_scrollingStateTreeAsText, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_scrollingStateTreeAsTextBody>(*lexicalGlobalObject, *callFrame, "scrollingStateTreeAsText");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_scrollingTreeAsTextBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.scrollingTreeAsText())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_scrollingTreeAsText, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_scrollingTreeAsTextBody>(*lexicalGlobalObject, *callFrame, "scrollingTreeAsText");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_haveScrollingTreeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.haveScrollingTree())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_haveScrollingTree, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_haveScrollingTreeBody>(*lexicalGlobalObject, *callFrame, "haveScrollingTree");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_synchronousScrollingReasonsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.synchronousScrollingReasons())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_synchronousScrollingReasons, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_synchronousScrollingReasonsBody>(*lexicalGlobalObject, *callFrame, "synchronousScrollingReasons");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_nonFastScrollableRectsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<DOMRectList>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.nonFastScrollableRects())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_nonFastScrollableRects, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_nonFastScrollableRectsBody>(*lexicalGlobalObject, *callFrame, "nonFastScrollableRects");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_repaintRectsAsTextBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.repaintRectsAsText())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_repaintRectsAsText, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_repaintRectsAsTextBody>(*lexicalGlobalObject, *callFrame, "repaintRectsAsText");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setElementUsesDisplayListDrawingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "setElementUsesDisplayListDrawing"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto usesDisplayListDrawingConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (usesDisplayListDrawingConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setElementUsesDisplayListDrawing(*elementConversionResult.releaseReturnValue(), usesDisplayListDrawingConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setElementUsesDisplayListDrawing, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setElementUsesDisplayListDrawingBody>(*lexicalGlobalObject, *callFrame, "setElementUsesDisplayListDrawing");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setElementTracksDisplayListReplayBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "setElementTracksDisplayListReplay"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto trackReplayConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (trackReplayConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setElementTracksDisplayListReplay(*elementConversionResult.releaseReturnValue(), trackReplayConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setElementTracksDisplayListReplay, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setElementTracksDisplayListReplayBody>(*lexicalGlobalObject, *callFrame, "setElementTracksDisplayListReplay");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_displayListForElementBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "displayListForElement"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->argument(1);
    auto flagsConversionResult = convert<IDLUnsignedShort>(*lexicalGlobalObject, argument1.value());
    if (flagsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.displayListForElement(*elementConversionResult.releaseReturnValue(), flagsConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_displayListForElement, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_displayListForElementBody>(*lexicalGlobalObject, *callFrame, "displayListForElement");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_replayDisplayListForElementBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "replayDisplayListForElement"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->argument(1);
    auto flagsConversionResult = convert<IDLUnsignedShort>(*lexicalGlobalObject, argument1.value());
    if (flagsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.replayDisplayListForElement(*elementConversionResult.releaseReturnValue(), flagsConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_replayDisplayListForElement, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_replayDisplayListForElementBody>(*lexicalGlobalObject, *callFrame, "replayDisplayListForElement");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setForceUseGlyphDisplayListForTestingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto enabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (enabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setForceUseGlyphDisplayListForTesting(enabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setForceUseGlyphDisplayListForTesting, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setForceUseGlyphDisplayListForTestingBody>(*lexicalGlobalObject, *callFrame, "setForceUseGlyphDisplayListForTesting");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_cachedGlyphDisplayListsForTextNodeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto nodeConversionResult = convert<IDLInterface<Node>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "node"_s, "Internals"_s, "cachedGlyphDisplayListsForTextNode"_s, "Node"_s); });
    if (nodeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->argument(1);
    auto flagsConversionResult = convert<IDLUnsignedShort>(*lexicalGlobalObject, argument1.value());
    if (flagsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.cachedGlyphDisplayListsForTextNode(*nodeConversionResult.releaseReturnValue(), flagsConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_cachedGlyphDisplayListsForTextNode, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_cachedGlyphDisplayListsForTextNodeBody>(*lexicalGlobalObject, *callFrame, "cachedGlyphDisplayListsForTextNode");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_clearGlyphDisplayListCacheForTestingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.clearGlyphDisplayListCacheForTesting(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_clearGlyphDisplayListCacheForTesting, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_clearGlyphDisplayListCacheForTestingBody>(*lexicalGlobalObject, *callFrame, "clearGlyphDisplayListCacheForTesting");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_garbageCollectDocumentResourcesBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.garbageCollectDocumentResources(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_garbageCollectDocumentResources, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_garbageCollectDocumentResourcesBody>(*lexicalGlobalObject, *callFrame, "garbageCollectDocumentResources");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_insertAuthorCSSBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto cssConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (cssConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.insertAuthorCSS(cssConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_insertAuthorCSS, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_insertAuthorCSSBody>(*lexicalGlobalObject, *callFrame, "insertAuthorCSS");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_insertUserCSSBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto cssConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (cssConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.insertUserCSS(cssConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_insertUserCSS, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_insertUserCSSBody>(*lexicalGlobalObject, *callFrame, "insertUserCSS");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_beginSimulatedMemoryWarningBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.beginSimulatedMemoryWarning(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_beginSimulatedMemoryWarning, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_beginSimulatedMemoryWarningBody>(*lexicalGlobalObject, *callFrame, "beginSimulatedMemoryWarning");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_endSimulatedMemoryWarningBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.endSimulatedMemoryWarning(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_endSimulatedMemoryWarning, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_endSimulatedMemoryWarningBody>(*lexicalGlobalObject, *callFrame, "endSimulatedMemoryWarning");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_beginSimulatedMemoryPressureBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.beginSimulatedMemoryPressure(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_beginSimulatedMemoryPressure, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_beginSimulatedMemoryPressureBody>(*lexicalGlobalObject, *callFrame, "beginSimulatedMemoryPressure");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_endSimulatedMemoryPressureBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.endSimulatedMemoryPressure(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_endSimulatedMemoryPressure, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_endSimulatedMemoryPressureBody>(*lexicalGlobalObject, *callFrame, "endSimulatedMemoryPressure");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_numberOfIDBTransactionsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.numberOfIDBTransactions())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_numberOfIDBTransactions, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_numberOfIDBTransactionsBody>(*lexicalGlobalObject, *callFrame, "numberOfIDBTransactions");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_scrollableAreaWidthBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto nodeConversionResult = convert<IDLInterface<Node>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "node"_s, "Internals"_s, "scrollableAreaWidth"_s, "Node"_s); });
    if (nodeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.scrollableAreaWidth(*nodeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_scrollableAreaWidth, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_scrollableAreaWidthBody>(*lexicalGlobalObject, *callFrame, "scrollableAreaWidth");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_numberOfLiveNodesBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.numberOfLiveNodes())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_numberOfLiveNodes, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_numberOfLiveNodesBody>(*lexicalGlobalObject, *callFrame, "numberOfLiveNodes");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_numberOfLiveDocumentsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.numberOfLiveDocuments())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_numberOfLiveDocuments, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_numberOfLiveDocumentsBody>(*lexicalGlobalObject, *callFrame, "numberOfLiveDocuments");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_referencingNodeCountBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto documentConversionResult = convert<IDLInterface<Document>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "document"_s, "Internals"_s, "referencingNodeCount"_s, "Document"_s); });
    if (documentConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.referencingNodeCount(*documentConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_referencingNodeCount, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_referencingNodeCountBody>(*lexicalGlobalObject, *callFrame, "referencingNodeCount");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_executeOpportunisticallyScheduledTasksBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.executeOpportunisticallyScheduledTasks(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_executeOpportunisticallyScheduledTasks, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_executeOpportunisticallyScheduledTasksBody>(*lexicalGlobalObject, *callFrame, "executeOpportunisticallyScheduledTasks");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_numberOfIntersectionObserversBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto documentConversionResult = convert<IDLInterface<Document>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "document"_s, "Internals"_s, "numberOfIntersectionObservers"_s, "Document"_s); });
    if (documentConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.numberOfIntersectionObservers(*documentConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_numberOfIntersectionObservers, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_numberOfIntersectionObserversBody>(*lexicalGlobalObject, *callFrame, "numberOfIntersectionObservers");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_numberOfResizeObserversBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto documentConversionResult = convert<IDLInterface<Document>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "document"_s, "Internals"_s, "numberOfResizeObservers"_s, "Document"_s); });
    if (documentConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.numberOfResizeObservers(*documentConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_numberOfResizeObservers, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_numberOfResizeObserversBody>(*lexicalGlobalObject, *callFrame, "numberOfResizeObservers");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_openDummyInspectorFrontendBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto urlConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (urlConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLInterface<WindowProxy>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.openDummyInspectorFrontend(urlConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_openDummyInspectorFrontend, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_openDummyInspectorFrontendBody>(*lexicalGlobalObject, *callFrame, "openDummyInspectorFrontend");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_closeDummyInspectorFrontendBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.closeDummyInspectorFrontend(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_closeDummyInspectorFrontend, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_closeDummyInspectorFrontendBody>(*lexicalGlobalObject, *callFrame, "closeDummyInspectorFrontend");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setInspectorIsUnderTestBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto isUnderTestConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (isUnderTestConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setInspectorIsUnderTest(isUnderTestConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setInspectorIsUnderTest, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setInspectorIsUnderTestBody>(*lexicalGlobalObject, *callFrame, "setInspectorIsUnderTest");
}

#if ENABLE(WEB_AUDIO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_baseAudioContextIdentifierBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto contextConversionResult = convert<IDLInterface<BaseAudioContext>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "context"_s, "Internals"_s, "baseAudioContextIdentifier"_s, "BaseAudioContext"_s); });
    if (contextConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLongLong>(*lexicalGlobalObject, throwScope, impl.baseAudioContextIdentifier(*contextConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_baseAudioContextIdentifier, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_baseAudioContextIdentifierBody>(*lexicalGlobalObject, *callFrame, "baseAudioContextIdentifier");
}

#endif

#if ENABLE(WEB_AUDIO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isBaseAudioContextAliveBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto contextIDConversionResult = convert<IDLUnsignedLongLong>(*lexicalGlobalObject, argument0.value());
    if (contextIDConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isBaseAudioContextAlive(contextIDConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isBaseAudioContextAlive, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isBaseAudioContextAliveBody>(*lexicalGlobalObject, *callFrame, "isBaseAudioContextAlive");
}

#endif

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_counterValueBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "counterValue"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.counterValue(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_counterValue, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_counterValueBody>(*lexicalGlobalObject, *callFrame, "counterValue");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_pageNumberBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "pageNumber"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->argument(1);
    auto pageWidthConversionResult = convertOptionalWithDefault<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument1.value(), [&]() -> ConversionResult<IDLUnrestrictedFloat> { return Converter<IDLUnrestrictedFloat>::ReturnType { 800 }; });
    if (pageWidthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->argument(2);
    auto pageHeightConversionResult = convertOptionalWithDefault<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument2.value(), [&]() -> ConversionResult<IDLUnrestrictedFloat> { return Converter<IDLUnrestrictedFloat>::ReturnType { 600 }; });
    if (pageHeightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLLong>(*lexicalGlobalObject, throwScope, impl.pageNumber(*elementConversionResult.releaseReturnValue(), pageWidthConversionResult.releaseReturnValue(), pageHeightConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_pageNumber, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_pageNumberBody>(*lexicalGlobalObject, *callFrame, "pageNumber");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_shortcutIconURLsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLSequence<IDLDOMString>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.shortcutIconURLs())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_shortcutIconURLs, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_shortcutIconURLsBody>(*lexicalGlobalObject, *callFrame, "shortcutIconURLs");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_numberOfPagesBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->argument(0);
    auto pageWidthInPixelsConversionResult = convertOptionalWithDefault<IDLUnrestrictedDouble>(*lexicalGlobalObject, argument0.value(), [&]() -> ConversionResult<IDLUnrestrictedDouble> { return Converter<IDLUnrestrictedDouble>::ReturnType { 800 }; });
    if (pageWidthInPixelsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->argument(1);
    auto pageHeightInPixelsConversionResult = convertOptionalWithDefault<IDLUnrestrictedDouble>(*lexicalGlobalObject, argument1.value(), [&]() -> ConversionResult<IDLUnrestrictedDouble> { return Converter<IDLUnrestrictedDouble>::ReturnType { 600 }; });
    if (pageHeightInPixelsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLLong>(*lexicalGlobalObject, throwScope, impl.numberOfPages(pageWidthInPixelsConversionResult.releaseReturnValue(), pageHeightInPixelsConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_numberOfPages, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_numberOfPagesBody>(*lexicalGlobalObject, *callFrame, "numberOfPages");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_pagePropertyBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto propertyNameConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (propertyNameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto pageNumberConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (pageNumberConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.pageProperty(propertyNameConversionResult.releaseReturnValue(), pageNumberConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_pageProperty, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_pagePropertyBody>(*lexicalGlobalObject, *callFrame, "pageProperty");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_pageSizeAndMarginsInPixelsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 7) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto pageIndexConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument0.value());
    if (pageIndexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto marginTopConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (marginTopConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto marginRightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (marginRightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto marginBottomConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (marginBottomConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto marginLeftConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument6.value());
    if (marginLeftConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.pageSizeAndMarginsInPixels(pageIndexConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), marginTopConversionResult.releaseReturnValue(), marginRightConversionResult.releaseReturnValue(), marginBottomConversionResult.releaseReturnValue(), marginLeftConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_pageSizeAndMarginsInPixels, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_pageSizeAndMarginsInPixelsBody>(*lexicalGlobalObject, *callFrame, "pageSizeAndMarginsInPixels");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_pageScaleFactorBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLFloat>(*lexicalGlobalObject, throwScope, impl.pageScaleFactor())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_pageScaleFactor, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_pageScaleFactorBody>(*lexicalGlobalObject, *callFrame, "pageScaleFactor");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setPageZoomFactorBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto zoomFactorConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument0.value());
    if (zoomFactorConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setPageZoomFactor(zoomFactorConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPageZoomFactor, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setPageZoomFactorBody>(*lexicalGlobalObject, *callFrame, "setPageZoomFactor");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setTextZoomFactorBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto zoomFactorConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument0.value());
    if (zoomFactorConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setTextZoomFactor(zoomFactorConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setTextZoomFactor, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setTextZoomFactorBody>(*lexicalGlobalObject, *callFrame, "setTextZoomFactor");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setUseFixedLayoutBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto useFixedLayoutConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (useFixedLayoutConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setUseFixedLayout(useFixedLayoutConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setUseFixedLayout, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setUseFixedLayoutBody>(*lexicalGlobalObject, *callFrame, "setUseFixedLayout");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setFixedLayoutSizeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument0.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setFixedLayoutSize(widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setFixedLayoutSize, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setFixedLayoutSizeBody>(*lexicalGlobalObject, *callFrame, "setFixedLayoutSize");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setPrintingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument0.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setPrinting(widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPrinting, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setPrintingBody>(*lexicalGlobalObject, *callFrame, "setPrinting");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setViewExposedRectBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto xConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument0.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto yConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument1.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto widthConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument2.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto heightConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument3.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setViewExposedRect(xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setViewExposedRect, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setViewExposedRectBody>(*lexicalGlobalObject, *callFrame, "setViewExposedRect");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setHeaderHeightBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto heightConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument0.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setHeaderHeight(heightConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setHeaderHeight, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setHeaderHeightBody>(*lexicalGlobalObject, *callFrame, "setHeaderHeight");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setFooterHeightBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto heightConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument0.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setFooterHeight(heightConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setFooterHeight, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setFooterHeightBody>(*lexicalGlobalObject, *callFrame, "setFooterHeight");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setFullscreenInsetsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto insetsConversionResult = convert<IDLDictionary<Internals::FullscreenInsets>>(*lexicalGlobalObject, argument0.value());
    if (insetsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setFullscreenInsets(insetsConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setFullscreenInsets, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setFullscreenInsetsBody>(*lexicalGlobalObject, *callFrame, "setFullscreenInsets");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setFullscreenAutoHideDurationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto durationConversionResult = convert<IDLDouble>(*lexicalGlobalObject, argument0.value());
    if (durationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setFullscreenAutoHideDuration(durationConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setFullscreenAutoHideDuration, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setFullscreenAutoHideDurationBody>(*lexicalGlobalObject, *callFrame, "setFullscreenAutoHideDuration");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setScreenContentsFormatsForTestingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto contentsFormatsConversionResult = convert<IDLSequence<IDLEnumeration<Internals::ContentsFormat>>>(*lexicalGlobalObject, argument0.value());
    if (contentsFormatsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setScreenContentsFormatsForTesting(contentsFormatsConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setScreenContentsFormatsForTesting, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setScreenContentsFormatsForTestingBody>(*lexicalGlobalObject, *callFrame, "setScreenContentsFormatsForTesting");
}

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isChangingPresentationModeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLVideoElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "isChangingPresentationMode"_s, "HTMLVideoElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isChangingPresentationMode(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isChangingPresentationMode, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isChangingPresentationModeBody>(*lexicalGlobalObject, *callFrame, "isChangingPresentationMode");
}

#endif

#if ENABLE(VIDEO_PRESENTATION_MODE)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setMockVideoPresentationModeEnabledBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto enabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (enabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setMockVideoPresentationModeEnabled(enabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMockVideoPresentationModeEnabled, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setMockVideoPresentationModeEnabledBody>(*lexicalGlobalObject, *callFrame, "setMockVideoPresentationModeEnabled");
}

#endif

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setApplicationCacheOriginQuotaBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto quotaConversionResult = convert<IDLUnsignedLongLong>(*lexicalGlobalObject, argument0.value());
    if (quotaConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setApplicationCacheOriginQuota(quotaConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setApplicationCacheOriginQuota, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setApplicationCacheOriginQuotaBody>(*lexicalGlobalObject, *callFrame, "setApplicationCacheOriginQuota");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_registerURLSchemeAsBypassingContentSecurityPolicyBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto schemeConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (schemeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.registerURLSchemeAsBypassingContentSecurityPolicy(schemeConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_registerURLSchemeAsBypassingContentSecurityPolicy, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_registerURLSchemeAsBypassingContentSecurityPolicyBody>(*lexicalGlobalObject, *callFrame, "registerURLSchemeAsBypassingContentSecurityPolicy");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_removeURLSchemeRegisteredAsBypassingContentSecurityPolicyBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto schemeConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (schemeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.removeURLSchemeRegisteredAsBypassingContentSecurityPolicy(schemeConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_removeURLSchemeRegisteredAsBypassingContentSecurityPolicy, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_removeURLSchemeRegisteredAsBypassingContentSecurityPolicyBody>(*lexicalGlobalObject, *callFrame, "removeURLSchemeRegisteredAsBypassingContentSecurityPolicy");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_registerDefaultPortForProtocolBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto portConversionResult = convert<IDLUnsignedShort>(*lexicalGlobalObject, argument0.value());
    if (portConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto schemeConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (schemeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.registerDefaultPortForProtocol(portConversionResult.releaseReturnValue(), schemeConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_registerDefaultPortForProtocol, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_registerDefaultPortForProtocolBody>(*lexicalGlobalObject, *callFrame, "registerDefaultPortForProtocol");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_mallocStatisticsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<MallocStatistics>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.mallocStatistics())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_mallocStatistics, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_mallocStatisticsBody>(*lexicalGlobalObject, *callFrame, "mallocStatistics");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_typeConversionsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<TypeConversions>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.typeConversions())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_typeConversions, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_typeConversionsBody>(*lexicalGlobalObject, *callFrame, "typeConversions");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_memoryInfoBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<MemoryInfo>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.memoryInfo())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_memoryInfo, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_memoryInfoBody>(*lexicalGlobalObject, *callFrame, "memoryInfo");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_getReferencedFilePathsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLSequence<IDLDOMString>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getReferencedFilePaths())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_getReferencedFilePaths, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_getReferencedFilePathsBody>(*lexicalGlobalObject, *callFrame, "getReferencedFilePaths");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_startTrackingRepaintsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.startTrackingRepaints(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_startTrackingRepaints, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_startTrackingRepaintsBody>(*lexicalGlobalObject, *callFrame, "startTrackingRepaints");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_stopTrackingRepaintsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.stopTrackingRepaints(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_stopTrackingRepaints, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_stopTrackingRepaintsBody>(*lexicalGlobalObject, *callFrame, "stopTrackingRepaints");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_startTrackingLayerFlushesBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.startTrackingLayerFlushes(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_startTrackingLayerFlushes, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_startTrackingLayerFlushesBody>(*lexicalGlobalObject, *callFrame, "startTrackingLayerFlushes");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_layerFlushCountBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.layerFlushCount())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_layerFlushCount, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_layerFlushCountBody>(*lexicalGlobalObject, *callFrame, "layerFlushCount");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setCanvasNoiseInjectionSaltBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLCanvasElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "setCanvasNoiseInjectionSalt"_s, "HTMLCanvasElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto saltConversionResult = convert<IDLUnsignedLongLong>(*lexicalGlobalObject, argument1.value());
    if (saltConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setCanvasNoiseInjectionSalt(*elementConversionResult.releaseReturnValue(), saltConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setCanvasNoiseInjectionSalt, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setCanvasNoiseInjectionSaltBody>(*lexicalGlobalObject, *callFrame, "setCanvasNoiseInjectionSalt");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_doesCanvasHavePendingCanvasNoiseInjectionBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLCanvasElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "doesCanvasHavePendingCanvasNoiseInjection"_s, "HTMLCanvasElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.doesCanvasHavePendingCanvasNoiseInjection(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_doesCanvasHavePendingCanvasNoiseInjection, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_doesCanvasHavePendingCanvasNoiseInjectionBody>(*lexicalGlobalObject, *callFrame, "doesCanvasHavePendingCanvasNoiseInjection");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isTimerThrottledBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto timerHandleConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument0.value());
    if (timerHandleConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isTimerThrottled(timerHandleConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isTimerThrottled, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isTimerThrottledBody>(*lexicalGlobalObject, *callFrame, "isTimerThrottled");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_requestAnimationFrameThrottlingReasonsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.requestAnimationFrameThrottlingReasons())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_requestAnimationFrameThrottlingReasons, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_requestAnimationFrameThrottlingReasonsBody>(*lexicalGlobalObject, *callFrame, "requestAnimationFrameThrottlingReasons");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_areTimersThrottledBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.areTimersThrottled())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_areTimersThrottled, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_areTimersThrottledBody>(*lexicalGlobalObject, *callFrame, "areTimersThrottled");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setLowPowerModeEnabledBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto enabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (enabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setLowPowerModeEnabled(enabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setLowPowerModeEnabled, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setLowPowerModeEnabledBody>(*lexicalGlobalObject, *callFrame, "setLowPowerModeEnabled");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setAggressiveThermalMitigationEnabledBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto enabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (enabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setAggressiveThermalMitigationEnabled(enabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setAggressiveThermalMitigationEnabled, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setAggressiveThermalMitigationEnabledBody>(*lexicalGlobalObject, *callFrame, "setAggressiveThermalMitigationEnabled");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setOutsideViewportThrottlingEnabledBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto enabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (enabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setOutsideViewportThrottlingEnabled(enabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setOutsideViewportThrottlingEnabled, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setOutsideViewportThrottlingEnabledBody>(*lexicalGlobalObject, *callFrame, "setOutsideViewportThrottlingEnabled");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_startTrackingStyleRecalcsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.startTrackingStyleRecalcs(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_startTrackingStyleRecalcs, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_startTrackingStyleRecalcsBody>(*lexicalGlobalObject, *callFrame, "startTrackingStyleRecalcs");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_styleRecalcCountBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.styleRecalcCount())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_styleRecalcCount, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_styleRecalcCountBody>(*lexicalGlobalObject, *callFrame, "styleRecalcCount");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_startTrackingLayoutUpdatesBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.startTrackingLayoutUpdates(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_startTrackingLayoutUpdates, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_startTrackingLayoutUpdatesBody>(*lexicalGlobalObject, *callFrame, "startTrackingLayoutUpdates");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_layoutUpdateCountBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.layoutUpdateCount())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_layoutUpdateCount, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_layoutUpdateCountBody>(*lexicalGlobalObject, *callFrame, "layoutUpdateCount");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_startTrackingRenderLayerPositionUpdatesBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.startTrackingRenderLayerPositionUpdates(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_startTrackingRenderLayerPositionUpdates, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_startTrackingRenderLayerPositionUpdatesBody>(*lexicalGlobalObject, *callFrame, "startTrackingRenderLayerPositionUpdates");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_renderLayerPositionUpdateCountBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.renderLayerPositionUpdateCount())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_renderLayerPositionUpdateCount, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_renderLayerPositionUpdateCountBody>(*lexicalGlobalObject, *callFrame, "renderLayerPositionUpdateCount");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_startTrackingCompositingUpdatesBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.startTrackingCompositingUpdates(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_startTrackingCompositingUpdates, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_startTrackingCompositingUpdatesBody>(*lexicalGlobalObject, *callFrame, "startTrackingCompositingUpdates");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_compositingUpdateCountBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.compositingUpdateCount())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_compositingUpdateCount, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_compositingUpdateCountBody>(*lexicalGlobalObject, *callFrame, "compositingUpdateCount");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_startTrackingRenderingUpdatesBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.startTrackingRenderingUpdates(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_startTrackingRenderingUpdates, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_startTrackingRenderingUpdatesBody>(*lexicalGlobalObject, *callFrame, "startTrackingRenderingUpdates");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_renderingUpdateCountBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.renderingUpdateCount())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_renderingUpdateCount, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_renderingUpdateCountBody>(*lexicalGlobalObject, *callFrame, "renderingUpdateCount");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_updateLayoutAndStyleForAllFramesBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.updateLayoutAndStyleForAllFrames(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_updateLayoutAndStyleForAllFrames, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_updateLayoutAndStyleForAllFramesBody>(*lexicalGlobalObject, *callFrame, "updateLayoutAndStyleForAllFrames");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasksBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->argument(0);
    auto nodeConversionResult = convert<IDLNullable<IDLInterface<Node>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "node"_s, "Internals"_s, "updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasks"_s, "Node"_s); });
    if (nodeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasks(nodeConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasks, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasksBody>(*lexicalGlobalObject, *callFrame, "updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasks");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_getCurrentCursorInfoBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.getCurrentCursorInfo())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_getCurrentCursorInfo, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_getCurrentCursorInfoBody>(*lexicalGlobalObject, *callFrame, "getCurrentCursorInfo");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_markerTextForListItemBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "markerTextForListItem"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.markerTextForListItem(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_markerTextForListItem, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_markerTextForListItemBody>(*lexicalGlobalObject, *callFrame, "markerTextForListItem");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_toolTipFromElementBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "toolTipFromElement"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.toolTipFromElement(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_toolTipFromElement, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_toolTipFromElementBody>(*lexicalGlobalObject, *callFrame, "toolTipFromElement");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_deserializeBufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto bufferConversionResult = convert<IDLArrayBuffer>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "buffer"_s, "Internals"_s, "deserializeBuffer"_s, "ArrayBuffer"_s); });
    if (bufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLSerializedScriptValue<SerializedScriptValue>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.deserializeBuffer(bufferConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_deserializeBuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_deserializeBufferBody>(*lexicalGlobalObject, *callFrame, "deserializeBuffer");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_serializeObjectBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto objectConversionResult = convert<IDLSerializedScriptValue<SerializedScriptValue>>(*lexicalGlobalObject, argument0.value());
    if (objectConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLArrayBuffer>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.serializeObject(objectConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_serializeObject, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_serializeObjectBody>(*lexicalGlobalObject, *callFrame, "serializeObject");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isFromCurrentWorldBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto objConversionResult = convert<IDLAny>(*lexicalGlobalObject, argument0.value());
    if (objConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isFromCurrentWorld(objConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isFromCurrentWorld, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isFromCurrentWorldBody>(*lexicalGlobalObject, *callFrame, "isFromCurrentWorld");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_evaluateInWorldIgnoringExceptionBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto nameConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (nameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto sourceConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (sourceConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLAny>(*lexicalGlobalObject, throwScope, impl.evaluateInWorldIgnoringException(nameConversionResult.releaseReturnValue(), sourceConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_evaluateInWorldIgnoringException, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_evaluateInWorldIgnoringExceptionBody>(*lexicalGlobalObject, *callFrame, "evaluateInWorldIgnoringException");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setUsesOverlayScrollbarsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto enabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (enabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setUsesOverlayScrollbars(enabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setUsesOverlayScrollbars, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setUsesOverlayScrollbarsBody>(*lexicalGlobalObject, *callFrame, "setUsesOverlayScrollbars");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_forceAXObjectCacheUpdateBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.forceAXObjectCacheUpdate(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_forceAXObjectCacheUpdate, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_forceAXObjectCacheUpdateBody>(*lexicalGlobalObject, *callFrame, "forceAXObjectCacheUpdate");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_forceReloadBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto endToEndConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (endToEndConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.forceReload(endToEndConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_forceReload, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_forceReloadBody>(*lexicalGlobalObject, *callFrame, "forceReload");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_reloadExpiredOnlyBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.reloadExpiredOnly(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_reloadExpiredOnly, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_reloadExpiredOnlyBody>(*lexicalGlobalObject, *callFrame, "reloadExpiredOnly");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_enableFixedWidthAutoSizeModeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto enabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (enabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.enableFixedWidthAutoSizeMode(enabledConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_enableFixedWidthAutoSizeMode, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_enableFixedWidthAutoSizeModeBody>(*lexicalGlobalObject, *callFrame, "enableFixedWidthAutoSizeMode");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_enableSizeToContentAutoSizeModeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto enabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (enabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.enableSizeToContentAutoSizeMode(enabledConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_enableSizeToContentAutoSizeMode, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_enableSizeToContentAutoSizeModeBody>(*lexicalGlobalObject, *callFrame, "enableSizeToContentAutoSizeMode");
}

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_mediaResponseSourcesBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto mediaConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "media"_s, "Internals"_s, "mediaResponseSources"_s, "HTMLMediaElement"_s); });
    if (mediaConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLSequence<IDLDOMString>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.mediaResponseSources(*mediaConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_mediaResponseSources, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_mediaResponseSourcesBody>(*lexicalGlobalObject, *callFrame, "mediaResponseSources");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_mediaResponseContentRangesBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto mediaConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "media"_s, "Internals"_s, "mediaResponseContentRanges"_s, "HTMLMediaElement"_s); });
    if (mediaConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLSequence<IDLDOMString>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.mediaResponseContentRanges(*mediaConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_mediaResponseContentRanges, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_mediaResponseContentRangesBody>(*lexicalGlobalObject, *callFrame, "mediaResponseContentRanges");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_simulateAudioInterruptionBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "simulateAudioInterruption"_s, "HTMLMediaElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.simulateAudioInterruption(*elementConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_simulateAudioInterruption, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_simulateAudioInterruptionBody>(*lexicalGlobalObject, *callFrame, "simulateAudioInterruption");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_mediaElementHasCharacteristicBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "mediaElementHasCharacteristic"_s, "HTMLMediaElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto characteristicConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (characteristicConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.mediaElementHasCharacteristic(*elementConversionResult.releaseReturnValue(), characteristicConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_mediaElementHasCharacteristic, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_mediaElementHasCharacteristicBody>(*lexicalGlobalObject, *callFrame, "mediaElementHasCharacteristic");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_beginSimulatedHDCPErrorBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto mediaConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "media"_s, "Internals"_s, "beginSimulatedHDCPError"_s, "HTMLMediaElement"_s); });
    if (mediaConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.beginSimulatedHDCPError(*mediaConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_beginSimulatedHDCPError, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_beginSimulatedHDCPErrorBody>(*lexicalGlobalObject, *callFrame, "beginSimulatedHDCPError");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_endSimulatedHDCPErrorBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto mediaConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "media"_s, "Internals"_s, "endSimulatedHDCPError"_s, "HTMLMediaElement"_s); });
    if (mediaConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.endSimulatedHDCPError(*mediaConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_endSimulatedHDCPError, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_endSimulatedHDCPErrorBody>(*lexicalGlobalObject, *callFrame, "endSimulatedHDCPError");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_mediaPlayerRenderingCanBeAcceleratedBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto mediaConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "media"_s, "Internals"_s, "mediaPlayerRenderingCanBeAccelerated"_s, "HTMLMediaElement"_s); });
    if (mediaConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.mediaPlayerRenderingCanBeAccelerated(*mediaConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_mediaPlayerRenderingCanBeAccelerated, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_mediaPlayerRenderingCanBeAcceleratedBody>(*lexicalGlobalObject, *callFrame, "mediaPlayerRenderingCanBeAccelerated");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_elementShouldBufferDataBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto mediaConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "media"_s, "Internals"_s, "elementShouldBufferData"_s, "HTMLMediaElement"_s); });
    if (mediaConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.elementShouldBufferData(*mediaConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_elementShouldBufferData, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_elementShouldBufferDataBody>(*lexicalGlobalObject, *callFrame, "elementShouldBufferData");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_elementBufferingPolicyBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto mediaConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "media"_s, "Internals"_s, "elementBufferingPolicy"_s, "HTMLMediaElement"_s); });
    if (mediaConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.elementBufferingPolicy(*mediaConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_elementBufferingPolicy, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_elementBufferingPolicyBody>(*lexicalGlobalObject, *callFrame, "elementBufferingPolicy");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setMediaElementBufferingPolicyBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "setMediaElementBufferingPolicy"_s, "HTMLMediaElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto policyConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (policyConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setMediaElementBufferingPolicy(*elementConversionResult.releaseReturnValue(), policyConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMediaElementBufferingPolicy, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setMediaElementBufferingPolicyBody>(*lexicalGlobalObject, *callFrame, "setMediaElementBufferingPolicy");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_privatePlayerVolumeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto mediaConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "media"_s, "Internals"_s, "privatePlayerVolume"_s, "HTMLMediaElement"_s); });
    if (mediaConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDouble>(*lexicalGlobalObject, throwScope, impl.privatePlayerVolume(*mediaConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_privatePlayerVolume, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_privatePlayerVolumeBody>(*lexicalGlobalObject, *callFrame, "privatePlayerVolume");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_privatePlayerMutedBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto mediaConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "media"_s, "Internals"_s, "privatePlayerMuted"_s, "HTMLMediaElement"_s); });
    if (mediaConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.privatePlayerMuted(*mediaConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_privatePlayerMuted, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_privatePlayerMutedBody>(*lexicalGlobalObject, *callFrame, "privatePlayerMuted");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isMediaElementHiddenBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto mediaConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "media"_s, "Internals"_s, "isMediaElementHidden"_s, "HTMLMediaElement"_s); });
    if (mediaConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isMediaElementHidden(*mediaConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isMediaElementHidden, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isMediaElementHiddenBody>(*lexicalGlobalObject, *callFrame, "isMediaElementHidden");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setOverridePreferredDynamicRangeModeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto mediaConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "media"_s, "Internals"_s, "setOverridePreferredDynamicRangeMode"_s, "HTMLMediaElement"_s); });
    if (mediaConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto modeConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (modeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setOverridePreferredDynamicRangeMode(*mediaConversionResult.releaseReturnValue(), modeConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setOverridePreferredDynamicRangeMode, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setOverridePreferredDynamicRangeModeBody>(*lexicalGlobalObject, *callFrame, "setOverridePreferredDynamicRangeMode");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_elementEffectivePlaybackRateBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto mediaConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "media"_s, "Internals"_s, "elementEffectivePlaybackRate"_s, "HTMLMediaElement"_s); });
    if (mediaConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDouble>(*lexicalGlobalObject, throwScope, impl.elementEffectivePlaybackRate(*mediaConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_elementEffectivePlaybackRate, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_elementEffectivePlaybackRateBody>(*lexicalGlobalObject, *callFrame, "elementEffectivePlaybackRate");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_enableGStreamerHolePunchingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLVideoElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "enableGStreamerHolePunching"_s, "HTMLVideoElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.enableGStreamerHolePunching(*elementConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_enableGStreamerHolePunching, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_enableGStreamerHolePunchingBody>(*lexicalGlobalObject, *callFrame, "enableGStreamerHolePunching");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_effectiveDynamicRangeLimitValueBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto mediaConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "media"_s, "Internals"_s, "effectiveDynamicRangeLimitValue"_s, "HTMLMediaElement"_s); });
    if (mediaConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDouble>(*lexicalGlobalObject, throwScope, impl.effectiveDynamicRangeLimitValue(*mediaConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_effectiveDynamicRangeLimitValue, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_effectiveDynamicRangeLimitValueBody>(*lexicalGlobalObject, *callFrame, "effectiveDynamicRangeLimitValue");
}

#endif

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_getContextEffectiveDynamicRangeLimitValueBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto canvasConversionResult = convert<IDLInterface<HTMLCanvasElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "canvas"_s, "Internals"_s, "getContextEffectiveDynamicRangeLimitValue"_s, "HTMLCanvasElement"_s); });
    if (canvasConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDouble>(*lexicalGlobalObject, throwScope, impl.getContextEffectiveDynamicRangeLimitValue(*canvasConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_getContextEffectiveDynamicRangeLimitValue, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_getContextEffectiveDynamicRangeLimitValueBody>(*lexicalGlobalObject, *callFrame, "getContextEffectiveDynamicRangeLimitValue");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setPageShouldSuppressHDRBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto shouldSuppressHDRConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (shouldSuppressHDRConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setPageShouldSuppressHDR(shouldSuppressHDRConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPageShouldSuppressHDR, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setPageShouldSuppressHDRBody>(*lexicalGlobalObject, *callFrame, "setPageShouldSuppressHDR");
}

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_enterViewerModeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLVideoElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "enterViewerMode"_s, "HTMLVideoElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.enterViewerMode(*elementConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_enterViewerMode, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_enterViewerModeBody>(*lexicalGlobalObject, *callFrame, "enterViewerMode");
}

#endif

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setIsPlayingToBluetoothOverrideBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->argument(0);
    auto isPlayingConversionResult = convertOptionalWithDefault<IDLNullable<IDLBoolean>>(*lexicalGlobalObject, argument0.value(), [&]() -> ConversionResult<IDLNullable<IDLBoolean>> { return typename Converter<IDLNullable<IDLBoolean>>::ReturnType { std::nullopt }; });
    if (isPlayingConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setIsPlayingToBluetoothOverride(isPlayingConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setIsPlayingToBluetoothOverride, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setIsPlayingToBluetoothOverrideBody>(*lexicalGlobalObject, *callFrame, "setIsPlayingToBluetoothOverride");
}

#if ENABLE(LEGACY_ENCRYPTED_MEDIA)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_initializeMockCDMBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.initializeMockCDM(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_initializeMockCDM, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_initializeMockCDMBody>(*lexicalGlobalObject, *callFrame, "initializeMockCDM");
}

#endif

#if ENABLE(ENCRYPTED_MEDIA)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_registerMockCDMBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<MockCDMFactory>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.registerMockCDM())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_registerMockCDM, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_registerMockCDMBody>(*lexicalGlobalObject, *callFrame, "registerMockCDM");
}

#endif

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_enableMockMediaCapabilitiesBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.enableMockMediaCapabilities(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_enableMockMediaCapabilities, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_enableMockMediaCapabilitiesBody>(*lexicalGlobalObject, *callFrame, "enableMockMediaCapabilities");
}

#if ENABLE(SPEECH_SYNTHESIS)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_enableMockSpeechSynthesizerBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.enableMockSpeechSynthesizer(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_enableMockSpeechSynthesizer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_enableMockSpeechSynthesizerBody>(*lexicalGlobalObject, *callFrame, "enableMockSpeechSynthesizer");
}

#endif

#if ENABLE(SPEECH_SYNTHESIS)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_simulateSpeechSynthesizerVoiceListChangeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.simulateSpeechSynthesizerVoiceListChange(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_simulateSpeechSynthesizerVoiceListChange, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_simulateSpeechSynthesizerVoiceListChangeBody>(*lexicalGlobalObject, *callFrame, "simulateSpeechSynthesizerVoiceListChange");
}

#endif

#if ENABLE(SPEECH_SYNTHESIS)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_enableMockSpeechSynthesizerForMediaElementBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "enableMockSpeechSynthesizerForMediaElement"_s, "HTMLMediaElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.enableMockSpeechSynthesizerForMediaElement(*elementConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_enableMockSpeechSynthesizerForMediaElement, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_enableMockSpeechSynthesizerForMediaElementBody>(*lexicalGlobalObject, *callFrame, "enableMockSpeechSynthesizerForMediaElement");
}

#endif

#if ENABLE(SPEECH_SYNTHESIS)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setSpeechUtteranceDurationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto durationConversionResult = convert<IDLDouble>(*lexicalGlobalObject, argument0.value());
    if (durationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setSpeechUtteranceDuration(durationConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setSpeechUtteranceDuration, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setSpeechUtteranceDurationBody>(*lexicalGlobalObject, *callFrame, "setSpeechUtteranceDuration");
}

#endif

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_getImageSourceURLBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "getImageSourceURL"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.getImageSourceURL(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_getImageSourceURL, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_getImageSourceURLBody>(*lexicalGlobalObject, *callFrame, "getImageSourceURL");
}

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_captionsStyleSheetOverrideBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.captionsStyleSheetOverride())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_captionsStyleSheetOverride, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_captionsStyleSheetOverrideBody>(*lexicalGlobalObject, *callFrame, "captionsStyleSheetOverride");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setCaptionsStyleSheetOverrideBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto overrideConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (overrideConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setCaptionsStyleSheetOverride(overrideConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setCaptionsStyleSheetOverride, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setCaptionsStyleSheetOverrideBody>(*lexicalGlobalObject, *callFrame, "setCaptionsStyleSheetOverride");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setPrimaryAudioTrackLanguageOverrideBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto languageConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (languageConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setPrimaryAudioTrackLanguageOverride(languageConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPrimaryAudioTrackLanguageOverride, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setPrimaryAudioTrackLanguageOverrideBody>(*lexicalGlobalObject, *callFrame, "setPrimaryAudioTrackLanguageOverride");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setCaptionDisplayModeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto modeConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (modeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setCaptionDisplayMode(modeConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setCaptionDisplayMode, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setCaptionDisplayModeBody>(*lexicalGlobalObject, *callFrame, "setCaptionDisplayMode");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_createGenericCueBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto startTimeConversionResult = convert<IDLDouble>(*lexicalGlobalObject, argument0.value());
    if (startTimeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto endTimeConversionResult = convert<IDLDouble>(*lexicalGlobalObject, argument1.value());
    if (endTimeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto textConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument2.value());
    if (textConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<TextTrackCueGeneric>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.createGenericCue(startTimeConversionResult.releaseReturnValue(), endTimeConversionResult.releaseReturnValue(), textConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_createGenericCue, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_createGenericCueBody>(*lexicalGlobalObject, *callFrame, "createGenericCue");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_textTrackBCP47LanguageBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto trackConversionResult = convert<IDLInterface<TextTrack>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "track"_s, "Internals"_s, "textTrackBCP47Language"_s, "TextTrack"_s); });
    if (trackConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.textTrackBCP47Language(*trackConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_textTrackBCP47Language, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_textTrackBCP47LanguageBody>(*lexicalGlobalObject, *callFrame, "textTrackBCP47Language");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_createTimeRangesBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto startTimesConversionResult = convert<IDLFloat32Array>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "startTimes"_s, "Internals"_s, "createTimeRanges"_s, "Float32Array"_s); });
    if (startTimesConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto endTimesConversionResult = convert<IDLFloat32Array>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "endTimes"_s, "Internals"_s, "createTimeRanges"_s, "Float32Array"_s); });
    if (endTimesConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<TimeRanges>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.createTimeRanges(startTimesConversionResult.releaseReturnValue(), endTimesConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_createTimeRanges, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_createTimeRangesBody>(*lexicalGlobalObject, *callFrame, "createTimeRanges");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_closestTimeToTimeRangesBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto timeConversionResult = convert<IDLUnrestrictedDouble>(*lexicalGlobalObject, argument0.value());
    if (timeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto rangesConversionResult = convert<IDLInterface<TimeRanges>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "ranges"_s, "Internals"_s, "closestTimeToTimeRanges"_s, "TimeRanges"_s); });
    if (rangesConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnrestrictedDouble>(*lexicalGlobalObject, throwScope, impl.closestTimeToTimeRanges(timeConversionResult.releaseReturnValue(), *rangesConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_closestTimeToTimeRanges, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_closestTimeToTimeRangesBody>(*lexicalGlobalObject, *callFrame, "closestTimeToTimeRanges");
}

#endif

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isSelectPopupVisibleBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLSelectElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "isSelectPopupVisible"_s, "HTMLSelectElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isSelectPopupVisible(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isSelectPopupVisible, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isSelectPopupVisibleBody>(*lexicalGlobalObject, *callFrame, "isSelectPopupVisible");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_selectionBoundsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<DOMRect>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.selectionBounds())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_selectionBounds, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_selectionBoundsBody>(*lexicalGlobalObject, *callFrame, "selectionBounds");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_selectedRangeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLInterface<StaticRange>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.selectedRange())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_selectedRange, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_selectedRangeBody>(*lexicalGlobalObject, *callFrame, "selectedRange");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setSelectionWithoutValidationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto baseNodeConversionResult = convert<IDLInterface<Node>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "baseNode"_s, "Internals"_s, "setSelectionWithoutValidation"_s, "Node"_s); });
    if (baseNodeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto baseOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (baseOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto extentNodeConversionResult = convert<IDLNullable<IDLInterface<Node>>>(*lexicalGlobalObject, argument2.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 2, "extentNode"_s, "Internals"_s, "setSelectionWithoutValidation"_s, "Node"_s); });
    if (extentNodeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto extentOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (extentOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setSelectionWithoutValidation(*baseNodeConversionResult.releaseReturnValue(), baseOffsetConversionResult.releaseReturnValue(), extentNodeConversionResult.releaseReturnValue(), extentOffsetConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setSelectionWithoutValidation, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setSelectionWithoutValidationBody>(*lexicalGlobalObject, *callFrame, "setSelectionWithoutValidation");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setSelectionFromNoneBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setSelectionFromNone(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setSelectionFromNone, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setSelectionFromNoneBody>(*lexicalGlobalObject, *callFrame, "setSelectionFromNone");
}

#if ENABLE(MEDIA_SOURCE)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_initializeMockMediaSourceBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.initializeMockMediaSource(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_initializeMockMediaSource, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_initializeMockMediaSourceBody>(*lexicalGlobalObject, *callFrame, "initializeMockMediaSource");
}

#endif

#if ENABLE(MEDIA_SOURCE)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_bufferedSamplesForTrackIdBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperationReturningPromise<JSInternals>::ClassParameter castedThis, Ref<DeferredPromise>&& promise)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto bufferConversionResult = convert<IDLInterface<SourceBuffer>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "buffer"_s, "Internals"_s, "bufferedSamplesForTrackId"_s, "SourceBuffer"_s); });
    if (bufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto trackIdConversionResult = convert<IDLAtomStringAdaptor<IDLDOMString>>(*lexicalGlobalObject, argument1.value());
    if (trackIdConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLPromise<IDLSequence<IDLDOMString>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, [&]() -> decltype(auto) { return impl.bufferedSamplesForTrackId(*bufferConversionResult.releaseReturnValue(), trackIdConversionResult.releaseReturnValue(), WTFMove(promise)); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_bufferedSamplesForTrackId, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperationReturningPromise<JSInternals>::call<jsInternalsPrototypeFunction_bufferedSamplesForTrackIdBody>(*lexicalGlobalObject, *callFrame, "bufferedSamplesForTrackId");
}

#endif

#if ENABLE(MEDIA_SOURCE)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setMaximumSourceBufferSizeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperationReturningPromise<JSInternals>::ClassParameter castedThis, Ref<DeferredPromise>&& promise)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto bufferConversionResult = convert<IDLInterface<SourceBuffer>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "buffer"_s, "Internals"_s, "setMaximumSourceBufferSize"_s, "SourceBuffer"_s); });
    if (bufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto maximumSizeConversionResult = convert<IDLUnsignedLongLong>(*lexicalGlobalObject, argument1.value());
    if (maximumSizeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLPromise<IDLUndefined>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, [&]() -> decltype(auto) { return impl.setMaximumSourceBufferSize(*bufferConversionResult.releaseReturnValue(), maximumSizeConversionResult.releaseReturnValue(), WTFMove(promise)); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMaximumSourceBufferSize, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperationReturningPromise<JSInternals>::call<jsInternalsPrototypeFunction_setMaximumSourceBufferSizeBody>(*lexicalGlobalObject, *callFrame, "setMaximumSourceBufferSize");
}

#endif

#if ENABLE(MEDIA_SOURCE)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_enqueuedSamplesForTrackIDBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperationReturningPromise<JSInternals>::ClassParameter castedThis, Ref<DeferredPromise>&& promise)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto bufferConversionResult = convert<IDLInterface<SourceBuffer>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "buffer"_s, "Internals"_s, "enqueuedSamplesForTrackID"_s, "SourceBuffer"_s); });
    if (bufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto trackIDConversionResult = convert<IDLAtomStringAdaptor<IDLDOMString>>(*lexicalGlobalObject, argument1.value());
    if (trackIDConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLPromise<IDLSequence<IDLDOMString>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, [&]() -> decltype(auto) { return impl.enqueuedSamplesForTrackID(*bufferConversionResult.releaseReturnValue(), trackIDConversionResult.releaseReturnValue(), WTFMove(promise)); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_enqueuedSamplesForTrackID, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperationReturningPromise<JSInternals>::call<jsInternalsPrototypeFunction_enqueuedSamplesForTrackIDBody>(*lexicalGlobalObject, *callFrame, "enqueuedSamplesForTrackID");
}

#endif

#if ENABLE(MEDIA_SOURCE)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setShouldGenerateTimestampsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto bufferConversionResult = convert<IDLInterface<SourceBuffer>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "buffer"_s, "Internals"_s, "setShouldGenerateTimestamps"_s, "SourceBuffer"_s); });
    if (bufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto flagConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (flagConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setShouldGenerateTimestamps(*bufferConversionResult.releaseReturnValue(), flagConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setShouldGenerateTimestamps, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setShouldGenerateTimestampsBody>(*lexicalGlobalObject, *callFrame, "setShouldGenerateTimestamps");
}

#endif

#if ENABLE(MEDIA_SOURCE)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_minimumUpcomingPresentationTimeForTrackIDBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto bufferConversionResult = convert<IDLInterface<SourceBuffer>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "buffer"_s, "Internals"_s, "minimumUpcomingPresentationTimeForTrackID"_s, "SourceBuffer"_s); });
    if (bufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto trackIDConversionResult = convert<IDLAtomStringAdaptor<IDLDOMString>>(*lexicalGlobalObject, argument1.value());
    if (trackIDConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDouble>(*lexicalGlobalObject, throwScope, impl.minimumUpcomingPresentationTimeForTrackID(*bufferConversionResult.releaseReturnValue(), trackIDConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_minimumUpcomingPresentationTimeForTrackID, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_minimumUpcomingPresentationTimeForTrackIDBody>(*lexicalGlobalObject, *callFrame, "minimumUpcomingPresentationTimeForTrackID");
}

#endif

#if ENABLE(MEDIA_SOURCE)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setMaximumQueueDepthForTrackIDBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto bufferConversionResult = convert<IDLInterface<SourceBuffer>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "buffer"_s, "Internals"_s, "setMaximumQueueDepthForTrackID"_s, "SourceBuffer"_s); });
    if (bufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto trackIDConversionResult = convert<IDLAtomStringAdaptor<IDLDOMString>>(*lexicalGlobalObject, argument1.value());
    if (trackIDConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto maxQueueDepthConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (maxQueueDepthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setMaximumQueueDepthForTrackID(*bufferConversionResult.releaseReturnValue(), trackIDConversionResult.releaseReturnValue(), maxQueueDepthConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMaximumQueueDepthForTrackID, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setMaximumQueueDepthForTrackIDBody>(*lexicalGlobalObject, *callFrame, "setMaximumQueueDepthForTrackID");
}

#endif

#if ENABLE(MEDIA_SOURCE)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_evictableSizeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto bufferConversionResult = convert<IDLInterface<SourceBuffer>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "buffer"_s, "Internals"_s, "evictableSize"_s, "SourceBuffer"_s); });
    if (bufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.evictableSize(*bufferConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_evictableSize, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_evictableSizeBody>(*lexicalGlobalObject, *callFrame, "evictableSize");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_beginMediaSessionInterruptionBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto interruptionTypeConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (interruptionTypeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.beginMediaSessionInterruption(interruptionTypeConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_beginMediaSessionInterruption, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_beginMediaSessionInterruptionBody>(*lexicalGlobalObject, *callFrame, "beginMediaSessionInterruption");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_endMediaSessionInterruptionBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto flagsConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (flagsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.endMediaSessionInterruption(flagsConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_endMediaSessionInterruption, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_endMediaSessionInterruptionBody>(*lexicalGlobalObject, *callFrame, "endMediaSessionInterruption");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_applicationWillBecomeInactiveBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.applicationWillBecomeInactive(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_applicationWillBecomeInactive, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_applicationWillBecomeInactiveBody>(*lexicalGlobalObject, *callFrame, "applicationWillBecomeInactive");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_applicationDidBecomeActiveBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.applicationDidBecomeActive(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_applicationDidBecomeActive, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_applicationDidBecomeActiveBody>(*lexicalGlobalObject, *callFrame, "applicationDidBecomeActive");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_applicationWillEnterForegroundBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->argument(0);
    auto suspendedUnderLockConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (suspendedUnderLockConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.applicationWillEnterForeground(suspendedUnderLockConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_applicationWillEnterForeground, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_applicationWillEnterForegroundBody>(*lexicalGlobalObject, *callFrame, "applicationWillEnterForeground");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_applicationDidEnterBackgroundBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->argument(0);
    auto suspendedUnderLockConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (suspendedUnderLockConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.applicationDidEnterBackground(suspendedUnderLockConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_applicationDidEnterBackground, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_applicationDidEnterBackgroundBody>(*lexicalGlobalObject, *callFrame, "applicationDidEnterBackground");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setMediaSessionRestrictionsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto mediaTypeConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (mediaTypeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto restrictionsConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (restrictionsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setMediaSessionRestrictions(mediaTypeConversionResult.releaseReturnValue(), restrictionsConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMediaSessionRestrictions, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setMediaSessionRestrictionsBody>(*lexicalGlobalObject, *callFrame, "setMediaSessionRestrictions");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_mediaSessionRestrictionsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto mediaTypeConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (mediaTypeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.mediaSessionRestrictions(mediaTypeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_mediaSessionRestrictions, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_mediaSessionRestrictionsBody>(*lexicalGlobalObject, *callFrame, "mediaSessionRestrictions");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setMediaElementRestrictionsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "setMediaElementRestrictions"_s, "HTMLMediaElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto restrictionsConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (restrictionsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setMediaElementRestrictions(*elementConversionResult.releaseReturnValue(), restrictionsConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMediaElementRestrictions, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setMediaElementRestrictionsBody>(*lexicalGlobalObject, *callFrame, "setMediaElementRestrictions");
}

#endif

#if ENABLE(WEB_AUDIO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setAudioContextRestrictionsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto contextConversionResult = convert<IDLInterface<AudioContext>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "context"_s, "Internals"_s, "setAudioContextRestrictions"_s, "AudioContext"_s); });
    if (contextConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto restrictionsConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (restrictionsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setAudioContextRestrictions(*contextConversionResult.releaseReturnValue(), restrictionsConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setAudioContextRestrictions, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setAudioContextRestrictionsBody>(*lexicalGlobalObject, *callFrame, "setAudioContextRestrictions");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_postRemoteControlCommandBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto commandConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (commandConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->argument(1);
    auto argumentConversionResult = convertOptionalWithDefault<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument1.value(), [&]() -> ConversionResult<IDLUnrestrictedFloat> { return Converter<IDLUnrestrictedFloat>::ReturnType { 0 }; });
    if (argumentConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.postRemoteControlCommand(commandConversionResult.releaseReturnValue(), argumentConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_postRemoteControlCommand, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_postRemoteControlCommandBody>(*lexicalGlobalObject, *callFrame, "postRemoteControlCommand");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_activeAudioRouteDidChangeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto shouldPauseConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (shouldPauseConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.activeAudioRouteDidChange(shouldPauseConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_activeAudioRouteDidChange, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_activeAudioRouteDidChangeBody>(*lexicalGlobalObject, *callFrame, "activeAudioRouteDidChange");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_beginAudioSessionInterruptionBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.beginAudioSessionInterruption(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_beginAudioSessionInterruption, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_beginAudioSessionInterruptionBody>(*lexicalGlobalObject, *callFrame, "beginAudioSessionInterruption");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_endAudioSessionInterruptionBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.endAudioSessionInterruption(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_endAudioSessionInterruption, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_endAudioSessionInterruptionBody>(*lexicalGlobalObject, *callFrame, "endAudioSessionInterruption");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_clearAudioSessionInterruptionFlagBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.clearAudioSessionInterruptionFlag(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_clearAudioSessionInterruptionFlag, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_clearAudioSessionInterruptionFlagBody>(*lexicalGlobalObject, *callFrame, "clearAudioSessionInterruptionFlag");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_suspendAllMediaBufferingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.suspendAllMediaBuffering(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_suspendAllMediaBuffering, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_suspendAllMediaBufferingBody>(*lexicalGlobalObject, *callFrame, "suspendAllMediaBuffering");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_suspendAllMediaPlaybackBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.suspendAllMediaPlayback(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_suspendAllMediaPlayback, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_suspendAllMediaPlaybackBody>(*lexicalGlobalObject, *callFrame, "suspendAllMediaPlayback");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_resumeAllMediaPlaybackBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.resumeAllMediaPlayback(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_resumeAllMediaPlayback, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_resumeAllMediaPlaybackBody>(*lexicalGlobalObject, *callFrame, "resumeAllMediaPlayback");
}

#endif

#if ENABLE(WIRELESS_PLAYBACK_TARGET)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setMockMediaPlaybackTargetPickerEnabledBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto enabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (enabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setMockMediaPlaybackTargetPickerEnabled(enabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMockMediaPlaybackTargetPickerEnabled, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setMockMediaPlaybackTargetPickerEnabledBody>(*lexicalGlobalObject, *callFrame, "setMockMediaPlaybackTargetPickerEnabled");
}

#endif

#if ENABLE(WIRELESS_PLAYBACK_TARGET)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setMockMediaPlaybackTargetPickerStateBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto deviceNameConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (deviceNameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto deviceStateConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (deviceStateConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setMockMediaPlaybackTargetPickerState(deviceNameConversionResult.releaseReturnValue(), deviceStateConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMockMediaPlaybackTargetPickerState, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setMockMediaPlaybackTargetPickerStateBody>(*lexicalGlobalObject, *callFrame, "setMockMediaPlaybackTargetPickerState");
}

#endif

#if ENABLE(WIRELESS_PLAYBACK_TARGET)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_mockMediaPlaybackTargetPickerDismissPopupBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.mockMediaPlaybackTargetPickerDismissPopup(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_mockMediaPlaybackTargetPickerDismissPopup, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_mockMediaPlaybackTargetPickerDismissPopupBody>(*lexicalGlobalObject, *callFrame, "mockMediaPlaybackTargetPickerDismissPopup");
}

#endif

#if ENABLE(MEDIA_RECORDER)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setCustomPrivateRecorderCreatorBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setCustomPrivateRecorderCreator(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setCustomPrivateRecorderCreator, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setCustomPrivateRecorderCreatorBody>(*lexicalGlobalObject, *callFrame, "setCustomPrivateRecorderCreator");
}

#endif

#if ENABLE(WEB_AUDIO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_useMockAudioDestinationCocoaBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.useMockAudioDestinationCocoa(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_useMockAudioDestinationCocoa, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_useMockAudioDestinationCocoaBody>(*lexicalGlobalObject, *callFrame, "useMockAudioDestinationCocoa");
}

#endif

#if ENABLE(WEB_RTC)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_emulateRTCPeerConnectionPlatformEventBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto connectionConversionResult = convert<IDLInterface<RTCPeerConnection>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "connection"_s, "Internals"_s, "emulateRTCPeerConnectionPlatformEvent"_s, "RTCPeerConnection"_s); });
    if (connectionConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto actionConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (actionConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.emulateRTCPeerConnectionPlatformEvent(*connectionConversionResult.releaseReturnValue(), actionConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_emulateRTCPeerConnectionPlatformEvent, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_emulateRTCPeerConnectionPlatformEventBody>(*lexicalGlobalObject, *callFrame, "emulateRTCPeerConnectionPlatformEvent");
}

#endif

#if ENABLE(WEB_RTC)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_useMockRTCPeerConnectionFactoryBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto testCaseConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (testCaseConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.useMockRTCPeerConnectionFactory(testCaseConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_useMockRTCPeerConnectionFactory, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_useMockRTCPeerConnectionFactoryBody>(*lexicalGlobalObject, *callFrame, "useMockRTCPeerConnectionFactory");
}

#endif

#if ENABLE(WEB_RTC)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setICECandidateFilteringBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto enabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (enabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setICECandidateFiltering(enabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setICECandidateFiltering, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setICECandidateFilteringBody>(*lexicalGlobalObject, *callFrame, "setICECandidateFiltering");
}

#endif

#if ENABLE(WEB_RTC)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setEnumeratingAllNetworkInterfacesEnabledBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto enabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (enabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setEnumeratingAllNetworkInterfacesEnabled(enabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setEnumeratingAllNetworkInterfacesEnabled, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setEnumeratingAllNetworkInterfacesEnabledBody>(*lexicalGlobalObject, *callFrame, "setEnumeratingAllNetworkInterfacesEnabled");
}

#endif

#if ENABLE(WEB_RTC)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_stopPeerConnectionBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto connectionConversionResult = convert<IDLInterface<RTCPeerConnection>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "connection"_s, "Internals"_s, "stopPeerConnection"_s, "RTCPeerConnection"_s); });
    if (connectionConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.stopPeerConnection(*connectionConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_stopPeerConnection, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_stopPeerConnectionBody>(*lexicalGlobalObject, *callFrame, "stopPeerConnection");
}

#endif

#if ENABLE(WEB_RTC)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_clearPeerConnectionFactoryBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.clearPeerConnectionFactory(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_clearPeerConnectionFactory, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_clearPeerConnectionFactoryBody>(*lexicalGlobalObject, *callFrame, "clearPeerConnectionFactory");
}

#endif

#if ENABLE(WEB_RTC)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setEnableWebRTCEncryptionBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto enabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (enabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setEnableWebRTCEncryption(enabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setEnableWebRTCEncryption, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setEnableWebRTCEncryptionBody>(*lexicalGlobalObject, *callFrame, "setEnableWebRTCEncryption");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_simulateSystemSleepBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.simulateSystemSleep(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_simulateSystemSleep, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_simulateSystemSleepBody>(*lexicalGlobalObject, *callFrame, "simulateSystemSleep");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_simulateSystemWakeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.simulateSystemWake(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_simulateSystemWake, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_simulateSystemWakeBody>(*lexicalGlobalObject, *callFrame, "simulateSystemWake");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_elementIsBlockingDisplaySleepBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "elementIsBlockingDisplaySleep"_s, "HTMLMediaElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.elementIsBlockingDisplaySleep(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_elementIsBlockingDisplaySleep, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_elementIsBlockingDisplaySleepBody>(*lexicalGlobalObject, *callFrame, "elementIsBlockingDisplaySleep");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isPlayerVisibleInViewportBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "isPlayerVisibleInViewport"_s, "HTMLMediaElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isPlayerVisibleInViewport(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isPlayerVisibleInViewport, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isPlayerVisibleInViewportBody>(*lexicalGlobalObject, *callFrame, "isPlayerVisibleInViewport");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isPlayerMutedBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "isPlayerMuted"_s, "HTMLMediaElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isPlayerMuted(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isPlayerMuted, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isPlayerMutedBody>(*lexicalGlobalObject, *callFrame, "isPlayerMuted");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isPlayerPausedBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "isPlayerPaused"_s, "HTMLMediaElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isPlayerPaused(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isPlayerPaused, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isPlayerPausedBody>(*lexicalGlobalObject, *callFrame, "isPlayerPaused");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_forceStereoDecodingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "forceStereoDecoding"_s, "HTMLMediaElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.forceStereoDecoding(*elementConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_forceStereoDecoding, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_forceStereoDecodingBody>(*lexicalGlobalObject, *callFrame, "forceStereoDecoding");
}

#endif

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_installMockPageOverlayBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto typeConversionResult = convert<IDLEnumeration<Internals::PageOverlayType>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentMustBeEnumError(lexicalGlobalObject, scope, 0, "type"_s, "Internals"_s, "installMockPageOverlay"_s, expectedEnumerationValues<Internals::PageOverlayType>()); });
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<MockPageOverlay>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.installMockPageOverlay(typeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_installMockPageOverlay, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_installMockPageOverlayBody>(*lexicalGlobalObject, *callFrame, "installMockPageOverlay");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_pageOverlayLayerTreeAsTextBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->argument(0);
    auto flagsConversionResult = convert<IDLUnsignedShort>(*lexicalGlobalObject, argument0.value());
    if (flagsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.pageOverlayLayerTreeAsText(flagsConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_pageOverlayLayerTreeAsText, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_pageOverlayLayerTreeAsTextBody>(*lexicalGlobalObject, *callFrame, "pageOverlayLayerTreeAsText");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setPageMutedBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto mutedStateConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (mutedStateConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setPageMuted(mutedStateConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPageMuted, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setPageMutedBody>(*lexicalGlobalObject, *callFrame, "setPageMuted");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_pageMediaStateBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.pageMediaState())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_pageMediaState, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_pageMediaStateBody>(*lexicalGlobalObject, *callFrame, "pageMediaState");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setPageDefersLoadingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto defersLoadingConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (defersLoadingConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setPageDefersLoading(defersLoadingConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPageDefersLoading, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setPageDefersLoadingBody>(*lexicalGlobalObject, *callFrame, "setPageDefersLoading");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_pageDefersLoadingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.pageDefersLoading())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_pageDefersLoading, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_pageDefersLoadingBody>(*lexicalGlobalObject, *callFrame, "pageDefersLoading");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_grantUniversalAccessBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.grantUniversalAccess(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_grantUniversalAccess, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_grantUniversalAccessBody>(*lexicalGlobalObject, *callFrame, "grantUniversalAccess");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_disableCORSForURLBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto urlConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (urlConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.disableCORSForURL(urlConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_disableCORSForURL, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_disableCORSForURLBody>(*lexicalGlobalObject, *callFrame, "disableCORSForURL");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_createFileBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto urlConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (urlConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLInterface<File>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.createFile(urlConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_createFile, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_createFileBody>(*lexicalGlobalObject, *callFrame, "createFile");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_asyncCreateFileBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperationReturningPromise<JSInternals>::ClassParameter castedThis, Ref<DeferredPromise>&& promise)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto urlConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (urlConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLPromise<IDLInterface<File>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, [&]() -> decltype(auto) { return impl.asyncCreateFile(urlConversionResult.releaseReturnValue(), WTFMove(promise)); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_asyncCreateFile, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperationReturningPromise<JSInternals>::call<jsInternalsPrototypeFunction_asyncCreateFileBody>(*lexicalGlobalObject, *callFrame, "asyncCreateFile");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_createTemporaryFileBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto nameConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (nameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto contentsConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (contentsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.createTemporaryFile(nameConversionResult.releaseReturnValue(), contentsConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_createTemporaryFile, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_createTemporaryFileBody>(*lexicalGlobalObject, *callFrame, "createTemporaryFile");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_queueMicroTaskBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto testNumberConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument0.value());
    if (testNumberConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.queueMicroTask(testNumberConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_queueMicroTask, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_queueMicroTaskBody>(*lexicalGlobalObject, *callFrame, "queueMicroTask");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_testPreloaderSettingViewportBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.testPreloaderSettingViewport())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_testPreloaderSettingViewport, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_testPreloaderSettingViewportBody>(*lexicalGlobalObject, *callFrame, "testPreloaderSettingViewport");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_scrollSnapOffsetsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "scrollSnapOffsets"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.scrollSnapOffsets(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_scrollSnapOffsets, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_scrollSnapOffsetsBody>(*lexicalGlobalObject, *callFrame, "scrollSnapOffsets");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isScrollSnapInProgressBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "isScrollSnapInProgress"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isScrollSnapInProgress(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isScrollSnapInProgress, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isScrollSnapInProgressBody>(*lexicalGlobalObject, *callFrame, "isScrollSnapInProgress");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setPlatformMomentumScrollingPredictionEnabledBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto enabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (enabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setPlatformMomentumScrollingPredictionEnabled(enabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPlatformMomentumScrollingPredictionEnabled, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setPlatformMomentumScrollingPredictionEnabledBody>(*lexicalGlobalObject, *callFrame, "setPlatformMomentumScrollingPredictionEnabled");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_pathStringWithShrinkWrappedRectsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto rectComponentsConversionResult = convert<IDLSequence<IDLDouble>>(*lexicalGlobalObject, argument0.value());
    if (rectComponentsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto radiusConversionResult = convert<IDLDouble>(*lexicalGlobalObject, argument1.value());
    if (radiusConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.pathStringWithShrinkWrappedRects(rectComponentsConversionResult.releaseReturnValue(), radiusConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_pathStringWithShrinkWrappedRects, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_pathStringWithShrinkWrappedRectsBody>(*lexicalGlobalObject, *callFrame, "pathStringWithShrinkWrappedRects");
}

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_getCurrentMediaControlsStatusForElementBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "getCurrentMediaControlsStatusForElement"_s, "HTMLMediaElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.getCurrentMediaControlsStatusForElement(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_getCurrentMediaControlsStatusForElement, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_getCurrentMediaControlsStatusForElementBody>(*lexicalGlobalObject, *callFrame, "getCurrentMediaControlsStatusForElement");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setMediaControlsMaximumRightContainerButtonCountOverrideBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "setMediaControlsMaximumRightContainerButtonCountOverride"_s, "HTMLMediaElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto countConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (countConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setMediaControlsMaximumRightContainerButtonCountOverride(*elementConversionResult.releaseReturnValue(), countConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMediaControlsMaximumRightContainerButtonCountOverride, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setMediaControlsMaximumRightContainerButtonCountOverrideBody>(*lexicalGlobalObject, *callFrame, "setMediaControlsMaximumRightContainerButtonCountOverride");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setMediaControlsHidePlaybackRatesBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "setMediaControlsHidePlaybackRates"_s, "HTMLMediaElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto hidePlaybackRatesConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (hidePlaybackRatesConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setMediaControlsHidePlaybackRates(*elementConversionResult.releaseReturnValue(), hidePlaybackRatesConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMediaControlsHidePlaybackRates, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setMediaControlsHidePlaybackRatesBody>(*lexicalGlobalObject, *callFrame, "setMediaControlsHidePlaybackRates");
}

#endif

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_userVisibleStringBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto urlConversionResult = convert<IDLInterface<DOMURL>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "url"_s, "Internals"_s, "userVisibleString"_s, "DOMURL"_s); });
    if (urlConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.userVisibleString(*urlConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_userVisibleString, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_userVisibleStringBody>(*lexicalGlobalObject, *callFrame, "userVisibleString");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_pageMediaVolumeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLFloat>(*lexicalGlobalObject, throwScope, impl.pageMediaVolume())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_pageMediaVolume, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_pageMediaVolumeBody>(*lexicalGlobalObject, *callFrame, "pageMediaVolume");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setPageMediaVolumeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto volumeConversionResult = convert<IDLFloat>(*lexicalGlobalObject, argument0.value());
    if (volumeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setPageMediaVolume(volumeConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPageMediaVolume, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setPageMediaVolumeBody>(*lexicalGlobalObject, *callFrame, "setPageMediaVolume");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setShowAllPluginsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto showAllConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (showAllConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setShowAllPlugins(showAllConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setShowAllPlugins, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setShowAllPluginsBody>(*lexicalGlobalObject, *callFrame, "setShowAllPlugins");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_cloneArrayBufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto bufferConversionResult = convert<IDLAny>(*lexicalGlobalObject, argument0.value());
    if (bufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto srcByteOffsetConversionResult = convert<IDLAny>(*lexicalGlobalObject, argument1.value());
    if (srcByteOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto byteLengthConversionResult = convert<IDLAny>(*lexicalGlobalObject, argument2.value());
    if (byteLengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLAny>(*lexicalGlobalObject, throwScope, impl.cloneArrayBuffer(*jsCast<JSDOMGlobalObject*>(lexicalGlobalObject), bufferConversionResult.releaseReturnValue(), srcByteOffsetConversionResult.releaseReturnValue(), byteLengthConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_cloneArrayBuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_cloneArrayBufferBody>(*lexicalGlobalObject, *callFrame, "cloneArrayBuffer");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isReadableStreamDisturbedBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto streamConversionResult = convert<IDLInterface<ReadableStream>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "stream"_s, "Internals"_s, "isReadableStreamDisturbed"_s, "ReadableStream"_s); });
    if (streamConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isReadableStreamDisturbed(*streamConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isReadableStreamDisturbed, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isReadableStreamDisturbedBody>(*lexicalGlobalObject, *callFrame, "isReadableStreamDisturbed");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_resourceLoadStatisticsForURLBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto urlConversionResult = convert<IDLInterface<DOMURL>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "url"_s, "Internals"_s, "resourceLoadStatisticsForURL"_s, "DOMURL"_s); });
    if (urlConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.resourceLoadStatisticsForURL(*urlConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_resourceLoadStatisticsForURL, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_resourceLoadStatisticsForURLBody>(*lexicalGlobalObject, *callFrame, "resourceLoadStatisticsForURL");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setTrackingPreventionEnabledBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto enableConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (enableConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setTrackingPreventionEnabled(enableConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setTrackingPreventionEnabled, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setTrackingPreventionEnabledBody>(*lexicalGlobalObject, *callFrame, "setTrackingPreventionEnabled");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setCanShowModalDialogOverrideBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto allowConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (allowConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setCanShowModalDialogOverride(allowConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setCanShowModalDialogOverride, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setCanShowModalDialogOverrideBody>(*lexicalGlobalObject, *callFrame, "setCanShowModalDialogOverride");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_composedTreeAsTextBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto parentConversionResult = convert<IDLInterface<Node>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "parent"_s, "Internals"_s, "composedTreeAsText"_s, "Node"_s); });
    if (parentConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.composedTreeAsText(*parentConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_composedTreeAsText, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_composedTreeAsTextBody>(*lexicalGlobalObject, *callFrame, "composedTreeAsText");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isProcessingUserGestureBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isProcessingUserGesture())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isProcessingUserGesture, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isProcessingUserGestureBody>(*lexicalGlobalObject, *callFrame, "isProcessingUserGesture");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_lastHandledUserGestureTimestampBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDouble>(*lexicalGlobalObject, throwScope, impl.lastHandledUserGestureTimestamp())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_lastHandledUserGestureTimestamp, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_lastHandledUserGestureTimestampBody>(*lexicalGlobalObject, *callFrame, "lastHandledUserGestureTimestamp");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_withUserGestureBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto callbackConversionResult = convert<IDLCallbackFunction<JSVoidCallback>>(*lexicalGlobalObject, argument0.value(), *castedThis->globalObject(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentMustBeFunctionError(lexicalGlobalObject, scope, 0, "callback"_s, "Internals"_s, "withUserGesture"_s); });
    if (callbackConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.withUserGesture(callbackConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_withUserGesture, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_withUserGestureBody>(*lexicalGlobalObject, *callFrame, "withUserGesture");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_withoutUserGestureBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto callbackConversionResult = convert<IDLCallbackFunction<JSVoidCallback>>(*lexicalGlobalObject, argument0.value(), *castedThis->globalObject(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentMustBeFunctionError(lexicalGlobalObject, scope, 0, "callback"_s, "Internals"_s, "withoutUserGesture"_s); });
    if (callbackConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.withoutUserGesture(callbackConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_withoutUserGesture, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_withoutUserGestureBody>(*lexicalGlobalObject, *callFrame, "withoutUserGesture");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_userIsInteractingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.userIsInteracting())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_userIsInteracting, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_userIsInteractingBody>(*lexicalGlobalObject, *callFrame, "userIsInteracting");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_hasTransientActivationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.hasTransientActivation())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasTransientActivation, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_hasTransientActivationBody>(*lexicalGlobalObject, *callFrame, "hasTransientActivation");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_hasHistoryActionActivationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.hasHistoryActionActivation())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasHistoryActionActivation, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_hasHistoryActionActivationBody>(*lexicalGlobalObject, *callFrame, "hasHistoryActionActivation");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_observeGCBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto observedConversionResult = convert<IDLAny>(*lexicalGlobalObject, argument0.value());
    if (observedConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLInterface<GCObservation>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.observeGC(observedConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_observeGC, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_observeGCBody>(*lexicalGlobalObject, *callFrame, "observeGC");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setUserInterfaceLayoutDirectionBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto userInterfaceLayoutDirectionConversionResult = convert<IDLEnumeration<Internals::UserInterfaceLayoutDirection>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentMustBeEnumError(lexicalGlobalObject, scope, 0, "userInterfaceLayoutDirection"_s, "Internals"_s, "setUserInterfaceLayoutDirection"_s, expectedEnumerationValues<Internals::UserInterfaceLayoutDirection>()); });
    if (userInterfaceLayoutDirectionConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setUserInterfaceLayoutDirection(userInterfaceLayoutDirectionConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setUserInterfaceLayoutDirection, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setUserInterfaceLayoutDirectionBody>(*lexicalGlobalObject, *callFrame, "setUserInterfaceLayoutDirection");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setBaseWritingDirectionBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto directionConversionResult = convert<IDLEnumeration<Internals::BaseWritingDirection>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentMustBeEnumError(lexicalGlobalObject, scope, 0, "direction"_s, "Internals"_s, "setBaseWritingDirection"_s, expectedEnumerationValues<Internals::BaseWritingDirection>()); });
    if (directionConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setBaseWritingDirection(directionConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setBaseWritingDirection, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setBaseWritingDirectionBody>(*lexicalGlobalObject, *callFrame, "setBaseWritingDirection");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_userPrefersContrastBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.userPrefersContrast())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_userPrefersContrast, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_userPrefersContrastBody>(*lexicalGlobalObject, *callFrame, "userPrefersContrast");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_userPrefersReducedMotionBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.userPrefersReducedMotion())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_userPrefersReducedMotion, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_userPrefersReducedMotionBody>(*lexicalGlobalObject, *callFrame, "userPrefersReducedMotion");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_reportBacktraceBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.reportBacktrace(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_reportBacktrace, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_reportBacktraceBody>(*lexicalGlobalObject, *callFrame, "reportBacktrace");
}

#if ENABLE(POINTER_LOCK)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_pageHasPendingPointerLockBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.pageHasPendingPointerLock())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_pageHasPendingPointerLock, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_pageHasPendingPointerLockBody>(*lexicalGlobalObject, *callFrame, "pageHasPendingPointerLock");
}

#endif

#if ENABLE(POINTER_LOCK)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_pageHasPointerLockBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.pageHasPointerLock())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_pageHasPointerLock, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_pageHasPointerLockBody>(*lexicalGlobalObject, *callFrame, "pageHasPointerLock");
}

#endif

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_accessKeyModifiersBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLSequence<IDLDOMString>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.accessKeyModifiers())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_accessKeyModifiers, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_accessKeyModifiersBody>(*lexicalGlobalObject, *callFrame, "accessKeyModifiers");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setQuickLookPasswordBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto passwordConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (passwordConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setQuickLookPassword(passwordConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setQuickLookPassword, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setQuickLookPasswordBody>(*lexicalGlobalObject, *callFrame, "setQuickLookPassword");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setAsRunningUserScriptsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RefPtr context = jsCast<JSDOMGlobalObject*>(lexicalGlobalObject)->scriptExecutionContext();
    if (!context) [[unlikely]]
        return JSValue::encode(jsUndefined());
    Ref document = downcast<Document>(*context);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setAsRunningUserScripts(document.get()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setAsRunningUserScripts, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setAsRunningUserScriptsBody>(*lexicalGlobalObject, *callFrame, "setAsRunningUserScripts");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_disableTileSizeUpdateDelayBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.disableTileSizeUpdateDelay(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_disableTileSizeUpdateDelay, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_disableTileSizeUpdateDelayBody>(*lexicalGlobalObject, *callFrame, "disableTileSizeUpdateDelay");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setSpeculativeTilingDelayDisabledForTestingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto disabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (disabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setSpeculativeTilingDelayDisabledForTesting(disabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setSpeculativeTilingDelayDisabledForTesting, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setSpeculativeTilingDelayDisabledForTestingBody>(*lexicalGlobalObject, *callFrame, "setSpeculativeTilingDelayDisabledForTesting");
}

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_simulateEventForWebGLContextBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto eventConversionResult = convert<IDLEnumeration<Internals::SimulatedWebGLContextEvent>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentMustBeEnumError(lexicalGlobalObject, scope, 0, "event"_s, "Internals"_s, "simulateEventForWebGLContext"_s, expectedEnumerationValues<Internals::SimulatedWebGLContextEvent>()); });
    if (eventConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto contextConversionResult = convert<IDLInterface<WebGLRenderingContext>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "context"_s, "Internals"_s, "simulateEventForWebGLContext"_s, "WebGLRenderingContext"_s); });
    if (contextConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.simulateEventForWebGLContext(eventConversionResult.releaseReturnValue(), *contextConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_simulateEventForWebGLContext, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_simulateEventForWebGLContextBody>(*lexicalGlobalObject, *callFrame, "simulateEventForWebGLContext");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_requestedGPUBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto contextConversionResult = convert<IDLInterface<WebGLRenderingContext>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "context"_s, "Internals"_s, "requestedGPU"_s, "WebGLRenderingContext"_s); });
    if (contextConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLEnumeration<Internals::RequestedGPU>>(*lexicalGlobalObject, throwScope, impl.requestedGPU(*contextConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_requestedGPU, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_requestedGPUBody>(*lexicalGlobalObject, *callFrame, "requestedGPU");
}

#endif

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setPageVisibilityBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto isVisibleConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (isVisibleConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setPageVisibility(isVisibleConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPageVisibility, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setPageVisibilityBody>(*lexicalGlobalObject, *callFrame, "setPageVisibility");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setPageIsFocusedBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto isFocusedConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (isFocusedConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setPageIsFocused(isFocusedConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPageIsFocused, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setPageIsFocusedBody>(*lexicalGlobalObject, *callFrame, "setPageIsFocused");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setPageIsFocusedAndActiveBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto isFocusedConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (isFocusedConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setPageIsFocusedAndActive(isFocusedConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPageIsFocusedAndActive, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setPageIsFocusedAndActiveBody>(*lexicalGlobalObject, *callFrame, "setPageIsFocusedAndActive");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setPageIsInWindowBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto isInWindowConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (isInWindowConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setPageIsInWindow(isInWindowConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPageIsInWindow, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setPageIsInWindowBody>(*lexicalGlobalObject, *callFrame, "setPageIsInWindow");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isPageActiveBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isPageActive())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isPageActive, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isPageActiveBody>(*lexicalGlobalObject, *callFrame, "isPageActive");
}

#if ENABLE(WEB_RTC)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_applyRotationForOutgoingVideoSourcesBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto connectionConversionResult = convert<IDLInterface<RTCPeerConnection>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "connection"_s, "Internals"_s, "applyRotationForOutgoingVideoSources"_s, "RTCPeerConnection"_s); });
    if (connectionConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.applyRotationForOutgoingVideoSources(*connectionConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_applyRotationForOutgoingVideoSources, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_applyRotationForOutgoingVideoSourcesBody>(*lexicalGlobalObject, *callFrame, "applyRotationForOutgoingVideoSources");
}

#endif

#if ENABLE(WEB_RTC)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setWebRTCH265SupportBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto allowedConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (allowedConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setWebRTCH265Support(allowedConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setWebRTCH265Support, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setWebRTCH265SupportBody>(*lexicalGlobalObject, *callFrame, "setWebRTCH265Support");
}

#endif

#if ENABLE(WEB_RTC)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setWebRTCVP9SupportBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto supportVP9Profile0ConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (supportVP9Profile0ConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto supportVP9Profile2ConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (supportVP9Profile2ConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setWebRTCVP9Support(supportVP9Profile0ConversionResult.releaseReturnValue(), supportVP9Profile2ConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setWebRTCVP9Support, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setWebRTCVP9SupportBody>(*lexicalGlobalObject, *callFrame, "setWebRTCVP9Support");
}

#endif

#if ENABLE(WEB_RTC)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_disableWebRTCHardwareVP9Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.disableWebRTCHardwareVP9(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_disableWebRTCHardwareVP9, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_disableWebRTCHardwareVP9Body>(*lexicalGlobalObject, *callFrame, "disableWebRTCHardwareVP9");
}

#endif

#if ENABLE(WEB_RTC)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isSupportingVP9HardwareDecoderBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isSupportingVP9HardwareDecoder())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isSupportingVP9HardwareDecoder, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isSupportingVP9HardwareDecoderBody>(*lexicalGlobalObject, *callFrame, "isSupportingVP9HardwareDecoder");
}

#endif

#if ENABLE(WEB_RTC)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isVP9HardwareDecoderUsedBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperationReturningPromise<JSInternals>::ClassParameter castedThis, Ref<DeferredPromise>&& promise)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto connectionConversionResult = convert<IDLInterface<RTCPeerConnection>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "connection"_s, "Internals"_s, "isVP9HardwareDecoderUsed"_s, "RTCPeerConnection"_s); });
    if (connectionConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLPromise<IDLBoolean>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, [&]() -> decltype(auto) { return impl.isVP9HardwareDecoderUsed(*connectionConversionResult.releaseReturnValue(), WTFMove(promise)); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isVP9HardwareDecoderUsed, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperationReturningPromise<JSInternals>::call<jsInternalsPrototypeFunction_isVP9HardwareDecoderUsedBody>(*lexicalGlobalObject, *callFrame, "isVP9HardwareDecoderUsed");
}

#endif

#if ENABLE(WEB_RTC)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setSFrameCounterBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto transformConversionResult = convert<IDLInterface<RTCRtpSFrameTransform>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "transform"_s, "Internals"_s, "setSFrameCounter"_s, "RTCRtpSFrameTransform"_s); });
    if (transformConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto counterConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (counterConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setSFrameCounter(*transformConversionResult.releaseReturnValue(), counterConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setSFrameCounter, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setSFrameCounterBody>(*lexicalGlobalObject, *callFrame, "setSFrameCounter");
}

#endif

#if ENABLE(WEB_RTC)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_sframeCounterBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto transformConversionResult = convert<IDLInterface<RTCRtpSFrameTransform>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "transform"_s, "Internals"_s, "sframeCounter"_s, "RTCRtpSFrameTransform"_s); });
    if (transformConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLongLong>(*lexicalGlobalObject, throwScope, impl.sframeCounter(*transformConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_sframeCounter, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_sframeCounterBody>(*lexicalGlobalObject, *callFrame, "sframeCounter");
}

#endif

#if ENABLE(WEB_RTC)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_sframeKeyIdBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto transformConversionResult = convert<IDLInterface<RTCRtpSFrameTransform>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "transform"_s, "Internals"_s, "sframeKeyId"_s, "RTCRtpSFrameTransform"_s); });
    if (transformConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLongLong>(*lexicalGlobalObject, throwScope, impl.sframeKeyId(*transformConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_sframeKeyId, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_sframeKeyIdBody>(*lexicalGlobalObject, *callFrame, "sframeKeyId");
}

#endif

#if ENABLE(MEDIA_STREAM)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setMockAudioTrackChannelNumberBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto trackConversionResult = convert<IDLInterface<MediaStreamTrack>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "track"_s, "Internals"_s, "setMockAudioTrackChannelNumber"_s, "MediaStreamTrack"_s); });
    if (trackConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto countConversionResult = convert<IDLUnsignedShort>(*lexicalGlobalObject, argument1.value());
    if (countConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setMockAudioTrackChannelNumber(*trackConversionResult.releaseReturnValue(), countConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMockAudioTrackChannelNumber, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setMockAudioTrackChannelNumberBody>(*lexicalGlobalObject, *callFrame, "setMockAudioTrackChannelNumber");
}

#endif

#if ENABLE(MEDIA_STREAM)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setShouldInterruptAudioOnPageVisibilityChangeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto shouldInterruptConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (shouldInterruptConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setShouldInterruptAudioOnPageVisibilityChange(shouldInterruptConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setShouldInterruptAudioOnPageVisibilityChange, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setShouldInterruptAudioOnPageVisibilityChangeBody>(*lexicalGlobalObject, *callFrame, "setShouldInterruptAudioOnPageVisibilityChange");
}

#endif

#if ENABLE(MEDIA_STREAM)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setCameraMediaStreamTrackOrientationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto trackConversionResult = convert<IDLInterface<MediaStreamTrack>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "track"_s, "Internals"_s, "setCameraMediaStreamTrackOrientation"_s, "MediaStreamTrack"_s); });
    if (trackConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto orientationConversionResult = convert<IDLShort>(*lexicalGlobalObject, argument1.value());
    if (orientationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setCameraMediaStreamTrackOrientation(*trackConversionResult.releaseReturnValue(), orientationConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setCameraMediaStreamTrackOrientation, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setCameraMediaStreamTrackOrientationBody>(*lexicalGlobalObject, *callFrame, "setCameraMediaStreamTrackOrientation");
}

#endif

#if ENABLE(MEDIA_STREAM)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_observeMediaStreamTrackBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto trackConversionResult = convert<IDLInterface<MediaStreamTrack>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "track"_s, "Internals"_s, "observeMediaStreamTrack"_s, "MediaStreamTrack"_s); });
    if (trackConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.observeMediaStreamTrack(*trackConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_observeMediaStreamTrack, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_observeMediaStreamTrackBody>(*lexicalGlobalObject, *callFrame, "observeMediaStreamTrack");
}

#endif

#if ENABLE(MEDIA_STREAM)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_mediaStreamTrackVideoFrameRotationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperationReturningPromise<JSInternals>::ClassParameter castedThis, Ref<DeferredPromise>&& promise)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLPromise<IDLShort>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, [&]() -> decltype(auto) { return impl.mediaStreamTrackVideoFrameRotation(WTFMove(promise)); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_mediaStreamTrackVideoFrameRotation, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperationReturningPromise<JSInternals>::call<jsInternalsPrototypeFunction_mediaStreamTrackVideoFrameRotationBody>(*lexicalGlobalObject, *callFrame, "mediaStreamTrackVideoFrameRotation");
}

#endif

#if ENABLE(MEDIA_STREAM)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_delayMediaStreamTrackSamplesBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto trackConversionResult = convert<IDLInterface<MediaStreamTrack>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "track"_s, "Internals"_s, "delayMediaStreamTrackSamples"_s, "MediaStreamTrack"_s); });
    if (trackConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto delayConversionResult = convert<IDLFloat>(*lexicalGlobalObject, argument1.value());
    if (delayConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.delayMediaStreamTrackSamples(*trackConversionResult.releaseReturnValue(), delayConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_delayMediaStreamTrackSamples, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_delayMediaStreamTrackSamplesBody>(*lexicalGlobalObject, *callFrame, "delayMediaStreamTrackSamples");
}

#endif

#if ENABLE(MEDIA_STREAM)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setMediaStreamTrackMutedBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto trackConversionResult = convert<IDLInterface<MediaStreamTrack>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "track"_s, "Internals"_s, "setMediaStreamTrackMuted"_s, "MediaStreamTrack"_s); });
    if (trackConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto mutedConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (mutedConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setMediaStreamTrackMuted(*trackConversionResult.releaseReturnValue(), mutedConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMediaStreamTrackMuted, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setMediaStreamTrackMutedBody>(*lexicalGlobalObject, *callFrame, "setMediaStreamTrackMuted");
}

#endif

#if ENABLE(MEDIA_STREAM)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_removeMediaStreamTrackBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto streamConversionResult = convert<IDLInterface<MediaStream>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "stream"_s, "Internals"_s, "removeMediaStreamTrack"_s, "MediaStream"_s); });
    if (streamConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto trackConversionResult = convert<IDLInterface<MediaStreamTrack>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "track"_s, "Internals"_s, "removeMediaStreamTrack"_s, "MediaStreamTrack"_s); });
    if (trackConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.removeMediaStreamTrack(*streamConversionResult.releaseReturnValue(), *trackConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_removeMediaStreamTrack, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_removeMediaStreamTrackBody>(*lexicalGlobalObject, *callFrame, "removeMediaStreamTrack");
}

#endif

#if ENABLE(MEDIA_STREAM)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_simulateMediaStreamTrackCaptureSourceFailureBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto trackConversionResult = convert<IDLInterface<MediaStreamTrack>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "track"_s, "Internals"_s, "simulateMediaStreamTrackCaptureSourceFailure"_s, "MediaStreamTrack"_s); });
    if (trackConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.simulateMediaStreamTrackCaptureSourceFailure(*trackConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_simulateMediaStreamTrackCaptureSourceFailure, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_simulateMediaStreamTrackCaptureSourceFailureBody>(*lexicalGlobalObject, *callFrame, "simulateMediaStreamTrackCaptureSourceFailure");
}

#endif

#if ENABLE(MEDIA_STREAM)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setMediaStreamTrackIdentifierBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto trackConversionResult = convert<IDLInterface<MediaStreamTrack>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "track"_s, "Internals"_s, "setMediaStreamTrackIdentifier"_s, "MediaStreamTrack"_s); });
    if (trackConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto identifierConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (identifierConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setMediaStreamTrackIdentifier(*trackConversionResult.releaseReturnValue(), identifierConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMediaStreamTrackIdentifier, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setMediaStreamTrackIdentifierBody>(*lexicalGlobalObject, *callFrame, "setMediaStreamTrackIdentifier");
}

#endif

#if ENABLE(MEDIA_STREAM)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setMediaStreamSourceInterruptedBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto trackConversionResult = convert<IDLInterface<MediaStreamTrack>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "track"_s, "Internals"_s, "setMediaStreamSourceInterrupted"_s, "MediaStreamTrack"_s); });
    if (trackConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto interruptedConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (interruptedConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setMediaStreamSourceInterrupted(*trackConversionResult.releaseReturnValue(), interruptedConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMediaStreamSourceInterrupted, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setMediaStreamSourceInterruptedBody>(*lexicalGlobalObject, *callFrame, "setMediaStreamSourceInterrupted");
}

#endif

#if ENABLE(MEDIA_STREAM)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isMediaStreamSourceInterruptedBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto trackConversionResult = convert<IDLInterface<MediaStreamTrack>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "track"_s, "Internals"_s, "isMediaStreamSourceInterrupted"_s, "MediaStreamTrack"_s); });
    if (trackConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isMediaStreamSourceInterrupted(*trackConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isMediaStreamSourceInterrupted, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isMediaStreamSourceInterruptedBody>(*lexicalGlobalObject, *callFrame, "isMediaStreamSourceInterrupted");
}

#endif

#if ENABLE(MEDIA_STREAM)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isMediaStreamSourceEndedBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto trackConversionResult = convert<IDLInterface<MediaStreamTrack>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "track"_s, "Internals"_s, "isMediaStreamSourceEnded"_s, "MediaStreamTrack"_s); });
    if (trackConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isMediaStreamSourceEnded(*trackConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isMediaStreamSourceEnded, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isMediaStreamSourceEndedBody>(*lexicalGlobalObject, *callFrame, "isMediaStreamSourceEnded");
}

#endif

#if ENABLE(MEDIA_STREAM)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isMockRealtimeMediaSourceCenterEnabledBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isMockRealtimeMediaSourceCenterEnabled())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isMockRealtimeMediaSourceCenterEnabled, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isMockRealtimeMediaSourceCenterEnabledBody>(*lexicalGlobalObject, *callFrame, "isMockRealtimeMediaSourceCenterEnabled");
}

#endif

#if ENABLE(MEDIA_STREAM)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_shouldAudioTrackPlayBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto trackConversionResult = convert<IDLInterface<AudioTrack>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "track"_s, "Internals"_s, "shouldAudioTrackPlay"_s, "AudioTrack"_s); });
    if (trackConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.shouldAudioTrackPlay(*trackConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_shouldAudioTrackPlay, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_shouldAudioTrackPlayBody>(*lexicalGlobalObject, *callFrame, "shouldAudioTrackPlay");
}

#endif

#if ENABLE(MEDIA_STREAM)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_mediaStreamTrackPersistentIdBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto trackConversionResult = convert<IDLInterface<MediaStreamTrack>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "track"_s, "Internals"_s, "mediaStreamTrackPersistentId"_s, "MediaStreamTrack"_s); });
    if (trackConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.mediaStreamTrackPersistentId(*trackConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_mediaStreamTrackPersistentId, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_mediaStreamTrackPersistentIdBody>(*lexicalGlobalObject, *callFrame, "mediaStreamTrackPersistentId");
}

#endif

#if ENABLE(MEDIA_STREAM)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_audioCaptureSourceCountBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.audioCaptureSourceCount())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_audioCaptureSourceCount, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_audioCaptureSourceCountBody>(*lexicalGlobalObject, *callFrame, "audioCaptureSourceCount");
}

#endif

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isHardwareVP9DecoderExpectedBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isHardwareVP9DecoderExpected())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isHardwareVP9DecoderExpected, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isHardwareVP9DecoderExpectedBody>(*lexicalGlobalObject, *callFrame, "isHardwareVP9DecoderExpected");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_documentIdentifierBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto documentConversionResult = convert<IDLInterface<Document>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "document"_s, "Internals"_s, "documentIdentifier"_s, "Document"_s); });
    if (documentConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.documentIdentifier(*documentConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_documentIdentifier, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_documentIdentifierBody>(*lexicalGlobalObject, *callFrame, "documentIdentifier");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isDocumentAliveBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto documentIdentifierConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (documentIdentifierConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isDocumentAlive(documentIdentifierConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isDocumentAlive, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isDocumentAliveBody>(*lexicalGlobalObject, *callFrame, "isDocumentAlive");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_messagePortIdentifierBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto portConversionResult = convert<IDLInterface<MessagePort>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "port"_s, "Internals"_s, "messagePortIdentifier"_s, "MessagePort"_s); });
    if (portConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLongLong>(*lexicalGlobalObject, throwScope, impl.messagePortIdentifier(*portConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_messagePortIdentifier, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_messagePortIdentifierBody>(*lexicalGlobalObject, *callFrame, "messagePortIdentifier");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isMessagePortAliveBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto messagePortIdentifierConversionResult = convert<IDLUnsignedLongLong>(*lexicalGlobalObject, argument0.value());
    if (messagePortIdentifierConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isMessagePortAlive(messagePortIdentifierConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isMessagePortAlive, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isMessagePortAliveBody>(*lexicalGlobalObject, *callFrame, "isMessagePortAlive");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_elementIdentifierBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "elementIdentifier"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLongLong>(*lexicalGlobalObject, throwScope, impl.elementIdentifier(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_elementIdentifier, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_elementIdentifierBody>(*lexicalGlobalObject, *callFrame, "elementIdentifier");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isElementAliveBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto nodeIdentifierConversionResult = convert<IDLUnsignedLongLong>(*lexicalGlobalObject, argument0.value());
    if (nodeIdentifierConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isElementAlive(nodeIdentifierConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isElementAlive, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isElementAliveBody>(*lexicalGlobalObject, *callFrame, "isElementAlive");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_pageIdentifierBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto documentConversionResult = convert<IDLInterface<Document>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "document"_s, "Internals"_s, "pageIdentifier"_s, "Document"_s); });
    if (documentConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLongLong>(*lexicalGlobalObject, throwScope, impl.pageIdentifier(*documentConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_pageIdentifier, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_pageIdentifierBody>(*lexicalGlobalObject, *callFrame, "pageIdentifier");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isAnyWorkletGlobalScopeAliveBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isAnyWorkletGlobalScopeAlive())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isAnyWorkletGlobalScopeAlive, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isAnyWorkletGlobalScopeAliveBody>(*lexicalGlobalObject, *callFrame, "isAnyWorkletGlobalScopeAlive");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_serviceWorkerClientInternalIdentifierBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto documentConversionResult = convert<IDLInterface<Document>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "document"_s, "Internals"_s, "serviceWorkerClientInternalIdentifier"_s, "Document"_s); });
    if (documentConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.serviceWorkerClientInternalIdentifier(*documentConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_serviceWorkerClientInternalIdentifier, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_serviceWorkerClientInternalIdentifierBody>(*lexicalGlobalObject, *callFrame, "serviceWorkerClientInternalIdentifier");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_storeRegistrationsOnDiskBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperationReturningPromise<JSInternals>::ClassParameter castedThis, Ref<DeferredPromise>&& promise)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLPromise<IDLUndefined>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, [&]() -> decltype(auto) { return impl.storeRegistrationsOnDisk(WTFMove(promise)); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_storeRegistrationsOnDisk, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperationReturningPromise<JSInternals>::call<jsInternalsPrototypeFunction_storeRegistrationsOnDiskBody>(*lexicalGlobalObject, *callFrame, "storeRegistrationsOnDisk");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_sendH2PingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperationReturningPromise<JSInternals>::ClassParameter castedThis, Ref<DeferredPromise>&& promise)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto urlConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (urlConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLPromise<IDLDouble>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, [&]() -> decltype(auto) { return impl.sendH2Ping(urlConversionResult.releaseReturnValue(), WTFMove(promise)); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_sendH2Ping, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperationReturningPromise<JSInternals>::call<jsInternalsPrototypeFunction_sendH2PingBody>(*lexicalGlobalObject, *callFrame, "sendH2Ping");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_clearCacheStorageMemoryRepresentationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperationReturningPromise<JSInternals>::ClassParameter castedThis, Ref<DeferredPromise>&& promise)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLPromise<IDLUndefined>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, [&]() -> decltype(auto) { return impl.clearCacheStorageMemoryRepresentation(WTFMove(promise)); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_clearCacheStorageMemoryRepresentation, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperationReturningPromise<JSInternals>::call<jsInternalsPrototypeFunction_clearCacheStorageMemoryRepresentationBody>(*lexicalGlobalObject, *callFrame, "clearCacheStorageMemoryRepresentation");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_cacheStorageEngineRepresentationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperationReturningPromise<JSInternals>::ClassParameter castedThis, Ref<DeferredPromise>&& promise)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLPromise<IDLDOMString>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, [&]() -> decltype(auto) { return impl.cacheStorageEngineRepresentation(WTFMove(promise)); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_cacheStorageEngineRepresentation, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperationReturningPromise<JSInternals>::call<jsInternalsPrototypeFunction_cacheStorageEngineRepresentationBody>(*lexicalGlobalObject, *callFrame, "cacheStorageEngineRepresentation");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setResponseSizeWithPaddingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto responseConversionResult = convert<IDLInterface<FetchResponse>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "response"_s, "Internals"_s, "setResponseSizeWithPadding"_s, "FetchResponse"_s); });
    if (responseConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto sizeConversionResult = convert<IDLUnsignedLongLong>(*lexicalGlobalObject, argument1.value());
    if (sizeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setResponseSizeWithPadding(*responseConversionResult.releaseReturnValue(), sizeConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setResponseSizeWithPadding, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setResponseSizeWithPaddingBody>(*lexicalGlobalObject, *callFrame, "setResponseSizeWithPadding");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_responseSizeWithPaddingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto responseConversionResult = convert<IDLInterface<FetchResponse>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "response"_s, "Internals"_s, "responseSizeWithPadding"_s, "FetchResponse"_s); });
    if (responseConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLongLong>(*lexicalGlobalObject, throwScope, impl.responseSizeWithPadding(*responseConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_responseSizeWithPadding, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_responseSizeWithPaddingBody>(*lexicalGlobalObject, *callFrame, "responseSizeWithPadding");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_responseNetworkLoadMetricsProtocolBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto responseConversionResult = convert<IDLInterface<FetchResponse>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "response"_s, "Internals"_s, "responseNetworkLoadMetricsProtocol"_s, "FetchResponse"_s); });
    if (responseConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.responseNetworkLoadMetricsProtocol(*responseConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_responseNetworkLoadMetricsProtocol, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_responseNetworkLoadMetricsProtocolBody>(*lexicalGlobalObject, *callFrame, "responseNetworkLoadMetricsProtocol");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_blobInternalURLBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto blobConversionResult = convert<IDLInterface<Blob>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "blob"_s, "Internals"_s, "blobInternalURL"_s, "Blob"_s); });
    if (blobConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.blobInternalURL(*blobConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_blobInternalURL, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_blobInternalURLBody>(*lexicalGlobalObject, *callFrame, "blobInternalURL");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isBlobInternalURLRegisteredBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperationReturningPromise<JSInternals>::ClassParameter castedThis, Ref<DeferredPromise>&& promise)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto urlConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (urlConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLPromise<IDLBoolean>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, [&]() -> decltype(auto) { return impl.isBlobInternalURLRegistered(urlConversionResult.releaseReturnValue(), WTFMove(promise)); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isBlobInternalURLRegistered, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperationReturningPromise<JSInternals>::call<jsInternalsPrototypeFunction_isBlobInternalURLRegisteredBody>(*lexicalGlobalObject, *callFrame, "isBlobInternalURLRegistered");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_updateQuotaBasedOnSpaceUsageBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.updateQuotaBasedOnSpaceUsage(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_updateQuotaBasedOnSpaceUsage, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_updateQuotaBasedOnSpaceUsageBody>(*lexicalGlobalObject, *callFrame, "updateQuotaBasedOnSpaceUsage");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setConsoleMessageListenerBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto callbackConversionResult = convert<IDLNullable<IDLCallbackFunction<JSStringCallback>>>(*lexicalGlobalObject, argument0.value(), *castedThis->globalObject(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentMustBeFunctionError(lexicalGlobalObject, scope, 0, "callback"_s, "Internals"_s, "setConsoleMessageListener"_s); });
    if (callbackConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setConsoleMessageListener(callbackConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setConsoleMessageListener, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setConsoleMessageListenerBody>(*lexicalGlobalObject, *callFrame, "setConsoleMessageListener");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_audioSessionCategoryBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLEnumeration<Internals::AudioSessionCategory>>(*lexicalGlobalObject, throwScope, impl.audioSessionCategory())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_audioSessionCategory, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_audioSessionCategoryBody>(*lexicalGlobalObject, *callFrame, "audioSessionCategory");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_audioSessionModeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLEnumeration<Internals::AudioSessionMode>>(*lexicalGlobalObject, throwScope, impl.audioSessionMode())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_audioSessionMode, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_audioSessionModeBody>(*lexicalGlobalObject, *callFrame, "audioSessionMode");
}

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_categoryAtMostRecentPlaybackBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "categoryAtMostRecentPlayback"_s, "HTMLMediaElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLEnumeration<Internals::AudioSessionCategory>>(*lexicalGlobalObject, throwScope, impl.categoryAtMostRecentPlayback(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_categoryAtMostRecentPlayback, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_categoryAtMostRecentPlaybackBody>(*lexicalGlobalObject, *callFrame, "categoryAtMostRecentPlayback");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_modeAtMostRecentPlaybackBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "modeAtMostRecentPlayback"_s, "HTMLMediaElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLEnumeration<Internals::AudioSessionMode>>(*lexicalGlobalObject, throwScope, impl.modeAtMostRecentPlayback(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_modeAtMostRecentPlayback, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_modeAtMostRecentPlaybackBody>(*lexicalGlobalObject, *callFrame, "modeAtMostRecentPlayback");
}

#endif

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_routeSharingPolicyBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLEnumeration<Internals::RouteSharingPolicy>>(*lexicalGlobalObject, throwScope, impl.routeSharingPolicy())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_routeSharingPolicy, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_routeSharingPolicyBody>(*lexicalGlobalObject, *callFrame, "routeSharingPolicy");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_preferredAudioBufferSizeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDouble>(*lexicalGlobalObject, throwScope, impl.preferredAudioBufferSize())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_preferredAudioBufferSize, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_preferredAudioBufferSizeBody>(*lexicalGlobalObject, *callFrame, "preferredAudioBufferSize");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_currentAudioBufferSizeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDouble>(*lexicalGlobalObject, throwScope, impl.currentAudioBufferSize())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_currentAudioBufferSize, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_currentAudioBufferSizeBody>(*lexicalGlobalObject, *callFrame, "currentAudioBufferSize");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_audioSessionActiveBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.audioSessionActive())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_audioSessionActive, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_audioSessionActiveBody>(*lexicalGlobalObject, *callFrame, "audioSessionActive");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_hasServiceWorkerRegistrationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperationReturningPromise<JSInternals>::ClassParameter castedThis, Ref<DeferredPromise>&& promise)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto scopeURLConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (scopeURLConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLPromise<IDLBoolean>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, [&]() -> decltype(auto) { return impl.hasServiceWorkerRegistration(scopeURLConversionResult.releaseReturnValue(), WTFMove(promise)); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasServiceWorkerRegistration, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperationReturningPromise<JSInternals>::call<jsInternalsPrototypeFunction_hasServiceWorkerRegistrationBody>(*lexicalGlobalObject, *callFrame, "hasServiceWorkerRegistration");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_terminateServiceWorkerBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperationReturningPromise<JSInternals>::ClassParameter castedThis, Ref<DeferredPromise>&& promise)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto workerConversionResult = convert<IDLInterface<ServiceWorker>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "worker"_s, "Internals"_s, "terminateServiceWorker"_s, "ServiceWorker"_s); });
    if (workerConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLPromise<IDLUndefined>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, [&]() -> decltype(auto) { return impl.terminateServiceWorker(*workerConversionResult.releaseReturnValue(), WTFMove(promise)); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_terminateServiceWorker, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperationReturningPromise<JSInternals>::call<jsInternalsPrototypeFunction_terminateServiceWorkerBody>(*lexicalGlobalObject, *callFrame, "terminateServiceWorker");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_whenServiceWorkerIsTerminatedBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperationReturningPromise<JSInternals>::ClassParameter castedThis, Ref<DeferredPromise>&& promise)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto workerConversionResult = convert<IDLInterface<ServiceWorker>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "worker"_s, "Internals"_s, "whenServiceWorkerIsTerminated"_s, "ServiceWorker"_s); });
    if (workerConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLPromise<IDLUndefined>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, [&]() -> decltype(auto) { return impl.whenServiceWorkerIsTerminated(*workerConversionResult.releaseReturnValue(), WTFMove(promise)); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_whenServiceWorkerIsTerminated, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperationReturningPromise<JSInternals>::call<jsInternalsPrototypeFunction_whenServiceWorkerIsTerminatedBody>(*lexicalGlobalObject, *callFrame, "whenServiceWorkerIsTerminated");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_terminateWebContentProcessBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.terminateWebContentProcess(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_terminateWebContentProcess, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_terminateWebContentProcessBody>(*lexicalGlobalObject, *callFrame, "terminateWebContentProcess");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isSystemPreviewLinkBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "isSystemPreviewLink"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isSystemPreviewLink(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isSystemPreviewLink, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isSystemPreviewLinkBody>(*lexicalGlobalObject, *callFrame, "isSystemPreviewLink");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isSystemPreviewImageBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "isSystemPreviewImage"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isSystemPreviewImage(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isSystemPreviewImage, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isSystemPreviewImageBody>(*lexicalGlobalObject, *callFrame, "isSystemPreviewImage");
}

#if ENABLE(IMAGE_ANALYSIS)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_requestTextRecognitionBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "requestTextRecognition"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto callbackConversionResult = convert<IDLCallbackFunction<JSVoidCallback>>(*lexicalGlobalObject, argument1.value(), *castedThis->globalObject(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentMustBeFunctionError(lexicalGlobalObject, scope, 1, "callback"_s, "Internals"_s, "requestTextRecognition"_s); });
    if (callbackConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.requestTextRecognition(*elementConversionResult.releaseReturnValue(), callbackConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_requestTextRecognition, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_requestTextRecognitionBody>(*lexicalGlobalObject, *callFrame, "requestTextRecognition");
}

#endif

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_installImageOverlayBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "installImageOverlay"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto linesConversionResult = convert<IDLSequence<IDLDictionary<Internals::ImageOverlayLine>>>(*lexicalGlobalObject, argument1.value());
    if (linesConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->argument(2);
    auto blocksConversionResult = convertOptionalWithDefault<IDLSequence<IDLDictionary<Internals::ImageOverlayBlock>>>(*lexicalGlobalObject, argument2.value(), [&]() -> ConversionResult<IDLSequence<IDLDictionary<Internals::ImageOverlayBlock>>> { return Converter<IDLSequence<IDLDictionary<Internals::ImageOverlayBlock>>>::ReturnType { }; });
    if (blocksConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->argument(3);
    auto dataDetectorsConversionResult = convertOptionalWithDefault<IDLSequence<IDLDictionary<Internals::ImageOverlayDataDetector>>>(*lexicalGlobalObject, argument3.value(), [&]() -> ConversionResult<IDLSequence<IDLDictionary<Internals::ImageOverlayDataDetector>>> { return Converter<IDLSequence<IDLDictionary<Internals::ImageOverlayDataDetector>>>::ReturnType { }; });
    if (dataDetectorsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.installImageOverlay(*elementConversionResult.releaseReturnValue(), linesConversionResult.releaseReturnValue(), blocksConversionResult.releaseReturnValue(), dataDetectorsConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_installImageOverlay, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_installImageOverlayBody>(*lexicalGlobalObject, *callFrame, "installImageOverlay");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_usingAppleInternalSDKBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.usingAppleInternalSDK())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_usingAppleInternalSDK, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_usingAppleInternalSDKBody>(*lexicalGlobalObject, *callFrame, "usingAppleInternalSDK");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_usingGStreamerBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.usingGStreamer())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_usingGStreamer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_usingGStreamerBody>(*lexicalGlobalObject, *callFrame, "usingGStreamer");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_postTaskBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto callbackConversionResult = convert<IDLCallbackFunction<JSVoidCallback>>(*lexicalGlobalObject, argument0.value(), *castedThis->globalObject(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentMustBeFunctionError(lexicalGlobalObject, scope, 0, "callback"_s, "Internals"_s, "postTask"_s); });
    if (callbackConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.postTask(callbackConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_postTask, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_postTaskBody>(*lexicalGlobalObject, *callFrame, "postTask");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_queueTaskBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    auto* context = jsCast<JSDOMGlobalObject*>(lexicalGlobalObject)->scriptExecutionContext();
    if (!context) [[unlikely]]
        return JSValue::encode(jsUndefined());
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto sourceConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (sourceConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto callbackConversionResult = convert<IDLCallbackFunction<JSVoidCallback>>(*lexicalGlobalObject, argument1.value(), *castedThis->globalObject(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentMustBeFunctionError(lexicalGlobalObject, scope, 1, "callback"_s, "Internals"_s, "queueTask"_s); });
    if (callbackConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.queueTask(*context, sourceConversionResult.releaseReturnValue(), callbackConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_queueTask, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_queueTaskBody>(*lexicalGlobalObject, *callFrame, "queueTask");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_queueTaskToQueueMicrotaskBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    RefPtr context = jsCast<JSDOMGlobalObject*>(lexicalGlobalObject)->scriptExecutionContext();
    if (!context) [[unlikely]]
        return JSValue::encode(jsUndefined());
    Ref document = downcast<Document>(*context);
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto sourceConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (sourceConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto callbackConversionResult = convert<IDLCallbackFunction<JSVoidCallback>>(*lexicalGlobalObject, argument1.value(), *castedThis->globalObject(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentMustBeFunctionError(lexicalGlobalObject, scope, 1, "callback"_s, "Internals"_s, "queueTaskToQueueMicrotask"_s); });
    if (callbackConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.queueTaskToQueueMicrotask(document.get(), sourceConversionResult.releaseReturnValue(), callbackConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_queueTaskToQueueMicrotask, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_queueTaskToQueueMicrotaskBody>(*lexicalGlobalObject, *callFrame, "queueTaskToQueueMicrotask");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_hasSameEventLoopAsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto windowProxyConversionResult = convert<IDLInterface<WindowProxy>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "windowProxy"_s, "Internals"_s, "hasSameEventLoopAs"_s, "WindowProxy"_s); });
    if (windowProxyConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.hasSameEventLoopAs(*windowProxyConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasSameEventLoopAs, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_hasSameEventLoopAsBody>(*lexicalGlobalObject, *callFrame, "hasSameEventLoopAs");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_windowLocationHostBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto windowConversionResult = convert<IDLInterface<DOMWindow>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "window"_s, "Internals"_s, "windowLocationHost"_s, "DOMWindow"_s); });
    if (windowConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.windowLocationHost(*windowConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_windowLocationHost, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_windowLocationHostBody>(*lexicalGlobalObject, *callFrame, "windowLocationHost");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_markContextAsInsecureBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.markContextAsInsecure(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_markContextAsInsecure, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_markContextAsInsecureBody>(*lexicalGlobalObject, *callFrame, "markContextAsInsecure");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setMaxCanvasAreaBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto sizeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (sizeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setMaxCanvasArea(sizeConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMaxCanvasArea, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setMaxCanvasAreaBody>(*lexicalGlobalObject, *callFrame, "setMaxCanvasArea");
}

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_elementIsActiveNowPlayingSessionBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "elementIsActiveNowPlayingSession"_s, "HTMLMediaElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.elementIsActiveNowPlayingSession(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_elementIsActiveNowPlayingSession, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_elementIsActiveNowPlayingSessionBody>(*lexicalGlobalObject, *callFrame, "elementIsActiveNowPlayingSession");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_bestMediaElementForRemoteControlsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto purposeConversionResult = convert<IDLEnumeration<Internals::PlaybackControlsPurpose>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentMustBeEnumError(lexicalGlobalObject, scope, 0, "purpose"_s, "Internals"_s, "bestMediaElementForRemoteControls"_s, expectedEnumerationValues<Internals::PlaybackControlsPurpose>()); });
    if (purposeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.bestMediaElementForRemoteControls(purposeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_bestMediaElementForRemoteControls, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_bestMediaElementForRemoteControlsBody>(*lexicalGlobalObject, *callFrame, "bestMediaElementForRemoteControls");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_mediaSessionStateBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "mediaSessionState"_s, "HTMLMediaElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLEnumeration<Internals::MediaSessionState>>(*lexicalGlobalObject, throwScope, impl.mediaSessionState(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_mediaSessionState, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_mediaSessionStateBody>(*lexicalGlobalObject, *callFrame, "mediaSessionState");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_mediaUsageStateBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "mediaUsageState"_s, "HTMLMediaElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDictionary<Internals::MediaUsageState>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.mediaUsageState(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_mediaUsageState, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_mediaUsageStateBody>(*lexicalGlobalObject, *callFrame, "mediaUsageState");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_elementShouldDisplayPosterImageBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLVideoElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "elementShouldDisplayPosterImage"_s, "HTMLVideoElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.elementShouldDisplayPosterImage(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_elementShouldDisplayPosterImage, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_elementShouldDisplayPosterImageBody>(*lexicalGlobalObject, *callFrame, "elementShouldDisplayPosterImage");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setMediaElementVolumeLockedBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "setMediaElementVolumeLocked"_s, "HTMLMediaElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto volumeLockedConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (volumeLockedConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setMediaElementVolumeLocked(*elementConversionResult.releaseReturnValue(), volumeLockedConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMediaElementVolumeLocked, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setMediaElementVolumeLockedBody>(*lexicalGlobalObject, *callFrame, "setMediaElementVolumeLocked");
}

#endif

#if ENABLE(SPEECH_SYNTHESIS)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_speechSynthesisUtteranceForCueBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto cueConversionResult = convert<IDLInterface<VTTCue>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "cue"_s, "Internals"_s, "speechSynthesisUtteranceForCue"_s, "VTTCue"_s); });
    if (cueConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<SpeechSynthesisUtterance>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.speechSynthesisUtteranceForCue(*cueConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_speechSynthesisUtteranceForCue, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_speechSynthesisUtteranceForCueBody>(*lexicalGlobalObject, *callFrame, "speechSynthesisUtteranceForCue");
}

#endif

#if ENABLE(SPEECH_SYNTHESIS)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_mediaElementCurrentlySpokenCueBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto mediaConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "media"_s, "Internals"_s, "mediaElementCurrentlySpokenCue"_s, "HTMLMediaElement"_s); });
    if (mediaConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<VTTCue>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.mediaElementCurrentlySpokenCue(*mediaConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_mediaElementCurrentlySpokenCue, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_mediaElementCurrentlySpokenCueBody>(*lexicalGlobalObject, *callFrame, "mediaElementCurrentlySpokenCue");
}

#endif

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_ongoingLoadsDescriptionsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.ongoingLoadsDescriptions())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_ongoingLoadsDescriptions, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_ongoingLoadsDescriptionsBody>(*lexicalGlobalObject, *callFrame, "ongoingLoadsDescriptions");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setCaptureExtraNetworkLoadMetricsEnabledBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto valueConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (valueConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setCaptureExtraNetworkLoadMetricsEnabled(valueConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setCaptureExtraNetworkLoadMetricsEnabled, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setCaptureExtraNetworkLoadMetricsEnabledBody>(*lexicalGlobalObject, *callFrame, "setCaptureExtraNetworkLoadMetricsEnabled");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_reloadWithoutContentExtensionsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.reloadWithoutContentExtensions(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_reloadWithoutContentExtensions, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_reloadWithoutContentExtensionsBody>(*lexicalGlobalObject, *callFrame, "reloadWithoutContentExtensions");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_disableContentExtensionsChecksBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.disableContentExtensionsChecks(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_disableContentExtensionsChecks, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_disableContentExtensionsChecksBody>(*lexicalGlobalObject, *callFrame, "disableContentExtensionsChecks");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_pluginCountBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.pluginCount())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_pluginCount, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_pluginCountBody>(*lexicalGlobalObject, *callFrame, "pluginCount");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_pluginScrollPositionXBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "pluginScrollPositionX"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.pluginScrollPositionX(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_pluginScrollPositionX, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_pluginScrollPositionXBody>(*lexicalGlobalObject, *callFrame, "pluginScrollPositionX");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_pluginScrollPositionYBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "pluginScrollPositionY"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.pluginScrollPositionY(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_pluginScrollPositionY, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_pluginScrollPositionYBody>(*lexicalGlobalObject, *callFrame, "pluginScrollPositionY");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_notifyResourceLoadObserverBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.notifyResourceLoadObserver(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_notifyResourceLoadObserver, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_notifyResourceLoadObserverBody>(*lexicalGlobalObject, *callFrame, "notifyResourceLoadObserver");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_primaryScreenDisplayIDBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.primaryScreenDisplayID())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_primaryScreenDisplayID, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_primaryScreenDisplayIDBody>(*lexicalGlobalObject, *callFrame, "primaryScreenDisplayID");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_capsLockIsOnBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.capsLockIsOn())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_capsLockIsOn, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_capsLockIsOnBody>(*lexicalGlobalObject, *callFrame, "capsLockIsOn");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_parseHEVCCodecParametersBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto codecParametersConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (codecParametersConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLDictionary<Internals::HEVCParameterSet>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.parseHEVCCodecParameters(codecParametersConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_parseHEVCCodecParameters, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_parseHEVCCodecParametersBody>(*lexicalGlobalObject, *callFrame, "parseHEVCCodecParameters");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_createHEVCCodecParametersStringBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto parametersConversionResult = convert<IDLDictionary<Internals::HEVCParameterSet>>(*lexicalGlobalObject, argument0.value());
    if (parametersConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.createHEVCCodecParametersString(parametersConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_createHEVCCodecParametersString, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_createHEVCCodecParametersStringBody>(*lexicalGlobalObject, *callFrame, "createHEVCCodecParametersString");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_parseDoViCodecParametersBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto codecParametersConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (codecParametersConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLDictionary<Internals::DoViParameterSet>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.parseDoViCodecParameters(codecParametersConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_parseDoViCodecParameters, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_parseDoViCodecParametersBody>(*lexicalGlobalObject, *callFrame, "parseDoViCodecParameters");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_createDoViCodecParametersStringBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto parametersConversionResult = convert<IDLDictionary<Internals::DoViParameterSet>>(*lexicalGlobalObject, argument0.value());
    if (parametersConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.createDoViCodecParametersString(parametersConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_createDoViCodecParametersString, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_createDoViCodecParametersStringBody>(*lexicalGlobalObject, *callFrame, "createDoViCodecParametersString");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_parseVPCodecParametersBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto codecParametersConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (codecParametersConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLDictionary<Internals::VPCodecConfigurationRecord>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.parseVPCodecParameters(codecParametersConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_parseVPCodecParameters, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_parseVPCodecParametersBody>(*lexicalGlobalObject, *callFrame, "parseVPCodecParameters");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_parseAV1CodecParametersBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto codecParametersConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (codecParametersConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLDictionary<Internals::AV1CodecConfigurationRecord>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.parseAV1CodecParameters(codecParametersConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_parseAV1CodecParameters, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_parseAV1CodecParametersBody>(*lexicalGlobalObject, *callFrame, "parseAV1CodecParameters");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_createAV1CodecParametersStringBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto parametersConversionResult = convert<IDLDictionary<Internals::AV1CodecConfigurationRecord>>(*lexicalGlobalObject, argument0.value());
    if (parametersConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.createAV1CodecParametersString(parametersConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_createAV1CodecParametersString, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_createAV1CodecParametersStringBody>(*lexicalGlobalObject, *callFrame, "createAV1CodecParametersString");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_validateAV1ConfigurationRecordBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto codecParametersConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (codecParametersConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.validateAV1ConfigurationRecord(codecParametersConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_validateAV1ConfigurationRecord, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_validateAV1ConfigurationRecordBody>(*lexicalGlobalObject, *callFrame, "validateAV1ConfigurationRecord");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_validateAV1PerLevelConstraintsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto codecParametersConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (codecParametersConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto configurationConversionResult = convert<IDLDictionary<VideoConfiguration>>(*lexicalGlobalObject, argument1.value());
    if (configurationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.validateAV1PerLevelConstraints(codecParametersConversionResult.releaseReturnValue(), configurationConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_validateAV1PerLevelConstraints, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_validateAV1PerLevelConstraintsBody>(*lexicalGlobalObject, *callFrame, "validateAV1PerLevelConstraints");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setCookieBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto cookieDataConversionResult = convert<IDLDictionary<Internals::CookieData>>(*lexicalGlobalObject, argument0.value());
    if (cookieDataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setCookie(cookieDataConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setCookie, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setCookieBody>(*lexicalGlobalObject, *callFrame, "setCookie");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_getCookiesBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLSequence<IDLDictionary<Internals::CookieData>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getCookies())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_getCookies, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_getCookiesBody>(*lexicalGlobalObject, *callFrame, "getCookies");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setAlwaysAllowLocalWebarchiveBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto alwaysAllowLocalWebarchiveConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (alwaysAllowLocalWebarchiveConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setAlwaysAllowLocalWebarchive(alwaysAllowLocalWebarchiveConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setAlwaysAllowLocalWebarchive, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setAlwaysAllowLocalWebarchiveBody>(*lexicalGlobalObject, *callFrame, "setAlwaysAllowLocalWebarchive");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_processWillSuspendBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.processWillSuspend(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_processWillSuspend, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_processWillSuspendBody>(*lexicalGlobalObject, *callFrame, "processWillSuspend");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_processDidResumeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.processDidResume(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_processDidResume, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_processDidResumeBody>(*lexicalGlobalObject, *callFrame, "processDidResume");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_testDictionaryLoggingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.testDictionaryLogging(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_testDictionaryLogging, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_testDictionaryLoggingBody>(*lexicalGlobalObject, *callFrame, "testDictionaryLogging");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setMaximumIntervalForUserGestureForwardingForFetchBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto intervalConversionResult = convert<IDLDouble>(*lexicalGlobalObject, argument0.value());
    if (intervalConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setMaximumIntervalForUserGestureForwardingForFetch(intervalConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMaximumIntervalForUserGestureForwardingForFetch, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setMaximumIntervalForUserGestureForwardingForFetchBody>(*lexicalGlobalObject, *callFrame, "setMaximumIntervalForUserGestureForwardingForFetch");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setTransientActivationDurationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto secondsConversionResult = convert<IDLDouble>(*lexicalGlobalObject, argument0.value());
    if (secondsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setTransientActivationDuration(secondsConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setTransientActivationDuration, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setTransientActivationDurationBody>(*lexicalGlobalObject, *callFrame, "setTransientActivationDuration");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setIsPlayingToAutomotiveHeadUnitBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto valueConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (valueConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setIsPlayingToAutomotiveHeadUnit(valueConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setIsPlayingToAutomotiveHeadUnit, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setIsPlayingToAutomotiveHeadUnitBody>(*lexicalGlobalObject, *callFrame, "setIsPlayingToAutomotiveHeadUnit");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_textIndicatorForRangeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto rangeConversionResult = convert<IDLInterface<Range>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "range"_s, "Internals"_s, "textIndicatorForRange"_s, "Range"_s); });
    if (rangeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto optionsConversionResult = convert<IDLDictionary<Internals::TextIndicatorOptions>>(*lexicalGlobalObject, argument1.value());
    if (optionsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDictionary<Internals::TextIndicatorInfo>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.textIndicatorForRange(*rangeConversionResult.releaseReturnValue(), optionsConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_textIndicatorForRange, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_textIndicatorForRangeBody>(*lexicalGlobalObject, *callFrame, "textIndicatorForRange");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_addPrefetchLoadEventListenerBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto linkConversionResult = convert<IDLInterface<HTMLLinkElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "link"_s, "Internals"_s, "addPrefetchLoadEventListener"_s, "HTMLLinkElement"_s); });
    if (linkConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto callbackConversionResult = convert<IDLNullable<IDLEventListener<JSEventListener>>>(*lexicalGlobalObject, argument1.value(), *castedThis, [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentMustBeObjectError(lexicalGlobalObject, scope, 1, "callback"_s, "Internals"_s, "addPrefetchLoadEventListener"_s); });
    if (callbackConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    auto result = JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.addPrefetchLoadEventListener(*linkConversionResult.releaseReturnValue(), callbackConversionResult.releaseReturnValue()); }));
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    vm.writeBarrier(&static_cast<JSObject&>(*castedThis), argument1.value());
    return result;
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_addPrefetchLoadEventListener, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_addPrefetchLoadEventListenerBody>(*lexicalGlobalObject, *callFrame, "addPrefetchLoadEventListener");
}

#if ENABLE(WEB_AUTHN)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setMockWebAuthenticationConfigurationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto configurationConversionResult = convert<IDLDictionary<MockWebAuthenticationConfiguration>>(*lexicalGlobalObject, argument0.value());
    if (configurationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setMockWebAuthenticationConfiguration(configurationConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMockWebAuthenticationConfiguration, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setMockWebAuthenticationConfigurationBody>(*lexicalGlobalObject, *callFrame, "setMockWebAuthenticationConfiguration");
}

#endif

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_createInternalsMapLikeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<InternalsMapLike>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.createInternalsMapLike())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_createInternalsMapLike, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_createInternalsMapLikeBody>(*lexicalGlobalObject, *callFrame, "createInternalsMapLike");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_createInternalsSetLikeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<InternalsSetLike>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.createInternalsSetLike())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_createInternalsSetLike, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_createInternalsSetLikeBody>(*lexicalGlobalObject, *callFrame, "createInternalsSetLike");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_highlightPseudoElementColorBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto highlightNameConversionResult = convert<IDLAtomStringAdaptor<IDLDOMString>>(*lexicalGlobalObject, argument0.value());
    if (highlightNameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "element"_s, "Internals"_s, "highlightPseudoElementColor"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.highlightPseudoElementColor(highlightNameConversionResult.releaseReturnValue(), *elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_highlightPseudoElementColor, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_highlightPseudoElementColorBody>(*lexicalGlobalObject, *callFrame, "highlightPseudoElementColor");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_hasSandboxMachLookupAccessToGlobalNameBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto processConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (processConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto serviceConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (serviceConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.hasSandboxMachLookupAccessToGlobalName(processConversionResult.releaseReturnValue(), serviceConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasSandboxMachLookupAccessToGlobalName, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_hasSandboxMachLookupAccessToGlobalNameBody>(*lexicalGlobalObject, *callFrame, "hasSandboxMachLookupAccessToGlobalName");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_hasSandboxMachLookupAccessToXPCServiceNameBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto processConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (processConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto serviceConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (serviceConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.hasSandboxMachLookupAccessToXPCServiceName(processConversionResult.releaseReturnValue(), serviceConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasSandboxMachLookupAccessToXPCServiceName, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_hasSandboxMachLookupAccessToXPCServiceNameBody>(*lexicalGlobalObject, *callFrame, "hasSandboxMachLookupAccessToXPCServiceName");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_hasSandboxIOKitOpenAccessToClassBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto processConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (processConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto ioKitClassConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (ioKitClassConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.hasSandboxIOKitOpenAccessToClass(processConversionResult.releaseReturnValue(), ioKitClassConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasSandboxIOKitOpenAccessToClass, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_hasSandboxIOKitOpenAccessToClassBody>(*lexicalGlobalObject, *callFrame, "hasSandboxIOKitOpenAccessToClass");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_hasSandboxUnixSyscallAccessBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto processConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (processConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto syscallConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (syscallConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.hasSandboxUnixSyscallAccess(processConversionResult.releaseReturnValue(), syscallConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasSandboxUnixSyscallAccess, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_hasSandboxUnixSyscallAccessBody>(*lexicalGlobalObject, *callFrame, "hasSandboxUnixSyscallAccess");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_systemColorForCSSValueBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto cssValueConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (cssValueConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto useDarkModeAppearanceConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (useDarkModeAppearanceConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto useElevatedUserInterfaceLevelConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument2.value());
    if (useElevatedUserInterfaceLevelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.systemColorForCSSValue(cssValueConversionResult.releaseReturnValue(), useDarkModeAppearanceConversionResult.releaseReturnValue(), useElevatedUserInterfaceLevelConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_systemColorForCSSValue, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_systemColorForCSSValueBody>(*lexicalGlobalObject, *callFrame, "systemColorForCSSValue");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_focusRingColorBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.focusRingColor())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_focusRingColor, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_focusRingColorBody>(*lexicalGlobalObject, *callFrame, "focusRingColor");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_systemHasBatteryBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.systemHasBattery())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_systemHasBattery, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_systemHasBatteryBody>(*lexicalGlobalObject, *callFrame, "systemHasBattery");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setSystemHasBatteryForTestingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto hasBatteryConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (hasBatteryConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setSystemHasBatteryForTesting(hasBatteryConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setSystemHasBatteryForTesting, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setSystemHasBatteryForTestingBody>(*lexicalGlobalObject, *callFrame, "setSystemHasBatteryForTesting");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setSystemHasACForTestingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto hasACConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (hasACConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setSystemHasACForTesting(hasACConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setSystemHasACForTesting, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setSystemHasACForTestingBody>(*lexicalGlobalObject, *callFrame, "setSystemHasACForTesting");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setHardwareVP9DecoderDisabledForTestingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto disabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (disabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setHardwareVP9DecoderDisabledForTesting(disabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setHardwareVP9DecoderDisabledForTesting, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setHardwareVP9DecoderDisabledForTestingBody>(*lexicalGlobalObject, *callFrame, "setHardwareVP9DecoderDisabledForTesting");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setVP9DecoderDisabledForTestingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto disabledConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (disabledConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setVP9DecoderDisabledForTesting(disabledConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setVP9DecoderDisabledForTesting, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setVP9DecoderDisabledForTestingBody>(*lexicalGlobalObject, *callFrame, "setVP9DecoderDisabledForTesting");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setVP9ScreenSizeAndScaleForTestingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto widthConversionResult = convert<IDLDouble>(*lexicalGlobalObject, argument0.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto heightConversionResult = convert<IDLDouble>(*lexicalGlobalObject, argument1.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto scaleConversionResult = convert<IDLDouble>(*lexicalGlobalObject, argument2.value());
    if (scaleConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setVP9ScreenSizeAndScaleForTesting(widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), scaleConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setVP9ScreenSizeAndScaleForTesting, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setVP9ScreenSizeAndScaleForTestingBody>(*lexicalGlobalObject, *callFrame, "setVP9ScreenSizeAndScaleForTesting");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_readPreferenceIntegerBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto domainConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (domainConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto keyConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (keyConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLLong>(*lexicalGlobalObject, throwScope, impl.readPreferenceInteger(domainConversionResult.releaseReturnValue(), keyConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_readPreferenceInteger, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_readPreferenceIntegerBody>(*lexicalGlobalObject, *callFrame, "readPreferenceInteger");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_encodedPreferenceValueBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto domainConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (domainConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto keyConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (keyConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.encodedPreferenceValue(domainConversionResult.releaseReturnValue(), keyConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_encodedPreferenceValue, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_encodedPreferenceValueBody>(*lexicalGlobalObject, *callFrame, "encodedPreferenceValue");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_supportsPictureInPictureBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.supportsPictureInPicture())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_supportsPictureInPicture, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_supportsPictureInPictureBody>(*lexicalGlobalObject, *callFrame, "supportsPictureInPicture");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isRemoteUIAppForAccessibilityBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isRemoteUIAppForAccessibility())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isRemoteUIAppForAccessibility, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isRemoteUIAppForAccessibilityBody>(*lexicalGlobalObject, *callFrame, "isRemoteUIAppForAccessibility");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_createSleepDisablerBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto reasonConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (reasonConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto displayConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (displayConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.createSleepDisabler(reasonConversionResult.releaseReturnValue(), displayConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_createSleepDisabler, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_createSleepDisablerBody>(*lexicalGlobalObject, *callFrame, "createSleepDisabler");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_destroySleepDisablerBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto identifierConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (identifierConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.destroySleepDisabler(identifierConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_destroySleepDisabler, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_destroySleepDisablerBody>(*lexicalGlobalObject, *callFrame, "destroySleepDisabler");
}

#if ENABLE(APP_HIGHLIGHTS)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_numberOfAppHighlightsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.numberOfAppHighlights())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_numberOfAppHighlights, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_numberOfAppHighlightsBody>(*lexicalGlobalObject, *callFrame, "numberOfAppHighlights");
}

#endif

#if ENABLE(ENCRYPTED_MEDIA)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_mediaKeysInternalInstanceObjectRefCountBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto mediaKeysConversionResult = convert<IDLInterface<MediaKeys>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "mediaKeys"_s, "Internals"_s, "mediaKeysInternalInstanceObjectRefCount"_s, "MediaKeys"_s); });
    if (mediaKeysConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.mediaKeysInternalInstanceObjectRefCount(*mediaKeysConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_mediaKeysInternalInstanceObjectRefCount, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_mediaKeysInternalInstanceObjectRefCountBody>(*lexicalGlobalObject, *callFrame, "mediaKeysInternalInstanceObjectRefCount");
}

#endif

#if ENABLE(ENCRYPTED_MEDIA)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_mediaKeySessionInternalInstanceSessionObjectRefCountBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto sessionConversionResult = convert<IDLInterface<MediaKeySession>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "session"_s, "Internals"_s, "mediaKeySessionInternalInstanceSessionObjectRefCount"_s, "MediaKeySession"_s); });
    if (sessionConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.mediaKeySessionInternalInstanceSessionObjectRefCount(*sessionConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_mediaKeySessionInternalInstanceSessionObjectRefCount, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_mediaKeySessionInternalInstanceSessionObjectRefCountBody>(*lexicalGlobalObject, *callFrame, "mediaKeySessionInternalInstanceSessionObjectRefCount");
}

#endif

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setContentSizeCategoryBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto categoryConversionResult = convert<IDLEnumeration<Internals::ContentSizeCategory>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentMustBeEnumError(lexicalGlobalObject, scope, 0, "category"_s, "Internals"_s, "setContentSizeCategory"_s, expectedEnumerationValues<Internals::ContentSizeCategory>()); });
    if (categoryConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setContentSizeCategory(categoryConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setContentSizeCategory, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setContentSizeCategoryBody>(*lexicalGlobalObject, *callFrame, "setContentSizeCategory");
}

#if ENABLE(SERVICE_CONTROLS)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_hasImageControlsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLImageElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "hasImageControls"_s, "HTMLImageElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.hasImageControls(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasImageControls, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_hasImageControlsBody>(*lexicalGlobalObject, *callFrame, "hasImageControls");
}

#endif

#if ENABLE(MEDIA_SESSION)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_currentMediaSessionPositionBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto sessionConversionResult = convert<IDLInterface<MediaSession>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "session"_s, "Internals"_s, "currentMediaSessionPosition"_s, "MediaSession"_s); });
    if (sessionConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDouble>(*lexicalGlobalObject, throwScope, impl.currentMediaSessionPosition(*sessionConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_currentMediaSessionPosition, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_currentMediaSessionPositionBody>(*lexicalGlobalObject, *callFrame, "currentMediaSessionPosition");
}

#endif

#if ENABLE(MEDIA_SESSION)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_sendMediaSessionActionBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto sessionConversionResult = convert<IDLInterface<MediaSession>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "session"_s, "Internals"_s, "sendMediaSessionAction"_s, "MediaSession"_s); });
    if (sessionConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto actionDetailsConversionResult = convert<IDLDictionary<MediaSessionActionDetails>>(*lexicalGlobalObject, argument1.value());
    if (actionDetailsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.sendMediaSessionAction(*sessionConversionResult.releaseReturnValue(), actionDetailsConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_sendMediaSessionAction, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_sendMediaSessionActionBody>(*lexicalGlobalObject, *callFrame, "sendMediaSessionAction");
}

#endif

#if ENABLE(MEDIA_SESSION) && ENABLE(WEB_CODECS)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_loadArtworkImageBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperationReturningPromise<JSInternals>::ClassParameter castedThis, Ref<DeferredPromise>&& promise)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto urlConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (urlConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLPromise<IDLInterface<WebCodecsVideoFrame>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, [&]() -> decltype(auto) { return impl.loadArtworkImage(urlConversionResult.releaseReturnValue(), WTFMove(promise)); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_loadArtworkImage, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperationReturningPromise<JSInternals>::call<jsInternalsPrototypeFunction_loadArtworkImageBody>(*lexicalGlobalObject, *callFrame, "loadArtworkImage");
}

#endif

#if ENABLE(MEDIA_SESSION)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_platformSupportedCommandsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLSequence<IDLDOMString>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.platformSupportedCommands())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_platformSupportedCommands, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_platformSupportedCommandsBody>(*lexicalGlobalObject, *callFrame, "platformSupportedCommands");
}

#endif

#if ENABLE(MEDIA_SESSION_COORDINATOR)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_registerMockMediaSessionCoordinatorBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    auto* context = jsCast<JSDOMGlobalObject*>(lexicalGlobalObject)->scriptExecutionContext();
    if (!context) [[unlikely]]
        return JSValue::encode(jsUndefined());
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto callbackConversionResult = convert<IDLCallbackFunction<JSStringCallback>>(*lexicalGlobalObject, argument0.value(), *castedThis->globalObject(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentMustBeFunctionError(lexicalGlobalObject, scope, 0, "callback"_s, "Internals"_s, "registerMockMediaSessionCoordinator"_s); });
    if (callbackConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.registerMockMediaSessionCoordinator(*context, callbackConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_registerMockMediaSessionCoordinator, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_registerMockMediaSessionCoordinatorBody>(*lexicalGlobalObject, *callFrame, "registerMockMediaSessionCoordinator");
}

#endif

#if ENABLE(MEDIA_SESSION_COORDINATOR)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setMockMediaSessionCoordinatorCommandsShouldFailBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto shouldFailConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (shouldFailConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setMockMediaSessionCoordinatorCommandsShouldFail(shouldFailConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setMockMediaSessionCoordinatorCommandsShouldFail, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setMockMediaSessionCoordinatorCommandsShouldFailBody>(*lexicalGlobalObject, *callFrame, "setMockMediaSessionCoordinatorCommandsShouldFail");
}

#endif

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_treeOrderBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto aConversionResult = convert<IDLInterface<Node>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "a"_s, "Internals"_s, "treeOrder"_s, "Node"_s); });
    if (aConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto bConversionResult = convert<IDLInterface<Node>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "b"_s, "Internals"_s, "treeOrder"_s, "Node"_s); });
    if (bConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->argument(2);
    auto treeConversionResult = convertOptionalWithDefault<IDLEnumeration<Internals::TreeType>>(*lexicalGlobalObject, argument2.value(), [&]() -> ConversionResult<IDLEnumeration<Internals::TreeType>> { return Converter<IDLEnumeration<Internals::TreeType>>::ReturnType { Internals::TreeType::Tree }; }, [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentMustBeEnumError(lexicalGlobalObject, scope, 2, "tree"_s, "Internals"_s, "treeOrder"_s, expectedEnumerationValues<Internals::TreeType>()); });
    if (treeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.treeOrder(*aConversionResult.releaseReturnValue(), *bConversionResult.releaseReturnValue(), treeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_treeOrder, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_treeOrderBody>(*lexicalGlobalObject, *callFrame, "treeOrder");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_treeOrderBoundaryPointsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto containerAConversionResult = convert<IDLInterface<Node>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "containerA"_s, "Internals"_s, "treeOrderBoundaryPoints"_s, "Node"_s); });
    if (containerAConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto offsetAConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (offsetAConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto containerBConversionResult = convert<IDLInterface<Node>>(*lexicalGlobalObject, argument2.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 2, "containerB"_s, "Internals"_s, "treeOrderBoundaryPoints"_s, "Node"_s); });
    if (containerBConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto offsetBConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (offsetBConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->argument(4);
    auto treeConversionResult = convertOptionalWithDefault<IDLEnumeration<Internals::TreeType>>(*lexicalGlobalObject, argument4.value(), [&]() -> ConversionResult<IDLEnumeration<Internals::TreeType>> { return Converter<IDLEnumeration<Internals::TreeType>>::ReturnType { Internals::TreeType::Tree }; }, [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentMustBeEnumError(lexicalGlobalObject, scope, 4, "tree"_s, "Internals"_s, "treeOrderBoundaryPoints"_s, expectedEnumerationValues<Internals::TreeType>()); });
    if (treeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.treeOrderBoundaryPoints(*containerAConversionResult.releaseReturnValue(), offsetAConversionResult.releaseReturnValue(), *containerBConversionResult.releaseReturnValue(), offsetBConversionResult.releaseReturnValue(), treeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_treeOrderBoundaryPoints, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_treeOrderBoundaryPointsBody>(*lexicalGlobalObject, *callFrame, "treeOrderBoundaryPoints");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_rangeContainsNodeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto rangeConversionResult = convert<IDLInterface<AbstractRange>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "range"_s, "Internals"_s, "rangeContainsNode"_s, "AbstractRange"_s); });
    if (rangeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto nodeConversionResult = convert<IDLInterface<Node>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "node"_s, "Internals"_s, "rangeContainsNode"_s, "Node"_s); });
    if (nodeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->argument(2);
    auto treeConversionResult = convertOptionalWithDefault<IDLEnumeration<Internals::TreeType>>(*lexicalGlobalObject, argument2.value(), [&]() -> ConversionResult<IDLEnumeration<Internals::TreeType>> { return Converter<IDLEnumeration<Internals::TreeType>>::ReturnType { Internals::TreeType::Tree }; }, [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentMustBeEnumError(lexicalGlobalObject, scope, 2, "tree"_s, "Internals"_s, "rangeContainsNode"_s, expectedEnumerationValues<Internals::TreeType>()); });
    if (treeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.rangeContainsNode(*rangeConversionResult.releaseReturnValue(), *nodeConversionResult.releaseReturnValue(), treeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_rangeContainsNode, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_rangeContainsNodeBody>(*lexicalGlobalObject, *callFrame, "rangeContainsNode");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_rangeContainsRangeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto outerRangeConversionResult = convert<IDLInterface<AbstractRange>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "outerRange"_s, "Internals"_s, "rangeContainsRange"_s, "AbstractRange"_s); });
    if (outerRangeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto innerRangeConversionResult = convert<IDLInterface<AbstractRange>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "innerRange"_s, "Internals"_s, "rangeContainsRange"_s, "AbstractRange"_s); });
    if (innerRangeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->argument(2);
    auto treeConversionResult = convertOptionalWithDefault<IDLEnumeration<Internals::TreeType>>(*lexicalGlobalObject, argument2.value(), [&]() -> ConversionResult<IDLEnumeration<Internals::TreeType>> { return Converter<IDLEnumeration<Internals::TreeType>>::ReturnType { Internals::TreeType::Tree }; }, [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentMustBeEnumError(lexicalGlobalObject, scope, 2, "tree"_s, "Internals"_s, "rangeContainsRange"_s, expectedEnumerationValues<Internals::TreeType>()); });
    if (treeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.rangeContainsRange(*outerRangeConversionResult.releaseReturnValue(), *innerRangeConversionResult.releaseReturnValue(), treeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_rangeContainsRange, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_rangeContainsRangeBody>(*lexicalGlobalObject, *callFrame, "rangeContainsRange");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_rangeContainsBoundaryPointBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto outerRangeConversionResult = convert<IDLInterface<AbstractRange>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "outerRange"_s, "Internals"_s, "rangeContainsBoundaryPoint"_s, "AbstractRange"_s); });
    if (outerRangeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto containerConversionResult = convert<IDLInterface<Node>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "container"_s, "Internals"_s, "rangeContainsBoundaryPoint"_s, "Node"_s); });
    if (containerConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto offsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (offsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->argument(3);
    auto treeConversionResult = convertOptionalWithDefault<IDLEnumeration<Internals::TreeType>>(*lexicalGlobalObject, argument3.value(), [&]() -> ConversionResult<IDLEnumeration<Internals::TreeType>> { return Converter<IDLEnumeration<Internals::TreeType>>::ReturnType { Internals::TreeType::Tree }; }, [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentMustBeEnumError(lexicalGlobalObject, scope, 3, "tree"_s, "Internals"_s, "rangeContainsBoundaryPoint"_s, expectedEnumerationValues<Internals::TreeType>()); });
    if (treeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.rangeContainsBoundaryPoint(*outerRangeConversionResult.releaseReturnValue(), *containerConversionResult.releaseReturnValue(), offsetConversionResult.releaseReturnValue(), treeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_rangeContainsBoundaryPoint, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_rangeContainsBoundaryPointBody>(*lexicalGlobalObject, *callFrame, "rangeContainsBoundaryPoint");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_rangeIntersectsNodeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto rangeConversionResult = convert<IDLInterface<AbstractRange>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "range"_s, "Internals"_s, "rangeIntersectsNode"_s, "AbstractRange"_s); });
    if (rangeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto nodeConversionResult = convert<IDLInterface<Node>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "node"_s, "Internals"_s, "rangeIntersectsNode"_s, "Node"_s); });
    if (nodeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->argument(2);
    auto treeConversionResult = convertOptionalWithDefault<IDLEnumeration<Internals::TreeType>>(*lexicalGlobalObject, argument2.value(), [&]() -> ConversionResult<IDLEnumeration<Internals::TreeType>> { return Converter<IDLEnumeration<Internals::TreeType>>::ReturnType { Internals::TreeType::Tree }; }, [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentMustBeEnumError(lexicalGlobalObject, scope, 2, "tree"_s, "Internals"_s, "rangeIntersectsNode"_s, expectedEnumerationValues<Internals::TreeType>()); });
    if (treeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.rangeIntersectsNode(*rangeConversionResult.releaseReturnValue(), *nodeConversionResult.releaseReturnValue(), treeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_rangeIntersectsNode, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_rangeIntersectsNodeBody>(*lexicalGlobalObject, *callFrame, "rangeIntersectsNode");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_rangeIntersectsRangeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto outerRangeConversionResult = convert<IDLInterface<AbstractRange>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "outerRange"_s, "Internals"_s, "rangeIntersectsRange"_s, "AbstractRange"_s); });
    if (outerRangeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto innerRangeConversionResult = convert<IDLInterface<AbstractRange>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "innerRange"_s, "Internals"_s, "rangeIntersectsRange"_s, "AbstractRange"_s); });
    if (innerRangeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->argument(2);
    auto treeConversionResult = convertOptionalWithDefault<IDLEnumeration<Internals::TreeType>>(*lexicalGlobalObject, argument2.value(), [&]() -> ConversionResult<IDLEnumeration<Internals::TreeType>> { return Converter<IDLEnumeration<Internals::TreeType>>::ReturnType { Internals::TreeType::Tree }; }, [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentMustBeEnumError(lexicalGlobalObject, scope, 2, "tree"_s, "Internals"_s, "rangeIntersectsRange"_s, expectedEnumerationValues<Internals::TreeType>()); });
    if (treeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.rangeIntersectsRange(*outerRangeConversionResult.releaseReturnValue(), *innerRangeConversionResult.releaseReturnValue(), treeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_rangeIntersectsRange, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_rangeIntersectsRangeBody>(*lexicalGlobalObject, *callFrame, "rangeIntersectsRange");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_systemBeepBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.systemBeep(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_systemBeep, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_systemBeepBody>(*lexicalGlobalObject, *callFrame, "systemBeep");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_dumpStyleResolversBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.dumpStyleResolvers())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_dumpStyleResolvers, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_dumpStyleResolversBody>(*lexicalGlobalObject, *callFrame, "dumpStyleResolvers");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setDocumentAutoplayPolicyBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto documentConversionResult = convert<IDLInterface<Document>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "document"_s, "Internals"_s, "setDocumentAutoplayPolicy"_s, "Document"_s); });
    if (documentConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto policyConversionResult = convert<IDLEnumeration<Internals::AutoplayPolicy>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentMustBeEnumError(lexicalGlobalObject, scope, 1, "policy"_s, "Internals"_s, "setDocumentAutoplayPolicy"_s, expectedEnumerationValues<Internals::AutoplayPolicy>()); });
    if (policyConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setDocumentAutoplayPolicy(*documentConversionResult.releaseReturnValue(), policyConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setDocumentAutoplayPolicy, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setDocumentAutoplayPolicyBody>(*lexicalGlobalObject, *callFrame, "setDocumentAutoplayPolicy");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_retainTextIteratorForDocumentContentBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.retainTextIteratorForDocumentContent(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_retainTextIteratorForDocumentContent, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_retainTextIteratorForDocumentContentBody>(*lexicalGlobalObject, *callFrame, "retainTextIteratorForDocumentContent");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_createPushSubscriptionBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 5) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto endpointConversionResult = convert<IDLUSVString>(*lexicalGlobalObject, argument0.value());
    if (endpointConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto expirationTimeConversionResult = convert<IDLNullable<IDLUnsignedLongLong>>(*lexicalGlobalObject, argument1.value());
    if (expirationTimeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto serverVAPIDPublicKeyConversionResult = convert<IDLArrayBuffer>(*lexicalGlobalObject, argument2.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 2, "serverVAPIDPublicKey"_s, "Internals"_s, "createPushSubscription"_s, "ArrayBuffer"_s); });
    if (serverVAPIDPublicKeyConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto clientECDHPublicKeyConversionResult = convert<IDLArrayBuffer>(*lexicalGlobalObject, argument3.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 3, "clientECDHPublicKey"_s, "Internals"_s, "createPushSubscription"_s, "ArrayBuffer"_s); });
    if (clientECDHPublicKeyConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto authConversionResult = convert<IDLArrayBuffer>(*lexicalGlobalObject, argument4.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 4, "auth"_s, "Internals"_s, "createPushSubscription"_s, "ArrayBuffer"_s); });
    if (authConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<PushSubscription>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.createPushSubscription(endpointConversionResult.releaseReturnValue(), expirationTimeConversionResult.releaseReturnValue(), serverVAPIDPublicKeyConversionResult.releaseReturnValue(), clientECDHPublicKeyConversionResult.releaseReturnValue(), authConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_createPushSubscription, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_createPushSubscriptionBody>(*lexicalGlobalObject, *callFrame, "createPushSubscription");
}

#if ENABLE(ARKIT_INLINE_PREVIEW_MAC)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_modelInlinePreviewUUIDsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperationReturningPromise<JSInternals>::ClassParameter castedThis, Ref<DeferredPromise>&& promise)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLPromise<IDLSequence<IDLDOMString>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, [&]() -> decltype(auto) { return impl.modelInlinePreviewUUIDs(WTFMove(promise)); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_modelInlinePreviewUUIDs, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperationReturningPromise<JSInternals>::call<jsInternalsPrototypeFunction_modelInlinePreviewUUIDsBody>(*lexicalGlobalObject, *callFrame, "modelInlinePreviewUUIDs");
}

#endif

#if ENABLE(ARKIT_INLINE_PREVIEW_MAC)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_modelInlinePreviewUUIDForModelElementBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto modelElementConversionResult = convert<IDLInterface<HTMLModelElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "modelElement"_s, "Internals"_s, "modelInlinePreviewUUIDForModelElement"_s, "HTMLModelElement"_s); });
    if (modelElementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.modelInlinePreviewUUIDForModelElement(*modelElementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_modelInlinePreviewUUIDForModelElement, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_modelInlinePreviewUUIDForModelElementBody>(*lexicalGlobalObject, *callFrame, "modelInlinePreviewUUIDForModelElement");
}

#endif

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_hasSleepDisablerBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.hasSleepDisabler())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_hasSleepDisabler, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_hasSleepDisablerBody>(*lexicalGlobalObject, *callFrame, "hasSleepDisabler");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_acceptTypedArraysBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLInt32Array>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "target"_s, "Internals"_s, "acceptTypedArrays"_s, "Int32Array"_s); });
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.acceptTypedArrays(targetConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_acceptTypedArrays, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_acceptTypedArraysBody>(*lexicalGlobalObject, *callFrame, "acceptTypedArrays");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_consumeTransientActivationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.consumeTransientActivation())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_consumeTransientActivation, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_consumeTransientActivationBody>(*lexicalGlobalObject, *callFrame, "consumeTransientActivation");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_consumeHistoryActionUserActivationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.consumeHistoryActionUserActivation())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_consumeHistoryActionUserActivation, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_consumeHistoryActionUserActivationBody>(*lexicalGlobalObject, *callFrame, "consumeHistoryActionUserActivation");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_selectorFilterHashCountsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto selectorConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (selectorConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDictionary<Internals::SelectorFilterHashCounts>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.selectorFilterHashCounts(selectorConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_selectorFilterHashCounts, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_selectorFilterHashCountsBody>(*lexicalGlobalObject, *callFrame, "selectorFilterHashCounts");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setHistoryTotalStateObjectPayloadLimitOverrideBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto limitConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (limitConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setHistoryTotalStateObjectPayloadLimitOverride(limitConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setHistoryTotalStateObjectPayloadLimitOverride, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setHistoryTotalStateObjectPayloadLimitOverrideBody>(*lexicalGlobalObject, *callFrame, "setHistoryTotalStateObjectPayloadLimitOverride");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isUsingUISideCompositingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isUsingUISideCompositing())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isUsingUISideCompositing, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isUsingUISideCompositingBody>(*lexicalGlobalObject, *callFrame, "isUsingUISideCompositing");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_getComputedLabelBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "getComputedLabel"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.getComputedLabel(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_getComputedLabel, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_getComputedLabelBody>(*lexicalGlobalObject, *callFrame, "getComputedLabel");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_getComputedRoleBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "getComputedRole"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.getComputedRole(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_getComputedRole, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_getComputedRoleBody>(*lexicalGlobalObject, *callFrame, "getComputedRole");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_pdfAnnotationRectsForTestingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "pdfAnnotationRectsForTesting"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLSequence<IDLDictionary<Internals::PDFAnnotationRect>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.pdfAnnotationRectsForTesting(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_pdfAnnotationRectsForTesting, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_pdfAnnotationRectsForTestingBody>(*lexicalGlobalObject, *callFrame, "pdfAnnotationRectsForTesting");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setPDFTextAnnotationValueForTestingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "setPDFTextAnnotationValueForTesting"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto pageIndexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (pageIndexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto annotationIndexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (annotationIndexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto valueConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument3.value());
    if (valueConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setPDFTextAnnotationValueForTesting(*elementConversionResult.releaseReturnValue(), pageIndexConversionResult.releaseReturnValue(), annotationIndexConversionResult.releaseReturnValue(), valueConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPDFTextAnnotationValueForTesting, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setPDFTextAnnotationValueForTestingBody>(*lexicalGlobalObject, *callFrame, "setPDFTextAnnotationValueForTesting");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_registerPDFTestBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto callbackConversionResult = convert<IDLCallbackFunction<JSVoidCallback>>(*lexicalGlobalObject, argument0.value(), *castedThis->globalObject(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentMustBeFunctionError(lexicalGlobalObject, scope, 0, "callback"_s, "Internals"_s, "registerPDFTest"_s); });
    if (callbackConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "element"_s, "Internals"_s, "registerPDFTest"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.registerPDFTest(callbackConversionResult.releaseReturnValue(), *elementConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_registerPDFTest, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_registerPDFTestBody>(*lexicalGlobalObject, *callFrame, "registerPDFTest");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setPDFDisplayModeForTestingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "setPDFDisplayModeForTesting"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto modeConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (modeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setPDFDisplayModeForTesting(*elementConversionResult.releaseReturnValue(), modeConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setPDFDisplayModeForTesting, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setPDFDisplayModeForTestingBody>(*lexicalGlobalObject, *callFrame, "setPDFDisplayModeForTesting");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_unlockPDFDocumentForTestingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "unlockPDFDocumentForTesting"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto passwordConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (passwordConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.unlockPDFDocumentForTesting(*elementConversionResult.releaseReturnValue(), passwordConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_unlockPDFDocumentForTesting, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_unlockPDFDocumentForTestingBody>(*lexicalGlobalObject, *callFrame, "unlockPDFDocumentForTesting");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_sendEditingCommandToPDFForTestingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<Element>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "sendEditingCommandToPDFForTesting"_s, "Element"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto commandNameConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (commandNameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->argument(2);
    auto argumentConversionResult = convertOptionalWithDefault<IDLDOMString>(*lexicalGlobalObject, argument2.value(), [&]() -> ConversionResult<IDLDOMString> { return Converter<IDLDOMString>::ReturnType { emptyString() }; });
    if (argumentConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.sendEditingCommandToPDFForTesting(*elementConversionResult.releaseReturnValue(), commandNameConversionResult.releaseReturnValue(), argumentConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_sendEditingCommandToPDFForTesting, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_sendEditingCommandToPDFForTestingBody>(*lexicalGlobalObject, *callFrame, "sendEditingCommandToPDFForTesting");
}

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isEffectivelyMutedBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "isEffectivelyMuted"_s, "HTMLMediaElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isEffectivelyMuted(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isEffectivelyMuted, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isEffectivelyMutedBody>(*lexicalGlobalObject, *callFrame, "isEffectivelyMuted");
}

#endif

#if ENABLE(VIDEO)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_addInternalEventTargetBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLMediaElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "addInternalEventTarget"_s, "HTMLMediaElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<EventTarget>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.addInternalEventTarget(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_addInternalEventTarget, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_addInternalEventTargetBody>(*lexicalGlobalObject, *callFrame, "addInternalEventTarget");
}

#endif

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_getEffectiveRenderingModeOfNewlyCreatedAcceleratedImageBufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLEnumeration<Internals::RenderingMode>>>(*lexicalGlobalObject, throwScope, impl.getEffectiveRenderingModeOfNewlyCreatedAcceleratedImageBuffer())));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_getEffectiveRenderingModeOfNewlyCreatedAcceleratedImageBuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_getEffectiveRenderingModeOfNewlyCreatedAcceleratedImageBufferBody>(*lexicalGlobalObject, *callFrame, "getEffectiveRenderingModeOfNewlyCreatedAcceleratedImageBuffer");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_getImageBufferResourceLimitsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperationReturningPromise<JSInternals>::ClassParameter castedThis, Ref<DeferredPromise>&& promise)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLPromise<IDLDictionary<Internals::ImageBufferResourceLimits>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, [&]() -> decltype(auto) { return impl.getImageBufferResourceLimits(WTFMove(promise)); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_getImageBufferResourceLimits, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperationReturningPromise<JSInternals>::call<jsInternalsPrototypeFunction_getImageBufferResourceLimitsBody>(*lexicalGlobalObject, *callFrame, "getImageBufferResourceLimits");
}

static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_setTopDocumentURLForQuirksBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto urlStringConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (urlStringConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setTopDocumentURLForQuirks(urlStringConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_setTopDocumentURLForQuirks, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_setTopDocumentURLForQuirksBody>(*lexicalGlobalObject, *callFrame, "setTopDocumentURLForQuirks");
}

#if ENABLE(MODEL_ELEMENT)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_disableModelLoadDelaysForTestingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.disableModelLoadDelaysForTesting(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_disableModelLoadDelaysForTesting, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_disableModelLoadDelaysForTestingBody>(*lexicalGlobalObject, *callFrame, "disableModelLoadDelaysForTesting");
}

#endif

#if ENABLE(MODEL_ELEMENT)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_modelElementStateBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLModelElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "modelElementState"_s, "HTMLModelElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDOMString>(*lexicalGlobalObject, throwScope, impl.modelElementState(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_modelElementState, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_modelElementStateBody>(*lexicalGlobalObject, *callFrame, "modelElementState");
}

#endif

#if ENABLE(MODEL_ELEMENT)
static inline JSC::EncodedJSValue jsInternalsPrototypeFunction_isModelElementIntersectingViewportBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSInternals>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto elementConversionResult = convert<IDLInterface<HTMLModelElement>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "element"_s, "Internals"_s, "isModelElementIntersectingViewport"_s, "HTMLModelElement"_s); });
    if (elementConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isModelElementIntersectingViewport(*elementConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsInternalsPrototypeFunction_isModelElementIntersectingViewport, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSInternals>::call<jsInternalsPrototypeFunction_isModelElementIntersectingViewportBody>(*lexicalGlobalObject, *callFrame, "isModelElementIntersectingViewport");
}

#endif

JSC::GCClient::IsoSubspace* JSInternals::subspaceForImpl(JSC::VM& vm)
{
    return WebCore::subspaceForImpl<JSInternals, UseCustomHeapCellType::No>(vm, "JSInternals"_s,
        [] (auto& spaces) { return spaces.m_clientSubspaceForInternals.get(); },
        [] (auto& spaces, auto&& space) { spaces.m_clientSubspaceForInternals = std::forward<decltype(space)>(space); },
        [] (auto& spaces) { return spaces.m_subspaceForInternals.get(); },
        [] (auto& spaces, auto&& space) { spaces.m_subspaceForInternals = std::forward<decltype(space)>(space); }
    );
}

void JSInternals::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSInternals*>(cell);
    analyzer.setWrappedObjectForCell(cell, &thisObject->wrapped());
    if (RefPtr context = thisObject->scriptExecutionContext())
        analyzer.setLabelForCell(cell, makeString("url "_s, context->url().string()));
    Base::analyzeHeap(cell, analyzer);
}

bool JSInternalsOwner::isReachableFromOpaqueRoots(JSC::Handle<JSC::Unknown> handle, void*, AbstractSlotVisitor& visitor, ASCIILiteral* reason)
{
    UNUSED_PARAM(handle);
    UNUSED_PARAM(visitor);
    UNUSED_PARAM(reason);
    return false;
}

void JSInternalsOwner::finalize(JSC::Handle<JSC::Unknown> handle, void* context)
{
    auto* jsInternals = static_cast<JSInternals*>(handle.slot()->asCell());
    auto& world = *static_cast<DOMWrapperWorld*>(context);
    uncacheWrapper(world, jsInternals->protectedWrapped().ptr(), jsInternals);
}

WTF_ALLOW_UNSAFE_BUFFER_USAGE_BEGIN
#if ENABLE(BINDING_INTEGRITY)
#if PLATFORM(WIN)
#pragma warning(disable: 4483)
extern "C" { extern void (*const __identifier("??_7Internals@WebCore@@6B@")[])(); }
#else
extern "C" { extern void* _ZTVN7WebCore9InternalsE[]; }
#endif
template<std::same_as<Internals> T>
static inline void verifyVTable(Internals* ptr) 
{
    if constexpr (std::is_polymorphic_v<T>) {
        const void* actualVTablePointer = getVTablePointer<T>(ptr);
#if PLATFORM(WIN)
        void* expectedVTablePointer = __identifier("??_7Internals@WebCore@@6B@");
#else
        void* expectedVTablePointer = &_ZTVN7WebCore9InternalsE[2];
#endif

        // If you hit this assertion you either have a use after free bug, or
        // Internals has subclasses. If Internals has subclasses that get passed
        // to toJS() we currently require Internals you to opt out of binding hardening
        // by adding the SkipVTableValidation attribute to the interface IDL definition
        RELEASE_ASSERT(actualVTablePointer == expectedVTablePointer);
    }
}
#endif
WTF_ALLOW_UNSAFE_BUFFER_USAGE_END

JSC::JSValue toJSNewlyCreated(JSC::JSGlobalObject*, JSDOMGlobalObject* globalObject, Ref<Internals>&& impl)
{
#if ENABLE(BINDING_INTEGRITY)
    verifyVTable<Internals>(impl.ptr());
#endif
    return createWrapper<Internals>(globalObject, WTFMove(impl));
}

JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, Internals& impl)
{
    return wrap(lexicalGlobalObject, globalObject, impl);
}

Internals* JSInternals::toWrapped(JSC::VM&, JSC::JSValue value)
{
    if (auto* wrapper = jsDynamicCast<JSInternals*>(value))
        return &wrapper->wrapped();
    return nullptr;
}

}
