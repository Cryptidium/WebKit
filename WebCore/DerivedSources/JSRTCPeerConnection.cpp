/*
    This file is part of the WebKit open source project.
    This file has been generated by generate-bindings.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.
*/

#include "config.h"

#if ENABLE(WEB_RTC)

#include "JSRTCPeerConnection.h"

#include "ActiveDOMObject.h"
#include "ContextDestructionObserverInlines.h"
#include "DOMPromiseProxy.h"
#include "Document.h"
#include "EventNames.h"
#include "ExtendedDOMClientIsoSubspaces.h"
#include "ExtendedDOMIsoSubspaces.h"
#include "IDLTypes.h"
#include "JSDOMAttribute.h"
#include "JSDOMBinding.h"
#include "JSDOMConstructor.h"
#include "JSDOMConvertBase.h"
#include "JSDOMConvertBoolean.h"
#include "JSDOMConvertBufferSource.h"
#include "JSDOMConvertEnumeration.h"
#include "JSDOMConvertInterface.h"
#include "JSDOMConvertNullable.h"
#include "JSDOMConvertNumbers.h"
#include "JSDOMConvertObject.h"
#include "JSDOMConvertOptional.h"
#include "JSDOMConvertPromise.h"
#include "JSDOMConvertSequences.h"
#include "JSDOMConvertStrings.h"
#include "JSDOMConvertUnion.h"
#include "JSDOMConvertVariadic.h"
#include "JSDOMExceptionHandling.h"
#include "JSDOMGlobalObject.h"
#include "JSDOMGlobalObjectInlines.h"
#include "JSDOMOperation.h"
#include "JSDOMOperationReturningPromise.h"
#include "JSDOMWrapperCache.h"
#include "JSEventListener.h"
#include "JSMediaStream.h"
#include "JSMediaStreamTrack.h"
#include "JSRTCAnswerOptions.h"
#include "JSRTCCertificate.h"
#include "JSRTCConfiguration.h"
#include "JSRTCDataChannel.h"
#include "JSRTCIceCandidate.h"
#include "JSRTCIceCandidateInit.h"
#include "JSRTCIceConnectionState.h"
#include "JSRTCIceGatheringState.h"
#include "JSRTCLocalSessionDescriptionInit.h"
#include "JSRTCOfferOptions.h"
#include "JSRTCPeerConnectionState.h"
#include "JSRTCRtpEncodingParameters.h"
#include "JSRTCRtpReceiver.h"
#include "JSRTCRtpSender.h"
#include "JSRTCRtpTransceiver.h"
#include "JSRTCRtpTransceiverDirection.h"
#include "JSRTCSctpTransport.h"
#include "JSRTCSessionDescription.h"
#include "JSRTCSessionDescriptionInit.h"
#include "JSRTCSignalingState.h"
#include "JSRTCStatsReport.h"
#include "ScriptExecutionContext.h"
#include "WebCoreJSClientData.h"
#include <JavaScriptCore/HeapAnalyzer.h>
#include <JavaScriptCore/JSArray.h>
#include <JavaScriptCore/JSCInlines.h>
#include <JavaScriptCore/JSDestructibleObjectHeapCellType.h>
#include <JavaScriptCore/SlotVisitorMacros.h>
#include <JavaScriptCore/SubspaceInlines.h>
#include <wtf/GetPtr.h>
#include <wtf/PointerPreparations.h>
#include <wtf/URL.h>
#include <wtf/Variant.h>
#include <wtf/text/MakeString.h>

namespace WebCore {
using namespace JSC;

#if ENABLE(WEB_RTC)

template<> ConversionResult<IDLDictionary<RTCPeerConnection::DataChannelInit>> convertDictionary<RTCPeerConnection::DataChannelInit>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    bool isNullOrUndefined = value.isUndefinedOrNull();
    auto* object = isNullOrUndefined ? nullptr : value.getObject();
    if (!isNullOrUndefined && !object) [[unlikely]] {
        throwTypeError(&lexicalGlobalObject, throwScope);
        return ConversionResultException { };
    }
    RTCPeerConnection::DataChannelInit result;
    JSValue idValue;
    if (isNullOrUndefined)
        idValue = jsUndefined();
    else {
        idValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "id"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!idValue.isUndefined()) {
        auto idConversionResult = convert<IDLEnforceRangeAdaptor<IDLUnsignedShort>>(lexicalGlobalObject, idValue);
        if (idConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.id = idConversionResult.releaseReturnValue();
    }
    JSValue maxPacketLifeTimeValue;
    if (isNullOrUndefined)
        maxPacketLifeTimeValue = jsUndefined();
    else {
        maxPacketLifeTimeValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "maxPacketLifeTime"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!maxPacketLifeTimeValue.isUndefined()) {
        auto maxPacketLifeTimeConversionResult = convert<IDLUnsignedShort>(lexicalGlobalObject, maxPacketLifeTimeValue);
        if (maxPacketLifeTimeConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.maxPacketLifeTime = maxPacketLifeTimeConversionResult.releaseReturnValue();
    }
    JSValue maxRetransmitsValue;
    if (isNullOrUndefined)
        maxRetransmitsValue = jsUndefined();
    else {
        maxRetransmitsValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "maxRetransmits"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!maxRetransmitsValue.isUndefined()) {
        auto maxRetransmitsConversionResult = convert<IDLUnsignedShort>(lexicalGlobalObject, maxRetransmitsValue);
        if (maxRetransmitsConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.maxRetransmits = maxRetransmitsConversionResult.releaseReturnValue();
    }
    JSValue negotiatedValue;
    if (isNullOrUndefined)
        negotiatedValue = jsUndefined();
    else {
        negotiatedValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "negotiated"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto negotiatedConversionResult = convertOptionalWithDefault<IDLBoolean>(lexicalGlobalObject, negotiatedValue, [&]() -> ConversionResult<IDLBoolean> { return Converter<IDLBoolean>::ReturnType { false }; });
    if (negotiatedConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.negotiated = negotiatedConversionResult.releaseReturnValue();
    JSValue orderedValue;
    if (isNullOrUndefined)
        orderedValue = jsUndefined();
    else {
        orderedValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "ordered"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto orderedConversionResult = convertOptionalWithDefault<IDLBoolean>(lexicalGlobalObject, orderedValue, [&]() -> ConversionResult<IDLBoolean> { return Converter<IDLBoolean>::ReturnType { true }; });
    if (orderedConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.ordered = orderedConversionResult.releaseReturnValue();
    JSValue protocolValue;
    if (isNullOrUndefined)
        protocolValue = jsUndefined();
    else {
        protocolValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "protocol"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto protocolConversionResult = convertOptionalWithDefault<IDLUSVString>(lexicalGlobalObject, protocolValue, [&]() -> ConversionResult<IDLUSVString> { return Converter<IDLUSVString>::ReturnType { emptyString() }; });
    if (protocolConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.protocol = protocolConversionResult.releaseReturnValue();
    return result;
}

#endif

#if ENABLE(WEB_RTC)

template<> ConversionResult<IDLDictionary<RTCPeerConnection::CertificateParameters>> convertDictionary<RTCPeerConnection::CertificateParameters>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    bool isNullOrUndefined = value.isUndefinedOrNull();
    auto* object = isNullOrUndefined ? nullptr : value.getObject();
    if (!isNullOrUndefined && !object) [[unlikely]] {
        throwTypeError(&lexicalGlobalObject, throwScope);
        return ConversionResultException { };
    }
    RTCPeerConnection::CertificateParameters result;
    JSValue expiresValue;
    if (isNullOrUndefined)
        expiresValue = jsUndefined();
    else {
        expiresValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "expires"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!expiresValue.isUndefined()) {
        auto expiresConversionResult = convert<IDLDouble>(lexicalGlobalObject, expiresValue);
        if (expiresConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.expires = expiresConversionResult.releaseReturnValue();
    }
    JSValue hashValue;
    if (isNullOrUndefined)
        hashValue = jsUndefined();
    else {
        hashValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "hash"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!hashValue.isUndefined()) {
        auto hashConversionResult = convert<IDLDOMString>(lexicalGlobalObject, hashValue);
        if (hashConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.hash = hashConversionResult.releaseReturnValue();
    }
    JSValue modulusLengthValue;
    if (isNullOrUndefined)
        modulusLengthValue = jsUndefined();
    else {
        modulusLengthValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "modulusLength"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!modulusLengthValue.isUndefined()) {
        auto modulusLengthConversionResult = convert<IDLUnsignedLong>(lexicalGlobalObject, modulusLengthValue);
        if (modulusLengthConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.modulusLength = modulusLengthConversionResult.releaseReturnValue();
    }
    JSValue nameValue;
    if (isNullOrUndefined)
        nameValue = jsUndefined();
    else {
        nameValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "name"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!nameValue.isUndefined()) {
        auto nameConversionResult = convert<IDLDOMString>(lexicalGlobalObject, nameValue);
        if (nameConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.name = nameConversionResult.releaseReturnValue();
    }
    JSValue namedCurveValue;
    if (isNullOrUndefined)
        namedCurveValue = jsUndefined();
    else {
        namedCurveValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "namedCurve"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!namedCurveValue.isUndefined()) {
        auto namedCurveConversionResult = convert<IDLDOMString>(lexicalGlobalObject, namedCurveValue);
        if (namedCurveConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.namedCurve = namedCurveConversionResult.releaseReturnValue();
    }
    JSValue publicExponentValue;
    if (isNullOrUndefined)
        publicExponentValue = jsUndefined();
    else {
        publicExponentValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "publicExponent"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!publicExponentValue.isUndefined()) {
        auto publicExponentConversionResult = convert<IDLUint8Array>(lexicalGlobalObject, publicExponentValue);
        if (publicExponentConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.publicExponent = publicExponentConversionResult.releaseReturnValue();
    }
    return result;
}

#endif

#if ENABLE(WEB_RTC)

template<> ConversionResult<IDLDictionary<RTCRtpTransceiverInit>> convertDictionary<RTCRtpTransceiverInit>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    bool isNullOrUndefined = value.isUndefinedOrNull();
    auto* object = isNullOrUndefined ? nullptr : value.getObject();
    if (!isNullOrUndefined && !object) [[unlikely]] {
        throwTypeError(&lexicalGlobalObject, throwScope);
        return ConversionResultException { };
    }
    RTCRtpTransceiverInit result;
    JSValue directionValue;
    if (isNullOrUndefined)
        directionValue = jsUndefined();
    else {
        directionValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "direction"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto directionConversionResult = convertOptionalWithDefault<IDLEnumeration<RTCRtpTransceiverDirection>>(lexicalGlobalObject, directionValue, [&]() -> ConversionResult<IDLEnumeration<RTCRtpTransceiverDirection>> { return Converter<IDLEnumeration<RTCRtpTransceiverDirection>>::ReturnType { RTCRtpTransceiverDirection::Sendrecv }; });
    if (directionConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.direction = directionConversionResult.releaseReturnValue();
    JSValue sendEncodingsValue;
    if (isNullOrUndefined)
        sendEncodingsValue = jsUndefined();
    else {
        sendEncodingsValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "sendEncodings"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto sendEncodingsConversionResult = convertOptionalWithDefault<IDLSequence<IDLDictionary<RTCRtpEncodingParameters>>>(lexicalGlobalObject, sendEncodingsValue, [&]() -> ConversionResult<IDLSequence<IDLDictionary<RTCRtpEncodingParameters>>> { return Converter<IDLSequence<IDLDictionary<RTCRtpEncodingParameters>>>::ReturnType { }; });
    if (sendEncodingsConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.sendEncodings = sendEncodingsConversionResult.releaseReturnValue();
    JSValue streamsValue;
    if (isNullOrUndefined)
        streamsValue = jsUndefined();
    else {
        streamsValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "streams"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto streamsConversionResult = convertOptionalWithDefault<IDLSequence<IDLInterface<MediaStream>>>(lexicalGlobalObject, streamsValue, [&]() -> ConversionResult<IDLSequence<IDLInterface<MediaStream>>> { return Converter<IDLSequence<IDLInterface<MediaStream>>>::ReturnType { }; });
    if (streamsConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.streams = streamsConversionResult.releaseReturnValue();
    return result;
}

#endif

// Functions

static JSC_DECLARE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_createOffer);
static JSC_DECLARE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_createAnswer);
static JSC_DECLARE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_setLocalDescription);
static JSC_DECLARE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_setRemoteDescription);
static JSC_DECLARE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_addIceCandidate);
static JSC_DECLARE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_restartIce);
static JSC_DECLARE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_getConfiguration);
static JSC_DECLARE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_setConfiguration);
static JSC_DECLARE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_close);
static JSC_DECLARE_HOST_FUNCTION(jsRTCPeerConnectionConstructorFunction_generateCertificate);
static JSC_DECLARE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_getSenders);
static JSC_DECLARE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_getReceivers);
static JSC_DECLARE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_getTransceivers);
static JSC_DECLARE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_addTrack);
static JSC_DECLARE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_removeTrack);
static JSC_DECLARE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_addTransceiver);
static JSC_DECLARE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_createDataChannel);
static JSC_DECLARE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_getStats);

// Attributes

static JSC_DECLARE_CUSTOM_GETTER(jsRTCPeerConnectionConstructor);
static JSC_DECLARE_CUSTOM_GETTER(jsRTCPeerConnection_localDescription);
static JSC_DECLARE_CUSTOM_GETTER(jsRTCPeerConnection_currentLocalDescription);
static JSC_DECLARE_CUSTOM_GETTER(jsRTCPeerConnection_pendingLocalDescription);
static JSC_DECLARE_CUSTOM_GETTER(jsRTCPeerConnection_remoteDescription);
static JSC_DECLARE_CUSTOM_GETTER(jsRTCPeerConnection_currentRemoteDescription);
static JSC_DECLARE_CUSTOM_GETTER(jsRTCPeerConnection_pendingRemoteDescription);
static JSC_DECLARE_CUSTOM_GETTER(jsRTCPeerConnection_signalingState);
static JSC_DECLARE_CUSTOM_GETTER(jsRTCPeerConnection_iceGatheringState);
static JSC_DECLARE_CUSTOM_GETTER(jsRTCPeerConnection_iceConnectionState);
static JSC_DECLARE_CUSTOM_GETTER(jsRTCPeerConnection_connectionState);
static JSC_DECLARE_CUSTOM_GETTER(jsRTCPeerConnection_canTrickleIceCandidates);
static JSC_DECLARE_CUSTOM_GETTER(jsRTCPeerConnection_onnegotiationneeded);
static JSC_DECLARE_CUSTOM_SETTER(setJSRTCPeerConnection_onnegotiationneeded);
static JSC_DECLARE_CUSTOM_GETTER(jsRTCPeerConnection_onicecandidate);
static JSC_DECLARE_CUSTOM_SETTER(setJSRTCPeerConnection_onicecandidate);
static JSC_DECLARE_CUSTOM_GETTER(jsRTCPeerConnection_onsignalingstatechange);
static JSC_DECLARE_CUSTOM_SETTER(setJSRTCPeerConnection_onsignalingstatechange);
static JSC_DECLARE_CUSTOM_GETTER(jsRTCPeerConnection_oniceconnectionstatechange);
static JSC_DECLARE_CUSTOM_SETTER(setJSRTCPeerConnection_oniceconnectionstatechange);
static JSC_DECLARE_CUSTOM_GETTER(jsRTCPeerConnection_onicegatheringstatechange);
static JSC_DECLARE_CUSTOM_SETTER(setJSRTCPeerConnection_onicegatheringstatechange);
static JSC_DECLARE_CUSTOM_GETTER(jsRTCPeerConnection_onconnectionstatechange);
static JSC_DECLARE_CUSTOM_SETTER(setJSRTCPeerConnection_onconnectionstatechange);
static JSC_DECLARE_CUSTOM_GETTER(jsRTCPeerConnection_onicecandidateerror);
static JSC_DECLARE_CUSTOM_SETTER(setJSRTCPeerConnection_onicecandidateerror);
static JSC_DECLARE_CUSTOM_GETTER(jsRTCPeerConnection_ontrack);
static JSC_DECLARE_CUSTOM_SETTER(setJSRTCPeerConnection_ontrack);
static JSC_DECLARE_CUSTOM_GETTER(jsRTCPeerConnection_sctp);
static JSC_DECLARE_CUSTOM_GETTER(jsRTCPeerConnection_ondatachannel);
static JSC_DECLARE_CUSTOM_SETTER(setJSRTCPeerConnection_ondatachannel);

class JSRTCPeerConnectionPrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;
    static JSRTCPeerConnectionPrototype* create(JSC::VM& vm, JSDOMGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSRTCPeerConnectionPrototype* ptr = new (NotNull, JSC::allocateCell<JSRTCPeerConnectionPrototype>(vm)) JSRTCPeerConnectionPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSRTCPeerConnectionPrototype, Base);
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSRTCPeerConnectionPrototype(JSC::VM& vm, JSC::JSGlobalObject*, JSC::Structure* structure)
        : JSC::JSNonFinalObject(vm, structure)
    {
    }

    void finishCreation(JSC::VM&);
};
STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSRTCPeerConnectionPrototype, JSRTCPeerConnectionPrototype::Base);

using JSRTCPeerConnectionDOMConstructor = JSDOMConstructor<JSRTCPeerConnection>;

/* Hash table for constructor */

static const std::array<HashTableValue, 1> JSRTCPeerConnectionConstructorTableValues {
    HashTableValue { "generateCertificate"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsRTCPeerConnectionConstructorFunction_generateCertificate, 1 } },
};

template<> EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSRTCPeerConnectionDOMConstructor::construct(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = lexicalGlobalObject->vm();
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* castedThis = jsCast<JSRTCPeerConnectionDOMConstructor*>(callFrame->jsCallee());
    ASSERT(castedThis);
    RefPtr context = castedThis->scriptExecutionContext();
    if (!context) [[unlikely]]
        return throwConstructorScriptExecutionContextUnavailableError(*lexicalGlobalObject, throwScope, "RTCPeerConnection"_s);
    Ref document = downcast<Document>(*context);
    EnsureStillAliveScope argument0 = callFrame->argument(0);
    auto configurationConversionResult = convert<IDLDictionary<RTCConfiguration>>(*lexicalGlobalObject, argument0.value());
    if (configurationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    auto object = RTCPeerConnection::create(document.get(), configurationConversionResult.releaseReturnValue());
    if constexpr (IsExceptionOr<decltype(object)>)
        RETURN_IF_EXCEPTION(throwScope, { });
    static_assert(TypeOrExceptionOrUnderlyingType<decltype(object)>::isRef);
    auto jsValue = toJSNewlyCreated<IDLInterface<RTCPeerConnection>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, WTFMove(object));
    if constexpr (IsExceptionOr<decltype(object)>)
        RETURN_IF_EXCEPTION(throwScope, { });
    setSubclassStructureIfNeeded<RTCPeerConnection>(lexicalGlobalObject, callFrame, asObject(jsValue));
    RETURN_IF_EXCEPTION(throwScope, { });
    return JSValue::encode(jsValue);
}
JSC_ANNOTATE_HOST_FUNCTION(JSRTCPeerConnectionDOMConstructorConstruct, JSRTCPeerConnectionDOMConstructor::construct);

template<> const ClassInfo JSRTCPeerConnectionDOMConstructor::s_info = { "RTCPeerConnection"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSRTCPeerConnectionDOMConstructor) };

template<> JSValue JSRTCPeerConnectionDOMConstructor::prototypeForStructure(JSC::VM& vm, const JSDOMGlobalObject& globalObject)
{
    return JSEventTarget::getConstructor(vm, &globalObject);
}

template<> void JSRTCPeerConnectionDOMConstructor::initializeProperties(VM& vm, JSDOMGlobalObject& globalObject)
{
    putDirect(vm, vm.propertyNames->length, jsNumber(0), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);
    JSString* nameString = jsNontrivialString(vm, "RTCPeerConnection"_s);
    m_originalName.set(vm, this, nameString);
    putDirect(vm, vm.propertyNames->name, nameString, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);
    putDirect(vm, vm.propertyNames->prototype, JSRTCPeerConnection::prototype(vm, globalObject), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::DontDelete);
    reifyStaticProperties(vm, JSRTCPeerConnection::info(), JSRTCPeerConnectionConstructorTableValues, *this);
}

/* Hash table for prototype */

static const std::array<HashTableValue, 39> JSRTCPeerConnectionPrototypeTableValues {
    HashTableValue { "constructor"_s, static_cast<unsigned>(PropertyAttribute::DontEnum), NoIntrinsic, { HashTableValue::GetterSetterType, jsRTCPeerConnectionConstructor, 0 } },
    HashTableValue { "localDescription"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsRTCPeerConnection_localDescription, 0 } },
    HashTableValue { "currentLocalDescription"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsRTCPeerConnection_currentLocalDescription, 0 } },
    HashTableValue { "pendingLocalDescription"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsRTCPeerConnection_pendingLocalDescription, 0 } },
    HashTableValue { "remoteDescription"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsRTCPeerConnection_remoteDescription, 0 } },
    HashTableValue { "currentRemoteDescription"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsRTCPeerConnection_currentRemoteDescription, 0 } },
    HashTableValue { "pendingRemoteDescription"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsRTCPeerConnection_pendingRemoteDescription, 0 } },
    HashTableValue { "signalingState"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsRTCPeerConnection_signalingState, 0 } },
    HashTableValue { "iceGatheringState"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsRTCPeerConnection_iceGatheringState, 0 } },
    HashTableValue { "iceConnectionState"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsRTCPeerConnection_iceConnectionState, 0 } },
    HashTableValue { "connectionState"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsRTCPeerConnection_connectionState, 0 } },
    HashTableValue { "canTrickleIceCandidates"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsRTCPeerConnection_canTrickleIceCandidates, 0 } },
    HashTableValue { "onnegotiationneeded"_s, JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsRTCPeerConnection_onnegotiationneeded, setJSRTCPeerConnection_onnegotiationneeded } },
    HashTableValue { "onicecandidate"_s, JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsRTCPeerConnection_onicecandidate, setJSRTCPeerConnection_onicecandidate } },
    HashTableValue { "onsignalingstatechange"_s, JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsRTCPeerConnection_onsignalingstatechange, setJSRTCPeerConnection_onsignalingstatechange } },
    HashTableValue { "oniceconnectionstatechange"_s, JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsRTCPeerConnection_oniceconnectionstatechange, setJSRTCPeerConnection_oniceconnectionstatechange } },
    HashTableValue { "onicegatheringstatechange"_s, JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsRTCPeerConnection_onicegatheringstatechange, setJSRTCPeerConnection_onicegatheringstatechange } },
    HashTableValue { "onconnectionstatechange"_s, JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsRTCPeerConnection_onconnectionstatechange, setJSRTCPeerConnection_onconnectionstatechange } },
    HashTableValue { "onicecandidateerror"_s, JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsRTCPeerConnection_onicecandidateerror, setJSRTCPeerConnection_onicecandidateerror } },
    HashTableValue { "ontrack"_s, JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsRTCPeerConnection_ontrack, setJSRTCPeerConnection_ontrack } },
    HashTableValue { "sctp"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsRTCPeerConnection_sctp, 0 } },
    HashTableValue { "ondatachannel"_s, JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsRTCPeerConnection_ondatachannel, setJSRTCPeerConnection_ondatachannel } },
    HashTableValue { "createOffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsRTCPeerConnectionPrototypeFunction_createOffer, 0 } },
    HashTableValue { "createAnswer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsRTCPeerConnectionPrototypeFunction_createAnswer, 0 } },
    HashTableValue { "setLocalDescription"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsRTCPeerConnectionPrototypeFunction_setLocalDescription, 0 } },
    HashTableValue { "setRemoteDescription"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsRTCPeerConnectionPrototypeFunction_setRemoteDescription, 1 } },
    HashTableValue { "addIceCandidate"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsRTCPeerConnectionPrototypeFunction_addIceCandidate, 0 } },
    HashTableValue { "restartIce"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsRTCPeerConnectionPrototypeFunction_restartIce, 0 } },
    HashTableValue { "getConfiguration"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsRTCPeerConnectionPrototypeFunction_getConfiguration, 0 } },
    HashTableValue { "setConfiguration"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsRTCPeerConnectionPrototypeFunction_setConfiguration, 0 } },
    HashTableValue { "close"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsRTCPeerConnectionPrototypeFunction_close, 0 } },
    HashTableValue { "getSenders"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsRTCPeerConnectionPrototypeFunction_getSenders, 0 } },
    HashTableValue { "getReceivers"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsRTCPeerConnectionPrototypeFunction_getReceivers, 0 } },
    HashTableValue { "getTransceivers"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsRTCPeerConnectionPrototypeFunction_getTransceivers, 0 } },
    HashTableValue { "addTrack"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsRTCPeerConnectionPrototypeFunction_addTrack, 1 } },
    HashTableValue { "removeTrack"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsRTCPeerConnectionPrototypeFunction_removeTrack, 1 } },
    HashTableValue { "addTransceiver"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsRTCPeerConnectionPrototypeFunction_addTransceiver, 1 } },
    HashTableValue { "createDataChannel"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsRTCPeerConnectionPrototypeFunction_createDataChannel, 1 } },
    HashTableValue { "getStats"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsRTCPeerConnectionPrototypeFunction_getStats, 0 } },
};

const ClassInfo JSRTCPeerConnectionPrototype::s_info = { "RTCPeerConnection"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSRTCPeerConnectionPrototype) };

void JSRTCPeerConnectionPrototype::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSRTCPeerConnection::info(), JSRTCPeerConnectionPrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

const ClassInfo JSRTCPeerConnection::s_info = { "RTCPeerConnection"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSRTCPeerConnection) };

JSRTCPeerConnection::JSRTCPeerConnection(Structure* structure, JSDOMGlobalObject& globalObject, Ref<RTCPeerConnection>&& impl)
    : JSEventTarget(structure, globalObject, WTFMove(impl))
{
}

Ref<RTCPeerConnection> JSRTCPeerConnection::protectedWrapped() const
{
    return wrapped();
}

static_assert(std::is_base_of<ActiveDOMObject, RTCPeerConnection>::value, "Interface is marked as [ActiveDOMObject] but implementation class does not subclass ActiveDOMObject.");

JSObject* JSRTCPeerConnection::createPrototype(VM& vm, JSDOMGlobalObject& globalObject)
{
    auto* structure = JSRTCPeerConnectionPrototype::createStructure(vm, &globalObject, JSEventTarget::prototype(vm, globalObject));
    structure->setMayBePrototype(true);
    return JSRTCPeerConnectionPrototype::create(vm, &globalObject, structure);
}

JSObject* JSRTCPeerConnection::prototype(VM& vm, JSDOMGlobalObject& globalObject)
{
    return getDOMPrototype<JSRTCPeerConnection>(vm, globalObject);
}

JSValue JSRTCPeerConnection::getConstructor(VM& vm, const JSGlobalObject* globalObject)
{
    return getDOMConstructor<JSRTCPeerConnectionDOMConstructor, DOMConstructorID::RTCPeerConnection>(vm, *jsCast<const JSDOMGlobalObject*>(globalObject));
}

JSC_DEFINE_CUSTOM_GETTER(jsRTCPeerConnectionConstructor, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* prototype = jsDynamicCast<JSRTCPeerConnectionPrototype*>(JSValue::decode(thisValue));
    if (!prototype) [[unlikely]]
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(JSRTCPeerConnection::getConstructor(vm, prototype->globalObject()));
}

static inline JSValue jsRTCPeerConnection_localDescriptionGetter(JSGlobalObject& lexicalGlobalObject, JSRTCPeerConnection& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLNullable<IDLInterface<RTCSessionDescription>>>(lexicalGlobalObject, *thisObject.globalObject(), throwScope, impl.localDescription())));
}

JSC_DEFINE_CUSTOM_GETTER(jsRTCPeerConnection_localDescription, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCPeerConnection>::get<jsRTCPeerConnection_localDescriptionGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline JSValue jsRTCPeerConnection_currentLocalDescriptionGetter(JSGlobalObject& lexicalGlobalObject, JSRTCPeerConnection& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLNullable<IDLInterface<RTCSessionDescription>>>(lexicalGlobalObject, *thisObject.globalObject(), throwScope, impl.currentLocalDescription())));
}

JSC_DEFINE_CUSTOM_GETTER(jsRTCPeerConnection_currentLocalDescription, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCPeerConnection>::get<jsRTCPeerConnection_currentLocalDescriptionGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline JSValue jsRTCPeerConnection_pendingLocalDescriptionGetter(JSGlobalObject& lexicalGlobalObject, JSRTCPeerConnection& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLNullable<IDLInterface<RTCSessionDescription>>>(lexicalGlobalObject, *thisObject.globalObject(), throwScope, impl.pendingLocalDescription())));
}

JSC_DEFINE_CUSTOM_GETTER(jsRTCPeerConnection_pendingLocalDescription, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCPeerConnection>::get<jsRTCPeerConnection_pendingLocalDescriptionGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline JSValue jsRTCPeerConnection_remoteDescriptionGetter(JSGlobalObject& lexicalGlobalObject, JSRTCPeerConnection& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLNullable<IDLInterface<RTCSessionDescription>>>(lexicalGlobalObject, *thisObject.globalObject(), throwScope, impl.remoteDescription())));
}

JSC_DEFINE_CUSTOM_GETTER(jsRTCPeerConnection_remoteDescription, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCPeerConnection>::get<jsRTCPeerConnection_remoteDescriptionGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline JSValue jsRTCPeerConnection_currentRemoteDescriptionGetter(JSGlobalObject& lexicalGlobalObject, JSRTCPeerConnection& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLNullable<IDLInterface<RTCSessionDescription>>>(lexicalGlobalObject, *thisObject.globalObject(), throwScope, impl.currentRemoteDescription())));
}

JSC_DEFINE_CUSTOM_GETTER(jsRTCPeerConnection_currentRemoteDescription, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCPeerConnection>::get<jsRTCPeerConnection_currentRemoteDescriptionGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline JSValue jsRTCPeerConnection_pendingRemoteDescriptionGetter(JSGlobalObject& lexicalGlobalObject, JSRTCPeerConnection& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLNullable<IDLInterface<RTCSessionDescription>>>(lexicalGlobalObject, *thisObject.globalObject(), throwScope, impl.pendingRemoteDescription())));
}

JSC_DEFINE_CUSTOM_GETTER(jsRTCPeerConnection_pendingRemoteDescription, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCPeerConnection>::get<jsRTCPeerConnection_pendingRemoteDescriptionGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline JSValue jsRTCPeerConnection_signalingStateGetter(JSGlobalObject& lexicalGlobalObject, JSRTCPeerConnection& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLEnumeration<RTCSignalingState>>(lexicalGlobalObject, throwScope, impl.signalingState())));
}

JSC_DEFINE_CUSTOM_GETTER(jsRTCPeerConnection_signalingState, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCPeerConnection>::get<jsRTCPeerConnection_signalingStateGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline JSValue jsRTCPeerConnection_iceGatheringStateGetter(JSGlobalObject& lexicalGlobalObject, JSRTCPeerConnection& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLEnumeration<RTCIceGatheringState>>(lexicalGlobalObject, throwScope, impl.iceGatheringState())));
}

JSC_DEFINE_CUSTOM_GETTER(jsRTCPeerConnection_iceGatheringState, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCPeerConnection>::get<jsRTCPeerConnection_iceGatheringStateGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline JSValue jsRTCPeerConnection_iceConnectionStateGetter(JSGlobalObject& lexicalGlobalObject, JSRTCPeerConnection& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLEnumeration<RTCIceConnectionState>>(lexicalGlobalObject, throwScope, impl.iceConnectionState())));
}

JSC_DEFINE_CUSTOM_GETTER(jsRTCPeerConnection_iceConnectionState, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCPeerConnection>::get<jsRTCPeerConnection_iceConnectionStateGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline JSValue jsRTCPeerConnection_connectionStateGetter(JSGlobalObject& lexicalGlobalObject, JSRTCPeerConnection& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLEnumeration<RTCPeerConnectionState>>(lexicalGlobalObject, throwScope, impl.connectionState())));
}

JSC_DEFINE_CUSTOM_GETTER(jsRTCPeerConnection_connectionState, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCPeerConnection>::get<jsRTCPeerConnection_connectionStateGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline JSValue jsRTCPeerConnection_canTrickleIceCandidatesGetter(JSGlobalObject& lexicalGlobalObject, JSRTCPeerConnection& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLNullable<IDLBoolean>>(lexicalGlobalObject, throwScope, impl.canTrickleIceCandidates())));
}

JSC_DEFINE_CUSTOM_GETTER(jsRTCPeerConnection_canTrickleIceCandidates, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCPeerConnection>::get<jsRTCPeerConnection_canTrickleIceCandidatesGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline JSValue jsRTCPeerConnection_onnegotiationneededGetter(JSGlobalObject& lexicalGlobalObject, JSRTCPeerConnection& thisObject)
{
    UNUSED_PARAM(lexicalGlobalObject);
    return eventHandlerAttribute(thisObject.protectedWrapped(), eventNames().negotiationneededEvent, worldForDOMObject(thisObject));
}

JSC_DEFINE_CUSTOM_GETTER(jsRTCPeerConnection_onnegotiationneeded, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCPeerConnection>::get<jsRTCPeerConnection_onnegotiationneededGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline bool setJSRTCPeerConnection_onnegotiationneededSetter(JSGlobalObject& lexicalGlobalObject, JSRTCPeerConnection& thisObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    UNUSED_PARAM(vm);
    setEventHandlerAttribute<JSEventListener>(thisObject.protectedWrapped(), eventNames().negotiationneededEvent, value, thisObject);
    vm.writeBarrier(&thisObject, value);
    ensureStillAliveHere(value);

    return true;
}

JSC_DEFINE_CUSTOM_SETTER(setJSRTCPeerConnection_onnegotiationneeded, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, EncodedJSValue encodedValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCPeerConnection>::set<setJSRTCPeerConnection_onnegotiationneededSetter>(*lexicalGlobalObject, thisValue, encodedValue, attributeName);
}

static inline JSValue jsRTCPeerConnection_onicecandidateGetter(JSGlobalObject& lexicalGlobalObject, JSRTCPeerConnection& thisObject)
{
    UNUSED_PARAM(lexicalGlobalObject);
    return eventHandlerAttribute(thisObject.protectedWrapped(), eventNames().icecandidateEvent, worldForDOMObject(thisObject));
}

JSC_DEFINE_CUSTOM_GETTER(jsRTCPeerConnection_onicecandidate, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCPeerConnection>::get<jsRTCPeerConnection_onicecandidateGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline bool setJSRTCPeerConnection_onicecandidateSetter(JSGlobalObject& lexicalGlobalObject, JSRTCPeerConnection& thisObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    UNUSED_PARAM(vm);
    setEventHandlerAttribute<JSEventListener>(thisObject.protectedWrapped(), eventNames().icecandidateEvent, value, thisObject);
    vm.writeBarrier(&thisObject, value);
    ensureStillAliveHere(value);

    return true;
}

JSC_DEFINE_CUSTOM_SETTER(setJSRTCPeerConnection_onicecandidate, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, EncodedJSValue encodedValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCPeerConnection>::set<setJSRTCPeerConnection_onicecandidateSetter>(*lexicalGlobalObject, thisValue, encodedValue, attributeName);
}

static inline JSValue jsRTCPeerConnection_onsignalingstatechangeGetter(JSGlobalObject& lexicalGlobalObject, JSRTCPeerConnection& thisObject)
{
    UNUSED_PARAM(lexicalGlobalObject);
    return eventHandlerAttribute(thisObject.protectedWrapped(), eventNames().signalingstatechangeEvent, worldForDOMObject(thisObject));
}

JSC_DEFINE_CUSTOM_GETTER(jsRTCPeerConnection_onsignalingstatechange, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCPeerConnection>::get<jsRTCPeerConnection_onsignalingstatechangeGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline bool setJSRTCPeerConnection_onsignalingstatechangeSetter(JSGlobalObject& lexicalGlobalObject, JSRTCPeerConnection& thisObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    UNUSED_PARAM(vm);
    setEventHandlerAttribute<JSEventListener>(thisObject.protectedWrapped(), eventNames().signalingstatechangeEvent, value, thisObject);
    vm.writeBarrier(&thisObject, value);
    ensureStillAliveHere(value);

    return true;
}

JSC_DEFINE_CUSTOM_SETTER(setJSRTCPeerConnection_onsignalingstatechange, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, EncodedJSValue encodedValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCPeerConnection>::set<setJSRTCPeerConnection_onsignalingstatechangeSetter>(*lexicalGlobalObject, thisValue, encodedValue, attributeName);
}

static inline JSValue jsRTCPeerConnection_oniceconnectionstatechangeGetter(JSGlobalObject& lexicalGlobalObject, JSRTCPeerConnection& thisObject)
{
    UNUSED_PARAM(lexicalGlobalObject);
    return eventHandlerAttribute(thisObject.protectedWrapped(), eventNames().iceconnectionstatechangeEvent, worldForDOMObject(thisObject));
}

JSC_DEFINE_CUSTOM_GETTER(jsRTCPeerConnection_oniceconnectionstatechange, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCPeerConnection>::get<jsRTCPeerConnection_oniceconnectionstatechangeGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline bool setJSRTCPeerConnection_oniceconnectionstatechangeSetter(JSGlobalObject& lexicalGlobalObject, JSRTCPeerConnection& thisObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    UNUSED_PARAM(vm);
    setEventHandlerAttribute<JSEventListener>(thisObject.protectedWrapped(), eventNames().iceconnectionstatechangeEvent, value, thisObject);
    vm.writeBarrier(&thisObject, value);
    ensureStillAliveHere(value);

    return true;
}

JSC_DEFINE_CUSTOM_SETTER(setJSRTCPeerConnection_oniceconnectionstatechange, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, EncodedJSValue encodedValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCPeerConnection>::set<setJSRTCPeerConnection_oniceconnectionstatechangeSetter>(*lexicalGlobalObject, thisValue, encodedValue, attributeName);
}

static inline JSValue jsRTCPeerConnection_onicegatheringstatechangeGetter(JSGlobalObject& lexicalGlobalObject, JSRTCPeerConnection& thisObject)
{
    UNUSED_PARAM(lexicalGlobalObject);
    return eventHandlerAttribute(thisObject.protectedWrapped(), eventNames().icegatheringstatechangeEvent, worldForDOMObject(thisObject));
}

JSC_DEFINE_CUSTOM_GETTER(jsRTCPeerConnection_onicegatheringstatechange, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCPeerConnection>::get<jsRTCPeerConnection_onicegatheringstatechangeGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline bool setJSRTCPeerConnection_onicegatheringstatechangeSetter(JSGlobalObject& lexicalGlobalObject, JSRTCPeerConnection& thisObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    UNUSED_PARAM(vm);
    setEventHandlerAttribute<JSEventListener>(thisObject.protectedWrapped(), eventNames().icegatheringstatechangeEvent, value, thisObject);
    vm.writeBarrier(&thisObject, value);
    ensureStillAliveHere(value);

    return true;
}

JSC_DEFINE_CUSTOM_SETTER(setJSRTCPeerConnection_onicegatheringstatechange, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, EncodedJSValue encodedValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCPeerConnection>::set<setJSRTCPeerConnection_onicegatheringstatechangeSetter>(*lexicalGlobalObject, thisValue, encodedValue, attributeName);
}

static inline JSValue jsRTCPeerConnection_onconnectionstatechangeGetter(JSGlobalObject& lexicalGlobalObject, JSRTCPeerConnection& thisObject)
{
    UNUSED_PARAM(lexicalGlobalObject);
    return eventHandlerAttribute(thisObject.protectedWrapped(), eventNames().connectionstatechangeEvent, worldForDOMObject(thisObject));
}

JSC_DEFINE_CUSTOM_GETTER(jsRTCPeerConnection_onconnectionstatechange, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCPeerConnection>::get<jsRTCPeerConnection_onconnectionstatechangeGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline bool setJSRTCPeerConnection_onconnectionstatechangeSetter(JSGlobalObject& lexicalGlobalObject, JSRTCPeerConnection& thisObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    UNUSED_PARAM(vm);
    setEventHandlerAttribute<JSEventListener>(thisObject.protectedWrapped(), eventNames().connectionstatechangeEvent, value, thisObject);
    vm.writeBarrier(&thisObject, value);
    ensureStillAliveHere(value);

    return true;
}

JSC_DEFINE_CUSTOM_SETTER(setJSRTCPeerConnection_onconnectionstatechange, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, EncodedJSValue encodedValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCPeerConnection>::set<setJSRTCPeerConnection_onconnectionstatechangeSetter>(*lexicalGlobalObject, thisValue, encodedValue, attributeName);
}

static inline JSValue jsRTCPeerConnection_onicecandidateerrorGetter(JSGlobalObject& lexicalGlobalObject, JSRTCPeerConnection& thisObject)
{
    UNUSED_PARAM(lexicalGlobalObject);
    return eventHandlerAttribute(thisObject.protectedWrapped(), eventNames().icecandidateerrorEvent, worldForDOMObject(thisObject));
}

JSC_DEFINE_CUSTOM_GETTER(jsRTCPeerConnection_onicecandidateerror, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCPeerConnection>::get<jsRTCPeerConnection_onicecandidateerrorGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline bool setJSRTCPeerConnection_onicecandidateerrorSetter(JSGlobalObject& lexicalGlobalObject, JSRTCPeerConnection& thisObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    UNUSED_PARAM(vm);
    setEventHandlerAttribute<JSEventListener>(thisObject.protectedWrapped(), eventNames().icecandidateerrorEvent, value, thisObject);
    vm.writeBarrier(&thisObject, value);
    ensureStillAliveHere(value);

    return true;
}

JSC_DEFINE_CUSTOM_SETTER(setJSRTCPeerConnection_onicecandidateerror, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, EncodedJSValue encodedValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCPeerConnection>::set<setJSRTCPeerConnection_onicecandidateerrorSetter>(*lexicalGlobalObject, thisValue, encodedValue, attributeName);
}

static inline JSValue jsRTCPeerConnection_ontrackGetter(JSGlobalObject& lexicalGlobalObject, JSRTCPeerConnection& thisObject)
{
    UNUSED_PARAM(lexicalGlobalObject);
    return eventHandlerAttribute(thisObject.protectedWrapped(), eventNames().trackEvent, worldForDOMObject(thisObject));
}

JSC_DEFINE_CUSTOM_GETTER(jsRTCPeerConnection_ontrack, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCPeerConnection>::get<jsRTCPeerConnection_ontrackGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline bool setJSRTCPeerConnection_ontrackSetter(JSGlobalObject& lexicalGlobalObject, JSRTCPeerConnection& thisObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    UNUSED_PARAM(vm);
    setEventHandlerAttribute<JSEventListener>(thisObject.protectedWrapped(), eventNames().trackEvent, value, thisObject);
    vm.writeBarrier(&thisObject, value);
    ensureStillAliveHere(value);

    return true;
}

JSC_DEFINE_CUSTOM_SETTER(setJSRTCPeerConnection_ontrack, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, EncodedJSValue encodedValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCPeerConnection>::set<setJSRTCPeerConnection_ontrackSetter>(*lexicalGlobalObject, thisValue, encodedValue, attributeName);
}

static inline JSValue jsRTCPeerConnection_sctpGetter(JSGlobalObject& lexicalGlobalObject, JSRTCPeerConnection& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLNullable<IDLInterface<RTCSctpTransport>>>(lexicalGlobalObject, *thisObject.globalObject(), throwScope, impl.sctp())));
}

JSC_DEFINE_CUSTOM_GETTER(jsRTCPeerConnection_sctp, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCPeerConnection>::get<jsRTCPeerConnection_sctpGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline JSValue jsRTCPeerConnection_ondatachannelGetter(JSGlobalObject& lexicalGlobalObject, JSRTCPeerConnection& thisObject)
{
    UNUSED_PARAM(lexicalGlobalObject);
    return eventHandlerAttribute(thisObject.protectedWrapped(), eventNames().datachannelEvent, worldForDOMObject(thisObject));
}

JSC_DEFINE_CUSTOM_GETTER(jsRTCPeerConnection_ondatachannel, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCPeerConnection>::get<jsRTCPeerConnection_ondatachannelGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

static inline bool setJSRTCPeerConnection_ondatachannelSetter(JSGlobalObject& lexicalGlobalObject, JSRTCPeerConnection& thisObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    UNUSED_PARAM(vm);
    setEventHandlerAttribute<JSEventListener>(thisObject.protectedWrapped(), eventNames().datachannelEvent, value, thisObject);
    vm.writeBarrier(&thisObject, value);
    ensureStillAliveHere(value);

    return true;
}

JSC_DEFINE_CUSTOM_SETTER(setJSRTCPeerConnection_ondatachannel, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, EncodedJSValue encodedValue, PropertyName attributeName))
{
    return IDLAttribute<JSRTCPeerConnection>::set<setJSRTCPeerConnection_ondatachannelSetter>(*lexicalGlobalObject, thisValue, encodedValue, attributeName);
}

static inline JSC::EncodedJSValue jsRTCPeerConnectionPrototypeFunction_createOfferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperationReturningPromise<JSRTCPeerConnection>::ClassParameter castedThis, Ref<DeferredPromise>&& promise)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->argument(0);
    auto offerOptionsConversionResult = convert<IDLDictionary<RTCOfferOptions>>(*lexicalGlobalObject, argument0.value());
    if (offerOptionsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLPromise<IDLDictionary<RTCSessionDescriptionInit>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, [&]() -> decltype(auto) { return impl.createOffer(offerOptionsConversionResult.releaseReturnValue(), WTFMove(promise)); })));
}

JSC_DEFINE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_createOffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperationReturningPromise<JSRTCPeerConnection>::call<jsRTCPeerConnectionPrototypeFunction_createOfferBody>(*lexicalGlobalObject, *callFrame, "createOffer");
}

static inline JSC::EncodedJSValue jsRTCPeerConnectionPrototypeFunction_createAnswerBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperationReturningPromise<JSRTCPeerConnection>::ClassParameter castedThis, Ref<DeferredPromise>&& promise)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->argument(0);
    auto answerOptionsConversionResult = convert<IDLDictionary<RTCAnswerOptions>>(*lexicalGlobalObject, argument0.value());
    if (answerOptionsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLPromise<IDLDictionary<RTCSessionDescriptionInit>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, [&]() -> decltype(auto) { return impl.createAnswer(answerOptionsConversionResult.releaseReturnValue(), WTFMove(promise)); })));
}

JSC_DEFINE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_createAnswer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperationReturningPromise<JSRTCPeerConnection>::call<jsRTCPeerConnectionPrototypeFunction_createAnswerBody>(*lexicalGlobalObject, *callFrame, "createAnswer");
}

static inline JSC::EncodedJSValue jsRTCPeerConnectionPrototypeFunction_setLocalDescriptionBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperationReturningPromise<JSRTCPeerConnection>::ClassParameter castedThis, Ref<DeferredPromise>&& promise)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->argument(0);
    auto descriptionConversionResult = convert<IDLDictionary<RTCLocalSessionDescriptionInit>>(*lexicalGlobalObject, argument0.value());
    if (descriptionConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLPromise<IDLUndefined>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, [&]() -> decltype(auto) { return impl.setLocalDescription(descriptionConversionResult.releaseReturnValue(), WTFMove(promise)); })));
}

JSC_DEFINE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_setLocalDescription, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperationReturningPromise<JSRTCPeerConnection>::call<jsRTCPeerConnectionPrototypeFunction_setLocalDescriptionBody>(*lexicalGlobalObject, *callFrame, "setLocalDescription");
}

static inline JSC::EncodedJSValue jsRTCPeerConnectionPrototypeFunction_setRemoteDescriptionBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperationReturningPromise<JSRTCPeerConnection>::ClassParameter castedThis, Ref<DeferredPromise>&& promise)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto descriptionConversionResult = convert<IDLDictionary<RTCSessionDescriptionInit>>(*lexicalGlobalObject, argument0.value());
    if (descriptionConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLPromise<IDLUndefined>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, [&]() -> decltype(auto) { return impl.setRemoteDescription(descriptionConversionResult.releaseReturnValue(), WTFMove(promise)); })));
}

JSC_DEFINE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_setRemoteDescription, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperationReturningPromise<JSRTCPeerConnection>::call<jsRTCPeerConnectionPrototypeFunction_setRemoteDescriptionBody>(*lexicalGlobalObject, *callFrame, "setRemoteDescription");
}

static inline JSC::EncodedJSValue jsRTCPeerConnectionPrototypeFunction_addIceCandidateBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperationReturningPromise<JSRTCPeerConnection>::ClassParameter castedThis, Ref<DeferredPromise>&& promise)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->argument(0);
    auto candidateConversionResult = convert<IDLOptional<IDLUnion<IDLDictionary<RTCIceCandidateInit>, IDLInterface<RTCIceCandidate>>>>(*lexicalGlobalObject, argument0.value());
    if (candidateConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLPromise<IDLUndefined>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, [&]() -> decltype(auto) { return impl.addIceCandidate(candidateConversionResult.releaseReturnValue(), WTFMove(promise)); })));
}

JSC_DEFINE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_addIceCandidate, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperationReturningPromise<JSRTCPeerConnection>::call<jsRTCPeerConnectionPrototypeFunction_addIceCandidateBody>(*lexicalGlobalObject, *callFrame, "addIceCandidate");
}

static inline JSC::EncodedJSValue jsRTCPeerConnectionPrototypeFunction_restartIceBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSRTCPeerConnection>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.restartIce(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_restartIce, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSRTCPeerConnection>::call<jsRTCPeerConnectionPrototypeFunction_restartIceBody>(*lexicalGlobalObject, *callFrame, "restartIce");
}

static inline JSC::EncodedJSValue jsRTCPeerConnectionPrototypeFunction_getConfigurationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSRTCPeerConnection>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLDictionary<RTCConfiguration>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getConfiguration())));
}

JSC_DEFINE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_getConfiguration, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSRTCPeerConnection>::call<jsRTCPeerConnectionPrototypeFunction_getConfigurationBody>(*lexicalGlobalObject, *callFrame, "getConfiguration");
}

static inline JSC::EncodedJSValue jsRTCPeerConnectionPrototypeFunction_setConfigurationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSRTCPeerConnection>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->argument(0);
    auto configurationConversionResult = convert<IDLDictionary<RTCConfiguration>>(*lexicalGlobalObject, argument0.value());
    if (configurationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.setConfiguration(configurationConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_setConfiguration, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSRTCPeerConnection>::call<jsRTCPeerConnectionPrototypeFunction_setConfigurationBody>(*lexicalGlobalObject, *callFrame, "setConfiguration");
}

static inline JSC::EncodedJSValue jsRTCPeerConnectionPrototypeFunction_closeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSRTCPeerConnection>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.close(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_close, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSRTCPeerConnection>::call<jsRTCPeerConnectionPrototypeFunction_closeBody>(*lexicalGlobalObject, *callFrame, "close");
}

static inline JSC::EncodedJSValue jsRTCPeerConnectionConstructorFunction_generateCertificateBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, Ref<DeferredPromise>&& promise)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto keygenAlgorithmConversionResult = convert<IDLUnion<IDLObject, IDLDOMString>>(*lexicalGlobalObject, argument0.value());
    if (keygenAlgorithmConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLPromise<IDLInterface<RTCCertificate>>>(*lexicalGlobalObject, *jsCast<JSDOMGlobalObject*>(lexicalGlobalObject), throwScope, [&]() -> decltype(auto) { return RTCPeerConnection::generateCertificate(*jsCast<JSDOMGlobalObject*>(lexicalGlobalObject), keygenAlgorithmConversionResult.releaseReturnValue(), WTFMove(promise)); })));
}

JSC_DEFINE_HOST_FUNCTION(jsRTCPeerConnectionConstructorFunction_generateCertificate, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperationReturningPromise<JSRTCPeerConnection>::callStatic<jsRTCPeerConnectionConstructorFunction_generateCertificateBody>(*lexicalGlobalObject, *callFrame, "generateCertificate");
}

static inline JSC::EncodedJSValue jsRTCPeerConnectionPrototypeFunction_getSendersBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSRTCPeerConnection>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLSequence<IDLInterface<RTCRtpSender>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getSenders())));
}

JSC_DEFINE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_getSenders, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSRTCPeerConnection>::call<jsRTCPeerConnectionPrototypeFunction_getSendersBody>(*lexicalGlobalObject, *callFrame, "getSenders");
}

static inline JSC::EncodedJSValue jsRTCPeerConnectionPrototypeFunction_getReceiversBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSRTCPeerConnection>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLSequence<IDLInterface<RTCRtpReceiver>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getReceivers())));
}

JSC_DEFINE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_getReceivers, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSRTCPeerConnection>::call<jsRTCPeerConnectionPrototypeFunction_getReceiversBody>(*lexicalGlobalObject, *callFrame, "getReceivers");
}

static inline JSC::EncodedJSValue jsRTCPeerConnectionPrototypeFunction_getTransceiversBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSRTCPeerConnection>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLSequence<IDLInterface<RTCRtpTransceiver>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getTransceivers())));
}

JSC_DEFINE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_getTransceivers, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSRTCPeerConnection>::call<jsRTCPeerConnectionPrototypeFunction_getTransceiversBody>(*lexicalGlobalObject, *callFrame, "getTransceivers");
}

static inline JSC::EncodedJSValue jsRTCPeerConnectionPrototypeFunction_addTrackBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSRTCPeerConnection>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto trackConversionResult = convert<IDLInterface<MediaStreamTrack>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "track"_s, "RTCPeerConnection"_s, "addTrack"_s, "MediaStreamTrack"_s); });
    if (trackConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    auto streams = convertVariadicArguments<IDLInterface<MediaStream>>(*lexicalGlobalObject, *callFrame, 1);
    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<RTCRtpSender>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.addTrack(*trackConversionResult.releaseReturnValue(), WTFMove(streams)))));
}

JSC_DEFINE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_addTrack, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSRTCPeerConnection>::call<jsRTCPeerConnectionPrototypeFunction_addTrackBody>(*lexicalGlobalObject, *callFrame, "addTrack");
}

static inline JSC::EncodedJSValue jsRTCPeerConnectionPrototypeFunction_removeTrackBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSRTCPeerConnection>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto senderConversionResult = convert<IDLInterface<RTCRtpSender>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "sender"_s, "RTCPeerConnection"_s, "removeTrack"_s, "RTCRtpSender"_s); });
    if (senderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.removeTrack(*senderConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_removeTrack, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSRTCPeerConnection>::call<jsRTCPeerConnectionPrototypeFunction_removeTrackBody>(*lexicalGlobalObject, *callFrame, "removeTrack");
}

static inline JSC::EncodedJSValue jsRTCPeerConnectionPrototypeFunction_addTransceiverBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSRTCPeerConnection>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto trackConversionResult = convert<IDLUnion<IDLInterface<MediaStreamTrack>, IDLDOMString>>(*lexicalGlobalObject, argument0.value());
    if (trackConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->argument(1);
    auto initConversionResult = convert<IDLDictionary<RTCRtpTransceiverInit>>(*lexicalGlobalObject, argument1.value());
    if (initConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<RTCRtpTransceiver>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.addTransceiver(trackConversionResult.releaseReturnValue(), initConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_addTransceiver, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSRTCPeerConnection>::call<jsRTCPeerConnectionPrototypeFunction_addTransceiverBody>(*lexicalGlobalObject, *callFrame, "addTransceiver");
}

static inline JSC::EncodedJSValue jsRTCPeerConnectionPrototypeFunction_createDataChannelBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSRTCPeerConnection>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto labelConversionResult = convert<IDLUSVString>(*lexicalGlobalObject, argument0.value());
    if (labelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->argument(1);
    auto optionsConversionResult = convert<IDLDictionary<RTCPeerConnection::DataChannelInit>>(*lexicalGlobalObject, argument1.value());
    if (optionsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<RTCDataChannel>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.createDataChannel(labelConversionResult.releaseReturnValue(), optionsConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_createDataChannel, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSRTCPeerConnection>::call<jsRTCPeerConnectionPrototypeFunction_createDataChannelBody>(*lexicalGlobalObject, *callFrame, "createDataChannel");
}

static inline JSC::EncodedJSValue jsRTCPeerConnectionPrototypeFunction_getStatsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperationReturningPromise<JSRTCPeerConnection>::ClassParameter castedThis, Ref<DeferredPromise>&& promise)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->argument(0);
    auto selectorConversionResult = convert<IDLNullable<IDLInterface<MediaStreamTrack>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "selector"_s, "RTCPeerConnection"_s, "getStats"_s, "MediaStreamTrack"_s); });
    if (selectorConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLPromise<IDLInterface<RTCStatsReport>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, [&]() -> decltype(auto) { return impl.getStats(selectorConversionResult.releaseReturnValue(), WTFMove(promise)); })));
}

JSC_DEFINE_HOST_FUNCTION(jsRTCPeerConnectionPrototypeFunction_getStats, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperationReturningPromise<JSRTCPeerConnection>::call<jsRTCPeerConnectionPrototypeFunction_getStatsBody>(*lexicalGlobalObject, *callFrame, "getStats");
}

JSC::GCClient::IsoSubspace* JSRTCPeerConnection::subspaceForImpl(JSC::VM& vm)
{
    return WebCore::subspaceForImpl<JSRTCPeerConnection, UseCustomHeapCellType::No>(vm, "JSRTCPeerConnection"_s,
        [] (auto& spaces) { return spaces.m_clientSubspaceForRTCPeerConnection.get(); },
        [] (auto& spaces, auto&& space) { spaces.m_clientSubspaceForRTCPeerConnection = std::forward<decltype(space)>(space); },
        [] (auto& spaces) { return spaces.m_subspaceForRTCPeerConnection.get(); },
        [] (auto& spaces, auto&& space) { spaces.m_subspaceForRTCPeerConnection = std::forward<decltype(space)>(space); }
    );
}

void JSRTCPeerConnection::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSRTCPeerConnection*>(cell);
    analyzer.setWrappedObjectForCell(cell, &thisObject->wrapped());
    if (RefPtr context = thisObject->scriptExecutionContext())
        analyzer.setLabelForCell(cell, makeString("url "_s, context->url().string()));
    Base::analyzeHeap(cell, analyzer);
}

bool JSRTCPeerConnectionOwner::isReachableFromOpaqueRoots(JSC::Handle<JSC::Unknown> handle, void*, AbstractSlotVisitor& visitor, ASCIILiteral* reason)
{
    SUPPRESS_UNCOUNTED_LOCAL auto* jsRTCPeerConnection = jsCast<JSRTCPeerConnection*>(handle.slot()->asCell());
    SUPPRESS_UNCOUNTED_LOCAL auto& wrapped = jsRTCPeerConnection->wrapped();
    if (!wrapped.isContextStopped() && wrapped.hasPendingActivity()) {
        if (reason) [[unlikely]]
            *reason = "ActiveDOMObject with pending activity"_s;
        return true;
     }
    UNUSED_PARAM(visitor);
    UNUSED_PARAM(reason);
    return false;
}

void JSRTCPeerConnectionOwner::finalize(JSC::Handle<JSC::Unknown> handle, void* context)
{
    auto* jsRTCPeerConnection = static_cast<JSRTCPeerConnection*>(handle.slot()->asCell());
    auto& world = *static_cast<DOMWrapperWorld*>(context);
    uncacheWrapper(world, jsRTCPeerConnection->protectedWrapped().ptr(), jsRTCPeerConnection);
}

WTF_ALLOW_UNSAFE_BUFFER_USAGE_BEGIN
#if ENABLE(BINDING_INTEGRITY)
#if PLATFORM(WIN)
#pragma warning(disable: 4483)
extern "C" { extern void (*const __identifier("??_7RTCPeerConnection@WebCore@@6B@")[])(); }
#else
extern "C" { extern void* _ZTVN7WebCore17RTCPeerConnectionE[]; }
#endif
template<std::same_as<RTCPeerConnection> T>
static inline void verifyVTable(RTCPeerConnection* ptr) 
{
    if constexpr (std::is_polymorphic_v<T>) {
        const void* actualVTablePointer = getVTablePointer<T>(ptr);
#if PLATFORM(WIN)
        void* expectedVTablePointer = __identifier("??_7RTCPeerConnection@WebCore@@6B@");
#else
        void* expectedVTablePointer = &_ZTVN7WebCore17RTCPeerConnectionE[2];
#endif

        // If you hit this assertion you either have a use after free bug, or
        // RTCPeerConnection has subclasses. If RTCPeerConnection has subclasses that get passed
        // to toJS() we currently require RTCPeerConnection you to opt out of binding hardening
        // by adding the SkipVTableValidation attribute to the interface IDL definition
        RELEASE_ASSERT(actualVTablePointer == expectedVTablePointer);
    }
}
#endif
WTF_ALLOW_UNSAFE_BUFFER_USAGE_END

JSC::JSValue toJSNewlyCreated(JSC::JSGlobalObject*, JSDOMGlobalObject* globalObject, Ref<RTCPeerConnection>&& impl)
{
#if ENABLE(BINDING_INTEGRITY)
    verifyVTable<RTCPeerConnection>(impl.ptr());
#endif
    return createWrapper<RTCPeerConnection>(globalObject, WTFMove(impl));
}

JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, RTCPeerConnection& impl)
{
    return wrap(lexicalGlobalObject, globalObject, impl);
}

RTCPeerConnection* JSRTCPeerConnection::toWrapped(JSC::VM&, JSC::JSValue value)
{
    if (auto* wrapper = jsDynamicCast<JSRTCPeerConnection*>(value))
        return &wrapper->wrapped();
    return nullptr;
}

}

#endif // ENABLE(WEB_RTC)
