// This file is automatically generated from CSSProperties.json by the process-css-properties.py script. Do not edit it.

#include "config.h"
#include "CSSPropertyParsing.h"

#include "CSSParserContext.h"
#include "CSSParserIdioms.h"
#include "CSSPropertyParser.h"
#include "CSSPropertyParserCustom.h"
#include "CSSPropertyParserState.h"
#include "DeprecatedGlobalSettings.h"

namespace WebCore {

using namespace CSSPropertyParserHelpers;

static bool isKeywordValidForRubyPosition(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueInterCharacter:
    case CSSValueID::CSSValueOver:
    case CSSValueID::CSSValueUnder:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWritingMode(CSSValueID keyword, CSS::PropertyParserState& state)
{
    switch (keyword) {
    case CSSValueID::CSSValueHorizontalBt:
    case CSSValueID::CSSValueHorizontalTb:
    case CSSValueID::CSSValueLr:
    case CSSValueID::CSSValueLrTb:
    case CSSValueID::CSSValueRl:
    case CSSValueID::CSSValueRlTb:
    case CSSValueID::CSSValueTb:
    case CSSValueID::CSSValueTbRl:
    case CSSValueID::CSSValueVerticalLr:
    case CSSValueID::CSSValueVerticalRl:
        return true;
    case CSSValueID::CSSValueSidewaysLr:
    case CSSValueID::CSSValueSidewaysRl:
        return state.context.sidewaysWritingModesEnabled;
    default:
        return false;
    }
}

static bool isKeywordValidForDirection(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueLtr:
    case CSSValueID::CSSValueRtl:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForFontFeatureSettings(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNormal:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForFontKerning(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValueNormal:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForFontOpticalSizing(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForFontPalette(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueDark:
    case CSSValueID::CSSValueLight:
    case CSSValueID::CSSValueNormal:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForFontSize(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueLarge:
    case CSSValueID::CSSValueLarger:
    case CSSValueID::CSSValueMedium:
    case CSSValueID::CSSValueSmall:
    case CSSValueID::CSSValueSmaller:
    case CSSValueID::CSSValueXLarge:
    case CSSValueID::CSSValueXSmall:
    case CSSValueID::CSSValueXxLarge:
    case CSSValueID::CSSValueXxSmall:
    case CSSValueID::CSSValueXxxLarge:
    case CSSValueID::CSSValueWebkitRubyText:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForFontSynthesisSmallCaps(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForFontSynthesisStyle(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForFontSynthesisWeight(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForFontVariantAlternates(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNormal:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForFontVariantCaps(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAllPetiteCaps:
    case CSSValueID::CSSValueAllSmallCaps:
    case CSSValueID::CSSValueNormal:
    case CSSValueID::CSSValuePetiteCaps:
    case CSSValueID::CSSValueSmallCaps:
    case CSSValueID::CSSValueTitlingCaps:
    case CSSValueID::CSSValueUnicase:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForFontVariantEastAsian(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNormal:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForFontVariantEmoji(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueEmoji:
    case CSSValueID::CSSValueNormal:
    case CSSValueID::CSSValueText:
    case CSSValueID::CSSValueUnicode:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForFontVariantLigatures(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValueNormal:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForFontVariantNumeric(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNormal:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForFontVariantPosition(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNormal:
    case CSSValueID::CSSValueSub:
    case CSSValueID::CSSValueSuper:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForFontVariationSettings(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNormal:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForFontWeight(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueBold:
    case CSSValueID::CSSValueBolder:
    case CSSValueID::CSSValueLighter:
    case CSSValueID::CSSValueNormal:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForFontWidth(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueCondensed:
    case CSSValueID::CSSValueExpanded:
    case CSSValueID::CSSValueExtraCondensed:
    case CSSValueID::CSSValueExtraExpanded:
    case CSSValueID::CSSValueNormal:
    case CSSValueID::CSSValueSemiCondensed:
    case CSSValueID::CSSValueSemiExpanded:
    case CSSValueID::CSSValueUltraCondensed:
    case CSSValueID::CSSValueUltraExpanded:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForTextOrientation(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueMixed:
    case CSSValueID::CSSValueSideways:
    case CSSValueID::CSSValueUpright:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForTextRendering(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueGeometricPrecision:
    case CSSValueID::CSSValueOptimizeLegibility:
    case CSSValueID::CSSValueOptimizeSpeed:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForZoom(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNormal:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitFontSmoothing(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAntialiased:
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValueSubpixelAntialiased:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitLocale(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitTextZoom(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNormal:
    case CSSValueID::CSSValueReset:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForLetterSpacing(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNormal:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForTextAutospace(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueNoAutospace:
    case CSSValueID::CSSValueNormal:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForTextSpacingTrim(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueSpaceAll:
    case CSSValueID::CSSValueTrimAll:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForAccentColor(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForAlignmentBaseline(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAfterEdge:
    case CSSValueID::CSSValueAlphabetic:
    case CSSValueID::CSSValueBaseline:
    case CSSValueID::CSSValueBeforeEdge:
    case CSSValueID::CSSValueCentral:
    case CSSValueID::CSSValueHanging:
    case CSSValueID::CSSValueIdeographic:
    case CSSValueID::CSSValueMathematical:
    case CSSValueID::CSSValueMiddle:
    case CSSValueID::CSSValueTextAfterEdge:
    case CSSValueID::CSSValueTextBeforeEdge:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForAnchorName(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForAnchorScope(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAll:
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForAppearance(CSSValueID keyword, CSS::PropertyParserState& state)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueButton:
    case CSSValueID::CSSValueCheckbox:
    case CSSValueID::CSSValueListbox:
    case CSSValueID::CSSValueMenulist:
    case CSSValueID::CSSValueMenulistButton:
    case CSSValueID::CSSValueMeter:
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValueProgressBar:
    case CSSValueID::CSSValuePushButton:
    case CSSValueID::CSSValueRadio:
    case CSSValueID::CSSValueSearchfield:
    case CSSValueID::CSSValueSliderHorizontal:
    case CSSValueID::CSSValueSliderVertical:
    case CSSValueID::CSSValueSquareButton:
    case CSSValueID::CSSValueTextarea:
    case CSSValueID::CSSValueTextfield:
        return true;
    case CSSValueID::CSSValueAttachment:
    case CSSValueID::CSSValueBorderlessAttachment:
        return DeprecatedGlobalSettings::attachmentElementEnabled();
    case CSSValueID::CSSValueBase:
        return state.context.cssAppearanceBaseEnabled;
    case CSSValueID::CSSValueDefaultButton:
        return state.context.useSystemAppearance;
    default:
        return false;
    }
}

static bool isKeywordValidForBackfaceVisibility(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueHidden:
    case CSSValueID::CSSValueVisible:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBaselineShift(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueBaseline:
    case CSSValueID::CSSValueSub:
    case CSSValueID::CSSValueSuper:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBlockEllipsis(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBlockStepAlign(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueCenter:
    case CSSValueID::CSSValueEnd:
    case CSSValueID::CSSValueStart:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBlockStepInsert(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueContentBox:
    case CSSValueID::CSSValueMarginBox:
    case CSSValueID::CSSValuePaddingBox:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBlockStepRound(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueDown:
    case CSSValueID::CSSValueNearest:
    case CSSValueID::CSSValueUp:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBlockStepSize(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBorderCollapse(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueCollapse:
    case CSSValueID::CSSValueSeparate:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBorderImageSource(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBoxSizing(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueBorderBox:
    case CSSValueID::CSSValueContentBox:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBreakAfter(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueAvoid:
    case CSSValueID::CSSValueAvoidColumn:
    case CSSValueID::CSSValueAvoidPage:
    case CSSValueID::CSSValueColumn:
    case CSSValueID::CSSValueLeft:
    case CSSValueID::CSSValuePage:
    case CSSValueID::CSSValueRecto:
    case CSSValueID::CSSValueRight:
    case CSSValueID::CSSValueVerso:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBreakBefore(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueAvoid:
    case CSSValueID::CSSValueAvoidColumn:
    case CSSValueID::CSSValueAvoidPage:
    case CSSValueID::CSSValueColumn:
    case CSSValueID::CSSValueLeft:
    case CSSValueID::CSSValuePage:
    case CSSValueID::CSSValueRecto:
    case CSSValueID::CSSValueRight:
    case CSSValueID::CSSValueVerso:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBreakInside(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueAvoid:
    case CSSValueID::CSSValueAvoidColumn:
    case CSSValueID::CSSValueAvoidPage:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBufferedRendering(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueDynamic:
    case CSSValueID::CSSValueStatic:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForCaptionSide(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueBottom:
    case CSSValueID::CSSValueTop:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForCaretColor(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForClear(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueBoth:
    case CSSValueID::CSSValueInlineEnd:
    case CSSValueID::CSSValueInlineStart:
    case CSSValueID::CSSValueLeft:
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValueRight:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForClip(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForClipRule(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueEvenodd:
    case CSSValueID::CSSValueNonzero:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForColorInterpolation(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueLinearRGB:
    case CSSValueID::CSSValueSRGB:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForColorInterpolationFilters(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueLinearRGB:
    case CSSValueID::CSSValueSRGB:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForColumnCount(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForColumnFill(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueBalance:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForColumnGap(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNormal:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForColumnRuleStyle(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueDashed:
    case CSSValueID::CSSValueDotted:
    case CSSValueID::CSSValueDouble:
    case CSSValueID::CSSValueGroove:
    case CSSValueID::CSSValueHidden:
    case CSSValueID::CSSValueInset:
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValueOutset:
    case CSSValueID::CSSValueRidge:
    case CSSValueID::CSSValueSolid:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForColumnRuleWidth(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueMedium:
    case CSSValueID::CSSValueThick:
    case CSSValueID::CSSValueThin:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForColumnSpan(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAll:
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForColumnWidth(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForContain(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueContent:
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValueStrict:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForContainerName(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForContainerType(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueInlineSize:
    case CSSValueID::CSSValueNormal:
    case CSSValueID::CSSValueSize:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForContentVisibility(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueHidden:
    case CSSValueID::CSSValueVisible:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForContinue(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueDiscard:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForD(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForDominantBaseline(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAlphabetic:
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueCentral:
    case CSSValueID::CSSValueHanging:
    case CSSValueID::CSSValueIdeographic:
    case CSSValueID::CSSValueMathematical:
    case CSSValueID::CSSValueMiddle:
    case CSSValueID::CSSValueNoChange:
    case CSSValueID::CSSValueResetSize:
    case CSSValueID::CSSValueTextAfterEdge:
    case CSSValueID::CSSValueTextBeforeEdge:
    case CSSValueID::CSSValueUseScript:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForEmptyCells(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueHide:
    case CSSValueID::CSSValueShow:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForFieldSizing(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueContent:
    case CSSValueID::CSSValueFixed:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForFill(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForFillRule(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueEvenodd:
    case CSSValueID::CSSValueNonzero:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForFlexBasis(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueContent:
    case CSSValueID::CSSValueFitContent:
    case CSSValueID::CSSValueIntrinsic:
    case CSSValueID::CSSValueMaxContent:
    case CSSValueID::CSSValueMinContent:
    case CSSValueID::CSSValueMinIntrinsic:
    case CSSValueID::CSSValueWebkitFillAvailable:
    case CSSValueID::CSSValueWebkitFitContent:
    case CSSValueID::CSSValueWebkitMaxContent:
    case CSSValueID::CSSValueWebkitMinContent:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForFlexDirection(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueColumn:
    case CSSValueID::CSSValueColumnReverse:
    case CSSValueID::CSSValueRow:
    case CSSValueID::CSSValueRowReverse:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForFlexWrap(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNowrap:
    case CSSValueID::CSSValueWrap:
    case CSSValueID::CSSValueWrapReverse:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForFloat(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueInlineEnd:
    case CSSValueID::CSSValueInlineStart:
    case CSSValueID::CSSValueLeft:
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValueRight:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForGlyphOrientationVertical(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForHangingPunctuation(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForHyphenateCharacter(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForHyphens(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueManual:
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForImageOrientation(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueFromImage:
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForImageRendering(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueCrispEdges:
    case CSSValueID::CSSValueOptimizeQuality:
    case CSSValueID::CSSValueOptimizeSpeed:
    case CSSValueID::CSSValuePixelated:
    case CSSValueID::CSSValueWebkitCrispEdges:
    case CSSValueID::CSSValueWebkitOptimizeContrast:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForInputSecurity(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForIsolation(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueIsolate:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForLineBreak(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAfterWhiteSpace:
    case CSSValueID::CSSValueAnywhere:
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueLoose:
    case CSSValueID::CSSValueNormal:
    case CSSValueID::CSSValueStrict:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForLineHeight(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNormal:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForListStyleImage(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForListStylePosition(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueInside:
    case CSSValueID::CSSValueOutside:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForListStyleType(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForMarkerEnd(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForMarkerMid(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForMarkerStart(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForMaskBorderSource(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForMaskType(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAlpha:
    case CSSValueID::CSSValueLuminance:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForMathStyle(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueCompact:
    case CSSValueID::CSSValueNormal:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForMaxLines(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForMixBlendMode(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueColor:
    case CSSValueID::CSSValueColorBurn:
    case CSSValueID::CSSValueColorDodge:
    case CSSValueID::CSSValueDarken:
    case CSSValueID::CSSValueDifference:
    case CSSValueID::CSSValueExclusion:
    case CSSValueID::CSSValueHardLight:
    case CSSValueID::CSSValueHue:
    case CSSValueID::CSSValueLighten:
    case CSSValueID::CSSValueLuminosity:
    case CSSValueID::CSSValueMultiply:
    case CSSValueID::CSSValueNormal:
    case CSSValueID::CSSValueOverlay:
    case CSSValueID::CSSValuePlusDarker:
    case CSSValueID::CSSValuePlusLighter:
    case CSSValueID::CSSValueSaturation:
    case CSSValueID::CSSValueScreen:
    case CSSValueID::CSSValueSoftLight:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForObjectFit(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueContain:
    case CSSValueID::CSSValueCover:
    case CSSValueID::CSSValueFill:
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValueScaleDown:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForOffsetAnchor(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForOffsetPosition(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueNormal:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForOutlineColor(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueWebkitFocusRingColor:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForOutlineStyle(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueDashed:
    case CSSValueID::CSSValueDotted:
    case CSSValueID::CSSValueDouble:
    case CSSValueID::CSSValueGroove:
    case CSSValueID::CSSValueInset:
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValueOutset:
    case CSSValueID::CSSValueRidge:
    case CSSValueID::CSSValueSolid:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForOutlineWidth(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueMedium:
    case CSSValueID::CSSValueThick:
    case CSSValueID::CSSValueThin:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForOverflowAnchor(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForOverflowWrap(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAnywhere:
    case CSSValueID::CSSValueBreakWord:
    case CSSValueID::CSSValueNormal:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForPage(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForPerspective(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForPointerEvents(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAll:
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueBoundingBox:
    case CSSValueID::CSSValueFill:
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValuePainted:
    case CSSValueID::CSSValueStroke:
    case CSSValueID::CSSValueVisible:
    case CSSValueID::CSSValueVisibleFill:
    case CSSValueID::CSSValueVisiblePainted:
    case CSSValueID::CSSValueVisibleStroke:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForPosition(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAbsolute:
    case CSSValueID::CSSValueFixed:
    case CSSValueID::CSSValueRelative:
    case CSSValueID::CSSValueStatic:
    case CSSValueID::CSSValueSticky:
    case CSSValueID::CSSValueWebkitSticky:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForPositionAnchor(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForPositionTryOrder(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueMostBlockSize:
    case CSSValueID::CSSValueMostHeight:
    case CSSValueID::CSSValueMostInlineSize:
    case CSSValueID::CSSValueMostWidth:
    case CSSValueID::CSSValueNormal:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForPositionVisibility(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAlways:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForPrintColorAdjust(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueEconomy:
    case CSSValueID::CSSValueExact:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForResize(CSSValueID keyword, CSS::PropertyParserState& state)
{
    switch (keyword) {
    case CSSValueID::CSSValueBlock:
    case CSSValueID::CSSValueBoth:
    case CSSValueID::CSSValueHorizontal:
    case CSSValueID::CSSValueInline:
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValueVertical:
        return true;
    case CSSValueID::CSSValueInternalTextareaAuto:
        return isUASheetBehavior(state.context.mode);
    default:
        return false;
    }
}

static bool isKeywordValidForRowGap(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNormal:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForRubyAlign(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueCenter:
    case CSSValueID::CSSValueSpaceAround:
    case CSSValueID::CSSValueSpaceBetween:
    case CSSValueID::CSSValueStart:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForRubyOverhang(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForRx(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForRy(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForScrollBehavior(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueSmooth:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForScrollSnapStop(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAlways:
    case CSSValueID::CSSValueNormal:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForScrollbarGutter(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForScrollbarWidth(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValueThin:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForShapeRendering(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueCrispedges:
    case CSSValueID::CSSValueGeometricPrecision:
    case CSSValueID::CSSValueOptimizeSpeed:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForSpeakAs(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForStroke(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForStrokeLinecap(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueButt:
    case CSSValueID::CSSValueRound:
    case CSSValueID::CSSValueSquare:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForStrokeLinejoin(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueBevel:
    case CSSValueID::CSSValueMiter:
    case CSSValueID::CSSValueRound:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForTableLayout(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueFixed:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForTextAlign(CSSValueID keyword, CSS::PropertyParserState& state)
{
    switch (keyword) {
    case CSSValueID::CSSValueCenter:
    case CSSValueID::CSSValueEnd:
    case CSSValueID::CSSValueJustify:
    case CSSValueID::CSSValueLeft:
    case CSSValueID::CSSValueMatchParent:
    case CSSValueID::CSSValueRight:
    case CSSValueID::CSSValueStart:
    case CSSValueID::CSSValueWebkitAuto:
    case CSSValueID::CSSValueWebkitCenter:
    case CSSValueID::CSSValueWebkitLeft:
    case CSSValueID::CSSValueWebkitMatchParent:
    case CSSValueID::CSSValueWebkitRight:
        return true;
    case CSSValueID::CSSValueInternalThCenter:
        return isUASheetBehavior(state.context.mode);
    default:
        return false;
    }
}

static bool isKeywordValidForTextAlignLast(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueCenter:
    case CSSValueID::CSSValueEnd:
    case CSSValueID::CSSValueJustify:
    case CSSValueID::CSSValueLeft:
    case CSSValueID::CSSValueMatchParent:
    case CSSValueID::CSSValueRight:
    case CSSValueID::CSSValueStart:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForTextAnchor(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueEnd:
    case CSSValueID::CSSValueMiddle:
    case CSSValueID::CSSValueStart:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForTextBoxTrim(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValueTrimBoth:
    case CSSValueID::CSSValueTrimEnd:
    case CSSValueID::CSSValueTrimStart:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForTextCombineUpright(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAll:
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForTextDecorationLine(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForTextDecorationSkipInk(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAll:
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForTextDecorationStyle(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueDashed:
    case CSSValueID::CSSValueDotted:
    case CSSValueID::CSSValueDouble:
    case CSSValueID::CSSValueSolid:
    case CSSValueID::CSSValueWavy:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForTextDecorationThickness(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueFromFont:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForTextEmphasisStyle(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForTextGroupAlign(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueCenter:
    case CSSValueID::CSSValueEnd:
    case CSSValueID::CSSValueLeft:
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValueRight:
    case CSSValueID::CSSValueStart:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForTextJustify(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueDistribute:
    case CSSValueID::CSSValueInterCharacter:
    case CSSValueID::CSSValueInterWord:
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForTextOverflow(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueClip:
    case CSSValueID::CSSValueEllipsis:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForTextTransform(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForTextUnderlineOffset(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForTextUnderlinePosition(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForTextWrapMode(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNowrap:
    case CSSValueID::CSSValueWrap:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForTextWrapStyle(CSSValueID keyword, CSS::PropertyParserState& state)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueBalance:
    case CSSValueID::CSSValueStable:
        return true;
    case CSSValueID::CSSValuePretty:
        return state.context.cssTextWrapPrettyEnabled;
    default:
        return false;
    }
}

static bool isKeywordValidForTimelineScope(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAll:
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForTouchAction(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueManipulation:
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForTransform(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForTransformBox(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueBorderBox:
    case CSSValueID::CSSValueContentBox:
    case CSSValueID::CSSValueFillBox:
    case CSSValueID::CSSValueStrokeBox:
    case CSSValueID::CSSValueViewBox:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForTransformStyle(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueFlat:
    case CSSValueID::CSSValuePreserve3d:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForTransitionProperty(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForUnicodeBidi(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueBidiOverride:
    case CSSValueID::CSSValueEmbed:
    case CSSValueID::CSSValueIsolate:
    case CSSValueID::CSSValueIsolateOverride:
    case CSSValueID::CSSValueNormal:
    case CSSValueID::CSSValuePlaintext:
    case CSSValueID::CSSValueWebkitIsolate:
    case CSSValueID::CSSValueWebkitIsolateOverride:
    case CSSValueID::CSSValueWebkitPlaintext:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForVectorEffect(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNonScalingStroke:
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForVerticalAlign(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueBaseline:
    case CSSValueID::CSSValueBottom:
    case CSSValueID::CSSValueMiddle:
    case CSSValueID::CSSValueSub:
    case CSSValueID::CSSValueSuper:
    case CSSValueID::CSSValueTextBottom:
    case CSSValueID::CSSValueTextTop:
    case CSSValueID::CSSValueTop:
    case CSSValueID::CSSValueWebkitBaselineMiddle:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForViewTransitionClass(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForViewTransitionName(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueMatchElement:
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForVisibility(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueCollapse:
    case CSSValueID::CSSValueHidden:
    case CSSValueID::CSSValueVisible:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWhiteSpaceCollapse(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueBreakSpaces:
    case CSSValueID::CSSValueCollapse:
    case CSSValueID::CSSValuePreserve:
    case CSSValueID::CSSValuePreserveBreaks:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWordBreak(CSSValueID keyword, CSS::PropertyParserState& state)
{
    switch (keyword) {
    case CSSValueID::CSSValueBreakAll:
    case CSSValueID::CSSValueBreakWord:
    case CSSValueID::CSSValueKeepAll:
    case CSSValueID::CSSValueNormal:
        return true;
    case CSSValueID::CSSValueAutoPhrase:
        return state.context.cssWordBreakAutoPhraseEnabled;
    default:
        return false;
    }
}

static bool isKeywordValidForZIndex(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitBoxAlign(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueBaseline:
    case CSSValueID::CSSValueCenter:
    case CSSValueID::CSSValueEnd:
    case CSSValueID::CSSValueStart:
    case CSSValueID::CSSValueStretch:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitBoxDecorationBreak(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueClone:
    case CSSValueID::CSSValueSlice:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitBoxDirection(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNormal:
    case CSSValueID::CSSValueReverse:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitBoxLines(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueMultiple:
    case CSSValueID::CSSValueSingle:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitBoxOrient(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueBlockAxis:
    case CSSValueID::CSSValueHorizontal:
    case CSSValueID::CSSValueInlineAxis:
    case CSSValueID::CSSValueVertical:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitBoxPack(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueCenter:
    case CSSValueID::CSSValueEnd:
    case CSSValueID::CSSValueJustify:
    case CSSValueID::CSSValueStart:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitColumnAxis(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueHorizontal:
    case CSSValueID::CSSValueVertical:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitColumnProgression(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNormal:
    case CSSValueID::CSSValueReverse:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitCursorVisibility(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueAutoHide:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitHyphenateLimitAfter(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitHyphenateLimitBefore(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitHyphenateLimitLines(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNoLimit:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitInitialLetter(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNormal:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitLineAlign(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueEdges:
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitLineBoxContain(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitLineClamp(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitLineGrid(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitLineSnap(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueBaseline:
    case CSSValueID::CSSValueContain:
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitMarqueeDirection(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAhead:
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueBackwards:
    case CSSValueID::CSSValueDown:
    case CSSValueID::CSSValueForwards:
    case CSSValueID::CSSValueLeft:
    case CSSValueID::CSSValueReverse:
    case CSSValueID::CSSValueRight:
    case CSSValueID::CSSValueUp:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitMarqueeStyle(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAlternate:
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValueScroll:
    case CSSValueID::CSSValueSlide:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitNbspMode(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNormal:
    case CSSValueID::CSSValueSpace:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitRtlOrdering(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueLogical:
    case CSSValueID::CSSValueVisual:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitRubyPosition(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAfter:
    case CSSValueID::CSSValueBefore:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitTextCombine(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueHorizontal:
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitTextDecorationsInEffect(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitTextSecurity(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueCircle:
    case CSSValueID::CSSValueDisc:
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValueSquare:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitTextStrokeWidth(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueMedium:
    case CSSValueID::CSSValueThick:
    case CSSValueID::CSSValueThin:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitUserDrag(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueElement:
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitUserModify(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueReadOnly:
    case CSSValueID::CSSValueReadWrite:
    case CSSValueID::CSSValueReadWritePlaintextOnly:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWebkitUserSelect(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAll:
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValueText:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWordSpacing(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNormal:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBorderBottomStyle(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueDashed:
    case CSSValueID::CSSValueDotted:
    case CSSValueID::CSSValueDouble:
    case CSSValueID::CSSValueGroove:
    case CSSValueID::CSSValueHidden:
    case CSSValueID::CSSValueInset:
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValueOutset:
    case CSSValueID::CSSValueRidge:
    case CSSValueID::CSSValueSolid:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBorderBottomWidth(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueMedium:
    case CSSValueID::CSSValueThick:
    case CSSValueID::CSSValueThin:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBorderLeftStyle(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueDashed:
    case CSSValueID::CSSValueDotted:
    case CSSValueID::CSSValueDouble:
    case CSSValueID::CSSValueGroove:
    case CSSValueID::CSSValueHidden:
    case CSSValueID::CSSValueInset:
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValueOutset:
    case CSSValueID::CSSValueRidge:
    case CSSValueID::CSSValueSolid:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBorderLeftWidth(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueMedium:
    case CSSValueID::CSSValueThick:
    case CSSValueID::CSSValueThin:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBorderRightStyle(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueDashed:
    case CSSValueID::CSSValueDotted:
    case CSSValueID::CSSValueDouble:
    case CSSValueID::CSSValueGroove:
    case CSSValueID::CSSValueHidden:
    case CSSValueID::CSSValueInset:
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValueOutset:
    case CSSValueID::CSSValueRidge:
    case CSSValueID::CSSValueSolid:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBorderRightWidth(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueMedium:
    case CSSValueID::CSSValueThick:
    case CSSValueID::CSSValueThin:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBorderTopStyle(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueDashed:
    case CSSValueID::CSSValueDotted:
    case CSSValueID::CSSValueDouble:
    case CSSValueID::CSSValueGroove:
    case CSSValueID::CSSValueHidden:
    case CSSValueID::CSSValueInset:
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValueOutset:
    case CSSValueID::CSSValueRidge:
    case CSSValueID::CSSValueSolid:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBorderTopWidth(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueMedium:
    case CSSValueID::CSSValueThick:
    case CSSValueID::CSSValueThin:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBottom(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForCornerBottomLeftShape(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueBevel:
    case CSSValueID::CSSValueNotch:
    case CSSValueID::CSSValueRound:
    case CSSValueID::CSSValueScoop:
    case CSSValueID::CSSValueSquircle:
    case CSSValueID::CSSValueStraight:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForCornerBottomRightShape(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueBevel:
    case CSSValueID::CSSValueNotch:
    case CSSValueID::CSSValueRound:
    case CSSValueID::CSSValueScoop:
    case CSSValueID::CSSValueSquircle:
    case CSSValueID::CSSValueStraight:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForCornerTopLeftShape(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueBevel:
    case CSSValueID::CSSValueNotch:
    case CSSValueID::CSSValueRound:
    case CSSValueID::CSSValueScoop:
    case CSSValueID::CSSValueSquircle:
    case CSSValueID::CSSValueStraight:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForCornerTopRightShape(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueBevel:
    case CSSValueID::CSSValueNotch:
    case CSSValueID::CSSValueRound:
    case CSSValueID::CSSValueScoop:
    case CSSValueID::CSSValueSquircle:
    case CSSValueID::CSSValueStraight:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForHeight(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueFitContent:
    case CSSValueID::CSSValueIntrinsic:
    case CSSValueID::CSSValueMaxContent:
    case CSSValueID::CSSValueMinContent:
    case CSSValueID::CSSValueMinIntrinsic:
    case CSSValueID::CSSValueWebkitFillAvailable:
    case CSSValueID::CSSValueWebkitFitContent:
    case CSSValueID::CSSValueWebkitMaxContent:
    case CSSValueID::CSSValueWebkitMinContent:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForLeft(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForMarginBottom(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForMarginLeft(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForMarginRight(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForMarginTop(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForMaxHeight(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueFitContent:
    case CSSValueID::CSSValueIntrinsic:
    case CSSValueID::CSSValueMaxContent:
    case CSSValueID::CSSValueMinContent:
    case CSSValueID::CSSValueMinIntrinsic:
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValueWebkitFillAvailable:
    case CSSValueID::CSSValueWebkitFitContent:
    case CSSValueID::CSSValueWebkitMaxContent:
    case CSSValueID::CSSValueWebkitMinContent:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForMaxWidth(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueFitContent:
    case CSSValueID::CSSValueIntrinsic:
    case CSSValueID::CSSValueMaxContent:
    case CSSValueID::CSSValueMinContent:
    case CSSValueID::CSSValueMinIntrinsic:
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValueWebkitFillAvailable:
    case CSSValueID::CSSValueWebkitFitContent:
    case CSSValueID::CSSValueWebkitMaxContent:
    case CSSValueID::CSSValueWebkitMinContent:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForMinHeight(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueFitContent:
    case CSSValueID::CSSValueIntrinsic:
    case CSSValueID::CSSValueMaxContent:
    case CSSValueID::CSSValueMinContent:
    case CSSValueID::CSSValueMinIntrinsic:
    case CSSValueID::CSSValueWebkitFillAvailable:
    case CSSValueID::CSSValueWebkitFitContent:
    case CSSValueID::CSSValueWebkitMaxContent:
    case CSSValueID::CSSValueWebkitMinContent:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForMinWidth(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueFitContent:
    case CSSValueID::CSSValueIntrinsic:
    case CSSValueID::CSSValueMaxContent:
    case CSSValueID::CSSValueMinContent:
    case CSSValueID::CSSValueMinIntrinsic:
    case CSSValueID::CSSValueWebkitFillAvailable:
    case CSSValueID::CSSValueWebkitFitContent:
    case CSSValueID::CSSValueWebkitMaxContent:
    case CSSValueID::CSSValueWebkitMinContent:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForOverflowX(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueClip:
    case CSSValueID::CSSValueHidden:
    case CSSValueID::CSSValueOverlay:
    case CSSValueID::CSSValueScroll:
    case CSSValueID::CSSValueVisible:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForOverflowY(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueClip:
    case CSSValueID::CSSValueHidden:
    case CSSValueID::CSSValueOverlay:
    case CSSValueID::CSSValueScroll:
    case CSSValueID::CSSValueVisible:
    case CSSValueID::CSSValueWebkitPagedX:
    case CSSValueID::CSSValueWebkitPagedY:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForOverscrollBehaviorX(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueContain:
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForOverscrollBehaviorY(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueContain:
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForRight(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForScrollPaddingBottom(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForScrollPaddingLeft(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForScrollPaddingRight(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForScrollPaddingTop(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForTop(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForWidth(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueFitContent:
    case CSSValueID::CSSValueIntrinsic:
    case CSSValueID::CSSValueMaxContent:
    case CSSValueID::CSSValueMinContent:
    case CSSValueID::CSSValueMinIntrinsic:
    case CSSValueID::CSSValueWebkitFillAvailable:
    case CSSValueID::CSSValueWebkitFitContent:
    case CSSValueID::CSSValueWebkitMaxContent:
    case CSSValueID::CSSValueWebkitMinContent:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBlockSize(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueFitContent:
    case CSSValueID::CSSValueIntrinsic:
    case CSSValueID::CSSValueMaxContent:
    case CSSValueID::CSSValueMinContent:
    case CSSValueID::CSSValueMinIntrinsic:
    case CSSValueID::CSSValueWebkitFillAvailable:
    case CSSValueID::CSSValueWebkitFitContent:
    case CSSValueID::CSSValueWebkitMaxContent:
    case CSSValueID::CSSValueWebkitMinContent:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBorderBlockEndStyle(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueDashed:
    case CSSValueID::CSSValueDotted:
    case CSSValueID::CSSValueDouble:
    case CSSValueID::CSSValueGroove:
    case CSSValueID::CSSValueHidden:
    case CSSValueID::CSSValueInset:
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValueOutset:
    case CSSValueID::CSSValueRidge:
    case CSSValueID::CSSValueSolid:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBorderBlockEndWidth(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueMedium:
    case CSSValueID::CSSValueThick:
    case CSSValueID::CSSValueThin:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBorderBlockStartStyle(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueDashed:
    case CSSValueID::CSSValueDotted:
    case CSSValueID::CSSValueDouble:
    case CSSValueID::CSSValueGroove:
    case CSSValueID::CSSValueHidden:
    case CSSValueID::CSSValueInset:
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValueOutset:
    case CSSValueID::CSSValueRidge:
    case CSSValueID::CSSValueSolid:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBorderBlockStartWidth(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueMedium:
    case CSSValueID::CSSValueThick:
    case CSSValueID::CSSValueThin:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBorderInlineEndStyle(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueDashed:
    case CSSValueID::CSSValueDotted:
    case CSSValueID::CSSValueDouble:
    case CSSValueID::CSSValueGroove:
    case CSSValueID::CSSValueHidden:
    case CSSValueID::CSSValueInset:
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValueOutset:
    case CSSValueID::CSSValueRidge:
    case CSSValueID::CSSValueSolid:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBorderInlineEndWidth(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueMedium:
    case CSSValueID::CSSValueThick:
    case CSSValueID::CSSValueThin:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBorderInlineStartStyle(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueDashed:
    case CSSValueID::CSSValueDotted:
    case CSSValueID::CSSValueDouble:
    case CSSValueID::CSSValueGroove:
    case CSSValueID::CSSValueHidden:
    case CSSValueID::CSSValueInset:
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValueOutset:
    case CSSValueID::CSSValueRidge:
    case CSSValueID::CSSValueSolid:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForBorderInlineStartWidth(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueMedium:
    case CSSValueID::CSSValueThick:
    case CSSValueID::CSSValueThin:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForCornerEndEndShape(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueBevel:
    case CSSValueID::CSSValueNotch:
    case CSSValueID::CSSValueRound:
    case CSSValueID::CSSValueScoop:
    case CSSValueID::CSSValueSquircle:
    case CSSValueID::CSSValueStraight:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForCornerEndStartShape(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueBevel:
    case CSSValueID::CSSValueNotch:
    case CSSValueID::CSSValueRound:
    case CSSValueID::CSSValueScoop:
    case CSSValueID::CSSValueSquircle:
    case CSSValueID::CSSValueStraight:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForCornerStartEndShape(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueBevel:
    case CSSValueID::CSSValueNotch:
    case CSSValueID::CSSValueRound:
    case CSSValueID::CSSValueScoop:
    case CSSValueID::CSSValueSquircle:
    case CSSValueID::CSSValueStraight:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForCornerStartStartShape(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueBevel:
    case CSSValueID::CSSValueNotch:
    case CSSValueID::CSSValueRound:
    case CSSValueID::CSSValueScoop:
    case CSSValueID::CSSValueSquircle:
    case CSSValueID::CSSValueStraight:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForInlineSize(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueFitContent:
    case CSSValueID::CSSValueIntrinsic:
    case CSSValueID::CSSValueMaxContent:
    case CSSValueID::CSSValueMinContent:
    case CSSValueID::CSSValueMinIntrinsic:
    case CSSValueID::CSSValueWebkitFillAvailable:
    case CSSValueID::CSSValueWebkitFitContent:
    case CSSValueID::CSSValueWebkitMaxContent:
    case CSSValueID::CSSValueWebkitMinContent:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForInsetBlockEnd(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForInsetBlockStart(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForInsetInlineEnd(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForInsetInlineStart(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForMarginBlockEnd(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForMarginBlockStart(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForMarginInlineEnd(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForMarginInlineStart(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForMaxBlockSize(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueFitContent:
    case CSSValueID::CSSValueIntrinsic:
    case CSSValueID::CSSValueMaxContent:
    case CSSValueID::CSSValueMinContent:
    case CSSValueID::CSSValueMinIntrinsic:
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValueWebkitFillAvailable:
    case CSSValueID::CSSValueWebkitFitContent:
    case CSSValueID::CSSValueWebkitMaxContent:
    case CSSValueID::CSSValueWebkitMinContent:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForMaxInlineSize(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueFitContent:
    case CSSValueID::CSSValueIntrinsic:
    case CSSValueID::CSSValueMaxContent:
    case CSSValueID::CSSValueMinContent:
    case CSSValueID::CSSValueMinIntrinsic:
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValueWebkitFillAvailable:
    case CSSValueID::CSSValueWebkitFitContent:
    case CSSValueID::CSSValueWebkitMaxContent:
    case CSSValueID::CSSValueWebkitMinContent:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForMinBlockSize(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueFitContent:
    case CSSValueID::CSSValueIntrinsic:
    case CSSValueID::CSSValueMaxContent:
    case CSSValueID::CSSValueMinContent:
    case CSSValueID::CSSValueMinIntrinsic:
    case CSSValueID::CSSValueWebkitFillAvailable:
    case CSSValueID::CSSValueWebkitFitContent:
    case CSSValueID::CSSValueWebkitMaxContent:
    case CSSValueID::CSSValueWebkitMinContent:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForMinInlineSize(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueFitContent:
    case CSSValueID::CSSValueIntrinsic:
    case CSSValueID::CSSValueMaxContent:
    case CSSValueID::CSSValueMinContent:
    case CSSValueID::CSSValueMinIntrinsic:
    case CSSValueID::CSSValueWebkitFillAvailable:
    case CSSValueID::CSSValueWebkitFitContent:
    case CSSValueID::CSSValueWebkitMaxContent:
    case CSSValueID::CSSValueWebkitMinContent:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForOverflowBlock(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueClip:
    case CSSValueID::CSSValueHidden:
    case CSSValueID::CSSValueScroll:
    case CSSValueID::CSSValueVisible:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForOverflowInline(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueClip:
    case CSSValueID::CSSValueHidden:
    case CSSValueID::CSSValueScroll:
    case CSSValueID::CSSValueVisible:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForOverscrollBehaviorBlock(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueContain:
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForOverscrollBehaviorInline(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueContain:
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForScrollPaddingBlockEnd(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForScrollPaddingBlockStart(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForScrollPaddingInlineEnd(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForScrollPaddingInlineStart(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForCounterStyleSpeakAs(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueBullets:
    case CSSValueID::CSSValueNumbers:
    case CSSValueID::CSSValueSpellOut:
    case CSSValueID::CSSValueWords:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForFontFaceFontDisplay(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueBlock:
    case CSSValueID::CSSValueFallback:
    case CSSValueID::CSSValueOptional:
    case CSSValueID::CSSValueSwap:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForFontFaceFontFeatureSettings(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueNormal:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForFontFaceFontWeight(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueBold:
    case CSSValueID::CSSValueNormal:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForFontFaceFontWidth(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueCondensed:
    case CSSValueID::CSSValueExpanded:
    case CSSValueID::CSSValueExtraCondensed:
    case CSSValueID::CSSValueExtraExpanded:
    case CSSValueID::CSSValueNormal:
    case CSSValueID::CSSValueSemiCondensed:
    case CSSValueID::CSSValueSemiExpanded:
    case CSSValueID::CSSValueUltraCondensed:
    case CSSValueID::CSSValueUltraExpanded:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForFontPaletteValuesBasePalette(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueDark:
    case CSSValueID::CSSValueLight:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForPageSize(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForPropertyInherits(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueFalse:
    case CSSValueID::CSSValueTrue:
        return true;
    default:
        return false;
    }
}

static bool isKeywordValidForViewTransitionNavigation(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueNone:
        return true;
    default:
        return false;
    }
}

static RefPtr<CSSValue> consumeFontPalette(CSSParserTokenRange& range)
{
    // dark | light | normal
    if (auto result = consumeIdent(range, isKeywordValidForFontPalette))
        return result;
    // <dashed-ident>
    return consumeDashedIdent(range);
}

static RefPtr<CSSValue> consumeFontVariantLigatures(CSSParserTokenRange& range)
{
    // none | normal
    if (auto result = consumeIdent(range, isKeywordValidForFontVariantLigatures))
        return result;
    // [ [ common-ligatures | no-common-ligatures ] || [ discretionary-ligatures | no-discretionary-ligatures ] || [ historical-ligatures | no-historical-ligatures ] || [ contextual | no-contextual ] ]@(no-single-item-opt)
    auto consumeMatchOneOrMoreAnyOrder = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        RefPtr<CSSValue> value0; // [ common-ligatures | no-common-ligatures ]
        auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // common-ligatures | no-common-ligatures
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueCommonLigatures:
                case CSSValueID::CSSValueNoCommonLigatures:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value0)
                return false;
            value0 = consumeTerm0(range);
            return !!value0;
        };
        RefPtr<CSSValue> value1; // [ discretionary-ligatures | no-discretionary-ligatures ]
        auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // discretionary-ligatures | no-discretionary-ligatures
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueDiscretionaryLigatures:
                case CSSValueID::CSSValueNoDiscretionaryLigatures:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value1)
                return false;
            value1 = consumeTerm1(range);
            return !!value1;
        };
        RefPtr<CSSValue> value2; // [ historical-ligatures | no-historical-ligatures ]
        auto tryConsumeTerm2 = [&value2](CSSParserTokenRange& range) -> bool {
            auto consumeTerm2 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // historical-ligatures | no-historical-ligatures
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueHistoricalLigatures:
                case CSSValueID::CSSValueNoHistoricalLigatures:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value2)
                return false;
            value2 = consumeTerm2(range);
            return !!value2;
        };
        RefPtr<CSSValue> value3; // [ contextual | no-contextual ]
        auto tryConsumeTerm3 = [&value3](CSSParserTokenRange& range) -> bool {
            auto consumeTerm3 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // contextual | no-contextual
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueContextual:
                case CSSValueID::CSSValueNoContextual:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value3)
                return false;
            value3 = consumeTerm3(range);
            return !!value3;
        };
        for (size_t i = 0; i < 4 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range) || tryConsumeTerm1(range) || tryConsumeTerm2(range) || tryConsumeTerm3(range))
                continue;
            break;
        }
        CSSValueListBuilder list;
        if (value0) // [ common-ligatures | no-common-ligatures ]
            list.append(value0.releaseNonNull());
        if (value1) // [ discretionary-ligatures | no-discretionary-ligatures ]
            list.append(value1.releaseNonNull());
        if (value2) // [ historical-ligatures | no-historical-ligatures ]
            list.append(value2.releaseNonNull());
        if (value3) // [ contextual | no-contextual ]
            list.append(value3.releaseNonNull());
        if (list.isEmpty())
            return { };
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchOneOrMoreAnyOrder(range);
}

static RefPtr<CSSValue> consumeFontVariantNumeric(CSSParserTokenRange& range)
{
    // normal
    if (auto result = consumeIdent(range, isKeywordValidForFontVariantNumeric))
        return result;
    // [ [ lining-nums | oldstyle-nums ] || [ proportional-nums | tabular-nums ] || [ diagonal-fractions | stacked-fractions ] || ordinal || slashed-zero ]@(no-single-item-opt)
    auto consumeMatchOneOrMoreAnyOrder = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        RefPtr<CSSValue> value0; // [ lining-nums | oldstyle-nums ]
        auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // lining-nums | oldstyle-nums
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueLiningNums:
                case CSSValueID::CSSValueOldstyleNums:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value0)
                return false;
            value0 = consumeTerm0(range);
            return !!value0;
        };
        RefPtr<CSSValue> value1; // [ proportional-nums | tabular-nums ]
        auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // proportional-nums | tabular-nums
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueProportionalNums:
                case CSSValueID::CSSValueTabularNums:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value1)
                return false;
            value1 = consumeTerm1(range);
            return !!value1;
        };
        RefPtr<CSSValue> value2; // [ diagonal-fractions | stacked-fractions ]
        auto tryConsumeTerm2 = [&value2](CSSParserTokenRange& range) -> bool {
            auto consumeTerm2 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // diagonal-fractions | stacked-fractions
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueDiagonalFractions:
                case CSSValueID::CSSValueStackedFractions:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value2)
                return false;
            value2 = consumeTerm2(range);
            return !!value2;
        };
        RefPtr<CSSValue> value3; // ordinal
        auto tryConsumeTerm3 = [&value3](CSSParserTokenRange& range) -> bool {
            auto consumeTerm3 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // ordinal
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueOrdinal:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value3)
                return false;
            value3 = consumeTerm3(range);
            return !!value3;
        };
        RefPtr<CSSValue> value4; // slashed-zero
        auto tryConsumeTerm4 = [&value4](CSSParserTokenRange& range) -> bool {
            auto consumeTerm4 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // slashed-zero
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueSlashedZero:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value4)
                return false;
            value4 = consumeTerm4(range);
            return !!value4;
        };
        for (size_t i = 0; i < 5 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range) || tryConsumeTerm1(range) || tryConsumeTerm2(range) || tryConsumeTerm3(range) || tryConsumeTerm4(range))
                continue;
            break;
        }
        CSSValueListBuilder list;
        if (value0) // [ lining-nums | oldstyle-nums ]
            list.append(value0.releaseNonNull());
        if (value1) // [ proportional-nums | tabular-nums ]
            list.append(value1.releaseNonNull());
        if (value2) // [ diagonal-fractions | stacked-fractions ]
            list.append(value2.releaseNonNull());
        if (value3) // ordinal
            list.append(value3.releaseNonNull());
        if (value4) // slashed-zero
            list.append(value4.releaseNonNull());
        if (list.isEmpty())
            return { };
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchOneOrMoreAnyOrder(range);
}

static RefPtr<CSSValue> consumeFontVariationSettings(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // normal
    if (auto result = consumeIdent(range, isKeywordValidForFontVariationSettings))
        return result;
    // <variation-tag-value>#@(no-single-item-opt)
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <variation-tag-value>
            return consumeVariationTagValue(range, state);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::None, CSSValueList>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeFontWidth(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // condensed | expanded | extra-condensed | extra-expanded | normal | semi-condensed | semi-expanded | ultra-condensed | ultra-expanded
    if (auto result = consumeIdent(range, isKeywordValidForFontWidth))
        return result;
    // <percentage [0,inf]>
    return CSSPrimitiveValueResolver<CSS::Percentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state);
}

static RefPtr<CSSValue> consumeZoom(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // normal
    if (auto result = consumeIdent(range, isKeywordValidForZoom))
        return result;
    // <percentage [0,inf]>
    if (auto result = CSSPrimitiveValueResolver<CSS::Percentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state))
        return result;
    // <number [0,inf]>
    return CSSPrimitiveValueResolver<CSS::Number<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state);
}

static RefPtr<CSSValue> consumeWebkitLocale(CSSParserTokenRange& range)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForWebkitLocale))
        return result;
    // <string>
    return consumeString(range);
}

static RefPtr<CSSValue> consumeLetterSpacing(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // normal
    if (auto result = consumeIdent(range, isKeywordValidForLetterSpacing))
        return result;
    // <length-percentage>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeTextAutospace(CSSParserTokenRange& range)
{
    // auto | no-autospace | normal
    if (auto result = consumeIdent(range, isKeywordValidForTextAutospace))
        return result;
    // [ ideograph-alpha || ideograph-numeric ]@(no-single-item-opt)
    auto consumeMatchOneOrMoreAnyOrder = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        RefPtr<CSSValue> value0; // ideograph-alpha
        auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // ideograph-alpha
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueIdeographAlpha:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value0)
                return false;
            value0 = consumeTerm0(range);
            return !!value0;
        };
        RefPtr<CSSValue> value1; // ideograph-numeric
        auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // ideograph-numeric
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueIdeographNumeric:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value1)
                return false;
            value1 = consumeTerm1(range);
            return !!value1;
        };
        for (size_t i = 0; i < 2 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range) || tryConsumeTerm1(range))
                continue;
            break;
        }
        CSSValueListBuilder list;
        if (value0) // ideograph-alpha
            list.append(value0.releaseNonNull());
        if (value1) // ideograph-numeric
            list.append(value1.releaseNonNull());
        if (list.isEmpty())
            return { };
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchOneOrMoreAnyOrder(range);
}

static RefPtr<CSSValue> consumeAccentColor(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForAccentColor))
        return result;
    // <color>
    return consumeColor(range, state, { .allowedColorTypes = { CSS::ColorType::Absolute, CSS::ColorType::Current, CSS::ColorType::System } });
}

static RefPtr<CSSValue> consumeAnchorName(CSSParserTokenRange& range)
{
    // none
    if (auto result = consumeIdent(range, isKeywordValidForAnchorName))
        return result;
    // <dashed-ident>#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // <dashed-ident>
            return consumeDashedIdent(range);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm);
    };
    return consumeUnboundedRepetition(range);
}

static RefPtr<CSSValue> consumeAnchorScope(CSSParserTokenRange& range)
{
    // all | none
    if (auto result = consumeIdent(range, isKeywordValidForAnchorScope))
        return result;
    // <dashed-ident>#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // <dashed-ident>
            return consumeDashedIdent(range);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm);
    };
    return consumeUnboundedRepetition(range);
}

static RefPtr<CSSValue> consumeAnimationComposition(CSSParserTokenRange& range)
{
    // [ replace | add | accumulate ]#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // replace | add | accumulate
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueReplace:
            case CSSValueID::CSSValueAdd:
            case CSSValueID::CSSValueAccumulate:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                return nullptr;
            }
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm);
    };
    return consumeUnboundedRepetition(range);
}

static RefPtr<CSSValue> consumeAnimationDelay(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <time>#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <time>
            return CSSPrimitiveValueResolver<CSS::Time<>>::consumeAndResolve(range, state);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeAnimationDirection(CSSParserTokenRange& range)
{
    // [ normal | reverse | alternate | alternate-reverse ]#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // normal | reverse | alternate | alternate-reverse
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueNormal:
            case CSSValueID::CSSValueReverse:
            case CSSValueID::CSSValueAlternate:
            case CSSValueID::CSSValueAlternateReverse:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                return nullptr;
            }
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm);
    };
    return consumeUnboundedRepetition(range);
}

static RefPtr<CSSValue> consumeAnimationDuration(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // [ auto | <time [0,inf]> ]#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // auto
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueAuto:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                break;
            }
            // <time [0,inf]>
            return CSSPrimitiveValueResolver<CSS::Time<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeAnimationFillMode(CSSParserTokenRange& range)
{
    // [ none | forwards | backwards | both ]#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // none | forwards | backwards | both
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueNone:
            case CSSValueID::CSSValueForwards:
            case CSSValueID::CSSValueBackwards:
            case CSSValueID::CSSValueBoth:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                return nullptr;
            }
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm);
    };
    return consumeUnboundedRepetition(range);
}

static RefPtr<CSSValue> consumeAnimationIterationCount(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // [ infinite | <number [0,inf]> ]#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // infinite
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueInfinite:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                break;
            }
            // <number [0,inf]>
            return CSSPrimitiveValueResolver<CSS::Number<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeAnimationName(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // [ none | <keyframes-name> ]#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // none
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueNone:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                break;
            }
            // <keyframes-name>
            return consumeKeyframesName(range, state);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeAnimationPlayState(CSSParserTokenRange& range)
{
    // [ running | paused ]#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // running | paused
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueRunning:
            case CSSValueID::CSSValuePaused:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                return nullptr;
            }
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm);
    };
    return consumeUnboundedRepetition(range);
}

static RefPtr<CSSValue> consumeAnimationRangeEnd(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <single-animation-range-end-override-function>#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <single-animation-range-end-override-function>
            return consumeSingleAnimationRangeEnd(range, state);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeAnimationRangeStart(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <single-animation-range-start-override-function>#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <single-animation-range-start-override-function>
            return consumeSingleAnimationRangeStart(range, state);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeAnimationTimeline(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // [ auto | none | <dashed-ident> | <scroll()-override-function> | <view()-override-function> ]#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // auto | none
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueAuto:
            case CSSValueID::CSSValueNone:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                break;
            }
            // <dashed-ident>
            if (auto result = consumeDashedIdent(range))
                return result;
            // <scroll()-override-function>
            if (auto result = consumeAnimationTimelineScroll(range, state))
                return result;
            // <view()-override-function>
            return consumeAnimationTimelineView(range, state);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeAnimationTimingFunction(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <easing-function>#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <easing-function>
            return consumeEasingFunction(range, state);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeAspectRatio(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // [ auto || <ratio> ]
    auto consumeMatchOneOrMoreAnyOrder = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        RefPtr<CSSValue> value0; // auto
        auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // auto
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueAuto:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value0)
                return false;
            value0 = consumeTerm0(range);
            return !!value0;
        };
        RefPtr<CSSValue> value1; // <ratio>
        auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                // <ratio>
                return consumeRatio(range, state);
            };
            if (value1)
                return false;
            value1 = consumeTerm1(range, state);
            return !!value1;
        };
        for (size_t i = 0; i < 2 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range) || tryConsumeTerm1(range, state))
                continue;
            break;
        }
        CSSValueListBuilder list;
        if (value0) // auto
            list.append(value0.releaseNonNull());
        if (value1) // <ratio>
            list.append(value1.releaseNonNull());
        if (list.isEmpty())
            return { };
        if (list.size() == 1)
            return WTFMove(list[0]); // single item optimization
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchOneOrMoreAnyOrder(range, state);
}

static RefPtr<CSSValue> consumeBackgroundAttachment(CSSParserTokenRange& range)
{
    // [ scroll | fixed | local ]#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // scroll | fixed | local
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueScroll:
            case CSSValueID::CSSValueFixed:
            case CSSValueID::CSSValueLocal:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                return nullptr;
            }
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm);
    };
    return consumeUnboundedRepetition(range);
}

static RefPtr<CSSValue> consumeBackgroundBlendMode(CSSParserTokenRange& range)
{
    // [ normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity ]#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueNormal:
            case CSSValueID::CSSValueMultiply:
            case CSSValueID::CSSValueScreen:
            case CSSValueID::CSSValueOverlay:
            case CSSValueID::CSSValueDarken:
            case CSSValueID::CSSValueLighten:
            case CSSValueID::CSSValueColorDodge:
            case CSSValueID::CSSValueColorBurn:
            case CSSValueID::CSSValueHardLight:
            case CSSValueID::CSSValueSoftLight:
            case CSSValueID::CSSValueDifference:
            case CSSValueID::CSSValueExclusion:
            case CSSValueID::CSSValueHue:
            case CSSValueID::CSSValueSaturation:
            case CSSValueID::CSSValueColor:
            case CSSValueID::CSSValueLuminosity:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                return nullptr;
            }
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm);
    };
    return consumeUnboundedRepetition(range);
}

static RefPtr<CSSValue> consumeBackgroundClip(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // [ border-box | padding-box | content-box | border-area@(settings-flag=cssBackgroundClipBorderAreaEnabled) | text | -webkit-text ]#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // border-box | padding-box | content-box | border-area@(settings-flag=cssBackgroundClipBorderAreaEnabled) | text | -webkit-text
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueBorderBox:
            case CSSValueID::CSSValuePaddingBox:
            case CSSValueID::CSSValueContentBox:
            case CSSValueID::CSSValueText:
            case CSSValueID::CSSValueWebkitText:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            case CSSValueID::CSSValueBorderArea:
                if (!state.context.cssBackgroundClipBorderAreaEnabled)
                    return nullptr;
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                return nullptr;
            }
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeBackgroundImage(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // [ <image> | none ]#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // none
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueNone:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                break;
            }
            // <image>
            return consumeImage(range, state, { AllowedImageType::URLFunction, AllowedImageType::ImageSet, AllowedImageType::GeneratedImage });
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeBackgroundOrigin(CSSParserTokenRange& range)
{
    // [ border-box | padding-box | content-box ]#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // border-box | padding-box | content-box
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueBorderBox:
            case CSSValueID::CSSValuePaddingBox:
            case CSSValueID::CSSValueContentBox:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                return nullptr;
            }
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm);
    };
    return consumeUnboundedRepetition(range);
}

static RefPtr<CSSValue> consumeBackgroundPositionX(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <position-x>#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <position-x>
            return consumePositionX(range, state);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeBackgroundPositionY(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <position-y>#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <position-y>
            return consumePositionY(range, state);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeBackgroundRepeat(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <repeat-style>#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <repeat-style>
            return consumeRepeatStyle(range, state);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeBackgroundSize(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <single-background-size>#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <single-background-size>
            return consumeSingleBackgroundSize(range, state);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeBaselineShift(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // baseline | sub | super
    if (auto result = consumeIdent(range, isKeywordValidForBaselineShift))
        return result;
    // <length-percentage>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeBorderImageSource(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // none
    if (auto result = consumeIdent(range, isKeywordValidForBorderImageSource))
        return result;
    // <image>
    return consumeImage(range, state, { AllowedImageType::URLFunction, AllowedImageType::ImageSet, AllowedImageType::GeneratedImage });
}

static RefPtr<CSSValue> consumeCaretColor(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForCaretColor))
        return result;
    // <color>
    return consumeColor(range, state, { .allowedColorTypes = { CSS::ColorType::Absolute, CSS::ColorType::Current, CSS::ColorType::System } });
}

static RefPtr<CSSValue> consumeClip(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForClip))
        return result;
    // <rect()-override-function>
    return consumeClipRectFunction(range, state);
}

static RefPtr<CSSValue> consumeColumnRuleWidth(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // medium | thick | thin
    if (auto result = consumeIdent(range, isKeywordValidForColumnRuleWidth))
        return result;
    // <length [0,inf]>
    return CSSPrimitiveValueResolver<CSS::Length<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeContain(CSSParserTokenRange& range)
{
    // content | none | strict
    if (auto result = consumeIdent(range, isKeywordValidForContain))
        return result;
    // [ [ size | inline-size ] || layout || style || paint ]@(no-single-item-opt)
    auto consumeMatchOneOrMoreAnyOrder = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        RefPtr<CSSValue> value0; // [ size | inline-size ]
        auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // size | inline-size
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueSize:
                case CSSValueID::CSSValueInlineSize:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value0)
                return false;
            value0 = consumeTerm0(range);
            return !!value0;
        };
        RefPtr<CSSValue> value1; // layout
        auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // layout
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueLayout:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value1)
                return false;
            value1 = consumeTerm1(range);
            return !!value1;
        };
        RefPtr<CSSValue> value2; // style
        auto tryConsumeTerm2 = [&value2](CSSParserTokenRange& range) -> bool {
            auto consumeTerm2 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // style
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueStyle:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value2)
                return false;
            value2 = consumeTerm2(range);
            return !!value2;
        };
        RefPtr<CSSValue> value3; // paint
        auto tryConsumeTerm3 = [&value3](CSSParserTokenRange& range) -> bool {
            auto consumeTerm3 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // paint
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValuePaint:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value3)
                return false;
            value3 = consumeTerm3(range);
            return !!value3;
        };
        for (size_t i = 0; i < 4 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range) || tryConsumeTerm1(range) || tryConsumeTerm2(range) || tryConsumeTerm3(range))
                continue;
            break;
        }
        CSSValueListBuilder list;
        if (value0) // [ size | inline-size ]
            list.append(value0.releaseNonNull());
        if (value1) // layout
            list.append(value1.releaseNonNull());
        if (value2) // style
            list.append(value2.releaseNonNull());
        if (value3) // paint
            list.append(value3.releaseNonNull());
        if (list.isEmpty())
            return { };
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchOneOrMoreAnyOrder(range);
}

static RefPtr<CSSValue> consumeContainerName(CSSParserTokenRange& range)
{
    // none
    if (auto result = consumeIdent(range, isKeywordValidForContainerName))
        return result;
    // <custom-ident excluding=['none', 'and', 'or', 'not']>+@(no-single-item-opt)
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // <custom-ident excluding=['none', 'and', 'or', 'not']>
            return consumeCustomIdentExcluding(range, { CSSValueID::CSSValueNone, CSSValueID::CSSValueAnd, CSSValueID::CSSValueOr, CSSValueID::CSSValueNot });
        };
        return consumeListSeparatedBy<' ', ListBounds::minimumOf(1), ListOptimization::None, CSSValueList>(range, consumeRepeatedTerm);
    };
    return consumeUnboundedRepetition(range);
}

static RefPtr<CSSValue> consumeD(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // none
    if (auto result = consumeIdent(range, isKeywordValidForD))
        return result;
    // <path()>
    return consumePath(range, state);
}

static RefPtr<CSSValue> consumeFill(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // none
    if (auto result = consumeIdent(range, isKeywordValidForFill))
        return result;
    // <color>
    if (auto result = consumeColor(range, state, { .allowedColorTypes = { CSS::ColorType::Absolute, CSS::ColorType::Current, CSS::ColorType::System } }))
        return result;
    // [ <url> [ none | <color> ]? ]
    auto consumeMatchAllOrdered = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeTerm0 = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <url>
            return consumeURL(range, state, { });
        };
        auto consumeTerm1 = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // none
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueNone:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                break;
            }
            // <color>
            return consumeColor(range, state, { .allowedColorTypes = { CSS::ColorType::Absolute, CSS::ColorType::Current, CSS::ColorType::System } });
        };
        CSSValueListBuilder list;
        // <url>
        auto value0 = consumeTerm0(range, state);
        if (value0)
            list.append(value0.releaseNonNull());
        else
            return { };
        // [ none | <color> ]?
        auto value1 = consumeTerm1(range, state);
        if (value1)
            list.append(value1.releaseNonNull());
        if (list.size() == 1)
            return WTFMove(list[0]); // single item optimization
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchAllOrdered(range, state);
}

static RefPtr<CSSValue> consumeFillOpacity(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <number>
    if (auto result = CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, state))
        return result;
    // <percentage>
    return CSSPrimitiveValueResolver<CSS::Percentage<>>::consumeAndResolve(range, state);
}

static RefPtr<CSSValue> consumeFlexBasis(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto | content | fit-content | intrinsic | max-content | min-content | min-intrinsic | -webkit-fill-available | -webkit-fit-content | -webkit-max-content | -webkit-min-content
    if (auto result = consumeIdent(range, isKeywordValidForFlexBasis))
        return result;
    // <length-percentage [0,inf]>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeFloodOpacity(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <number>
    if (auto result = CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, state))
        return result;
    // <percentage>
    return CSSPrimitiveValueResolver<CSS::Percentage<>>::consumeAndResolve(range, state);
}

static RefPtr<CSSValue> consumeGlyphOrientationVertical(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForGlyphOrientationVertical))
        return result;
    // <angle unitless-zero=['allowed']>
    return CSSPrimitiveValueResolver<CSS::Angle<>>::consumeAndResolve(range, state, { .unitlessZeroAngle = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeHangingPunctuation(CSSParserTokenRange& range)
{
    // none
    if (auto result = consumeIdent(range, isKeywordValidForHangingPunctuation))
        return result;
    // [ first || [ force-end | allow-end ] || last ]@(preserve-order no-single-item-opt)
    auto consumeMatchOneOrMoreAnyOrder = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        CSSValueListBuilder list;
        bool consumedValue0 = false; // first
        auto tryConsumeTerm0 = [&list, &consumedValue0](CSSParserTokenRange& range) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // first
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueFirst:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (consumedValue0)
                return false;
            if (auto value = consumeTerm0(range)) {
                list.append(value.releaseNonNull());
                consumedValue0 = true;
                return true;
            }
            return false;
        };
        bool consumedValue1 = false; // [ force-end | allow-end ]
        auto tryConsumeTerm1 = [&list, &consumedValue1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // force-end | allow-end
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueForceEnd:
                case CSSValueID::CSSValueAllowEnd:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (consumedValue1)
                return false;
            if (auto value = consumeTerm1(range)) {
                list.append(value.releaseNonNull());
                consumedValue1 = true;
                return true;
            }
            return false;
        };
        bool consumedValue2 = false; // last
        auto tryConsumeTerm2 = [&list, &consumedValue2](CSSParserTokenRange& range) -> bool {
            auto consumeTerm2 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // last
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueLast:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (consumedValue2)
                return false;
            if (auto value = consumeTerm2(range)) {
                list.append(value.releaseNonNull());
                consumedValue2 = true;
                return true;
            }
            return false;
        };
        for (size_t i = 0; i < 3 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range) || tryConsumeTerm1(range) || tryConsumeTerm2(range))
                continue;
            break;
        }
        if (list.isEmpty())
            return { };
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchOneOrMoreAnyOrder(range);
}

static RefPtr<CSSValue> consumeHyphenateCharacter(CSSParserTokenRange& range)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForHyphenateCharacter))
        return result;
    // <string>
    return consumeString(range);
}

static RefPtr<CSSValue> consumeListStyleImage(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // none
    if (auto result = consumeIdent(range, isKeywordValidForListStyleImage))
        return result;
    // <image>
    return consumeImage(range, state, { AllowedImageType::URLFunction, AllowedImageType::ImageSet, AllowedImageType::GeneratedImage });
}

static RefPtr<CSSValue> consumeMarkerEnd(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // none
    if (auto result = consumeIdent(range, isKeywordValidForMarkerEnd))
        return result;
    // <url>
    return consumeURL(range, state, { });
}

static RefPtr<CSSValue> consumeMarkerMid(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // none
    if (auto result = consumeIdent(range, isKeywordValidForMarkerMid))
        return result;
    // <url>
    return consumeURL(range, state, { });
}

static RefPtr<CSSValue> consumeMarkerStart(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // none
    if (auto result = consumeIdent(range, isKeywordValidForMarkerStart))
        return result;
    // <url>
    return consumeURL(range, state, { });
}

static RefPtr<CSSValue> consumeMaskBorderOutset(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // [ <number [0,inf]> | <length [0,inf]> ]{1,4}@(type=CSSQuadValue no-single-item-opt)
    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <number [0,inf]>
            if (auto result = CSSPrimitiveValueResolver<CSS::Number<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state))
                return result;
            // <length [0,inf]>
            return CSSPrimitiveValueResolver<CSS::Length<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow });
        };
        CSSParserTokenRange rangeCopy = range;
        auto term0 = consumeRepeatedTerm(rangeCopy, state);
        if (!term0)
            return { };
        auto term1 = consumeRepeatedTerm(rangeCopy, state);
        if (!term1) {
            range = rangeCopy;
            return CSSQuadValue::create(term0.releaseNonNull());
        }
        auto term2 = consumeRepeatedTerm(rangeCopy, state);
        if (!term2) {
            range = rangeCopy;
            return CSSQuadValue::create(term0.releaseNonNull(), term1.releaseNonNull());
        }
        auto term3 = consumeRepeatedTerm(rangeCopy, state);
        if (!term3) {
            range = rangeCopy;
            return CSSQuadValue::create(term0.releaseNonNull(), term1.releaseNonNull(), term2.releaseNonNull());
        }
        range = rangeCopy;
        return CSSQuadValue::create(term0.releaseNonNull(), term1.releaseNonNull(), term2.releaseNonNull(), term3.releaseNonNull());
    };
    return consumeBoundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeMaskBorderRepeat(CSSParserTokenRange& range)
{
    // [ stretch | repeat | round | space ]{1,2}@(type=CSSValuePair default=previous)
    auto consumeBoundedRepetition = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // stretch | repeat | round | space
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueStretch:
            case CSSValueID::CSSValueRepeat:
            case CSSValueID::CSSValueRound:
            case CSSValueID::CSSValueSpace:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                return nullptr;
            }
        };
        CSSParserTokenRange rangeCopy = range;
        auto term0 = consumeRepeatedTerm(rangeCopy);
        if (!term0)
            return { };
        auto term1 = consumeRepeatedTerm(rangeCopy);
        if (!term1) {
            term1 = term0;
            range = rangeCopy;
            return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull());
        }
        range = rangeCopy;
        return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull());
    };
    return consumeBoundedRepetition(range);
}

static RefPtr<CSSValue> consumeMaskBorderSource(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // none
    if (auto result = consumeIdent(range, isKeywordValidForMaskBorderSource))
        return result;
    // <image>
    return consumeImage(range, state, { AllowedImageType::URLFunction, AllowedImageType::ImageSet, AllowedImageType::GeneratedImage });
}

static RefPtr<CSSValue> consumeMaskClip(CSSParserTokenRange& range)
{
    // [ border-box | padding-box | content-box | no-clip ]#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // border-box | padding-box | content-box | no-clip
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueBorderBox:
            case CSSValueID::CSSValuePaddingBox:
            case CSSValueID::CSSValueContentBox:
            case CSSValueID::CSSValueNoClip:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                return nullptr;
            }
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm);
    };
    return consumeUnboundedRepetition(range);
}

static RefPtr<CSSValue> consumeMaskComposite(CSSParserTokenRange& range)
{
    // [ add | subtract | intersect | exclude ]#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // add | subtract | intersect | exclude
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueAdd:
            case CSSValueID::CSSValueSubtract:
            case CSSValueID::CSSValueIntersect:
            case CSSValueID::CSSValueExclude:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                return nullptr;
            }
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm);
    };
    return consumeUnboundedRepetition(range);
}

static RefPtr<CSSValue> consumeMaskImage(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // [ <image> | none ]#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // none
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueNone:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                break;
            }
            // <image>
            return consumeImage(range, state, { AllowedImageType::URLFunction, AllowedImageType::ImageSet, AllowedImageType::GeneratedImage });
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeMaskMode(CSSParserTokenRange& range)
{
    // [ alpha | luminance | match-source ]#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // alpha | luminance | match-source
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueAlpha:
            case CSSValueID::CSSValueLuminance:
            case CSSValueID::CSSValueMatchSource:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                return nullptr;
            }
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm);
    };
    return consumeUnboundedRepetition(range);
}

static RefPtr<CSSValue> consumeMaskOrigin(CSSParserTokenRange& range)
{
    // [ border-box | padding-box | content-box | border | content | padding | -webkit-text ]#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // border-box | padding-box | content-box | border | content | padding | -webkit-text
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueBorderBox:
            case CSSValueID::CSSValuePaddingBox:
            case CSSValueID::CSSValueContentBox:
            case CSSValueID::CSSValueBorder:
            case CSSValueID::CSSValueContent:
            case CSSValueID::CSSValuePadding:
            case CSSValueID::CSSValueWebkitText:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                return nullptr;
            }
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm);
    };
    return consumeUnboundedRepetition(range);
}

static RefPtr<CSSValue> consumeMaskRepeat(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <repeat-style>#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <repeat-style>
            return consumeRepeatStyle(range, state);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeMaskSize(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <single-mask-size>#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <single-mask-size>
            return consumeSingleMaskSize(range, state);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeOffsetAnchor(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForOffsetAnchor))
        return result;
    // <position>
    return consumePosition(range, state);
}

static RefPtr<CSSValue> consumeOffsetPosition(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto | normal
    if (auto result = consumeIdent(range, isKeywordValidForOffsetPosition))
        return result;
    // <position>
    return consumePosition(range, state);
}

static RefPtr<CSSValue> consumeOffsetRotate(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // [ [ auto | reverse ] || <angle> ]@(type=CSSOffsetRotateValue)
    auto consumeMatchOneOrMoreAnyOrder = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        RefPtr<CSSValue> value0; // [ auto | reverse ]
        auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // auto | reverse
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueAuto:
                case CSSValueID::CSSValueReverse:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value0)
                return false;
            value0 = consumeTerm0(range);
            return !!value0;
        };
        RefPtr<CSSValue> value1; // <angle>
        auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                // <angle>
                return CSSPrimitiveValueResolver<CSS::Angle<>>::consumeAndResolve(range, state, { .unitlessZeroAngle = UnitlessZeroQuirk::Forbid });
            };
            if (value1)
                return false;
            value1 = consumeTerm1(range, state);
            return !!value1;
        };
        for (size_t i = 0; i < 2 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range) || tryConsumeTerm1(range, state))
                continue;
            break;
        }
        CSSValueListBuilder list;
        if (value0) // [ auto | reverse ]
            list.append(value0.releaseNonNull());
        if (value1) // <angle>
            list.append(value1.releaseNonNull());
        if (list.isEmpty())
            return { };
        if (list.size() == 1)
            return WTFMove(list[0]); // single item optimization
        return CSSOffsetRotateValue::create(WTFMove(list[0]), WTFMove(list[1]));
    };
    return consumeMatchOneOrMoreAnyOrder(range, state);
}

static RefPtr<CSSValue> consumeOpacity(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <number>
    if (auto result = CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, state))
        return result;
    // <percentage>
    return CSSPrimitiveValueResolver<CSS::Percentage<>>::consumeAndResolve(range, state);
}

static RefPtr<CSSValue> consumeOutlineColor(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // -webkit-focus-ring-color
    if (auto result = consumeIdent(range, isKeywordValidForOutlineColor))
        return result;
    // <color>
    return consumeColor(range, state, { .allowedColorTypes = { CSS::ColorType::Absolute, CSS::ColorType::Current, CSS::ColorType::System } });
}

static RefPtr<CSSValue> consumeOutlineWidth(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // medium | thick | thin
    if (auto result = consumeIdent(range, isKeywordValidForOutlineWidth))
        return result;
    // <length [0,inf]>
    return CSSPrimitiveValueResolver<CSS::Length<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumePage(CSSParserTokenRange& range)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForPage))
        return result;
    // <custom-ident>
    return consumeCustomIdent(range);
}

static RefPtr<CSSValue> consumePositionAnchor(CSSParserTokenRange& range)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForPositionAnchor))
        return result;
    // <dashed-ident>
    return consumeDashedIdent(range);
}

static RefPtr<CSSValue> consumePositionVisibility(CSSParserTokenRange& range)
{
    // always
    if (auto result = consumeIdent(range, isKeywordValidForPositionVisibility))
        return result;
    // [ anchors-valid || anchors-visible || no-overflow ]@(no-single-item-opt)
    auto consumeMatchOneOrMoreAnyOrder = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        RefPtr<CSSValue> value0; // anchors-valid
        auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // anchors-valid
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueAnchorsValid:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value0)
                return false;
            value0 = consumeTerm0(range);
            return !!value0;
        };
        RefPtr<CSSValue> value1; // anchors-visible
        auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // anchors-visible
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueAnchorsVisible:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value1)
                return false;
            value1 = consumeTerm1(range);
            return !!value1;
        };
        RefPtr<CSSValue> value2; // no-overflow
        auto tryConsumeTerm2 = [&value2](CSSParserTokenRange& range) -> bool {
            auto consumeTerm2 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // no-overflow
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueNoOverflow:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value2)
                return false;
            value2 = consumeTerm2(range);
            return !!value2;
        };
        for (size_t i = 0; i < 3 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range) || tryConsumeTerm1(range) || tryConsumeTerm2(range))
                continue;
            break;
        }
        CSSValueListBuilder list;
        if (value0) // anchors-valid
            list.append(value0.releaseNonNull());
        if (value1) // anchors-visible
            list.append(value1.releaseNonNull());
        if (value2) // no-overflow
            list.append(value2.releaseNonNull());
        if (list.isEmpty())
            return { };
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchOneOrMoreAnyOrder(range);
}

static RefPtr<CSSValue> consumeRx(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForRx))
        return result;
    // <length-percentage [0,inf]>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeRy(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForRy))
        return result;
    // <length-percentage [0,inf]>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeScrollSnapAlign(CSSParserTokenRange& range)
{
    // [ none | start | end | center ]{1,2}@(type=CSSValuePair default=previous)
    auto consumeBoundedRepetition = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // none | start | end | center
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueNone:
            case CSSValueID::CSSValueStart:
            case CSSValueID::CSSValueEnd:
            case CSSValueID::CSSValueCenter:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                return nullptr;
            }
        };
        CSSParserTokenRange rangeCopy = range;
        auto term0 = consumeRepeatedTerm(rangeCopy);
        if (!term0)
            return { };
        auto term1 = consumeRepeatedTerm(rangeCopy);
        if (!term1) {
            term1 = term0;
            range = rangeCopy;
            return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull());
        }
        range = rangeCopy;
        return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull());
    };
    return consumeBoundedRepetition(range);
}

static RefPtr<CSSValue> consumeScrollbarGutter(CSSParserTokenRange& range)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForScrollbarGutter))
        return result;
    // [ stable && both-edges? ]@(type=CSSValuePair)
    auto consumeMatchAllAnyOrder = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        RefPtr<CSSValue> value0; // stable
        auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // stable
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueStable:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value0)
                return false;
            value0 = consumeTerm0(range);
            return !!value0;
        };
        RefPtr<CSSValue> value1; // both-edges?
        auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // both-edges
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueBothEdges:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value1)
                return false;
            value1 = consumeTerm1(range);
            return !!value1;
        };
        for (size_t i = 0; i < 2 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range) || tryConsumeTerm1(range))
                continue;
            break;
        }
        CSSValueListBuilder list;
        if (value0) // stable
            list.append(value0.releaseNonNull());
        else
            return { };
        if (value1) // both-edges?
            list.append(value1.releaseNonNull());
        if (list.size() == 1)
            return WTFMove(list[0]); // single item optimization
        return CSSValuePair::create(WTFMove(list[0]), WTFMove(list[1]));
    };
    return consumeMatchAllAnyOrder(range);
}

static RefPtr<CSSValue> consumeSpeakAs(CSSParserTokenRange& range)
{
    // none
    if (auto result = consumeIdent(range, isKeywordValidForSpeakAs))
        return result;
    // [ [ normal | spell-out ] || digits || [ literal-punctuation | no-punctuation ] ]@(no-single-item-opt)
    auto consumeMatchOneOrMoreAnyOrder = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        RefPtr<CSSValue> value0; // [ normal | spell-out ]
        auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // normal | spell-out
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueNormal:
                case CSSValueID::CSSValueSpellOut:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value0)
                return false;
            value0 = consumeTerm0(range);
            return !!value0;
        };
        RefPtr<CSSValue> value1; // digits
        auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // digits
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueDigits:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value1)
                return false;
            value1 = consumeTerm1(range);
            return !!value1;
        };
        RefPtr<CSSValue> value2; // [ literal-punctuation | no-punctuation ]
        auto tryConsumeTerm2 = [&value2](CSSParserTokenRange& range) -> bool {
            auto consumeTerm2 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // literal-punctuation | no-punctuation
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueLiteralPunctuation:
                case CSSValueID::CSSValueNoPunctuation:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value2)
                return false;
            value2 = consumeTerm2(range);
            return !!value2;
        };
        for (size_t i = 0; i < 3 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range) || tryConsumeTerm1(range) || tryConsumeTerm2(range))
                continue;
            break;
        }
        CSSValueListBuilder list;
        if (value0) // [ normal | spell-out ]
            list.append(value0.releaseNonNull());
        if (value1) // digits
            list.append(value1.releaseNonNull());
        if (value2) // [ literal-punctuation | no-punctuation ]
            list.append(value2.releaseNonNull());
        if (list.isEmpty())
            return { };
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchOneOrMoreAnyOrder(range);
}

static RefPtr<CSSValue> consumeStopOpacity(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <number>
    if (auto result = CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, state))
        return result;
    // <percentage>
    return CSSPrimitiveValueResolver<CSS::Percentage<>>::consumeAndResolve(range, state);
}

static RefPtr<CSSValue> consumeStroke(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // none
    if (auto result = consumeIdent(range, isKeywordValidForStroke))
        return result;
    // <color>
    if (auto result = consumeColor(range, state, { .allowedColorTypes = { CSS::ColorType::Absolute, CSS::ColorType::Current, CSS::ColorType::System } }))
        return result;
    // [ <url> [ none | <color> ]? ]
    auto consumeMatchAllOrdered = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeTerm0 = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <url>
            return consumeURL(range, state, { });
        };
        auto consumeTerm1 = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // none
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueNone:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                break;
            }
            // <color>
            return consumeColor(range, state, { .allowedColorTypes = { CSS::ColorType::Absolute, CSS::ColorType::Current, CSS::ColorType::System } });
        };
        CSSValueListBuilder list;
        // <url>
        auto value0 = consumeTerm0(range, state);
        if (value0)
            list.append(value0.releaseNonNull());
        else
            return { };
        // [ none | <color> ]?
        auto value1 = consumeTerm1(range, state);
        if (value1)
            list.append(value1.releaseNonNull());
        if (list.size() == 1)
            return WTFMove(list[0]); // single item optimization
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchAllOrdered(range, state);
}

static RefPtr<CSSValue> consumeStrokeDashoffset(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <length-percentage>
    if (auto result = CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow }))
        return result;
    // <number>
    return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, state);
}

static RefPtr<CSSValue> consumeStrokeOpacity(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <number>
    if (auto result = CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, state))
        return result;
    // <percentage>
    return CSSPrimitiveValueResolver<CSS::Percentage<>>::consumeAndResolve(range, state);
}

static RefPtr<CSSValue> consumeStrokeWidth(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <length-percentage [0,inf]>
    if (auto result = CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow }))
        return result;
    // <number [0,inf]>
    return CSSPrimitiveValueResolver<CSS::Number<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state);
}

static RefPtr<CSSValue> consumeTabSize(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <number [0,inf]>
    if (auto result = CSSPrimitiveValueResolver<CSS::Number<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state))
        return result;
    // <length [0,inf]>
    return CSSPrimitiveValueResolver<CSS::Length<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeTextDecorationThickness(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto | from-font
    if (auto result = consumeIdent(range, isKeywordValidForTextDecorationThickness))
        return result;
    // <length-percentage>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeTextEmphasisPosition(CSSParserTokenRange& range)
{
    // [ [ over | under ] && [ right | left ]? ]@(no-single-item-opt)
    auto consumeMatchAllAnyOrder = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        RefPtr<CSSValue> value0; // [ over | under ]
        auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // over | under
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueOver:
                case CSSValueID::CSSValueUnder:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value0)
                return false;
            value0 = consumeTerm0(range);
            return !!value0;
        };
        RefPtr<CSSValue> value1; // [ right | left ]?
        auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // right | left
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueRight:
                case CSSValueID::CSSValueLeft:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value1)
                return false;
            value1 = consumeTerm1(range);
            return !!value1;
        };
        for (size_t i = 0; i < 2 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range) || tryConsumeTerm1(range))
                continue;
            break;
        }
        CSSValueListBuilder list;
        if (value0) // [ over | under ]
            list.append(value0.releaseNonNull());
        else
            return { };
        if (value1) // [ right | left ]?
            list.append(value1.releaseNonNull());
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchAllAnyOrder(range);
}

static RefPtr<CSSValue> consumeTextEmphasisStyle(CSSParserTokenRange& range)
{
    // none
    if (auto result = consumeIdent(range, isKeywordValidForTextEmphasisStyle))
        return result;
    // <string>
    if (auto result = consumeString(range))
        return result;
    // [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ]
    auto consumeMatchOneOrMoreAnyOrder = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        RefPtr<CSSValue> value0; // [ filled | open ]
        auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // filled | open
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueFilled:
                case CSSValueID::CSSValueOpen:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value0)
                return false;
            value0 = consumeTerm0(range);
            return !!value0;
        };
        RefPtr<CSSValue> value1; // [ dot | circle | double-circle | triangle | sesame ]
        auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // dot | circle | double-circle | triangle | sesame
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueDot:
                case CSSValueID::CSSValueCircle:
                case CSSValueID::CSSValueDoubleCircle:
                case CSSValueID::CSSValueTriangle:
                case CSSValueID::CSSValueSesame:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value1)
                return false;
            value1 = consumeTerm1(range);
            return !!value1;
        };
        for (size_t i = 0; i < 2 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range) || tryConsumeTerm1(range))
                continue;
            break;
        }
        CSSValueListBuilder list;
        if (value0) // [ filled | open ]
            list.append(value0.releaseNonNull());
        if (value1) // [ dot | circle | double-circle | triangle | sesame ]
            list.append(value1.releaseNonNull());
        if (list.isEmpty())
            return { };
        if (list.size() == 1)
            return WTFMove(list[0]); // single item optimization
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchOneOrMoreAnyOrder(range);
}

static RefPtr<CSSValue> consumeTextIndent(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // [ <length-percentage> && hanging? && each-line? ]
    auto consumeMatchAllAnyOrder = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        RefPtr<CSSValue> value0; // <length-percentage>
        auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                // <length-percentage>
                return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
            };
            if (value0)
                return false;
            value0 = consumeTerm0(range, state);
            return !!value0;
        };
        RefPtr<CSSValue> value1; // hanging?
        auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // hanging
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueHanging:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value1)
                return false;
            value1 = consumeTerm1(range);
            return !!value1;
        };
        RefPtr<CSSValue> value2; // each-line?
        auto tryConsumeTerm2 = [&value2](CSSParserTokenRange& range) -> bool {
            auto consumeTerm2 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // each-line
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueEachLine:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value2)
                return false;
            value2 = consumeTerm2(range);
            return !!value2;
        };
        for (size_t i = 0; i < 3 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range, state) || tryConsumeTerm1(range) || tryConsumeTerm2(range))
                continue;
            break;
        }
        CSSValueListBuilder list;
        if (value0) // <length-percentage>
            list.append(value0.releaseNonNull());
        else
            return { };
        if (value1) // hanging?
            list.append(value1.releaseNonNull());
        if (value2) // each-line?
            list.append(value2.releaseNonNull());
        if (list.size() == 1)
            return WTFMove(list[0]); // single item optimization
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchAllAnyOrder(range, state);
}

static RefPtr<CSSValue> consumeTextTransform(CSSParserTokenRange& range)
{
    // none
    if (auto result = consumeIdent(range, isKeywordValidForTextTransform))
        return result;
    // [ [ capitalize | uppercase | lowercase ] || full-width || full-size-kana ]@(no-single-item-opt)
    auto consumeMatchOneOrMoreAnyOrder = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        RefPtr<CSSValue> value0; // [ capitalize | uppercase | lowercase ]
        auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // capitalize | uppercase | lowercase
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueCapitalize:
                case CSSValueID::CSSValueUppercase:
                case CSSValueID::CSSValueLowercase:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value0)
                return false;
            value0 = consumeTerm0(range);
            return !!value0;
        };
        RefPtr<CSSValue> value1; // full-width
        auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // full-width
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueFullWidth:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value1)
                return false;
            value1 = consumeTerm1(range);
            return !!value1;
        };
        RefPtr<CSSValue> value2; // full-size-kana
        auto tryConsumeTerm2 = [&value2](CSSParserTokenRange& range) -> bool {
            auto consumeTerm2 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // full-size-kana
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueFullSizeKana:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value2)
                return false;
            value2 = consumeTerm2(range);
            return !!value2;
        };
        for (size_t i = 0; i < 3 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range) || tryConsumeTerm1(range) || tryConsumeTerm2(range))
                continue;
            break;
        }
        CSSValueListBuilder list;
        if (value0) // [ capitalize | uppercase | lowercase ]
            list.append(value0.releaseNonNull());
        if (value1) // full-width
            list.append(value1.releaseNonNull());
        if (value2) // full-size-kana
            list.append(value2.releaseNonNull());
        if (list.isEmpty())
            return { };
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchOneOrMoreAnyOrder(range);
}

static RefPtr<CSSValue> consumeTextUnderlineOffset(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForTextUnderlineOffset))
        return result;
    // <length-percentage>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeTextUnderlinePosition(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForTextUnderlinePosition))
        return result;
    // [ [ under | from-font ] || [ left | right ]@(settings-flag=cssTextUnderlinePositionLeftRightEnabled) ]@(type=CSSValuePair)
    auto consumeMatchOneOrMoreAnyOrder = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        RefPtr<CSSValue> value0; // [ under | from-font ]
        auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // under | from-font
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueUnder:
                case CSSValueID::CSSValueFromFont:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value0)
                return false;
            value0 = consumeTerm0(range);
            return !!value0;
        };
        RefPtr<CSSValue> value1; // [ left | right ]@(settings-flag=cssTextUnderlinePositionLeftRightEnabled)
        auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                if (!state.context.cssTextUnderlinePositionLeftRightEnabled)
                    return { };
                // left | right
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueLeft:
                case CSSValueID::CSSValueRight:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value1)
                return false;
            value1 = consumeTerm1(range, state);
            return !!value1;
        };
        for (size_t i = 0; i < 2 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range) || tryConsumeTerm1(range, state))
                continue;
            break;
        }
        CSSValueListBuilder list;
        if (value0) // [ under | from-font ]
            list.append(value0.releaseNonNull());
        if (value1) // [ left | right ]@(settings-flag=cssTextUnderlinePositionLeftRightEnabled)
            list.append(value1.releaseNonNull());
        if (list.isEmpty())
            return { };
        if (list.size() == 1)
            return WTFMove(list[0]); // single item optimization
        return CSSValuePair::create(WTFMove(list[0]), WTFMove(list[1]));
    };
    return consumeMatchOneOrMoreAnyOrder(range, state);
}

static RefPtr<CSSValue> consumeTimelineScope(CSSParserTokenRange& range)
{
    // all | none
    if (auto result = consumeIdent(range, isKeywordValidForTimelineScope))
        return result;
    // <dashed-ident>#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // <dashed-ident>
            return consumeDashedIdent(range);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm);
    };
    return consumeUnboundedRepetition(range);
}

static RefPtr<CSSValue> consumeTouchAction(CSSParserTokenRange& range)
{
    // auto | manipulation | none
    if (auto result = consumeIdent(range, isKeywordValidForTouchAction))
        return result;
    // [ pan-x || pan-y || pinch-zoom ]@(no-single-item-opt)
    auto consumeMatchOneOrMoreAnyOrder = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        RefPtr<CSSValue> value0; // pan-x
        auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // pan-x
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValuePanX:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value0)
                return false;
            value0 = consumeTerm0(range);
            return !!value0;
        };
        RefPtr<CSSValue> value1; // pan-y
        auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // pan-y
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValuePanY:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value1)
                return false;
            value1 = consumeTerm1(range);
            return !!value1;
        };
        RefPtr<CSSValue> value2; // pinch-zoom
        auto tryConsumeTerm2 = [&value2](CSSParserTokenRange& range) -> bool {
            auto consumeTerm2 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // pinch-zoom
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValuePinchZoom:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value2)
                return false;
            value2 = consumeTerm2(range);
            return !!value2;
        };
        for (size_t i = 0; i < 3 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range) || tryConsumeTerm1(range) || tryConsumeTerm2(range))
                continue;
            break;
        }
        CSSValueListBuilder list;
        if (value0) // pan-x
            list.append(value0.releaseNonNull());
        if (value1) // pan-y
            list.append(value1.releaseNonNull());
        if (value2) // pinch-zoom
            list.append(value2.releaseNonNull());
        if (list.isEmpty())
            return { };
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchOneOrMoreAnyOrder(range);
}

static RefPtr<CSSValue> consumeTransitionBehavior(CSSParserTokenRange& range)
{
    // [ normal | allow-discrete ]#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // normal | allow-discrete
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueNormal:
            case CSSValueID::CSSValueAllowDiscrete:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                return nullptr;
            }
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm);
    };
    return consumeUnboundedRepetition(range);
}

static RefPtr<CSSValue> consumeTransitionDelay(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <time>#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <time>
            return CSSPrimitiveValueResolver<CSS::Time<>>::consumeAndResolve(range, state);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeTransitionDuration(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <time [0,inf]>#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <time [0,inf]>
            return CSSPrimitiveValueResolver<CSS::Time<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeTransitionProperty(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // none
    if (auto result = consumeIdent(range, isKeywordValidForTransitionProperty))
        return result;
    // <single-transition-property>#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <single-transition-property>
            return consumeSingleTransitionProperty(range, state);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeTransitionTimingFunction(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <easing-function>#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <easing-function>
            return consumeEasingFunction(range, state);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeVerticalAlign(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // baseline | bottom | middle | sub | super | text-bottom | text-top | top | -webkit-baseline-middle
    if (auto result = consumeIdent(range, isKeywordValidForVerticalAlign))
        return result;
    // <length-percentage>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeViewTimelineInset(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <single-view-timeline-inset-item-override-function>#@(no-single-item-opt)
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <single-view-timeline-inset-item-override-function>
            return consumeSingleViewTimelineInsetItem(range, state);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::None, CSSValueList>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeViewTransitionClass(CSSParserTokenRange& range)
{
    // none
    if (auto result = consumeIdent(range, isKeywordValidForViewTransitionClass))
        return result;
    // <custom-ident excluding=['none']>+@(no-single-item-opt)
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // <custom-ident excluding=['none']>
            return consumeCustomIdentExcluding(range, { CSSValueID::CSSValueNone });
        };
        return consumeListSeparatedBy<' ', ListBounds::minimumOf(1), ListOptimization::None, CSSValueList>(range, consumeRepeatedTerm);
    };
    return consumeUnboundedRepetition(range);
}

static RefPtr<CSSValue> consumeViewTransitionName(CSSParserTokenRange& range)
{
    // auto | match-element | none
    if (auto result = consumeIdent(range, isKeywordValidForViewTransitionName))
        return result;
    // <custom-ident>
    return consumeCustomIdent(range);
}

static RefPtr<CSSValue> consumeZIndex(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForZIndex))
        return result;
    // <integer>
    return CSSPrimitiveValueResolver<CSS::Integer<>>::consumeAndResolve(range, state);
}

static RefPtr<CSSValue> consumeWebkitBackgroundClip(CSSParserTokenRange& range)
{
    // [ border-box | padding-box | content-box | border | content | padding | -webkit-text | text ]#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // border-box | padding-box | content-box | border | content | padding | -webkit-text | text
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueBorderBox:
            case CSSValueID::CSSValuePaddingBox:
            case CSSValueID::CSSValueContentBox:
            case CSSValueID::CSSValueBorder:
            case CSSValueID::CSSValueContent:
            case CSSValueID::CSSValuePadding:
            case CSSValueID::CSSValueWebkitText:
            case CSSValueID::CSSValueText:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                return nullptr;
            }
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm);
    };
    return consumeUnboundedRepetition(range);
}

static RefPtr<CSSValue> consumeWebkitBackgroundOrigin(CSSParserTokenRange& range)
{
    // [ border-box | padding-box | content-box | border | content | padding | -webkit-text ]#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // border-box | padding-box | content-box | border | content | padding | -webkit-text
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueBorderBox:
            case CSSValueID::CSSValuePaddingBox:
            case CSSValueID::CSSValueContentBox:
            case CSSValueID::CSSValueBorder:
            case CSSValueID::CSSValueContent:
            case CSSValueID::CSSValuePadding:
            case CSSValueID::CSSValueWebkitText:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                return nullptr;
            }
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm);
    };
    return consumeUnboundedRepetition(range);
}

static RefPtr<CSSValue> consumeWebkitHyphenateLimitAfter(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForWebkitHyphenateLimitAfter))
        return result;
    // <number [0,inf]>
    return CSSPrimitiveValueResolver<CSS::Number<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state);
}

static RefPtr<CSSValue> consumeWebkitHyphenateLimitBefore(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForWebkitHyphenateLimitBefore))
        return result;
    // <number [0,inf]>
    return CSSPrimitiveValueResolver<CSS::Number<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state);
}

static RefPtr<CSSValue> consumeWebkitHyphenateLimitLines(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // no-limit
    if (auto result = consumeIdent(range, isKeywordValidForWebkitHyphenateLimitLines))
        return result;
    // <number [0,inf]>
    return CSSPrimitiveValueResolver<CSS::Number<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state);
}

static RefPtr<CSSValue> consumeWebkitInitialLetter(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // normal
    if (auto result = consumeIdent(range, isKeywordValidForWebkitInitialLetter))
        return result;
    // <number [0,inf]>{1,2}@(type=CSSValuePair default=previous)
    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <number [0,inf]>
            return CSSPrimitiveValueResolver<CSS::Number<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state);
        };
        CSSParserTokenRange rangeCopy = range;
        auto term0 = consumeRepeatedTerm(rangeCopy, state);
        if (!term0)
            return { };
        auto term1 = consumeRepeatedTerm(rangeCopy, state);
        if (!term1) {
            term1 = term0;
            range = rangeCopy;
            return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull());
        }
        range = rangeCopy;
        return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull());
    };
    return consumeBoundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeWebkitLineBoxContain(CSSParserTokenRange& range)
{
    // none
    if (auto result = consumeIdent(range, isKeywordValidForWebkitLineBoxContain))
        return result;
    // [ block || inline || font || glyphs || replaced || inline-box || initial-letter ]
    auto consumeMatchOneOrMoreAnyOrder = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        RefPtr<CSSValue> value0; // block
        auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // block
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueBlock:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value0)
                return false;
            value0 = consumeTerm0(range);
            return !!value0;
        };
        RefPtr<CSSValue> value1; // inline
        auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // inline
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueInline:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value1)
                return false;
            value1 = consumeTerm1(range);
            return !!value1;
        };
        RefPtr<CSSValue> value2; // font
        auto tryConsumeTerm2 = [&value2](CSSParserTokenRange& range) -> bool {
            auto consumeTerm2 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // font
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueFont:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value2)
                return false;
            value2 = consumeTerm2(range);
            return !!value2;
        };
        RefPtr<CSSValue> value3; // glyphs
        auto tryConsumeTerm3 = [&value3](CSSParserTokenRange& range) -> bool {
            auto consumeTerm3 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // glyphs
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueGlyphs:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value3)
                return false;
            value3 = consumeTerm3(range);
            return !!value3;
        };
        RefPtr<CSSValue> value4; // replaced
        auto tryConsumeTerm4 = [&value4](CSSParserTokenRange& range) -> bool {
            auto consumeTerm4 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // replaced
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueReplaced:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value4)
                return false;
            value4 = consumeTerm4(range);
            return !!value4;
        };
        RefPtr<CSSValue> value5; // inline-box
        auto tryConsumeTerm5 = [&value5](CSSParserTokenRange& range) -> bool {
            auto consumeTerm5 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // inline-box
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueInlineBox:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value5)
                return false;
            value5 = consumeTerm5(range);
            return !!value5;
        };
        RefPtr<CSSValue> value6; // initial-letter
        auto tryConsumeTerm6 = [&value6](CSSParserTokenRange& range) -> bool {
            auto consumeTerm6 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // initial-letter
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueInitialLetter:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value6)
                return false;
            value6 = consumeTerm6(range);
            return !!value6;
        };
        for (size_t i = 0; i < 7 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range) || tryConsumeTerm1(range) || tryConsumeTerm2(range) || tryConsumeTerm3(range) || tryConsumeTerm4(range) || tryConsumeTerm5(range) || tryConsumeTerm6(range))
                continue;
            break;
        }
        CSSValueListBuilder list;
        if (value0) // block
            list.append(value0.releaseNonNull());
        if (value1) // inline
            list.append(value1.releaseNonNull());
        if (value2) // font
            list.append(value2.releaseNonNull());
        if (value3) // glyphs
            list.append(value3.releaseNonNull());
        if (value4) // replaced
            list.append(value4.releaseNonNull());
        if (value5) // inline-box
            list.append(value5.releaseNonNull());
        if (value6) // initial-letter
            list.append(value6.releaseNonNull());
        if (list.isEmpty())
            return { };
        if (list.size() == 1)
            return WTFMove(list[0]); // single item optimization
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchOneOrMoreAnyOrder(range);
}

static RefPtr<CSSValue> consumeWebkitLineClamp(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // none
    if (auto result = consumeIdent(range, isKeywordValidForWebkitLineClamp))
        return result;
    // <percentage [0,inf]>
    if (auto result = CSSPrimitiveValueResolver<CSS::Percentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state))
        return result;
    // <integer [1,inf]>
    return CSSPrimitiveValueResolver<CSS::Integer<CSS::Range{1, CSS::Range::infinity}>>::consumeAndResolve(range, state);
}

static RefPtr<CSSValue> consumeWebkitLineGrid(CSSParserTokenRange& range)
{
    // none
    if (auto result = consumeIdent(range, isKeywordValidForWebkitLineGrid))
        return result;
    // <custom-ident>
    return consumeCustomIdent(range);
}

static RefPtr<CSSValue> consumeWebkitMaskClip(CSSParserTokenRange& range)
{
    // [ border-box | padding-box | content-box | border | content | padding | -webkit-text | text ]#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // border-box | padding-box | content-box | border | content | padding | -webkit-text | text
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueBorderBox:
            case CSSValueID::CSSValuePaddingBox:
            case CSSValueID::CSSValueContentBox:
            case CSSValueID::CSSValueBorder:
            case CSSValueID::CSSValueContent:
            case CSSValueID::CSSValuePadding:
            case CSSValueID::CSSValueWebkitText:
            case CSSValueID::CSSValueText:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                return nullptr;
            }
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm);
    };
    return consumeUnboundedRepetition(range);
}

static RefPtr<CSSValue> consumeWebkitMaskComposite(CSSParserTokenRange& range)
{
    // [ clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor | plus-darker | plus-lighter ]#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor | plus-darker | plus-lighter
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueClear:
            case CSSValueID::CSSValueCopy:
            case CSSValueID::CSSValueSourceOver:
            case CSSValueID::CSSValueSourceIn:
            case CSSValueID::CSSValueSourceOut:
            case CSSValueID::CSSValueSourceAtop:
            case CSSValueID::CSSValueDestinationOver:
            case CSSValueID::CSSValueDestinationIn:
            case CSSValueID::CSSValueDestinationOut:
            case CSSValueID::CSSValueDestinationAtop:
            case CSSValueID::CSSValueXor:
            case CSSValueID::CSSValuePlusDarker:
            case CSSValueID::CSSValuePlusLighter:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                return nullptr;
            }
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm);
    };
    return consumeUnboundedRepetition(range);
}

static RefPtr<CSSValue> consumeWebkitMaskPositionX(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <position-x>#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <position-x>
            return consumePositionX(range, state);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeWebkitMaskPositionY(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <position-y>#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <position-y>
            return consumePositionY(range, state);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeWebkitMaskSourceType(CSSParserTokenRange& range)
{
    // [ auto | alpha | luminance ]#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // auto | alpha | luminance
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueAuto:
            case CSSValueID::CSSValueAlpha:
            case CSSValueID::CSSValueLuminance:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                return nullptr;
            }
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm);
    };
    return consumeUnboundedRepetition(range);
}

static RefPtr<CSSValue> consumeWebkitRubyPosition(CSSParserTokenRange& range)
{
    // after | before
    if (auto result = consumeIdent(range, isKeywordValidForWebkitRubyPosition))
        return result;
    // inter-character@(aliased-to=legacy-inter-character)
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueInterCharacter:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(CSSValueID::CSSValueLegacyInterCharacter);
    default:
        return nullptr;
    }
}

static RefPtr<CSSValue> consumeWebkitTextDecorationsInEffect(CSSParserTokenRange& range)
{
    // none
    if (auto result = consumeIdent(range, isKeywordValidForWebkitTextDecorationsInEffect))
        return result;
    // [ underline || overline || line-through || blink ]@(no-single-item-opt)
    auto consumeMatchOneOrMoreAnyOrder = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        RefPtr<CSSValue> value0; // underline
        auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // underline
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueUnderline:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value0)
                return false;
            value0 = consumeTerm0(range);
            return !!value0;
        };
        RefPtr<CSSValue> value1; // overline
        auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // overline
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueOverline:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value1)
                return false;
            value1 = consumeTerm1(range);
            return !!value1;
        };
        RefPtr<CSSValue> value2; // line-through
        auto tryConsumeTerm2 = [&value2](CSSParserTokenRange& range) -> bool {
            auto consumeTerm2 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // line-through
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueLineThrough:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value2)
                return false;
            value2 = consumeTerm2(range);
            return !!value2;
        };
        RefPtr<CSSValue> value3; // blink
        auto tryConsumeTerm3 = [&value3](CSSParserTokenRange& range) -> bool {
            auto consumeTerm3 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // blink
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueBlink:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value3)
                return false;
            value3 = consumeTerm3(range);
            return !!value3;
        };
        for (size_t i = 0; i < 4 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range) || tryConsumeTerm1(range) || tryConsumeTerm2(range) || tryConsumeTerm3(range))
                continue;
            break;
        }
        CSSValueListBuilder list;
        if (value0) // underline
            list.append(value0.releaseNonNull());
        if (value1) // overline
            list.append(value1.releaseNonNull());
        if (value2) // line-through
            list.append(value2.releaseNonNull());
        if (value3) // blink
            list.append(value3.releaseNonNull());
        if (list.isEmpty())
            return { };
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchOneOrMoreAnyOrder(range);
}

static RefPtr<CSSValue> consumeWebkitTextStrokeWidth(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // medium | thick | thin
    if (auto result = consumeIdent(range, isKeywordValidForWebkitTextStrokeWidth))
        return result;
    // <length [0,inf]>
    return CSSPrimitiveValueResolver<CSS::Length<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeWordSpacing(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // normal
    if (auto result = consumeIdent(range, isKeywordValidForWordSpacing))
        return result;
    // <length-percentage>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeBorderBottomLeftRadius(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <length-percentage [0,inf]>{1,2}@(type=CSSValuePair default=previous)
    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <length-percentage [0,inf]>
            return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
        };
        CSSParserTokenRange rangeCopy = range;
        auto term0 = consumeRepeatedTerm(rangeCopy, state);
        if (!term0)
            return { };
        auto term1 = consumeRepeatedTerm(rangeCopy, state);
        if (!term1) {
            term1 = term0;
            range = rangeCopy;
            return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull());
        }
        range = rangeCopy;
        return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull());
    };
    return consumeBoundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeBorderBottomRightRadius(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <length-percentage [0,inf]>{1,2}@(type=CSSValuePair default=previous)
    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <length-percentage [0,inf]>
            return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
        };
        CSSParserTokenRange rangeCopy = range;
        auto term0 = consumeRepeatedTerm(rangeCopy, state);
        if (!term0)
            return { };
        auto term1 = consumeRepeatedTerm(rangeCopy, state);
        if (!term1) {
            term1 = term0;
            range = rangeCopy;
            return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull());
        }
        range = rangeCopy;
        return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull());
    };
    return consumeBoundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeBorderBottomWidth(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // medium | thick | thin
    if (auto result = consumeIdent(range, isKeywordValidForBorderBottomWidth))
        return result;
    // <length [0,inf]>
    return CSSPrimitiveValueResolver<CSS::Length<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeBorderLeftWidth(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // medium | thick | thin
    if (auto result = consumeIdent(range, isKeywordValidForBorderLeftWidth))
        return result;
    // <length [0,inf]>
    return CSSPrimitiveValueResolver<CSS::Length<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeBorderRightWidth(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // medium | thick | thin
    if (auto result = consumeIdent(range, isKeywordValidForBorderRightWidth))
        return result;
    // <length [0,inf]>
    return CSSPrimitiveValueResolver<CSS::Length<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeBorderTopLeftRadius(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <length-percentage [0,inf]>{1,2}@(type=CSSValuePair default=previous)
    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <length-percentage [0,inf]>
            return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
        };
        CSSParserTokenRange rangeCopy = range;
        auto term0 = consumeRepeatedTerm(rangeCopy, state);
        if (!term0)
            return { };
        auto term1 = consumeRepeatedTerm(rangeCopy, state);
        if (!term1) {
            term1 = term0;
            range = rangeCopy;
            return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull());
        }
        range = rangeCopy;
        return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull());
    };
    return consumeBoundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeBorderTopRightRadius(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <length-percentage [0,inf]>{1,2}@(type=CSSValuePair default=previous)
    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <length-percentage [0,inf]>
            return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
        };
        CSSParserTokenRange rangeCopy = range;
        auto term0 = consumeRepeatedTerm(rangeCopy, state);
        if (!term0)
            return { };
        auto term1 = consumeRepeatedTerm(rangeCopy, state);
        if (!term1) {
            term1 = term0;
            range = rangeCopy;
            return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull());
        }
        range = rangeCopy;
        return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull());
    };
    return consumeBoundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeBorderTopWidth(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // medium | thick | thin
    if (auto result = consumeIdent(range, isKeywordValidForBorderTopWidth))
        return result;
    // <length [0,inf]>
    return CSSPrimitiveValueResolver<CSS::Length<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeBottom(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForBottom))
        return result;
    // <length-percentage anchor=['allowed'] anchor-size=['allowed']>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Allow, .anchorSizePolicy = AnchorSizePolicy::Allow, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeCornerBottomLeftShape(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // bevel | notch | round | scoop | squircle | straight
    if (auto result = consumeIdent(range, isKeywordValidForCornerBottomLeftShape))
        return result;
    // superellipse([ <number [0,inf]> | infinity ])
    auto consumeSuperellipseFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
            auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                // infinity
                switch (auto keyword = args.peek().id(); keyword) {
                case CSSValueID::CSSValueInfinity:
                    args.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    break;
                }
                // <number [0,inf]>
                return CSSPrimitiveValueResolver<CSS::Number<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(args, state);
            };
            auto parameter = consumeParameter(args, state);
            if (!parameter)
                return { };
            return CSSValueListBuilder { parameter.releaseNonNull() };
        };
        if (range.peek().functionId() != CSSValueID::CSSValueSuperellipse)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, state);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueSuperellipse, WTFMove(*result));
    };
    return consumeSuperellipseFunction(range, state);
}

static RefPtr<CSSValue> consumeCornerBottomRightShape(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // bevel | notch | round | scoop | squircle | straight
    if (auto result = consumeIdent(range, isKeywordValidForCornerBottomRightShape))
        return result;
    // superellipse([ <number [0,inf]> | infinity ])
    auto consumeSuperellipseFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
            auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                // infinity
                switch (auto keyword = args.peek().id(); keyword) {
                case CSSValueID::CSSValueInfinity:
                    args.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    break;
                }
                // <number [0,inf]>
                return CSSPrimitiveValueResolver<CSS::Number<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(args, state);
            };
            auto parameter = consumeParameter(args, state);
            if (!parameter)
                return { };
            return CSSValueListBuilder { parameter.releaseNonNull() };
        };
        if (range.peek().functionId() != CSSValueID::CSSValueSuperellipse)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, state);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueSuperellipse, WTFMove(*result));
    };
    return consumeSuperellipseFunction(range, state);
}

static RefPtr<CSSValue> consumeCornerTopLeftShape(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // bevel | notch | round | scoop | squircle | straight
    if (auto result = consumeIdent(range, isKeywordValidForCornerTopLeftShape))
        return result;
    // superellipse([ <number [0,inf]> | infinity ])
    auto consumeSuperellipseFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
            auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                // infinity
                switch (auto keyword = args.peek().id(); keyword) {
                case CSSValueID::CSSValueInfinity:
                    args.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    break;
                }
                // <number [0,inf]>
                return CSSPrimitiveValueResolver<CSS::Number<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(args, state);
            };
            auto parameter = consumeParameter(args, state);
            if (!parameter)
                return { };
            return CSSValueListBuilder { parameter.releaseNonNull() };
        };
        if (range.peek().functionId() != CSSValueID::CSSValueSuperellipse)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, state);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueSuperellipse, WTFMove(*result));
    };
    return consumeSuperellipseFunction(range, state);
}

static RefPtr<CSSValue> consumeCornerTopRightShape(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // bevel | notch | round | scoop | squircle | straight
    if (auto result = consumeIdent(range, isKeywordValidForCornerTopRightShape))
        return result;
    // superellipse([ <number [0,inf]> | infinity ])
    auto consumeSuperellipseFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
            auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                // infinity
                switch (auto keyword = args.peek().id(); keyword) {
                case CSSValueID::CSSValueInfinity:
                    args.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    break;
                }
                // <number [0,inf]>
                return CSSPrimitiveValueResolver<CSS::Number<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(args, state);
            };
            auto parameter = consumeParameter(args, state);
            if (!parameter)
                return { };
            return CSSValueListBuilder { parameter.releaseNonNull() };
        };
        if (range.peek().functionId() != CSSValueID::CSSValueSuperellipse)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, state);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueSuperellipse, WTFMove(*result));
    };
    return consumeSuperellipseFunction(range, state);
}

static RefPtr<CSSValue> consumeHeight(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto | fit-content | intrinsic | max-content | min-content | min-intrinsic | -webkit-fill-available | -webkit-fit-content | -webkit-max-content | -webkit-min-content
    if (auto result = consumeIdent(range, isKeywordValidForHeight))
        return result;
    // <length-percentage [0,inf] anchor-size=['allowed']>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Allow, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeLeft(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForLeft))
        return result;
    // <length-percentage anchor=['allowed'] anchor-size=['allowed']>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Allow, .anchorSizePolicy = AnchorSizePolicy::Allow, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeMarginBottom(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForMarginBottom))
        return result;
    // <length-percentage anchor-size=['allowed']>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Allow, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeMarginLeft(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForMarginLeft))
        return result;
    // <length-percentage anchor-size=['allowed']>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Allow, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeMarginRight(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForMarginRight))
        return result;
    // <length-percentage anchor-size=['allowed']>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Allow, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeMarginTop(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForMarginTop))
        return result;
    // <length-percentage anchor-size=['allowed']>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Allow, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeMaxHeight(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // fit-content | intrinsic | max-content | min-content | min-intrinsic | none | -webkit-fill-available | -webkit-fit-content | -webkit-max-content | -webkit-min-content
    if (auto result = consumeIdent(range, isKeywordValidForMaxHeight))
        return result;
    // <length-percentage [0,inf] anchor-size=['allowed']>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Allow, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeMaxWidth(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // fit-content | intrinsic | max-content | min-content | min-intrinsic | none | -webkit-fill-available | -webkit-fit-content | -webkit-max-content | -webkit-min-content
    if (auto result = consumeIdent(range, isKeywordValidForMaxWidth))
        return result;
    // <length-percentage [0,inf] anchor-size=['allowed']>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Allow, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeMinHeight(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto | fit-content | intrinsic | max-content | min-content | min-intrinsic | -webkit-fill-available | -webkit-fit-content | -webkit-max-content | -webkit-min-content
    if (auto result = consumeIdent(range, isKeywordValidForMinHeight))
        return result;
    // <length-percentage [0,inf] anchor-size=['allowed']>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Allow, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeMinWidth(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto | fit-content | intrinsic | max-content | min-content | min-intrinsic | -webkit-fill-available | -webkit-fit-content | -webkit-max-content | -webkit-min-content
    if (auto result = consumeIdent(range, isKeywordValidForMinWidth))
        return result;
    // <length-percentage [0,inf] anchor-size=['allowed']>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Allow, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeRight(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForRight))
        return result;
    // <length-percentage anchor=['allowed'] anchor-size=['allowed']>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Allow, .anchorSizePolicy = AnchorSizePolicy::Allow, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeScrollPaddingBottom(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForScrollPaddingBottom))
        return result;
    // <length-percentage [0,inf]>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeScrollPaddingLeft(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForScrollPaddingLeft))
        return result;
    // <length-percentage [0,inf]>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeScrollPaddingRight(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForScrollPaddingRight))
        return result;
    // <length-percentage [0,inf]>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeScrollPaddingTop(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForScrollPaddingTop))
        return result;
    // <length-percentage [0,inf]>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeTop(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForTop))
        return result;
    // <length-percentage anchor=['allowed'] anchor-size=['allowed']>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Allow, .anchorSizePolicy = AnchorSizePolicy::Allow, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeWidth(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto | fit-content | intrinsic | max-content | min-content | min-intrinsic | -webkit-fill-available | -webkit-fit-content | -webkit-max-content | -webkit-min-content
    if (auto result = consumeIdent(range, isKeywordValidForWidth))
        return result;
    // <length-percentage [0,inf] anchor-size=['allowed']>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Allow, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeBlockSize(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto | fit-content | intrinsic | max-content | min-content | min-intrinsic | -webkit-fill-available | -webkit-fit-content | -webkit-max-content | -webkit-min-content
    if (auto result = consumeIdent(range, isKeywordValidForBlockSize))
        return result;
    // <length-percentage [0,inf] anchor-size=['allowed']>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Allow, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeBorderBlockEndWidth(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // medium | thick | thin
    if (auto result = consumeIdent(range, isKeywordValidForBorderBlockEndWidth))
        return result;
    // <length [0,inf]>
    return CSSPrimitiveValueResolver<CSS::Length<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeBorderBlockStartWidth(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // medium | thick | thin
    if (auto result = consumeIdent(range, isKeywordValidForBorderBlockStartWidth))
        return result;
    // <length [0,inf]>
    return CSSPrimitiveValueResolver<CSS::Length<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeBorderEndEndRadius(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <length-percentage [0,inf]>{1,2}@(type=CSSValuePair default=previous)
    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <length-percentage [0,inf]>
            return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
        };
        CSSParserTokenRange rangeCopy = range;
        auto term0 = consumeRepeatedTerm(rangeCopy, state);
        if (!term0)
            return { };
        auto term1 = consumeRepeatedTerm(rangeCopy, state);
        if (!term1) {
            term1 = term0;
            range = rangeCopy;
            return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull());
        }
        range = rangeCopy;
        return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull());
    };
    return consumeBoundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeBorderEndStartRadius(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <length-percentage [0,inf]>{1,2}@(type=CSSValuePair default=previous)
    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <length-percentage [0,inf]>
            return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
        };
        CSSParserTokenRange rangeCopy = range;
        auto term0 = consumeRepeatedTerm(rangeCopy, state);
        if (!term0)
            return { };
        auto term1 = consumeRepeatedTerm(rangeCopy, state);
        if (!term1) {
            term1 = term0;
            range = rangeCopy;
            return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull());
        }
        range = rangeCopy;
        return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull());
    };
    return consumeBoundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeBorderInlineEndWidth(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // medium | thick | thin
    if (auto result = consumeIdent(range, isKeywordValidForBorderInlineEndWidth))
        return result;
    // <length [0,inf]>
    return CSSPrimitiveValueResolver<CSS::Length<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeBorderInlineStartWidth(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // medium | thick | thin
    if (auto result = consumeIdent(range, isKeywordValidForBorderInlineStartWidth))
        return result;
    // <length [0,inf]>
    return CSSPrimitiveValueResolver<CSS::Length<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeBorderStartEndRadius(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <length-percentage [0,inf]>{1,2}@(type=CSSValuePair default=previous)
    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <length-percentage [0,inf]>
            return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
        };
        CSSParserTokenRange rangeCopy = range;
        auto term0 = consumeRepeatedTerm(rangeCopy, state);
        if (!term0)
            return { };
        auto term1 = consumeRepeatedTerm(rangeCopy, state);
        if (!term1) {
            term1 = term0;
            range = rangeCopy;
            return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull());
        }
        range = rangeCopy;
        return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull());
    };
    return consumeBoundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeBorderStartStartRadius(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <length-percentage [0,inf]>{1,2}@(type=CSSValuePair default=previous)
    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <length-percentage [0,inf]>
            return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
        };
        CSSParserTokenRange rangeCopy = range;
        auto term0 = consumeRepeatedTerm(rangeCopy, state);
        if (!term0)
            return { };
        auto term1 = consumeRepeatedTerm(rangeCopy, state);
        if (!term1) {
            term1 = term0;
            range = rangeCopy;
            return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull());
        }
        range = rangeCopy;
        return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull());
    };
    return consumeBoundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeContainIntrinsicBlockSize(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // [ auto? [ none | <length [0,inf]> ] ]@(type=CSSValuePair)
    auto consumeMatchAllOrdered = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeTerm0 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // auto
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueAuto:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                return nullptr;
            }
        };
        auto consumeTerm1 = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // none
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueNone:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                break;
            }
            // <length [0,inf]>
            return CSSPrimitiveValueResolver<CSS::Length<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow });
        };
        CSSValueListBuilder list;
        // auto?
        auto value0 = consumeTerm0(range);
        if (value0)
            list.append(value0.releaseNonNull());
        // [ none | <length [0,inf]> ]
        auto value1 = consumeTerm1(range, state);
        if (value1)
            list.append(value1.releaseNonNull());
        else
            return { };
        if (list.size() == 1)
            return WTFMove(list[0]); // single item optimization
        return CSSValuePair::create(WTFMove(list[0]), WTFMove(list[1]));
    };
    return consumeMatchAllOrdered(range, state);
}

static RefPtr<CSSValue> consumeContainIntrinsicInlineSize(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // [ auto? [ none | <length [0,inf]> ] ]@(type=CSSValuePair)
    auto consumeMatchAllOrdered = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeTerm0 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // auto
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueAuto:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                return nullptr;
            }
        };
        auto consumeTerm1 = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // none
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueNone:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                break;
            }
            // <length [0,inf]>
            return CSSPrimitiveValueResolver<CSS::Length<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow });
        };
        CSSValueListBuilder list;
        // auto?
        auto value0 = consumeTerm0(range);
        if (value0)
            list.append(value0.releaseNonNull());
        // [ none | <length [0,inf]> ]
        auto value1 = consumeTerm1(range, state);
        if (value1)
            list.append(value1.releaseNonNull());
        else
            return { };
        if (list.size() == 1)
            return WTFMove(list[0]); // single item optimization
        return CSSValuePair::create(WTFMove(list[0]), WTFMove(list[1]));
    };
    return consumeMatchAllOrdered(range, state);
}

static RefPtr<CSSValue> consumeCornerEndEndShape(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // bevel | notch | round | scoop | squircle | straight
    if (auto result = consumeIdent(range, isKeywordValidForCornerEndEndShape))
        return result;
    // superellipse([ <number [0,inf]> | infinity ])
    auto consumeSuperellipseFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
            auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                // infinity
                switch (auto keyword = args.peek().id(); keyword) {
                case CSSValueID::CSSValueInfinity:
                    args.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    break;
                }
                // <number [0,inf]>
                return CSSPrimitiveValueResolver<CSS::Number<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(args, state);
            };
            auto parameter = consumeParameter(args, state);
            if (!parameter)
                return { };
            return CSSValueListBuilder { parameter.releaseNonNull() };
        };
        if (range.peek().functionId() != CSSValueID::CSSValueSuperellipse)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, state);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueSuperellipse, WTFMove(*result));
    };
    return consumeSuperellipseFunction(range, state);
}

static RefPtr<CSSValue> consumeCornerEndStartShape(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // bevel | notch | round | scoop | squircle | straight
    if (auto result = consumeIdent(range, isKeywordValidForCornerEndStartShape))
        return result;
    // superellipse([ <number [0,inf]> | infinity ])
    auto consumeSuperellipseFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
            auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                // infinity
                switch (auto keyword = args.peek().id(); keyword) {
                case CSSValueID::CSSValueInfinity:
                    args.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    break;
                }
                // <number [0,inf]>
                return CSSPrimitiveValueResolver<CSS::Number<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(args, state);
            };
            auto parameter = consumeParameter(args, state);
            if (!parameter)
                return { };
            return CSSValueListBuilder { parameter.releaseNonNull() };
        };
        if (range.peek().functionId() != CSSValueID::CSSValueSuperellipse)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, state);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueSuperellipse, WTFMove(*result));
    };
    return consumeSuperellipseFunction(range, state);
}

static RefPtr<CSSValue> consumeCornerStartStartShape(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // bevel | notch | round | scoop | squircle | straight
    if (auto result = consumeIdent(range, isKeywordValidForCornerStartStartShape))
        return result;
    // superellipse([ <number [0,inf]> | infinity ])
    auto consumeSuperellipseFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
            auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                // infinity
                switch (auto keyword = args.peek().id(); keyword) {
                case CSSValueID::CSSValueInfinity:
                    args.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    break;
                }
                // <number [0,inf]>
                return CSSPrimitiveValueResolver<CSS::Number<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(args, state);
            };
            auto parameter = consumeParameter(args, state);
            if (!parameter)
                return { };
            return CSSValueListBuilder { parameter.releaseNonNull() };
        };
        if (range.peek().functionId() != CSSValueID::CSSValueSuperellipse)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, state);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueSuperellipse, WTFMove(*result));
    };
    return consumeSuperellipseFunction(range, state);
}

static RefPtr<CSSValue> consumeInlineSize(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto | fit-content | intrinsic | max-content | min-content | min-intrinsic | -webkit-fill-available | -webkit-fit-content | -webkit-max-content | -webkit-min-content
    if (auto result = consumeIdent(range, isKeywordValidForInlineSize))
        return result;
    // <length-percentage [0,inf] anchor-size=['allowed']>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Allow, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeInsetBlockEnd(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForInsetBlockEnd))
        return result;
    // <length-percentage anchor=['allowed'] anchor-size=['allowed']>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Allow, .anchorSizePolicy = AnchorSizePolicy::Allow, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeInsetBlockStart(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForInsetBlockStart))
        return result;
    // <length-percentage anchor=['allowed'] anchor-size=['allowed']>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Allow, .anchorSizePolicy = AnchorSizePolicy::Allow, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeInsetInlineEnd(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForInsetInlineEnd))
        return result;
    // <length-percentage anchor=['allowed'] anchor-size=['allowed']>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Allow, .anchorSizePolicy = AnchorSizePolicy::Allow, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeInsetInlineStart(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForInsetInlineStart))
        return result;
    // <length-percentage anchor=['allowed'] anchor-size=['allowed']>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Allow, .anchorSizePolicy = AnchorSizePolicy::Allow, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeMarginBlockEnd(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForMarginBlockEnd))
        return result;
    // <length-percentage anchor-size=['allowed']>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Allow, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeMarginBlockStart(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForMarginBlockStart))
        return result;
    // <length-percentage anchor-size=['allowed']>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Allow, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeMarginInlineEnd(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForMarginInlineEnd))
        return result;
    // <length-percentage anchor-size=['allowed']>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Allow, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeMarginInlineStart(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForMarginInlineStart))
        return result;
    // <length-percentage anchor-size=['allowed']>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Allow, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeMaxBlockSize(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // fit-content | intrinsic | max-content | min-content | min-intrinsic | none | -webkit-fill-available | -webkit-fit-content | -webkit-max-content | -webkit-min-content
    if (auto result = consumeIdent(range, isKeywordValidForMaxBlockSize))
        return result;
    // <length-percentage [0,inf] anchor-size=['allowed']>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Allow, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeMaxInlineSize(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // fit-content | intrinsic | max-content | min-content | min-intrinsic | none | -webkit-fill-available | -webkit-fit-content | -webkit-max-content | -webkit-min-content
    if (auto result = consumeIdent(range, isKeywordValidForMaxInlineSize))
        return result;
    // <length-percentage [0,inf] anchor-size=['allowed']>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Allow, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeMinBlockSize(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto | fit-content | intrinsic | max-content | min-content | min-intrinsic | -webkit-fill-available | -webkit-fit-content | -webkit-max-content | -webkit-min-content
    if (auto result = consumeIdent(range, isKeywordValidForMinBlockSize))
        return result;
    // <length-percentage [0,inf] anchor-size=['allowed']>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Allow, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeMinInlineSize(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto | fit-content | intrinsic | max-content | min-content | min-intrinsic | -webkit-fill-available | -webkit-fit-content | -webkit-max-content | -webkit-min-content
    if (auto result = consumeIdent(range, isKeywordValidForMinInlineSize))
        return result;
    // <length-percentage [0,inf] anchor-size=['allowed']>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Allow, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeScrollPaddingBlockEnd(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForScrollPaddingBlockEnd))
        return result;
    // <length-percentage [0,inf]>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeScrollPaddingBlockStart(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForScrollPaddingBlockStart))
        return result;
    // <length-percentage [0,inf]>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeScrollPaddingInlineEnd(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForScrollPaddingInlineEnd))
        return result;
    // <length-percentage [0,inf]>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeScrollPaddingInlineStart(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForScrollPaddingInlineStart))
        return result;
    // <length-percentage [0,inf]>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

static RefPtr<CSSValue> consumeCounterStyleNegative(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // [ [ <string> | <image allowed-types=['url', 'generated']>@(settings-flag=counterStyleAtRuleImageSymbolsEnabled) | <custom-ident> ] [ <string> | <image allowed-types=['url', 'generated']>@(settings-flag=counterStyleAtRuleImageSymbolsEnabled) | <custom-ident> ]? ]
    auto consumeMatchAllOrdered = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeTerm0 = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <string>
            if (auto result = consumeString(range))
                return result;
            // <image allowed-types=['url', 'generated']>@(settings-flag=counterStyleAtRuleImageSymbolsEnabled)
            auto consumeImageReference = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                if (!state.context.counterStyleAtRuleImageSymbolsEnabled)
                    return { };
                return consumeImage(range, state, { AllowedImageType::URLFunction, AllowedImageType::GeneratedImage });
            };
            if (auto result = consumeImageReference(range, state))
                return result;
            // <custom-ident>
            return consumeCustomIdent(range);
        };
        auto consumeTerm1 = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <string>
            if (auto result = consumeString(range))
                return result;
            // <image allowed-types=['url', 'generated']>@(settings-flag=counterStyleAtRuleImageSymbolsEnabled)
            auto consumeImageReference = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                if (!state.context.counterStyleAtRuleImageSymbolsEnabled)
                    return { };
                return consumeImage(range, state, { AllowedImageType::URLFunction, AllowedImageType::GeneratedImage });
            };
            if (auto result = consumeImageReference(range, state))
                return result;
            // <custom-ident>
            return consumeCustomIdent(range);
        };
        CSSValueListBuilder list;
        // [ <string> | <image allowed-types=['url', 'generated']>@(settings-flag=counterStyleAtRuleImageSymbolsEnabled) | <custom-ident> ]
        auto value0 = consumeTerm0(range, state);
        if (value0)
            list.append(value0.releaseNonNull());
        else
            return { };
        // [ <string> | <image allowed-types=['url', 'generated']>@(settings-flag=counterStyleAtRuleImageSymbolsEnabled) | <custom-ident> ]?
        auto value1 = consumeTerm1(range, state);
        if (value1)
            list.append(value1.releaseNonNull());
        if (list.size() == 1)
            return WTFMove(list[0]); // single item optimization
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchAllOrdered(range, state);
}

static RefPtr<CSSValue> consumeCounterStylePad(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // [ <integer [0,inf]> && [ <string> | <image allowed-types=['url', 'generated']>@(settings-flag=counterStyleAtRuleImageSymbolsEnabled) | <custom-ident> ] ]
    auto consumeMatchAllAnyOrder = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        RefPtr<CSSValue> value0; // <integer [0,inf]>
        auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                // <integer [0,inf]>
                return CSSPrimitiveValueResolver<CSS::Integer<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state);
            };
            if (value0)
                return false;
            value0 = consumeTerm0(range, state);
            return !!value0;
        };
        RefPtr<CSSValue> value1; // [ <string> | <image allowed-types=['url', 'generated']>@(settings-flag=counterStyleAtRuleImageSymbolsEnabled) | <custom-ident> ]
        auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                // <string>
                if (auto result = consumeString(range))
                    return result;
                // <image allowed-types=['url', 'generated']>@(settings-flag=counterStyleAtRuleImageSymbolsEnabled)
                auto consumeImageReference = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                    if (!state.context.counterStyleAtRuleImageSymbolsEnabled)
                        return { };
                    return consumeImage(range, state, { AllowedImageType::URLFunction, AllowedImageType::GeneratedImage });
                };
                if (auto result = consumeImageReference(range, state))
                    return result;
                // <custom-ident>
                return consumeCustomIdent(range);
            };
            if (value1)
                return false;
            value1 = consumeTerm1(range, state);
            return !!value1;
        };
        for (size_t i = 0; i < 2 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range, state) || tryConsumeTerm1(range, state))
                continue;
            break;
        }
        if (!value0) // <integer [0,inf]>
            return { };
        if (!value1) // [ <string> | <image allowed-types=['url', 'generated']>@(settings-flag=counterStyleAtRuleImageSymbolsEnabled) | <custom-ident> ]
            return { };
        return CSSValueList::createSpaceSeparated(value0.releaseNonNull(), value1.releaseNonNull());
    };
    return consumeMatchAllAnyOrder(range, state);
}

static RefPtr<CSSValue> consumeCounterStylePrefix(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <string>
    if (auto result = consumeString(range))
        return result;
    // <image allowed-types=['url', 'generated']>@(settings-flag=counterStyleAtRuleImageSymbolsEnabled)
    auto consumeImageReference = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        if (!state.context.counterStyleAtRuleImageSymbolsEnabled)
            return { };
        return consumeImage(range, state, { AllowedImageType::URLFunction, AllowedImageType::GeneratedImage });
    };
    if (auto result = consumeImageReference(range, state))
        return result;
    // <custom-ident>
    return consumeCustomIdent(range);
}

static RefPtr<CSSValue> consumeCounterStyleSpeakAs(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto | bullets | numbers | spell-out | words
    if (auto result = consumeIdent(range, isKeywordValidForCounterStyleSpeakAs))
        return result;
    // <counter-style-name-override-function>
    return consumeCounterStyleName(range, state);
}

static RefPtr<CSSValue> consumeCounterStyleSuffix(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <string>
    if (auto result = consumeString(range))
        return result;
    // <image allowed-types=['url', 'generated']>@(settings-flag=counterStyleAtRuleImageSymbolsEnabled)
    auto consumeImageReference = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        if (!state.context.counterStyleAtRuleImageSymbolsEnabled)
            return { };
        return consumeImage(range, state, { AllowedImageType::URLFunction, AllowedImageType::GeneratedImage });
    };
    if (auto result = consumeImageReference(range, state))
        return result;
    // <custom-ident>
    return consumeCustomIdent(range);
}

static RefPtr<CSSValue> consumeCounterStyleSymbols(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // [ <string> | <image allowed-types=['url', 'generated']>@(settings-flag=counterStyleAtRuleImageSymbolsEnabled) | <custom-ident> ]+@(no-single-item-opt)
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <string>
            if (auto result = consumeString(range))
                return result;
            // <image allowed-types=['url', 'generated']>@(settings-flag=counterStyleAtRuleImageSymbolsEnabled)
            auto consumeImageReference = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                if (!state.context.counterStyleAtRuleImageSymbolsEnabled)
                    return { };
                return consumeImage(range, state, { AllowedImageType::URLFunction, AllowedImageType::GeneratedImage });
            };
            if (auto result = consumeImageReference(range, state))
                return result;
            // <custom-ident>
            return consumeCustomIdent(range);
        };
        return consumeListSeparatedBy<' ', ListBounds::minimumOf(1), ListOptimization::None, CSSValueList>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeFontPaletteValuesBasePalette(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // dark | light
    if (auto result = consumeIdent(range, isKeywordValidForFontPaletteValuesBasePalette))
        return result;
    // <integer [0,inf]>
    return CSSPrimitiveValueResolver<CSS::Integer<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state);
}

static RefPtr<CSSValue> consumeFontPaletteValuesFontFamily(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <family-name>#@(no-single-item-opt)
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <family-name>
            return consumeFamilyName(range, state);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::None, CSSValueList>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

static RefPtr<CSSValue> consumeFontPaletteValuesOverrideColors(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // [ <integer [0,inf]> <color allowed-types=['absolute']> ]@(type=CSSValuePair)#@(no-single-item-opt)
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // [ <integer [0,inf]> <color allowed-types=['absolute']> ]@(type=CSSValuePair)
            auto consumeMatchAllOrdered = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeTerm0 = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                    // <integer [0,inf]>
                    return CSSPrimitiveValueResolver<CSS::Integer<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state);
                };
                auto consumeTerm1 = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                    // <color allowed-types=['absolute']>
                    return consumeColor(range, state, { .allowedColorTypes = { CSS::ColorType::Absolute } });
                };
                // <integer [0,inf]>
                auto value0 = consumeTerm0(range, state);
                if (!value0)
                    return { };
                // <color allowed-types=['absolute']>
                auto value1 = consumeTerm1(range, state);
                if (!value1)
                    return { };
                return CSSValuePair::create(value0.releaseNonNull(), value1.releaseNonNull());
            };
            return consumeMatchAllOrdered(range, state);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::None, CSSValueList>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

static RefPtr<CSSValue> consumePageSize(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForPageSize))
        return result;
    // <length [0,inf]>{1,2}@(type=CSSValuePair)
    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <length [0,inf]>
            return CSSPrimitiveValueResolver<CSS::Length<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow });
        };
        CSSParserTokenRange rangeCopy = range;
        auto term0 = consumeRepeatedTerm(rangeCopy, state);
        if (!term0)
            return { };
        auto term1 = consumeRepeatedTerm(rangeCopy, state);
        if (!term1) {
            range = rangeCopy;
            return term0.releaseNonNull(); // single item optimization
        }
        range = rangeCopy;
        return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull());
    };
    if (auto result = consumeBoundedRepetition(range, state))
        return result;
    // [ [ A5 | A4 | A3 | B5 | B4 | jis-B5 | jis-B4 | letter | legal | ledger ] || [ portrait | landscape ] ]@(type=CSSValuePair)
    auto consumeMatchOneOrMoreAnyOrder = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        RefPtr<CSSValue> value0; // [ A5 | A4 | A3 | B5 | B4 | jis-B5 | jis-B4 | letter | legal | ledger ]
        auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // A5 | A4 | A3 | B5 | B4 | jis-B5 | jis-B4 | letter | legal | ledger
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueA5:
                case CSSValueID::CSSValueA4:
                case CSSValueID::CSSValueA3:
                case CSSValueID::CSSValueB5:
                case CSSValueID::CSSValueB4:
                case CSSValueID::CSSValueJisB5:
                case CSSValueID::CSSValueJisB4:
                case CSSValueID::CSSValueLetter:
                case CSSValueID::CSSValueLegal:
                case CSSValueID::CSSValueLedger:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value0)
                return false;
            value0 = consumeTerm0(range);
            return !!value0;
        };
        RefPtr<CSSValue> value1; // [ portrait | landscape ]
        auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // portrait | landscape
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValuePortrait:
                case CSSValueID::CSSValueLandscape:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value1)
                return false;
            value1 = consumeTerm1(range);
            return !!value1;
        };
        for (size_t i = 0; i < 2 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range) || tryConsumeTerm1(range))
                continue;
            break;
        }
        CSSValueListBuilder list;
        if (value0) // [ A5 | A4 | A3 | B5 | B4 | jis-B5 | jis-B4 | letter | legal | ledger ]
            list.append(value0.releaseNonNull());
        if (value1) // [ portrait | landscape ]
            list.append(value1.releaseNonNull());
        if (list.isEmpty())
            return { };
        if (list.size() == 1)
            return WTFMove(list[0]); // single item optimization
        return CSSValuePair::create(WTFMove(list[0]), WTFMove(list[1]));
    };
    return consumeMatchOneOrMoreAnyOrder(range);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeFontFeatureSettings(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // normal
    if (auto result = consumeIdent(range, isKeywordValidForFontFeatureSettings))
        return result;
    // <feature-tag-value>#@(no-single-item-opt)
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <feature-tag-value>
            return consumeFeatureTagValue(range, state);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::None, CSSValueList>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeFontSize(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // large | larger | medium | small | smaller | x-large | x-small | xx-large | xx-small | xxx-large | -webkit-ruby-text
    if (auto result = consumeIdent(range, isKeywordValidForFontSize))
        return result;
    // -webkit-xxx-large@(aliased-to=xxx-large)
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueWebkitXxxLarge:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(CSSValueID::CSSValueXxxLarge);
    default:
        break;
    }
    // <length-percentage [0,inf]>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

RefPtr<CSSValue> CSSPropertyParsing::consumeFontVariantAlternates(CSSParserTokenRange& range)
{
    // normal
    if (auto result = consumeIdent(range, isKeywordValidForFontVariantAlternates))
        return result;
    // [ stylistic(<custom-ident>) || historical-forms || styleset(<custom-ident>#) || character-variant(<custom-ident>#) || swash(<custom-ident>) || ornaments(<custom-ident>) || annotation(<custom-ident>) ]@(no-single-item-opt)
    auto consumeMatchOneOrMoreAnyOrder = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        RefPtr<CSSValue> value0; // stylistic(<custom-ident>)
        auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // stylistic(<custom-ident>)
                auto consumeStylisticFunction = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                    auto consumeParameters = [](CSSParserTokenRange& args) -> std::optional<CSSValueListBuilder> {
                        auto consumeParameter = [](CSSParserTokenRange& args) -> RefPtr<CSSValue> {
                            // <custom-ident>
                            return consumeCustomIdent(args);
                        };
                        auto parameter = consumeParameter(args);
                        if (!parameter)
                            return { };
                        return CSSValueListBuilder { parameter.releaseNonNull() };
                    };
                    if (range.peek().functionId() != CSSValueID::CSSValueStylistic)
                        return { };
                    CSSParserTokenRange rangeCopy = range;
                    CSSParserTokenRange args = consumeFunction(rangeCopy);
                    auto result = consumeParameters(args);
                    if (!result)
                        return { };
                    if (!args.atEnd())
                        return { };
                    range = rangeCopy;
                    return CSSFunctionValue::create(CSSValueID::CSSValueStylistic, WTFMove(*result));
                };
                return consumeStylisticFunction(range);
            };
            if (value0)
                return false;
            value0 = consumeTerm0(range);
            return !!value0;
        };
        RefPtr<CSSValue> value1; // historical-forms
        auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // historical-forms
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueHistoricalForms:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value1)
                return false;
            value1 = consumeTerm1(range);
            return !!value1;
        };
        RefPtr<CSSValue> value2; // styleset(<custom-ident>#)
        auto tryConsumeTerm2 = [&value2](CSSParserTokenRange& range) -> bool {
            auto consumeTerm2 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // styleset(<custom-ident>#)
                auto consumeStylesetFunction = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                    auto consumeParameters = [](CSSParserTokenRange& args) -> std::optional<CSSValueListBuilder> {
                        // <custom-ident>#
                        auto consumeUnboundedRepetition = [](CSSParserTokenRange& range) -> std::optional<CSSValueListBuilder> {
                            auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                                // <custom-ident>
                                return consumeCustomIdent(range);
                            };
                            return consumeListSeparatedByIntoBuilder<',', ListBounds::minimumOf(1)>(range, consumeRepeatedTerm);
                        };
                        return consumeUnboundedRepetition(args);
                    };
                    if (range.peek().functionId() != CSSValueID::CSSValueStyleset)
                        return { };
                    CSSParserTokenRange rangeCopy = range;
                    CSSParserTokenRange args = consumeFunction(rangeCopy);
                    auto result = consumeParameters(args);
                    if (!result)
                        return { };
                    if (!args.atEnd())
                        return { };
                    range = rangeCopy;
                    return CSSFunctionValue::create(CSSValueID::CSSValueStyleset, WTFMove(*result));
                };
                return consumeStylesetFunction(range);
            };
            if (value2)
                return false;
            value2 = consumeTerm2(range);
            return !!value2;
        };
        RefPtr<CSSValue> value3; // character-variant(<custom-ident>#)
        auto tryConsumeTerm3 = [&value3](CSSParserTokenRange& range) -> bool {
            auto consumeTerm3 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // character-variant(<custom-ident>#)
                auto consumeCharacterVariantFunction = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                    auto consumeParameters = [](CSSParserTokenRange& args) -> std::optional<CSSValueListBuilder> {
                        // <custom-ident>#
                        auto consumeUnboundedRepetition = [](CSSParserTokenRange& range) -> std::optional<CSSValueListBuilder> {
                            auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                                // <custom-ident>
                                return consumeCustomIdent(range);
                            };
                            return consumeListSeparatedByIntoBuilder<',', ListBounds::minimumOf(1)>(range, consumeRepeatedTerm);
                        };
                        return consumeUnboundedRepetition(args);
                    };
                    if (range.peek().functionId() != CSSValueID::CSSValueCharacterVariant)
                        return { };
                    CSSParserTokenRange rangeCopy = range;
                    CSSParserTokenRange args = consumeFunction(rangeCopy);
                    auto result = consumeParameters(args);
                    if (!result)
                        return { };
                    if (!args.atEnd())
                        return { };
                    range = rangeCopy;
                    return CSSFunctionValue::create(CSSValueID::CSSValueCharacterVariant, WTFMove(*result));
                };
                return consumeCharacterVariantFunction(range);
            };
            if (value3)
                return false;
            value3 = consumeTerm3(range);
            return !!value3;
        };
        RefPtr<CSSValue> value4; // swash(<custom-ident>)
        auto tryConsumeTerm4 = [&value4](CSSParserTokenRange& range) -> bool {
            auto consumeTerm4 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // swash(<custom-ident>)
                auto consumeSwashFunction = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                    auto consumeParameters = [](CSSParserTokenRange& args) -> std::optional<CSSValueListBuilder> {
                        auto consumeParameter = [](CSSParserTokenRange& args) -> RefPtr<CSSValue> {
                            // <custom-ident>
                            return consumeCustomIdent(args);
                        };
                        auto parameter = consumeParameter(args);
                        if (!parameter)
                            return { };
                        return CSSValueListBuilder { parameter.releaseNonNull() };
                    };
                    if (range.peek().functionId() != CSSValueID::CSSValueSwash)
                        return { };
                    CSSParserTokenRange rangeCopy = range;
                    CSSParserTokenRange args = consumeFunction(rangeCopy);
                    auto result = consumeParameters(args);
                    if (!result)
                        return { };
                    if (!args.atEnd())
                        return { };
                    range = rangeCopy;
                    return CSSFunctionValue::create(CSSValueID::CSSValueSwash, WTFMove(*result));
                };
                return consumeSwashFunction(range);
            };
            if (value4)
                return false;
            value4 = consumeTerm4(range);
            return !!value4;
        };
        RefPtr<CSSValue> value5; // ornaments(<custom-ident>)
        auto tryConsumeTerm5 = [&value5](CSSParserTokenRange& range) -> bool {
            auto consumeTerm5 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // ornaments(<custom-ident>)
                auto consumeOrnamentsFunction = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                    auto consumeParameters = [](CSSParserTokenRange& args) -> std::optional<CSSValueListBuilder> {
                        auto consumeParameter = [](CSSParserTokenRange& args) -> RefPtr<CSSValue> {
                            // <custom-ident>
                            return consumeCustomIdent(args);
                        };
                        auto parameter = consumeParameter(args);
                        if (!parameter)
                            return { };
                        return CSSValueListBuilder { parameter.releaseNonNull() };
                    };
                    if (range.peek().functionId() != CSSValueID::CSSValueOrnaments)
                        return { };
                    CSSParserTokenRange rangeCopy = range;
                    CSSParserTokenRange args = consumeFunction(rangeCopy);
                    auto result = consumeParameters(args);
                    if (!result)
                        return { };
                    if (!args.atEnd())
                        return { };
                    range = rangeCopy;
                    return CSSFunctionValue::create(CSSValueID::CSSValueOrnaments, WTFMove(*result));
                };
                return consumeOrnamentsFunction(range);
            };
            if (value5)
                return false;
            value5 = consumeTerm5(range);
            return !!value5;
        };
        RefPtr<CSSValue> value6; // annotation(<custom-ident>)
        auto tryConsumeTerm6 = [&value6](CSSParserTokenRange& range) -> bool {
            auto consumeTerm6 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // annotation(<custom-ident>)
                auto consumeAnnotationFunction = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                    auto consumeParameters = [](CSSParserTokenRange& args) -> std::optional<CSSValueListBuilder> {
                        auto consumeParameter = [](CSSParserTokenRange& args) -> RefPtr<CSSValue> {
                            // <custom-ident>
                            return consumeCustomIdent(args);
                        };
                        auto parameter = consumeParameter(args);
                        if (!parameter)
                            return { };
                        return CSSValueListBuilder { parameter.releaseNonNull() };
                    };
                    if (range.peek().functionId() != CSSValueID::CSSValueAnnotation)
                        return { };
                    CSSParserTokenRange rangeCopy = range;
                    CSSParserTokenRange args = consumeFunction(rangeCopy);
                    auto result = consumeParameters(args);
                    if (!result)
                        return { };
                    if (!args.atEnd())
                        return { };
                    range = rangeCopy;
                    return CSSFunctionValue::create(CSSValueID::CSSValueAnnotation, WTFMove(*result));
                };
                return consumeAnnotationFunction(range);
            };
            if (value6)
                return false;
            value6 = consumeTerm6(range);
            return !!value6;
        };
        for (size_t i = 0; i < 7 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range) || tryConsumeTerm1(range) || tryConsumeTerm2(range) || tryConsumeTerm3(range) || tryConsumeTerm4(range) || tryConsumeTerm5(range) || tryConsumeTerm6(range))
                continue;
            break;
        }
        CSSValueListBuilder list;
        if (value0) // stylistic(<custom-ident>)
            list.append(value0.releaseNonNull());
        if (value1) // historical-forms
            list.append(value1.releaseNonNull());
        if (value2) // styleset(<custom-ident>#)
            list.append(value2.releaseNonNull());
        if (value3) // character-variant(<custom-ident>#)
            list.append(value3.releaseNonNull());
        if (value4) // swash(<custom-ident>)
            list.append(value4.releaseNonNull());
        if (value5) // ornaments(<custom-ident>)
            list.append(value5.releaseNonNull());
        if (value6) // annotation(<custom-ident>)
            list.append(value6.releaseNonNull());
        if (list.isEmpty())
            return { };
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchOneOrMoreAnyOrder(range);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeFontVariantCaps(CSSParserTokenRange& range)
{
    return consumeIdent(range, isKeywordValidForFontVariantCaps);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeFontVariantEastAsian(CSSParserTokenRange& range)
{
    // normal
    if (auto result = consumeIdent(range, isKeywordValidForFontVariantEastAsian))
        return result;
    // [ [ jis78 | jis83 | jis90 | jis04 | simplified | traditional ] || [ full-width | proportional-width ] || ruby ]@(no-single-item-opt)
    auto consumeMatchOneOrMoreAnyOrder = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        RefPtr<CSSValue> value0; // [ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]
        auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // jis78 | jis83 | jis90 | jis04 | simplified | traditional
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueJis78:
                case CSSValueID::CSSValueJis83:
                case CSSValueID::CSSValueJis90:
                case CSSValueID::CSSValueJis04:
                case CSSValueID::CSSValueSimplified:
                case CSSValueID::CSSValueTraditional:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value0)
                return false;
            value0 = consumeTerm0(range);
            return !!value0;
        };
        RefPtr<CSSValue> value1; // [ full-width | proportional-width ]
        auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // full-width | proportional-width
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueFullWidth:
                case CSSValueID::CSSValueProportionalWidth:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value1)
                return false;
            value1 = consumeTerm1(range);
            return !!value1;
        };
        RefPtr<CSSValue> value2; // ruby
        auto tryConsumeTerm2 = [&value2](CSSParserTokenRange& range) -> bool {
            auto consumeTerm2 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // ruby
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueRuby:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value2)
                return false;
            value2 = consumeTerm2(range);
            return !!value2;
        };
        for (size_t i = 0; i < 3 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range) || tryConsumeTerm1(range) || tryConsumeTerm2(range))
                continue;
            break;
        }
        CSSValueListBuilder list;
        if (value0) // [ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]
            list.append(value0.releaseNonNull());
        if (value1) // [ full-width | proportional-width ]
            list.append(value1.releaseNonNull());
        if (value2) // ruby
            list.append(value2.releaseNonNull());
        if (list.isEmpty())
            return { };
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchOneOrMoreAnyOrder(range);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeFontVariantEmoji(CSSParserTokenRange& range)
{
    return consumeIdent(range, isKeywordValidForFontVariantEmoji);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeFontVariantPosition(CSSParserTokenRange& range)
{
    return consumeIdent(range, isKeywordValidForFontVariantPosition);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeFontWeight(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // bold | bolder | lighter | normal
    if (auto result = consumeIdent(range, isKeywordValidForFontWeight))
        return result;
    // <number [1,1000]>
    return CSSPrimitiveValueResolver<CSS::Number<CSS::Range{1, 1000}>>::consumeAndResolve(range, state);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeBlockEllipsis(CSSParserTokenRange& range)
{
    // auto | none
    if (auto result = consumeIdent(range, isKeywordValidForBlockEllipsis))
        return result;
    // <string>
    return consumeString(range);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeBlockStepAlign(CSSParserTokenRange& range)
{
    return consumeIdent(range, isKeywordValidForBlockStepAlign);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeBlockStepInsert(CSSParserTokenRange& range)
{
    return consumeIdent(range, isKeywordValidForBlockStepInsert);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeBlockStepRound(CSSParserTokenRange& range)
{
    return consumeIdent(range, isKeywordValidForBlockStepRound);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeBlockStepSize(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // none
    if (auto result = consumeIdent(range, isKeywordValidForBlockStepSize))
        return result;
    // <length [0,inf]>
    return CSSPrimitiveValueResolver<CSS::Length<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

RefPtr<CSSValue> CSSPropertyParsing::consumeBorderImageOutset(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // [ <number [0,inf]> | <length [0,inf]> ]{1,4}@(type=CSSQuadValue no-single-item-opt)
    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <number [0,inf]>
            if (auto result = CSSPrimitiveValueResolver<CSS::Number<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state))
                return result;
            // <length [0,inf]>
            return CSSPrimitiveValueResolver<CSS::Length<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow });
        };
        CSSParserTokenRange rangeCopy = range;
        auto term0 = consumeRepeatedTerm(rangeCopy, state);
        if (!term0)
            return { };
        auto term1 = consumeRepeatedTerm(rangeCopy, state);
        if (!term1) {
            range = rangeCopy;
            return CSSQuadValue::create(term0.releaseNonNull());
        }
        auto term2 = consumeRepeatedTerm(rangeCopy, state);
        if (!term2) {
            range = rangeCopy;
            return CSSQuadValue::create(term0.releaseNonNull(), term1.releaseNonNull());
        }
        auto term3 = consumeRepeatedTerm(rangeCopy, state);
        if (!term3) {
            range = rangeCopy;
            return CSSQuadValue::create(term0.releaseNonNull(), term1.releaseNonNull(), term2.releaseNonNull());
        }
        range = rangeCopy;
        return CSSQuadValue::create(term0.releaseNonNull(), term1.releaseNonNull(), term2.releaseNonNull(), term3.releaseNonNull());
    };
    return consumeBoundedRepetition(range, state);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeBorderImageRepeat(CSSParserTokenRange& range)
{
    // [ stretch | repeat | round | space ]{1,2}@(type=CSSValuePair default=previous)
    auto consumeBoundedRepetition = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // stretch | repeat | round | space
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueStretch:
            case CSSValueID::CSSValueRepeat:
            case CSSValueID::CSSValueRound:
            case CSSValueID::CSSValueSpace:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                return nullptr;
            }
        };
        CSSParserTokenRange rangeCopy = range;
        auto term0 = consumeRepeatedTerm(rangeCopy);
        if (!term0)
            return { };
        auto term1 = consumeRepeatedTerm(rangeCopy);
        if (!term1) {
            term1 = term0;
            range = rangeCopy;
            return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull());
        }
        range = rangeCopy;
        return CSSValuePair::create(term0.releaseNonNull(), term1.releaseNonNull());
    };
    return consumeBoundedRepetition(range);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeColumnCount(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForColumnCount))
        return result;
    // <integer [1,inf]>
    return CSSPrimitiveValueResolver<CSS::Integer<CSS::Range{1, CSS::Range::infinity}>>::consumeAndResolve(range, state);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeColumnGap(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // normal
    if (auto result = consumeIdent(range, isKeywordValidForColumnGap))
        return result;
    // <length-percentage [0,inf]>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

RefPtr<CSSValue> CSSPropertyParsing::consumeColumnWidth(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    if (auto result = consumeIdent(range, isKeywordValidForColumnWidth))
        return result;
    // <length [0,inf]>
    return CSSPrimitiveValueResolver<CSS::Length<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

RefPtr<CSSValue> CSSPropertyParsing::consumeContinue(CSSParserTokenRange& range)
{
    return consumeIdent(range, isKeywordValidForContinue);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeLineHeight(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // normal
    if (auto result = consumeIdent(range, isKeywordValidForLineHeight))
        return result;
    // <number [0,inf]>
    if (auto result = CSSPrimitiveValueResolver<CSS::Number<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state))
        return result;
    // <length-percentage [0,inf]>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

RefPtr<CSSValue> CSSPropertyParsing::consumeListStyleType(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // none
    if (auto result = consumeIdent(range, isKeywordValidForListStyleType))
        return result;
    // <counter-style-override-function>
    if (auto result = consumeCounterStyle(range, state))
        return result;
    // <string>
    return consumeString(range);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeMaxLines(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // none
    if (auto result = consumeIdent(range, isKeywordValidForMaxLines))
        return result;
    // <integer [1,inf]>
    return CSSPrimitiveValueResolver<CSS::Integer<CSS::Range{1, CSS::Range::infinity}>>::consumeAndResolve(range, state);
}

RefPtr<CSSValue> CSSPropertyParsing::consumePerspective(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // none
    if (auto result = consumeIdent(range, isKeywordValidForPerspective))
        return result;
    // <length [0,inf]>
    return CSSPrimitiveValueResolver<CSS::Length<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

RefPtr<CSSValue> CSSPropertyParsing::consumeRowGap(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // normal
    if (auto result = consumeIdent(range, isKeywordValidForRowGap))
        return result;
    // <length-percentage [0,inf]>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

RefPtr<CSSValue> CSSPropertyParsing::consumeScrollTimelineAxis(CSSParserTokenRange& range)
{
    // [ block | inline | x | y ]#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // block | inline | x | y
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueBlock:
            case CSSValueID::CSSValueInline:
            case CSSValueID::CSSValueX:
            case CSSValueID::CSSValueY:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                return nullptr;
            }
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm);
    };
    return consumeUnboundedRepetition(range);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeScrollTimelineName(CSSParserTokenRange& range)
{
    // [ none | <dashed-ident> ]#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // none
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueNone:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                break;
            }
            // <dashed-ident>
            return consumeDashedIdent(range);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm);
    };
    return consumeUnboundedRepetition(range);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeTextBoxTrim(CSSParserTokenRange& range)
{
    return consumeIdent(range, isKeywordValidForTextBoxTrim);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeTextDecorationLine(CSSParserTokenRange& range)
{
    // none
    if (auto result = consumeIdent(range, isKeywordValidForTextDecorationLine))
        return result;
    // [ underline || overline || line-through || blink ]@(no-single-item-opt)
    auto consumeMatchOneOrMoreAnyOrder = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        RefPtr<CSSValue> value0; // underline
        auto tryConsumeTerm0 = [&value0](CSSParserTokenRange& range) -> bool {
            auto consumeTerm0 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // underline
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueUnderline:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value0)
                return false;
            value0 = consumeTerm0(range);
            return !!value0;
        };
        RefPtr<CSSValue> value1; // overline
        auto tryConsumeTerm1 = [&value1](CSSParserTokenRange& range) -> bool {
            auto consumeTerm1 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // overline
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueOverline:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value1)
                return false;
            value1 = consumeTerm1(range);
            return !!value1;
        };
        RefPtr<CSSValue> value2; // line-through
        auto tryConsumeTerm2 = [&value2](CSSParserTokenRange& range) -> bool {
            auto consumeTerm2 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // line-through
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueLineThrough:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value2)
                return false;
            value2 = consumeTerm2(range);
            return !!value2;
        };
        RefPtr<CSSValue> value3; // blink
        auto tryConsumeTerm3 = [&value3](CSSParserTokenRange& range) -> bool {
            auto consumeTerm3 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
                // blink
                switch (auto keyword = range.peek().id(); keyword) {
                case CSSValueID::CSSValueBlink:
                    range.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    return nullptr;
                }
            };
            if (value3)
                return false;
            value3 = consumeTerm3(range);
            return !!value3;
        };
        for (size_t i = 0; i < 4 && !range.atEnd(); ++i) {
            if (tryConsumeTerm0(range) || tryConsumeTerm1(range) || tryConsumeTerm2(range) || tryConsumeTerm3(range))
                continue;
            break;
        }
        CSSValueListBuilder list;
        if (value0) // underline
            list.append(value0.releaseNonNull());
        if (value1) // overline
            list.append(value1.releaseNonNull());
        if (value2) // line-through
            list.append(value2.releaseNonNull());
        if (value3) // blink
            list.append(value3.releaseNonNull());
        if (list.isEmpty())
            return { };
        return CSSValueList::createSpaceSeparated(WTFMove(list));
    };
    return consumeMatchOneOrMoreAnyOrder(range);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeTextWrapMode(CSSParserTokenRange& range)
{
    return consumeIdent(range, isKeywordValidForTextWrapMode);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeTextWrapStyle(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    return consumeIdent(range, isKeywordValidForTextWrapStyle, state);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeTransform(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // none
    if (auto result = consumeIdent(range, isKeywordValidForTransform))
        return result;
    // [ matrix(<number>#{6}) | <translate()-override-function> | translateX(<length-percentage>) | translateY(<length-percentage>) | scale(<number-or-percentage-resolved-to-number>#{1,2}) | scaleX(<number-or-percentage-resolved-to-number>) | scaleY(<number-or-percentage-resolved-to-number>) | rotate(<angle unitless-zero=['allowed']>) | skew(<angle unitless-zero=['allowed']>#{1,2}) | skewX(<angle unitless-zero=['allowed']>) | skewY(<angle unitless-zero=['allowed']>) | matrix3d(<number>#{16}) | <translate3d()-override-function> | translateZ(<length>) | scale3d(<number-or-percentage-resolved-to-number>#{3}) | scaleZ(<number-or-percentage-resolved-to-number>) | <rotate3d()-override-function> | rotateX(<angle unitless-zero=['allowed']>) | rotateY(<angle unitless-zero=['allowed']>) | rotateZ(<angle unitless-zero=['allowed']>) | perspective([ <length [0,inf]> | <number [0,inf]> | none ]) ]+@(type=CSSTransformListValue no-single-item-opt)
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <translate()-override-function>
            if (auto result = consumeTranslateFunction(range, state))
                return result;
            // <translate3d()-override-function>
            if (auto result = consumeTranslate3dFunction(range, state))
                return result;
            // <rotate3d()-override-function>
            if (auto result = consumeRotate3dFunction(range, state))
                return result;
            // matrix(<number>#{6})
            auto consumeMatrixFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    // <number>#{6}
                    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                            // <number>
                            return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, state);
                        };
                        return consumeListSeparatedByIntoBuilder<',', ListBounds { 6, 6 }>(range, consumeRepeatedTerm, state);
                    };
                    return consumeBoundedRepetition(args, state);
                };
                if (range.peek().functionId() != CSSValueID::CSSValueMatrix)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueMatrix, WTFMove(*result));
            };
            if (auto result = consumeMatrixFunction(range, state))
                return result;
            // translateX(<length-percentage>)
            auto consumeTranslateXFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                        // <length-percentage>
                        return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(args, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
                    };
                    auto parameter = consumeParameter(args, state);
                    if (!parameter)
                        return { };
                    return CSSValueListBuilder { parameter.releaseNonNull() };
                };
                if (range.peek().functionId() != CSSValueID::CSSValueTranslateX)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueTranslateX, WTFMove(*result));
            };
            if (auto result = consumeTranslateXFunction(range, state))
                return result;
            // translateY(<length-percentage>)
            auto consumeTranslateYFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                        // <length-percentage>
                        return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(args, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
                    };
                    auto parameter = consumeParameter(args, state);
                    if (!parameter)
                        return { };
                    return CSSValueListBuilder { parameter.releaseNonNull() };
                };
                if (range.peek().functionId() != CSSValueID::CSSValueTranslateY)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueTranslateY, WTFMove(*result));
            };
            if (auto result = consumeTranslateYFunction(range, state))
                return result;
            // scale(<number-or-percentage-resolved-to-number>#{1,2})
            auto consumeScaleFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    // <number-or-percentage-resolved-to-number>#{1,2}
                    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                            // <number-or-percentage-resolved-to-number>
                            return consumePercentageDividedBy100OrNumber(range, state);
                        };
                        return consumeListSeparatedByIntoBuilder<',', ListBounds { 1, 2 }>(range, consumeRepeatedTerm, state);
                    };
                    return consumeBoundedRepetition(args, state);
                };
                if (range.peek().functionId() != CSSValueID::CSSValueScale)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueScale, WTFMove(*result));
            };
            if (auto result = consumeScaleFunction(range, state))
                return result;
            // scaleX(<number-or-percentage-resolved-to-number>)
            auto consumeScaleXFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                        // <number-or-percentage-resolved-to-number>
                        return consumePercentageDividedBy100OrNumber(args, state);
                    };
                    auto parameter = consumeParameter(args, state);
                    if (!parameter)
                        return { };
                    return CSSValueListBuilder { parameter.releaseNonNull() };
                };
                if (range.peek().functionId() != CSSValueID::CSSValueScaleX)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueScaleX, WTFMove(*result));
            };
            if (auto result = consumeScaleXFunction(range, state))
                return result;
            // scaleY(<number-or-percentage-resolved-to-number>)
            auto consumeScaleYFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                        // <number-or-percentage-resolved-to-number>
                        return consumePercentageDividedBy100OrNumber(args, state);
                    };
                    auto parameter = consumeParameter(args, state);
                    if (!parameter)
                        return { };
                    return CSSValueListBuilder { parameter.releaseNonNull() };
                };
                if (range.peek().functionId() != CSSValueID::CSSValueScaleY)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueScaleY, WTFMove(*result));
            };
            if (auto result = consumeScaleYFunction(range, state))
                return result;
            // rotate(<angle unitless-zero=['allowed']>)
            auto consumeRotateFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                        // <angle unitless-zero=['allowed']>
                        return CSSPrimitiveValueResolver<CSS::Angle<>>::consumeAndResolve(args, state, { .unitlessZeroAngle = UnitlessZeroQuirk::Allow });
                    };
                    auto parameter = consumeParameter(args, state);
                    if (!parameter)
                        return { };
                    return CSSValueListBuilder { parameter.releaseNonNull() };
                };
                if (range.peek().functionId() != CSSValueID::CSSValueRotate)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueRotate, WTFMove(*result));
            };
            if (auto result = consumeRotateFunction(range, state))
                return result;
            // skew(<angle unitless-zero=['allowed']>#{1,2})
            auto consumeSkewFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    // <angle unitless-zero=['allowed']>#{1,2}
                    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                            // <angle unitless-zero=['allowed']>
                            return CSSPrimitiveValueResolver<CSS::Angle<>>::consumeAndResolve(range, state, { .unitlessZeroAngle = UnitlessZeroQuirk::Allow });
                        };
                        return consumeListSeparatedByIntoBuilder<',', ListBounds { 1, 2 }>(range, consumeRepeatedTerm, state);
                    };
                    return consumeBoundedRepetition(args, state);
                };
                if (range.peek().functionId() != CSSValueID::CSSValueSkew)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueSkew, WTFMove(*result));
            };
            if (auto result = consumeSkewFunction(range, state))
                return result;
            // skewX(<angle unitless-zero=['allowed']>)
            auto consumeSkewXFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                        // <angle unitless-zero=['allowed']>
                        return CSSPrimitiveValueResolver<CSS::Angle<>>::consumeAndResolve(args, state, { .unitlessZeroAngle = UnitlessZeroQuirk::Allow });
                    };
                    auto parameter = consumeParameter(args, state);
                    if (!parameter)
                        return { };
                    return CSSValueListBuilder { parameter.releaseNonNull() };
                };
                if (range.peek().functionId() != CSSValueID::CSSValueSkewX)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueSkewX, WTFMove(*result));
            };
            if (auto result = consumeSkewXFunction(range, state))
                return result;
            // skewY(<angle unitless-zero=['allowed']>)
            auto consumeSkewYFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                        // <angle unitless-zero=['allowed']>
                        return CSSPrimitiveValueResolver<CSS::Angle<>>::consumeAndResolve(args, state, { .unitlessZeroAngle = UnitlessZeroQuirk::Allow });
                    };
                    auto parameter = consumeParameter(args, state);
                    if (!parameter)
                        return { };
                    return CSSValueListBuilder { parameter.releaseNonNull() };
                };
                if (range.peek().functionId() != CSSValueID::CSSValueSkewY)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueSkewY, WTFMove(*result));
            };
            if (auto result = consumeSkewYFunction(range, state))
                return result;
            // matrix3d(<number>#{16})
            auto consumeMatrix3dFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    // <number>#{16}
                    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                            // <number>
                            return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, state);
                        };
                        return consumeListSeparatedByIntoBuilder<',', ListBounds { 16, 16 }>(range, consumeRepeatedTerm, state);
                    };
                    return consumeBoundedRepetition(args, state);
                };
                if (range.peek().functionId() != CSSValueID::CSSValueMatrix3d)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueMatrix3d, WTFMove(*result));
            };
            if (auto result = consumeMatrix3dFunction(range, state))
                return result;
            // translateZ(<length>)
            auto consumeTranslateZFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                        // <length>
                        return CSSPrimitiveValueResolver<CSS::Length<>>::consumeAndResolve(args, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow });
                    };
                    auto parameter = consumeParameter(args, state);
                    if (!parameter)
                        return { };
                    return CSSValueListBuilder { parameter.releaseNonNull() };
                };
                if (range.peek().functionId() != CSSValueID::CSSValueTranslateZ)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueTranslateZ, WTFMove(*result));
            };
            if (auto result = consumeTranslateZFunction(range, state))
                return result;
            // scale3d(<number-or-percentage-resolved-to-number>#{3})
            auto consumeScale3dFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    // <number-or-percentage-resolved-to-number>#{3}
                    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                            // <number-or-percentage-resolved-to-number>
                            return consumePercentageDividedBy100OrNumber(range, state);
                        };
                        return consumeListSeparatedByIntoBuilder<',', ListBounds { 3, 3 }>(range, consumeRepeatedTerm, state);
                    };
                    return consumeBoundedRepetition(args, state);
                };
                if (range.peek().functionId() != CSSValueID::CSSValueScale3d)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueScale3d, WTFMove(*result));
            };
            if (auto result = consumeScale3dFunction(range, state))
                return result;
            // scaleZ(<number-or-percentage-resolved-to-number>)
            auto consumeScaleZFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                        // <number-or-percentage-resolved-to-number>
                        return consumePercentageDividedBy100OrNumber(args, state);
                    };
                    auto parameter = consumeParameter(args, state);
                    if (!parameter)
                        return { };
                    return CSSValueListBuilder { parameter.releaseNonNull() };
                };
                if (range.peek().functionId() != CSSValueID::CSSValueScaleZ)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueScaleZ, WTFMove(*result));
            };
            if (auto result = consumeScaleZFunction(range, state))
                return result;
            // rotateX(<angle unitless-zero=['allowed']>)
            auto consumeRotateXFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                        // <angle unitless-zero=['allowed']>
                        return CSSPrimitiveValueResolver<CSS::Angle<>>::consumeAndResolve(args, state, { .unitlessZeroAngle = UnitlessZeroQuirk::Allow });
                    };
                    auto parameter = consumeParameter(args, state);
                    if (!parameter)
                        return { };
                    return CSSValueListBuilder { parameter.releaseNonNull() };
                };
                if (range.peek().functionId() != CSSValueID::CSSValueRotateX)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueRotateX, WTFMove(*result));
            };
            if (auto result = consumeRotateXFunction(range, state))
                return result;
            // rotateY(<angle unitless-zero=['allowed']>)
            auto consumeRotateYFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                        // <angle unitless-zero=['allowed']>
                        return CSSPrimitiveValueResolver<CSS::Angle<>>::consumeAndResolve(args, state, { .unitlessZeroAngle = UnitlessZeroQuirk::Allow });
                    };
                    auto parameter = consumeParameter(args, state);
                    if (!parameter)
                        return { };
                    return CSSValueListBuilder { parameter.releaseNonNull() };
                };
                if (range.peek().functionId() != CSSValueID::CSSValueRotateY)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueRotateY, WTFMove(*result));
            };
            if (auto result = consumeRotateYFunction(range, state))
                return result;
            // rotateZ(<angle unitless-zero=['allowed']>)
            auto consumeRotateZFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                        // <angle unitless-zero=['allowed']>
                        return CSSPrimitiveValueResolver<CSS::Angle<>>::consumeAndResolve(args, state, { .unitlessZeroAngle = UnitlessZeroQuirk::Allow });
                    };
                    auto parameter = consumeParameter(args, state);
                    if (!parameter)
                        return { };
                    return CSSValueListBuilder { parameter.releaseNonNull() };
                };
                if (range.peek().functionId() != CSSValueID::CSSValueRotateZ)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueRotateZ, WTFMove(*result));
            };
            if (auto result = consumeRotateZFunction(range, state))
                return result;
            // perspective([ <length [0,inf]> | <number [0,inf]> | none ])
            auto consumePerspectiveFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                        // none
                        switch (auto keyword = args.peek().id(); keyword) {
                        case CSSValueID::CSSValueNone:
                            args.consumeIncludingWhitespace();
                            return CSSPrimitiveValue::create(keyword);
                        default:
                            break;
                        }
                        // <length [0,inf]>
                        if (auto result = CSSPrimitiveValueResolver<CSS::Length<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(args, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow }))
                            return result;
                        // <number [0,inf]>
                        return CSSPrimitiveValueResolver<CSS::Number<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(args, state);
                    };
                    auto parameter = consumeParameter(args, state);
                    if (!parameter)
                        return { };
                    return CSSValueListBuilder { parameter.releaseNonNull() };
                };
                if (range.peek().functionId() != CSSValueID::CSSValuePerspective)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValuePerspective, WTFMove(*result));
            };
            return consumePerspectiveFunction(range, state);
        };
        return consumeListSeparatedBy<' ', ListBounds::minimumOf(1), ListOptimization::None, CSSTransformListValue>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeViewTimelineAxis(CSSParserTokenRange& range)
{
    // [ block | inline | x | y ]#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // block | inline | x | y
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueBlock:
            case CSSValueID::CSSValueInline:
            case CSSValueID::CSSValueX:
            case CSSValueID::CSSValueY:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                return nullptr;
            }
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm);
    };
    return consumeUnboundedRepetition(range);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeViewTimelineName(CSSParserTokenRange& range)
{
    // [ none | <dashed-ident> ]#
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // none
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueNone:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                break;
            }
            // <dashed-ident>
            return consumeDashedIdent(range);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::SingleValue, CSSValueList>(range, consumeRepeatedTerm);
    };
    return consumeUnboundedRepetition(range);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeWhiteSpaceCollapse(CSSParserTokenRange& range)
{
    return consumeIdent(range, isKeywordValidForWhiteSpaceCollapse);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeContainIntrinsicHeight(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // [ auto? [ none | <length [0,inf]> ] ]@(type=CSSValuePair)
    auto consumeMatchAllOrdered = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeTerm0 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // auto
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueAuto:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                return nullptr;
            }
        };
        auto consumeTerm1 = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // none
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueNone:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                break;
            }
            // <length [0,inf]>
            return CSSPrimitiveValueResolver<CSS::Length<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow });
        };
        CSSValueListBuilder list;
        // auto?
        auto value0 = consumeTerm0(range);
        if (value0)
            list.append(value0.releaseNonNull());
        // [ none | <length [0,inf]> ]
        auto value1 = consumeTerm1(range, state);
        if (value1)
            list.append(value1.releaseNonNull());
        else
            return { };
        if (list.size() == 1)
            return WTFMove(list[0]); // single item optimization
        return CSSValuePair::create(WTFMove(list[0]), WTFMove(list[1]));
    };
    return consumeMatchAllOrdered(range, state);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeContainIntrinsicWidth(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // [ auto? [ none | <length [0,inf]> ] ]@(type=CSSValuePair)
    auto consumeMatchAllOrdered = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeTerm0 = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // auto
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueAuto:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                return nullptr;
            }
        };
        auto consumeTerm1 = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // none
            switch (auto keyword = range.peek().id(); keyword) {
            case CSSValueID::CSSValueNone:
                range.consumeIncludingWhitespace();
                return CSSPrimitiveValue::create(keyword);
            default:
                break;
            }
            // <length [0,inf]>
            return CSSPrimitiveValueResolver<CSS::Length<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow });
        };
        CSSValueListBuilder list;
        // auto?
        auto value0 = consumeTerm0(range);
        if (value0)
            list.append(value0.releaseNonNull());
        // [ none | <length [0,inf]> ]
        auto value1 = consumeTerm1(range, state);
        if (value1)
            list.append(value1.releaseNonNull());
        else
            return { };
        if (list.size() == 1)
            return WTFMove(list[0]); // single item optimization
        return CSSValuePair::create(WTFMove(list[0]), WTFMove(list[1]));
    };
    return consumeMatchAllOrdered(range, state);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeOverscrollBehaviorX(CSSParserTokenRange& range)
{
    return consumeIdent(range, isKeywordValidForOverscrollBehaviorX);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeOverscrollBehaviorY(CSSParserTokenRange& range)
{
    return consumeIdent(range, isKeywordValidForOverscrollBehaviorY);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeCornerStartEndShape(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // bevel | notch | round | scoop | squircle | straight
    if (auto result = consumeIdent(range, isKeywordValidForCornerStartEndShape))
        return result;
    // superellipse([ <number [0,inf]> | infinity ])
    auto consumeSuperellipseFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
            auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                // infinity
                switch (auto keyword = args.peek().id(); keyword) {
                case CSSValueID::CSSValueInfinity:
                    args.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    break;
                }
                // <number [0,inf]>
                return CSSPrimitiveValueResolver<CSS::Number<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(args, state);
            };
            auto parameter = consumeParameter(args, state);
            if (!parameter)
                return { };
            return CSSValueListBuilder { parameter.releaseNonNull() };
        };
        if (range.peek().functionId() != CSSValueID::CSSValueSuperellipse)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, state);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueSuperellipse, WTFMove(*result));
    };
    return consumeSuperellipseFunction(range, state);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeFontFaceFontDisplay(CSSParserTokenRange& range)
{
    return consumeIdent(range, isKeywordValidForFontFaceFontDisplay);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeFontFaceFontFamily(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <family-name>
    return consumeFamilyName(range, state);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeFontFaceFontFeatureSettings(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // normal
    if (auto result = consumeIdent(range, isKeywordValidForFontFaceFontFeatureSettings))
        return result;
    // <feature-tag-value>#@(no-single-item-opt)
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <feature-tag-value>
            return consumeFeatureTagValue(range, state);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::None, CSSValueList>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeFontFaceFontWeight(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // bold | normal
    if (auto result = consumeIdent(range, isKeywordValidForFontFaceFontWeight))
        return result;
    // <number [1,1000]>{1,2}
    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <number [1,1000]>
            return CSSPrimitiveValueResolver<CSS::Number<CSS::Range{1, 1000}>>::consumeAndResolve(range, state);
        };
        return consumeListSeparatedBy<' ', ListBounds { 1, 2 }, ListOptimization::SingleValue>(range, consumeRepeatedTerm, state);
    };
    return consumeBoundedRepetition(range, state);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeFontFaceFontWidth(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // condensed | expanded | extra-condensed | extra-expanded | normal | semi-condensed | semi-expanded | ultra-condensed | ultra-expanded
    if (auto result = consumeIdent(range, isKeywordValidForFontFaceFontWidth))
        return result;
    // <percentage [0,inf]>{1,2}
    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <percentage [0,inf]>
            return CSSPrimitiveValueResolver<CSS::Percentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state);
        };
        return consumeListSeparatedBy<' ', ListBounds { 1, 2 }, ListOptimization::SingleValue>(range, consumeRepeatedTerm, state);
    };
    return consumeBoundedRepetition(range, state);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeFontFaceSizeAdjust(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <percentage [0,inf]>
    return CSSPrimitiveValueResolver<CSS::Percentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeFontFaceUnicodeRange(CSSParserTokenRange& range)
{
    // <unicode-range-token>#@(no-single-item-opt)
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range) -> RefPtr<CSSValue> {
            // <unicode-range-token>
            return consumeUnicodeRangeToken(range);
        };
        return consumeListSeparatedBy<',', ListBounds::minimumOf(1), ListOptimization::None, CSSValueList>(range, consumeRepeatedTerm);
    };
    return consumeUnboundedRepetition(range);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeViewTransitionNavigation(CSSParserTokenRange& range)
{
    return consumeIdent(range, isKeywordValidForViewTransitionNavigation);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeAxis(CSSParserTokenRange& range)
{
    // block | inline | x | y
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueBlock:
    case CSSValueID::CSSValueInline:
    case CSSValueID::CSSValueX:
    case CSSValueID::CSSValueY:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        return nullptr;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::consumeBlendMode(CSSParserTokenRange& range)
{
    // normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueNormal:
    case CSSValueID::CSSValueMultiply:
    case CSSValueID::CSSValueScreen:
    case CSSValueID::CSSValueOverlay:
    case CSSValueID::CSSValueDarken:
    case CSSValueID::CSSValueLighten:
    case CSSValueID::CSSValueColorDodge:
    case CSSValueID::CSSValueColorBurn:
    case CSSValueID::CSSValueHardLight:
    case CSSValueID::CSSValueSoftLight:
    case CSSValueID::CSSValueDifference:
    case CSSValueID::CSSValueExclusion:
    case CSSValueID::CSSValueHue:
    case CSSValueID::CSSValueSaturation:
    case CSSValueID::CSSValueColor:
    case CSSValueID::CSSValueLuminosity:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        return nullptr;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::consumeFontWidthAbsolute(CSSParserTokenRange& range)
{
    // normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueNormal:
    case CSSValueID::CSSValueUltraCondensed:
    case CSSValueID::CSSValueExtraCondensed:
    case CSSValueID::CSSValueCondensed:
    case CSSValueID::CSSValueSemiCondensed:
    case CSSValueID::CSSValueSemiExpanded:
    case CSSValueID::CSSValueExpanded:
    case CSSValueID::CSSValueExtraExpanded:
    case CSSValueID::CSSValueUltraExpanded:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        return nullptr;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::consumeGeometryBox(CSSParserTokenRange& range)
{
    // border-box | padding-box | content-box | margin-box | fill-box | stroke-box | view-box
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueBorderBox:
    case CSSValueID::CSSValuePaddingBox:
    case CSSValueID::CSSValueContentBox:
    case CSSValueID::CSSValueMarginBox:
    case CSSValueID::CSSValueFillBox:
    case CSSValueID::CSSValueStrokeBox:
    case CSSValueID::CSSValueViewBox:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        return nullptr;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::consumeLineWidth(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // thin | medium | thick
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueThin:
    case CSSValueID::CSSValueMedium:
    case CSSValueID::CSSValueThick:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        break;
    }
    // <length [0,inf]>
    return CSSPrimitiveValueResolver<CSS::Length<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

RefPtr<CSSValue> CSSPropertyParsing::consumeScroller(CSSParserTokenRange& range)
{
    // root | nearest | self
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueRoot:
    case CSSValueID::CSSValueNearest:
    case CSSValueID::CSSValueSelf:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        return nullptr;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::consumeShapeBox(CSSParserTokenRange& range)
{
    // border-box | padding-box | content-box | margin-box
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueBorderBox:
    case CSSValueID::CSSValuePaddingBox:
    case CSSValueID::CSSValueContentBox:
    case CSSValueID::CSSValueMarginBox:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        return nullptr;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleAnimationComposition(CSSParserTokenRange& range)
{
    // replace | add | accumulate
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueReplace:
    case CSSValueID::CSSValueAdd:
    case CSSValueID::CSSValueAccumulate:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        return nullptr;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleAnimationDirection(CSSParserTokenRange& range)
{
    // normal | reverse | alternate | alternate-reverse
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueNormal:
    case CSSValueID::CSSValueReverse:
    case CSSValueID::CSSValueAlternate:
    case CSSValueID::CSSValueAlternateReverse:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        return nullptr;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleAnimationDuration(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueAuto:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        break;
    }
    // <time [0,inf]>
    return CSSPrimitiveValueResolver<CSS::Time<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleAnimationFillMode(CSSParserTokenRange& range)
{
    // none | forwards | backwards | both
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueNone:
    case CSSValueID::CSSValueForwards:
    case CSSValueID::CSSValueBackwards:
    case CSSValueID::CSSValueBoth:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        return nullptr;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleAnimationIterationCount(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // infinite
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueInfinite:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        break;
    }
    // <number [0,inf]>
    return CSSPrimitiveValueResolver<CSS::Number<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleAnimationName(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // none
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueNone:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        break;
    }
    // <keyframes-name>
    return consumeKeyframesName(range, state);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleAnimationPlayState(CSSParserTokenRange& range)
{
    // running | paused
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueRunning:
    case CSSValueID::CSSValuePaused:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        return nullptr;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleBackgroundAttachment(CSSParserTokenRange& range)
{
    // scroll | fixed | local
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueScroll:
    case CSSValueID::CSSValueFixed:
    case CSSValueID::CSSValueLocal:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        return nullptr;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleBackgroundBlendMode(CSSParserTokenRange& range)
{
    // normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueNormal:
    case CSSValueID::CSSValueMultiply:
    case CSSValueID::CSSValueScreen:
    case CSSValueID::CSSValueOverlay:
    case CSSValueID::CSSValueDarken:
    case CSSValueID::CSSValueLighten:
    case CSSValueID::CSSValueColorDodge:
    case CSSValueID::CSSValueColorBurn:
    case CSSValueID::CSSValueHardLight:
    case CSSValueID::CSSValueSoftLight:
    case CSSValueID::CSSValueDifference:
    case CSSValueID::CSSValueExclusion:
    case CSSValueID::CSSValueHue:
    case CSSValueID::CSSValueSaturation:
    case CSSValueID::CSSValueColor:
    case CSSValueID::CSSValueLuminosity:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        return nullptr;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleBackgroundClip(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // border-box | padding-box | content-box | border-area@(settings-flag=cssBackgroundClipBorderAreaEnabled) | text | -webkit-text
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueBorderBox:
    case CSSValueID::CSSValuePaddingBox:
    case CSSValueID::CSSValueContentBox:
    case CSSValueID::CSSValueText:
    case CSSValueID::CSSValueWebkitText:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    case CSSValueID::CSSValueBorderArea:
        if (!state.context.cssBackgroundClipBorderAreaEnabled)
            return nullptr;
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        return nullptr;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleBackgroundImage(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // none
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueNone:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        break;
    }
    // <image>
    return consumeImage(range, state, { AllowedImageType::URLFunction, AllowedImageType::ImageSet, AllowedImageType::GeneratedImage });
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleBackgroundOrigin(CSSParserTokenRange& range)
{
    // border-box | padding-box | content-box
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueBorderBox:
    case CSSValueID::CSSValuePaddingBox:
    case CSSValueID::CSSValueContentBox:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        return nullptr;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleBackgroundPositionX(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <position-x>
    return consumePositionX(range, state);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleBackgroundPositionY(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <position-y>
    return consumePositionY(range, state);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleBackgroundRepeat(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <repeat-style>
    return consumeRepeatStyle(range, state);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleContainerName(CSSParserTokenRange& range)
{
    // <custom-ident excluding=['none', 'and', 'or', 'not']>
    return consumeCustomIdentExcluding(range, { CSSValueID::CSSValueNone, CSSValueID::CSSValueAnd, CSSValueID::CSSValueOr, CSSValueID::CSSValueNot });
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleMaskClip(CSSParserTokenRange& range)
{
    // border-box | padding-box | content-box | no-clip
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueBorderBox:
    case CSSValueID::CSSValuePaddingBox:
    case CSSValueID::CSSValueContentBox:
    case CSSValueID::CSSValueNoClip:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        return nullptr;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleMaskComposite(CSSParserTokenRange& range)
{
    // add | subtract | intersect | exclude
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueAdd:
    case CSSValueID::CSSValueSubtract:
    case CSSValueID::CSSValueIntersect:
    case CSSValueID::CSSValueExclude:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        return nullptr;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleMaskImage(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // none
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueNone:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        break;
    }
    // <image>
    return consumeImage(range, state, { AllowedImageType::URLFunction, AllowedImageType::ImageSet, AllowedImageType::GeneratedImage });
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleMaskMode(CSSParserTokenRange& range)
{
    // alpha | luminance | match-source
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueAlpha:
    case CSSValueID::CSSValueLuminance:
    case CSSValueID::CSSValueMatchSource:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        return nullptr;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleMaskOrigin(CSSParserTokenRange& range)
{
    // border-box | padding-box | content-box | border | content | padding | -webkit-text
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueBorderBox:
    case CSSValueID::CSSValuePaddingBox:
    case CSSValueID::CSSValueContentBox:
    case CSSValueID::CSSValueBorder:
    case CSSValueID::CSSValueContent:
    case CSSValueID::CSSValuePadding:
    case CSSValueID::CSSValueWebkitText:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        return nullptr;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleMaskRepeat(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <repeat-style>
    return consumeRepeatStyle(range, state);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleScrollTimelineName(CSSParserTokenRange& range)
{
    // none
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueNone:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        break;
    }
    // <dashed-ident>
    return consumeDashedIdent(range);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleViewTimelineInset(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueAuto:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        break;
    }
    // <length-percentage>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleWebkitBackgroundClip(CSSParserTokenRange& range)
{
    // border-box | padding-box | content-box | border | content | padding | -webkit-text | text
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueBorderBox:
    case CSSValueID::CSSValuePaddingBox:
    case CSSValueID::CSSValueContentBox:
    case CSSValueID::CSSValueBorder:
    case CSSValueID::CSSValueContent:
    case CSSValueID::CSSValuePadding:
    case CSSValueID::CSSValueWebkitText:
    case CSSValueID::CSSValueText:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        return nullptr;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleWebkitBackgroundOrigin(CSSParserTokenRange& range)
{
    // border-box | padding-box | content-box | border | content | padding | -webkit-text
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueBorderBox:
    case CSSValueID::CSSValuePaddingBox:
    case CSSValueID::CSSValueContentBox:
    case CSSValueID::CSSValueBorder:
    case CSSValueID::CSSValueContent:
    case CSSValueID::CSSValuePadding:
    case CSSValueID::CSSValueWebkitText:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        return nullptr;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleWebkitMaskClip(CSSParserTokenRange& range)
{
    // border-box | padding-box | content-box | border | content | padding | -webkit-text | text
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueBorderBox:
    case CSSValueID::CSSValuePaddingBox:
    case CSSValueID::CSSValueContentBox:
    case CSSValueID::CSSValueBorder:
    case CSSValueID::CSSValueContent:
    case CSSValueID::CSSValuePadding:
    case CSSValueID::CSSValueWebkitText:
    case CSSValueID::CSSValueText:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        return nullptr;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleWebkitMaskComposite(CSSParserTokenRange& range)
{
    // clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor | plus-darker | plus-lighter
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueClear:
    case CSSValueID::CSSValueCopy:
    case CSSValueID::CSSValueSourceOver:
    case CSSValueID::CSSValueSourceIn:
    case CSSValueID::CSSValueSourceOut:
    case CSSValueID::CSSValueSourceAtop:
    case CSSValueID::CSSValueDestinationOver:
    case CSSValueID::CSSValueDestinationIn:
    case CSSValueID::CSSValueDestinationOut:
    case CSSValueID::CSSValueDestinationAtop:
    case CSSValueID::CSSValueXor:
    case CSSValueID::CSSValuePlusDarker:
    case CSSValueID::CSSValuePlusLighter:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        return nullptr;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleWebkitMaskPositionX(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <position-x>
    return consumePositionX(range, state);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleWebkitMaskPositionY(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <position-y>
    return consumePositionY(range, state);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSingleWebkitMaskSourceType(CSSParserTokenRange& range)
{
    // auto | alpha | luminance
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueAlpha:
    case CSSValueID::CSSValueLuminance:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        return nullptr;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::consumeSymbol(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <string>
    if (auto result = consumeString(range))
        return result;
    // <image allowed-types=['url', 'generated']>@(settings-flag=counterStyleAtRuleImageSymbolsEnabled)
    auto consumeImageReference = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        if (!state.context.counterStyleAtRuleImageSymbolsEnabled)
            return { };
        return consumeImage(range, state, { AllowedImageType::URLFunction, AllowedImageType::GeneratedImage });
    };
    if (auto result = consumeImageReference(range, state))
        return result;
    // <custom-ident>
    return consumeCustomIdent(range);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeTimelineRangeName(CSSParserTokenRange& range)
{
    // cover | contain | entry | exit | entry-crossing | exit-crossing
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueCover:
    case CSSValueID::CSSValueContain:
    case CSSValueID::CSSValueEntry:
    case CSSValueID::CSSValueExit:
    case CSSValueID::CSSValueEntryCrossing:
    case CSSValueID::CSSValueExitCrossing:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        return nullptr;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::consumeTransformFunction(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // <translate()-override-function>
    if (auto result = consumeTranslateFunction(range, state))
        return result;
    // <translate3d()-override-function>
    if (auto result = consumeTranslate3dFunction(range, state))
        return result;
    // <rotate3d()-override-function>
    if (auto result = consumeRotate3dFunction(range, state))
        return result;
    // matrix(<number>#{6})
    auto consumeMatrixFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
            // <number>#{6}
            auto consumeBoundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                    // <number>
                    return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, state);
                };
                return consumeListSeparatedByIntoBuilder<',', ListBounds { 6, 6 }>(range, consumeRepeatedTerm, state);
            };
            return consumeBoundedRepetition(args, state);
        };
        if (range.peek().functionId() != CSSValueID::CSSValueMatrix)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, state);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueMatrix, WTFMove(*result));
    };
    if (auto result = consumeMatrixFunction(range, state))
        return result;
    // translateX(<length-percentage>)
    auto consumeTranslateXFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
            auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                // <length-percentage>
                return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(args, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
            };
            auto parameter = consumeParameter(args, state);
            if (!parameter)
                return { };
            return CSSValueListBuilder { parameter.releaseNonNull() };
        };
        if (range.peek().functionId() != CSSValueID::CSSValueTranslateX)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, state);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueTranslateX, WTFMove(*result));
    };
    if (auto result = consumeTranslateXFunction(range, state))
        return result;
    // translateY(<length-percentage>)
    auto consumeTranslateYFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
            auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                // <length-percentage>
                return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(args, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
            };
            auto parameter = consumeParameter(args, state);
            if (!parameter)
                return { };
            return CSSValueListBuilder { parameter.releaseNonNull() };
        };
        if (range.peek().functionId() != CSSValueID::CSSValueTranslateY)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, state);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueTranslateY, WTFMove(*result));
    };
    if (auto result = consumeTranslateYFunction(range, state))
        return result;
    // scale(<number-or-percentage-resolved-to-number>#{1,2})
    auto consumeScaleFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
            // <number-or-percentage-resolved-to-number>#{1,2}
            auto consumeBoundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                    // <number-or-percentage-resolved-to-number>
                    return consumePercentageDividedBy100OrNumber(range, state);
                };
                return consumeListSeparatedByIntoBuilder<',', ListBounds { 1, 2 }>(range, consumeRepeatedTerm, state);
            };
            return consumeBoundedRepetition(args, state);
        };
        if (range.peek().functionId() != CSSValueID::CSSValueScale)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, state);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueScale, WTFMove(*result));
    };
    if (auto result = consumeScaleFunction(range, state))
        return result;
    // scaleX(<number-or-percentage-resolved-to-number>)
    auto consumeScaleXFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
            auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                // <number-or-percentage-resolved-to-number>
                return consumePercentageDividedBy100OrNumber(args, state);
            };
            auto parameter = consumeParameter(args, state);
            if (!parameter)
                return { };
            return CSSValueListBuilder { parameter.releaseNonNull() };
        };
        if (range.peek().functionId() != CSSValueID::CSSValueScaleX)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, state);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueScaleX, WTFMove(*result));
    };
    if (auto result = consumeScaleXFunction(range, state))
        return result;
    // scaleY(<number-or-percentage-resolved-to-number>)
    auto consumeScaleYFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
            auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                // <number-or-percentage-resolved-to-number>
                return consumePercentageDividedBy100OrNumber(args, state);
            };
            auto parameter = consumeParameter(args, state);
            if (!parameter)
                return { };
            return CSSValueListBuilder { parameter.releaseNonNull() };
        };
        if (range.peek().functionId() != CSSValueID::CSSValueScaleY)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, state);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueScaleY, WTFMove(*result));
    };
    if (auto result = consumeScaleYFunction(range, state))
        return result;
    // rotate(<angle unitless-zero=['allowed']>)
    auto consumeRotateFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
            auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                // <angle unitless-zero=['allowed']>
                return CSSPrimitiveValueResolver<CSS::Angle<>>::consumeAndResolve(args, state, { .unitlessZeroAngle = UnitlessZeroQuirk::Allow });
            };
            auto parameter = consumeParameter(args, state);
            if (!parameter)
                return { };
            return CSSValueListBuilder { parameter.releaseNonNull() };
        };
        if (range.peek().functionId() != CSSValueID::CSSValueRotate)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, state);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueRotate, WTFMove(*result));
    };
    if (auto result = consumeRotateFunction(range, state))
        return result;
    // skew(<angle unitless-zero=['allowed']>#{1,2})
    auto consumeSkewFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
            // <angle unitless-zero=['allowed']>#{1,2}
            auto consumeBoundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                    // <angle unitless-zero=['allowed']>
                    return CSSPrimitiveValueResolver<CSS::Angle<>>::consumeAndResolve(range, state, { .unitlessZeroAngle = UnitlessZeroQuirk::Allow });
                };
                return consumeListSeparatedByIntoBuilder<',', ListBounds { 1, 2 }>(range, consumeRepeatedTerm, state);
            };
            return consumeBoundedRepetition(args, state);
        };
        if (range.peek().functionId() != CSSValueID::CSSValueSkew)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, state);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueSkew, WTFMove(*result));
    };
    if (auto result = consumeSkewFunction(range, state))
        return result;
    // skewX(<angle unitless-zero=['allowed']>)
    auto consumeSkewXFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
            auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                // <angle unitless-zero=['allowed']>
                return CSSPrimitiveValueResolver<CSS::Angle<>>::consumeAndResolve(args, state, { .unitlessZeroAngle = UnitlessZeroQuirk::Allow });
            };
            auto parameter = consumeParameter(args, state);
            if (!parameter)
                return { };
            return CSSValueListBuilder { parameter.releaseNonNull() };
        };
        if (range.peek().functionId() != CSSValueID::CSSValueSkewX)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, state);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueSkewX, WTFMove(*result));
    };
    if (auto result = consumeSkewXFunction(range, state))
        return result;
    // skewY(<angle unitless-zero=['allowed']>)
    auto consumeSkewYFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
            auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                // <angle unitless-zero=['allowed']>
                return CSSPrimitiveValueResolver<CSS::Angle<>>::consumeAndResolve(args, state, { .unitlessZeroAngle = UnitlessZeroQuirk::Allow });
            };
            auto parameter = consumeParameter(args, state);
            if (!parameter)
                return { };
            return CSSValueListBuilder { parameter.releaseNonNull() };
        };
        if (range.peek().functionId() != CSSValueID::CSSValueSkewY)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, state);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueSkewY, WTFMove(*result));
    };
    if (auto result = consumeSkewYFunction(range, state))
        return result;
    // matrix3d(<number>#{16})
    auto consumeMatrix3dFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
            // <number>#{16}
            auto consumeBoundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                    // <number>
                    return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, state);
                };
                return consumeListSeparatedByIntoBuilder<',', ListBounds { 16, 16 }>(range, consumeRepeatedTerm, state);
            };
            return consumeBoundedRepetition(args, state);
        };
        if (range.peek().functionId() != CSSValueID::CSSValueMatrix3d)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, state);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueMatrix3d, WTFMove(*result));
    };
    if (auto result = consumeMatrix3dFunction(range, state))
        return result;
    // translateZ(<length>)
    auto consumeTranslateZFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
            auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                // <length>
                return CSSPrimitiveValueResolver<CSS::Length<>>::consumeAndResolve(args, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow });
            };
            auto parameter = consumeParameter(args, state);
            if (!parameter)
                return { };
            return CSSValueListBuilder { parameter.releaseNonNull() };
        };
        if (range.peek().functionId() != CSSValueID::CSSValueTranslateZ)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, state);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueTranslateZ, WTFMove(*result));
    };
    if (auto result = consumeTranslateZFunction(range, state))
        return result;
    // scale3d(<number-or-percentage-resolved-to-number>#{3})
    auto consumeScale3dFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
            // <number-or-percentage-resolved-to-number>#{3}
            auto consumeBoundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                    // <number-or-percentage-resolved-to-number>
                    return consumePercentageDividedBy100OrNumber(range, state);
                };
                return consumeListSeparatedByIntoBuilder<',', ListBounds { 3, 3 }>(range, consumeRepeatedTerm, state);
            };
            return consumeBoundedRepetition(args, state);
        };
        if (range.peek().functionId() != CSSValueID::CSSValueScale3d)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, state);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueScale3d, WTFMove(*result));
    };
    if (auto result = consumeScale3dFunction(range, state))
        return result;
    // scaleZ(<number-or-percentage-resolved-to-number>)
    auto consumeScaleZFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
            auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                // <number-or-percentage-resolved-to-number>
                return consumePercentageDividedBy100OrNumber(args, state);
            };
            auto parameter = consumeParameter(args, state);
            if (!parameter)
                return { };
            return CSSValueListBuilder { parameter.releaseNonNull() };
        };
        if (range.peek().functionId() != CSSValueID::CSSValueScaleZ)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, state);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueScaleZ, WTFMove(*result));
    };
    if (auto result = consumeScaleZFunction(range, state))
        return result;
    // rotateX(<angle unitless-zero=['allowed']>)
    auto consumeRotateXFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
            auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                // <angle unitless-zero=['allowed']>
                return CSSPrimitiveValueResolver<CSS::Angle<>>::consumeAndResolve(args, state, { .unitlessZeroAngle = UnitlessZeroQuirk::Allow });
            };
            auto parameter = consumeParameter(args, state);
            if (!parameter)
                return { };
            return CSSValueListBuilder { parameter.releaseNonNull() };
        };
        if (range.peek().functionId() != CSSValueID::CSSValueRotateX)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, state);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueRotateX, WTFMove(*result));
    };
    if (auto result = consumeRotateXFunction(range, state))
        return result;
    // rotateY(<angle unitless-zero=['allowed']>)
    auto consumeRotateYFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
            auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                // <angle unitless-zero=['allowed']>
                return CSSPrimitiveValueResolver<CSS::Angle<>>::consumeAndResolve(args, state, { .unitlessZeroAngle = UnitlessZeroQuirk::Allow });
            };
            auto parameter = consumeParameter(args, state);
            if (!parameter)
                return { };
            return CSSValueListBuilder { parameter.releaseNonNull() };
        };
        if (range.peek().functionId() != CSSValueID::CSSValueRotateY)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, state);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueRotateY, WTFMove(*result));
    };
    if (auto result = consumeRotateYFunction(range, state))
        return result;
    // rotateZ(<angle unitless-zero=['allowed']>)
    auto consumeRotateZFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
            auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                // <angle unitless-zero=['allowed']>
                return CSSPrimitiveValueResolver<CSS::Angle<>>::consumeAndResolve(args, state, { .unitlessZeroAngle = UnitlessZeroQuirk::Allow });
            };
            auto parameter = consumeParameter(args, state);
            if (!parameter)
                return { };
            return CSSValueListBuilder { parameter.releaseNonNull() };
        };
        if (range.peek().functionId() != CSSValueID::CSSValueRotateZ)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, state);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValueRotateZ, WTFMove(*result));
    };
    if (auto result = consumeRotateZFunction(range, state))
        return result;
    // perspective([ <length [0,inf]> | <number [0,inf]> | none ])
    auto consumePerspectiveFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
            auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                // none
                switch (auto keyword = args.peek().id(); keyword) {
                case CSSValueID::CSSValueNone:
                    args.consumeIncludingWhitespace();
                    return CSSPrimitiveValue::create(keyword);
                default:
                    break;
                }
                // <length [0,inf]>
                if (auto result = CSSPrimitiveValueResolver<CSS::Length<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(args, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow }))
                    return result;
                // <number [0,inf]>
                return CSSPrimitiveValueResolver<CSS::Number<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(args, state);
            };
            auto parameter = consumeParameter(args, state);
            if (!parameter)
                return { };
            return CSSValueListBuilder { parameter.releaseNonNull() };
        };
        if (range.peek().functionId() != CSSValueID::CSSValuePerspective)
            return { };
        CSSParserTokenRange rangeCopy = range;
        CSSParserTokenRange args = consumeFunction(rangeCopy);
        auto result = consumeParameters(args, state);
        if (!result)
            return { };
        if (!args.atEnd())
            return { };
        range = rangeCopy;
        return CSSFunctionValue::create(CSSValueID::CSSValuePerspective, WTFMove(*result));
    };
    return consumePerspectiveFunction(range, state);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeTransformList(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // [ matrix(<number>#{6}) | <translate()-override-function> | translateX(<length-percentage>) | translateY(<length-percentage>) | scale(<number-or-percentage-resolved-to-number>#{1,2}) | scaleX(<number-or-percentage-resolved-to-number>) | scaleY(<number-or-percentage-resolved-to-number>) | rotate(<angle unitless-zero=['allowed']>) | skew(<angle unitless-zero=['allowed']>#{1,2}) | skewX(<angle unitless-zero=['allowed']>) | skewY(<angle unitless-zero=['allowed']>) | matrix3d(<number>#{16}) | <translate3d()-override-function> | translateZ(<length>) | scale3d(<number-or-percentage-resolved-to-number>#{3}) | scaleZ(<number-or-percentage-resolved-to-number>) | <rotate3d()-override-function> | rotateX(<angle unitless-zero=['allowed']>) | rotateY(<angle unitless-zero=['allowed']>) | rotateZ(<angle unitless-zero=['allowed']>) | perspective([ <length [0,inf]> | <number [0,inf]> | none ]) ]+@(type=CSSTransformListValue no-single-item-opt)
    auto consumeUnboundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
            // <translate()-override-function>
            if (auto result = consumeTranslateFunction(range, state))
                return result;
            // <translate3d()-override-function>
            if (auto result = consumeTranslate3dFunction(range, state))
                return result;
            // <rotate3d()-override-function>
            if (auto result = consumeRotate3dFunction(range, state))
                return result;
            // matrix(<number>#{6})
            auto consumeMatrixFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    // <number>#{6}
                    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                            // <number>
                            return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, state);
                        };
                        return consumeListSeparatedByIntoBuilder<',', ListBounds { 6, 6 }>(range, consumeRepeatedTerm, state);
                    };
                    return consumeBoundedRepetition(args, state);
                };
                if (range.peek().functionId() != CSSValueID::CSSValueMatrix)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueMatrix, WTFMove(*result));
            };
            if (auto result = consumeMatrixFunction(range, state))
                return result;
            // translateX(<length-percentage>)
            auto consumeTranslateXFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                        // <length-percentage>
                        return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(args, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
                    };
                    auto parameter = consumeParameter(args, state);
                    if (!parameter)
                        return { };
                    return CSSValueListBuilder { parameter.releaseNonNull() };
                };
                if (range.peek().functionId() != CSSValueID::CSSValueTranslateX)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueTranslateX, WTFMove(*result));
            };
            if (auto result = consumeTranslateXFunction(range, state))
                return result;
            // translateY(<length-percentage>)
            auto consumeTranslateYFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                        // <length-percentage>
                        return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(args, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
                    };
                    auto parameter = consumeParameter(args, state);
                    if (!parameter)
                        return { };
                    return CSSValueListBuilder { parameter.releaseNonNull() };
                };
                if (range.peek().functionId() != CSSValueID::CSSValueTranslateY)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueTranslateY, WTFMove(*result));
            };
            if (auto result = consumeTranslateYFunction(range, state))
                return result;
            // scale(<number-or-percentage-resolved-to-number>#{1,2})
            auto consumeScaleFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    // <number-or-percentage-resolved-to-number>#{1,2}
                    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                            // <number-or-percentage-resolved-to-number>
                            return consumePercentageDividedBy100OrNumber(range, state);
                        };
                        return consumeListSeparatedByIntoBuilder<',', ListBounds { 1, 2 }>(range, consumeRepeatedTerm, state);
                    };
                    return consumeBoundedRepetition(args, state);
                };
                if (range.peek().functionId() != CSSValueID::CSSValueScale)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueScale, WTFMove(*result));
            };
            if (auto result = consumeScaleFunction(range, state))
                return result;
            // scaleX(<number-or-percentage-resolved-to-number>)
            auto consumeScaleXFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                        // <number-or-percentage-resolved-to-number>
                        return consumePercentageDividedBy100OrNumber(args, state);
                    };
                    auto parameter = consumeParameter(args, state);
                    if (!parameter)
                        return { };
                    return CSSValueListBuilder { parameter.releaseNonNull() };
                };
                if (range.peek().functionId() != CSSValueID::CSSValueScaleX)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueScaleX, WTFMove(*result));
            };
            if (auto result = consumeScaleXFunction(range, state))
                return result;
            // scaleY(<number-or-percentage-resolved-to-number>)
            auto consumeScaleYFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                        // <number-or-percentage-resolved-to-number>
                        return consumePercentageDividedBy100OrNumber(args, state);
                    };
                    auto parameter = consumeParameter(args, state);
                    if (!parameter)
                        return { };
                    return CSSValueListBuilder { parameter.releaseNonNull() };
                };
                if (range.peek().functionId() != CSSValueID::CSSValueScaleY)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueScaleY, WTFMove(*result));
            };
            if (auto result = consumeScaleYFunction(range, state))
                return result;
            // rotate(<angle unitless-zero=['allowed']>)
            auto consumeRotateFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                        // <angle unitless-zero=['allowed']>
                        return CSSPrimitiveValueResolver<CSS::Angle<>>::consumeAndResolve(args, state, { .unitlessZeroAngle = UnitlessZeroQuirk::Allow });
                    };
                    auto parameter = consumeParameter(args, state);
                    if (!parameter)
                        return { };
                    return CSSValueListBuilder { parameter.releaseNonNull() };
                };
                if (range.peek().functionId() != CSSValueID::CSSValueRotate)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueRotate, WTFMove(*result));
            };
            if (auto result = consumeRotateFunction(range, state))
                return result;
            // skew(<angle unitless-zero=['allowed']>#{1,2})
            auto consumeSkewFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    // <angle unitless-zero=['allowed']>#{1,2}
                    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                            // <angle unitless-zero=['allowed']>
                            return CSSPrimitiveValueResolver<CSS::Angle<>>::consumeAndResolve(range, state, { .unitlessZeroAngle = UnitlessZeroQuirk::Allow });
                        };
                        return consumeListSeparatedByIntoBuilder<',', ListBounds { 1, 2 }>(range, consumeRepeatedTerm, state);
                    };
                    return consumeBoundedRepetition(args, state);
                };
                if (range.peek().functionId() != CSSValueID::CSSValueSkew)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueSkew, WTFMove(*result));
            };
            if (auto result = consumeSkewFunction(range, state))
                return result;
            // skewX(<angle unitless-zero=['allowed']>)
            auto consumeSkewXFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                        // <angle unitless-zero=['allowed']>
                        return CSSPrimitiveValueResolver<CSS::Angle<>>::consumeAndResolve(args, state, { .unitlessZeroAngle = UnitlessZeroQuirk::Allow });
                    };
                    auto parameter = consumeParameter(args, state);
                    if (!parameter)
                        return { };
                    return CSSValueListBuilder { parameter.releaseNonNull() };
                };
                if (range.peek().functionId() != CSSValueID::CSSValueSkewX)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueSkewX, WTFMove(*result));
            };
            if (auto result = consumeSkewXFunction(range, state))
                return result;
            // skewY(<angle unitless-zero=['allowed']>)
            auto consumeSkewYFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                        // <angle unitless-zero=['allowed']>
                        return CSSPrimitiveValueResolver<CSS::Angle<>>::consumeAndResolve(args, state, { .unitlessZeroAngle = UnitlessZeroQuirk::Allow });
                    };
                    auto parameter = consumeParameter(args, state);
                    if (!parameter)
                        return { };
                    return CSSValueListBuilder { parameter.releaseNonNull() };
                };
                if (range.peek().functionId() != CSSValueID::CSSValueSkewY)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueSkewY, WTFMove(*result));
            };
            if (auto result = consumeSkewYFunction(range, state))
                return result;
            // matrix3d(<number>#{16})
            auto consumeMatrix3dFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    // <number>#{16}
                    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                            // <number>
                            return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, state);
                        };
                        return consumeListSeparatedByIntoBuilder<',', ListBounds { 16, 16 }>(range, consumeRepeatedTerm, state);
                    };
                    return consumeBoundedRepetition(args, state);
                };
                if (range.peek().functionId() != CSSValueID::CSSValueMatrix3d)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueMatrix3d, WTFMove(*result));
            };
            if (auto result = consumeMatrix3dFunction(range, state))
                return result;
            // translateZ(<length>)
            auto consumeTranslateZFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                        // <length>
                        return CSSPrimitiveValueResolver<CSS::Length<>>::consumeAndResolve(args, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow });
                    };
                    auto parameter = consumeParameter(args, state);
                    if (!parameter)
                        return { };
                    return CSSValueListBuilder { parameter.releaseNonNull() };
                };
                if (range.peek().functionId() != CSSValueID::CSSValueTranslateZ)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueTranslateZ, WTFMove(*result));
            };
            if (auto result = consumeTranslateZFunction(range, state))
                return result;
            // scale3d(<number-or-percentage-resolved-to-number>#{3})
            auto consumeScale3dFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    // <number-or-percentage-resolved-to-number>#{3}
                    auto consumeBoundedRepetition = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                        auto consumeRepeatedTerm = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                            // <number-or-percentage-resolved-to-number>
                            return consumePercentageDividedBy100OrNumber(range, state);
                        };
                        return consumeListSeparatedByIntoBuilder<',', ListBounds { 3, 3 }>(range, consumeRepeatedTerm, state);
                    };
                    return consumeBoundedRepetition(args, state);
                };
                if (range.peek().functionId() != CSSValueID::CSSValueScale3d)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueScale3d, WTFMove(*result));
            };
            if (auto result = consumeScale3dFunction(range, state))
                return result;
            // scaleZ(<number-or-percentage-resolved-to-number>)
            auto consumeScaleZFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                        // <number-or-percentage-resolved-to-number>
                        return consumePercentageDividedBy100OrNumber(args, state);
                    };
                    auto parameter = consumeParameter(args, state);
                    if (!parameter)
                        return { };
                    return CSSValueListBuilder { parameter.releaseNonNull() };
                };
                if (range.peek().functionId() != CSSValueID::CSSValueScaleZ)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueScaleZ, WTFMove(*result));
            };
            if (auto result = consumeScaleZFunction(range, state))
                return result;
            // rotateX(<angle unitless-zero=['allowed']>)
            auto consumeRotateXFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                        // <angle unitless-zero=['allowed']>
                        return CSSPrimitiveValueResolver<CSS::Angle<>>::consumeAndResolve(args, state, { .unitlessZeroAngle = UnitlessZeroQuirk::Allow });
                    };
                    auto parameter = consumeParameter(args, state);
                    if (!parameter)
                        return { };
                    return CSSValueListBuilder { parameter.releaseNonNull() };
                };
                if (range.peek().functionId() != CSSValueID::CSSValueRotateX)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueRotateX, WTFMove(*result));
            };
            if (auto result = consumeRotateXFunction(range, state))
                return result;
            // rotateY(<angle unitless-zero=['allowed']>)
            auto consumeRotateYFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                        // <angle unitless-zero=['allowed']>
                        return CSSPrimitiveValueResolver<CSS::Angle<>>::consumeAndResolve(args, state, { .unitlessZeroAngle = UnitlessZeroQuirk::Allow });
                    };
                    auto parameter = consumeParameter(args, state);
                    if (!parameter)
                        return { };
                    return CSSValueListBuilder { parameter.releaseNonNull() };
                };
                if (range.peek().functionId() != CSSValueID::CSSValueRotateY)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueRotateY, WTFMove(*result));
            };
            if (auto result = consumeRotateYFunction(range, state))
                return result;
            // rotateZ(<angle unitless-zero=['allowed']>)
            auto consumeRotateZFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                        // <angle unitless-zero=['allowed']>
                        return CSSPrimitiveValueResolver<CSS::Angle<>>::consumeAndResolve(args, state, { .unitlessZeroAngle = UnitlessZeroQuirk::Allow });
                    };
                    auto parameter = consumeParameter(args, state);
                    if (!parameter)
                        return { };
                    return CSSValueListBuilder { parameter.releaseNonNull() };
                };
                if (range.peek().functionId() != CSSValueID::CSSValueRotateZ)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValueRotateZ, WTFMove(*result));
            };
            if (auto result = consumeRotateZFunction(range, state))
                return result;
            // perspective([ <length [0,inf]> | <number [0,inf]> | none ])
            auto consumePerspectiveFunction = [](CSSParserTokenRange& range, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                auto consumeParameters = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> std::optional<CSSValueListBuilder> {
                    auto consumeParameter = [](CSSParserTokenRange& args, CSS::PropertyParserState& state) -> RefPtr<CSSValue> {
                        // none
                        switch (auto keyword = args.peek().id(); keyword) {
                        case CSSValueID::CSSValueNone:
                            args.consumeIncludingWhitespace();
                            return CSSPrimitiveValue::create(keyword);
                        default:
                            break;
                        }
                        // <length [0,inf]>
                        if (auto result = CSSPrimitiveValueResolver<CSS::Length<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(args, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow }))
                            return result;
                        // <number [0,inf]>
                        return CSSPrimitiveValueResolver<CSS::Number<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(args, state);
                    };
                    auto parameter = consumeParameter(args, state);
                    if (!parameter)
                        return { };
                    return CSSValueListBuilder { parameter.releaseNonNull() };
                };
                if (range.peek().functionId() != CSSValueID::CSSValuePerspective)
                    return { };
                CSSParserTokenRange rangeCopy = range;
                CSSParserTokenRange args = consumeFunction(rangeCopy);
                auto result = consumeParameters(args, state);
                if (!result)
                    return { };
                if (!args.atEnd())
                    return { };
                range = rangeCopy;
                return CSSFunctionValue::create(CSSValueID::CSSValuePerspective, WTFMove(*result));
            };
            return consumePerspectiveFunction(range, state);
        };
        return consumeListSeparatedBy<' ', ListBounds::minimumOf(1), ListOptimization::None, CSSTransformListValue>(range, consumeRepeatedTerm, state);
    };
    return consumeUnboundedRepetition(range, state);
}

RefPtr<CSSValue> CSSPropertyParsing::consumeTransitionBehaviorValue(CSSParserTokenRange& range)
{
    // normal | allow-discrete
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueNormal:
    case CSSValueID::CSSValueAllowDiscrete:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        return nullptr;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::consumeWidthOrHeight(CSSParserTokenRange& range, CSS::PropertyParserState& state)
{
    // auto | intrinsic | min-intrinsic | min-content | -webkit-min-content | max-content | -webkit-max-content | -webkit-fill-available | fit-content | -webkit-fit-content
    switch (auto keyword = range.peek().id(); keyword) {
    case CSSValueID::CSSValueAuto:
    case CSSValueID::CSSValueIntrinsic:
    case CSSValueID::CSSValueMinIntrinsic:
    case CSSValueID::CSSValueMinContent:
    case CSSValueID::CSSValueWebkitMinContent:
    case CSSValueID::CSSValueMaxContent:
    case CSSValueID::CSSValueWebkitMaxContent:
    case CSSValueID::CSSValueWebkitFillAvailable:
    case CSSValueID::CSSValueFitContent:
    case CSSValueID::CSSValueWebkitFitContent:
        range.consumeIncludingWhitespace();
        return CSSPrimitiveValue::create(keyword);
    default:
        break;
    }
    // <length-percentage [0,inf] anchor-size=['allowed']>
    return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Allow, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
}

RefPtr<CSSValue> CSSPropertyParsing::parseStylePropertyLonghand(CSSParserTokenRange& range, CSSPropertyID id, CSS::PropertyParserState& state)
{
    if (!isExposed(id, state.context.propertySettings) && !isInternal(id)) {
        // Allow internal properties as we use them to parse several internal-only-shorthands (e.g. background-repeat),
        // and to handle certain DOM-exposed values (e.g. -webkit-font-size-delta from execCommand('FontSizeDelta')).
        ASSERT_NOT_REACHED();
        return { };
    }
    switch (id) {
    case CSSPropertyID::CSSPropertyColorScheme:
        return consumeColorScheme(range, state);
    case CSSPropertyID::CSSPropertyRubyPosition:
        return consumeIdent(range, isKeywordValidForRubyPosition);
    case CSSPropertyID::CSSPropertyWritingMode:
        return consumeIdent(range, isKeywordValidForWritingMode, state);
    case CSSPropertyID::CSSPropertyDirection:
        return consumeIdent(range, isKeywordValidForDirection);
    case CSSPropertyID::CSSPropertyDisplay:
        return consumeDisplay(range, state);
    case CSSPropertyID::CSSPropertyFontFamily:
        return consumeFontFamily(range, state);
    case CSSPropertyID::CSSPropertyFontFeatureSettings:
        return CSSPropertyParsing::consumeFontFeatureSettings(range, state);
    case CSSPropertyID::CSSPropertyFontKerning:
        return consumeIdent(range, isKeywordValidForFontKerning);
    case CSSPropertyID::CSSPropertyFontOpticalSizing:
        return consumeIdent(range, isKeywordValidForFontOpticalSizing);
    case CSSPropertyID::CSSPropertyFontPalette:
        return consumeFontPalette(range);
    case CSSPropertyID::CSSPropertyFontSize:
        return CSSPropertyParsing::consumeFontSize(range, state);
    case CSSPropertyID::CSSPropertyFontSizeAdjust:
        return consumeFontSizeAdjust(range, state);
    case CSSPropertyID::CSSPropertyFontStyle:
        return consumeFontStyle(range, state);
    case CSSPropertyID::CSSPropertyFontSynthesisSmallCaps:
        return consumeIdent(range, isKeywordValidForFontSynthesisSmallCaps);
    case CSSPropertyID::CSSPropertyFontSynthesisStyle:
        return consumeIdent(range, isKeywordValidForFontSynthesisStyle);
    case CSSPropertyID::CSSPropertyFontSynthesisWeight:
        return consumeIdent(range, isKeywordValidForFontSynthesisWeight);
    case CSSPropertyID::CSSPropertyFontVariantAlternates:
        return CSSPropertyParsing::consumeFontVariantAlternates(range);
    case CSSPropertyID::CSSPropertyFontVariantCaps:
        return consumeIdent(range, isKeywordValidForFontVariantCaps);
    case CSSPropertyID::CSSPropertyFontVariantEastAsian:
        return CSSPropertyParsing::consumeFontVariantEastAsian(range);
    case CSSPropertyID::CSSPropertyFontVariantEmoji:
        return consumeIdent(range, isKeywordValidForFontVariantEmoji);
    case CSSPropertyID::CSSPropertyFontVariantLigatures:
        return consumeFontVariantLigatures(range);
    case CSSPropertyID::CSSPropertyFontVariantNumeric:
        return consumeFontVariantNumeric(range);
    case CSSPropertyID::CSSPropertyFontVariantPosition:
        return consumeIdent(range, isKeywordValidForFontVariantPosition);
    case CSSPropertyID::CSSPropertyFontVariationSettings:
        return consumeFontVariationSettings(range, state);
    case CSSPropertyID::CSSPropertyFontWeight:
        return CSSPropertyParsing::consumeFontWeight(range, state);
    case CSSPropertyID::CSSPropertyFontWidth:
        return consumeFontWidth(range, state);
    case CSSPropertyID::CSSPropertyTextOrientation:
        return consumeIdent(range, isKeywordValidForTextOrientation);
    case CSSPropertyID::CSSPropertyTextRendering:
        return consumeIdent(range, isKeywordValidForTextRendering);
    case CSSPropertyID::CSSPropertyZoom:
        return consumeZoom(range, state);
    case CSSPropertyID::CSSPropertyWebkitFontSmoothing:
        return consumeIdent(range, isKeywordValidForWebkitFontSmoothing);
    case CSSPropertyID::CSSPropertyWebkitLocale:
        return consumeWebkitLocale(range);
    case CSSPropertyID::CSSPropertyWebkitTextZoom:
        return consumeIdent(range, isKeywordValidForWebkitTextZoom);
    case CSSPropertyID::CSSPropertyLetterSpacing:
        return consumeLetterSpacing(range, state);
    case CSSPropertyID::CSSPropertyTextAutospace:
        return consumeTextAutospace(range);
    case CSSPropertyID::CSSPropertyTextSpacingTrim:
        return consumeIdent(range, isKeywordValidForTextSpacingTrim);
    case CSSPropertyID::CSSPropertyAccentColor:
        return consumeAccentColor(range, state);
    case CSSPropertyID::CSSPropertyAlignContent:
        return consumeAlignContent(range, state);
    case CSSPropertyID::CSSPropertyAlignItems:
        return consumeAlignItems(range, state);
    case CSSPropertyID::CSSPropertyAlignSelf:
        return consumeAlignSelf(range, state);
    case CSSPropertyID::CSSPropertyAlignmentBaseline:
        return consumeIdent(range, isKeywordValidForAlignmentBaseline);
    case CSSPropertyID::CSSPropertyAnchorName:
        return consumeAnchorName(range);
    case CSSPropertyID::CSSPropertyAnchorScope:
        return consumeAnchorScope(range);
    case CSSPropertyID::CSSPropertyAnimationComposition:
        return consumeAnimationComposition(range);
    case CSSPropertyID::CSSPropertyAnimationDelay:
        return consumeAnimationDelay(range, state);
    case CSSPropertyID::CSSPropertyAnimationDirection:
        return consumeAnimationDirection(range);
    case CSSPropertyID::CSSPropertyAnimationDuration:
        return consumeAnimationDuration(range, state);
    case CSSPropertyID::CSSPropertyAnimationFillMode:
        return consumeAnimationFillMode(range);
    case CSSPropertyID::CSSPropertyAnimationIterationCount:
        return consumeAnimationIterationCount(range, state);
    case CSSPropertyID::CSSPropertyAnimationName:
        return consumeAnimationName(range, state);
    case CSSPropertyID::CSSPropertyAnimationPlayState:
        return consumeAnimationPlayState(range);
    case CSSPropertyID::CSSPropertyAnimationRangeEnd:
        return consumeAnimationRangeEnd(range, state);
    case CSSPropertyID::CSSPropertyAnimationRangeStart:
        return consumeAnimationRangeStart(range, state);
    case CSSPropertyID::CSSPropertyAnimationTimeline:
        return consumeAnimationTimeline(range, state);
    case CSSPropertyID::CSSPropertyAnimationTimingFunction:
        return consumeAnimationTimingFunction(range, state);
    case CSSPropertyID::CSSPropertyAppearance:
        return consumeIdent(range, isKeywordValidForAppearance, state);
    case CSSPropertyID::CSSPropertyAspectRatio:
        return consumeAspectRatio(range, state);
    case CSSPropertyID::CSSPropertyBackdropFilter:
    case CSSPropertyID::CSSPropertyFilter:
    case CSSPropertyID::CSSPropertyWebkitBackdropFilter:
        return consumeFilter(range, state);
    case CSSPropertyID::CSSPropertyBackfaceVisibility:
        return consumeIdent(range, isKeywordValidForBackfaceVisibility);
    case CSSPropertyID::CSSPropertyBackgroundAttachment:
        return consumeBackgroundAttachment(range);
    case CSSPropertyID::CSSPropertyBackgroundBlendMode:
        return consumeBackgroundBlendMode(range);
    case CSSPropertyID::CSSPropertyBackgroundClip:
        return consumeBackgroundClip(range, state);
    case CSSPropertyID::CSSPropertyBackgroundColor:
    case CSSPropertyID::CSSPropertyColor:
    case CSSPropertyID::CSSPropertyColumnRuleColor:
    case CSSPropertyID::CSSPropertyFloodColor:
    case CSSPropertyID::CSSPropertyLightingColor:
    case CSSPropertyID::CSSPropertyStopColor:
    case CSSPropertyID::CSSPropertyStrokeColor:
    case CSSPropertyID::CSSPropertyTextDecorationColor:
    case CSSPropertyID::CSSPropertyTextEmphasisColor:
    case CSSPropertyID::CSSPropertyWebkitTextFillColor:
    case CSSPropertyID::CSSPropertyWebkitTextStrokeColor:
    case CSSPropertyID::CSSPropertyBorderBottomColor:
    case CSSPropertyID::CSSPropertyBorderLeftColor:
    case CSSPropertyID::CSSPropertyBorderRightColor:
    case CSSPropertyID::CSSPropertyBorderTopColor:
    case CSSPropertyID::CSSPropertyBorderBlockEndColor:
    case CSSPropertyID::CSSPropertyBorderBlockStartColor:
    case CSSPropertyID::CSSPropertyBorderInlineEndColor:
    case CSSPropertyID::CSSPropertyBorderInlineStartColor:
        return consumeColor(range, state, { .allowedColorTypes = { CSS::ColorType::Absolute, CSS::ColorType::Current, CSS::ColorType::System } });
    case CSSPropertyID::CSSPropertyBackgroundImage:
        return consumeBackgroundImage(range, state);
    case CSSPropertyID::CSSPropertyBackgroundOrigin:
        return consumeBackgroundOrigin(range);
    case CSSPropertyID::CSSPropertyBackgroundPositionX:
        return consumeBackgroundPositionX(range, state);
    case CSSPropertyID::CSSPropertyBackgroundPositionY:
        return consumeBackgroundPositionY(range, state);
    case CSSPropertyID::CSSPropertyBackgroundRepeat:
        return consumeBackgroundRepeat(range, state);
    case CSSPropertyID::CSSPropertyBackgroundSize:
        return consumeBackgroundSize(range, state);
    case CSSPropertyID::CSSPropertyBaselineShift:
        return consumeBaselineShift(range, state);
    case CSSPropertyID::CSSPropertyBlockEllipsis:
        return CSSPropertyParsing::consumeBlockEllipsis(range);
    case CSSPropertyID::CSSPropertyBlockStepAlign:
        return consumeIdent(range, isKeywordValidForBlockStepAlign);
    case CSSPropertyID::CSSPropertyBlockStepInsert:
        return consumeIdent(range, isKeywordValidForBlockStepInsert);
    case CSSPropertyID::CSSPropertyBlockStepRound:
        return consumeIdent(range, isKeywordValidForBlockStepRound);
    case CSSPropertyID::CSSPropertyBlockStepSize:
        return CSSPropertyParsing::consumeBlockStepSize(range, state);
    case CSSPropertyID::CSSPropertyBorderCollapse:
        return consumeIdent(range, isKeywordValidForBorderCollapse);
    case CSSPropertyID::CSSPropertyBorderImageOutset:
        return CSSPropertyParsing::consumeBorderImageOutset(range, state);
    case CSSPropertyID::CSSPropertyBorderImageRepeat:
        return CSSPropertyParsing::consumeBorderImageRepeat(range);
    case CSSPropertyID::CSSPropertyBorderImageSlice:
    case CSSPropertyID::CSSPropertyMaskBorderSlice:
        return consumeBorderImageSlice(range, state);
    case CSSPropertyID::CSSPropertyBorderImageSource:
        return consumeBorderImageSource(range, state);
    case CSSPropertyID::CSSPropertyBorderImageWidth:
    case CSSPropertyID::CSSPropertyMaskBorderWidth:
        return consumeBorderImageWidth(range, state);
    case CSSPropertyID::CSSPropertyBoxShadow:
        return consumeBoxShadow(range, state);
    case CSSPropertyID::CSSPropertyBoxSizing:
        return consumeIdent(range, isKeywordValidForBoxSizing);
    case CSSPropertyID::CSSPropertyBreakAfter:
        return consumeIdent(range, isKeywordValidForBreakAfter);
    case CSSPropertyID::CSSPropertyBreakBefore:
        return consumeIdent(range, isKeywordValidForBreakBefore);
    case CSSPropertyID::CSSPropertyBreakInside:
        return consumeIdent(range, isKeywordValidForBreakInside);
    case CSSPropertyID::CSSPropertyBufferedRendering:
        return consumeIdent(range, isKeywordValidForBufferedRendering);
    case CSSPropertyID::CSSPropertyCaptionSide:
        return consumeIdent(range, isKeywordValidForCaptionSide);
    case CSSPropertyID::CSSPropertyCaretColor:
        return consumeCaretColor(range, state);
    case CSSPropertyID::CSSPropertyClear:
        return consumeIdent(range, isKeywordValidForClear);
    case CSSPropertyID::CSSPropertyClip:
        return consumeClip(range, state);
    case CSSPropertyID::CSSPropertyClipPath:
        return consumeClipPath(range, state);
    case CSSPropertyID::CSSPropertyClipRule:
        return consumeIdent(range, isKeywordValidForClipRule);
    case CSSPropertyID::CSSPropertyColorInterpolation:
        return consumeIdent(range, isKeywordValidForColorInterpolation);
    case CSSPropertyID::CSSPropertyColorInterpolationFilters:
        return consumeIdent(range, isKeywordValidForColorInterpolationFilters);
    case CSSPropertyID::CSSPropertyColumnCount:
        return CSSPropertyParsing::consumeColumnCount(range, state);
    case CSSPropertyID::CSSPropertyColumnFill:
        return consumeIdent(range, isKeywordValidForColumnFill);
    case CSSPropertyID::CSSPropertyColumnGap:
        return CSSPropertyParsing::consumeColumnGap(range, state);
    case CSSPropertyID::CSSPropertyColumnRuleStyle:
        return consumeIdent(range, isKeywordValidForColumnRuleStyle);
    case CSSPropertyID::CSSPropertyColumnRuleWidth:
        return consumeColumnRuleWidth(range, state);
    case CSSPropertyID::CSSPropertyColumnSpan:
        return consumeIdent(range, isKeywordValidForColumnSpan);
    case CSSPropertyID::CSSPropertyColumnWidth:
        return CSSPropertyParsing::consumeColumnWidth(range, state);
    case CSSPropertyID::CSSPropertyContain:
        return consumeContain(range);
    case CSSPropertyID::CSSPropertyContainerName:
        return consumeContainerName(range);
    case CSSPropertyID::CSSPropertyContainerType:
        return consumeIdent(range, isKeywordValidForContainerType);
    case CSSPropertyID::CSSPropertyContent:
        return consumeContent(range, state);
    case CSSPropertyID::CSSPropertyContentVisibility:
        return consumeIdent(range, isKeywordValidForContentVisibility);
    case CSSPropertyID::CSSPropertyContinue:
        return consumeIdent(range, isKeywordValidForContinue);
    case CSSPropertyID::CSSPropertyCounterIncrement:
        return consumeCounterIncrement(range, state);
    case CSSPropertyID::CSSPropertyCounterReset:
        return consumeCounterReset(range, state);
    case CSSPropertyID::CSSPropertyCounterSet:
        return consumeCounterSet(range, state);
    case CSSPropertyID::CSSPropertyCursor:
        return consumeCursor(range, state);
    case CSSPropertyID::CSSPropertyCx:
    case CSSPropertyID::CSSPropertyCy:
    case CSSPropertyID::CSSPropertyOffsetDistance:
    case CSSPropertyID::CSSPropertyX:
    case CSSPropertyID::CSSPropertyY:
    case CSSPropertyID::CSSPropertyWebkitMarqueeIncrement:
        return CSSPrimitiveValueResolver<CSS::LengthPercentage<>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
    case CSSPropertyID::CSSPropertyD:
        return consumeD(range, state);
    case CSSPropertyID::CSSPropertyDominantBaseline:
        return consumeIdent(range, isKeywordValidForDominantBaseline);
    case CSSPropertyID::CSSPropertyDynamicRangeLimit:
        return consumeDynamicRangeLimit(range, state);
    case CSSPropertyID::CSSPropertyEmptyCells:
        return consumeIdent(range, isKeywordValidForEmptyCells);
    case CSSPropertyID::CSSPropertyFieldSizing:
        return consumeIdent(range, isKeywordValidForFieldSizing);
    case CSSPropertyID::CSSPropertyFill:
        return consumeFill(range, state);
    case CSSPropertyID::CSSPropertyFillOpacity:
        return consumeFillOpacity(range, state);
    case CSSPropertyID::CSSPropertyFillRule:
        return consumeIdent(range, isKeywordValidForFillRule);
    case CSSPropertyID::CSSPropertyFlexBasis:
        return consumeFlexBasis(range, state);
    case CSSPropertyID::CSSPropertyFlexDirection:
        return consumeIdent(range, isKeywordValidForFlexDirection);
    case CSSPropertyID::CSSPropertyFlexGrow:
    case CSSPropertyID::CSSPropertyFlexShrink:
    case CSSPropertyID::CSSPropertyStrokeMiterlimit:
    case CSSPropertyID::CSSPropertyWebkitMarqueeRepetition:
        return CSSPrimitiveValueResolver<CSS::Number<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state);
    case CSSPropertyID::CSSPropertyFlexWrap:
        return consumeIdent(range, isKeywordValidForFlexWrap);
    case CSSPropertyID::CSSPropertyFloat:
        return consumeIdent(range, isKeywordValidForFloat);
    case CSSPropertyID::CSSPropertyFloodOpacity:
        return consumeFloodOpacity(range, state);
    case CSSPropertyID::CSSPropertyGlyphOrientationHorizontal:
        return CSSPrimitiveValueResolver<CSS::Angle<>>::consumeAndResolve(range, state, { .unitlessZeroAngle = UnitlessZeroQuirk::Allow });
    case CSSPropertyID::CSSPropertyGlyphOrientationVertical:
        return consumeGlyphOrientationVertical(range, state);
    case CSSPropertyID::CSSPropertyGridAutoColumns:
    case CSSPropertyID::CSSPropertyGridAutoRows:
        return consumeGridTrackList(range, state);
    case CSSPropertyID::CSSPropertyGridAutoFlow:
        return consumeGridAutoFlow(range, state);
    case CSSPropertyID::CSSPropertyGridColumnEnd:
    case CSSPropertyID::CSSPropertyGridColumnStart:
    case CSSPropertyID::CSSPropertyGridRowEnd:
    case CSSPropertyID::CSSPropertyGridRowStart:
        return consumeGridLine(range, state);
    case CSSPropertyID::CSSPropertyGridTemplateAreas:
        return consumeGridTemplateAreas(range, state);
    case CSSPropertyID::CSSPropertyGridTemplateColumns:
    case CSSPropertyID::CSSPropertyGridTemplateRows:
        return consumeGridTemplatesRowsOrColumns(range, state);
    case CSSPropertyID::CSSPropertyHangingPunctuation:
        return consumeHangingPunctuation(range);
    case CSSPropertyID::CSSPropertyHyphenateCharacter:
        return consumeHyphenateCharacter(range);
    case CSSPropertyID::CSSPropertyHyphens:
        return consumeIdent(range, isKeywordValidForHyphens);
    case CSSPropertyID::CSSPropertyImageOrientation:
        return consumeIdent(range, isKeywordValidForImageOrientation);
    case CSSPropertyID::CSSPropertyImageRendering:
        return consumeIdent(range, isKeywordValidForImageRendering);
    case CSSPropertyID::CSSPropertyInputSecurity:
        return consumeIdent(range, isKeywordValidForInputSecurity);
    case CSSPropertyID::CSSPropertyIsolation:
        return consumeIdent(range, isKeywordValidForIsolation);
    case CSSPropertyID::CSSPropertyJustifyContent:
        return consumeJustifyContent(range, state);
    case CSSPropertyID::CSSPropertyJustifyItems:
        return consumeJustifyItems(range, state);
    case CSSPropertyID::CSSPropertyJustifySelf:
        return consumeJustifySelf(range, state);
    case CSSPropertyID::CSSPropertyLineBreak:
        return consumeIdent(range, isKeywordValidForLineBreak);
    case CSSPropertyID::CSSPropertyLineFitEdge:
        return consumeLineFitEdge(range, state);
    case CSSPropertyID::CSSPropertyLineHeight:
        return CSSPropertyParsing::consumeLineHeight(range, state);
    case CSSPropertyID::CSSPropertyListStyleImage:
        return consumeListStyleImage(range, state);
    case CSSPropertyID::CSSPropertyListStylePosition:
        return consumeIdent(range, isKeywordValidForListStylePosition);
    case CSSPropertyID::CSSPropertyListStyleType:
        return CSSPropertyParsing::consumeListStyleType(range, state);
    case CSSPropertyID::CSSPropertyMarginTrim:
        return consumeMarginTrim(range, state);
    case CSSPropertyID::CSSPropertyMarkerEnd:
        return consumeMarkerEnd(range, state);
    case CSSPropertyID::CSSPropertyMarkerMid:
        return consumeMarkerMid(range, state);
    case CSSPropertyID::CSSPropertyMarkerStart:
        return consumeMarkerStart(range, state);
    case CSSPropertyID::CSSPropertyMaskBorderOutset:
        return consumeMaskBorderOutset(range, state);
    case CSSPropertyID::CSSPropertyMaskBorderRepeat:
        return consumeMaskBorderRepeat(range);
    case CSSPropertyID::CSSPropertyMaskBorderSource:
        return consumeMaskBorderSource(range, state);
    case CSSPropertyID::CSSPropertyMaskClip:
        return consumeMaskClip(range);
    case CSSPropertyID::CSSPropertyMaskComposite:
        return consumeMaskComposite(range);
    case CSSPropertyID::CSSPropertyMaskImage:
        return consumeMaskImage(range, state);
    case CSSPropertyID::CSSPropertyMaskMode:
        return consumeMaskMode(range);
    case CSSPropertyID::CSSPropertyMaskOrigin:
        return consumeMaskOrigin(range);
    case CSSPropertyID::CSSPropertyMaskRepeat:
        return consumeMaskRepeat(range, state);
    case CSSPropertyID::CSSPropertyMaskSize:
        return consumeMaskSize(range, state);
    case CSSPropertyID::CSSPropertyMaskType:
        return consumeIdent(range, isKeywordValidForMaskType);
    case CSSPropertyID::CSSPropertyMathStyle:
        return consumeIdent(range, isKeywordValidForMathStyle);
    case CSSPropertyID::CSSPropertyMaxLines:
        return CSSPropertyParsing::consumeMaxLines(range, state);
    case CSSPropertyID::CSSPropertyMixBlendMode:
        return consumeIdent(range, isKeywordValidForMixBlendMode);
    case CSSPropertyID::CSSPropertyObjectFit:
        return consumeIdent(range, isKeywordValidForObjectFit);
    case CSSPropertyID::CSSPropertyObjectPosition:
        return consumePosition(range, state);
    case CSSPropertyID::CSSPropertyOffsetAnchor:
        return consumeOffsetAnchor(range, state);
    case CSSPropertyID::CSSPropertyOffsetPath:
        return consumeOffsetPath(range, state);
    case CSSPropertyID::CSSPropertyOffsetPosition:
        return consumeOffsetPosition(range, state);
    case CSSPropertyID::CSSPropertyOffsetRotate:
        return consumeOffsetRotate(range, state);
    case CSSPropertyID::CSSPropertyOpacity:
        return consumeOpacity(range, state);
    case CSSPropertyID::CSSPropertyOrder:
        return CSSPrimitiveValueResolver<CSS::Integer<>>::consumeAndResolve(range, state);
    case CSSPropertyID::CSSPropertyOrphans:
    case CSSPropertyID::CSSPropertyWidows:
    case CSSPropertyID::CSSPropertyWebkitBoxOrdinalGroup:
        return CSSPrimitiveValueResolver<CSS::Integer<CSS::Range{1, CSS::Range::infinity}>>::consumeAndResolve(range, state);
    case CSSPropertyID::CSSPropertyOutlineColor:
        return consumeOutlineColor(range, state);
    case CSSPropertyID::CSSPropertyOutlineOffset:
    case CSSPropertyID::CSSPropertyTransformOriginZ:
    case CSSPropertyID::CSSPropertyWebkitFontSizeDelta:
    case CSSPropertyID::CSSPropertyScrollMarginBottom:
    case CSSPropertyID::CSSPropertyScrollMarginLeft:
    case CSSPropertyID::CSSPropertyScrollMarginRight:
    case CSSPropertyID::CSSPropertyScrollMarginTop:
    case CSSPropertyID::CSSPropertyScrollMarginBlockEnd:
    case CSSPropertyID::CSSPropertyScrollMarginBlockStart:
    case CSSPropertyID::CSSPropertyScrollMarginInlineEnd:
    case CSSPropertyID::CSSPropertyScrollMarginInlineStart:
        return CSSPrimitiveValueResolver<CSS::Length<>>::consumeAndResolve(range, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow });
    case CSSPropertyID::CSSPropertyOutlineStyle:
        return consumeIdent(range, isKeywordValidForOutlineStyle);
    case CSSPropertyID::CSSPropertyOutlineWidth:
        return consumeOutlineWidth(range, state);
    case CSSPropertyID::CSSPropertyOverflowAnchor:
        return consumeIdent(range, isKeywordValidForOverflowAnchor);
    case CSSPropertyID::CSSPropertyOverflowWrap:
        return consumeIdent(range, isKeywordValidForOverflowWrap);
    case CSSPropertyID::CSSPropertyPage:
        return consumePage(range);
    case CSSPropertyID::CSSPropertyPaintOrder:
        return consumePaintOrder(range, state);
    case CSSPropertyID::CSSPropertyPerspective:
        return CSSPropertyParsing::consumePerspective(range, state);
    case CSSPropertyID::CSSPropertyPerspectiveOriginX:
    case CSSPropertyID::CSSPropertyTransformOriginX:
        return consumePositionX(range, state);
    case CSSPropertyID::CSSPropertyPerspectiveOriginY:
    case CSSPropertyID::CSSPropertyTransformOriginY:
        return consumePositionY(range, state);
    case CSSPropertyID::CSSPropertyPointerEvents:
        return consumeIdent(range, isKeywordValidForPointerEvents);
    case CSSPropertyID::CSSPropertyPosition:
        return consumeIdent(range, isKeywordValidForPosition);
    case CSSPropertyID::CSSPropertyPositionAnchor:
        return consumePositionAnchor(range);
    case CSSPropertyID::CSSPropertyPositionArea:
        return consumePositionArea(range, state);
    case CSSPropertyID::CSSPropertyPositionTryFallbacks:
        return consumePositionTryFallbacks(range, state);
    case CSSPropertyID::CSSPropertyPositionTryOrder:
        return consumeIdent(range, isKeywordValidForPositionTryOrder);
    case CSSPropertyID::CSSPropertyPositionVisibility:
        return consumePositionVisibility(range);
    case CSSPropertyID::CSSPropertyPrintColorAdjust:
        return consumeIdent(range, isKeywordValidForPrintColorAdjust);
    case CSSPropertyID::CSSPropertyQuotes:
        return consumeQuotes(range, state);
    case CSSPropertyID::CSSPropertyR:
    case CSSPropertyID::CSSPropertyShapeMargin:
    case CSSPropertyID::CSSPropertyPaddingBottom:
    case CSSPropertyID::CSSPropertyPaddingLeft:
    case CSSPropertyID::CSSPropertyPaddingRight:
    case CSSPropertyID::CSSPropertyPaddingTop:
    case CSSPropertyID::CSSPropertyPaddingBlockEnd:
    case CSSPropertyID::CSSPropertyPaddingBlockStart:
    case CSSPropertyID::CSSPropertyPaddingInlineEnd:
    case CSSPropertyID::CSSPropertyPaddingInlineStart:
        return CSSPrimitiveValueResolver<CSS::LengthPercentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .anchorPolicy = AnchorPolicy::Forbid, .anchorSizePolicy = AnchorSizePolicy::Forbid, .unitlessZeroLength = UnitlessZeroQuirk::Allow });
    case CSSPropertyID::CSSPropertyResize:
        return consumeIdent(range, isKeywordValidForResize, state);
    case CSSPropertyID::CSSPropertyRotate:
        return consumeRotate(range, state);
    case CSSPropertyID::CSSPropertyRowGap:
        return CSSPropertyParsing::consumeRowGap(range, state);
    case CSSPropertyID::CSSPropertyRubyAlign:
        return consumeIdent(range, isKeywordValidForRubyAlign);
    case CSSPropertyID::CSSPropertyRubyOverhang:
        return consumeIdent(range, isKeywordValidForRubyOverhang);
    case CSSPropertyID::CSSPropertyRx:
        return consumeRx(range, state);
    case CSSPropertyID::CSSPropertyRy:
        return consumeRy(range, state);
    case CSSPropertyID::CSSPropertyScale:
        return consumeScale(range, state);
    case CSSPropertyID::CSSPropertyScrollBehavior:
        return consumeIdent(range, isKeywordValidForScrollBehavior);
    case CSSPropertyID::CSSPropertyScrollSnapAlign:
        return consumeScrollSnapAlign(range);
    case CSSPropertyID::CSSPropertyScrollSnapStop:
        return consumeIdent(range, isKeywordValidForScrollSnapStop);
    case CSSPropertyID::CSSPropertyScrollSnapType:
        return consumeScrollSnapType(range, state);
    case CSSPropertyID::CSSPropertyScrollTimelineAxis:
        return CSSPropertyParsing::consumeScrollTimelineAxis(range);
    case CSSPropertyID::CSSPropertyScrollTimelineName:
        return CSSPropertyParsing::consumeScrollTimelineName(range);
    case CSSPropertyID::CSSPropertyScrollbarColor:
        return consumeScrollbarColor(range, state);
    case CSSPropertyID::CSSPropertyScrollbarGutter:
        return consumeScrollbarGutter(range);
    case CSSPropertyID::CSSPropertyScrollbarWidth:
        return consumeIdent(range, isKeywordValidForScrollbarWidth);
    case CSSPropertyID::CSSPropertyShapeImageThreshold:
    case CSSPropertyID::CSSPropertyWebkitBoxFlex:
        return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, state);
    case CSSPropertyID::CSSPropertyShapeOutside:
        return consumeShapeOutside(range, state);
    case CSSPropertyID::CSSPropertyShapeRendering:
        return consumeIdent(range, isKeywordValidForShapeRendering);
    case CSSPropertyID::CSSPropertySpeakAs:
        return consumeSpeakAs(range);
    case CSSPropertyID::CSSPropertyStopOpacity:
        return consumeStopOpacity(range, state);
    case CSSPropertyID::CSSPropertyStroke:
        return consumeStroke(range, state);
    case CSSPropertyID::CSSPropertyStrokeDasharray:
        return consumeStrokeDasharray(range, state);
    case CSSPropertyID::CSSPropertyStrokeDashoffset:
        return consumeStrokeDashoffset(range, state);
    case CSSPropertyID::CSSPropertyStrokeLinecap:
        return consumeIdent(range, isKeywordValidForStrokeLinecap);
    case CSSPropertyID::CSSPropertyStrokeLinejoin:
        return consumeIdent(range, isKeywordValidForStrokeLinejoin);
    case CSSPropertyID::CSSPropertyStrokeOpacity:
        return consumeStrokeOpacity(range, state);
    case CSSPropertyID::CSSPropertyStrokeWidth:
        return consumeStrokeWidth(range, state);
    case CSSPropertyID::CSSPropertyTabSize:
        return consumeTabSize(range, state);
    case CSSPropertyID::CSSPropertyTableLayout:
        return consumeIdent(range, isKeywordValidForTableLayout);
    case CSSPropertyID::CSSPropertyTextAlign:
        return consumeIdent(range, isKeywordValidForTextAlign, state);
    case CSSPropertyID::CSSPropertyTextAlignLast:
        return consumeIdent(range, isKeywordValidForTextAlignLast);
    case CSSPropertyID::CSSPropertyTextAnchor:
        return consumeIdent(range, isKeywordValidForTextAnchor);
    case CSSPropertyID::CSSPropertyTextBoxEdge:
        return consumeTextBoxEdge(range, state);
    case CSSPropertyID::CSSPropertyTextBoxTrim:
        return consumeIdent(range, isKeywordValidForTextBoxTrim);
    case CSSPropertyID::CSSPropertyTextCombineUpright:
        return consumeIdent(range, isKeywordValidForTextCombineUpright);
    case CSSPropertyID::CSSPropertyTextDecorationLine:
        return CSSPropertyParsing::consumeTextDecorationLine(range);
    case CSSPropertyID::CSSPropertyTextDecorationSkipInk:
        return consumeIdent(range, isKeywordValidForTextDecorationSkipInk);
    case CSSPropertyID::CSSPropertyTextDecorationStyle:
        return consumeIdent(range, isKeywordValidForTextDecorationStyle);
    case CSSPropertyID::CSSPropertyTextDecorationThickness:
        return consumeTextDecorationThickness(range, state);
    case CSSPropertyID::CSSPropertyTextEmphasisPosition:
        return consumeTextEmphasisPosition(range);
    case CSSPropertyID::CSSPropertyTextEmphasisStyle:
        return consumeTextEmphasisStyle(range);
    case CSSPropertyID::CSSPropertyTextGroupAlign:
        return consumeIdent(range, isKeywordValidForTextGroupAlign);
    case CSSPropertyID::CSSPropertyTextIndent:
        return consumeTextIndent(range, state);
    case CSSPropertyID::CSSPropertyTextJustify:
        return consumeIdent(range, isKeywordValidForTextJustify);
    case CSSPropertyID::CSSPropertyTextOverflow:
        return consumeIdent(range, isKeywordValidForTextOverflow);
    case CSSPropertyID::CSSPropertyTextShadow:
        return consumeTextShadow(range, state);
    case CSSPropertyID::CSSPropertyTextTransform:
        return consumeTextTransform(range);
    case CSSPropertyID::CSSPropertyTextUnderlineOffset:
        return consumeTextUnderlineOffset(range, state);
    case CSSPropertyID::CSSPropertyTextUnderlinePosition:
        return consumeTextUnderlinePosition(range, state);
    case CSSPropertyID::CSSPropertyTextWrapMode:
        return consumeIdent(range, isKeywordValidForTextWrapMode);
    case CSSPropertyID::CSSPropertyTextWrapStyle:
        return consumeIdent(range, isKeywordValidForTextWrapStyle, state);
    case CSSPropertyID::CSSPropertyTimelineScope:
        return consumeTimelineScope(range);
    case CSSPropertyID::CSSPropertyTouchAction:
        return consumeTouchAction(range);
    case CSSPropertyID::CSSPropertyTransform:
        return CSSPropertyParsing::consumeTransform(range, state);
    case CSSPropertyID::CSSPropertyTransformBox:
        return consumeIdent(range, isKeywordValidForTransformBox);
    case CSSPropertyID::CSSPropertyTransformStyle:
        return consumeIdent(range, isKeywordValidForTransformStyle);
    case CSSPropertyID::CSSPropertyTransitionBehavior:
        return consumeTransitionBehavior(range);
    case CSSPropertyID::CSSPropertyTransitionDelay:
        return consumeTransitionDelay(range, state);
    case CSSPropertyID::CSSPropertyTransitionDuration:
        return consumeTransitionDuration(range, state);
    case CSSPropertyID::CSSPropertyTransitionProperty:
        return consumeTransitionProperty(range, state);
    case CSSPropertyID::CSSPropertyTransitionTimingFunction:
        return consumeTransitionTimingFunction(range, state);
    case CSSPropertyID::CSSPropertyTranslate:
        return consumeTranslate(range, state);
    case CSSPropertyID::CSSPropertyUnicodeBidi:
        return consumeIdent(range, isKeywordValidForUnicodeBidi);
    case CSSPropertyID::CSSPropertyVectorEffect:
        return consumeIdent(range, isKeywordValidForVectorEffect);
    case CSSPropertyID::CSSPropertyVerticalAlign:
        return consumeVerticalAlign(range, state);
    case CSSPropertyID::CSSPropertyViewTimelineAxis:
        return CSSPropertyParsing::consumeViewTimelineAxis(range);
    case CSSPropertyID::CSSPropertyViewTimelineInset:
        return consumeViewTimelineInset(range, state);
    case CSSPropertyID::CSSPropertyViewTimelineName:
        return CSSPropertyParsing::consumeViewTimelineName(range);
    case CSSPropertyID::CSSPropertyViewTransitionClass:
        return consumeViewTransitionClass(range);
    case CSSPropertyID::CSSPropertyViewTransitionName:
        return consumeViewTransitionName(range);
    case CSSPropertyID::CSSPropertyVisibility:
        return consumeIdent(range, isKeywordValidForVisibility);
    case CSSPropertyID::CSSPropertyWhiteSpaceCollapse:
        return consumeIdent(range, isKeywordValidForWhiteSpaceCollapse);
    case CSSPropertyID::CSSPropertyWillChange:
        return consumeWillChange(range, state);
    case CSSPropertyID::CSSPropertyWordBreak:
        return consumeIdent(range, isKeywordValidForWordBreak, state);
    case CSSPropertyID::CSSPropertyZIndex:
        return consumeZIndex(range, state);
    case CSSPropertyID::CSSPropertyAppleColorFilter:
        return consumeAppleColorFilter(range, state);
    case CSSPropertyID::CSSPropertyWebkitBackgroundClip:
        return consumeWebkitBackgroundClip(range);
    case CSSPropertyID::CSSPropertyWebkitBackgroundOrigin:
        return consumeWebkitBackgroundOrigin(range);
    case CSSPropertyID::CSSPropertyWebkitBorderHorizontalSpacing:
    case CSSPropertyID::CSSPropertyWebkitBorderVerticalSpacing:
        return CSSPrimitiveValueResolver<CSS::Length<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state, { .unitlessZeroLength = UnitlessZeroQuirk::Allow });
    case CSSPropertyID::CSSPropertyWebkitBoxAlign:
        return consumeIdent(range, isKeywordValidForWebkitBoxAlign);
    case CSSPropertyID::CSSPropertyWebkitBoxDecorationBreak:
        return consumeIdent(range, isKeywordValidForWebkitBoxDecorationBreak);
    case CSSPropertyID::CSSPropertyWebkitBoxDirection:
        return consumeIdent(range, isKeywordValidForWebkitBoxDirection);
    case CSSPropertyID::CSSPropertyWebkitBoxFlexGroup:
        return CSSPrimitiveValueResolver<CSS::Integer<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state);
    case CSSPropertyID::CSSPropertyWebkitBoxLines:
        return consumeIdent(range, isKeywordValidForWebkitBoxLines);
    case CSSPropertyID::CSSPropertyWebkitBoxOrient:
        return consumeIdent(range, isKeywordValidForWebkitBoxOrient);
    case CSSPropertyID::CSSPropertyWebkitBoxPack:
        return consumeIdent(range, isKeywordValidForWebkitBoxPack);
    case CSSPropertyID::CSSPropertyWebkitBoxReflect:
        return consumeWebkitBoxReflect(range, state);
    case CSSPropertyID::CSSPropertyWebkitBoxShadow:
        return consumeWebkitBoxShadow(range, state);
    case CSSPropertyID::CSSPropertyWebkitColumnAxis:
        return consumeIdent(range, isKeywordValidForWebkitColumnAxis);
    case CSSPropertyID::CSSPropertyWebkitColumnProgression:
        return consumeIdent(range, isKeywordValidForWebkitColumnProgression);
    case CSSPropertyID::CSSPropertyWebkitCursorVisibility:
        return consumeIdent(range, isKeywordValidForWebkitCursorVisibility);
    case CSSPropertyID::CSSPropertyWebkitHyphenateLimitAfter:
        return consumeWebkitHyphenateLimitAfter(range, state);
    case CSSPropertyID::CSSPropertyWebkitHyphenateLimitBefore:
        return consumeWebkitHyphenateLimitBefore(range, state);
    case CSSPropertyID::CSSPropertyWebkitHyphenateLimitLines:
        return consumeWebkitHyphenateLimitLines(range, state);
    case CSSPropertyID::CSSPropertyWebkitInitialLetter:
        return consumeWebkitInitialLetter(range, state);
    case CSSPropertyID::CSSPropertyWebkitLineAlign:
        return consumeIdent(range, isKeywordValidForWebkitLineAlign);
    case CSSPropertyID::CSSPropertyWebkitLineBoxContain:
        return consumeWebkitLineBoxContain(range);
    case CSSPropertyID::CSSPropertyWebkitLineClamp:
        return consumeWebkitLineClamp(range, state);
    case CSSPropertyID::CSSPropertyWebkitLineGrid:
        return consumeWebkitLineGrid(range);
    case CSSPropertyID::CSSPropertyWebkitLineSnap:
        return consumeIdent(range, isKeywordValidForWebkitLineSnap);
    case CSSPropertyID::CSSPropertyWebkitMarqueeDirection:
        return consumeIdent(range, isKeywordValidForWebkitMarqueeDirection);
    case CSSPropertyID::CSSPropertyWebkitMarqueeSpeed:
        return CSSPrimitiveValueResolver<CSS::Time<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state);
    case CSSPropertyID::CSSPropertyWebkitMarqueeStyle:
        return consumeIdent(range, isKeywordValidForWebkitMarqueeStyle);
    case CSSPropertyID::CSSPropertyWebkitMaskClip:
        return consumeWebkitMaskClip(range);
    case CSSPropertyID::CSSPropertyWebkitMaskComposite:
        return consumeWebkitMaskComposite(range);
    case CSSPropertyID::CSSPropertyWebkitMaskPositionX:
        return consumeWebkitMaskPositionX(range, state);
    case CSSPropertyID::CSSPropertyWebkitMaskPositionY:
        return consumeWebkitMaskPositionY(range, state);
    case CSSPropertyID::CSSPropertyWebkitMaskSourceType:
        return consumeWebkitMaskSourceType(range);
    case CSSPropertyID::CSSPropertyWebkitNbspMode:
        return consumeIdent(range, isKeywordValidForWebkitNbspMode);
    case CSSPropertyID::CSSPropertyWebkitRtlOrdering:
        return consumeIdent(range, isKeywordValidForWebkitRtlOrdering);
    case CSSPropertyID::CSSPropertyWebkitRubyPosition:
        return consumeWebkitRubyPosition(range);
    case CSSPropertyID::CSSPropertyWebkitTextCombine:
        return consumeIdent(range, isKeywordValidForWebkitTextCombine);
    case CSSPropertyID::CSSPropertyWebkitTextDecorationsInEffect:
        return consumeWebkitTextDecorationsInEffect(range);
    case CSSPropertyID::CSSPropertyWebkitTextSecurity:
        return consumeIdent(range, isKeywordValidForWebkitTextSecurity);
    case CSSPropertyID::CSSPropertyWebkitTextStrokeWidth:
        return consumeWebkitTextStrokeWidth(range, state);
    case CSSPropertyID::CSSPropertyWebkitUserDrag:
        return consumeIdent(range, isKeywordValidForWebkitUserDrag);
    case CSSPropertyID::CSSPropertyWebkitUserModify:
        return consumeIdent(range, isKeywordValidForWebkitUserModify);
    case CSSPropertyID::CSSPropertyWebkitUserSelect:
        return consumeIdent(range, isKeywordValidForWebkitUserSelect);
    case CSSPropertyID::CSSPropertyWordSpacing:
        return consumeWordSpacing(range, state);
    case CSSPropertyID::CSSPropertyBorderBottomLeftRadius:
        return consumeBorderBottomLeftRadius(range, state);
    case CSSPropertyID::CSSPropertyBorderBottomRightRadius:
        return consumeBorderBottomRightRadius(range, state);
    case CSSPropertyID::CSSPropertyBorderBottomStyle:
        return consumeIdent(range, isKeywordValidForBorderBottomStyle);
    case CSSPropertyID::CSSPropertyBorderBottomWidth:
        return consumeBorderBottomWidth(range, state);
    case CSSPropertyID::CSSPropertyBorderLeftStyle:
        return consumeIdent(range, isKeywordValidForBorderLeftStyle);
    case CSSPropertyID::CSSPropertyBorderLeftWidth:
        return consumeBorderLeftWidth(range, state);
    case CSSPropertyID::CSSPropertyBorderRightStyle:
        return consumeIdent(range, isKeywordValidForBorderRightStyle);
    case CSSPropertyID::CSSPropertyBorderRightWidth:
        return consumeBorderRightWidth(range, state);
    case CSSPropertyID::CSSPropertyBorderTopLeftRadius:
        return consumeBorderTopLeftRadius(range, state);
    case CSSPropertyID::CSSPropertyBorderTopRightRadius:
        return consumeBorderTopRightRadius(range, state);
    case CSSPropertyID::CSSPropertyBorderTopStyle:
        return consumeIdent(range, isKeywordValidForBorderTopStyle);
    case CSSPropertyID::CSSPropertyBorderTopWidth:
        return consumeBorderTopWidth(range, state);
    case CSSPropertyID::CSSPropertyBottom:
        return consumeBottom(range, state);
    case CSSPropertyID::CSSPropertyContainIntrinsicHeight:
        return CSSPropertyParsing::consumeContainIntrinsicHeight(range, state);
    case CSSPropertyID::CSSPropertyContainIntrinsicWidth:
        return CSSPropertyParsing::consumeContainIntrinsicWidth(range, state);
    case CSSPropertyID::CSSPropertyCornerBottomLeftShape:
        return consumeCornerBottomLeftShape(range, state);
    case CSSPropertyID::CSSPropertyCornerBottomRightShape:
        return consumeCornerBottomRightShape(range, state);
    case CSSPropertyID::CSSPropertyCornerTopLeftShape:
        return consumeCornerTopLeftShape(range, state);
    case CSSPropertyID::CSSPropertyCornerTopRightShape:
        return consumeCornerTopRightShape(range, state);
    case CSSPropertyID::CSSPropertyHeight:
        return consumeHeight(range, state);
    case CSSPropertyID::CSSPropertyLeft:
        return consumeLeft(range, state);
    case CSSPropertyID::CSSPropertyMarginBottom:
        return consumeMarginBottom(range, state);
    case CSSPropertyID::CSSPropertyMarginLeft:
        return consumeMarginLeft(range, state);
    case CSSPropertyID::CSSPropertyMarginRight:
        return consumeMarginRight(range, state);
    case CSSPropertyID::CSSPropertyMarginTop:
        return consumeMarginTop(range, state);
    case CSSPropertyID::CSSPropertyMaxHeight:
        return consumeMaxHeight(range, state);
    case CSSPropertyID::CSSPropertyMaxWidth:
        return consumeMaxWidth(range, state);
    case CSSPropertyID::CSSPropertyMinHeight:
        return consumeMinHeight(range, state);
    case CSSPropertyID::CSSPropertyMinWidth:
        return consumeMinWidth(range, state);
    case CSSPropertyID::CSSPropertyOverflowX:
        return consumeIdent(range, isKeywordValidForOverflowX);
    case CSSPropertyID::CSSPropertyOverflowY:
        return consumeIdent(range, isKeywordValidForOverflowY);
    case CSSPropertyID::CSSPropertyOverscrollBehaviorX:
        return consumeIdent(range, isKeywordValidForOverscrollBehaviorX);
    case CSSPropertyID::CSSPropertyOverscrollBehaviorY:
        return consumeIdent(range, isKeywordValidForOverscrollBehaviorY);
    case CSSPropertyID::CSSPropertyRight:
        return consumeRight(range, state);
    case CSSPropertyID::CSSPropertyScrollPaddingBottom:
        return consumeScrollPaddingBottom(range, state);
    case CSSPropertyID::CSSPropertyScrollPaddingLeft:
        return consumeScrollPaddingLeft(range, state);
    case CSSPropertyID::CSSPropertyScrollPaddingRight:
        return consumeScrollPaddingRight(range, state);
    case CSSPropertyID::CSSPropertyScrollPaddingTop:
        return consumeScrollPaddingTop(range, state);
    case CSSPropertyID::CSSPropertyTop:
        return consumeTop(range, state);
    case CSSPropertyID::CSSPropertyWidth:
        return consumeWidth(range, state);
    case CSSPropertyID::CSSPropertyBlockSize:
        return consumeBlockSize(range, state);
    case CSSPropertyID::CSSPropertyBorderBlockEndStyle:
        return consumeIdent(range, isKeywordValidForBorderBlockEndStyle);
    case CSSPropertyID::CSSPropertyBorderBlockEndWidth:
        return consumeBorderBlockEndWidth(range, state);
    case CSSPropertyID::CSSPropertyBorderBlockStartStyle:
        return consumeIdent(range, isKeywordValidForBorderBlockStartStyle);
    case CSSPropertyID::CSSPropertyBorderBlockStartWidth:
        return consumeBorderBlockStartWidth(range, state);
    case CSSPropertyID::CSSPropertyBorderEndEndRadius:
        return consumeBorderEndEndRadius(range, state);
    case CSSPropertyID::CSSPropertyBorderEndStartRadius:
        return consumeBorderEndStartRadius(range, state);
    case CSSPropertyID::CSSPropertyBorderInlineEndStyle:
        return consumeIdent(range, isKeywordValidForBorderInlineEndStyle);
    case CSSPropertyID::CSSPropertyBorderInlineEndWidth:
        return consumeBorderInlineEndWidth(range, state);
    case CSSPropertyID::CSSPropertyBorderInlineStartStyle:
        return consumeIdent(range, isKeywordValidForBorderInlineStartStyle);
    case CSSPropertyID::CSSPropertyBorderInlineStartWidth:
        return consumeBorderInlineStartWidth(range, state);
    case CSSPropertyID::CSSPropertyBorderStartEndRadius:
        return consumeBorderStartEndRadius(range, state);
    case CSSPropertyID::CSSPropertyBorderStartStartRadius:
        return consumeBorderStartStartRadius(range, state);
    case CSSPropertyID::CSSPropertyContainIntrinsicBlockSize:
        return consumeContainIntrinsicBlockSize(range, state);
    case CSSPropertyID::CSSPropertyContainIntrinsicInlineSize:
        return consumeContainIntrinsicInlineSize(range, state);
    case CSSPropertyID::CSSPropertyCornerEndEndShape:
        return consumeCornerEndEndShape(range, state);
    case CSSPropertyID::CSSPropertyCornerEndStartShape:
        return consumeCornerEndStartShape(range, state);
    case CSSPropertyID::CSSPropertyCornerStartEndShape:
        return CSSPropertyParsing::consumeCornerStartEndShape(range, state);
    case CSSPropertyID::CSSPropertyCornerStartStartShape:
        return consumeCornerStartStartShape(range, state);
    case CSSPropertyID::CSSPropertyInlineSize:
        return consumeInlineSize(range, state);
    case CSSPropertyID::CSSPropertyInsetBlockEnd:
        return consumeInsetBlockEnd(range, state);
    case CSSPropertyID::CSSPropertyInsetBlockStart:
        return consumeInsetBlockStart(range, state);
    case CSSPropertyID::CSSPropertyInsetInlineEnd:
        return consumeInsetInlineEnd(range, state);
    case CSSPropertyID::CSSPropertyInsetInlineStart:
        return consumeInsetInlineStart(range, state);
    case CSSPropertyID::CSSPropertyMarginBlockEnd:
        return consumeMarginBlockEnd(range, state);
    case CSSPropertyID::CSSPropertyMarginBlockStart:
        return consumeMarginBlockStart(range, state);
    case CSSPropertyID::CSSPropertyMarginInlineEnd:
        return consumeMarginInlineEnd(range, state);
    case CSSPropertyID::CSSPropertyMarginInlineStart:
        return consumeMarginInlineStart(range, state);
    case CSSPropertyID::CSSPropertyMaxBlockSize:
        return consumeMaxBlockSize(range, state);
    case CSSPropertyID::CSSPropertyMaxInlineSize:
        return consumeMaxInlineSize(range, state);
    case CSSPropertyID::CSSPropertyMinBlockSize:
        return consumeMinBlockSize(range, state);
    case CSSPropertyID::CSSPropertyMinInlineSize:
        return consumeMinInlineSize(range, state);
    case CSSPropertyID::CSSPropertyOverflowBlock:
        return consumeIdent(range, isKeywordValidForOverflowBlock);
    case CSSPropertyID::CSSPropertyOverflowInline:
        return consumeIdent(range, isKeywordValidForOverflowInline);
    case CSSPropertyID::CSSPropertyOverscrollBehaviorBlock:
        return consumeIdent(range, isKeywordValidForOverscrollBehaviorBlock);
    case CSSPropertyID::CSSPropertyOverscrollBehaviorInline:
        return consumeIdent(range, isKeywordValidForOverscrollBehaviorInline);
    case CSSPropertyID::CSSPropertyScrollPaddingBlockEnd:
        return consumeScrollPaddingBlockEnd(range, state);
    case CSSPropertyID::CSSPropertyScrollPaddingBlockStart:
        return consumeScrollPaddingBlockStart(range, state);
    case CSSPropertyID::CSSPropertyScrollPaddingInlineEnd:
        return consumeScrollPaddingInlineEnd(range, state);
    case CSSPropertyID::CSSPropertyScrollPaddingInlineStart:
        return consumeScrollPaddingInlineStart(range, state);
    default:
        return { };
    }
}

bool CSSPropertyParsing::parseStylePropertyShorthand(CSSParserTokenRange& range, CSSPropertyID id, CSS::PropertyParserState& state, CSS::PropertyParserResult& result)
{
    ASSERT(isShorthand(id));

    switch (id) {
    case CSSPropertyID::CSSPropertyAnimation:
        return CSS::PropertyParserCustom::consumeAnimationShorthand(range, state, animationShorthand(), result);
    case CSSPropertyID::CSSPropertyAnimationRange:
        if (!state.context.propertySettings.scrollDrivenAnimationsEnabled) {
            ASSERT_NOT_REACHED();
            return false;
        }
        return CSS::PropertyParserCustom::consumeAnimationRangeShorthand(range, state, animationRangeShorthand(), result);
    case CSSPropertyID::CSSPropertyBackground:
        return CSS::PropertyParserCustom::consumeBackgroundShorthand(range, state, backgroundShorthand(), result);
    case CSSPropertyID::CSSPropertyBackgroundPosition:
        return CSS::PropertyParserCustom::consumeBackgroundPositionShorthand(range, state, backgroundPositionShorthand(), result);
    case CSSPropertyID::CSSPropertyBlockStep:
        if (!state.context.propertySettings.cssRhythmicSizingEnabled) {
            ASSERT_NOT_REACHED();
            return false;
        }
        return CSS::PropertyParserCustom::consumeBlockStepShorthand(range, state, blockStepShorthand(), result);
    case CSSPropertyID::CSSPropertyBorder:
        return CSS::PropertyParserCustom::consumeBorderShorthand(range, state, borderShorthand(), result);
    case CSSPropertyID::CSSPropertyBorderBlock:
        return CSS::PropertyParserCustom::consumeBorderBlockShorthand(range, state, borderBlockShorthand(), result);
    case CSSPropertyID::CSSPropertyBorderBlockColor:
        return CSS::PropertyParserCustom::consumeCoalescingPairShorthand(range, state, borderBlockColorShorthand(), result);
    case CSSPropertyID::CSSPropertyBorderBlockEnd:
        return CSS::PropertyParserCustom::consumeStandardSpaceSeparatedShorthand(range, state, borderBlockEndShorthand(), result);
    case CSSPropertyID::CSSPropertyBorderBlockStart:
        return CSS::PropertyParserCustom::consumeStandardSpaceSeparatedShorthand(range, state, borderBlockStartShorthand(), result);
    case CSSPropertyID::CSSPropertyBorderBlockStyle:
        return CSS::PropertyParserCustom::consumeCoalescingPairShorthand(range, state, borderBlockStyleShorthand(), result);
    case CSSPropertyID::CSSPropertyBorderBlockWidth:
        return CSS::PropertyParserCustom::consumeCoalescingPairShorthand(range, state, borderBlockWidthShorthand(), result);
    case CSSPropertyID::CSSPropertyBorderBottom:
        return CSS::PropertyParserCustom::consumeStandardSpaceSeparatedShorthand(range, state, borderBottomShorthand(), result);
    case CSSPropertyID::CSSPropertyBorderColor:
        return CSS::PropertyParserCustom::consumeCoalescingQuadShorthand(range, state, borderColorShorthand(), result);
    case CSSPropertyID::CSSPropertyBorderImage:
        return CSS::PropertyParserCustom::consumeBorderImageShorthand(range, state, borderImageShorthand(), result);
    case CSSPropertyID::CSSPropertyBorderInline:
        return CSS::PropertyParserCustom::consumeBorderInlineShorthand(range, state, borderInlineShorthand(), result);
    case CSSPropertyID::CSSPropertyBorderInlineColor:
        return CSS::PropertyParserCustom::consumeCoalescingPairShorthand(range, state, borderInlineColorShorthand(), result);
    case CSSPropertyID::CSSPropertyBorderInlineEnd:
        return CSS::PropertyParserCustom::consumeStandardSpaceSeparatedShorthand(range, state, borderInlineEndShorthand(), result);
    case CSSPropertyID::CSSPropertyBorderInlineStart:
        return CSS::PropertyParserCustom::consumeStandardSpaceSeparatedShorthand(range, state, borderInlineStartShorthand(), result);
    case CSSPropertyID::CSSPropertyBorderInlineStyle:
        return CSS::PropertyParserCustom::consumeCoalescingPairShorthand(range, state, borderInlineStyleShorthand(), result);
    case CSSPropertyID::CSSPropertyBorderInlineWidth:
        return CSS::PropertyParserCustom::consumeCoalescingPairShorthand(range, state, borderInlineWidthShorthand(), result);
    case CSSPropertyID::CSSPropertyBorderLeft:
        return CSS::PropertyParserCustom::consumeStandardSpaceSeparatedShorthand(range, state, borderLeftShorthand(), result);
    case CSSPropertyID::CSSPropertyBorderRadius:
        return CSS::PropertyParserCustom::consumeBorderRadiusShorthand(range, state, borderRadiusShorthand(), result);
    case CSSPropertyID::CSSPropertyBorderRight:
        return CSS::PropertyParserCustom::consumeStandardSpaceSeparatedShorthand(range, state, borderRightShorthand(), result);
    case CSSPropertyID::CSSPropertyBorderSpacing:
        return CSS::PropertyParserCustom::consumeBorderSpacingShorthand(range, state, borderSpacingShorthand(), result);
    case CSSPropertyID::CSSPropertyBorderStyle:
        return CSS::PropertyParserCustom::consumeCoalescingQuadShorthand(range, state, borderStyleShorthand(), result);
    case CSSPropertyID::CSSPropertyBorderTop:
        return CSS::PropertyParserCustom::consumeStandardSpaceSeparatedShorthand(range, state, borderTopShorthand(), result);
    case CSSPropertyID::CSSPropertyBorderWidth:
        return CSS::PropertyParserCustom::consumeCoalescingQuadShorthand(range, state, borderWidthShorthand(), result);
    case CSSPropertyID::CSSPropertyColumnRule:
        return CSS::PropertyParserCustom::consumeStandardSpaceSeparatedShorthand(range, state, columnRuleShorthand(), result);
    case CSSPropertyID::CSSPropertyColumns:
        return CSS::PropertyParserCustom::consumeColumnsShorthand(range, state, columnsShorthand(), result);
    case CSSPropertyID::CSSPropertyContainIntrinsicSize:
        return CSS::PropertyParserCustom::consumeContainIntrinsicSizeShorthand(range, state, containIntrinsicSizeShorthand(), result);
    case CSSPropertyID::CSSPropertyContainer:
        return CSS::PropertyParserCustom::consumeContainerShorthand(range, state, containerShorthand(), result);
    case CSSPropertyID::CSSPropertyCornerShape:
        if (!state.context.propertySettings.cssCornerShapeEnabled) {
            ASSERT_NOT_REACHED();
            return false;
        }
        return CSS::PropertyParserCustom::consumeCoalescingQuadShorthand(range, state, cornerShapeShorthand(), result);
    case CSSPropertyID::CSSPropertyFlex:
        return CSS::PropertyParserCustom::consumeFlexShorthand(range, state, flexShorthand(), result);
    case CSSPropertyID::CSSPropertyFlexFlow:
        return CSS::PropertyParserCustom::consumeStandardSpaceSeparatedShorthand(range, state, flexFlowShorthand(), result);
    case CSSPropertyID::CSSPropertyFont:
        return CSS::PropertyParserCustom::consumeFontShorthand(range, state, fontShorthand(), result);
    case CSSPropertyID::CSSPropertyFontSynthesis:
        return CSS::PropertyParserCustom::consumeFontSynthesisShorthand(range, state, fontSynthesisShorthand(), result);
    case CSSPropertyID::CSSPropertyFontVariant:
        return CSS::PropertyParserCustom::consumeFontVariantShorthand(range, state, fontVariantShorthand(), result);
    case CSSPropertyID::CSSPropertyGap:
        return CSS::PropertyParserCustom::consumeAlignShorthand(range, state, gapShorthand(), result);
    case CSSPropertyID::CSSPropertyGrid:
        return CSS::PropertyParserCustom::consumeGridShorthand(range, state, gridShorthand(), result);
    case CSSPropertyID::CSSPropertyGridArea:
        return CSS::PropertyParserCustom::consumeGridAreaShorthand(range, state, gridAreaShorthand(), result);
    case CSSPropertyID::CSSPropertyGridColumn:
        return CSS::PropertyParserCustom::consumeGridItemPositionShorthand(range, state, gridColumnShorthand(), result);
    case CSSPropertyID::CSSPropertyGridRow:
        return CSS::PropertyParserCustom::consumeGridItemPositionShorthand(range, state, gridRowShorthand(), result);
    case CSSPropertyID::CSSPropertyGridTemplate:
        return CSS::PropertyParserCustom::consumeGridTemplateShorthand(range, state, gridTemplateShorthand(), result);
    case CSSPropertyID::CSSPropertyInset:
        return CSS::PropertyParserCustom::consumeCoalescingQuadShorthand(range, state, insetShorthand(), result);
    case CSSPropertyID::CSSPropertyInsetBlock:
        return CSS::PropertyParserCustom::consumeCoalescingPairShorthand(range, state, insetBlockShorthand(), result);
    case CSSPropertyID::CSSPropertyInsetInline:
        return CSS::PropertyParserCustom::consumeCoalescingPairShorthand(range, state, insetInlineShorthand(), result);
    case CSSPropertyID::CSSPropertyLineClamp:
        if (!state.context.propertySettings.cssLineClampEnabled) {
            ASSERT_NOT_REACHED();
            return false;
        }
        return CSS::PropertyParserCustom::consumeLineClampShorthand(range, state, lineClampShorthand(), result);
    case CSSPropertyID::CSSPropertyListStyle:
        return CSS::PropertyParserCustom::consumeListStyleShorthand(range, state, listStyleShorthand(), result);
    case CSSPropertyID::CSSPropertyMargin:
        return CSS::PropertyParserCustom::consumeCoalescingQuadShorthand(range, state, marginShorthand(), result);
    case CSSPropertyID::CSSPropertyMarginBlock:
        return CSS::PropertyParserCustom::consumeCoalescingPairShorthand(range, state, marginBlockShorthand(), result);
    case CSSPropertyID::CSSPropertyMarginInline:
        return CSS::PropertyParserCustom::consumeCoalescingPairShorthand(range, state, marginInlineShorthand(), result);
    case CSSPropertyID::CSSPropertyMarker:
        return CSS::PropertyParserCustom::consumeMarkerShorthand(range, state, markerShorthand(), result);
    case CSSPropertyID::CSSPropertyMask:
        return CSS::PropertyParserCustom::consumeMaskShorthand(range, state, maskShorthand(), result);
    case CSSPropertyID::CSSPropertyMaskBorder:
        return CSS::PropertyParserCustom::consumeMaskBorderShorthand(range, state, maskBorderShorthand(), result);
    case CSSPropertyID::CSSPropertyMaskPosition:
        return CSS::PropertyParserCustom::consumeMaskPositionShorthand(range, state, maskPositionShorthand(), result);
    case CSSPropertyID::CSSPropertyOffset:
        return CSS::PropertyParserCustom::consumeOffsetShorthand(range, state, offsetShorthand(), result);
    case CSSPropertyID::CSSPropertyOutline:
        return CSS::PropertyParserCustom::consumeStandardSpaceSeparatedShorthand(range, state, outlineShorthand(), result);
    case CSSPropertyID::CSSPropertyOverflow:
        return CSS::PropertyParserCustom::consumeOverflowShorthand(range, state, overflowShorthand(), result);
    case CSSPropertyID::CSSPropertyOverscrollBehavior:
        if (!state.context.propertySettings.overscrollBehaviorEnabled) {
            ASSERT_NOT_REACHED();
            return false;
        }
        return CSS::PropertyParserCustom::consumeOverscrollBehaviorShorthand(range, state, overscrollBehaviorShorthand(), result);
    case CSSPropertyID::CSSPropertyPadding:
        return CSS::PropertyParserCustom::consumeCoalescingQuadShorthand(range, state, paddingShorthand(), result);
    case CSSPropertyID::CSSPropertyPaddingBlock:
        return CSS::PropertyParserCustom::consumeCoalescingPairShorthand(range, state, paddingBlockShorthand(), result);
    case CSSPropertyID::CSSPropertyPaddingInline:
        return CSS::PropertyParserCustom::consumeCoalescingPairShorthand(range, state, paddingInlineShorthand(), result);
    case CSSPropertyID::CSSPropertyPageBreakAfter:
        return CSS::PropertyParserCustom::consumePageBreakAfterShorthand(range, state, pageBreakAfterShorthand(), result);
    case CSSPropertyID::CSSPropertyPageBreakBefore:
        return CSS::PropertyParserCustom::consumePageBreakBeforeShorthand(range, state, pageBreakBeforeShorthand(), result);
    case CSSPropertyID::CSSPropertyPageBreakInside:
        return CSS::PropertyParserCustom::consumePageBreakInsideShorthand(range, state, pageBreakInsideShorthand(), result);
    case CSSPropertyID::CSSPropertyPerspectiveOrigin:
        return CSS::PropertyParserCustom::consumePerspectiveOriginShorthand(range, state, perspectiveOriginShorthand(), result);
    case CSSPropertyID::CSSPropertyPlaceContent:
        return CSS::PropertyParserCustom::consumeAlignShorthand(range, state, placeContentShorthand(), result);
    case CSSPropertyID::CSSPropertyPlaceItems:
        return CSS::PropertyParserCustom::consumeAlignShorthand(range, state, placeItemsShorthand(), result);
    case CSSPropertyID::CSSPropertyPlaceSelf:
        return CSS::PropertyParserCustom::consumeAlignShorthand(range, state, placeSelfShorthand(), result);
    case CSSPropertyID::CSSPropertyPositionTry:
        if (!state.context.propertySettings.cssAnchorPositioningEnabled) {
            ASSERT_NOT_REACHED();
            return false;
        }
        return CSS::PropertyParserCustom::consumePositionTryShorthand(range, state, positionTryShorthand(), result);
    case CSSPropertyID::CSSPropertyScrollMargin:
        return CSS::PropertyParserCustom::consumeCoalescingQuadShorthand(range, state, scrollMarginShorthand(), result);
    case CSSPropertyID::CSSPropertyScrollMarginBlock:
        return CSS::PropertyParserCustom::consumeCoalescingPairShorthand(range, state, scrollMarginBlockShorthand(), result);
    case CSSPropertyID::CSSPropertyScrollMarginInline:
        return CSS::PropertyParserCustom::consumeCoalescingPairShorthand(range, state, scrollMarginInlineShorthand(), result);
    case CSSPropertyID::CSSPropertyScrollPadding:
        return CSS::PropertyParserCustom::consumeCoalescingQuadShorthand(range, state, scrollPaddingShorthand(), result);
    case CSSPropertyID::CSSPropertyScrollPaddingBlock:
        return CSS::PropertyParserCustom::consumeCoalescingPairShorthand(range, state, scrollPaddingBlockShorthand(), result);
    case CSSPropertyID::CSSPropertyScrollPaddingInline:
        return CSS::PropertyParserCustom::consumeCoalescingPairShorthand(range, state, scrollPaddingInlineShorthand(), result);
    case CSSPropertyID::CSSPropertyScrollTimeline:
        if (!state.context.propertySettings.scrollDrivenAnimationsEnabled) {
            ASSERT_NOT_REACHED();
            return false;
        }
        return CSS::PropertyParserCustom::consumeScrollTimelineShorthand(range, state, scrollTimelineShorthand(), result);
    case CSSPropertyID::CSSPropertyTextBox:
        if (!state.context.propertySettings.cssTextBoxTrimEnabled) {
            ASSERT_NOT_REACHED();
            return false;
        }
        return CSS::PropertyParserCustom::consumeTextBoxShorthand(range, state, textBoxShorthand(), result);
    case CSSPropertyID::CSSPropertyTextDecoration:
        return CSS::PropertyParserCustom::consumeSingleShorthand(range, state, textDecorationShorthand(), result);
    case CSSPropertyID::CSSPropertyTextDecorationSkip:
        return CSS::PropertyParserCustom::consumeTextDecorationSkipShorthand(range, state, textDecorationSkipShorthand(), result);
    case CSSPropertyID::CSSPropertyTextEmphasis:
        return CSS::PropertyParserCustom::consumeStandardSpaceSeparatedShorthand(range, state, textEmphasisShorthand(), result);
    case CSSPropertyID::CSSPropertyTextWrap:
        return CSS::PropertyParserCustom::consumeTextWrapShorthand(range, state, textWrapShorthand(), result);
    case CSSPropertyID::CSSPropertyTransformOrigin:
        return CSS::PropertyParserCustom::consumeTransformOriginShorthand(range, state, transformOriginShorthand(), result);
    case CSSPropertyID::CSSPropertyTransition:
        return CSS::PropertyParserCustom::consumeAnimationShorthand(range, state, transitionShorthandForParsing(), result);
    case CSSPropertyID::CSSPropertyViewTimeline:
        if (!state.context.propertySettings.scrollDrivenAnimationsEnabled) {
            ASSERT_NOT_REACHED();
            return false;
        }
        return CSS::PropertyParserCustom::consumeViewTimelineShorthand(range, state, viewTimelineShorthand(), result);
    case CSSPropertyID::CSSPropertyWhiteSpace:
        return CSS::PropertyParserCustom::consumeWhiteSpaceShorthand(range, state, whiteSpaceShorthand(), result);
    case CSSPropertyID::CSSPropertyWebkitBackgroundSize:
        return CSS::PropertyParserCustom::consumeWebkitBackgroundSizeShorthand(range, state, webkitBackgroundSizeShorthand(), result);
    case CSSPropertyID::CSSPropertyWebkitBorderImage:
        return CSS::PropertyParserCustom::consumeWebkitBorderImageShorthand(range, state, webkitBorderImageShorthand(), result);
    case CSSPropertyID::CSSPropertyWebkitBorderRadius:
        return CSS::PropertyParserCustom::consumeWebkitBorderRadiusShorthand(range, state, webkitBorderRadiusShorthand(), result);
    case CSSPropertyID::CSSPropertyWebkitColumnBreakAfter:
        return CSS::PropertyParserCustom::consumeWebkitColumnBreakAfterShorthand(range, state, webkitColumnBreakAfterShorthand(), result);
    case CSSPropertyID::CSSPropertyWebkitColumnBreakBefore:
        return CSS::PropertyParserCustom::consumeWebkitColumnBreakBeforeShorthand(range, state, webkitColumnBreakBeforeShorthand(), result);
    case CSSPropertyID::CSSPropertyWebkitColumnBreakInside:
        return CSS::PropertyParserCustom::consumeWebkitColumnBreakInsideShorthand(range, state, webkitColumnBreakInsideShorthand(), result);
    case CSSPropertyID::CSSPropertyWebkitMask:
        return CSS::PropertyParserCustom::consumeBackgroundShorthand(range, state, webkitMaskShorthand(), result);
    case CSSPropertyID::CSSPropertyWebkitMaskBoxImage:
        return CSS::PropertyParserCustom::consumeWebkitMaskBoxImageShorthand(range, state, webkitMaskBoxImageShorthand(), result);
    case CSSPropertyID::CSSPropertyWebkitMaskPosition:
        return CSS::PropertyParserCustom::consumeBackgroundPositionShorthand(range, state, webkitMaskPositionShorthand(), result);
    case CSSPropertyID::CSSPropertyWebkitPerspective:
        return CSS::PropertyParserCustom::consumeWebkitPerspectiveShorthand(range, state, webkitPerspectiveShorthand(), result);
    case CSSPropertyID::CSSPropertyWebkitTextDecoration:
        return CSS::PropertyParserCustom::consumeStandardSpaceSeparatedShorthand(range, state, webkitTextDecorationShorthand(), result);
    case CSSPropertyID::CSSPropertyWebkitTextOrientation:
        return CSS::PropertyParserCustom::consumeWebkitTextOrientationShorthand(range, state, webkitTextOrientationShorthand(), result);
    case CSSPropertyID::CSSPropertyWebkitTextStroke:
        return CSS::PropertyParserCustom::consumeStandardSpaceSeparatedShorthand(range, state, webkitTextStrokeShorthand(), result);
    default:
        return false;
    }
}

bool CSSPropertyParsing::isKeywordValidForStyleProperty(CSSPropertyID id, CSSValueID keyword, CSS::PropertyParserState& state)
{
    switch (id) {
    case CSSPropertyID::CSSPropertyRubyPosition:
        return isKeywordValidForRubyPosition(keyword);
    case CSSPropertyID::CSSPropertyWritingMode:
        return isKeywordValidForWritingMode(keyword, state);
    case CSSPropertyID::CSSPropertyDirection:
        return isKeywordValidForDirection(keyword);
    case CSSPropertyID::CSSPropertyFontFeatureSettings:
        return isKeywordValidForFontFeatureSettings(keyword);
    case CSSPropertyID::CSSPropertyFontKerning:
        return isKeywordValidForFontKerning(keyword);
    case CSSPropertyID::CSSPropertyFontOpticalSizing:
        return isKeywordValidForFontOpticalSizing(keyword);
    case CSSPropertyID::CSSPropertyFontPalette:
        return isKeywordValidForFontPalette(keyword);
    case CSSPropertyID::CSSPropertyFontSize:
        return isKeywordValidForFontSize(keyword);
    case CSSPropertyID::CSSPropertyFontSynthesisSmallCaps:
        return isKeywordValidForFontSynthesisSmallCaps(keyword);
    case CSSPropertyID::CSSPropertyFontSynthesisStyle:
        return isKeywordValidForFontSynthesisStyle(keyword);
    case CSSPropertyID::CSSPropertyFontSynthesisWeight:
        return isKeywordValidForFontSynthesisWeight(keyword);
    case CSSPropertyID::CSSPropertyFontVariantAlternates:
        return isKeywordValidForFontVariantAlternates(keyword);
    case CSSPropertyID::CSSPropertyFontVariantCaps:
        return isKeywordValidForFontVariantCaps(keyword);
    case CSSPropertyID::CSSPropertyFontVariantEastAsian:
        return isKeywordValidForFontVariantEastAsian(keyword);
    case CSSPropertyID::CSSPropertyFontVariantEmoji:
        return isKeywordValidForFontVariantEmoji(keyword);
    case CSSPropertyID::CSSPropertyFontVariantLigatures:
        return isKeywordValidForFontVariantLigatures(keyword);
    case CSSPropertyID::CSSPropertyFontVariantNumeric:
        return isKeywordValidForFontVariantNumeric(keyword);
    case CSSPropertyID::CSSPropertyFontVariantPosition:
        return isKeywordValidForFontVariantPosition(keyword);
    case CSSPropertyID::CSSPropertyFontVariationSettings:
        return isKeywordValidForFontVariationSettings(keyword);
    case CSSPropertyID::CSSPropertyFontWeight:
        return isKeywordValidForFontWeight(keyword);
    case CSSPropertyID::CSSPropertyFontWidth:
        return isKeywordValidForFontWidth(keyword);
    case CSSPropertyID::CSSPropertyTextOrientation:
        return isKeywordValidForTextOrientation(keyword);
    case CSSPropertyID::CSSPropertyTextRendering:
        return isKeywordValidForTextRendering(keyword);
    case CSSPropertyID::CSSPropertyZoom:
        return isKeywordValidForZoom(keyword);
    case CSSPropertyID::CSSPropertyWebkitFontSmoothing:
        return isKeywordValidForWebkitFontSmoothing(keyword);
    case CSSPropertyID::CSSPropertyWebkitLocale:
        return isKeywordValidForWebkitLocale(keyword);
    case CSSPropertyID::CSSPropertyWebkitTextZoom:
        return isKeywordValidForWebkitTextZoom(keyword);
    case CSSPropertyID::CSSPropertyLetterSpacing:
        return isKeywordValidForLetterSpacing(keyword);
    case CSSPropertyID::CSSPropertyTextAutospace:
        return isKeywordValidForTextAutospace(keyword);
    case CSSPropertyID::CSSPropertyTextSpacingTrim:
        return isKeywordValidForTextSpacingTrim(keyword);
    case CSSPropertyID::CSSPropertyAccentColor:
        return isKeywordValidForAccentColor(keyword);
    case CSSPropertyID::CSSPropertyAlignmentBaseline:
        return isKeywordValidForAlignmentBaseline(keyword);
    case CSSPropertyID::CSSPropertyAnchorName:
        return isKeywordValidForAnchorName(keyword);
    case CSSPropertyID::CSSPropertyAnchorScope:
        return isKeywordValidForAnchorScope(keyword);
    case CSSPropertyID::CSSPropertyAppearance:
        return isKeywordValidForAppearance(keyword, state);
    case CSSPropertyID::CSSPropertyBackfaceVisibility:
        return isKeywordValidForBackfaceVisibility(keyword);
    case CSSPropertyID::CSSPropertyBaselineShift:
        return isKeywordValidForBaselineShift(keyword);
    case CSSPropertyID::CSSPropertyBlockEllipsis:
        return isKeywordValidForBlockEllipsis(keyword);
    case CSSPropertyID::CSSPropertyBlockStepAlign:
        return isKeywordValidForBlockStepAlign(keyword);
    case CSSPropertyID::CSSPropertyBlockStepInsert:
        return isKeywordValidForBlockStepInsert(keyword);
    case CSSPropertyID::CSSPropertyBlockStepRound:
        return isKeywordValidForBlockStepRound(keyword);
    case CSSPropertyID::CSSPropertyBlockStepSize:
        return isKeywordValidForBlockStepSize(keyword);
    case CSSPropertyID::CSSPropertyBorderCollapse:
        return isKeywordValidForBorderCollapse(keyword);
    case CSSPropertyID::CSSPropertyBorderImageSource:
        return isKeywordValidForBorderImageSource(keyword);
    case CSSPropertyID::CSSPropertyBoxSizing:
        return isKeywordValidForBoxSizing(keyword);
    case CSSPropertyID::CSSPropertyBreakAfter:
        return isKeywordValidForBreakAfter(keyword);
    case CSSPropertyID::CSSPropertyBreakBefore:
        return isKeywordValidForBreakBefore(keyword);
    case CSSPropertyID::CSSPropertyBreakInside:
        return isKeywordValidForBreakInside(keyword);
    case CSSPropertyID::CSSPropertyBufferedRendering:
        return isKeywordValidForBufferedRendering(keyword);
    case CSSPropertyID::CSSPropertyCaptionSide:
        return isKeywordValidForCaptionSide(keyword);
    case CSSPropertyID::CSSPropertyCaretColor:
        return isKeywordValidForCaretColor(keyword);
    case CSSPropertyID::CSSPropertyClear:
        return isKeywordValidForClear(keyword);
    case CSSPropertyID::CSSPropertyClip:
        return isKeywordValidForClip(keyword);
    case CSSPropertyID::CSSPropertyClipRule:
        return isKeywordValidForClipRule(keyword);
    case CSSPropertyID::CSSPropertyColorInterpolation:
        return isKeywordValidForColorInterpolation(keyword);
    case CSSPropertyID::CSSPropertyColorInterpolationFilters:
        return isKeywordValidForColorInterpolationFilters(keyword);
    case CSSPropertyID::CSSPropertyColumnCount:
        return isKeywordValidForColumnCount(keyword);
    case CSSPropertyID::CSSPropertyColumnFill:
        return isKeywordValidForColumnFill(keyword);
    case CSSPropertyID::CSSPropertyColumnGap:
        return isKeywordValidForColumnGap(keyword);
    case CSSPropertyID::CSSPropertyColumnRuleStyle:
        return isKeywordValidForColumnRuleStyle(keyword);
    case CSSPropertyID::CSSPropertyColumnRuleWidth:
        return isKeywordValidForColumnRuleWidth(keyword);
    case CSSPropertyID::CSSPropertyColumnSpan:
        return isKeywordValidForColumnSpan(keyword);
    case CSSPropertyID::CSSPropertyColumnWidth:
        return isKeywordValidForColumnWidth(keyword);
    case CSSPropertyID::CSSPropertyContain:
        return isKeywordValidForContain(keyword);
    case CSSPropertyID::CSSPropertyContainerName:
        return isKeywordValidForContainerName(keyword);
    case CSSPropertyID::CSSPropertyContainerType:
        return isKeywordValidForContainerType(keyword);
    case CSSPropertyID::CSSPropertyContentVisibility:
        return isKeywordValidForContentVisibility(keyword);
    case CSSPropertyID::CSSPropertyContinue:
        return isKeywordValidForContinue(keyword);
    case CSSPropertyID::CSSPropertyD:
        return isKeywordValidForD(keyword);
    case CSSPropertyID::CSSPropertyDominantBaseline:
        return isKeywordValidForDominantBaseline(keyword);
    case CSSPropertyID::CSSPropertyEmptyCells:
        return isKeywordValidForEmptyCells(keyword);
    case CSSPropertyID::CSSPropertyFieldSizing:
        return isKeywordValidForFieldSizing(keyword);
    case CSSPropertyID::CSSPropertyFill:
        return isKeywordValidForFill(keyword);
    case CSSPropertyID::CSSPropertyFillRule:
        return isKeywordValidForFillRule(keyword);
    case CSSPropertyID::CSSPropertyFlexBasis:
        return isKeywordValidForFlexBasis(keyword);
    case CSSPropertyID::CSSPropertyFlexDirection:
        return isKeywordValidForFlexDirection(keyword);
    case CSSPropertyID::CSSPropertyFlexWrap:
        return isKeywordValidForFlexWrap(keyword);
    case CSSPropertyID::CSSPropertyFloat:
        return isKeywordValidForFloat(keyword);
    case CSSPropertyID::CSSPropertyGlyphOrientationVertical:
        return isKeywordValidForGlyphOrientationVertical(keyword);
    case CSSPropertyID::CSSPropertyHangingPunctuation:
        return isKeywordValidForHangingPunctuation(keyword);
    case CSSPropertyID::CSSPropertyHyphenateCharacter:
        return isKeywordValidForHyphenateCharacter(keyword);
    case CSSPropertyID::CSSPropertyHyphens:
        return isKeywordValidForHyphens(keyword);
    case CSSPropertyID::CSSPropertyImageOrientation:
        return isKeywordValidForImageOrientation(keyword);
    case CSSPropertyID::CSSPropertyImageRendering:
        return isKeywordValidForImageRendering(keyword);
    case CSSPropertyID::CSSPropertyInputSecurity:
        return isKeywordValidForInputSecurity(keyword);
    case CSSPropertyID::CSSPropertyIsolation:
        return isKeywordValidForIsolation(keyword);
    case CSSPropertyID::CSSPropertyLineBreak:
        return isKeywordValidForLineBreak(keyword);
    case CSSPropertyID::CSSPropertyLineHeight:
        return isKeywordValidForLineHeight(keyword);
    case CSSPropertyID::CSSPropertyListStyleImage:
        return isKeywordValidForListStyleImage(keyword);
    case CSSPropertyID::CSSPropertyListStylePosition:
        return isKeywordValidForListStylePosition(keyword);
    case CSSPropertyID::CSSPropertyListStyleType:
        return isKeywordValidForListStyleType(keyword);
    case CSSPropertyID::CSSPropertyMarkerEnd:
        return isKeywordValidForMarkerEnd(keyword);
    case CSSPropertyID::CSSPropertyMarkerMid:
        return isKeywordValidForMarkerMid(keyword);
    case CSSPropertyID::CSSPropertyMarkerStart:
        return isKeywordValidForMarkerStart(keyword);
    case CSSPropertyID::CSSPropertyMaskBorderSource:
        return isKeywordValidForMaskBorderSource(keyword);
    case CSSPropertyID::CSSPropertyMaskType:
        return isKeywordValidForMaskType(keyword);
    case CSSPropertyID::CSSPropertyMathStyle:
        return isKeywordValidForMathStyle(keyword);
    case CSSPropertyID::CSSPropertyMaxLines:
        return isKeywordValidForMaxLines(keyword);
    case CSSPropertyID::CSSPropertyMixBlendMode:
        return isKeywordValidForMixBlendMode(keyword);
    case CSSPropertyID::CSSPropertyObjectFit:
        return isKeywordValidForObjectFit(keyword);
    case CSSPropertyID::CSSPropertyOffsetAnchor:
        return isKeywordValidForOffsetAnchor(keyword);
    case CSSPropertyID::CSSPropertyOffsetPosition:
        return isKeywordValidForOffsetPosition(keyword);
    case CSSPropertyID::CSSPropertyOutlineColor:
        return isKeywordValidForOutlineColor(keyword);
    case CSSPropertyID::CSSPropertyOutlineStyle:
        return isKeywordValidForOutlineStyle(keyword);
    case CSSPropertyID::CSSPropertyOutlineWidth:
        return isKeywordValidForOutlineWidth(keyword);
    case CSSPropertyID::CSSPropertyOverflowAnchor:
        return isKeywordValidForOverflowAnchor(keyword);
    case CSSPropertyID::CSSPropertyOverflowWrap:
        return isKeywordValidForOverflowWrap(keyword);
    case CSSPropertyID::CSSPropertyPage:
        return isKeywordValidForPage(keyword);
    case CSSPropertyID::CSSPropertyPerspective:
        return isKeywordValidForPerspective(keyword);
    case CSSPropertyID::CSSPropertyPointerEvents:
        return isKeywordValidForPointerEvents(keyword);
    case CSSPropertyID::CSSPropertyPosition:
        return isKeywordValidForPosition(keyword);
    case CSSPropertyID::CSSPropertyPositionAnchor:
        return isKeywordValidForPositionAnchor(keyword);
    case CSSPropertyID::CSSPropertyPositionTryOrder:
        return isKeywordValidForPositionTryOrder(keyword);
    case CSSPropertyID::CSSPropertyPositionVisibility:
        return isKeywordValidForPositionVisibility(keyword);
    case CSSPropertyID::CSSPropertyPrintColorAdjust:
        return isKeywordValidForPrintColorAdjust(keyword);
    case CSSPropertyID::CSSPropertyResize:
        return isKeywordValidForResize(keyword, state);
    case CSSPropertyID::CSSPropertyRowGap:
        return isKeywordValidForRowGap(keyword);
    case CSSPropertyID::CSSPropertyRubyAlign:
        return isKeywordValidForRubyAlign(keyword);
    case CSSPropertyID::CSSPropertyRubyOverhang:
        return isKeywordValidForRubyOverhang(keyword);
    case CSSPropertyID::CSSPropertyRx:
        return isKeywordValidForRx(keyword);
    case CSSPropertyID::CSSPropertyRy:
        return isKeywordValidForRy(keyword);
    case CSSPropertyID::CSSPropertyScrollBehavior:
        return isKeywordValidForScrollBehavior(keyword);
    case CSSPropertyID::CSSPropertyScrollSnapStop:
        return isKeywordValidForScrollSnapStop(keyword);
    case CSSPropertyID::CSSPropertyScrollbarGutter:
        return isKeywordValidForScrollbarGutter(keyword);
    case CSSPropertyID::CSSPropertyScrollbarWidth:
        return isKeywordValidForScrollbarWidth(keyword);
    case CSSPropertyID::CSSPropertyShapeRendering:
        return isKeywordValidForShapeRendering(keyword);
    case CSSPropertyID::CSSPropertySpeakAs:
        return isKeywordValidForSpeakAs(keyword);
    case CSSPropertyID::CSSPropertyStroke:
        return isKeywordValidForStroke(keyword);
    case CSSPropertyID::CSSPropertyStrokeLinecap:
        return isKeywordValidForStrokeLinecap(keyword);
    case CSSPropertyID::CSSPropertyStrokeLinejoin:
        return isKeywordValidForStrokeLinejoin(keyword);
    case CSSPropertyID::CSSPropertyTableLayout:
        return isKeywordValidForTableLayout(keyword);
    case CSSPropertyID::CSSPropertyTextAlign:
        return isKeywordValidForTextAlign(keyword, state);
    case CSSPropertyID::CSSPropertyTextAlignLast:
        return isKeywordValidForTextAlignLast(keyword);
    case CSSPropertyID::CSSPropertyTextAnchor:
        return isKeywordValidForTextAnchor(keyword);
    case CSSPropertyID::CSSPropertyTextBoxTrim:
        return isKeywordValidForTextBoxTrim(keyword);
    case CSSPropertyID::CSSPropertyTextCombineUpright:
        return isKeywordValidForTextCombineUpright(keyword);
    case CSSPropertyID::CSSPropertyTextDecorationLine:
        return isKeywordValidForTextDecorationLine(keyword);
    case CSSPropertyID::CSSPropertyTextDecorationSkipInk:
        return isKeywordValidForTextDecorationSkipInk(keyword);
    case CSSPropertyID::CSSPropertyTextDecorationStyle:
        return isKeywordValidForTextDecorationStyle(keyword);
    case CSSPropertyID::CSSPropertyTextDecorationThickness:
        return isKeywordValidForTextDecorationThickness(keyword);
    case CSSPropertyID::CSSPropertyTextEmphasisStyle:
        return isKeywordValidForTextEmphasisStyle(keyword);
    case CSSPropertyID::CSSPropertyTextGroupAlign:
        return isKeywordValidForTextGroupAlign(keyword);
    case CSSPropertyID::CSSPropertyTextJustify:
        return isKeywordValidForTextJustify(keyword);
    case CSSPropertyID::CSSPropertyTextOverflow:
        return isKeywordValidForTextOverflow(keyword);
    case CSSPropertyID::CSSPropertyTextTransform:
        return isKeywordValidForTextTransform(keyword);
    case CSSPropertyID::CSSPropertyTextUnderlineOffset:
        return isKeywordValidForTextUnderlineOffset(keyword);
    case CSSPropertyID::CSSPropertyTextUnderlinePosition:
        return isKeywordValidForTextUnderlinePosition(keyword);
    case CSSPropertyID::CSSPropertyTextWrapMode:
        return isKeywordValidForTextWrapMode(keyword);
    case CSSPropertyID::CSSPropertyTextWrapStyle:
        return isKeywordValidForTextWrapStyle(keyword, state);
    case CSSPropertyID::CSSPropertyTimelineScope:
        return isKeywordValidForTimelineScope(keyword);
    case CSSPropertyID::CSSPropertyTouchAction:
        return isKeywordValidForTouchAction(keyword);
    case CSSPropertyID::CSSPropertyTransform:
        return isKeywordValidForTransform(keyword);
    case CSSPropertyID::CSSPropertyTransformBox:
        return isKeywordValidForTransformBox(keyword);
    case CSSPropertyID::CSSPropertyTransformStyle:
        return isKeywordValidForTransformStyle(keyword);
    case CSSPropertyID::CSSPropertyTransitionProperty:
        return isKeywordValidForTransitionProperty(keyword);
    case CSSPropertyID::CSSPropertyUnicodeBidi:
        return isKeywordValidForUnicodeBidi(keyword);
    case CSSPropertyID::CSSPropertyVectorEffect:
        return isKeywordValidForVectorEffect(keyword);
    case CSSPropertyID::CSSPropertyVerticalAlign:
        return isKeywordValidForVerticalAlign(keyword);
    case CSSPropertyID::CSSPropertyViewTransitionClass:
        return isKeywordValidForViewTransitionClass(keyword);
    case CSSPropertyID::CSSPropertyViewTransitionName:
        return isKeywordValidForViewTransitionName(keyword);
    case CSSPropertyID::CSSPropertyVisibility:
        return isKeywordValidForVisibility(keyword);
    case CSSPropertyID::CSSPropertyWhiteSpaceCollapse:
        return isKeywordValidForWhiteSpaceCollapse(keyword);
    case CSSPropertyID::CSSPropertyWordBreak:
        return isKeywordValidForWordBreak(keyword, state);
    case CSSPropertyID::CSSPropertyZIndex:
        return isKeywordValidForZIndex(keyword);
    case CSSPropertyID::CSSPropertyWebkitBoxAlign:
        return isKeywordValidForWebkitBoxAlign(keyword);
    case CSSPropertyID::CSSPropertyWebkitBoxDecorationBreak:
        return isKeywordValidForWebkitBoxDecorationBreak(keyword);
    case CSSPropertyID::CSSPropertyWebkitBoxDirection:
        return isKeywordValidForWebkitBoxDirection(keyword);
    case CSSPropertyID::CSSPropertyWebkitBoxLines:
        return isKeywordValidForWebkitBoxLines(keyword);
    case CSSPropertyID::CSSPropertyWebkitBoxOrient:
        return isKeywordValidForWebkitBoxOrient(keyword);
    case CSSPropertyID::CSSPropertyWebkitBoxPack:
        return isKeywordValidForWebkitBoxPack(keyword);
    case CSSPropertyID::CSSPropertyWebkitColumnAxis:
        return isKeywordValidForWebkitColumnAxis(keyword);
    case CSSPropertyID::CSSPropertyWebkitColumnProgression:
        return isKeywordValidForWebkitColumnProgression(keyword);
    case CSSPropertyID::CSSPropertyWebkitCursorVisibility:
        return isKeywordValidForWebkitCursorVisibility(keyword);
    case CSSPropertyID::CSSPropertyWebkitHyphenateLimitAfter:
        return isKeywordValidForWebkitHyphenateLimitAfter(keyword);
    case CSSPropertyID::CSSPropertyWebkitHyphenateLimitBefore:
        return isKeywordValidForWebkitHyphenateLimitBefore(keyword);
    case CSSPropertyID::CSSPropertyWebkitHyphenateLimitLines:
        return isKeywordValidForWebkitHyphenateLimitLines(keyword);
    case CSSPropertyID::CSSPropertyWebkitInitialLetter:
        return isKeywordValidForWebkitInitialLetter(keyword);
    case CSSPropertyID::CSSPropertyWebkitLineAlign:
        return isKeywordValidForWebkitLineAlign(keyword);
    case CSSPropertyID::CSSPropertyWebkitLineBoxContain:
        return isKeywordValidForWebkitLineBoxContain(keyword);
    case CSSPropertyID::CSSPropertyWebkitLineClamp:
        return isKeywordValidForWebkitLineClamp(keyword);
    case CSSPropertyID::CSSPropertyWebkitLineGrid:
        return isKeywordValidForWebkitLineGrid(keyword);
    case CSSPropertyID::CSSPropertyWebkitLineSnap:
        return isKeywordValidForWebkitLineSnap(keyword);
    case CSSPropertyID::CSSPropertyWebkitMarqueeDirection:
        return isKeywordValidForWebkitMarqueeDirection(keyword);
    case CSSPropertyID::CSSPropertyWebkitMarqueeStyle:
        return isKeywordValidForWebkitMarqueeStyle(keyword);
    case CSSPropertyID::CSSPropertyWebkitNbspMode:
        return isKeywordValidForWebkitNbspMode(keyword);
    case CSSPropertyID::CSSPropertyWebkitRtlOrdering:
        return isKeywordValidForWebkitRtlOrdering(keyword);
    case CSSPropertyID::CSSPropertyWebkitRubyPosition:
        return isKeywordValidForWebkitRubyPosition(keyword);
    case CSSPropertyID::CSSPropertyWebkitTextCombine:
        return isKeywordValidForWebkitTextCombine(keyword);
    case CSSPropertyID::CSSPropertyWebkitTextDecorationsInEffect:
        return isKeywordValidForWebkitTextDecorationsInEffect(keyword);
    case CSSPropertyID::CSSPropertyWebkitTextSecurity:
        return isKeywordValidForWebkitTextSecurity(keyword);
    case CSSPropertyID::CSSPropertyWebkitTextStrokeWidth:
        return isKeywordValidForWebkitTextStrokeWidth(keyword);
    case CSSPropertyID::CSSPropertyWebkitUserDrag:
        return isKeywordValidForWebkitUserDrag(keyword);
    case CSSPropertyID::CSSPropertyWebkitUserModify:
        return isKeywordValidForWebkitUserModify(keyword);
    case CSSPropertyID::CSSPropertyWebkitUserSelect:
        return isKeywordValidForWebkitUserSelect(keyword);
    case CSSPropertyID::CSSPropertyWordSpacing:
        return isKeywordValidForWordSpacing(keyword);
    case CSSPropertyID::CSSPropertyBorderBottomStyle:
        return isKeywordValidForBorderBottomStyle(keyword);
    case CSSPropertyID::CSSPropertyBorderBottomWidth:
        return isKeywordValidForBorderBottomWidth(keyword);
    case CSSPropertyID::CSSPropertyBorderLeftStyle:
        return isKeywordValidForBorderLeftStyle(keyword);
    case CSSPropertyID::CSSPropertyBorderLeftWidth:
        return isKeywordValidForBorderLeftWidth(keyword);
    case CSSPropertyID::CSSPropertyBorderRightStyle:
        return isKeywordValidForBorderRightStyle(keyword);
    case CSSPropertyID::CSSPropertyBorderRightWidth:
        return isKeywordValidForBorderRightWidth(keyword);
    case CSSPropertyID::CSSPropertyBorderTopStyle:
        return isKeywordValidForBorderTopStyle(keyword);
    case CSSPropertyID::CSSPropertyBorderTopWidth:
        return isKeywordValidForBorderTopWidth(keyword);
    case CSSPropertyID::CSSPropertyBottom:
        return isKeywordValidForBottom(keyword);
    case CSSPropertyID::CSSPropertyCornerBottomLeftShape:
        return isKeywordValidForCornerBottomLeftShape(keyword);
    case CSSPropertyID::CSSPropertyCornerBottomRightShape:
        return isKeywordValidForCornerBottomRightShape(keyword);
    case CSSPropertyID::CSSPropertyCornerTopLeftShape:
        return isKeywordValidForCornerTopLeftShape(keyword);
    case CSSPropertyID::CSSPropertyCornerTopRightShape:
        return isKeywordValidForCornerTopRightShape(keyword);
    case CSSPropertyID::CSSPropertyHeight:
        return isKeywordValidForHeight(keyword);
    case CSSPropertyID::CSSPropertyLeft:
        return isKeywordValidForLeft(keyword);
    case CSSPropertyID::CSSPropertyMarginBottom:
        return isKeywordValidForMarginBottom(keyword);
    case CSSPropertyID::CSSPropertyMarginLeft:
        return isKeywordValidForMarginLeft(keyword);
    case CSSPropertyID::CSSPropertyMarginRight:
        return isKeywordValidForMarginRight(keyword);
    case CSSPropertyID::CSSPropertyMarginTop:
        return isKeywordValidForMarginTop(keyword);
    case CSSPropertyID::CSSPropertyMaxHeight:
        return isKeywordValidForMaxHeight(keyword);
    case CSSPropertyID::CSSPropertyMaxWidth:
        return isKeywordValidForMaxWidth(keyword);
    case CSSPropertyID::CSSPropertyMinHeight:
        return isKeywordValidForMinHeight(keyword);
    case CSSPropertyID::CSSPropertyMinWidth:
        return isKeywordValidForMinWidth(keyword);
    case CSSPropertyID::CSSPropertyOverflowX:
        return isKeywordValidForOverflowX(keyword);
    case CSSPropertyID::CSSPropertyOverflowY:
        return isKeywordValidForOverflowY(keyword);
    case CSSPropertyID::CSSPropertyOverscrollBehaviorX:
        return isKeywordValidForOverscrollBehaviorX(keyword);
    case CSSPropertyID::CSSPropertyOverscrollBehaviorY:
        return isKeywordValidForOverscrollBehaviorY(keyword);
    case CSSPropertyID::CSSPropertyRight:
        return isKeywordValidForRight(keyword);
    case CSSPropertyID::CSSPropertyScrollPaddingBottom:
        return isKeywordValidForScrollPaddingBottom(keyword);
    case CSSPropertyID::CSSPropertyScrollPaddingLeft:
        return isKeywordValidForScrollPaddingLeft(keyword);
    case CSSPropertyID::CSSPropertyScrollPaddingRight:
        return isKeywordValidForScrollPaddingRight(keyword);
    case CSSPropertyID::CSSPropertyScrollPaddingTop:
        return isKeywordValidForScrollPaddingTop(keyword);
    case CSSPropertyID::CSSPropertyTop:
        return isKeywordValidForTop(keyword);
    case CSSPropertyID::CSSPropertyWidth:
        return isKeywordValidForWidth(keyword);
    case CSSPropertyID::CSSPropertyBlockSize:
        return isKeywordValidForBlockSize(keyword);
    case CSSPropertyID::CSSPropertyBorderBlockEndStyle:
        return isKeywordValidForBorderBlockEndStyle(keyword);
    case CSSPropertyID::CSSPropertyBorderBlockEndWidth:
        return isKeywordValidForBorderBlockEndWidth(keyword);
    case CSSPropertyID::CSSPropertyBorderBlockStartStyle:
        return isKeywordValidForBorderBlockStartStyle(keyword);
    case CSSPropertyID::CSSPropertyBorderBlockStartWidth:
        return isKeywordValidForBorderBlockStartWidth(keyword);
    case CSSPropertyID::CSSPropertyBorderInlineEndStyle:
        return isKeywordValidForBorderInlineEndStyle(keyword);
    case CSSPropertyID::CSSPropertyBorderInlineEndWidth:
        return isKeywordValidForBorderInlineEndWidth(keyword);
    case CSSPropertyID::CSSPropertyBorderInlineStartStyle:
        return isKeywordValidForBorderInlineStartStyle(keyword);
    case CSSPropertyID::CSSPropertyBorderInlineStartWidth:
        return isKeywordValidForBorderInlineStartWidth(keyword);
    case CSSPropertyID::CSSPropertyCornerEndEndShape:
        return isKeywordValidForCornerEndEndShape(keyword);
    case CSSPropertyID::CSSPropertyCornerEndStartShape:
        return isKeywordValidForCornerEndStartShape(keyword);
    case CSSPropertyID::CSSPropertyCornerStartEndShape:
        return isKeywordValidForCornerStartEndShape(keyword);
    case CSSPropertyID::CSSPropertyCornerStartStartShape:
        return isKeywordValidForCornerStartStartShape(keyword);
    case CSSPropertyID::CSSPropertyInlineSize:
        return isKeywordValidForInlineSize(keyword);
    case CSSPropertyID::CSSPropertyInsetBlockEnd:
        return isKeywordValidForInsetBlockEnd(keyword);
    case CSSPropertyID::CSSPropertyInsetBlockStart:
        return isKeywordValidForInsetBlockStart(keyword);
    case CSSPropertyID::CSSPropertyInsetInlineEnd:
        return isKeywordValidForInsetInlineEnd(keyword);
    case CSSPropertyID::CSSPropertyInsetInlineStart:
        return isKeywordValidForInsetInlineStart(keyword);
    case CSSPropertyID::CSSPropertyMarginBlockEnd:
        return isKeywordValidForMarginBlockEnd(keyword);
    case CSSPropertyID::CSSPropertyMarginBlockStart:
        return isKeywordValidForMarginBlockStart(keyword);
    case CSSPropertyID::CSSPropertyMarginInlineEnd:
        return isKeywordValidForMarginInlineEnd(keyword);
    case CSSPropertyID::CSSPropertyMarginInlineStart:
        return isKeywordValidForMarginInlineStart(keyword);
    case CSSPropertyID::CSSPropertyMaxBlockSize:
        return isKeywordValidForMaxBlockSize(keyword);
    case CSSPropertyID::CSSPropertyMaxInlineSize:
        return isKeywordValidForMaxInlineSize(keyword);
    case CSSPropertyID::CSSPropertyMinBlockSize:
        return isKeywordValidForMinBlockSize(keyword);
    case CSSPropertyID::CSSPropertyMinInlineSize:
        return isKeywordValidForMinInlineSize(keyword);
    case CSSPropertyID::CSSPropertyOverflowBlock:
        return isKeywordValidForOverflowBlock(keyword);
    case CSSPropertyID::CSSPropertyOverflowInline:
        return isKeywordValidForOverflowInline(keyword);
    case CSSPropertyID::CSSPropertyOverscrollBehaviorBlock:
        return isKeywordValidForOverscrollBehaviorBlock(keyword);
    case CSSPropertyID::CSSPropertyOverscrollBehaviorInline:
        return isKeywordValidForOverscrollBehaviorInline(keyword);
    case CSSPropertyID::CSSPropertyScrollPaddingBlockEnd:
        return isKeywordValidForScrollPaddingBlockEnd(keyword);
    case CSSPropertyID::CSSPropertyScrollPaddingBlockStart:
        return isKeywordValidForScrollPaddingBlockStart(keyword);
    case CSSPropertyID::CSSPropertyScrollPaddingInlineEnd:
        return isKeywordValidForScrollPaddingInlineEnd(keyword);
    case CSSPropertyID::CSSPropertyScrollPaddingInlineStart:
        return isKeywordValidForScrollPaddingInlineStart(keyword);
    default:
        return false;
    }
}

bool CSSPropertyParsing::isKeywordFastPathEligibleStyleProperty(CSSPropertyID id)
{
    switch (id) {
    case CSSPropertyID::CSSPropertyRubyPosition:
    case CSSPropertyID::CSSPropertyWritingMode:
    case CSSPropertyID::CSSPropertyDirection:
    case CSSPropertyID::CSSPropertyFontFeatureSettings:
    case CSSPropertyID::CSSPropertyFontKerning:
    case CSSPropertyID::CSSPropertyFontOpticalSizing:
    case CSSPropertyID::CSSPropertyFontPalette:
    case CSSPropertyID::CSSPropertyFontSize:
    case CSSPropertyID::CSSPropertyFontSynthesisSmallCaps:
    case CSSPropertyID::CSSPropertyFontSynthesisStyle:
    case CSSPropertyID::CSSPropertyFontSynthesisWeight:
    case CSSPropertyID::CSSPropertyFontVariantAlternates:
    case CSSPropertyID::CSSPropertyFontVariantCaps:
    case CSSPropertyID::CSSPropertyFontVariantEastAsian:
    case CSSPropertyID::CSSPropertyFontVariantEmoji:
    case CSSPropertyID::CSSPropertyFontVariantLigatures:
    case CSSPropertyID::CSSPropertyFontVariantNumeric:
    case CSSPropertyID::CSSPropertyFontVariantPosition:
    case CSSPropertyID::CSSPropertyFontVariationSettings:
    case CSSPropertyID::CSSPropertyFontWeight:
    case CSSPropertyID::CSSPropertyFontWidth:
    case CSSPropertyID::CSSPropertyTextOrientation:
    case CSSPropertyID::CSSPropertyTextRendering:
    case CSSPropertyID::CSSPropertyZoom:
    case CSSPropertyID::CSSPropertyWebkitFontSmoothing:
    case CSSPropertyID::CSSPropertyWebkitLocale:
    case CSSPropertyID::CSSPropertyWebkitTextZoom:
    case CSSPropertyID::CSSPropertyLetterSpacing:
    case CSSPropertyID::CSSPropertyTextAutospace:
    case CSSPropertyID::CSSPropertyTextSpacingTrim:
    case CSSPropertyID::CSSPropertyAccentColor:
    case CSSPropertyID::CSSPropertyAlignmentBaseline:
    case CSSPropertyID::CSSPropertyAnchorName:
    case CSSPropertyID::CSSPropertyAnchorScope:
    case CSSPropertyID::CSSPropertyAppearance:
    case CSSPropertyID::CSSPropertyBackfaceVisibility:
    case CSSPropertyID::CSSPropertyBaselineShift:
    case CSSPropertyID::CSSPropertyBlockEllipsis:
    case CSSPropertyID::CSSPropertyBlockStepAlign:
    case CSSPropertyID::CSSPropertyBlockStepInsert:
    case CSSPropertyID::CSSPropertyBlockStepRound:
    case CSSPropertyID::CSSPropertyBlockStepSize:
    case CSSPropertyID::CSSPropertyBorderCollapse:
    case CSSPropertyID::CSSPropertyBorderImageSource:
    case CSSPropertyID::CSSPropertyBoxSizing:
    case CSSPropertyID::CSSPropertyBreakAfter:
    case CSSPropertyID::CSSPropertyBreakBefore:
    case CSSPropertyID::CSSPropertyBreakInside:
    case CSSPropertyID::CSSPropertyBufferedRendering:
    case CSSPropertyID::CSSPropertyCaptionSide:
    case CSSPropertyID::CSSPropertyCaretColor:
    case CSSPropertyID::CSSPropertyClear:
    case CSSPropertyID::CSSPropertyClip:
    case CSSPropertyID::CSSPropertyClipRule:
    case CSSPropertyID::CSSPropertyColorInterpolation:
    case CSSPropertyID::CSSPropertyColorInterpolationFilters:
    case CSSPropertyID::CSSPropertyColumnCount:
    case CSSPropertyID::CSSPropertyColumnFill:
    case CSSPropertyID::CSSPropertyColumnGap:
    case CSSPropertyID::CSSPropertyColumnRuleStyle:
    case CSSPropertyID::CSSPropertyColumnRuleWidth:
    case CSSPropertyID::CSSPropertyColumnSpan:
    case CSSPropertyID::CSSPropertyColumnWidth:
    case CSSPropertyID::CSSPropertyContain:
    case CSSPropertyID::CSSPropertyContainerName:
    case CSSPropertyID::CSSPropertyContainerType:
    case CSSPropertyID::CSSPropertyContentVisibility:
    case CSSPropertyID::CSSPropertyContinue:
    case CSSPropertyID::CSSPropertyD:
    case CSSPropertyID::CSSPropertyDominantBaseline:
    case CSSPropertyID::CSSPropertyEmptyCells:
    case CSSPropertyID::CSSPropertyFieldSizing:
    case CSSPropertyID::CSSPropertyFill:
    case CSSPropertyID::CSSPropertyFillRule:
    case CSSPropertyID::CSSPropertyFlexBasis:
    case CSSPropertyID::CSSPropertyFlexDirection:
    case CSSPropertyID::CSSPropertyFlexWrap:
    case CSSPropertyID::CSSPropertyFloat:
    case CSSPropertyID::CSSPropertyGlyphOrientationVertical:
    case CSSPropertyID::CSSPropertyHangingPunctuation:
    case CSSPropertyID::CSSPropertyHyphenateCharacter:
    case CSSPropertyID::CSSPropertyHyphens:
    case CSSPropertyID::CSSPropertyImageOrientation:
    case CSSPropertyID::CSSPropertyImageRendering:
    case CSSPropertyID::CSSPropertyInputSecurity:
    case CSSPropertyID::CSSPropertyIsolation:
    case CSSPropertyID::CSSPropertyLineBreak:
    case CSSPropertyID::CSSPropertyLineHeight:
    case CSSPropertyID::CSSPropertyListStyleImage:
    case CSSPropertyID::CSSPropertyListStylePosition:
    case CSSPropertyID::CSSPropertyListStyleType:
    case CSSPropertyID::CSSPropertyMarkerEnd:
    case CSSPropertyID::CSSPropertyMarkerMid:
    case CSSPropertyID::CSSPropertyMarkerStart:
    case CSSPropertyID::CSSPropertyMaskBorderSource:
    case CSSPropertyID::CSSPropertyMaskType:
    case CSSPropertyID::CSSPropertyMathStyle:
    case CSSPropertyID::CSSPropertyMaxLines:
    case CSSPropertyID::CSSPropertyMixBlendMode:
    case CSSPropertyID::CSSPropertyObjectFit:
    case CSSPropertyID::CSSPropertyOffsetAnchor:
    case CSSPropertyID::CSSPropertyOffsetPosition:
    case CSSPropertyID::CSSPropertyOutlineColor:
    case CSSPropertyID::CSSPropertyOutlineStyle:
    case CSSPropertyID::CSSPropertyOutlineWidth:
    case CSSPropertyID::CSSPropertyOverflowAnchor:
    case CSSPropertyID::CSSPropertyOverflowWrap:
    case CSSPropertyID::CSSPropertyPage:
    case CSSPropertyID::CSSPropertyPerspective:
    case CSSPropertyID::CSSPropertyPointerEvents:
    case CSSPropertyID::CSSPropertyPosition:
    case CSSPropertyID::CSSPropertyPositionAnchor:
    case CSSPropertyID::CSSPropertyPositionTryOrder:
    case CSSPropertyID::CSSPropertyPositionVisibility:
    case CSSPropertyID::CSSPropertyPrintColorAdjust:
    case CSSPropertyID::CSSPropertyResize:
    case CSSPropertyID::CSSPropertyRowGap:
    case CSSPropertyID::CSSPropertyRubyAlign:
    case CSSPropertyID::CSSPropertyRubyOverhang:
    case CSSPropertyID::CSSPropertyRx:
    case CSSPropertyID::CSSPropertyRy:
    case CSSPropertyID::CSSPropertyScrollBehavior:
    case CSSPropertyID::CSSPropertyScrollSnapStop:
    case CSSPropertyID::CSSPropertyScrollbarGutter:
    case CSSPropertyID::CSSPropertyScrollbarWidth:
    case CSSPropertyID::CSSPropertyShapeRendering:
    case CSSPropertyID::CSSPropertySpeakAs:
    case CSSPropertyID::CSSPropertyStroke:
    case CSSPropertyID::CSSPropertyStrokeLinecap:
    case CSSPropertyID::CSSPropertyStrokeLinejoin:
    case CSSPropertyID::CSSPropertyTableLayout:
    case CSSPropertyID::CSSPropertyTextAlign:
    case CSSPropertyID::CSSPropertyTextAlignLast:
    case CSSPropertyID::CSSPropertyTextAnchor:
    case CSSPropertyID::CSSPropertyTextBoxTrim:
    case CSSPropertyID::CSSPropertyTextCombineUpright:
    case CSSPropertyID::CSSPropertyTextDecorationLine:
    case CSSPropertyID::CSSPropertyTextDecorationSkipInk:
    case CSSPropertyID::CSSPropertyTextDecorationStyle:
    case CSSPropertyID::CSSPropertyTextDecorationThickness:
    case CSSPropertyID::CSSPropertyTextEmphasisStyle:
    case CSSPropertyID::CSSPropertyTextGroupAlign:
    case CSSPropertyID::CSSPropertyTextJustify:
    case CSSPropertyID::CSSPropertyTextOverflow:
    case CSSPropertyID::CSSPropertyTextTransform:
    case CSSPropertyID::CSSPropertyTextUnderlineOffset:
    case CSSPropertyID::CSSPropertyTextUnderlinePosition:
    case CSSPropertyID::CSSPropertyTextWrapMode:
    case CSSPropertyID::CSSPropertyTextWrapStyle:
    case CSSPropertyID::CSSPropertyTimelineScope:
    case CSSPropertyID::CSSPropertyTouchAction:
    case CSSPropertyID::CSSPropertyTransform:
    case CSSPropertyID::CSSPropertyTransformBox:
    case CSSPropertyID::CSSPropertyTransformStyle:
    case CSSPropertyID::CSSPropertyTransitionProperty:
    case CSSPropertyID::CSSPropertyUnicodeBidi:
    case CSSPropertyID::CSSPropertyVectorEffect:
    case CSSPropertyID::CSSPropertyVerticalAlign:
    case CSSPropertyID::CSSPropertyViewTransitionClass:
    case CSSPropertyID::CSSPropertyViewTransitionName:
    case CSSPropertyID::CSSPropertyVisibility:
    case CSSPropertyID::CSSPropertyWhiteSpaceCollapse:
    case CSSPropertyID::CSSPropertyWordBreak:
    case CSSPropertyID::CSSPropertyZIndex:
    case CSSPropertyID::CSSPropertyWebkitBoxAlign:
    case CSSPropertyID::CSSPropertyWebkitBoxDecorationBreak:
    case CSSPropertyID::CSSPropertyWebkitBoxDirection:
    case CSSPropertyID::CSSPropertyWebkitBoxLines:
    case CSSPropertyID::CSSPropertyWebkitBoxOrient:
    case CSSPropertyID::CSSPropertyWebkitBoxPack:
    case CSSPropertyID::CSSPropertyWebkitColumnAxis:
    case CSSPropertyID::CSSPropertyWebkitColumnProgression:
    case CSSPropertyID::CSSPropertyWebkitCursorVisibility:
    case CSSPropertyID::CSSPropertyWebkitHyphenateLimitAfter:
    case CSSPropertyID::CSSPropertyWebkitHyphenateLimitBefore:
    case CSSPropertyID::CSSPropertyWebkitHyphenateLimitLines:
    case CSSPropertyID::CSSPropertyWebkitInitialLetter:
    case CSSPropertyID::CSSPropertyWebkitLineAlign:
    case CSSPropertyID::CSSPropertyWebkitLineBoxContain:
    case CSSPropertyID::CSSPropertyWebkitLineClamp:
    case CSSPropertyID::CSSPropertyWebkitLineGrid:
    case CSSPropertyID::CSSPropertyWebkitLineSnap:
    case CSSPropertyID::CSSPropertyWebkitMarqueeDirection:
    case CSSPropertyID::CSSPropertyWebkitMarqueeStyle:
    case CSSPropertyID::CSSPropertyWebkitNbspMode:
    case CSSPropertyID::CSSPropertyWebkitRtlOrdering:
    case CSSPropertyID::CSSPropertyWebkitRubyPosition:
    case CSSPropertyID::CSSPropertyWebkitTextCombine:
    case CSSPropertyID::CSSPropertyWebkitTextDecorationsInEffect:
    case CSSPropertyID::CSSPropertyWebkitTextSecurity:
    case CSSPropertyID::CSSPropertyWebkitTextStrokeWidth:
    case CSSPropertyID::CSSPropertyWebkitUserDrag:
    case CSSPropertyID::CSSPropertyWebkitUserModify:
    case CSSPropertyID::CSSPropertyWebkitUserSelect:
    case CSSPropertyID::CSSPropertyWordSpacing:
    case CSSPropertyID::CSSPropertyBorderBottomStyle:
    case CSSPropertyID::CSSPropertyBorderBottomWidth:
    case CSSPropertyID::CSSPropertyBorderLeftStyle:
    case CSSPropertyID::CSSPropertyBorderLeftWidth:
    case CSSPropertyID::CSSPropertyBorderRightStyle:
    case CSSPropertyID::CSSPropertyBorderRightWidth:
    case CSSPropertyID::CSSPropertyBorderTopStyle:
    case CSSPropertyID::CSSPropertyBorderTopWidth:
    case CSSPropertyID::CSSPropertyBottom:
    case CSSPropertyID::CSSPropertyCornerBottomLeftShape:
    case CSSPropertyID::CSSPropertyCornerBottomRightShape:
    case CSSPropertyID::CSSPropertyCornerTopLeftShape:
    case CSSPropertyID::CSSPropertyCornerTopRightShape:
    case CSSPropertyID::CSSPropertyHeight:
    case CSSPropertyID::CSSPropertyLeft:
    case CSSPropertyID::CSSPropertyMarginBottom:
    case CSSPropertyID::CSSPropertyMarginLeft:
    case CSSPropertyID::CSSPropertyMarginRight:
    case CSSPropertyID::CSSPropertyMarginTop:
    case CSSPropertyID::CSSPropertyMaxHeight:
    case CSSPropertyID::CSSPropertyMaxWidth:
    case CSSPropertyID::CSSPropertyMinHeight:
    case CSSPropertyID::CSSPropertyMinWidth:
    case CSSPropertyID::CSSPropertyOverflowX:
    case CSSPropertyID::CSSPropertyOverflowY:
    case CSSPropertyID::CSSPropertyOverscrollBehaviorX:
    case CSSPropertyID::CSSPropertyOverscrollBehaviorY:
    case CSSPropertyID::CSSPropertyRight:
    case CSSPropertyID::CSSPropertyScrollPaddingBottom:
    case CSSPropertyID::CSSPropertyScrollPaddingLeft:
    case CSSPropertyID::CSSPropertyScrollPaddingRight:
    case CSSPropertyID::CSSPropertyScrollPaddingTop:
    case CSSPropertyID::CSSPropertyTop:
    case CSSPropertyID::CSSPropertyWidth:
    case CSSPropertyID::CSSPropertyBlockSize:
    case CSSPropertyID::CSSPropertyBorderBlockEndStyle:
    case CSSPropertyID::CSSPropertyBorderBlockEndWidth:
    case CSSPropertyID::CSSPropertyBorderBlockStartStyle:
    case CSSPropertyID::CSSPropertyBorderBlockStartWidth:
    case CSSPropertyID::CSSPropertyBorderInlineEndStyle:
    case CSSPropertyID::CSSPropertyBorderInlineEndWidth:
    case CSSPropertyID::CSSPropertyBorderInlineStartStyle:
    case CSSPropertyID::CSSPropertyBorderInlineStartWidth:
    case CSSPropertyID::CSSPropertyCornerEndEndShape:
    case CSSPropertyID::CSSPropertyCornerEndStartShape:
    case CSSPropertyID::CSSPropertyCornerStartEndShape:
    case CSSPropertyID::CSSPropertyCornerStartStartShape:
    case CSSPropertyID::CSSPropertyInlineSize:
    case CSSPropertyID::CSSPropertyInsetBlockEnd:
    case CSSPropertyID::CSSPropertyInsetBlockStart:
    case CSSPropertyID::CSSPropertyInsetInlineEnd:
    case CSSPropertyID::CSSPropertyInsetInlineStart:
    case CSSPropertyID::CSSPropertyMarginBlockEnd:
    case CSSPropertyID::CSSPropertyMarginBlockStart:
    case CSSPropertyID::CSSPropertyMarginInlineEnd:
    case CSSPropertyID::CSSPropertyMarginInlineStart:
    case CSSPropertyID::CSSPropertyMaxBlockSize:
    case CSSPropertyID::CSSPropertyMaxInlineSize:
    case CSSPropertyID::CSSPropertyMinBlockSize:
    case CSSPropertyID::CSSPropertyMinInlineSize:
    case CSSPropertyID::CSSPropertyOverflowBlock:
    case CSSPropertyID::CSSPropertyOverflowInline:
    case CSSPropertyID::CSSPropertyOverscrollBehaviorBlock:
    case CSSPropertyID::CSSPropertyOverscrollBehaviorInline:
    case CSSPropertyID::CSSPropertyScrollPaddingBlockEnd:
    case CSSPropertyID::CSSPropertyScrollPaddingBlockStart:
    case CSSPropertyID::CSSPropertyScrollPaddingInlineEnd:
    case CSSPropertyID::CSSPropertyScrollPaddingInlineStart:
        return true;
    default:
        return false;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::parseCounterStyleDescriptor(CSSParserTokenRange& range, CSSPropertyID id, CSS::PropertyParserState& state)
{
    if (!isExposed(id, state.context.propertySettings) && !isInternal(id)) {
        // Allow internal properties as we use them to parse several internal-only-shorthands (e.g. background-repeat),
        // and to handle certain DOM-exposed values (e.g. -webkit-font-size-delta from execCommand('FontSizeDelta')).
        ASSERT_NOT_REACHED();
        return { };
    }
    switch (id) {
    case CSSPropertyID::CSSPropertyAdditiveSymbols:
        return consumeCounterStyleAdditiveSymbols(range, state);
    case CSSPropertyID::CSSPropertyFallback:
        return consumeCounterStyleName(range, state);
    case CSSPropertyID::CSSPropertyNegative:
        return consumeCounterStyleNegative(range, state);
    case CSSPropertyID::CSSPropertyPad:
        return consumeCounterStylePad(range, state);
    case CSSPropertyID::CSSPropertyPrefix:
        return consumeCounterStylePrefix(range, state);
    case CSSPropertyID::CSSPropertyRange:
        return consumeCounterStyleRange(range, state);
    case CSSPropertyID::CSSPropertySpeakAs:
        return consumeCounterStyleSpeakAs(range, state);
    case CSSPropertyID::CSSPropertySuffix:
        return consumeCounterStyleSuffix(range, state);
    case CSSPropertyID::CSSPropertySymbols:
        return consumeCounterStyleSymbols(range, state);
    case CSSPropertyID::CSSPropertySystem:
        return consumeCounterStyleSystem(range, state);
    default:
        return { };
    }
}

bool CSSPropertyParsing::isKeywordValidForCounterStyleDescriptor(CSSPropertyID id, CSSValueID keyword, CSS::PropertyParserState&)
{
    switch (id) {
    case CSSPropertyID::CSSPropertySpeakAs:
        return isKeywordValidForCounterStyleSpeakAs(keyword);
    default:
        return false;
    }
}

bool CSSPropertyParsing::isKeywordFastPathEligibleCounterStyleDescriptor(CSSPropertyID id)
{
    switch (id) {
    case CSSPropertyID::CSSPropertySpeakAs:
        return true;
    default:
        return false;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::parseFontFaceDescriptor(CSSParserTokenRange& range, CSSPropertyID id, CSS::PropertyParserState& state)
{
    if (!isExposed(id, state.context.propertySettings) && !isInternal(id)) {
        // Allow internal properties as we use them to parse several internal-only-shorthands (e.g. background-repeat),
        // and to handle certain DOM-exposed values (e.g. -webkit-font-size-delta from execCommand('FontSizeDelta')).
        ASSERT_NOT_REACHED();
        return { };
    }
    switch (id) {
    case CSSPropertyID::CSSPropertyFontDisplay:
        return consumeIdent(range, isKeywordValidForFontFaceFontDisplay);
    case CSSPropertyID::CSSPropertyFontFamily:
        return consumeFamilyName(range, state);
    case CSSPropertyID::CSSPropertyFontFeatureSettings:
        return CSSPropertyParsing::consumeFontFaceFontFeatureSettings(range, state);
    case CSSPropertyID::CSSPropertyFontStyle:
        return consumeFontFaceFontStyle(range, state);
    case CSSPropertyID::CSSPropertyFontWeight:
        return CSSPropertyParsing::consumeFontFaceFontWeight(range, state);
    case CSSPropertyID::CSSPropertyFontWidth:
        return CSSPropertyParsing::consumeFontFaceFontWidth(range, state);
    case CSSPropertyID::CSSPropertySizeAdjust:
        return CSSPrimitiveValueResolver<CSS::Percentage<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, state);
    case CSSPropertyID::CSSPropertySrc:
        return consumeFontFaceSrc(range, state);
    case CSSPropertyID::CSSPropertyUnicodeRange:
        return CSSPropertyParsing::consumeFontFaceUnicodeRange(range);
    default:
        return { };
    }
}

bool CSSPropertyParsing::isKeywordValidForFontFaceDescriptor(CSSPropertyID id, CSSValueID keyword, CSS::PropertyParserState&)
{
    switch (id) {
    case CSSPropertyID::CSSPropertyFontDisplay:
        return isKeywordValidForFontFaceFontDisplay(keyword);
    case CSSPropertyID::CSSPropertyFontFeatureSettings:
        return isKeywordValidForFontFaceFontFeatureSettings(keyword);
    case CSSPropertyID::CSSPropertyFontWeight:
        return isKeywordValidForFontFaceFontWeight(keyword);
    case CSSPropertyID::CSSPropertyFontWidth:
        return isKeywordValidForFontFaceFontWidth(keyword);
    default:
        return false;
    }
}

bool CSSPropertyParsing::isKeywordFastPathEligibleFontFaceDescriptor(CSSPropertyID id)
{
    switch (id) {
    case CSSPropertyID::CSSPropertyFontDisplay:
    case CSSPropertyID::CSSPropertyFontFeatureSettings:
    case CSSPropertyID::CSSPropertyFontWeight:
    case CSSPropertyID::CSSPropertyFontWidth:
        return true;
    default:
        return false;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::parseFontPaletteValuesDescriptor(CSSParserTokenRange& range, CSSPropertyID id, CSS::PropertyParserState& state)
{
    if (!isExposed(id, state.context.propertySettings) && !isInternal(id)) {
        // Allow internal properties as we use them to parse several internal-only-shorthands (e.g. background-repeat),
        // and to handle certain DOM-exposed values (e.g. -webkit-font-size-delta from execCommand('FontSizeDelta')).
        ASSERT_NOT_REACHED();
        return { };
    }
    switch (id) {
    case CSSPropertyID::CSSPropertyBasePalette:
        return consumeFontPaletteValuesBasePalette(range, state);
    case CSSPropertyID::CSSPropertyFontFamily:
        return consumeFontPaletteValuesFontFamily(range, state);
    case CSSPropertyID::CSSPropertyOverrideColors:
        return consumeFontPaletteValuesOverrideColors(range, state);
    default:
        return { };
    }
}

bool CSSPropertyParsing::isKeywordValidForFontPaletteValuesDescriptor(CSSPropertyID id, CSSValueID keyword, CSS::PropertyParserState&)
{
    switch (id) {
    case CSSPropertyID::CSSPropertyBasePalette:
        return isKeywordValidForFontPaletteValuesBasePalette(keyword);
    default:
        return false;
    }
}

bool CSSPropertyParsing::isKeywordFastPathEligibleFontPaletteValuesDescriptor(CSSPropertyID id)
{
    switch (id) {
    case CSSPropertyID::CSSPropertyBasePalette:
        return true;
    default:
        return false;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::parsePageDescriptor(CSSParserTokenRange& range, CSSPropertyID id, CSS::PropertyParserState& state)
{
    if (!isExposed(id, state.context.propertySettings) && !isInternal(id)) {
        // Allow internal properties as we use them to parse several internal-only-shorthands (e.g. background-repeat),
        // and to handle certain DOM-exposed values (e.g. -webkit-font-size-delta from execCommand('FontSizeDelta')).
        ASSERT_NOT_REACHED();
        return { };
    }
    switch (id) {
    case CSSPropertyID::CSSPropertySize:
        return consumePageSize(range, state);
    default:
        return { };
    }
}

bool CSSPropertyParsing::isKeywordValidForPageDescriptor(CSSPropertyID id, CSSValueID keyword, CSS::PropertyParserState&)
{
    switch (id) {
    case CSSPropertyID::CSSPropertySize:
        return isKeywordValidForPageSize(keyword);
    default:
        return false;
    }
}

bool CSSPropertyParsing::isKeywordFastPathEligiblePageDescriptor(CSSPropertyID id)
{
    switch (id) {
    case CSSPropertyID::CSSPropertySize:
        return true;
    default:
        return false;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::parsePropertyDescriptor(CSSParserTokenRange& range, CSSPropertyID id, CSS::PropertyParserState& state)
{
    if (!isExposed(id, state.context.propertySettings) && !isInternal(id)) {
        // Allow internal properties as we use them to parse several internal-only-shorthands (e.g. background-repeat),
        // and to handle certain DOM-exposed values (e.g. -webkit-font-size-delta from execCommand('FontSizeDelta')).
        ASSERT_NOT_REACHED();
        return { };
    }
    switch (id) {
    case CSSPropertyID::CSSPropertyInherits:
        return consumeIdent(range, isKeywordValidForPropertyInherits);
    case CSSPropertyID::CSSPropertyInitialValue:
        return consumeDeclarationValue(range, state);
    case CSSPropertyID::CSSPropertySyntax:
        return consumeString(range);
    default:
        return { };
    }
}

bool CSSPropertyParsing::isKeywordValidForPropertyDescriptor(CSSPropertyID id, CSSValueID keyword, CSS::PropertyParserState&)
{
    switch (id) {
    case CSSPropertyID::CSSPropertyInherits:
        return isKeywordValidForPropertyInherits(keyword);
    default:
        return false;
    }
}

bool CSSPropertyParsing::isKeywordFastPathEligiblePropertyDescriptor(CSSPropertyID id)
{
    switch (id) {
    case CSSPropertyID::CSSPropertyInherits:
        return true;
    default:
        return false;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::parseViewTransitionDescriptor(CSSParserTokenRange& range, CSSPropertyID id, CSS::PropertyParserState& state)
{
    if (!isExposed(id, state.context.propertySettings) && !isInternal(id)) {
        // Allow internal properties as we use them to parse several internal-only-shorthands (e.g. background-repeat),
        // and to handle certain DOM-exposed values (e.g. -webkit-font-size-delta from execCommand('FontSizeDelta')).
        ASSERT_NOT_REACHED();
        return { };
    }
    switch (id) {
    case CSSPropertyID::CSSPropertyNavigation:
        return consumeIdent(range, isKeywordValidForViewTransitionNavigation);
    case CSSPropertyID::CSSPropertyTypes:
        return consumeViewTransitionTypes(range, state);
    default:
        return { };
    }
}

bool CSSPropertyParsing::isKeywordValidForViewTransitionDescriptor(CSSPropertyID id, CSSValueID keyword, CSS::PropertyParserState&)
{
    switch (id) {
    case CSSPropertyID::CSSPropertyNavigation:
        return isKeywordValidForViewTransitionNavigation(keyword);
    default:
        return false;
    }
}

bool CSSPropertyParsing::isKeywordFastPathEligibleViewTransitionDescriptor(CSSPropertyID id)
{
    switch (id) {
    case CSSPropertyID::CSSPropertyNavigation:
        return true;
    default:
        return false;
    }
}

} // namespace WebCore

