/*
    This file is part of the WebKit open source project.
    This file has been generated by generate-bindings.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.
*/

#include "config.h"

#if ENABLE(WEBGL)

#include "JSWebGL2RenderingContext.h"

#include "ActiveDOMObject.h"
#include "ContextDestructionObserverInlines.h"
#include "ExtendedDOMClientIsoSubspaces.h"
#include "ExtendedDOMIsoSubspaces.h"
#include "IDLTypes.h"
#include "InspectorCanvasCallTracer.h"
#include "JSDOMAttribute.h"
#include "JSDOMBinding.h"
#include "JSDOMConstructorNotConstructable.h"
#include "JSDOMConvertBase.h"
#include "JSDOMConvertBoolean.h"
#include "JSDOMConvertBufferSource.h"
#include "JSDOMConvertInterface.h"
#include "JSDOMConvertNullable.h"
#include "JSDOMConvertNumbers.h"
#include "JSDOMConvertSequences.h"
#include "JSDOMConvertStrings.h"
#include "JSDOMConvertUnion.h"
#include "JSDOMConvertWebGL.h"
#include "JSDOMExceptionHandling.h"
#include "JSDOMGlobalObject.h"
#include "JSDOMGlobalObjectInlines.h"
#include "JSDOMOperation.h"
#include "JSDOMWrapperCache.h"
#include "JSHTMLCanvasElement.h"
#include "JSHTMLImageElement.h"
#include "JSHTMLVideoElement.h"
#include "JSImageBitmap.h"
#include "JSImageData.h"
#include "JSWebGLActiveInfo.h"
#include "JSWebGLBuffer.h"
#include "JSWebGLProgram.h"
#include "JSWebGLQuery.h"
#include "JSWebGLSampler.h"
#include "JSWebGLSync.h"
#include "JSWebGLTexture.h"
#include "JSWebGLTransformFeedback.h"
#include "JSWebGLUniformLocation.h"
#include "JSWebGLVertexArrayObject.h"
#include "ScriptExecutionContext.h"
#include "Settings.h"
#include "WebCoreJSClientData.h"
#include "WebCoreOpaqueRootInlines.h"
#include <JavaScriptCore/FunctionPrototype.h>
#include <JavaScriptCore/HeapAnalyzer.h>
#include <JavaScriptCore/JSArray.h>
#include <JavaScriptCore/JSCInlines.h>
#include <JavaScriptCore/JSDestructibleObjectHeapCellType.h>
#include <JavaScriptCore/SlotVisitorMacros.h>
#include <JavaScriptCore/SubspaceInlines.h>
#include <wtf/GetPtr.h>
#include <wtf/PointerPreparations.h>
#include <wtf/URL.h>
#include <wtf/Variant.h>
#include <wtf/text/MakeString.h>

#if ENABLE(WEBGL)
#include "JSDOMConvertDictionary.h"
#include "JSWebGLContextAttributes.h"
#include "JSWebGLFramebuffer.h"
#include "JSWebGLRenderbuffer.h"
#include "JSWebGLShader.h"
#include "JSWebGLShaderPrecisionFormat.h"
#endif

#if ENABLE(WEBGL) && ENABLE(WEBXR)
#include "DOMPromiseProxy.h"
#include "JSDOMConvertPromise.h"
#include "JSDOMOperationReturningPromise.h"
#endif

namespace WebCore {
using namespace JSC;

// Functions

static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_bufferData);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_bufferSubData);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_copyBufferSubData);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getBufferSubData);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_blitFramebuffer);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_framebufferTextureLayer);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_invalidateFramebuffer);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_invalidateSubFramebuffer);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_readBuffer);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getInternalformatParameter);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_renderbufferStorageMultisample);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_texStorage2D);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_texStorage3D);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_texImage3D);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_texSubImage3D);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_copyTexSubImage3D);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_compressedTexImage3D);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_compressedTexSubImage3D);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getFragDataLocation);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform1ui);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform2ui);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform3ui);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform4ui);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform1uiv);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform2uiv);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform3uiv);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform4uiv);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniformMatrix2x3fv);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniformMatrix3x2fv);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniformMatrix2x4fv);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniformMatrix4x2fv);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniformMatrix3x4fv);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniformMatrix4x3fv);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_vertexAttribI4i);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_vertexAttribI4iv);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_vertexAttribI4ui);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_vertexAttribI4uiv);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_vertexAttribIPointer);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_vertexAttribDivisor);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_drawArraysInstanced);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_drawElementsInstanced);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_drawRangeElements);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_drawBuffers);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_clearBufferiv);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_clearBufferuiv);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_clearBufferfv);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_clearBufferfi);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_createQuery);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_deleteQuery);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_isQuery);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_beginQuery);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_endQuery);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getQuery);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getQueryParameter);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_createSampler);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_deleteSampler);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_isSampler);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_bindSampler);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_samplerParameteri);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_samplerParameterf);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getSamplerParameter);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_fenceSync);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_isSync);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_deleteSync);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_clientWaitSync);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_waitSync);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getSyncParameter);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_createTransformFeedback);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_deleteTransformFeedback);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_isTransformFeedback);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_bindTransformFeedback);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_beginTransformFeedback);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_endTransformFeedback);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_transformFeedbackVaryings);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getTransformFeedbackVarying);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_pauseTransformFeedback);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_resumeTransformFeedback);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_bindBufferBase);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_bindBufferRange);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getIndexedParameter);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getUniformIndices);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getActiveUniforms);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getUniformBlockIndex);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getActiveUniformBlockParameter);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getActiveUniformBlockName);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniformBlockBinding);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_createVertexArray);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_deleteVertexArray);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_isVertexArray);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_bindVertexArray);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_texImage2D);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_texSubImage2D);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_compressedTexImage2D);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_compressedTexSubImage2D);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform1fv);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform2fv);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform3fv);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform4fv);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform1iv);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform2iv);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform3iv);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform4iv);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniformMatrix2fv);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniformMatrix3fv);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniformMatrix4fv);
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_readPixels);
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_activeTexture);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_attachShader);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_bindAttribLocation);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_bindBuffer);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_bindFramebuffer);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_bindRenderbuffer);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_bindTexture);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_blendColor);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_blendEquation);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_blendEquationSeparate);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_blendFunc);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_blendFuncSeparate);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_checkFramebufferStatus);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_clear);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_clearColor);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_clearDepth);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_clearStencil);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_colorMask);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_compileShader);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_copyTexImage2D);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_copyTexSubImage2D);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_createBuffer);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_createFramebuffer);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_createProgram);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_createRenderbuffer);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_createShader);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_createTexture);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_cullFace);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_deleteBuffer);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_deleteFramebuffer);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_deleteProgram);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_deleteRenderbuffer);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_deleteShader);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_deleteTexture);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_depthFunc);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_depthMask);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_depthRange);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_detachShader);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_disable);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_disableVertexAttribArray);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_drawArrays);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_drawElements);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_enable);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_enableVertexAttribArray);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_finish);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_flush);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_framebufferRenderbuffer);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_framebufferTexture2D);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_frontFace);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_generateMipmap);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getActiveAttrib);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getActiveUniform);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getAttachedShaders);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getAttribLocation);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getBufferParameter);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getContextAttributes);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getError);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getSupportedExtensions);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getExtension);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getFramebufferAttachmentParameter);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getParameter);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getProgramParameter);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getProgramInfoLog);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getRenderbufferParameter);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getShaderParameter);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getShaderInfoLog);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getShaderPrecisionFormat);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getShaderSource);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getTexParameter);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getUniform);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getUniformLocation);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getVertexAttrib);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getVertexAttribOffset);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_hint);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_isBuffer);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_isContextLost);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_isEnabled);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_isFramebuffer);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_isProgram);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_isRenderbuffer);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_isShader);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_isTexture);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_lineWidth);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_linkProgram);
#endif
#if ENABLE(WEBGL) && ENABLE(WEBXR)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_makeXRCompatible);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_pixelStorei);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_polygonOffset);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_renderbufferStorage);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_sampleCoverage);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_scissor);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_shaderSource);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_stencilFunc);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_stencilFuncSeparate);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_stencilMask);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_stencilMaskSeparate);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_stencilOp);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_stencilOpSeparate);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_texParameterf);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_texParameteri);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform1f);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform2f);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform3f);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform4f);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform1i);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform2i);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform3i);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform4i);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_useProgram);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_validateProgram);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_vertexAttrib1f);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_vertexAttrib2f);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_vertexAttrib3f);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_vertexAttrib4f);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_vertexAttrib1fv);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_vertexAttrib2fv);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_vertexAttrib3fv);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_vertexAttrib4fv);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_vertexAttribPointer);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_viewport);
#endif

// Attributes

static JSC_DECLARE_CUSTOM_GETTER(jsWebGL2RenderingContextConstructor);
#if ENABLE(WEBGL)
static JSC_DECLARE_CUSTOM_GETTER(jsWebGL2RenderingContext_canvas);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_CUSTOM_GETTER(jsWebGL2RenderingContext_drawingBufferWidth);
#endif
#if ENABLE(WEBGL)
static JSC_DECLARE_CUSTOM_GETTER(jsWebGL2RenderingContext_drawingBufferHeight);
#endif

class JSWebGL2RenderingContextPrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;
    static JSWebGL2RenderingContextPrototype* create(JSC::VM& vm, JSDOMGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSWebGL2RenderingContextPrototype* ptr = new (NotNull, JSC::allocateCell<JSWebGL2RenderingContextPrototype>(vm)) JSWebGL2RenderingContextPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSWebGL2RenderingContextPrototype, Base);
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSWebGL2RenderingContextPrototype(JSC::VM& vm, JSC::JSGlobalObject*, JSC::Structure* structure)
        : JSC::JSNonFinalObject(vm, structure)
    {
    }

    void finishCreation(JSC::VM&);
};
STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSWebGL2RenderingContextPrototype, JSWebGL2RenderingContextPrototype::Base);

using JSWebGL2RenderingContextDOMConstructor = JSDOMConstructorNotConstructable<JSWebGL2RenderingContext>;

/* Hash table for constructor */

static const std::array<HashTableValue, 561> JSWebGL2RenderingContextConstructorTableValues {
    HashTableValue { "READ_BUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0C02 } },
    HashTableValue { "UNPACK_ROW_LENGTH"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0CF2 } },
    HashTableValue { "UNPACK_SKIP_ROWS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0CF3 } },
    HashTableValue { "UNPACK_SKIP_PIXELS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0CF4 } },
    HashTableValue { "PACK_ROW_LENGTH"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D02 } },
    HashTableValue { "PACK_SKIP_ROWS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D03 } },
    HashTableValue { "PACK_SKIP_PIXELS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D04 } },
    HashTableValue { "COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1800 } },
    HashTableValue { "DEPTH"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1801 } },
    HashTableValue { "STENCIL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1802 } },
    HashTableValue { "RED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1903 } },
    HashTableValue { "RGB8"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8051 } },
    HashTableValue { "RGBA8"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8058 } },
    HashTableValue { "RGB10_A2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8059 } },
    HashTableValue { "TEXTURE_BINDING_3D"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x806A } },
    HashTableValue { "UNPACK_SKIP_IMAGES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x806D } },
    HashTableValue { "UNPACK_IMAGE_HEIGHT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x806E } },
    HashTableValue { "TEXTURE_3D"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x806F } },
    HashTableValue { "TEXTURE_WRAP_R"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8072 } },
    HashTableValue { "MAX_3D_TEXTURE_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8073 } },
    HashTableValue { "UNSIGNED_INT_2_10_10_10_REV"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8368 } },
    HashTableValue { "MAX_ELEMENTS_VERTICES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80E8 } },
    HashTableValue { "MAX_ELEMENTS_INDICES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80E9 } },
    HashTableValue { "TEXTURE_MIN_LOD"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x813A } },
    HashTableValue { "TEXTURE_MAX_LOD"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x813B } },
    HashTableValue { "TEXTURE_BASE_LEVEL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x813C } },
    HashTableValue { "TEXTURE_MAX_LEVEL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x813D } },
    HashTableValue { "MIN"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8007 } },
    HashTableValue { "MAX"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8008 } },
    HashTableValue { "DEPTH_COMPONENT24"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x81A6 } },
    HashTableValue { "MAX_TEXTURE_LOD_BIAS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84FD } },
    HashTableValue { "TEXTURE_COMPARE_MODE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x884C } },
    HashTableValue { "TEXTURE_COMPARE_FUNC"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x884D } },
    HashTableValue { "CURRENT_QUERY"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8865 } },
    HashTableValue { "QUERY_RESULT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8866 } },
    HashTableValue { "QUERY_RESULT_AVAILABLE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8867 } },
    HashTableValue { "STREAM_READ"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88E1 } },
    HashTableValue { "STREAM_COPY"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88E2 } },
    HashTableValue { "STATIC_READ"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88E5 } },
    HashTableValue { "STATIC_COPY"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88E6 } },
    HashTableValue { "DYNAMIC_READ"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88E9 } },
    HashTableValue { "DYNAMIC_COPY"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88EA } },
    HashTableValue { "MAX_DRAW_BUFFERS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8824 } },
    HashTableValue { "DRAW_BUFFER0"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8825 } },
    HashTableValue { "DRAW_BUFFER1"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8826 } },
    HashTableValue { "DRAW_BUFFER2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8827 } },
    HashTableValue { "DRAW_BUFFER3"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8828 } },
    HashTableValue { "DRAW_BUFFER4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8829 } },
    HashTableValue { "DRAW_BUFFER5"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x882A } },
    HashTableValue { "DRAW_BUFFER6"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x882B } },
    HashTableValue { "DRAW_BUFFER7"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x882C } },
    HashTableValue { "DRAW_BUFFER8"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x882D } },
    HashTableValue { "DRAW_BUFFER9"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x882E } },
    HashTableValue { "DRAW_BUFFER10"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x882F } },
    HashTableValue { "DRAW_BUFFER11"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8830 } },
    HashTableValue { "DRAW_BUFFER12"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8831 } },
    HashTableValue { "DRAW_BUFFER13"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8832 } },
    HashTableValue { "DRAW_BUFFER14"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8833 } },
    HashTableValue { "DRAW_BUFFER15"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8834 } },
    HashTableValue { "MAX_FRAGMENT_UNIFORM_COMPONENTS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B49 } },
    HashTableValue { "MAX_VERTEX_UNIFORM_COMPONENTS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B4A } },
    HashTableValue { "SAMPLER_3D"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B5F } },
    HashTableValue { "SAMPLER_2D_SHADOW"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B62 } },
    HashTableValue { "FRAGMENT_SHADER_DERIVATIVE_HINT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B8B } },
    HashTableValue { "PIXEL_PACK_BUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88EB } },
    HashTableValue { "PIXEL_UNPACK_BUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88EC } },
    HashTableValue { "PIXEL_PACK_BUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88ED } },
    HashTableValue { "PIXEL_UNPACK_BUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88EF } },
    HashTableValue { "FLOAT_MAT2x3"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B65 } },
    HashTableValue { "FLOAT_MAT2x4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B66 } },
    HashTableValue { "FLOAT_MAT3x2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B67 } },
    HashTableValue { "FLOAT_MAT3x4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B68 } },
    HashTableValue { "FLOAT_MAT4x2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B69 } },
    HashTableValue { "FLOAT_MAT4x3"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B6A } },
    HashTableValue { "SRGB"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C40 } },
    HashTableValue { "SRGB8"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C41 } },
    HashTableValue { "SRGB8_ALPHA8"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C43 } },
    HashTableValue { "COMPARE_REF_TO_TEXTURE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x884E } },
    HashTableValue { "RGBA32F"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8814 } },
    HashTableValue { "RGB32F"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8815 } },
    HashTableValue { "RGBA16F"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x881A } },
    HashTableValue { "RGB16F"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x881B } },
    HashTableValue { "VERTEX_ATTRIB_ARRAY_INTEGER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88FD } },
    HashTableValue { "MAX_ARRAY_TEXTURE_LAYERS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88FF } },
    HashTableValue { "MIN_PROGRAM_TEXEL_OFFSET"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8904 } },
    HashTableValue { "MAX_PROGRAM_TEXEL_OFFSET"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8905 } },
    HashTableValue { "MAX_VARYING_COMPONENTS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B4B } },
    HashTableValue { "TEXTURE_2D_ARRAY"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C1A } },
    HashTableValue { "TEXTURE_BINDING_2D_ARRAY"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C1D } },
    HashTableValue { "R11F_G11F_B10F"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C3A } },
    HashTableValue { "UNSIGNED_INT_10F_11F_11F_REV"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C3B } },
    HashTableValue { "RGB9_E5"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C3D } },
    HashTableValue { "UNSIGNED_INT_5_9_9_9_REV"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C3E } },
    HashTableValue { "TRANSFORM_FEEDBACK_BUFFER_MODE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C7F } },
    HashTableValue { "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C80 } },
    HashTableValue { "TRANSFORM_FEEDBACK_VARYINGS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C83 } },
    HashTableValue { "TRANSFORM_FEEDBACK_BUFFER_START"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C84 } },
    HashTableValue { "TRANSFORM_FEEDBACK_BUFFER_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C85 } },
    HashTableValue { "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C88 } },
    HashTableValue { "RASTERIZER_DISCARD"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C89 } },
    HashTableValue { "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C8A } },
    HashTableValue { "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C8B } },
    HashTableValue { "INTERLEAVED_ATTRIBS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C8C } },
    HashTableValue { "SEPARATE_ATTRIBS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C8D } },
    HashTableValue { "TRANSFORM_FEEDBACK_BUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C8E } },
    HashTableValue { "TRANSFORM_FEEDBACK_BUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C8F } },
    HashTableValue { "RGBA32UI"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D70 } },
    HashTableValue { "RGB32UI"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D71 } },
    HashTableValue { "RGBA16UI"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D76 } },
    HashTableValue { "RGB16UI"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D77 } },
    HashTableValue { "RGBA8UI"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D7C } },
    HashTableValue { "RGB8UI"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D7D } },
    HashTableValue { "RGBA32I"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D82 } },
    HashTableValue { "RGB32I"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D83 } },
    HashTableValue { "RGBA16I"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D88 } },
    HashTableValue { "RGB16I"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D89 } },
    HashTableValue { "RGBA8I"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D8E } },
    HashTableValue { "RGB8I"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D8F } },
    HashTableValue { "RED_INTEGER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D94 } },
    HashTableValue { "RGB_INTEGER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D98 } },
    HashTableValue { "RGBA_INTEGER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D99 } },
    HashTableValue { "SAMPLER_2D_ARRAY"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DC1 } },
    HashTableValue { "SAMPLER_2D_ARRAY_SHADOW"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DC4 } },
    HashTableValue { "SAMPLER_CUBE_SHADOW"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DC5 } },
    HashTableValue { "UNSIGNED_INT_VEC2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DC6 } },
    HashTableValue { "UNSIGNED_INT_VEC3"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DC7 } },
    HashTableValue { "UNSIGNED_INT_VEC4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DC8 } },
    HashTableValue { "INT_SAMPLER_2D"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DCA } },
    HashTableValue { "INT_SAMPLER_3D"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DCB } },
    HashTableValue { "INT_SAMPLER_CUBE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DCC } },
    HashTableValue { "INT_SAMPLER_2D_ARRAY"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DCF } },
    HashTableValue { "UNSIGNED_INT_SAMPLER_2D"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DD2 } },
    HashTableValue { "UNSIGNED_INT_SAMPLER_3D"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DD3 } },
    HashTableValue { "UNSIGNED_INT_SAMPLER_CUBE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DD4 } },
    HashTableValue { "UNSIGNED_INT_SAMPLER_2D_ARRAY"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DD7 } },
    HashTableValue { "DEPTH_COMPONENT32F"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CAC } },
    HashTableValue { "DEPTH32F_STENCIL8"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CAD } },
    HashTableValue { "FLOAT_32_UNSIGNED_INT_24_8_REV"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DAD } },
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8210 } },
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8211 } },
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_RED_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8212 } },
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8213 } },
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8214 } },
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8215 } },
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8216 } },
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8217 } },
    HashTableValue { "FRAMEBUFFER_DEFAULT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8218 } },
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_STENCIL_ATTACHMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x821A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_STENCIL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84F9 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "UNSIGNED_INT_24_8"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84FA } },
    HashTableValue { "DEPTH24_STENCIL8"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88F0 } },
    HashTableValue { "UNSIGNED_NORMALIZED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C17 } },
    HashTableValue { "DRAW_FRAMEBUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CA6 } },
    HashTableValue { "READ_FRAMEBUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CA8 } },
    HashTableValue { "DRAW_FRAMEBUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CA9 } },
    HashTableValue { "READ_FRAMEBUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CAA } },
    HashTableValue { "RENDERBUFFER_SAMPLES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CAB } },
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD4 } },
    HashTableValue { "MAX_COLOR_ATTACHMENTS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CDF } },
    HashTableValue { "COLOR_ATTACHMENT1"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CE1 } },
    HashTableValue { "COLOR_ATTACHMENT2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CE2 } },
    HashTableValue { "COLOR_ATTACHMENT3"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CE3 } },
    HashTableValue { "COLOR_ATTACHMENT4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CE4 } },
    HashTableValue { "COLOR_ATTACHMENT5"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CE5 } },
    HashTableValue { "COLOR_ATTACHMENT6"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CE6 } },
    HashTableValue { "COLOR_ATTACHMENT7"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CE7 } },
    HashTableValue { "COLOR_ATTACHMENT8"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CE8 } },
    HashTableValue { "COLOR_ATTACHMENT9"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CE9 } },
    HashTableValue { "COLOR_ATTACHMENT10"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CEA } },
    HashTableValue { "COLOR_ATTACHMENT11"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CEB } },
    HashTableValue { "COLOR_ATTACHMENT12"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CEC } },
    HashTableValue { "COLOR_ATTACHMENT13"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CED } },
    HashTableValue { "COLOR_ATTACHMENT14"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CEE } },
    HashTableValue { "COLOR_ATTACHMENT15"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CEF } },
    HashTableValue { "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D56 } },
    HashTableValue { "MAX_SAMPLES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D57 } },
    HashTableValue { "HALF_FLOAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x140B } },
    HashTableValue { "RG"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8227 } },
    HashTableValue { "RG_INTEGER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8228 } },
    HashTableValue { "R8"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8229 } },
    HashTableValue { "RG8"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x822B } },
    HashTableValue { "R16F"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x822D } },
    HashTableValue { "R32F"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x822E } },
    HashTableValue { "RG16F"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x822F } },
    HashTableValue { "RG32F"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8230 } },
    HashTableValue { "R8I"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8231 } },
    HashTableValue { "R8UI"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8232 } },
    HashTableValue { "R16I"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8233 } },
    HashTableValue { "R16UI"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8234 } },
    HashTableValue { "R32I"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8235 } },
    HashTableValue { "R32UI"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8236 } },
    HashTableValue { "RG8I"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8237 } },
    HashTableValue { "RG8UI"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8238 } },
    HashTableValue { "RG16I"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8239 } },
    HashTableValue { "RG16UI"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x823A } },
    HashTableValue { "RG32I"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x823B } },
    HashTableValue { "RG32UI"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x823C } },
    HashTableValue { "VERTEX_ARRAY_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x85B5 } },
    HashTableValue { "R8_SNORM"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8F94 } },
    HashTableValue { "RG8_SNORM"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8F95 } },
    HashTableValue { "RGB8_SNORM"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8F96 } },
    HashTableValue { "RGBA8_SNORM"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8F97 } },
    HashTableValue { "SIGNED_NORMALIZED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8F9C } },
    HashTableValue { "COPY_READ_BUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8F36 } },
    HashTableValue { "COPY_WRITE_BUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8F37 } },
    HashTableValue { "COPY_READ_BUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8F36 } },
    HashTableValue { "COPY_WRITE_BUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8F37 } },
    HashTableValue { "UNIFORM_BUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A11 } },
    HashTableValue { "UNIFORM_BUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A28 } },
    HashTableValue { "UNIFORM_BUFFER_START"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A29 } },
    HashTableValue { "UNIFORM_BUFFER_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A2A } },
    HashTableValue { "MAX_VERTEX_UNIFORM_BLOCKS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A2B } },
    HashTableValue { "MAX_FRAGMENT_UNIFORM_BLOCKS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A2D } },
    HashTableValue { "MAX_COMBINED_UNIFORM_BLOCKS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A2E } },
    HashTableValue { "MAX_UNIFORM_BUFFER_BINDINGS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A2F } },
    HashTableValue { "MAX_UNIFORM_BLOCK_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A30 } },
    HashTableValue { "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A31 } },
    HashTableValue { "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A33 } },
    HashTableValue { "UNIFORM_BUFFER_OFFSET_ALIGNMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A34 } },
    HashTableValue { "ACTIVE_UNIFORM_BLOCKS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A36 } },
    HashTableValue { "UNIFORM_TYPE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A37 } },
    HashTableValue { "UNIFORM_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A38 } },
    HashTableValue { "UNIFORM_BLOCK_INDEX"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A3A } },
    HashTableValue { "UNIFORM_OFFSET"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A3B } },
    HashTableValue { "UNIFORM_ARRAY_STRIDE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A3C } },
    HashTableValue { "UNIFORM_MATRIX_STRIDE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A3D } },
    HashTableValue { "UNIFORM_IS_ROW_MAJOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A3E } },
    HashTableValue { "UNIFORM_BLOCK_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A3F } },
    HashTableValue { "UNIFORM_BLOCK_DATA_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A40 } },
    HashTableValue { "UNIFORM_BLOCK_ACTIVE_UNIFORMS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A42 } },
    HashTableValue { "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A43 } },
    HashTableValue { "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A44 } },
    HashTableValue { "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A46 } },
    HashTableValue { "INVALID_INDEX"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0xFFFFFFFF } },
    HashTableValue { "MAX_VERTEX_OUTPUT_COMPONENTS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9122 } },
    HashTableValue { "MAX_FRAGMENT_INPUT_COMPONENTS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9125 } },
    HashTableValue { "MAX_SERVER_WAIT_TIMEOUT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9111 } },
    HashTableValue { "OBJECT_TYPE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9112 } },
    HashTableValue { "SYNC_CONDITION"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9113 } },
    HashTableValue { "SYNC_STATUS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9114 } },
    HashTableValue { "SYNC_FLAGS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9115 } },
    HashTableValue { "SYNC_FENCE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9116 } },
    HashTableValue { "SYNC_GPU_COMMANDS_COMPLETE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9117 } },
    HashTableValue { "UNSIGNALED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9118 } },
    HashTableValue { "SIGNALED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9119 } },
    HashTableValue { "ALREADY_SIGNALED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x911A } },
    HashTableValue { "TIMEOUT_EXPIRED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x911B } },
    HashTableValue { "CONDITION_SATISFIED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x911C } },
    HashTableValue { "WAIT_FAILED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x911D } },
    HashTableValue { "SYNC_FLUSH_COMMANDS_BIT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x00000001 } },
    HashTableValue { "VERTEX_ATTRIB_ARRAY_DIVISOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88FE } },
    HashTableValue { "ANY_SAMPLES_PASSED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C2F } },
    HashTableValue { "ANY_SAMPLES_PASSED_CONSERVATIVE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D6A } },
    HashTableValue { "SAMPLER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8919 } },
    HashTableValue { "RGB10_A2UI"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x906F } },
    HashTableValue { "INT_2_10_10_10_REV"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D9F } },
    HashTableValue { "TRANSFORM_FEEDBACK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8E22 } },
    HashTableValue { "TRANSFORM_FEEDBACK_PAUSED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8E23 } },
    HashTableValue { "TRANSFORM_FEEDBACK_ACTIVE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8E24 } },
    HashTableValue { "TRANSFORM_FEEDBACK_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8E25 } },
    HashTableValue { "TEXTURE_IMMUTABLE_FORMAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x912F } },
    HashTableValue { "MAX_ELEMENT_INDEX"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D6B } },
    HashTableValue { "TEXTURE_IMMUTABLE_LEVELS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x82DF } },
    HashTableValue { "TIMEOUT_IGNORED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, -1 } },
    HashTableValue { "MAX_CLIENT_WAIT_TIMEOUT_WEBGL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9247 } },
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_BUFFER_BIT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x00000100 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BUFFER_BIT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x00000400 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "COLOR_BUFFER_BIT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x00004000 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "POINTS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0000 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0001 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINE_LOOP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0002 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINE_STRIP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0003 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TRIANGLES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0004 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TRIANGLE_STRIP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0005 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TRIANGLE_FAN"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0006 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ZERO"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ONE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SRC_COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0300 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ONE_MINUS_SRC_COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0301 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SRC_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0302 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ONE_MINUS_SRC_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0303 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DST_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0304 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ONE_MINUS_DST_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0305 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DST_COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0306 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ONE_MINUS_DST_COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0307 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SRC_ALPHA_SATURATE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0308 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FUNC_ADD"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8006 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_EQUATION"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8009 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_EQUATION_RGB"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8009 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_EQUATION_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x883D } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FUNC_SUBTRACT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x800A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FUNC_REVERSE_SUBTRACT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x800B } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_DST_RGB"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80C8 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_SRC_RGB"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80C9 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_DST_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80CA } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_SRC_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80CB } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CONSTANT_COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8001 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ONE_MINUS_CONSTANT_COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8002 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CONSTANT_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8003 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ONE_MINUS_CONSTANT_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8004 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8005 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ARRAY_BUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8892 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ELEMENT_ARRAY_BUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8893 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ARRAY_BUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8894 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ELEMENT_ARRAY_BUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8895 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STREAM_DRAW"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88E0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STATIC_DRAW"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88E4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DYNAMIC_DRAW"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88E8 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BUFFER_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8764 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BUFFER_USAGE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8765 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CURRENT_VERTEX_ATTRIB"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8626 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRONT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0404 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BACK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0405 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRONT_AND_BACK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0408 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_2D"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0DE1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CULL_FACE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B44 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0BE2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DITHER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0BD0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_TEST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B90 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_TEST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B71 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SCISSOR_TEST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0C11 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "POLYGON_OFFSET_FILL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8037 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLE_ALPHA_TO_COVERAGE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x809E } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLE_COVERAGE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80A0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NO_ERROR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INVALID_ENUM"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0500 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INVALID_VALUE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0501 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INVALID_OPERATION"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0502 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "OUT_OF_MEMORY"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0505 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CW"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0900 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CCW"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0901 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINE_WIDTH"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B21 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ALIASED_POINT_SIZE_RANGE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x846D } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ALIASED_LINE_WIDTH_RANGE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x846E } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CULL_FACE_MODE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B45 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRONT_FACE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B46 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_RANGE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B70 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_WRITEMASK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B72 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_CLEAR_VALUE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B73 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_FUNC"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B74 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_CLEAR_VALUE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B91 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_FUNC"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B92 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_FAIL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B94 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_PASS_DEPTH_FAIL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B95 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_PASS_DEPTH_PASS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B96 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_REF"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B97 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_VALUE_MASK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B93 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_WRITEMASK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B98 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BACK_FUNC"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8800 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BACK_FAIL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8801 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BACK_PASS_DEPTH_FAIL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8802 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BACK_PASS_DEPTH_PASS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8803 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BACK_REF"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CA3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BACK_VALUE_MASK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CA4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BACK_WRITEMASK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CA5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VIEWPORT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0BA2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SCISSOR_BOX"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0C10 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "COLOR_CLEAR_VALUE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0C22 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "COLOR_WRITEMASK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0C23 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNPACK_ALIGNMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0CF5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "PACK_ALIGNMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D05 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_TEXTURE_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D33 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_VIEWPORT_DIMS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D3A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SUBPIXEL_BITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D50 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RED_BITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D52 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "GREEN_BITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D53 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLUE_BITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D54 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ALPHA_BITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D55 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_BITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D56 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D57 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "POLYGON_OFFSET_UNITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2A00 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "POLYGON_OFFSET_FACTOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8038 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_BINDING_2D"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8069 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLE_BUFFERS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80A8 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80A9 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLE_COVERAGE_VALUE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80AA } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLE_COVERAGE_INVERT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80AB } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "COMPRESSED_TEXTURE_FORMATS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x86A3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DONT_CARE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1100 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FASTEST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1101 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NICEST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1102 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "GENERATE_MIPMAP_HINT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8192 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BYTE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1400 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNSIGNED_BYTE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1401 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SHORT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1402 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNSIGNED_SHORT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1403 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1404 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNSIGNED_INT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1405 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FLOAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1406 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_COMPONENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1902 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1906 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RGB"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1907 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RGBA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1908 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LUMINANCE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1909 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LUMINANCE_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x190A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNSIGNED_SHORT_4_4_4_4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8033 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNSIGNED_SHORT_5_5_5_1"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8034 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNSIGNED_SHORT_5_6_5"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8363 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAGMENT_SHADER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B30 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_SHADER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B31 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_VERTEX_ATTRIBS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8869 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_VERTEX_UNIFORM_VECTORS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DFB } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_VARYING_VECTORS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DFC } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_COMBINED_TEXTURE_IMAGE_UNITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B4D } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_VERTEX_TEXTURE_IMAGE_UNITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B4C } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_TEXTURE_IMAGE_UNITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8872 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_FRAGMENT_UNIFORM_VECTORS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DFD } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SHADER_TYPE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B4F } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DELETE_STATUS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B80 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINK_STATUS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B82 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VALIDATE_STATUS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B83 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ATTACHED_SHADERS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B85 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ACTIVE_UNIFORMS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B86 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ACTIVE_ATTRIBUTES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B89 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SHADING_LANGUAGE_VERSION"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B8C } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CURRENT_PROGRAM"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B8D } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NEVER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0200 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LESS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0201 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "EQUAL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0202 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LEQUAL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0203 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "GREATER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0204 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NOTEQUAL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0205 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "GEQUAL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0206 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ALWAYS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0207 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "KEEP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1E00 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "REPLACE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1E01 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INCR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1E02 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DECR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1E03 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INVERT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x150A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INCR_WRAP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8507 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DECR_WRAP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8508 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VENDOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1F00 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1F01 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERSION"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1F02 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NEAREST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2600 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINEAR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2601 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NEAREST_MIPMAP_NEAREST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2700 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINEAR_MIPMAP_NEAREST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2701 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NEAREST_MIPMAP_LINEAR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2702 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINEAR_MIPMAP_LINEAR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2703 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_MAG_FILTER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2800 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_MIN_FILTER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2801 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_WRAP_S"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2802 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_WRAP_T"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2803 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1702 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_CUBE_MAP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8513 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_BINDING_CUBE_MAP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8514 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_CUBE_MAP_POSITIVE_X"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8515 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_CUBE_MAP_NEGATIVE_X"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8516 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_CUBE_MAP_POSITIVE_Y"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8517 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_CUBE_MAP_NEGATIVE_Y"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8518 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_CUBE_MAP_POSITIVE_Z"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8519 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_CUBE_MAP_NEGATIVE_Z"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x851A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_CUBE_MAP_TEXTURE_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x851C } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE0"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE1"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE3"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE5"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE6"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C6 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE7"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C7 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE8"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C8 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE9"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C9 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE10"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84CA } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE11"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84CB } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE12"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84CC } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE13"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84CD } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE14"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84CE } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE15"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84CF } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE16"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE17"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE18"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE19"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE20"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE21"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE22"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D6 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE23"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D7 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE24"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D8 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE25"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D9 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE26"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84DA } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE27"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84DB } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE28"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84DC } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE29"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84DD } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE30"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84DE } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE31"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84DF } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ACTIVE_TEXTURE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84E0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "REPEAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2901 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CLAMP_TO_EDGE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x812F } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MIRRORED_REPEAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8370 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FLOAT_VEC2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B50 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FLOAT_VEC3"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B51 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FLOAT_VEC4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B52 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INT_VEC2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B53 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INT_VEC3"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B54 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INT_VEC4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B55 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BOOL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B56 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BOOL_VEC2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B57 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BOOL_VEC3"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B58 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BOOL_VEC4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B59 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FLOAT_MAT2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B5A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FLOAT_MAT3"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B5B } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FLOAT_MAT4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B5C } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLER_2D"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B5E } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLER_CUBE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B60 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_ATTRIB_ARRAY_ENABLED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8622 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_ATTRIB_ARRAY_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8623 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_ATTRIB_ARRAY_STRIDE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8624 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_ATTRIB_ARRAY_TYPE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8625 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_ATTRIB_ARRAY_NORMALIZED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x886A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_ATTRIB_ARRAY_POINTER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8645 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x889F } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "IMPLEMENTATION_COLOR_READ_TYPE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B9A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "IMPLEMENTATION_COLOR_READ_FORMAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B9B } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "COMPILE_STATUS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B81 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LOW_FLOAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DF0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MEDIUM_FLOAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DF1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "HIGH_FLOAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DF2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LOW_INT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DF3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MEDIUM_INT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DF4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "HIGH_INT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DF5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D40 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D41 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RGBA4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8056 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RGB5_A1"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8057 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RGB565"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D62 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_COMPONENT16"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x81A5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_INDEX8"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D48 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_STENCIL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84F9 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_WIDTH"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D42 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_HEIGHT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D43 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_INTERNAL_FORMAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D44 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_RED_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D50 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_GREEN_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D51 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_BLUE_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D52 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_ALPHA_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D53 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_DEPTH_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D54 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_STENCIL_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D55 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "COLOR_ATTACHMENT0"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CE0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_ATTACHMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D00 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_ATTACHMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D20 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_STENCIL_ATTACHMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x821A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NONE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_COMPLETE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_INCOMPLETE_ATTACHMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD6 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD7 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_INCOMPLETE_DIMENSIONS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD9 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_UNSUPPORTED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CDD } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CA6 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CA7 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_RENDERBUFFER_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84E8 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INVALID_FRAMEBUFFER_OPERATION"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0506 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNPACK_FLIP_Y_WEBGL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9240 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNPACK_PREMULTIPLY_ALPHA_WEBGL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9241 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CONTEXT_LOST_WEBGL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9242 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNPACK_COLORSPACE_CONVERSION_WEBGL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9243 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BROWSER_DEFAULT_WEBGL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9244 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
};

template<> const ClassInfo JSWebGL2RenderingContextDOMConstructor::s_info = { "WebGL2RenderingContext"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSWebGL2RenderingContextDOMConstructor) };

template<> JSValue JSWebGL2RenderingContextDOMConstructor::prototypeForStructure(JSC::VM& vm, const JSDOMGlobalObject& globalObject)
{
    UNUSED_PARAM(vm);
    return globalObject.functionPrototype();
}

template<> void JSWebGL2RenderingContextDOMConstructor::initializeProperties(VM& vm, JSDOMGlobalObject& globalObject)
{
    putDirect(vm, vm.propertyNames->length, jsNumber(0), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);
    JSString* nameString = jsNontrivialString(vm, "WebGL2RenderingContext"_s);
    m_originalName.set(vm, this, nameString);
    putDirect(vm, vm.propertyNames->name, nameString, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);
    putDirect(vm, vm.propertyNames->prototype, JSWebGL2RenderingContext::prototype(vm, globalObject), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::DontDelete);
    reifyStaticProperties(vm, JSWebGL2RenderingContext::info(), JSWebGL2RenderingContextConstructorTableValues, *this);
}

/* Hash table for prototype */

static const std::array<HashTableValue, 790> JSWebGL2RenderingContextPrototypeTableValues {
    HashTableValue { "constructor"_s, static_cast<unsigned>(PropertyAttribute::DontEnum), NoIntrinsic, { HashTableValue::GetterSetterType, jsWebGL2RenderingContextConstructor, 0 } },
#if ENABLE(WEBGL)
    HashTableValue { "canvas"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsWebGL2RenderingContext_canvas, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "drawingBufferWidth"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsWebGL2RenderingContext_drawingBufferWidth, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "drawingBufferHeight"_s, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute, NoIntrinsic, { HashTableValue::GetterSetterType, jsWebGL2RenderingContext_drawingBufferHeight, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "bufferData"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_bufferData, 3 } },
    HashTableValue { "bufferSubData"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_bufferSubData, 3 } },
    HashTableValue { "copyBufferSubData"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_copyBufferSubData, 5 } },
    HashTableValue { "getBufferSubData"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getBufferSubData, 3 } },
    HashTableValue { "blitFramebuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_blitFramebuffer, 10 } },
    HashTableValue { "framebufferTextureLayer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_framebufferTextureLayer, 5 } },
    HashTableValue { "invalidateFramebuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_invalidateFramebuffer, 2 } },
    HashTableValue { "invalidateSubFramebuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_invalidateSubFramebuffer, 6 } },
    HashTableValue { "readBuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_readBuffer, 1 } },
    HashTableValue { "getInternalformatParameter"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getInternalformatParameter, 3 } },
    HashTableValue { "renderbufferStorageMultisample"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_renderbufferStorageMultisample, 5 } },
    HashTableValue { "texStorage2D"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_texStorage2D, 5 } },
    HashTableValue { "texStorage3D"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_texStorage3D, 6 } },
    HashTableValue { "texImage3D"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_texImage3D, 10 } },
    HashTableValue { "texSubImage3D"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_texSubImage3D, 11 } },
    HashTableValue { "copyTexSubImage3D"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_copyTexSubImage3D, 9 } },
    HashTableValue { "compressedTexImage3D"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_compressedTexImage3D, 8 } },
    HashTableValue { "compressedTexSubImage3D"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_compressedTexSubImage3D, 10 } },
    HashTableValue { "getFragDataLocation"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getFragDataLocation, 2 } },
    HashTableValue { "uniform1ui"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniform1ui, 2 } },
    HashTableValue { "uniform2ui"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniform2ui, 3 } },
    HashTableValue { "uniform3ui"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniform3ui, 4 } },
    HashTableValue { "uniform4ui"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniform4ui, 5 } },
    HashTableValue { "uniform1uiv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniform1uiv, 2 } },
    HashTableValue { "uniform2uiv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniform2uiv, 2 } },
    HashTableValue { "uniform3uiv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniform3uiv, 2 } },
    HashTableValue { "uniform4uiv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniform4uiv, 2 } },
    HashTableValue { "uniformMatrix2x3fv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniformMatrix2x3fv, 3 } },
    HashTableValue { "uniformMatrix3x2fv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniformMatrix3x2fv, 3 } },
    HashTableValue { "uniformMatrix2x4fv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniformMatrix2x4fv, 3 } },
    HashTableValue { "uniformMatrix4x2fv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniformMatrix4x2fv, 3 } },
    HashTableValue { "uniformMatrix3x4fv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniformMatrix3x4fv, 3 } },
    HashTableValue { "uniformMatrix4x3fv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniformMatrix4x3fv, 3 } },
    HashTableValue { "vertexAttribI4i"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_vertexAttribI4i, 5 } },
    HashTableValue { "vertexAttribI4iv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_vertexAttribI4iv, 2 } },
    HashTableValue { "vertexAttribI4ui"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_vertexAttribI4ui, 5 } },
    HashTableValue { "vertexAttribI4uiv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_vertexAttribI4uiv, 2 } },
    HashTableValue { "vertexAttribIPointer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_vertexAttribIPointer, 5 } },
    HashTableValue { "vertexAttribDivisor"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_vertexAttribDivisor, 2 } },
    HashTableValue { "drawArraysInstanced"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_drawArraysInstanced, 4 } },
    HashTableValue { "drawElementsInstanced"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_drawElementsInstanced, 5 } },
    HashTableValue { "drawRangeElements"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_drawRangeElements, 6 } },
    HashTableValue { "drawBuffers"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_drawBuffers, 1 } },
    HashTableValue { "clearBufferiv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_clearBufferiv, 3 } },
    HashTableValue { "clearBufferuiv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_clearBufferuiv, 3 } },
    HashTableValue { "clearBufferfv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_clearBufferfv, 3 } },
    HashTableValue { "clearBufferfi"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_clearBufferfi, 4 } },
    HashTableValue { "createQuery"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_createQuery, 0 } },
    HashTableValue { "deleteQuery"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_deleteQuery, 1 } },
    HashTableValue { "isQuery"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_isQuery, 1 } },
    HashTableValue { "beginQuery"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_beginQuery, 2 } },
    HashTableValue { "endQuery"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_endQuery, 1 } },
    HashTableValue { "getQuery"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getQuery, 2 } },
    HashTableValue { "getQueryParameter"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getQueryParameter, 2 } },
    HashTableValue { "createSampler"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_createSampler, 0 } },
    HashTableValue { "deleteSampler"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_deleteSampler, 1 } },
    HashTableValue { "isSampler"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_isSampler, 1 } },
    HashTableValue { "bindSampler"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_bindSampler, 2 } },
    HashTableValue { "samplerParameteri"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_samplerParameteri, 3 } },
    HashTableValue { "samplerParameterf"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_samplerParameterf, 3 } },
    HashTableValue { "getSamplerParameter"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getSamplerParameter, 2 } },
    HashTableValue { "fenceSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_fenceSync, 2 } },
    HashTableValue { "isSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_isSync, 1 } },
    HashTableValue { "deleteSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_deleteSync, 1 } },
    HashTableValue { "clientWaitSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_clientWaitSync, 3 } },
    HashTableValue { "waitSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_waitSync, 3 } },
    HashTableValue { "getSyncParameter"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getSyncParameter, 2 } },
    HashTableValue { "createTransformFeedback"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_createTransformFeedback, 0 } },
    HashTableValue { "deleteTransformFeedback"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_deleteTransformFeedback, 1 } },
    HashTableValue { "isTransformFeedback"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_isTransformFeedback, 1 } },
    HashTableValue { "bindTransformFeedback"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_bindTransformFeedback, 2 } },
    HashTableValue { "beginTransformFeedback"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_beginTransformFeedback, 1 } },
    HashTableValue { "endTransformFeedback"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_endTransformFeedback, 0 } },
    HashTableValue { "transformFeedbackVaryings"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_transformFeedbackVaryings, 3 } },
    HashTableValue { "getTransformFeedbackVarying"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getTransformFeedbackVarying, 2 } },
    HashTableValue { "pauseTransformFeedback"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_pauseTransformFeedback, 0 } },
    HashTableValue { "resumeTransformFeedback"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_resumeTransformFeedback, 0 } },
    HashTableValue { "bindBufferBase"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_bindBufferBase, 3 } },
    HashTableValue { "bindBufferRange"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_bindBufferRange, 5 } },
    HashTableValue { "getIndexedParameter"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getIndexedParameter, 2 } },
    HashTableValue { "getUniformIndices"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getUniformIndices, 2 } },
    HashTableValue { "getActiveUniforms"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getActiveUniforms, 3 } },
    HashTableValue { "getUniformBlockIndex"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getUniformBlockIndex, 2 } },
    HashTableValue { "getActiveUniformBlockParameter"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getActiveUniformBlockParameter, 3 } },
    HashTableValue { "getActiveUniformBlockName"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getActiveUniformBlockName, 2 } },
    HashTableValue { "uniformBlockBinding"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniformBlockBinding, 3 } },
    HashTableValue { "createVertexArray"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_createVertexArray, 0 } },
    HashTableValue { "deleteVertexArray"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_deleteVertexArray, 1 } },
    HashTableValue { "isVertexArray"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_isVertexArray, 1 } },
    HashTableValue { "bindVertexArray"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_bindVertexArray, 1 } },
    HashTableValue { "texImage2D"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_texImage2D, 6 } },
    HashTableValue { "texSubImage2D"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_texSubImage2D, 7 } },
    HashTableValue { "compressedTexImage2D"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_compressedTexImage2D, 7 } },
    HashTableValue { "compressedTexSubImage2D"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_compressedTexSubImage2D, 8 } },
    HashTableValue { "uniform1fv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniform1fv, 2 } },
    HashTableValue { "uniform2fv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniform2fv, 2 } },
    HashTableValue { "uniform3fv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniform3fv, 2 } },
    HashTableValue { "uniform4fv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniform4fv, 2 } },
    HashTableValue { "uniform1iv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniform1iv, 2 } },
    HashTableValue { "uniform2iv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniform2iv, 2 } },
    HashTableValue { "uniform3iv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniform3iv, 2 } },
    HashTableValue { "uniform4iv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniform4iv, 2 } },
    HashTableValue { "uniformMatrix2fv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniformMatrix2fv, 3 } },
    HashTableValue { "uniformMatrix3fv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniformMatrix3fv, 3 } },
    HashTableValue { "uniformMatrix4fv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniformMatrix4fv, 3 } },
    HashTableValue { "readPixels"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_readPixels, 7 } },
#if ENABLE(WEBGL)
    HashTableValue { "activeTexture"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_activeTexture, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "attachShader"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_attachShader, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "bindAttribLocation"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_bindAttribLocation, 3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "bindBuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_bindBuffer, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "bindFramebuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_bindFramebuffer, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "bindRenderbuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_bindRenderbuffer, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "bindTexture"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_bindTexture, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "blendColor"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_blendColor, 4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "blendEquation"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_blendEquation, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "blendEquationSeparate"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_blendEquationSeparate, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "blendFunc"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_blendFunc, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "blendFuncSeparate"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_blendFuncSeparate, 4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "checkFramebufferStatus"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_checkFramebufferStatus, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "clear"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_clear, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "clearColor"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_clearColor, 4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "clearDepth"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_clearDepth, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "clearStencil"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_clearStencil, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "colorMask"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_colorMask, 4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "compileShader"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_compileShader, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "copyTexImage2D"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_copyTexImage2D, 8 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "copyTexSubImage2D"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_copyTexSubImage2D, 8 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "createBuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_createBuffer, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "createFramebuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_createFramebuffer, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "createProgram"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_createProgram, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "createRenderbuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_createRenderbuffer, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "createShader"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_createShader, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "createTexture"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_createTexture, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "cullFace"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_cullFace, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "deleteBuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_deleteBuffer, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "deleteFramebuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_deleteFramebuffer, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "deleteProgram"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_deleteProgram, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "deleteRenderbuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_deleteRenderbuffer, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "deleteShader"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_deleteShader, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "deleteTexture"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_deleteTexture, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "depthFunc"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_depthFunc, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "depthMask"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_depthMask, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "depthRange"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_depthRange, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "detachShader"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_detachShader, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "disable"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_disable, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "disableVertexAttribArray"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_disableVertexAttribArray, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "drawArrays"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_drawArrays, 3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "drawElements"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_drawElements, 4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "enable"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_enable, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "enableVertexAttribArray"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_enableVertexAttribArray, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "finish"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_finish, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "flush"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_flush, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "framebufferRenderbuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_framebufferRenderbuffer, 4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "framebufferTexture2D"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_framebufferTexture2D, 5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "frontFace"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_frontFace, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "generateMipmap"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_generateMipmap, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getActiveAttrib"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getActiveAttrib, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getActiveUniform"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getActiveUniform, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getAttachedShaders"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getAttachedShaders, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getAttribLocation"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getAttribLocation, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getBufferParameter"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getBufferParameter, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getContextAttributes"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getContextAttributes, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getError"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getError, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getSupportedExtensions"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getSupportedExtensions, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getExtension"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getExtension, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getFramebufferAttachmentParameter"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getFramebufferAttachmentParameter, 3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getParameter"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getParameter, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getProgramParameter"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getProgramParameter, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getProgramInfoLog"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getProgramInfoLog, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getRenderbufferParameter"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getRenderbufferParameter, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getShaderParameter"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getShaderParameter, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getShaderInfoLog"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getShaderInfoLog, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getShaderPrecisionFormat"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getShaderPrecisionFormat, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getShaderSource"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getShaderSource, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getTexParameter"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getTexParameter, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getUniform"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getUniform, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getUniformLocation"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getUniformLocation, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getVertexAttrib"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getVertexAttrib, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "getVertexAttribOffset"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_getVertexAttribOffset, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "hint"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_hint, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "isBuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_isBuffer, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "isContextLost"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_isContextLost, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "isEnabled"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_isEnabled, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "isFramebuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_isFramebuffer, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "isProgram"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_isProgram, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "isRenderbuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_isRenderbuffer, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "isShader"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_isShader, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "isTexture"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_isTexture, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "lineWidth"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_lineWidth, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "linkProgram"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_linkProgram, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL) && ENABLE(WEBXR)
    HashTableValue { "makeXRCompatible"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_makeXRCompatible, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "pixelStorei"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_pixelStorei, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "polygonOffset"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_polygonOffset, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "renderbufferStorage"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_renderbufferStorage, 4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "sampleCoverage"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_sampleCoverage, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "scissor"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_scissor, 4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "shaderSource"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_shaderSource, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "stencilFunc"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_stencilFunc, 3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "stencilFuncSeparate"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_stencilFuncSeparate, 4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "stencilMask"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_stencilMask, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "stencilMaskSeparate"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_stencilMaskSeparate, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "stencilOp"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_stencilOp, 3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "stencilOpSeparate"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_stencilOpSeparate, 4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "texParameterf"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_texParameterf, 3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "texParameteri"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_texParameteri, 3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "uniform1f"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniform1f, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "uniform2f"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniform2f, 3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "uniform3f"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniform3f, 4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "uniform4f"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniform4f, 5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "uniform1i"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniform1i, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "uniform2i"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniform2i, 3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "uniform3i"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniform3i, 4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "uniform4i"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_uniform4i, 5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "useProgram"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_useProgram, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "validateProgram"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_validateProgram, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "vertexAttrib1f"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_vertexAttrib1f, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "vertexAttrib2f"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_vertexAttrib2f, 3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "vertexAttrib3f"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_vertexAttrib3f, 4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "vertexAttrib4f"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_vertexAttrib4f, 5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "vertexAttrib1fv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_vertexAttrib1fv, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "vertexAttrib2fv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_vertexAttrib2fv, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "vertexAttrib3fv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_vertexAttrib3fv, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "vertexAttrib4fv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_vertexAttrib4fv, 2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "vertexAttribPointer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_vertexAttribPointer, 6 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "viewport"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsWebGL2RenderingContextPrototypeFunction_viewport, 4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "READ_BUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0C02 } },
    HashTableValue { "UNPACK_ROW_LENGTH"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0CF2 } },
    HashTableValue { "UNPACK_SKIP_ROWS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0CF3 } },
    HashTableValue { "UNPACK_SKIP_PIXELS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0CF4 } },
    HashTableValue { "PACK_ROW_LENGTH"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D02 } },
    HashTableValue { "PACK_SKIP_ROWS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D03 } },
    HashTableValue { "PACK_SKIP_PIXELS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D04 } },
    HashTableValue { "COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1800 } },
    HashTableValue { "DEPTH"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1801 } },
    HashTableValue { "STENCIL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1802 } },
    HashTableValue { "RED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1903 } },
    HashTableValue { "RGB8"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8051 } },
    HashTableValue { "RGBA8"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8058 } },
    HashTableValue { "RGB10_A2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8059 } },
    HashTableValue { "TEXTURE_BINDING_3D"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x806A } },
    HashTableValue { "UNPACK_SKIP_IMAGES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x806D } },
    HashTableValue { "UNPACK_IMAGE_HEIGHT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x806E } },
    HashTableValue { "TEXTURE_3D"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x806F } },
    HashTableValue { "TEXTURE_WRAP_R"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8072 } },
    HashTableValue { "MAX_3D_TEXTURE_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8073 } },
    HashTableValue { "UNSIGNED_INT_2_10_10_10_REV"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8368 } },
    HashTableValue { "MAX_ELEMENTS_VERTICES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80E8 } },
    HashTableValue { "MAX_ELEMENTS_INDICES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80E9 } },
    HashTableValue { "TEXTURE_MIN_LOD"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x813A } },
    HashTableValue { "TEXTURE_MAX_LOD"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x813B } },
    HashTableValue { "TEXTURE_BASE_LEVEL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x813C } },
    HashTableValue { "TEXTURE_MAX_LEVEL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x813D } },
    HashTableValue { "MIN"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8007 } },
    HashTableValue { "MAX"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8008 } },
    HashTableValue { "DEPTH_COMPONENT24"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x81A6 } },
    HashTableValue { "MAX_TEXTURE_LOD_BIAS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84FD } },
    HashTableValue { "TEXTURE_COMPARE_MODE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x884C } },
    HashTableValue { "TEXTURE_COMPARE_FUNC"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x884D } },
    HashTableValue { "CURRENT_QUERY"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8865 } },
    HashTableValue { "QUERY_RESULT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8866 } },
    HashTableValue { "QUERY_RESULT_AVAILABLE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8867 } },
    HashTableValue { "STREAM_READ"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88E1 } },
    HashTableValue { "STREAM_COPY"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88E2 } },
    HashTableValue { "STATIC_READ"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88E5 } },
    HashTableValue { "STATIC_COPY"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88E6 } },
    HashTableValue { "DYNAMIC_READ"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88E9 } },
    HashTableValue { "DYNAMIC_COPY"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88EA } },
    HashTableValue { "MAX_DRAW_BUFFERS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8824 } },
    HashTableValue { "DRAW_BUFFER0"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8825 } },
    HashTableValue { "DRAW_BUFFER1"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8826 } },
    HashTableValue { "DRAW_BUFFER2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8827 } },
    HashTableValue { "DRAW_BUFFER3"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8828 } },
    HashTableValue { "DRAW_BUFFER4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8829 } },
    HashTableValue { "DRAW_BUFFER5"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x882A } },
    HashTableValue { "DRAW_BUFFER6"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x882B } },
    HashTableValue { "DRAW_BUFFER7"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x882C } },
    HashTableValue { "DRAW_BUFFER8"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x882D } },
    HashTableValue { "DRAW_BUFFER9"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x882E } },
    HashTableValue { "DRAW_BUFFER10"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x882F } },
    HashTableValue { "DRAW_BUFFER11"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8830 } },
    HashTableValue { "DRAW_BUFFER12"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8831 } },
    HashTableValue { "DRAW_BUFFER13"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8832 } },
    HashTableValue { "DRAW_BUFFER14"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8833 } },
    HashTableValue { "DRAW_BUFFER15"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8834 } },
    HashTableValue { "MAX_FRAGMENT_UNIFORM_COMPONENTS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B49 } },
    HashTableValue { "MAX_VERTEX_UNIFORM_COMPONENTS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B4A } },
    HashTableValue { "SAMPLER_3D"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B5F } },
    HashTableValue { "SAMPLER_2D_SHADOW"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B62 } },
    HashTableValue { "FRAGMENT_SHADER_DERIVATIVE_HINT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B8B } },
    HashTableValue { "PIXEL_PACK_BUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88EB } },
    HashTableValue { "PIXEL_UNPACK_BUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88EC } },
    HashTableValue { "PIXEL_PACK_BUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88ED } },
    HashTableValue { "PIXEL_UNPACK_BUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88EF } },
    HashTableValue { "FLOAT_MAT2x3"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B65 } },
    HashTableValue { "FLOAT_MAT2x4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B66 } },
    HashTableValue { "FLOAT_MAT3x2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B67 } },
    HashTableValue { "FLOAT_MAT3x4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B68 } },
    HashTableValue { "FLOAT_MAT4x2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B69 } },
    HashTableValue { "FLOAT_MAT4x3"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B6A } },
    HashTableValue { "SRGB"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C40 } },
    HashTableValue { "SRGB8"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C41 } },
    HashTableValue { "SRGB8_ALPHA8"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C43 } },
    HashTableValue { "COMPARE_REF_TO_TEXTURE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x884E } },
    HashTableValue { "RGBA32F"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8814 } },
    HashTableValue { "RGB32F"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8815 } },
    HashTableValue { "RGBA16F"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x881A } },
    HashTableValue { "RGB16F"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x881B } },
    HashTableValue { "VERTEX_ATTRIB_ARRAY_INTEGER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88FD } },
    HashTableValue { "MAX_ARRAY_TEXTURE_LAYERS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88FF } },
    HashTableValue { "MIN_PROGRAM_TEXEL_OFFSET"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8904 } },
    HashTableValue { "MAX_PROGRAM_TEXEL_OFFSET"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8905 } },
    HashTableValue { "MAX_VARYING_COMPONENTS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B4B } },
    HashTableValue { "TEXTURE_2D_ARRAY"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C1A } },
    HashTableValue { "TEXTURE_BINDING_2D_ARRAY"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C1D } },
    HashTableValue { "R11F_G11F_B10F"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C3A } },
    HashTableValue { "UNSIGNED_INT_10F_11F_11F_REV"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C3B } },
    HashTableValue { "RGB9_E5"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C3D } },
    HashTableValue { "UNSIGNED_INT_5_9_9_9_REV"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C3E } },
    HashTableValue { "TRANSFORM_FEEDBACK_BUFFER_MODE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C7F } },
    HashTableValue { "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C80 } },
    HashTableValue { "TRANSFORM_FEEDBACK_VARYINGS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C83 } },
    HashTableValue { "TRANSFORM_FEEDBACK_BUFFER_START"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C84 } },
    HashTableValue { "TRANSFORM_FEEDBACK_BUFFER_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C85 } },
    HashTableValue { "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C88 } },
    HashTableValue { "RASTERIZER_DISCARD"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C89 } },
    HashTableValue { "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C8A } },
    HashTableValue { "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C8B } },
    HashTableValue { "INTERLEAVED_ATTRIBS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C8C } },
    HashTableValue { "SEPARATE_ATTRIBS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C8D } },
    HashTableValue { "TRANSFORM_FEEDBACK_BUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C8E } },
    HashTableValue { "TRANSFORM_FEEDBACK_BUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C8F } },
    HashTableValue { "RGBA32UI"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D70 } },
    HashTableValue { "RGB32UI"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D71 } },
    HashTableValue { "RGBA16UI"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D76 } },
    HashTableValue { "RGB16UI"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D77 } },
    HashTableValue { "RGBA8UI"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D7C } },
    HashTableValue { "RGB8UI"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D7D } },
    HashTableValue { "RGBA32I"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D82 } },
    HashTableValue { "RGB32I"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D83 } },
    HashTableValue { "RGBA16I"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D88 } },
    HashTableValue { "RGB16I"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D89 } },
    HashTableValue { "RGBA8I"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D8E } },
    HashTableValue { "RGB8I"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D8F } },
    HashTableValue { "RED_INTEGER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D94 } },
    HashTableValue { "RGB_INTEGER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D98 } },
    HashTableValue { "RGBA_INTEGER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D99 } },
    HashTableValue { "SAMPLER_2D_ARRAY"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DC1 } },
    HashTableValue { "SAMPLER_2D_ARRAY_SHADOW"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DC4 } },
    HashTableValue { "SAMPLER_CUBE_SHADOW"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DC5 } },
    HashTableValue { "UNSIGNED_INT_VEC2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DC6 } },
    HashTableValue { "UNSIGNED_INT_VEC3"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DC7 } },
    HashTableValue { "UNSIGNED_INT_VEC4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DC8 } },
    HashTableValue { "INT_SAMPLER_2D"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DCA } },
    HashTableValue { "INT_SAMPLER_3D"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DCB } },
    HashTableValue { "INT_SAMPLER_CUBE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DCC } },
    HashTableValue { "INT_SAMPLER_2D_ARRAY"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DCF } },
    HashTableValue { "UNSIGNED_INT_SAMPLER_2D"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DD2 } },
    HashTableValue { "UNSIGNED_INT_SAMPLER_3D"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DD3 } },
    HashTableValue { "UNSIGNED_INT_SAMPLER_CUBE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DD4 } },
    HashTableValue { "UNSIGNED_INT_SAMPLER_2D_ARRAY"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DD7 } },
    HashTableValue { "DEPTH_COMPONENT32F"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CAC } },
    HashTableValue { "DEPTH32F_STENCIL8"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CAD } },
    HashTableValue { "FLOAT_32_UNSIGNED_INT_24_8_REV"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DAD } },
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8210 } },
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8211 } },
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_RED_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8212 } },
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8213 } },
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8214 } },
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8215 } },
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8216 } },
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8217 } },
    HashTableValue { "FRAMEBUFFER_DEFAULT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8218 } },
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_STENCIL_ATTACHMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x821A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_STENCIL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84F9 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
    HashTableValue { "UNSIGNED_INT_24_8"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84FA } },
    HashTableValue { "DEPTH24_STENCIL8"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88F0 } },
    HashTableValue { "UNSIGNED_NORMALIZED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C17 } },
    HashTableValue { "DRAW_FRAMEBUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CA6 } },
    HashTableValue { "READ_FRAMEBUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CA8 } },
    HashTableValue { "DRAW_FRAMEBUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CA9 } },
    HashTableValue { "READ_FRAMEBUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CAA } },
    HashTableValue { "RENDERBUFFER_SAMPLES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CAB } },
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD4 } },
    HashTableValue { "MAX_COLOR_ATTACHMENTS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CDF } },
    HashTableValue { "COLOR_ATTACHMENT1"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CE1 } },
    HashTableValue { "COLOR_ATTACHMENT2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CE2 } },
    HashTableValue { "COLOR_ATTACHMENT3"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CE3 } },
    HashTableValue { "COLOR_ATTACHMENT4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CE4 } },
    HashTableValue { "COLOR_ATTACHMENT5"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CE5 } },
    HashTableValue { "COLOR_ATTACHMENT6"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CE6 } },
    HashTableValue { "COLOR_ATTACHMENT7"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CE7 } },
    HashTableValue { "COLOR_ATTACHMENT8"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CE8 } },
    HashTableValue { "COLOR_ATTACHMENT9"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CE9 } },
    HashTableValue { "COLOR_ATTACHMENT10"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CEA } },
    HashTableValue { "COLOR_ATTACHMENT11"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CEB } },
    HashTableValue { "COLOR_ATTACHMENT12"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CEC } },
    HashTableValue { "COLOR_ATTACHMENT13"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CED } },
    HashTableValue { "COLOR_ATTACHMENT14"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CEE } },
    HashTableValue { "COLOR_ATTACHMENT15"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CEF } },
    HashTableValue { "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D56 } },
    HashTableValue { "MAX_SAMPLES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D57 } },
    HashTableValue { "HALF_FLOAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x140B } },
    HashTableValue { "RG"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8227 } },
    HashTableValue { "RG_INTEGER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8228 } },
    HashTableValue { "R8"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8229 } },
    HashTableValue { "RG8"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x822B } },
    HashTableValue { "R16F"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x822D } },
    HashTableValue { "R32F"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x822E } },
    HashTableValue { "RG16F"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x822F } },
    HashTableValue { "RG32F"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8230 } },
    HashTableValue { "R8I"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8231 } },
    HashTableValue { "R8UI"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8232 } },
    HashTableValue { "R16I"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8233 } },
    HashTableValue { "R16UI"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8234 } },
    HashTableValue { "R32I"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8235 } },
    HashTableValue { "R32UI"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8236 } },
    HashTableValue { "RG8I"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8237 } },
    HashTableValue { "RG8UI"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8238 } },
    HashTableValue { "RG16I"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8239 } },
    HashTableValue { "RG16UI"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x823A } },
    HashTableValue { "RG32I"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x823B } },
    HashTableValue { "RG32UI"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x823C } },
    HashTableValue { "VERTEX_ARRAY_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x85B5 } },
    HashTableValue { "R8_SNORM"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8F94 } },
    HashTableValue { "RG8_SNORM"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8F95 } },
    HashTableValue { "RGB8_SNORM"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8F96 } },
    HashTableValue { "RGBA8_SNORM"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8F97 } },
    HashTableValue { "SIGNED_NORMALIZED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8F9C } },
    HashTableValue { "COPY_READ_BUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8F36 } },
    HashTableValue { "COPY_WRITE_BUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8F37 } },
    HashTableValue { "COPY_READ_BUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8F36 } },
    HashTableValue { "COPY_WRITE_BUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8F37 } },
    HashTableValue { "UNIFORM_BUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A11 } },
    HashTableValue { "UNIFORM_BUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A28 } },
    HashTableValue { "UNIFORM_BUFFER_START"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A29 } },
    HashTableValue { "UNIFORM_BUFFER_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A2A } },
    HashTableValue { "MAX_VERTEX_UNIFORM_BLOCKS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A2B } },
    HashTableValue { "MAX_FRAGMENT_UNIFORM_BLOCKS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A2D } },
    HashTableValue { "MAX_COMBINED_UNIFORM_BLOCKS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A2E } },
    HashTableValue { "MAX_UNIFORM_BUFFER_BINDINGS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A2F } },
    HashTableValue { "MAX_UNIFORM_BLOCK_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A30 } },
    HashTableValue { "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A31 } },
    HashTableValue { "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A33 } },
    HashTableValue { "UNIFORM_BUFFER_OFFSET_ALIGNMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A34 } },
    HashTableValue { "ACTIVE_UNIFORM_BLOCKS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A36 } },
    HashTableValue { "UNIFORM_TYPE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A37 } },
    HashTableValue { "UNIFORM_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A38 } },
    HashTableValue { "UNIFORM_BLOCK_INDEX"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A3A } },
    HashTableValue { "UNIFORM_OFFSET"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A3B } },
    HashTableValue { "UNIFORM_ARRAY_STRIDE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A3C } },
    HashTableValue { "UNIFORM_MATRIX_STRIDE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A3D } },
    HashTableValue { "UNIFORM_IS_ROW_MAJOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A3E } },
    HashTableValue { "UNIFORM_BLOCK_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A3F } },
    HashTableValue { "UNIFORM_BLOCK_DATA_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A40 } },
    HashTableValue { "UNIFORM_BLOCK_ACTIVE_UNIFORMS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A42 } },
    HashTableValue { "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A43 } },
    HashTableValue { "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A44 } },
    HashTableValue { "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8A46 } },
    HashTableValue { "INVALID_INDEX"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0xFFFFFFFF } },
    HashTableValue { "MAX_VERTEX_OUTPUT_COMPONENTS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9122 } },
    HashTableValue { "MAX_FRAGMENT_INPUT_COMPONENTS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9125 } },
    HashTableValue { "MAX_SERVER_WAIT_TIMEOUT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9111 } },
    HashTableValue { "OBJECT_TYPE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9112 } },
    HashTableValue { "SYNC_CONDITION"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9113 } },
    HashTableValue { "SYNC_STATUS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9114 } },
    HashTableValue { "SYNC_FLAGS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9115 } },
    HashTableValue { "SYNC_FENCE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9116 } },
    HashTableValue { "SYNC_GPU_COMMANDS_COMPLETE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9117 } },
    HashTableValue { "UNSIGNALED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9118 } },
    HashTableValue { "SIGNALED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9119 } },
    HashTableValue { "ALREADY_SIGNALED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x911A } },
    HashTableValue { "TIMEOUT_EXPIRED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x911B } },
    HashTableValue { "CONDITION_SATISFIED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x911C } },
    HashTableValue { "WAIT_FAILED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x911D } },
    HashTableValue { "SYNC_FLUSH_COMMANDS_BIT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x00000001 } },
    HashTableValue { "VERTEX_ATTRIB_ARRAY_DIVISOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88FE } },
    HashTableValue { "ANY_SAMPLES_PASSED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8C2F } },
    HashTableValue { "ANY_SAMPLES_PASSED_CONSERVATIVE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D6A } },
    HashTableValue { "SAMPLER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8919 } },
    HashTableValue { "RGB10_A2UI"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x906F } },
    HashTableValue { "INT_2_10_10_10_REV"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D9F } },
    HashTableValue { "TRANSFORM_FEEDBACK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8E22 } },
    HashTableValue { "TRANSFORM_FEEDBACK_PAUSED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8E23 } },
    HashTableValue { "TRANSFORM_FEEDBACK_ACTIVE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8E24 } },
    HashTableValue { "TRANSFORM_FEEDBACK_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8E25 } },
    HashTableValue { "TEXTURE_IMMUTABLE_FORMAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x912F } },
    HashTableValue { "MAX_ELEMENT_INDEX"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D6B } },
    HashTableValue { "TEXTURE_IMMUTABLE_LEVELS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x82DF } },
    HashTableValue { "TIMEOUT_IGNORED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, -1 } },
    HashTableValue { "MAX_CLIENT_WAIT_TIMEOUT_WEBGL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9247 } },
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_BUFFER_BIT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x00000100 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BUFFER_BIT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x00000400 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "COLOR_BUFFER_BIT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x00004000 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "POINTS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0000 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0001 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINE_LOOP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0002 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINE_STRIP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0003 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TRIANGLES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0004 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TRIANGLE_STRIP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0005 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TRIANGLE_FAN"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0006 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ZERO"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ONE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SRC_COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0300 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ONE_MINUS_SRC_COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0301 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SRC_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0302 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ONE_MINUS_SRC_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0303 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DST_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0304 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ONE_MINUS_DST_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0305 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DST_COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0306 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ONE_MINUS_DST_COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0307 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SRC_ALPHA_SATURATE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0308 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FUNC_ADD"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8006 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_EQUATION"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8009 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_EQUATION_RGB"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8009 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_EQUATION_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x883D } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FUNC_SUBTRACT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x800A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FUNC_REVERSE_SUBTRACT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x800B } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_DST_RGB"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80C8 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_SRC_RGB"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80C9 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_DST_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80CA } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_SRC_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80CB } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CONSTANT_COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8001 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ONE_MINUS_CONSTANT_COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8002 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CONSTANT_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8003 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ONE_MINUS_CONSTANT_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8004 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND_COLOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8005 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ARRAY_BUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8892 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ELEMENT_ARRAY_BUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8893 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ARRAY_BUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8894 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ELEMENT_ARRAY_BUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8895 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STREAM_DRAW"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88E0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STATIC_DRAW"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88E4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DYNAMIC_DRAW"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x88E8 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BUFFER_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8764 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BUFFER_USAGE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8765 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CURRENT_VERTEX_ATTRIB"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8626 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRONT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0404 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BACK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0405 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRONT_AND_BACK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0408 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_2D"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0DE1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CULL_FACE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B44 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLEND"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0BE2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DITHER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0BD0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_TEST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B90 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_TEST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B71 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SCISSOR_TEST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0C11 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "POLYGON_OFFSET_FILL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8037 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLE_ALPHA_TO_COVERAGE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x809E } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLE_COVERAGE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80A0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NO_ERROR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INVALID_ENUM"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0500 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INVALID_VALUE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0501 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INVALID_OPERATION"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0502 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "OUT_OF_MEMORY"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0505 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CW"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0900 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CCW"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0901 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINE_WIDTH"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B21 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ALIASED_POINT_SIZE_RANGE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x846D } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ALIASED_LINE_WIDTH_RANGE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x846E } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CULL_FACE_MODE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B45 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRONT_FACE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B46 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_RANGE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B70 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_WRITEMASK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B72 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_CLEAR_VALUE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B73 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_FUNC"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B74 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_CLEAR_VALUE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B91 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_FUNC"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B92 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_FAIL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B94 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_PASS_DEPTH_FAIL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B95 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_PASS_DEPTH_PASS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B96 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_REF"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B97 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_VALUE_MASK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B93 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_WRITEMASK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0B98 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BACK_FUNC"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8800 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BACK_FAIL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8801 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BACK_PASS_DEPTH_FAIL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8802 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BACK_PASS_DEPTH_PASS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8803 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BACK_REF"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CA3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BACK_VALUE_MASK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CA4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BACK_WRITEMASK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CA5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VIEWPORT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0BA2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SCISSOR_BOX"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0C10 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "COLOR_CLEAR_VALUE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0C22 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "COLOR_WRITEMASK"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0C23 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNPACK_ALIGNMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0CF5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "PACK_ALIGNMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D05 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_TEXTURE_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D33 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_VIEWPORT_DIMS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D3A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SUBPIXEL_BITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D50 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RED_BITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D52 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "GREEN_BITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D53 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BLUE_BITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D54 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ALPHA_BITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D55 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_BITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D56 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_BITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0D57 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "POLYGON_OFFSET_UNITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2A00 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "POLYGON_OFFSET_FACTOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8038 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_BINDING_2D"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8069 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLE_BUFFERS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80A8 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80A9 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLE_COVERAGE_VALUE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80AA } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLE_COVERAGE_INVERT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x80AB } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "COMPRESSED_TEXTURE_FORMATS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x86A3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DONT_CARE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1100 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FASTEST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1101 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NICEST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1102 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "GENERATE_MIPMAP_HINT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8192 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BYTE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1400 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNSIGNED_BYTE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1401 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SHORT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1402 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNSIGNED_SHORT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1403 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1404 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNSIGNED_INT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1405 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FLOAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1406 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_COMPONENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1902 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1906 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RGB"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1907 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RGBA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1908 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LUMINANCE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1909 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LUMINANCE_ALPHA"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x190A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNSIGNED_SHORT_4_4_4_4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8033 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNSIGNED_SHORT_5_5_5_1"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8034 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNSIGNED_SHORT_5_6_5"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8363 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAGMENT_SHADER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B30 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_SHADER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B31 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_VERTEX_ATTRIBS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8869 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_VERTEX_UNIFORM_VECTORS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DFB } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_VARYING_VECTORS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DFC } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_COMBINED_TEXTURE_IMAGE_UNITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B4D } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_VERTEX_TEXTURE_IMAGE_UNITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B4C } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_TEXTURE_IMAGE_UNITS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8872 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_FRAGMENT_UNIFORM_VECTORS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DFD } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SHADER_TYPE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B4F } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DELETE_STATUS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B80 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINK_STATUS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B82 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VALIDATE_STATUS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B83 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ATTACHED_SHADERS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B85 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ACTIVE_UNIFORMS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B86 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ACTIVE_ATTRIBUTES"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B89 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SHADING_LANGUAGE_VERSION"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B8C } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CURRENT_PROGRAM"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B8D } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NEVER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0200 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LESS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0201 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "EQUAL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0202 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LEQUAL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0203 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "GREATER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0204 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NOTEQUAL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0205 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "GEQUAL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0206 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ALWAYS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0207 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "KEEP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1E00 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "REPLACE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1E01 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INCR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1E02 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DECR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1E03 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INVERT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x150A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INCR_WRAP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8507 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DECR_WRAP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8508 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VENDOR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1F00 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1F01 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERSION"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1F02 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NEAREST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2600 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINEAR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2601 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NEAREST_MIPMAP_NEAREST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2700 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINEAR_MIPMAP_NEAREST"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2701 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NEAREST_MIPMAP_LINEAR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2702 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LINEAR_MIPMAP_LINEAR"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2703 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_MAG_FILTER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2800 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_MIN_FILTER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2801 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_WRAP_S"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2802 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_WRAP_T"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2803 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x1702 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_CUBE_MAP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8513 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_BINDING_CUBE_MAP"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8514 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_CUBE_MAP_POSITIVE_X"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8515 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_CUBE_MAP_NEGATIVE_X"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8516 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_CUBE_MAP_POSITIVE_Y"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8517 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_CUBE_MAP_NEGATIVE_Y"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8518 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_CUBE_MAP_POSITIVE_Z"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8519 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE_CUBE_MAP_NEGATIVE_Z"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x851A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_CUBE_MAP_TEXTURE_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x851C } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE0"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE1"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE3"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE5"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE6"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C6 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE7"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C7 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE8"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C8 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE9"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84C9 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE10"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84CA } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE11"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84CB } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE12"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84CC } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE13"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84CD } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE14"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84CE } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE15"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84CF } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE16"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE17"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE18"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE19"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE20"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE21"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE22"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D6 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE23"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D7 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE24"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D8 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE25"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84D9 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE26"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84DA } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE27"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84DB } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE28"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84DC } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE29"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84DD } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE30"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84DE } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "TEXTURE31"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84DF } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "ACTIVE_TEXTURE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84E0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "REPEAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x2901 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CLAMP_TO_EDGE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x812F } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MIRRORED_REPEAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8370 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FLOAT_VEC2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B50 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FLOAT_VEC3"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B51 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FLOAT_VEC4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B52 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INT_VEC2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B53 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INT_VEC3"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B54 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INT_VEC4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B55 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BOOL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B56 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BOOL_VEC2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B57 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BOOL_VEC3"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B58 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BOOL_VEC4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B59 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FLOAT_MAT2"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B5A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FLOAT_MAT3"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B5B } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FLOAT_MAT4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B5C } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLER_2D"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B5E } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "SAMPLER_CUBE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B60 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_ATTRIB_ARRAY_ENABLED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8622 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_ATTRIB_ARRAY_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8623 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_ATTRIB_ARRAY_STRIDE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8624 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_ATTRIB_ARRAY_TYPE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8625 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_ATTRIB_ARRAY_NORMALIZED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x886A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_ATTRIB_ARRAY_POINTER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8645 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x889F } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "IMPLEMENTATION_COLOR_READ_TYPE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B9A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "IMPLEMENTATION_COLOR_READ_FORMAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B9B } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "COMPILE_STATUS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8B81 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LOW_FLOAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DF0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MEDIUM_FLOAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DF1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "HIGH_FLOAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DF2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "LOW_INT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DF3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MEDIUM_INT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DF4 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "HIGH_INT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8DF5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D40 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D41 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RGBA4"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8056 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RGB5_A1"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8057 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RGB565"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D62 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_COMPONENT16"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x81A5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_INDEX8"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D48 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_STENCIL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84F9 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_WIDTH"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D42 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_HEIGHT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D43 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_INTERNAL_FORMAT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D44 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_RED_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D50 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_GREEN_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D51 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_BLUE_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D52 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_ALPHA_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D53 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_DEPTH_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D54 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_STENCIL_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D55 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD1 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD2 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD3 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "COLOR_ATTACHMENT0"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CE0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_ATTACHMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D00 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "STENCIL_ATTACHMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8D20 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "DEPTH_STENCIL_ATTACHMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x821A } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "NONE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_COMPLETE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD5 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_INCOMPLETE_ATTACHMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD6 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD7 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_INCOMPLETE_DIMENSIONS"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CD9 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_UNSUPPORTED"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CDD } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "FRAMEBUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CA6 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "RENDERBUFFER_BINDING"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x8CA7 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "MAX_RENDERBUFFER_SIZE"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x84E8 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "INVALID_FRAMEBUFFER_OPERATION"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x0506 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNPACK_FLIP_Y_WEBGL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9240 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNPACK_PREMULTIPLY_ALPHA_WEBGL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9241 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "CONTEXT_LOST_WEBGL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9242 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "UNPACK_COLORSPACE_CONVERSION_WEBGL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9243 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
#if ENABLE(WEBGL)
    HashTableValue { "BROWSER_DEFAULT_WEBGL"_s, PropertyAttribute::ReadOnly | PropertyAttribute::DontDelete | PropertyAttribute::ConstantInteger, NoIntrinsic, { HashTableValue::ConstantType, 0x9244 } },
#else
    HashTableValue { { }, 0, NoIntrinsic, { HashTableValue::End } },
#endif
};

const ClassInfo JSWebGL2RenderingContextPrototype::s_info = { "WebGL2RenderingContext"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSWebGL2RenderingContextPrototype) };

void JSWebGL2RenderingContextPrototype::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSWebGL2RenderingContext::info(), JSWebGL2RenderingContextPrototypeTableValues, *this);
    bool hasDisabledRuntimeProperties = false;
#if ENABLE(WEBGL) && ENABLE(WEBXR)
    if (!jsCast<JSDOMGlobalObject*>(globalObject())->scriptExecutionContext()->settingsValues().webXREnabled) {
        hasDisabledRuntimeProperties = true;
        auto propertyName = Identifier::fromString(vm, "makeXRCompatible"_s);
        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);
        DeletePropertySlot slot;
        JSObject::deleteProperty(this, globalObject(), propertyName, slot);
    }
#endif
    if (hasDisabledRuntimeProperties && structure()->isDictionary())
        flattenDictionaryObject(vm);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

const ClassInfo JSWebGL2RenderingContext::s_info = { "WebGL2RenderingContext"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSWebGL2RenderingContext) };

JSWebGL2RenderingContext::JSWebGL2RenderingContext(Structure* structure, JSDOMGlobalObject& globalObject, Ref<WebGL2RenderingContext>&& impl)
    : JSDOMWrapper<WebGL2RenderingContext>(structure, globalObject, WTFMove(impl))
{
}

static_assert(std::is_base_of<ActiveDOMObject, WebGL2RenderingContext>::value, "Interface is marked as [ActiveDOMObject] but implementation class does not subclass ActiveDOMObject.");

JSObject* JSWebGL2RenderingContext::createPrototype(VM& vm, JSDOMGlobalObject& globalObject)
{
    auto* structure = JSWebGL2RenderingContextPrototype::createStructure(vm, &globalObject, globalObject.objectPrototype());
    structure->setMayBePrototype(true);
    return JSWebGL2RenderingContextPrototype::create(vm, &globalObject, structure);
}

JSObject* JSWebGL2RenderingContext::prototype(VM& vm, JSDOMGlobalObject& globalObject)
{
    return getDOMPrototype<JSWebGL2RenderingContext>(vm, globalObject);
}

JSValue JSWebGL2RenderingContext::getConstructor(VM& vm, const JSGlobalObject* globalObject)
{
    return getDOMConstructor<JSWebGL2RenderingContextDOMConstructor, DOMConstructorID::WebGL2RenderingContext>(vm, *jsCast<const JSDOMGlobalObject*>(globalObject));
}

void JSWebGL2RenderingContext::destroy(JSC::JSCell* cell)
{
    JSWebGL2RenderingContext* thisObject = static_cast<JSWebGL2RenderingContext*>(cell);
    thisObject->JSWebGL2RenderingContext::~JSWebGL2RenderingContext();
}

JSC_DEFINE_CUSTOM_GETTER(jsWebGL2RenderingContextConstructor, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* prototype = jsDynamicCast<JSWebGL2RenderingContextPrototype*>(JSValue::decode(thisValue));
    if (!prototype) [[unlikely]]
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(JSWebGL2RenderingContext::getConstructor(vm, prototype->globalObject()));
}

#if ENABLE(WEBGL)
static inline JSValue jsWebGL2RenderingContext_canvasGetter(JSGlobalObject& lexicalGlobalObject, JSWebGL2RenderingContext& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLUnion<IDLInterface<HTMLCanvasElement>>>(lexicalGlobalObject, *thisObject.globalObject(), throwScope, impl.canvas())));
}

JSC_DEFINE_CUSTOM_GETTER(jsWebGL2RenderingContext_canvas, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSWebGL2RenderingContext>::get<jsWebGL2RenderingContext_canvasGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

#endif

#if ENABLE(WEBGL)
static inline JSValue jsWebGL2RenderingContext_drawingBufferWidthGetter(JSGlobalObject& lexicalGlobalObject, JSWebGL2RenderingContext& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLLong>(lexicalGlobalObject, throwScope, impl.drawingBufferWidth())));
}

JSC_DEFINE_CUSTOM_GETTER(jsWebGL2RenderingContext_drawingBufferWidth, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSWebGL2RenderingContext>::get<jsWebGL2RenderingContext_drawingBufferWidthGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

#endif

#if ENABLE(WEBGL)
static inline JSValue jsWebGL2RenderingContext_drawingBufferHeightGetter(JSGlobalObject& lexicalGlobalObject, JSWebGL2RenderingContext& thisObject)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = thisObject.wrapped();
    RELEASE_AND_RETURN(throwScope, (toJS<IDLLong>(lexicalGlobalObject, throwScope, impl.drawingBufferHeight())));
}

JSC_DEFINE_CUSTOM_GETTER(jsWebGL2RenderingContext_drawingBufferHeight, (JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    return IDLAttribute<JSWebGL2RenderingContext>::get<jsWebGL2RenderingContext_drawingBufferHeightGetter, CastedThisErrorBehavior::Assert>(*lexicalGlobalObject, thisValue, attributeName);
}

#endif

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_bufferData1Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto dataConversionResult = convert<IDLAllowSharedAdaptor<IDLArrayBufferView>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "data"_s, "WebGL2RenderingContext"_s, "bufferData"_s, "ArrayBufferView"_s); });
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto usageConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (usageConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->argument(4);
    auto lengthConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument4.value());
    if (lengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "bufferData"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, usageConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, lengthConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.bufferData(targetConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue(), usageConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue(), lengthConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_bufferSubData1Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto dstByteOffsetConversionResult = convert<IDLLongLong>(*lexicalGlobalObject, argument1.value());
    if (dstByteOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto srcDataConversionResult = convert<IDLAllowSharedAdaptor<IDLArrayBufferView>>(*lexicalGlobalObject, argument2.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 2, "srcData"_s, "WebGL2RenderingContext"_s, "bufferSubData"_s, "ArrayBufferView"_s); });
    if (srcDataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->argument(4);
    auto lengthConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument4.value());
    if (lengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "bufferSubData"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dstByteOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcDataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, lengthConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.bufferSubData(targetConversionResult.releaseReturnValue(), dstByteOffsetConversionResult.releaseReturnValue(), srcDataConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue(), lengthConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_copyBufferSubDataBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 5) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto readTargetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (readTargetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto writeTargetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (writeTargetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto readOffsetConversionResult = convert<IDLLongLong>(*lexicalGlobalObject, argument2.value());
    if (readOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto writeOffsetConversionResult = convert<IDLLongLong>(*lexicalGlobalObject, argument3.value());
    if (writeOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto sizeConversionResult = convert<IDLLongLong>(*lexicalGlobalObject, argument4.value());
    if (sizeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "copyBufferSubData"_s, { InspectorCanvasCallTracer::processArgument(impl, readTargetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, writeTargetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, readOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, writeOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, sizeConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.copyBufferSubData(readTargetConversionResult.releaseReturnValue(), writeTargetConversionResult.releaseReturnValue(), readOffsetConversionResult.releaseReturnValue(), writeOffsetConversionResult.releaseReturnValue(), sizeConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_copyBufferSubData, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_copyBufferSubDataBody>(*lexicalGlobalObject, *callFrame, "copyBufferSubData");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getBufferSubDataBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto srcByteOffsetConversionResult = convert<IDLLongLong>(*lexicalGlobalObject, argument1.value());
    if (srcByteOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto dstDataConversionResult = convert<IDLAllowSharedAdaptor<IDLArrayBufferView>>(*lexicalGlobalObject, argument2.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 2, "dstData"_s, "WebGL2RenderingContext"_s, "getBufferSubData"_s, "ArrayBufferView"_s); });
    if (dstDataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->argument(3);
    auto dstOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (dstOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->argument(4);
    auto lengthConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument4.value());
    if (lengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getBufferSubData"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcByteOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dstDataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dstOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, lengthConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.getBufferSubData(targetConversionResult.releaseReturnValue(), srcByteOffsetConversionResult.releaseReturnValue(), dstDataConversionResult.releaseReturnValue(), dstOffsetConversionResult.releaseReturnValue(), lengthConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getBufferSubData, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getBufferSubDataBody>(*lexicalGlobalObject, *callFrame, "getBufferSubData");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_blitFramebufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 10) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto srcX0ConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument0.value());
    if (srcX0ConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto srcY0ConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (srcY0ConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto srcX1ConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (srcX1ConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto srcY1ConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (srcY1ConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto dstX0ConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (dstX0ConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto dstY0ConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (dstY0ConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto dstX1ConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument6.value());
    if (dstX1ConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto dstY1ConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument7.value());
    if (dstY1ConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument8 = callFrame->uncheckedArgument(8);
    auto maskConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument8.value());
    if (maskConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument9 = callFrame->uncheckedArgument(9);
    auto filterConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument9.value());
    if (filterConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "blitFramebuffer"_s, { InspectorCanvasCallTracer::processArgument(impl, srcX0ConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcY0ConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcX1ConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcY1ConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dstX0ConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dstY0ConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dstX1ConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dstY1ConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, maskConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, filterConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.blitFramebuffer(srcX0ConversionResult.releaseReturnValue(), srcY0ConversionResult.releaseReturnValue(), srcX1ConversionResult.releaseReturnValue(), srcY1ConversionResult.releaseReturnValue(), dstX0ConversionResult.releaseReturnValue(), dstY0ConversionResult.releaseReturnValue(), dstX1ConversionResult.releaseReturnValue(), dstY1ConversionResult.releaseReturnValue(), maskConversionResult.releaseReturnValue(), filterConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_blitFramebuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_blitFramebufferBody>(*lexicalGlobalObject, *callFrame, "blitFramebuffer");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_framebufferTextureLayerBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 5) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto attachmentConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (attachmentConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto textureConversionResult = convert<IDLNullable<IDLInterface<WebGLTexture>>>(*lexicalGlobalObject, argument2.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 2, "texture"_s, "WebGL2RenderingContext"_s, "framebufferTextureLayer"_s, "WebGLTexture"_s); });
    if (textureConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto layerConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (layerConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "framebufferTextureLayer"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, attachmentConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, textureConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, layerConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.framebufferTextureLayer(targetConversionResult.releaseReturnValue(), attachmentConversionResult.releaseReturnValue(), textureConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), layerConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_framebufferTextureLayer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_framebufferTextureLayerBody>(*lexicalGlobalObject, *callFrame, "framebufferTextureLayer");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_invalidateFramebufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto attachmentsConversionResult = convert<IDLSequence<IDLUnsignedLong>>(*lexicalGlobalObject, argument1.value());
    if (attachmentsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "invalidateFramebuffer"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, attachmentsConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.invalidateFramebuffer(targetConversionResult.releaseReturnValue(), attachmentsConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_invalidateFramebuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_invalidateFramebufferBody>(*lexicalGlobalObject, *callFrame, "invalidateFramebuffer");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_invalidateSubFramebufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 6) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto attachmentsConversionResult = convert<IDLSequence<IDLUnsignedLong>>(*lexicalGlobalObject, argument1.value());
    if (attachmentsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto xConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto yConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "invalidateSubFramebuffer"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, attachmentsConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.invalidateSubFramebuffer(targetConversionResult.releaseReturnValue(), attachmentsConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_invalidateSubFramebuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_invalidateSubFramebufferBody>(*lexicalGlobalObject, *callFrame, "invalidateSubFramebuffer");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_readBufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto srcConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (srcConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "readBuffer"_s, { InspectorCanvasCallTracer::processArgument(impl, srcConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.readBuffer(srcConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_readBuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_readBufferBody>(*lexicalGlobalObject, *callFrame, "readBuffer");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getInternalformatParameterBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto internalformatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (internalformatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getInternalformatParameter"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, internalformatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLWebGLAny>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getInternalformatParameter(targetConversionResult.releaseReturnValue(), internalformatConversionResult.releaseReturnValue(), pnameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getInternalformatParameter, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getInternalformatParameterBody>(*lexicalGlobalObject, *callFrame, "getInternalformatParameter");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_renderbufferStorageMultisampleBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 5) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto samplesConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (samplesConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto internalformatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (internalformatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "renderbufferStorageMultisample"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, samplesConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, internalformatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.renderbufferStorageMultisample(targetConversionResult.releaseReturnValue(), samplesConversionResult.releaseReturnValue(), internalformatConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_renderbufferStorageMultisample, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_renderbufferStorageMultisampleBody>(*lexicalGlobalObject, *callFrame, "renderbufferStorageMultisample");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_texStorage2DBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 5) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelsConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto internalformatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (internalformatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "texStorage2D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelsConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, internalformatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.texStorage2D(targetConversionResult.releaseReturnValue(), levelsConversionResult.releaseReturnValue(), internalformatConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_texStorage2D, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_texStorage2DBody>(*lexicalGlobalObject, *callFrame, "texStorage2D");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_texStorage3DBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 6) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelsConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto internalformatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (internalformatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto depthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (depthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "texStorage3D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelsConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, internalformatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, depthConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.texStorage3D(targetConversionResult.releaseReturnValue(), levelsConversionResult.releaseReturnValue(), internalformatConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), depthConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_texStorage3D, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_texStorage3DBody>(*lexicalGlobalObject, *callFrame, "texStorage3D");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_texImage3D1Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto internalformatConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (internalformatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto depthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (depthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto borderConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument6.value());
    if (borderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument7.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument8 = callFrame->uncheckedArgument(8);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument8.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument9 = callFrame->uncheckedArgument(9);
    auto pboOffsetConversionResult = convert<IDLLongLong>(*lexicalGlobalObject, argument9.value());
    if (pboOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "texImage3D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, internalformatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, depthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, borderConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pboOffsetConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.texImage3D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), internalformatConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), depthConversionResult.releaseReturnValue(), borderConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), pboOffsetConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_texImage3D2Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto internalformatConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (internalformatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto depthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (depthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto borderConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument6.value());
    if (borderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument7.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument8 = callFrame->uncheckedArgument(8);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument8.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument9 = callFrame->uncheckedArgument(9);
    auto sourceConversionResult = convert<IDLUnion<IDLInterface<ImageBitmap>, IDLInterface<ImageData>, IDLInterface<HTMLImageElement>, IDLInterface<HTMLCanvasElement>, IDLInterface<HTMLVideoElement>>>(*lexicalGlobalObject, argument9.value());
    if (sourceConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "texImage3D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, internalformatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, depthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, borderConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, sourceConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.texImage3D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), internalformatConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), depthConversionResult.releaseReturnValue(), borderConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), sourceConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_texImage3D3Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto internalformatConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (internalformatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto depthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (depthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto borderConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument6.value());
    if (borderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument7.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument8 = callFrame->uncheckedArgument(8);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument8.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument9 = callFrame->uncheckedArgument(9);
    auto pixelsConversionResult = convert<IDLNullable<IDLAllowSharedAdaptor<IDLArrayBufferView>>>(*lexicalGlobalObject, argument9.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 9, "pixels"_s, "WebGL2RenderingContext"_s, "texImage3D"_s, "ArrayBufferView"_s); });
    if (pixelsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "texImage3D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, internalformatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, depthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, borderConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pixelsConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.texImage3D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), internalformatConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), depthConversionResult.releaseReturnValue(), borderConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), pixelsConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_texImage3D4Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto internalformatConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (internalformatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto depthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (depthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto borderConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument6.value());
    if (borderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument7.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument8 = callFrame->uncheckedArgument(8);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument8.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument9 = callFrame->uncheckedArgument(9);
    auto srcDataConversionResult = convert<IDLAllowSharedAdaptor<IDLArrayBufferView>>(*lexicalGlobalObject, argument9.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 9, "srcData"_s, "WebGL2RenderingContext"_s, "texImage3D"_s, "ArrayBufferView"_s); });
    if (srcDataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument10 = callFrame->uncheckedArgument(10);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument10.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "texImage3D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, internalformatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, depthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, borderConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcDataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.texImage3D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), internalformatConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), depthConversionResult.releaseReturnValue(), borderConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), srcDataConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_texImage3DOverloadDispatcher(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    size_t argsCount = std::min<size_t>(11, callFrame->argumentCount());
    if (argsCount == 10) {
        JSValue distinguishingArg = callFrame->uncheckedArgument(9);
        if (distinguishingArg.isUndefinedOrNull())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texImage3D3Body(lexicalGlobalObject, callFrame, castedThis)));
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSImageBitmap>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texImage3D2Body(lexicalGlobalObject, callFrame, castedThis)));
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSImageData>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texImage3D2Body(lexicalGlobalObject, callFrame, castedThis)));
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSHTMLImageElement>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texImage3D2Body(lexicalGlobalObject, callFrame, castedThis)));
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSHTMLCanvasElement>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texImage3D2Body(lexicalGlobalObject, callFrame, castedThis)));
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSHTMLVideoElement>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texImage3D2Body(lexicalGlobalObject, callFrame, castedThis)));
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSArrayBufferView>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texImage3D3Body(lexicalGlobalObject, callFrame, castedThis)));
        if (distinguishingArg.isNumber())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texImage3D1Body(lexicalGlobalObject, callFrame, castedThis)));
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texImage3D1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    if (argsCount == 11) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texImage3D4Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    return argsCount < 10 ? throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject)) : throwVMTypeError(lexicalGlobalObject, throwScope);
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_texImage3D, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_texImage3DOverloadDispatcher>(*lexicalGlobalObject, *callFrame, "texImage3D");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_texSubImage3D1Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto xoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (xoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto yoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (yoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto zoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (zoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument6.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto depthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument7.value());
    if (depthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument8 = callFrame->uncheckedArgument(8);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument8.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument9 = callFrame->uncheckedArgument(9);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument9.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument10 = callFrame->uncheckedArgument(10);
    auto pboOffsetConversionResult = convert<IDLLongLong>(*lexicalGlobalObject, argument10.value());
    if (pboOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "texSubImage3D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, zoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, depthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pboOffsetConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.texSubImage3D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), xoffsetConversionResult.releaseReturnValue(), yoffsetConversionResult.releaseReturnValue(), zoffsetConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), depthConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), pboOffsetConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_texSubImage3D2Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto xoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (xoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto yoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (yoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto zoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (zoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument6.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto depthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument7.value());
    if (depthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument8 = callFrame->uncheckedArgument(8);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument8.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument9 = callFrame->uncheckedArgument(9);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument9.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument10 = callFrame->uncheckedArgument(10);
    auto sourceConversionResult = convert<IDLUnion<IDLInterface<ImageBitmap>, IDLInterface<ImageData>, IDLInterface<HTMLImageElement>, IDLInterface<HTMLCanvasElement>, IDLInterface<HTMLVideoElement>>>(*lexicalGlobalObject, argument10.value());
    if (sourceConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "texSubImage3D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, zoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, depthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, sourceConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.texSubImage3D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), xoffsetConversionResult.releaseReturnValue(), yoffsetConversionResult.releaseReturnValue(), zoffsetConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), depthConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), sourceConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_texSubImage3D3Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto xoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (xoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto yoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (yoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto zoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (zoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument6.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto depthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument7.value());
    if (depthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument8 = callFrame->uncheckedArgument(8);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument8.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument9 = callFrame->uncheckedArgument(9);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument9.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument10 = callFrame->uncheckedArgument(10);
    auto srcDataConversionResult = convert<IDLNullable<IDLAllowSharedAdaptor<IDLArrayBufferView>>>(*lexicalGlobalObject, argument10.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 10, "srcData"_s, "WebGL2RenderingContext"_s, "texSubImage3D"_s, "ArrayBufferView"_s); });
    if (srcDataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument11 = callFrame->argument(11);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument11.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "texSubImage3D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, zoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, depthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcDataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.texSubImage3D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), xoffsetConversionResult.releaseReturnValue(), yoffsetConversionResult.releaseReturnValue(), zoffsetConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), depthConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), srcDataConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_texSubImage3DOverloadDispatcher(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    size_t argsCount = std::min<size_t>(12, callFrame->argumentCount());
    if (argsCount == 11) {
        JSValue distinguishingArg = callFrame->uncheckedArgument(10);
        if (distinguishingArg.isUndefinedOrNull())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texSubImage3D3Body(lexicalGlobalObject, callFrame, castedThis)));
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSImageBitmap>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texSubImage3D2Body(lexicalGlobalObject, callFrame, castedThis)));
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSImageData>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texSubImage3D2Body(lexicalGlobalObject, callFrame, castedThis)));
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSHTMLImageElement>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texSubImage3D2Body(lexicalGlobalObject, callFrame, castedThis)));
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSHTMLCanvasElement>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texSubImage3D2Body(lexicalGlobalObject, callFrame, castedThis)));
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSHTMLVideoElement>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texSubImage3D2Body(lexicalGlobalObject, callFrame, castedThis)));
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSArrayBufferView>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texSubImage3D3Body(lexicalGlobalObject, callFrame, castedThis)));
        if (distinguishingArg.isNumber())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texSubImage3D1Body(lexicalGlobalObject, callFrame, castedThis)));
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texSubImage3D1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    if (argsCount == 12) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texSubImage3D3Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    return argsCount < 11 ? throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject)) : throwVMTypeError(lexicalGlobalObject, throwScope);
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_texSubImage3D, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_texSubImage3DOverloadDispatcher>(*lexicalGlobalObject, *callFrame, "texSubImage3D");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_copyTexSubImage3DBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 9) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto xoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (xoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto yoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (yoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto zoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (zoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto xConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto yConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument6.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument7.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument8 = callFrame->uncheckedArgument(8);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument8.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "copyTexSubImage3D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, zoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.copyTexSubImage3D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), xoffsetConversionResult.releaseReturnValue(), yoffsetConversionResult.releaseReturnValue(), zoffsetConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_copyTexSubImage3D, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_copyTexSubImage3DBody>(*lexicalGlobalObject, *callFrame, "copyTexSubImage3D");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_compressedTexImage3D1Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto internalformatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (internalformatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto depthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (depthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto borderConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument6.value());
    if (borderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto imageSizeConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument7.value());
    if (imageSizeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument8 = callFrame->uncheckedArgument(8);
    auto offsetConversionResult = convert<IDLLongLong>(*lexicalGlobalObject, argument8.value());
    if (offsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "compressedTexImage3D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, internalformatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, depthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, borderConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, imageSizeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, offsetConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.compressedTexImage3D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), internalformatConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), depthConversionResult.releaseReturnValue(), borderConversionResult.releaseReturnValue(), imageSizeConversionResult.releaseReturnValue(), offsetConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_compressedTexImage3D2Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto internalformatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (internalformatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto depthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (depthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto borderConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument6.value());
    if (borderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto srcDataConversionResult = convert<IDLAllowSharedAdaptor<IDLArrayBufferView>>(*lexicalGlobalObject, argument7.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 7, "srcData"_s, "WebGL2RenderingContext"_s, "compressedTexImage3D"_s, "ArrayBufferView"_s); });
    if (srcDataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument8 = callFrame->argument(8);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument8.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument9 = callFrame->argument(9);
    auto srcLengthOverrideConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument9.value());
    if (srcLengthOverrideConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "compressedTexImage3D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, internalformatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, depthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, borderConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcDataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcLengthOverrideConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.compressedTexImage3D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), internalformatConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), depthConversionResult.releaseReturnValue(), borderConversionResult.releaseReturnValue(), srcDataConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue(), srcLengthOverrideConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_compressedTexImage3DOverloadDispatcher(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    size_t argsCount = std::min<size_t>(10, callFrame->argumentCount());
    if (argsCount == 10) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_compressedTexImage3D2Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    if (argsCount == 8) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_compressedTexImage3D2Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    if (argsCount == 9) {
        JSValue distinguishingArg = callFrame->uncheckedArgument(7);
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSArrayBufferView>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_compressedTexImage3D2Body(lexicalGlobalObject, callFrame, castedThis)));
        if (distinguishingArg.isNumber())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_compressedTexImage3D1Body(lexicalGlobalObject, callFrame, castedThis)));
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_compressedTexImage3D1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    return argsCount < 8 ? throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject)) : throwVMTypeError(lexicalGlobalObject, throwScope);
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_compressedTexImage3D, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_compressedTexImage3DOverloadDispatcher>(*lexicalGlobalObject, *callFrame, "compressedTexImage3D");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_compressedTexSubImage3D1Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto xoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (xoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto yoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (yoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto zoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (zoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument6.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto depthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument7.value());
    if (depthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument8 = callFrame->uncheckedArgument(8);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument8.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument9 = callFrame->uncheckedArgument(9);
    auto imageSizeConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument9.value());
    if (imageSizeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument10 = callFrame->uncheckedArgument(10);
    auto offsetConversionResult = convert<IDLLongLong>(*lexicalGlobalObject, argument10.value());
    if (offsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "compressedTexSubImage3D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, zoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, depthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, imageSizeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, offsetConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.compressedTexSubImage3D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), xoffsetConversionResult.releaseReturnValue(), yoffsetConversionResult.releaseReturnValue(), zoffsetConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), depthConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), imageSizeConversionResult.releaseReturnValue(), offsetConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_compressedTexSubImage3D2Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto xoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (xoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto yoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (yoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto zoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (zoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument6.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto depthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument7.value());
    if (depthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument8 = callFrame->uncheckedArgument(8);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument8.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument9 = callFrame->uncheckedArgument(9);
    auto srcDataConversionResult = convert<IDLAllowSharedAdaptor<IDLArrayBufferView>>(*lexicalGlobalObject, argument9.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 9, "srcData"_s, "WebGL2RenderingContext"_s, "compressedTexSubImage3D"_s, "ArrayBufferView"_s); });
    if (srcDataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument10 = callFrame->argument(10);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument10.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument11 = callFrame->argument(11);
    auto srcLengthOverrideConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument11.value());
    if (srcLengthOverrideConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "compressedTexSubImage3D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, zoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, depthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcDataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcLengthOverrideConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.compressedTexSubImage3D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), xoffsetConversionResult.releaseReturnValue(), yoffsetConversionResult.releaseReturnValue(), zoffsetConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), depthConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), srcDataConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue(), srcLengthOverrideConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_compressedTexSubImage3DOverloadDispatcher(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    size_t argsCount = std::min<size_t>(12, callFrame->argumentCount());
    if (argsCount == 10) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_compressedTexSubImage3D2Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    if (argsCount == 11) {
        JSValue distinguishingArg = callFrame->uncheckedArgument(9);
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSArrayBufferView>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_compressedTexSubImage3D2Body(lexicalGlobalObject, callFrame, castedThis)));
        if (distinguishingArg.isNumber())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_compressedTexSubImage3D1Body(lexicalGlobalObject, callFrame, castedThis)));
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_compressedTexSubImage3D1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    if (argsCount == 12) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_compressedTexSubImage3D2Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    return argsCount < 10 ? throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject)) : throwVMTypeError(lexicalGlobalObject, throwScope);
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_compressedTexSubImage3D, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_compressedTexSubImage3DOverloadDispatcher>(*lexicalGlobalObject, *callFrame, "compressedTexSubImage3D");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getFragDataLocationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGL2RenderingContext"_s, "getFragDataLocation"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto nameConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (nameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getFragDataLocation"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, nameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLLong>(*lexicalGlobalObject, throwScope, impl.getFragDataLocation(*programConversionResult.releaseReturnValue(), nameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getFragDataLocation, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getFragDataLocationBody>(*lexicalGlobalObject, *callFrame, "getFragDataLocation");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform1uiBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform1ui"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto v0ConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (v0ConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform1ui"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, v0ConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform1ui(locationConversionResult.releaseReturnValue(), v0ConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform1ui, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniform1uiBody>(*lexicalGlobalObject, *callFrame, "uniform1ui");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform2uiBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform2ui"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto v0ConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (v0ConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto v1ConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (v1ConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform2ui"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, v0ConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, v1ConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform2ui(locationConversionResult.releaseReturnValue(), v0ConversionResult.releaseReturnValue(), v1ConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform2ui, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniform2uiBody>(*lexicalGlobalObject, *callFrame, "uniform2ui");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform3uiBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform3ui"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto v0ConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (v0ConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto v1ConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (v1ConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto v2ConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (v2ConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform3ui"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, v0ConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, v1ConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, v2ConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform3ui(locationConversionResult.releaseReturnValue(), v0ConversionResult.releaseReturnValue(), v1ConversionResult.releaseReturnValue(), v2ConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform3ui, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniform3uiBody>(*lexicalGlobalObject, *callFrame, "uniform3ui");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform4uiBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 5) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform4ui"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto v0ConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (v0ConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto v1ConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (v1ConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto v2ConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (v2ConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto v3ConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument4.value());
    if (v3ConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform4ui"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, v0ConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, v1ConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, v2ConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, v3ConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform4ui(locationConversionResult.releaseReturnValue(), v0ConversionResult.releaseReturnValue(), v1ConversionResult.releaseReturnValue(), v2ConversionResult.releaseReturnValue(), v3ConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform4ui, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniform4uiBody>(*lexicalGlobalObject, *callFrame, "uniform4ui");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform1uivBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform1uiv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto dataConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLUint32Array>, IDLSequence<IDLUnsignedLong>>>(*lexicalGlobalObject, argument1.value());
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->argument(2);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->argument(3);
    auto srcLengthConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (srcLengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform1uiv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcLengthConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform1uiv(locationConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue(), srcLengthConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform1uiv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniform1uivBody>(*lexicalGlobalObject, *callFrame, "uniform1uiv");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform2uivBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform2uiv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto dataConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLUint32Array>, IDLSequence<IDLUnsignedLong>>>(*lexicalGlobalObject, argument1.value());
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->argument(2);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->argument(3);
    auto srcLengthConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (srcLengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform2uiv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcLengthConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform2uiv(locationConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue(), srcLengthConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform2uiv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniform2uivBody>(*lexicalGlobalObject, *callFrame, "uniform2uiv");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform3uivBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform3uiv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto dataConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLUint32Array>, IDLSequence<IDLUnsignedLong>>>(*lexicalGlobalObject, argument1.value());
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->argument(2);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->argument(3);
    auto srcLengthConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (srcLengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform3uiv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcLengthConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform3uiv(locationConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue(), srcLengthConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform3uiv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniform3uivBody>(*lexicalGlobalObject, *callFrame, "uniform3uiv");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform4uivBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform4uiv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto dataConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLUint32Array>, IDLSequence<IDLUnsignedLong>>>(*lexicalGlobalObject, argument1.value());
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->argument(2);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->argument(3);
    auto srcLengthConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (srcLengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform4uiv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcLengthConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform4uiv(locationConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue(), srcLengthConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform4uiv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniform4uivBody>(*lexicalGlobalObject, *callFrame, "uniform4uiv");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniformMatrix2x3fvBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniformMatrix2x3fv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto transposeConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (transposeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto dataConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument2.value());
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->argument(3);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->argument(4);
    auto srcLengthConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument4.value());
    if (srcLengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniformMatrix2x3fv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, transposeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcLengthConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniformMatrix2x3fv(locationConversionResult.releaseReturnValue(), transposeConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue(), srcLengthConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniformMatrix2x3fv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniformMatrix2x3fvBody>(*lexicalGlobalObject, *callFrame, "uniformMatrix2x3fv");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniformMatrix3x2fvBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniformMatrix3x2fv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto transposeConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (transposeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto dataConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument2.value());
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->argument(3);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->argument(4);
    auto srcLengthConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument4.value());
    if (srcLengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniformMatrix3x2fv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, transposeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcLengthConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniformMatrix3x2fv(locationConversionResult.releaseReturnValue(), transposeConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue(), srcLengthConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniformMatrix3x2fv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniformMatrix3x2fvBody>(*lexicalGlobalObject, *callFrame, "uniformMatrix3x2fv");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniformMatrix2x4fvBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniformMatrix2x4fv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto transposeConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (transposeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto dataConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument2.value());
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->argument(3);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->argument(4);
    auto srcLengthConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument4.value());
    if (srcLengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniformMatrix2x4fv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, transposeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcLengthConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniformMatrix2x4fv(locationConversionResult.releaseReturnValue(), transposeConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue(), srcLengthConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniformMatrix2x4fv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniformMatrix2x4fvBody>(*lexicalGlobalObject, *callFrame, "uniformMatrix2x4fv");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniformMatrix4x2fvBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniformMatrix4x2fv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto transposeConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (transposeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto dataConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument2.value());
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->argument(3);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->argument(4);
    auto srcLengthConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument4.value());
    if (srcLengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniformMatrix4x2fv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, transposeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcLengthConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniformMatrix4x2fv(locationConversionResult.releaseReturnValue(), transposeConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue(), srcLengthConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniformMatrix4x2fv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniformMatrix4x2fvBody>(*lexicalGlobalObject, *callFrame, "uniformMatrix4x2fv");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniformMatrix3x4fvBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniformMatrix3x4fv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto transposeConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (transposeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto dataConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument2.value());
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->argument(3);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->argument(4);
    auto srcLengthConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument4.value());
    if (srcLengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniformMatrix3x4fv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, transposeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcLengthConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniformMatrix3x4fv(locationConversionResult.releaseReturnValue(), transposeConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue(), srcLengthConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniformMatrix3x4fv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniformMatrix3x4fvBody>(*lexicalGlobalObject, *callFrame, "uniformMatrix3x4fv");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniformMatrix4x3fvBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniformMatrix4x3fv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto transposeConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (transposeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto dataConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument2.value());
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->argument(3);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->argument(4);
    auto srcLengthConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument4.value());
    if (srcLengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniformMatrix4x3fv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, transposeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcLengthConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniformMatrix4x3fv(locationConversionResult.releaseReturnValue(), transposeConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue(), srcLengthConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniformMatrix4x3fv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniformMatrix4x3fvBody>(*lexicalGlobalObject, *callFrame, "uniformMatrix4x3fv");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_vertexAttribI4iBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 5) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto xConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto yConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto zConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (zConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto wConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (wConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "vertexAttribI4i"_s, { InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, zConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, wConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.vertexAttribI4i(indexConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), zConversionResult.releaseReturnValue(), wConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_vertexAttribI4i, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_vertexAttribI4iBody>(*lexicalGlobalObject, *callFrame, "vertexAttribI4i");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_vertexAttribI4ivBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto valuesConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLInt32Array>, IDLSequence<IDLLong>>>(*lexicalGlobalObject, argument1.value());
    if (valuesConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "vertexAttribI4iv"_s, { InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, valuesConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.vertexAttribI4iv(indexConversionResult.releaseReturnValue(), valuesConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_vertexAttribI4iv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_vertexAttribI4ivBody>(*lexicalGlobalObject, *callFrame, "vertexAttribI4iv");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_vertexAttribI4uiBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 5) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto xConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto yConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto zConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (zConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto wConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument4.value());
    if (wConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "vertexAttribI4ui"_s, { InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, zConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, wConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.vertexAttribI4ui(indexConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), zConversionResult.releaseReturnValue(), wConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_vertexAttribI4ui, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_vertexAttribI4uiBody>(*lexicalGlobalObject, *callFrame, "vertexAttribI4ui");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_vertexAttribI4uivBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto valuesConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLUint32Array>, IDLSequence<IDLUnsignedLong>>>(*lexicalGlobalObject, argument1.value());
    if (valuesConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "vertexAttribI4uiv"_s, { InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, valuesConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.vertexAttribI4uiv(indexConversionResult.releaseReturnValue(), valuesConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_vertexAttribI4uiv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_vertexAttribI4uivBody>(*lexicalGlobalObject, *callFrame, "vertexAttribI4uiv");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_vertexAttribIPointerBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 5) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto sizeConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (sizeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto strideConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (strideConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto offsetConversionResult = convert<IDLLongLong>(*lexicalGlobalObject, argument4.value());
    if (offsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "vertexAttribIPointer"_s, { InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, sizeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, strideConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, offsetConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.vertexAttribIPointer(indexConversionResult.releaseReturnValue(), sizeConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), strideConversionResult.releaseReturnValue(), offsetConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_vertexAttribIPointer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_vertexAttribIPointerBody>(*lexicalGlobalObject, *callFrame, "vertexAttribIPointer");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_vertexAttribDivisorBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto divisorConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (divisorConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "vertexAttribDivisor"_s, { InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, divisorConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.vertexAttribDivisor(indexConversionResult.releaseReturnValue(), divisorConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_vertexAttribDivisor, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_vertexAttribDivisorBody>(*lexicalGlobalObject, *callFrame, "vertexAttribDivisor");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_drawArraysInstancedBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto modeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (modeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto firstConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (firstConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto countConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (countConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto instanceCountConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (instanceCountConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "drawArraysInstanced"_s, { InspectorCanvasCallTracer::processArgument(impl, modeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, firstConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, countConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, instanceCountConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.drawArraysInstanced(modeConversionResult.releaseReturnValue(), firstConversionResult.releaseReturnValue(), countConversionResult.releaseReturnValue(), instanceCountConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_drawArraysInstanced, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_drawArraysInstancedBody>(*lexicalGlobalObject, *callFrame, "drawArraysInstanced");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_drawElementsInstancedBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 5) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto modeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (modeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto countConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (countConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto offsetConversionResult = convert<IDLLongLong>(*lexicalGlobalObject, argument3.value());
    if (offsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto instanceCountConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (instanceCountConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "drawElementsInstanced"_s, { InspectorCanvasCallTracer::processArgument(impl, modeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, countConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, offsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, instanceCountConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.drawElementsInstanced(modeConversionResult.releaseReturnValue(), countConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), offsetConversionResult.releaseReturnValue(), instanceCountConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_drawElementsInstanced, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_drawElementsInstancedBody>(*lexicalGlobalObject, *callFrame, "drawElementsInstanced");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_drawRangeElementsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 6) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto modeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (modeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto startConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (startConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto endConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (endConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto countConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (countConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument4.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto offsetConversionResult = convert<IDLLongLong>(*lexicalGlobalObject, argument5.value());
    if (offsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "drawRangeElements"_s, { InspectorCanvasCallTracer::processArgument(impl, modeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, startConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, endConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, countConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, offsetConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.drawRangeElements(modeConversionResult.releaseReturnValue(), startConversionResult.releaseReturnValue(), endConversionResult.releaseReturnValue(), countConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), offsetConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_drawRangeElements, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_drawRangeElementsBody>(*lexicalGlobalObject, *callFrame, "drawRangeElements");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_drawBuffersBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto buffersConversionResult = convert<IDLSequence<IDLUnsignedLong>>(*lexicalGlobalObject, argument0.value());
    if (buffersConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "drawBuffers"_s, { InspectorCanvasCallTracer::processArgument(impl, buffersConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.drawBuffers(buffersConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_drawBuffers, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_drawBuffersBody>(*lexicalGlobalObject, *callFrame, "drawBuffers");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_clearBufferivBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto bufferConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (bufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto drawbufferConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (drawbufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto valuesConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLInt32Array>, IDLSequence<IDLLong>>>(*lexicalGlobalObject, argument2.value());
    if (valuesConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->argument(3);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "clearBufferiv"_s, { InspectorCanvasCallTracer::processArgument(impl, bufferConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, drawbufferConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, valuesConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.clearBufferiv(bufferConversionResult.releaseReturnValue(), drawbufferConversionResult.releaseReturnValue(), valuesConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_clearBufferiv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_clearBufferivBody>(*lexicalGlobalObject, *callFrame, "clearBufferiv");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_clearBufferuivBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto bufferConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (bufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto drawbufferConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (drawbufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto valuesConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLUint32Array>, IDLSequence<IDLUnsignedLong>>>(*lexicalGlobalObject, argument2.value());
    if (valuesConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->argument(3);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "clearBufferuiv"_s, { InspectorCanvasCallTracer::processArgument(impl, bufferConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, drawbufferConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, valuesConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.clearBufferuiv(bufferConversionResult.releaseReturnValue(), drawbufferConversionResult.releaseReturnValue(), valuesConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_clearBufferuiv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_clearBufferuivBody>(*lexicalGlobalObject, *callFrame, "clearBufferuiv");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_clearBufferfvBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto bufferConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (bufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto drawbufferConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (drawbufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto valuesConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument2.value());
    if (valuesConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->argument(3);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "clearBufferfv"_s, { InspectorCanvasCallTracer::processArgument(impl, bufferConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, drawbufferConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, valuesConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.clearBufferfv(bufferConversionResult.releaseReturnValue(), drawbufferConversionResult.releaseReturnValue(), valuesConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_clearBufferfv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_clearBufferfvBody>(*lexicalGlobalObject, *callFrame, "clearBufferfv");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_clearBufferfiBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto bufferConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (bufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto drawbufferConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (drawbufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto depthConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument2.value());
    if (depthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto stencilConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (stencilConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "clearBufferfi"_s, { InspectorCanvasCallTracer::processArgument(impl, bufferConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, drawbufferConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, depthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, stencilConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.clearBufferfi(bufferConversionResult.releaseReturnValue(), drawbufferConversionResult.releaseReturnValue(), depthConversionResult.releaseReturnValue(), stencilConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_clearBufferfi, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_clearBufferfiBody>(*lexicalGlobalObject, *callFrame, "clearBufferfi");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_createQueryBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "createQuery"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLInterface<WebGLQuery>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.createQuery())));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_createQuery, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_createQueryBody>(*lexicalGlobalObject, *callFrame, "createQuery");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_deleteQueryBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto queryConversionResult = convert<IDLNullable<IDLInterface<WebGLQuery>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "query"_s, "WebGL2RenderingContext"_s, "deleteQuery"_s, "WebGLQuery"_s); });
    if (queryConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "deleteQuery"_s, { InspectorCanvasCallTracer::processArgument(impl, queryConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.deleteQuery(queryConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_deleteQuery, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_deleteQueryBody>(*lexicalGlobalObject, *callFrame, "deleteQuery");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_isQueryBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto queryConversionResult = convert<IDLNullable<IDLInterface<WebGLQuery>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "query"_s, "WebGL2RenderingContext"_s, "isQuery"_s, "WebGLQuery"_s); });
    if (queryConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "isQuery"_s, { InspectorCanvasCallTracer::processArgument(impl, queryConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isQuery(queryConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_isQuery, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_isQueryBody>(*lexicalGlobalObject, *callFrame, "isQuery");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_beginQueryBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto queryConversionResult = convert<IDLInterface<WebGLQuery>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "query"_s, "WebGL2RenderingContext"_s, "beginQuery"_s, "WebGLQuery"_s); });
    if (queryConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "beginQuery"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, queryConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.beginQuery(targetConversionResult.releaseReturnValue(), *queryConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_beginQuery, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_beginQueryBody>(*lexicalGlobalObject, *callFrame, "beginQuery");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_endQueryBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "endQuery"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.endQuery(targetConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_endQuery, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_endQueryBody>(*lexicalGlobalObject, *callFrame, "endQuery");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getQueryBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getQuery"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLWebGLAny>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getQuery(targetConversionResult.releaseReturnValue(), pnameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getQuery, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getQueryBody>(*lexicalGlobalObject, *callFrame, "getQuery");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getQueryParameterBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto queryConversionResult = convert<IDLInterface<WebGLQuery>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "query"_s, "WebGL2RenderingContext"_s, "getQueryParameter"_s, "WebGLQuery"_s); });
    if (queryConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getQueryParameter"_s, { InspectorCanvasCallTracer::processArgument(impl, queryConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLWebGLAny>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getQueryParameter(*queryConversionResult.releaseReturnValue(), pnameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getQueryParameter, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getQueryParameterBody>(*lexicalGlobalObject, *callFrame, "getQueryParameter");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_createSamplerBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "createSampler"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLInterface<WebGLSampler>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.createSampler())));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_createSampler, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_createSamplerBody>(*lexicalGlobalObject, *callFrame, "createSampler");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_deleteSamplerBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto samplerConversionResult = convert<IDLNullable<IDLInterface<WebGLSampler>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "sampler"_s, "WebGL2RenderingContext"_s, "deleteSampler"_s, "WebGLSampler"_s); });
    if (samplerConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "deleteSampler"_s, { InspectorCanvasCallTracer::processArgument(impl, samplerConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.deleteSampler(samplerConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_deleteSampler, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_deleteSamplerBody>(*lexicalGlobalObject, *callFrame, "deleteSampler");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_isSamplerBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto samplerConversionResult = convert<IDLNullable<IDLInterface<WebGLSampler>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "sampler"_s, "WebGL2RenderingContext"_s, "isSampler"_s, "WebGLSampler"_s); });
    if (samplerConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "isSampler"_s, { InspectorCanvasCallTracer::processArgument(impl, samplerConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isSampler(samplerConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_isSampler, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_isSamplerBody>(*lexicalGlobalObject, *callFrame, "isSampler");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_bindSamplerBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto unitConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (unitConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto samplerConversionResult = convert<IDLNullable<IDLInterface<WebGLSampler>>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "sampler"_s, "WebGL2RenderingContext"_s, "bindSampler"_s, "WebGLSampler"_s); });
    if (samplerConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "bindSampler"_s, { InspectorCanvasCallTracer::processArgument(impl, unitConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, samplerConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.bindSampler(unitConversionResult.releaseReturnValue(), samplerConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_bindSampler, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_bindSamplerBody>(*lexicalGlobalObject, *callFrame, "bindSampler");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_samplerParameteriBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto samplerConversionResult = convert<IDLInterface<WebGLSampler>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "sampler"_s, "WebGL2RenderingContext"_s, "samplerParameteri"_s, "WebGLSampler"_s); });
    if (samplerConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto paramConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (paramConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "samplerParameteri"_s, { InspectorCanvasCallTracer::processArgument(impl, samplerConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, paramConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.samplerParameteri(*samplerConversionResult.releaseReturnValue(), pnameConversionResult.releaseReturnValue(), paramConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_samplerParameteri, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_samplerParameteriBody>(*lexicalGlobalObject, *callFrame, "samplerParameteri");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_samplerParameterfBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto samplerConversionResult = convert<IDLInterface<WebGLSampler>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "sampler"_s, "WebGL2RenderingContext"_s, "samplerParameterf"_s, "WebGLSampler"_s); });
    if (samplerConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto paramConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument2.value());
    if (paramConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "samplerParameterf"_s, { InspectorCanvasCallTracer::processArgument(impl, samplerConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, paramConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.samplerParameterf(*samplerConversionResult.releaseReturnValue(), pnameConversionResult.releaseReturnValue(), paramConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_samplerParameterf, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_samplerParameterfBody>(*lexicalGlobalObject, *callFrame, "samplerParameterf");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getSamplerParameterBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto samplerConversionResult = convert<IDLInterface<WebGLSampler>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "sampler"_s, "WebGL2RenderingContext"_s, "getSamplerParameter"_s, "WebGLSampler"_s); });
    if (samplerConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getSamplerParameter"_s, { InspectorCanvasCallTracer::processArgument(impl, samplerConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLWebGLAny>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getSamplerParameter(*samplerConversionResult.releaseReturnValue(), pnameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getSamplerParameter, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getSamplerParameterBody>(*lexicalGlobalObject, *callFrame, "getSamplerParameter");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_fenceSyncBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto conditionConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (conditionConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto flagsConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (flagsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "fenceSync"_s, { InspectorCanvasCallTracer::processArgument(impl, conditionConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, flagsConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLInterface<WebGLSync>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.fenceSync(conditionConversionResult.releaseReturnValue(), flagsConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_fenceSync, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_fenceSyncBody>(*lexicalGlobalObject, *callFrame, "fenceSync");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_isSyncBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto syncConversionResult = convert<IDLNullable<IDLInterface<WebGLSync>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "sync"_s, "WebGL2RenderingContext"_s, "isSync"_s, "WebGLSync"_s); });
    if (syncConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "isSync"_s, { InspectorCanvasCallTracer::processArgument(impl, syncConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isSync(syncConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_isSync, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_isSyncBody>(*lexicalGlobalObject, *callFrame, "isSync");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_deleteSyncBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto syncConversionResult = convert<IDLNullable<IDLInterface<WebGLSync>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "sync"_s, "WebGL2RenderingContext"_s, "deleteSync"_s, "WebGLSync"_s); });
    if (syncConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "deleteSync"_s, { InspectorCanvasCallTracer::processArgument(impl, syncConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.deleteSync(syncConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_deleteSync, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_deleteSyncBody>(*lexicalGlobalObject, *callFrame, "deleteSync");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_clientWaitSyncBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto syncConversionResult = convert<IDLInterface<WebGLSync>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "sync"_s, "WebGL2RenderingContext"_s, "clientWaitSync"_s, "WebGLSync"_s); });
    if (syncConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto flagsConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (flagsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto timeoutConversionResult = convert<IDLUnsignedLongLong>(*lexicalGlobalObject, argument2.value());
    if (timeoutConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "clientWaitSync"_s, { InspectorCanvasCallTracer::processArgument(impl, syncConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, flagsConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, timeoutConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.clientWaitSync(*syncConversionResult.releaseReturnValue(), flagsConversionResult.releaseReturnValue(), timeoutConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_clientWaitSync, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_clientWaitSyncBody>(*lexicalGlobalObject, *callFrame, "clientWaitSync");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_waitSyncBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto syncConversionResult = convert<IDLInterface<WebGLSync>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "sync"_s, "WebGL2RenderingContext"_s, "waitSync"_s, "WebGLSync"_s); });
    if (syncConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto flagsConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (flagsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto timeoutConversionResult = convert<IDLLongLong>(*lexicalGlobalObject, argument2.value());
    if (timeoutConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "waitSync"_s, { InspectorCanvasCallTracer::processArgument(impl, syncConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, flagsConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, timeoutConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.waitSync(*syncConversionResult.releaseReturnValue(), flagsConversionResult.releaseReturnValue(), timeoutConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_waitSync, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_waitSyncBody>(*lexicalGlobalObject, *callFrame, "waitSync");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getSyncParameterBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto syncConversionResult = convert<IDLInterface<WebGLSync>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "sync"_s, "WebGL2RenderingContext"_s, "getSyncParameter"_s, "WebGLSync"_s); });
    if (syncConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getSyncParameter"_s, { InspectorCanvasCallTracer::processArgument(impl, syncConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLWebGLAny>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getSyncParameter(*syncConversionResult.releaseReturnValue(), pnameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getSyncParameter, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getSyncParameterBody>(*lexicalGlobalObject, *callFrame, "getSyncParameter");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_createTransformFeedbackBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "createTransformFeedback"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLInterface<WebGLTransformFeedback>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.createTransformFeedback())));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_createTransformFeedback, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_createTransformFeedbackBody>(*lexicalGlobalObject, *callFrame, "createTransformFeedback");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_deleteTransformFeedbackBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto idConversionResult = convert<IDLNullable<IDLInterface<WebGLTransformFeedback>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "id"_s, "WebGL2RenderingContext"_s, "deleteTransformFeedback"_s, "WebGLTransformFeedback"_s); });
    if (idConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "deleteTransformFeedback"_s, { InspectorCanvasCallTracer::processArgument(impl, idConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.deleteTransformFeedback(idConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_deleteTransformFeedback, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_deleteTransformFeedbackBody>(*lexicalGlobalObject, *callFrame, "deleteTransformFeedback");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_isTransformFeedbackBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto idConversionResult = convert<IDLNullable<IDLInterface<WebGLTransformFeedback>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "id"_s, "WebGL2RenderingContext"_s, "isTransformFeedback"_s, "WebGLTransformFeedback"_s); });
    if (idConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "isTransformFeedback"_s, { InspectorCanvasCallTracer::processArgument(impl, idConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isTransformFeedback(idConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_isTransformFeedback, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_isTransformFeedbackBody>(*lexicalGlobalObject, *callFrame, "isTransformFeedback");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_bindTransformFeedbackBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto idConversionResult = convert<IDLNullable<IDLInterface<WebGLTransformFeedback>>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "id"_s, "WebGL2RenderingContext"_s, "bindTransformFeedback"_s, "WebGLTransformFeedback"_s); });
    if (idConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "bindTransformFeedback"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, idConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.bindTransformFeedback(targetConversionResult.releaseReturnValue(), idConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_bindTransformFeedback, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_bindTransformFeedbackBody>(*lexicalGlobalObject, *callFrame, "bindTransformFeedback");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_beginTransformFeedbackBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto primitiveModeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (primitiveModeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "beginTransformFeedback"_s, { InspectorCanvasCallTracer::processArgument(impl, primitiveModeConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.beginTransformFeedback(primitiveModeConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_beginTransformFeedback, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_beginTransformFeedbackBody>(*lexicalGlobalObject, *callFrame, "beginTransformFeedback");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_endTransformFeedbackBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "endTransformFeedback"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.endTransformFeedback(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_endTransformFeedback, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_endTransformFeedbackBody>(*lexicalGlobalObject, *callFrame, "endTransformFeedback");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_transformFeedbackVaryingsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGL2RenderingContext"_s, "transformFeedbackVaryings"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto varyingsConversionResult = convert<IDLSequence<IDLDOMString>>(*lexicalGlobalObject, argument1.value());
    if (varyingsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto bufferModeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (bufferModeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "transformFeedbackVaryings"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, varyingsConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, bufferModeConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.transformFeedbackVaryings(*programConversionResult.releaseReturnValue(), varyingsConversionResult.releaseReturnValue(), bufferModeConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_transformFeedbackVaryings, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_transformFeedbackVaryingsBody>(*lexicalGlobalObject, *callFrame, "transformFeedbackVaryings");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getTransformFeedbackVaryingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGL2RenderingContext"_s, "getTransformFeedbackVarying"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getTransformFeedbackVarying"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLInterface<WebGLActiveInfo>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getTransformFeedbackVarying(*programConversionResult.releaseReturnValue(), indexConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getTransformFeedbackVarying, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getTransformFeedbackVaryingBody>(*lexicalGlobalObject, *callFrame, "getTransformFeedbackVarying");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_pauseTransformFeedbackBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "pauseTransformFeedback"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.pauseTransformFeedback(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_pauseTransformFeedback, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_pauseTransformFeedbackBody>(*lexicalGlobalObject, *callFrame, "pauseTransformFeedback");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_resumeTransformFeedbackBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "resumeTransformFeedback"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.resumeTransformFeedback(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_resumeTransformFeedback, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_resumeTransformFeedbackBody>(*lexicalGlobalObject, *callFrame, "resumeTransformFeedback");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_bindBufferBaseBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto bufferConversionResult = convert<IDLNullable<IDLInterface<WebGLBuffer>>>(*lexicalGlobalObject, argument2.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 2, "buffer"_s, "WebGL2RenderingContext"_s, "bindBufferBase"_s, "WebGLBuffer"_s); });
    if (bufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "bindBufferBase"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, bufferConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.bindBufferBase(targetConversionResult.releaseReturnValue(), indexConversionResult.releaseReturnValue(), bufferConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_bindBufferBase, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_bindBufferBaseBody>(*lexicalGlobalObject, *callFrame, "bindBufferBase");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_bindBufferRangeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 5) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto bufferConversionResult = convert<IDLNullable<IDLInterface<WebGLBuffer>>>(*lexicalGlobalObject, argument2.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 2, "buffer"_s, "WebGL2RenderingContext"_s, "bindBufferRange"_s, "WebGLBuffer"_s); });
    if (bufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto offsetConversionResult = convert<IDLLongLong>(*lexicalGlobalObject, argument3.value());
    if (offsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto sizeConversionResult = convert<IDLLongLong>(*lexicalGlobalObject, argument4.value());
    if (sizeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "bindBufferRange"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, bufferConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, offsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, sizeConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.bindBufferRange(targetConversionResult.releaseReturnValue(), indexConversionResult.releaseReturnValue(), bufferConversionResult.releaseReturnValue(), offsetConversionResult.releaseReturnValue(), sizeConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_bindBufferRange, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_bindBufferRangeBody>(*lexicalGlobalObject, *callFrame, "bindBufferRange");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getIndexedParameterBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getIndexedParameter"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLWebGLAny>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getIndexedParameter(targetConversionResult.releaseReturnValue(), indexConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getIndexedParameter, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getIndexedParameterBody>(*lexicalGlobalObject, *callFrame, "getIndexedParameter");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getUniformIndicesBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGL2RenderingContext"_s, "getUniformIndices"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto uniformNamesConversionResult = convert<IDLSequence<IDLDOMString>>(*lexicalGlobalObject, argument1.value());
    if (uniformNamesConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getUniformIndices"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, uniformNamesConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLSequence<IDLUnsignedLong>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getUniformIndices(*programConversionResult.releaseReturnValue(), uniformNamesConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getUniformIndices, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getUniformIndicesBody>(*lexicalGlobalObject, *callFrame, "getUniformIndices");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getActiveUniformsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGL2RenderingContext"_s, "getActiveUniforms"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto uniformIndicesConversionResult = convert<IDLSequence<IDLUnsignedLong>>(*lexicalGlobalObject, argument1.value());
    if (uniformIndicesConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getActiveUniforms"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, uniformIndicesConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLWebGLAny>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getActiveUniforms(*programConversionResult.releaseReturnValue(), uniformIndicesConversionResult.releaseReturnValue(), pnameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getActiveUniforms, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getActiveUniformsBody>(*lexicalGlobalObject, *callFrame, "getActiveUniforms");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getUniformBlockIndexBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGL2RenderingContext"_s, "getUniformBlockIndex"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto uniformBlockNameConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (uniformBlockNameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getUniformBlockIndex"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, uniformBlockNameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.getUniformBlockIndex(*programConversionResult.releaseReturnValue(), uniformBlockNameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getUniformBlockIndex, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getUniformBlockIndexBody>(*lexicalGlobalObject, *callFrame, "getUniformBlockIndex");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getActiveUniformBlockParameterBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGL2RenderingContext"_s, "getActiveUniformBlockParameter"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto uniformBlockIndexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (uniformBlockIndexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getActiveUniformBlockParameter"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, uniformBlockIndexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLWebGLAny>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getActiveUniformBlockParameter(*programConversionResult.releaseReturnValue(), uniformBlockIndexConversionResult.releaseReturnValue(), pnameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getActiveUniformBlockParameter, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getActiveUniformBlockParameterBody>(*lexicalGlobalObject, *callFrame, "getActiveUniformBlockParameter");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getActiveUniformBlockNameBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGL2RenderingContext"_s, "getActiveUniformBlockName"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto uniformBlockIndexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (uniformBlockIndexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getActiveUniformBlockName"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, uniformBlockIndexConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLWebGLAny>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getActiveUniformBlockName(*programConversionResult.releaseReturnValue(), uniformBlockIndexConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getActiveUniformBlockName, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getActiveUniformBlockNameBody>(*lexicalGlobalObject, *callFrame, "getActiveUniformBlockName");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniformBlockBindingBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGL2RenderingContext"_s, "uniformBlockBinding"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto uniformBlockIndexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (uniformBlockIndexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto uniformBlockBindingConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (uniformBlockBindingConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniformBlockBinding"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, uniformBlockIndexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, uniformBlockBindingConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniformBlockBinding(*programConversionResult.releaseReturnValue(), uniformBlockIndexConversionResult.releaseReturnValue(), uniformBlockBindingConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniformBlockBinding, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniformBlockBindingBody>(*lexicalGlobalObject, *callFrame, "uniformBlockBinding");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_createVertexArrayBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "createVertexArray"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLInterface<WebGLVertexArrayObject>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.createVertexArray())));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_createVertexArray, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_createVertexArrayBody>(*lexicalGlobalObject, *callFrame, "createVertexArray");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_deleteVertexArrayBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto vertexArrayConversionResult = convert<IDLNullable<IDLInterface<WebGLVertexArrayObject>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "vertexArray"_s, "WebGL2RenderingContext"_s, "deleteVertexArray"_s, "WebGLVertexArrayObject"_s); });
    if (vertexArrayConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "deleteVertexArray"_s, { InspectorCanvasCallTracer::processArgument(impl, vertexArrayConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.deleteVertexArray(vertexArrayConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_deleteVertexArray, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_deleteVertexArrayBody>(*lexicalGlobalObject, *callFrame, "deleteVertexArray");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_isVertexArrayBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto vertexArrayConversionResult = convert<IDLNullable<IDLInterface<WebGLVertexArrayObject>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "vertexArray"_s, "WebGL2RenderingContext"_s, "isVertexArray"_s, "WebGLVertexArrayObject"_s); });
    if (vertexArrayConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "isVertexArray"_s, { InspectorCanvasCallTracer::processArgument(impl, vertexArrayConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isVertexArray(vertexArrayConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_isVertexArray, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_isVertexArrayBody>(*lexicalGlobalObject, *callFrame, "isVertexArray");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_bindVertexArrayBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto vertexArrayConversionResult = convert<IDLNullable<IDLInterface<WebGLVertexArrayObject>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "vertexArray"_s, "WebGL2RenderingContext"_s, "bindVertexArray"_s, "WebGLVertexArrayObject"_s); });
    if (vertexArrayConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "bindVertexArray"_s, { InspectorCanvasCallTracer::processArgument(impl, vertexArrayConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.bindVertexArray(vertexArrayConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_bindVertexArray, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_bindVertexArrayBody>(*lexicalGlobalObject, *callFrame, "bindVertexArray");
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_texImage2D1Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto internalformatConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (internalformatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto borderConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (borderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument6.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument7.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument8 = callFrame->uncheckedArgument(8);
    auto pboOffsetConversionResult = convert<IDLLongLong>(*lexicalGlobalObject, argument8.value());
    if (pboOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "texImage2D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, internalformatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, borderConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pboOffsetConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.texImage2D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), internalformatConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), borderConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), pboOffsetConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_texImage2D2Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto internalformatConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (internalformatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto borderConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (borderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument6.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument7.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument8 = callFrame->uncheckedArgument(8);
    auto sourceConversionResult = convert<IDLUnion<IDLInterface<ImageBitmap>, IDLInterface<ImageData>, IDLInterface<HTMLImageElement>, IDLInterface<HTMLCanvasElement>, IDLInterface<HTMLVideoElement>>>(*lexicalGlobalObject, argument8.value());
    if (sourceConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "texImage2D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, internalformatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, borderConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, sourceConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.texImage2D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), internalformatConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), borderConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), sourceConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_texImage2D3Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto internalformatConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (internalformatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto borderConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (borderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument6.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument7.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument8 = callFrame->uncheckedArgument(8);
    auto srcDataConversionResult = convert<IDLAllowSharedAdaptor<IDLArrayBufferView>>(*lexicalGlobalObject, argument8.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 8, "srcData"_s, "WebGL2RenderingContext"_s, "texImage2D"_s, "ArrayBufferView"_s); });
    if (srcDataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument9 = callFrame->uncheckedArgument(9);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument9.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "texImage2D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, internalformatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, borderConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcDataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.texImage2D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), internalformatConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), borderConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), srcDataConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_texSubImage2D1Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto xoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (xoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto yoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (yoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument6.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument7.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument8 = callFrame->uncheckedArgument(8);
    auto pboOffsetConversionResult = convert<IDLLongLong>(*lexicalGlobalObject, argument8.value());
    if (pboOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "texSubImage2D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pboOffsetConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.texSubImage2D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), xoffsetConversionResult.releaseReturnValue(), yoffsetConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), pboOffsetConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_texSubImage2D2Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto xoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (xoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto yoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (yoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument6.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument7.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument8 = callFrame->uncheckedArgument(8);
    auto sourceConversionResult = convert<IDLUnion<IDLInterface<ImageBitmap>, IDLInterface<ImageData>, IDLInterface<HTMLImageElement>, IDLInterface<HTMLCanvasElement>, IDLInterface<HTMLVideoElement>>>(*lexicalGlobalObject, argument8.value());
    if (sourceConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "texSubImage2D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, sourceConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.texSubImage2D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), xoffsetConversionResult.releaseReturnValue(), yoffsetConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), sourceConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_texSubImage2D3Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto xoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (xoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto yoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (yoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument6.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument7.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument8 = callFrame->uncheckedArgument(8);
    auto srcDataConversionResult = convert<IDLAllowSharedAdaptor<IDLArrayBufferView>>(*lexicalGlobalObject, argument8.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 8, "srcData"_s, "WebGL2RenderingContext"_s, "texSubImage2D"_s, "ArrayBufferView"_s); });
    if (srcDataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument9 = callFrame->uncheckedArgument(9);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument9.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "texSubImage2D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcDataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.texSubImage2D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), xoffsetConversionResult.releaseReturnValue(), yoffsetConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), srcDataConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_compressedTexImage2D1Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto internalformatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (internalformatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto borderConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (borderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto imageSizeConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument6.value());
    if (imageSizeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto offsetConversionResult = convert<IDLLongLong>(*lexicalGlobalObject, argument7.value());
    if (offsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "compressedTexImage2D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, internalformatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, borderConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, imageSizeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, offsetConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.compressedTexImage2D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), internalformatConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), borderConversionResult.releaseReturnValue(), imageSizeConversionResult.releaseReturnValue(), offsetConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_compressedTexImage2D2Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto internalformatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (internalformatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto borderConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (borderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto srcDataConversionResult = convert<IDLAllowSharedAdaptor<IDLArrayBufferView>>(*lexicalGlobalObject, argument6.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 6, "srcData"_s, "WebGL2RenderingContext"_s, "compressedTexImage2D"_s, "ArrayBufferView"_s); });
    if (srcDataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument7.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument8 = callFrame->argument(8);
    auto srcLengthOverrideConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument8.value());
    if (srcLengthOverrideConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "compressedTexImage2D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, internalformatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, borderConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcDataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcLengthOverrideConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.compressedTexImage2D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), internalformatConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), borderConversionResult.releaseReturnValue(), srcDataConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue(), srcLengthOverrideConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_compressedTexSubImage2D1Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto xoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (xoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto yoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (yoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument6.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto imageSizeConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument7.value());
    if (imageSizeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument8 = callFrame->uncheckedArgument(8);
    auto offsetConversionResult = convert<IDLLongLong>(*lexicalGlobalObject, argument8.value());
    if (offsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "compressedTexSubImage2D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, imageSizeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, offsetConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.compressedTexSubImage2D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), xoffsetConversionResult.releaseReturnValue(), yoffsetConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), imageSizeConversionResult.releaseReturnValue(), offsetConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_compressedTexSubImage2D2Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto xoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (xoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto yoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (yoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument6.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto srcDataConversionResult = convert<IDLAllowSharedAdaptor<IDLArrayBufferView>>(*lexicalGlobalObject, argument7.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 7, "srcData"_s, "WebGL2RenderingContext"_s, "compressedTexSubImage2D"_s, "ArrayBufferView"_s); });
    if (srcDataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument8 = callFrame->uncheckedArgument(8);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument8.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument9 = callFrame->argument(9);
    auto srcLengthOverrideConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument9.value());
    if (srcLengthOverrideConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "compressedTexSubImage2D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcDataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcLengthOverrideConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.compressedTexSubImage2D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), xoffsetConversionResult.releaseReturnValue(), yoffsetConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), srcDataConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue(), srcLengthOverrideConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform1fv1Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform1fv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto dataConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument1.value());
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->argument(3);
    auto srcLengthConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (srcLengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform1fv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcLengthConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform1fv(locationConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue(), srcLengthConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform2fv1Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform2fv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto dataConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument1.value());
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->argument(3);
    auto srcLengthConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (srcLengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform2fv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcLengthConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform2fv(locationConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue(), srcLengthConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform3fv1Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform3fv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto dataConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument1.value());
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->argument(3);
    auto srcLengthConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (srcLengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform3fv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcLengthConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform3fv(locationConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue(), srcLengthConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform4fv1Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform4fv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto dataConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument1.value());
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->argument(3);
    auto srcLengthConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (srcLengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform4fv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcLengthConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform4fv(locationConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue(), srcLengthConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform1iv1Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform1iv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto dataConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLInt32Array>, IDLSequence<IDLLong>>>(*lexicalGlobalObject, argument1.value());
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->argument(3);
    auto srcLengthConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (srcLengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform1iv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcLengthConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform1iv(locationConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue(), srcLengthConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform2iv1Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform2iv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto dataConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLInt32Array>, IDLSequence<IDLLong>>>(*lexicalGlobalObject, argument1.value());
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->argument(3);
    auto srcLengthConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (srcLengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform2iv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcLengthConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform2iv(locationConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue(), srcLengthConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform3iv1Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform3iv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto dataConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLInt32Array>, IDLSequence<IDLLong>>>(*lexicalGlobalObject, argument1.value());
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->argument(3);
    auto srcLengthConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (srcLengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform3iv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcLengthConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform3iv(locationConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue(), srcLengthConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform4iv1Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform4iv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto dataConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLInt32Array>, IDLSequence<IDLLong>>>(*lexicalGlobalObject, argument1.value());
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->argument(3);
    auto srcLengthConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (srcLengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform4iv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcLengthConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform4iv(locationConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue(), srcLengthConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniformMatrix2fv1Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniformMatrix2fv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto transposeConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (transposeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto dataConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument2.value());
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->argument(4);
    auto srcLengthConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument4.value());
    if (srcLengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniformMatrix2fv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, transposeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcLengthConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniformMatrix2fv(locationConversionResult.releaseReturnValue(), transposeConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue(), srcLengthConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniformMatrix3fv1Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniformMatrix3fv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto transposeConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (transposeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto dataConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument2.value());
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->argument(4);
    auto srcLengthConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument4.value());
    if (srcLengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniformMatrix3fv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, transposeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcLengthConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniformMatrix3fv(locationConversionResult.releaseReturnValue(), transposeConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue(), srcLengthConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniformMatrix4fv1Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniformMatrix4fv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto transposeConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (transposeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto dataConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument2.value());
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto srcOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (srcOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->argument(4);
    auto srcLengthConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument4.value());
    if (srcLengthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniformMatrix4fv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, transposeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcOffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcLengthConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniformMatrix4fv(locationConversionResult.releaseReturnValue(), transposeConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue(), srcOffsetConversionResult.releaseReturnValue(), srcLengthConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_readPixels1Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto xConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument0.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto yConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument4.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument5.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto offsetConversionResult = convert<IDLLongLong>(*lexicalGlobalObject, argument6.value());
    if (offsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "readPixels"_s, { InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, offsetConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.readPixels(xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), offsetConversionResult.releaseReturnValue()); })));
}

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_readPixels2Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto xConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument0.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto yConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument4.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument5.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto dstDataConversionResult = convert<IDLAllowSharedAdaptor<IDLArrayBufferView>>(*lexicalGlobalObject, argument6.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 6, "dstData"_s, "WebGL2RenderingContext"_s, "readPixels"_s, "ArrayBufferView"_s); });
    if (dstDataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto dstOffsetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument7.value());
    if (dstOffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "readPixels"_s, { InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dstDataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dstOffsetConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.readPixels(xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), dstDataConversionResult.releaseReturnValue(), dstOffsetConversionResult.releaseReturnValue()); })));
}

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_activeTextureBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto textureConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (textureConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "activeTexture"_s, { InspectorCanvasCallTracer::processArgument(impl, textureConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.activeTexture(textureConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_activeTexture, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_activeTextureBody>(*lexicalGlobalObject, *callFrame, "activeTexture");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_attachShaderBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGL2RenderingContext"_s, "attachShader"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto shaderConversionResult = convert<IDLInterface<WebGLShader>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "shader"_s, "WebGL2RenderingContext"_s, "attachShader"_s, "WebGLShader"_s); });
    if (shaderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "attachShader"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, shaderConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.attachShader(*programConversionResult.releaseReturnValue(), *shaderConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_attachShader, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_attachShaderBody>(*lexicalGlobalObject, *callFrame, "attachShader");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_bindAttribLocationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGL2RenderingContext"_s, "bindAttribLocation"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto nameConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument2.value());
    if (nameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "bindAttribLocation"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, nameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.bindAttribLocation(*programConversionResult.releaseReturnValue(), indexConversionResult.releaseReturnValue(), nameConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_bindAttribLocation, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_bindAttribLocationBody>(*lexicalGlobalObject, *callFrame, "bindAttribLocation");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_bindBufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto bufferConversionResult = convert<IDLNullable<IDLInterface<WebGLBuffer>>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "buffer"_s, "WebGL2RenderingContext"_s, "bindBuffer"_s, "WebGLBuffer"_s); });
    if (bufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "bindBuffer"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, bufferConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.bindBuffer(targetConversionResult.releaseReturnValue(), bufferConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_bindBuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_bindBufferBody>(*lexicalGlobalObject, *callFrame, "bindBuffer");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_bindFramebufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto framebufferConversionResult = convert<IDLNullable<IDLInterface<WebGLFramebuffer>>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "framebuffer"_s, "WebGL2RenderingContext"_s, "bindFramebuffer"_s, "WebGLFramebuffer"_s); });
    if (framebufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "bindFramebuffer"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, framebufferConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.bindFramebuffer(targetConversionResult.releaseReturnValue(), framebufferConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_bindFramebuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_bindFramebufferBody>(*lexicalGlobalObject, *callFrame, "bindFramebuffer");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_bindRenderbufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto renderbufferConversionResult = convert<IDLNullable<IDLInterface<WebGLRenderbuffer>>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "renderbuffer"_s, "WebGL2RenderingContext"_s, "bindRenderbuffer"_s, "WebGLRenderbuffer"_s); });
    if (renderbufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "bindRenderbuffer"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, renderbufferConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.bindRenderbuffer(targetConversionResult.releaseReturnValue(), renderbufferConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_bindRenderbuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_bindRenderbufferBody>(*lexicalGlobalObject, *callFrame, "bindRenderbuffer");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_bindTextureBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto textureConversionResult = convert<IDLNullable<IDLInterface<WebGLTexture>>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "texture"_s, "WebGL2RenderingContext"_s, "bindTexture"_s, "WebGLTexture"_s); });
    if (textureConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "bindTexture"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, textureConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.bindTexture(targetConversionResult.releaseReturnValue(), textureConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_bindTexture, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_bindTextureBody>(*lexicalGlobalObject, *callFrame, "bindTexture");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_blendColorBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto redConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument0.value());
    if (redConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto greenConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument1.value());
    if (greenConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto blueConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument2.value());
    if (blueConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto alphaConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument3.value());
    if (alphaConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "blendColor"_s, { InspectorCanvasCallTracer::processArgument(impl, redConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, greenConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, blueConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, alphaConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.blendColor(redConversionResult.releaseReturnValue(), greenConversionResult.releaseReturnValue(), blueConversionResult.releaseReturnValue(), alphaConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_blendColor, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_blendColorBody>(*lexicalGlobalObject, *callFrame, "blendColor");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_blendEquationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto modeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (modeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "blendEquation"_s, { InspectorCanvasCallTracer::processArgument(impl, modeConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.blendEquation(modeConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_blendEquation, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_blendEquationBody>(*lexicalGlobalObject, *callFrame, "blendEquation");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_blendEquationSeparateBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto modeRGBConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (modeRGBConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto modeAlphaConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (modeAlphaConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "blendEquationSeparate"_s, { InspectorCanvasCallTracer::processArgument(impl, modeRGBConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, modeAlphaConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.blendEquationSeparate(modeRGBConversionResult.releaseReturnValue(), modeAlphaConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_blendEquationSeparate, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_blendEquationSeparateBody>(*lexicalGlobalObject, *callFrame, "blendEquationSeparate");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_blendFuncBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto sfactorConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (sfactorConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto dfactorConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (dfactorConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "blendFunc"_s, { InspectorCanvasCallTracer::processArgument(impl, sfactorConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dfactorConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.blendFunc(sfactorConversionResult.releaseReturnValue(), dfactorConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_blendFunc, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_blendFuncBody>(*lexicalGlobalObject, *callFrame, "blendFunc");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_blendFuncSeparateBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto srcRGBConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (srcRGBConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto dstRGBConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (dstRGBConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto srcAlphaConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (srcAlphaConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto dstAlphaConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (dstAlphaConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "blendFuncSeparate"_s, { InspectorCanvasCallTracer::processArgument(impl, srcRGBConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dstRGBConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, srcAlphaConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dstAlphaConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.blendFuncSeparate(srcRGBConversionResult.releaseReturnValue(), dstRGBConversionResult.releaseReturnValue(), srcAlphaConversionResult.releaseReturnValue(), dstAlphaConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_blendFuncSeparate, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_blendFuncSeparateBody>(*lexicalGlobalObject, *callFrame, "blendFuncSeparate");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_bufferData2Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto dataConversionResult = convert<IDLNullable<IDLUnion<IDLAllowSharedAdaptor<IDLArrayBuffer>, IDLAllowSharedAdaptor<IDLArrayBufferView>>>>(*lexicalGlobalObject, argument1.value());
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto usageConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (usageConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "bufferData"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dataConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, usageConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.bufferData(targetConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue(), usageConversionResult.releaseReturnValue()); })));
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_bufferData3Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto sizeConversionResult = convert<IDLLongLong>(*lexicalGlobalObject, argument1.value());
    if (sizeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto usageConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (usageConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "bufferData"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, sizeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, usageConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.bufferData(targetConversionResult.releaseReturnValue(), sizeConversionResult.releaseReturnValue(), usageConversionResult.releaseReturnValue()); })));
}

#endif

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_bufferDataOverloadDispatcher(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    size_t argsCount = std::min<size_t>(5, callFrame->argumentCount());
    if (argsCount == 3) {
        JSValue distinguishingArg = callFrame->uncheckedArgument(1);
#if ENABLE(WEBGL)
        if (distinguishingArg.isUndefinedOrNull())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_bufferData2Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
#if ENABLE(WEBGL)
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSArrayBuffer>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_bufferData2Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
#if ENABLE(WEBGL)
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSArrayBufferView>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_bufferData2Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
#if ENABLE(WEBGL)
        if (distinguishingArg.isNumber())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_bufferData3Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
#if ENABLE(WEBGL)
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_bufferData3Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
    }
    if (argsCount == 4) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_bufferData1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    if (argsCount == 5) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_bufferData1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    return argsCount < 3 ? throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject)) : throwVMTypeError(lexicalGlobalObject, throwScope);
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_bufferData, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_bufferDataOverloadDispatcher>(*lexicalGlobalObject, *callFrame, "bufferData");
}

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_bufferSubData2Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto offsetConversionResult = convert<IDLLongLong>(*lexicalGlobalObject, argument1.value());
    if (offsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto dataConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLArrayBuffer>, IDLAllowSharedAdaptor<IDLArrayBufferView>>>(*lexicalGlobalObject, argument2.value());
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "bufferSubData"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, offsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dataConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.bufferSubData(targetConversionResult.releaseReturnValue(), offsetConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue()); })));
}

#endif

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_bufferSubDataOverloadDispatcher(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    size_t argsCount = std::min<size_t>(5, callFrame->argumentCount());
    if (argsCount == 3) {
#if ENABLE(WEBGL)
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_bufferSubData2Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
    }
    if (argsCount == 4) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_bufferSubData1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    if (argsCount == 5) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_bufferSubData1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    return argsCount < 3 ? throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject)) : throwVMTypeError(lexicalGlobalObject, throwScope);
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_bufferSubData, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_bufferSubDataOverloadDispatcher>(*lexicalGlobalObject, *callFrame, "bufferSubData");
}

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_checkFramebufferStatusBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "checkFramebufferStatus"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.checkFramebufferStatus(targetConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_checkFramebufferStatus, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_checkFramebufferStatusBody>(*lexicalGlobalObject, *callFrame, "checkFramebufferStatus");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_clearBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto maskConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (maskConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "clear"_s, { InspectorCanvasCallTracer::processArgument(impl, maskConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.clear(maskConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_clear, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_clearBody>(*lexicalGlobalObject, *callFrame, "clear");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_clearColorBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto redConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument0.value());
    if (redConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto greenConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument1.value());
    if (greenConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto blueConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument2.value());
    if (blueConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto alphaConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument3.value());
    if (alphaConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "clearColor"_s, { InspectorCanvasCallTracer::processArgument(impl, redConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, greenConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, blueConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, alphaConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.clearColor(redConversionResult.releaseReturnValue(), greenConversionResult.releaseReturnValue(), blueConversionResult.releaseReturnValue(), alphaConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_clearColor, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_clearColorBody>(*lexicalGlobalObject, *callFrame, "clearColor");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_clearDepthBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto depthConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument0.value());
    if (depthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "clearDepth"_s, { InspectorCanvasCallTracer::processArgument(impl, depthConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.clearDepth(depthConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_clearDepth, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_clearDepthBody>(*lexicalGlobalObject, *callFrame, "clearDepth");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_clearStencilBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto sConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument0.value());
    if (sConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "clearStencil"_s, { InspectorCanvasCallTracer::processArgument(impl, sConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.clearStencil(sConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_clearStencil, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_clearStencilBody>(*lexicalGlobalObject, *callFrame, "clearStencil");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_colorMaskBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto redConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (redConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto greenConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (greenConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto blueConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument2.value());
    if (blueConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto alphaConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument3.value());
    if (alphaConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "colorMask"_s, { InspectorCanvasCallTracer::processArgument(impl, redConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, greenConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, blueConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, alphaConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.colorMask(redConversionResult.releaseReturnValue(), greenConversionResult.releaseReturnValue(), blueConversionResult.releaseReturnValue(), alphaConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_colorMask, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_colorMaskBody>(*lexicalGlobalObject, *callFrame, "colorMask");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_compileShaderBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto shaderConversionResult = convert<IDLInterface<WebGLShader>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "shader"_s, "WebGL2RenderingContext"_s, "compileShader"_s, "WebGLShader"_s); });
    if (shaderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "compileShader"_s, { InspectorCanvasCallTracer::processArgument(impl, shaderConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.compileShader(*shaderConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_compileShader, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_compileShaderBody>(*lexicalGlobalObject, *callFrame, "compileShader");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_texImage2D4Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto internalformatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (internalformatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto borderConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (borderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument6.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument7.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument8 = callFrame->uncheckedArgument(8);
    auto pixelsConversionResult = convert<IDLNullable<IDLAllowSharedAdaptor<IDLArrayBufferView>>>(*lexicalGlobalObject, argument8.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 8, "pixels"_s, "WebGL2RenderingContext"_s, "texImage2D"_s, "ArrayBufferView"_s); });
    if (pixelsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "texImage2D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, internalformatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, borderConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pixelsConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.texImage2D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), internalformatConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), borderConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), pixelsConversionResult.releaseReturnValue()); })));
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_texImage2D5Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto internalformatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (internalformatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument4.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto sourceConversionResult = convert<IDLUnion<IDLInterface<ImageBitmap>, IDLInterface<ImageData>, IDLInterface<HTMLImageElement>, IDLInterface<HTMLCanvasElement>, IDLInterface<HTMLVideoElement>>>(*lexicalGlobalObject, argument5.value());
    if (sourceConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "texImage2D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, internalformatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, sourceConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.texImage2D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), internalformatConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), sourceConversionResult.releaseReturnValue()); })));
}

#endif

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_texImage2DOverloadDispatcher(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    size_t argsCount = std::min<size_t>(10, callFrame->argumentCount());
    if (argsCount == 10) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texImage2D3Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    if (argsCount == 6) {
#if ENABLE(WEBGL)
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texImage2D5Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
    }
    if (argsCount == 9) {
        JSValue distinguishingArg = callFrame->uncheckedArgument(8);
#if ENABLE(WEBGL)
        if (distinguishingArg.isUndefinedOrNull())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texImage2D4Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSImageBitmap>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texImage2D2Body(lexicalGlobalObject, callFrame, castedThis)));
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSImageData>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texImage2D2Body(lexicalGlobalObject, callFrame, castedThis)));
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSHTMLImageElement>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texImage2D2Body(lexicalGlobalObject, callFrame, castedThis)));
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSHTMLCanvasElement>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texImage2D2Body(lexicalGlobalObject, callFrame, castedThis)));
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSHTMLVideoElement>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texImage2D2Body(lexicalGlobalObject, callFrame, castedThis)));
#if ENABLE(WEBGL)
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSArrayBufferView>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texImage2D4Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
        if (distinguishingArg.isNumber())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texImage2D1Body(lexicalGlobalObject, callFrame, castedThis)));
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texImage2D1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    return argsCount < 6 ? throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject)) : throwVMTypeError(lexicalGlobalObject, throwScope);
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_texImage2D, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_texImage2DOverloadDispatcher>(*lexicalGlobalObject, *callFrame, "texImage2D");
}

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_texSubImage2D4Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto xoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (xoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto yoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (yoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument6.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument7.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument8 = callFrame->uncheckedArgument(8);
    auto pixelsConversionResult = convert<IDLNullable<IDLAllowSharedAdaptor<IDLArrayBufferView>>>(*lexicalGlobalObject, argument8.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 8, "pixels"_s, "WebGL2RenderingContext"_s, "texSubImage2D"_s, "ArrayBufferView"_s); });
    if (pixelsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "texSubImage2D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pixelsConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.texSubImage2D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), xoffsetConversionResult.releaseReturnValue(), yoffsetConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), pixelsConversionResult.releaseReturnValue()); })));
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_texSubImage2D5Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto xoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (xoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto yoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (yoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument4.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument5.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto sourceConversionResult = convert<IDLUnion<IDLInterface<ImageBitmap>, IDLInterface<ImageData>, IDLInterface<HTMLImageElement>, IDLInterface<HTMLCanvasElement>, IDLInterface<HTMLVideoElement>>>(*lexicalGlobalObject, argument6.value());
    if (sourceConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "texSubImage2D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, sourceConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.texSubImage2D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), xoffsetConversionResult.releaseReturnValue(), yoffsetConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), sourceConversionResult.releaseReturnValue()); })));
}

#endif

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_texSubImage2DOverloadDispatcher(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    size_t argsCount = std::min<size_t>(10, callFrame->argumentCount());
    if (argsCount == 10) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texSubImage2D3Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    if (argsCount == 7) {
#if ENABLE(WEBGL)
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texSubImage2D5Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
    }
    if (argsCount == 9) {
        JSValue distinguishingArg = callFrame->uncheckedArgument(8);
#if ENABLE(WEBGL)
        if (distinguishingArg.isUndefinedOrNull())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texSubImage2D4Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSImageBitmap>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texSubImage2D2Body(lexicalGlobalObject, callFrame, castedThis)));
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSImageData>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texSubImage2D2Body(lexicalGlobalObject, callFrame, castedThis)));
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSHTMLImageElement>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texSubImage2D2Body(lexicalGlobalObject, callFrame, castedThis)));
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSHTMLCanvasElement>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texSubImage2D2Body(lexicalGlobalObject, callFrame, castedThis)));
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSHTMLVideoElement>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texSubImage2D2Body(lexicalGlobalObject, callFrame, castedThis)));
#if ENABLE(WEBGL)
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSArrayBufferView>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texSubImage2D4Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
        if (distinguishingArg.isNumber())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texSubImage2D1Body(lexicalGlobalObject, callFrame, castedThis)));
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_texSubImage2D1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    return argsCount < 7 ? throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject)) : throwVMTypeError(lexicalGlobalObject, throwScope);
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_texSubImage2D, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_texSubImage2DOverloadDispatcher>(*lexicalGlobalObject, *callFrame, "texSubImage2D");
}

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_compressedTexImage2D3Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto internalformatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (internalformatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto borderConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (borderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto dataConversionResult = convert<IDLAllowSharedAdaptor<IDLArrayBufferView>>(*lexicalGlobalObject, argument6.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 6, "data"_s, "WebGL2RenderingContext"_s, "compressedTexImage2D"_s, "ArrayBufferView"_s); });
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "compressedTexImage2D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, internalformatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, borderConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dataConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.compressedTexImage2D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), internalformatConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), borderConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue()); })));
}

#endif

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_compressedTexImage2DOverloadDispatcher(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    size_t argsCount = std::min<size_t>(9, callFrame->argumentCount());
    if (argsCount == 7) {
#if ENABLE(WEBGL)
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_compressedTexImage2D3Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
    }
    if (argsCount == 8) {
        JSValue distinguishingArg = callFrame->uncheckedArgument(6);
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSArrayBufferView>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_compressedTexImage2D2Body(lexicalGlobalObject, callFrame, castedThis)));
        if (distinguishingArg.isNumber())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_compressedTexImage2D1Body(lexicalGlobalObject, callFrame, castedThis)));
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_compressedTexImage2D1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    if (argsCount == 9) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_compressedTexImage2D2Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    return argsCount < 7 ? throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject)) : throwVMTypeError(lexicalGlobalObject, throwScope);
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_compressedTexImage2D, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_compressedTexImage2DOverloadDispatcher>(*lexicalGlobalObject, *callFrame, "compressedTexImage2D");
}

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_compressedTexSubImage2D3Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto xoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (xoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto yoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (yoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument6.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto dataConversionResult = convert<IDLAllowSharedAdaptor<IDLArrayBufferView>>(*lexicalGlobalObject, argument7.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 7, "data"_s, "WebGL2RenderingContext"_s, "compressedTexSubImage2D"_s, "ArrayBufferView"_s); });
    if (dataConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "compressedTexSubImage2D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, dataConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.compressedTexSubImage2D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), xoffsetConversionResult.releaseReturnValue(), yoffsetConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), dataConversionResult.releaseReturnValue()); })));
}

#endif

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_compressedTexSubImage2DOverloadDispatcher(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    size_t argsCount = std::min<size_t>(10, callFrame->argumentCount());
    if (argsCount == 10) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_compressedTexSubImage2D2Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    if (argsCount == 8) {
#if ENABLE(WEBGL)
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_compressedTexSubImage2D3Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
    }
    if (argsCount == 9) {
        JSValue distinguishingArg = callFrame->uncheckedArgument(7);
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSArrayBufferView>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_compressedTexSubImage2D2Body(lexicalGlobalObject, callFrame, castedThis)));
        if (distinguishingArg.isNumber())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_compressedTexSubImage2D1Body(lexicalGlobalObject, callFrame, castedThis)));
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_compressedTexSubImage2D1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    return argsCount < 8 ? throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject)) : throwVMTypeError(lexicalGlobalObject, throwScope);
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_compressedTexSubImage2D, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_compressedTexSubImage2DOverloadDispatcher>(*lexicalGlobalObject, *callFrame, "compressedTexSubImage2D");
}

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_copyTexImage2DBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 8) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto internalformatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (internalformatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto xConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto yConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument6.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto borderConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument7.value());
    if (borderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "copyTexImage2D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, internalformatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, borderConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.copyTexImage2D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), internalformatConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), borderConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_copyTexImage2D, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_copyTexImage2DBody>(*lexicalGlobalObject, *callFrame, "copyTexImage2D");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_copyTexSubImage2DBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 8) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto xoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (xoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto yoffsetConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (yoffsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto xConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto yConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument5.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument6.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument7 = callFrame->uncheckedArgument(7);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument7.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "copyTexSubImage2D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yoffsetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.copyTexSubImage2D(targetConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue(), xoffsetConversionResult.releaseReturnValue(), yoffsetConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_copyTexSubImage2D, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_copyTexSubImage2DBody>(*lexicalGlobalObject, *callFrame, "copyTexSubImage2D");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_createBufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "createBuffer"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<WebGLBuffer>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.createBuffer())));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_createBuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_createBufferBody>(*lexicalGlobalObject, *callFrame, "createBuffer");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_createFramebufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "createFramebuffer"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<WebGLFramebuffer>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.createFramebuffer())));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_createFramebuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_createFramebufferBody>(*lexicalGlobalObject, *callFrame, "createFramebuffer");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_createProgramBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "createProgram"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.createProgram())));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_createProgram, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_createProgramBody>(*lexicalGlobalObject, *callFrame, "createProgram");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_createRenderbufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "createRenderbuffer"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<WebGLRenderbuffer>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.createRenderbuffer())));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_createRenderbuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_createRenderbufferBody>(*lexicalGlobalObject, *callFrame, "createRenderbuffer");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_createShaderBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "createShader"_s, { InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<WebGLShader>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.createShader(typeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_createShader, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_createShaderBody>(*lexicalGlobalObject, *callFrame, "createShader");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_createTextureBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "createTexture"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<WebGLTexture>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.createTexture())));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_createTexture, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_createTextureBody>(*lexicalGlobalObject, *callFrame, "createTexture");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_cullFaceBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto modeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (modeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "cullFace"_s, { InspectorCanvasCallTracer::processArgument(impl, modeConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.cullFace(modeConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_cullFace, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_cullFaceBody>(*lexicalGlobalObject, *callFrame, "cullFace");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_deleteBufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto bufferConversionResult = convert<IDLNullable<IDLInterface<WebGLBuffer>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "buffer"_s, "WebGL2RenderingContext"_s, "deleteBuffer"_s, "WebGLBuffer"_s); });
    if (bufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "deleteBuffer"_s, { InspectorCanvasCallTracer::processArgument(impl, bufferConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.deleteBuffer(bufferConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_deleteBuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_deleteBufferBody>(*lexicalGlobalObject, *callFrame, "deleteBuffer");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_deleteFramebufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto framebufferConversionResult = convert<IDLNullable<IDLInterface<WebGLFramebuffer>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "framebuffer"_s, "WebGL2RenderingContext"_s, "deleteFramebuffer"_s, "WebGLFramebuffer"_s); });
    if (framebufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "deleteFramebuffer"_s, { InspectorCanvasCallTracer::processArgument(impl, framebufferConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.deleteFramebuffer(framebufferConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_deleteFramebuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_deleteFramebufferBody>(*lexicalGlobalObject, *callFrame, "deleteFramebuffer");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_deleteProgramBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGL2RenderingContext"_s, "deleteProgram"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "deleteProgram"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.deleteProgram(programConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_deleteProgram, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_deleteProgramBody>(*lexicalGlobalObject, *callFrame, "deleteProgram");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_deleteRenderbufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto renderbufferConversionResult = convert<IDLNullable<IDLInterface<WebGLRenderbuffer>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "renderbuffer"_s, "WebGL2RenderingContext"_s, "deleteRenderbuffer"_s, "WebGLRenderbuffer"_s); });
    if (renderbufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "deleteRenderbuffer"_s, { InspectorCanvasCallTracer::processArgument(impl, renderbufferConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.deleteRenderbuffer(renderbufferConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_deleteRenderbuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_deleteRenderbufferBody>(*lexicalGlobalObject, *callFrame, "deleteRenderbuffer");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_deleteShaderBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto shaderConversionResult = convert<IDLNullable<IDLInterface<WebGLShader>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "shader"_s, "WebGL2RenderingContext"_s, "deleteShader"_s, "WebGLShader"_s); });
    if (shaderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "deleteShader"_s, { InspectorCanvasCallTracer::processArgument(impl, shaderConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.deleteShader(shaderConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_deleteShader, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_deleteShaderBody>(*lexicalGlobalObject, *callFrame, "deleteShader");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_deleteTextureBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto textureConversionResult = convert<IDLNullable<IDLInterface<WebGLTexture>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "texture"_s, "WebGL2RenderingContext"_s, "deleteTexture"_s, "WebGLTexture"_s); });
    if (textureConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "deleteTexture"_s, { InspectorCanvasCallTracer::processArgument(impl, textureConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.deleteTexture(textureConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_deleteTexture, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_deleteTextureBody>(*lexicalGlobalObject, *callFrame, "deleteTexture");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_depthFuncBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto funcConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (funcConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "depthFunc"_s, { InspectorCanvasCallTracer::processArgument(impl, funcConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.depthFunc(funcConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_depthFunc, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_depthFuncBody>(*lexicalGlobalObject, *callFrame, "depthFunc");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_depthMaskBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto flagConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument0.value());
    if (flagConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "depthMask"_s, { InspectorCanvasCallTracer::processArgument(impl, flagConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.depthMask(flagConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_depthMask, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_depthMaskBody>(*lexicalGlobalObject, *callFrame, "depthMask");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_depthRangeBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto zNearConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument0.value());
    if (zNearConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto zFarConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument1.value());
    if (zFarConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "depthRange"_s, { InspectorCanvasCallTracer::processArgument(impl, zNearConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, zFarConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.depthRange(zNearConversionResult.releaseReturnValue(), zFarConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_depthRange, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_depthRangeBody>(*lexicalGlobalObject, *callFrame, "depthRange");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_detachShaderBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGL2RenderingContext"_s, "detachShader"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto shaderConversionResult = convert<IDLInterface<WebGLShader>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "shader"_s, "WebGL2RenderingContext"_s, "detachShader"_s, "WebGLShader"_s); });
    if (shaderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "detachShader"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, shaderConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.detachShader(*programConversionResult.releaseReturnValue(), *shaderConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_detachShader, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_detachShaderBody>(*lexicalGlobalObject, *callFrame, "detachShader");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_disableBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto capConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (capConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "disable"_s, { InspectorCanvasCallTracer::processArgument(impl, capConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.disable(capConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_disable, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_disableBody>(*lexicalGlobalObject, *callFrame, "disable");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_disableVertexAttribArrayBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "disableVertexAttribArray"_s, { InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.disableVertexAttribArray(indexConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_disableVertexAttribArray, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_disableVertexAttribArrayBody>(*lexicalGlobalObject, *callFrame, "disableVertexAttribArray");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_drawArraysBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto modeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (modeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto firstConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (firstConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto countConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (countConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "drawArrays"_s, { InspectorCanvasCallTracer::processArgument(impl, modeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, firstConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, countConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.drawArrays(modeConversionResult.releaseReturnValue(), firstConversionResult.releaseReturnValue(), countConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_drawArrays, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_drawArraysBody>(*lexicalGlobalObject, *callFrame, "drawArrays");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_drawElementsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto modeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (modeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto countConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (countConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto offsetConversionResult = convert<IDLLongLong>(*lexicalGlobalObject, argument3.value());
    if (offsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "drawElements"_s, { InspectorCanvasCallTracer::processArgument(impl, modeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, countConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, offsetConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.drawElements(modeConversionResult.releaseReturnValue(), countConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), offsetConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_drawElements, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_drawElementsBody>(*lexicalGlobalObject, *callFrame, "drawElements");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_enableBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto capConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (capConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "enable"_s, { InspectorCanvasCallTracer::processArgument(impl, capConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.enable(capConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_enable, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_enableBody>(*lexicalGlobalObject, *callFrame, "enable");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_enableVertexAttribArrayBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "enableVertexAttribArray"_s, { InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.enableVertexAttribArray(indexConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_enableVertexAttribArray, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_enableVertexAttribArrayBody>(*lexicalGlobalObject, *callFrame, "enableVertexAttribArray");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_finishBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "finish"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.finish(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_finish, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_finishBody>(*lexicalGlobalObject, *callFrame, "finish");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_flushBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "flush"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.flush(); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_flush, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_flushBody>(*lexicalGlobalObject, *callFrame, "flush");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_framebufferRenderbufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto attachmentConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (attachmentConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto renderbuffertargetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (renderbuffertargetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto renderbufferConversionResult = convert<IDLNullable<IDLInterface<WebGLRenderbuffer>>>(*lexicalGlobalObject, argument3.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 3, "renderbuffer"_s, "WebGL2RenderingContext"_s, "framebufferRenderbuffer"_s, "WebGLRenderbuffer"_s); });
    if (renderbufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "framebufferRenderbuffer"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, attachmentConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, renderbuffertargetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, renderbufferConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.framebufferRenderbuffer(targetConversionResult.releaseReturnValue(), attachmentConversionResult.releaseReturnValue(), renderbuffertargetConversionResult.releaseReturnValue(), renderbufferConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_framebufferRenderbuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_framebufferRenderbufferBody>(*lexicalGlobalObject, *callFrame, "framebufferRenderbuffer");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_framebufferTexture2DBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 5) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto attachmentConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (attachmentConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto textargetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (textargetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto textureConversionResult = convert<IDLNullable<IDLInterface<WebGLTexture>>>(*lexicalGlobalObject, argument3.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 3, "texture"_s, "WebGL2RenderingContext"_s, "framebufferTexture2D"_s, "WebGLTexture"_s); });
    if (textureConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto levelConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (levelConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "framebufferTexture2D"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, attachmentConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, textargetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, textureConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, levelConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.framebufferTexture2D(targetConversionResult.releaseReturnValue(), attachmentConversionResult.releaseReturnValue(), textargetConversionResult.releaseReturnValue(), textureConversionResult.releaseReturnValue(), levelConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_framebufferTexture2D, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_framebufferTexture2DBody>(*lexicalGlobalObject, *callFrame, "framebufferTexture2D");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_frontFaceBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto modeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (modeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "frontFace"_s, { InspectorCanvasCallTracer::processArgument(impl, modeConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.frontFace(modeConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_frontFace, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_frontFaceBody>(*lexicalGlobalObject, *callFrame, "frontFace");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_generateMipmapBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "generateMipmap"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.generateMipmap(targetConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_generateMipmap, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_generateMipmapBody>(*lexicalGlobalObject, *callFrame, "generateMipmap");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getActiveAttribBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGL2RenderingContext"_s, "getActiveAttrib"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getActiveAttrib"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<WebGLActiveInfo>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getActiveAttrib(*programConversionResult.releaseReturnValue(), indexConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getActiveAttrib, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getActiveAttribBody>(*lexicalGlobalObject, *callFrame, "getActiveAttrib");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getActiveUniformBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGL2RenderingContext"_s, "getActiveUniform"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getActiveUniform"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<WebGLActiveInfo>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getActiveUniform(*programConversionResult.releaseReturnValue(), indexConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getActiveUniform, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getActiveUniformBody>(*lexicalGlobalObject, *callFrame, "getActiveUniform");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getAttachedShadersBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGL2RenderingContext"_s, "getAttachedShaders"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getAttachedShaders"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLSequence<IDLInterface<WebGLShader>>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getAttachedShaders(*programConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getAttachedShaders, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getAttachedShadersBody>(*lexicalGlobalObject, *callFrame, "getAttachedShaders");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getAttribLocationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGL2RenderingContext"_s, "getAttribLocation"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto nameConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (nameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getAttribLocation"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, nameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLLong>(*lexicalGlobalObject, throwScope, impl.getAttribLocation(*programConversionResult.releaseReturnValue(), nameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getAttribLocation, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getAttribLocationBody>(*lexicalGlobalObject, *callFrame, "getAttribLocation");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getBufferParameterBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getBufferParameter"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLWebGLAny>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getBufferParameter(targetConversionResult.releaseReturnValue(), pnameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getBufferParameter, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getBufferParameterBody>(*lexicalGlobalObject, *callFrame, "getBufferParameter");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getContextAttributesBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getContextAttributes"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLDictionary<WebGLContextAttributes>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getContextAttributes())));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getContextAttributes, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getContextAttributesBody>(*lexicalGlobalObject, *callFrame, "getContextAttributes");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getErrorBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getError"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUnsignedLong>(*lexicalGlobalObject, throwScope, impl.getError())));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getError, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getErrorBody>(*lexicalGlobalObject, *callFrame, "getError");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getSupportedExtensionsBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getSupportedExtensions"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLSequence<IDLDOMString>>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getSupportedExtensions())));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getSupportedExtensions, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getSupportedExtensionsBody>(*lexicalGlobalObject, *callFrame, "getSupportedExtensions");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getExtensionBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto nameConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument0.value());
    if (nameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getExtension"_s, { InspectorCanvasCallTracer::processArgument(impl, nameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLWebGLExtensionAny>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getExtension(nameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getExtension, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getExtensionBody>(*lexicalGlobalObject, *callFrame, "getExtension");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getFramebufferAttachmentParameterBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto attachmentConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (attachmentConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getFramebufferAttachmentParameter"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, attachmentConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLWebGLAny>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getFramebufferAttachmentParameter(targetConversionResult.releaseReturnValue(), attachmentConversionResult.releaseReturnValue(), pnameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getFramebufferAttachmentParameter, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getFramebufferAttachmentParameterBody>(*lexicalGlobalObject, *callFrame, "getFramebufferAttachmentParameter");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getParameterBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getParameter"_s, { InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLWebGLAny>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getParameter(pnameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getParameter, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getParameterBody>(*lexicalGlobalObject, *callFrame, "getParameter");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getProgramParameterBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGL2RenderingContext"_s, "getProgramParameter"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getProgramParameter"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLWebGLAny>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getProgramParameter(*programConversionResult.releaseReturnValue(), pnameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getProgramParameter, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getProgramParameterBody>(*lexicalGlobalObject, *callFrame, "getProgramParameter");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getProgramInfoLogBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGL2RenderingContext"_s, "getProgramInfoLog"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getProgramInfoLog"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLDOMString>>(*lexicalGlobalObject, throwScope, impl.getProgramInfoLog(*programConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getProgramInfoLog, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getProgramInfoLogBody>(*lexicalGlobalObject, *callFrame, "getProgramInfoLog");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getRenderbufferParameterBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getRenderbufferParameter"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLWebGLAny>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getRenderbufferParameter(targetConversionResult.releaseReturnValue(), pnameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getRenderbufferParameter, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getRenderbufferParameterBody>(*lexicalGlobalObject, *callFrame, "getRenderbufferParameter");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getShaderParameterBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto shaderConversionResult = convert<IDLInterface<WebGLShader>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "shader"_s, "WebGL2RenderingContext"_s, "getShaderParameter"_s, "WebGLShader"_s); });
    if (shaderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getShaderParameter"_s, { InspectorCanvasCallTracer::processArgument(impl, shaderConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLWebGLAny>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getShaderParameter(*shaderConversionResult.releaseReturnValue(), pnameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getShaderParameter, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getShaderParameterBody>(*lexicalGlobalObject, *callFrame, "getShaderParameter");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getShaderInfoLogBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto shaderConversionResult = convert<IDLInterface<WebGLShader>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "shader"_s, "WebGL2RenderingContext"_s, "getShaderInfoLog"_s, "WebGLShader"_s); });
    if (shaderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getShaderInfoLog"_s, { InspectorCanvasCallTracer::processArgument(impl, shaderConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLDOMString>>(*lexicalGlobalObject, throwScope, impl.getShaderInfoLog(*shaderConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getShaderInfoLog, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getShaderInfoLogBody>(*lexicalGlobalObject, *callFrame, "getShaderInfoLog");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getShaderPrecisionFormatBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto shadertypeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (shadertypeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto precisiontypeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (precisiontypeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getShaderPrecisionFormat"_s, { InspectorCanvasCallTracer::processArgument(impl, shadertypeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, precisiontypeConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<WebGLShaderPrecisionFormat>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getShaderPrecisionFormat(shadertypeConversionResult.releaseReturnValue(), precisiontypeConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getShaderPrecisionFormat, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getShaderPrecisionFormatBody>(*lexicalGlobalObject, *callFrame, "getShaderPrecisionFormat");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getShaderSourceBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto shaderConversionResult = convert<IDLInterface<WebGLShader>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "shader"_s, "WebGL2RenderingContext"_s, "getShaderSource"_s, "WebGLShader"_s); });
    if (shaderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getShaderSource"_s, { InspectorCanvasCallTracer::processArgument(impl, shaderConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLNullable<IDLDOMString>>(*lexicalGlobalObject, throwScope, impl.getShaderSource(*shaderConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getShaderSource, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getShaderSourceBody>(*lexicalGlobalObject, *callFrame, "getShaderSource");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getTexParameterBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getTexParameter"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLWebGLAny>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getTexParameter(targetConversionResult.releaseReturnValue(), pnameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getTexParameter, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getTexParameterBody>(*lexicalGlobalObject, *callFrame, "getTexParameter");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getUniformBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGL2RenderingContext"_s, "getUniform"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto locationConversionResult = convert<IDLInterface<WebGLUniformLocation>>(*lexicalGlobalObject, argument1.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 1, "location"_s, "WebGL2RenderingContext"_s, "getUniform"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getUniform"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLWebGLAny>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getUniform(*programConversionResult.releaseReturnValue(), *locationConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getUniform, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getUniformBody>(*lexicalGlobalObject, *callFrame, "getUniform");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getUniformLocationBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGL2RenderingContext"_s, "getUniformLocation"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto nameConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (nameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getUniformLocation"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, nameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLInterface<WebGLUniformLocation>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getUniformLocation(*programConversionResult.releaseReturnValue(), nameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getUniformLocation, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getUniformLocationBody>(*lexicalGlobalObject, *callFrame, "getUniformLocation");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getVertexAttribBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getVertexAttrib"_s, { InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLWebGLAny>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, impl.getVertexAttrib(indexConversionResult.releaseReturnValue(), pnameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getVertexAttrib, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getVertexAttribBody>(*lexicalGlobalObject, *callFrame, "getVertexAttrib");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_getVertexAttribOffsetBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "getVertexAttribOffset"_s, { InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLLongLong>(*lexicalGlobalObject, throwScope, impl.getVertexAttribOffset(indexConversionResult.releaseReturnValue(), pnameConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_getVertexAttribOffset, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_getVertexAttribOffsetBody>(*lexicalGlobalObject, *callFrame, "getVertexAttribOffset");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_hintBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto modeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (modeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "hint"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, modeConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.hint(targetConversionResult.releaseReturnValue(), modeConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_hint, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_hintBody>(*lexicalGlobalObject, *callFrame, "hint");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_isBufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto bufferConversionResult = convert<IDLNullable<IDLInterface<WebGLBuffer>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "buffer"_s, "WebGL2RenderingContext"_s, "isBuffer"_s, "WebGLBuffer"_s); });
    if (bufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "isBuffer"_s, { InspectorCanvasCallTracer::processArgument(impl, bufferConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isBuffer(bufferConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_isBuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_isBufferBody>(*lexicalGlobalObject, *callFrame, "isBuffer");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_isContextLostBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "isContextLost"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isContextLost())));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_isContextLost, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_isContextLostBody>(*lexicalGlobalObject, *callFrame, "isContextLost");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_isEnabledBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto capConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (capConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "isEnabled"_s, { InspectorCanvasCallTracer::processArgument(impl, capConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isEnabled(capConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_isEnabled, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_isEnabledBody>(*lexicalGlobalObject, *callFrame, "isEnabled");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_isFramebufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto framebufferConversionResult = convert<IDLNullable<IDLInterface<WebGLFramebuffer>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "framebuffer"_s, "WebGL2RenderingContext"_s, "isFramebuffer"_s, "WebGLFramebuffer"_s); });
    if (framebufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "isFramebuffer"_s, { InspectorCanvasCallTracer::processArgument(impl, framebufferConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isFramebuffer(framebufferConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_isFramebuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_isFramebufferBody>(*lexicalGlobalObject, *callFrame, "isFramebuffer");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_isProgramBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGL2RenderingContext"_s, "isProgram"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "isProgram"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isProgram(programConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_isProgram, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_isProgramBody>(*lexicalGlobalObject, *callFrame, "isProgram");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_isRenderbufferBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto renderbufferConversionResult = convert<IDLNullable<IDLInterface<WebGLRenderbuffer>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "renderbuffer"_s, "WebGL2RenderingContext"_s, "isRenderbuffer"_s, "WebGLRenderbuffer"_s); });
    if (renderbufferConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "isRenderbuffer"_s, { InspectorCanvasCallTracer::processArgument(impl, renderbufferConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isRenderbuffer(renderbufferConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_isRenderbuffer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_isRenderbufferBody>(*lexicalGlobalObject, *callFrame, "isRenderbuffer");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_isShaderBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto shaderConversionResult = convert<IDLNullable<IDLInterface<WebGLShader>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "shader"_s, "WebGL2RenderingContext"_s, "isShader"_s, "WebGLShader"_s); });
    if (shaderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "isShader"_s, { InspectorCanvasCallTracer::processArgument(impl, shaderConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isShader(shaderConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_isShader, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_isShaderBody>(*lexicalGlobalObject, *callFrame, "isShader");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_isTextureBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto textureConversionResult = convert<IDLNullable<IDLInterface<WebGLTexture>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "texture"_s, "WebGL2RenderingContext"_s, "isTexture"_s, "WebGLTexture"_s); });
    if (textureConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "isTexture"_s, { InspectorCanvasCallTracer::processArgument(impl, textureConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLBoolean>(*lexicalGlobalObject, throwScope, impl.isTexture(textureConversionResult.releaseReturnValue()))));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_isTexture, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_isTextureBody>(*lexicalGlobalObject, *callFrame, "isTexture");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_lineWidthBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto widthConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument0.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "lineWidth"_s, { InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.lineWidth(widthConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_lineWidth, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_lineWidthBody>(*lexicalGlobalObject, *callFrame, "lineWidth");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_linkProgramBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGL2RenderingContext"_s, "linkProgram"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "linkProgram"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.linkProgram(*programConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_linkProgram, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_linkProgramBody>(*lexicalGlobalObject, *callFrame, "linkProgram");
}

#endif

#if ENABLE(WEBGL) && ENABLE(WEBXR)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_makeXRCompatibleBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperationReturningPromise<JSWebGL2RenderingContext>::ClassParameter castedThis, Ref<DeferredPromise>&& promise)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "makeXRCompatible"_s);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJSNewlyCreated<IDLPromise<IDLUndefined>>(*lexicalGlobalObject, *castedThis->globalObject(), throwScope, [&]() -> decltype(auto) { return impl.makeXRCompatible(WTFMove(promise)); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_makeXRCompatible, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperationReturningPromise<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_makeXRCompatibleBody>(*lexicalGlobalObject, *callFrame, "makeXRCompatible");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_pixelStoreiBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto paramConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (paramConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "pixelStorei"_s, { InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, paramConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.pixelStorei(pnameConversionResult.releaseReturnValue(), paramConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_pixelStorei, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_pixelStoreiBody>(*lexicalGlobalObject, *callFrame, "pixelStorei");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_polygonOffsetBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto factorConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument0.value());
    if (factorConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto unitsConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument1.value());
    if (unitsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "polygonOffset"_s, { InspectorCanvasCallTracer::processArgument(impl, factorConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, unitsConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.polygonOffset(factorConversionResult.releaseReturnValue(), unitsConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_polygonOffset, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_polygonOffsetBody>(*lexicalGlobalObject, *callFrame, "polygonOffset");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_readPixels3Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto xConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument0.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto yConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto formatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument4.value());
    if (formatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument5.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument6 = callFrame->uncheckedArgument(6);
    auto pixelsConversionResult = convert<IDLNullable<IDLAllowSharedAdaptor<IDLArrayBufferView>>>(*lexicalGlobalObject, argument6.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 6, "pixels"_s, "WebGL2RenderingContext"_s, "readPixels"_s, "ArrayBufferView"_s); });
    if (pixelsConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "readPixels"_s, { InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, formatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pixelsConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.readPixels(xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue(), formatConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), pixelsConversionResult.releaseReturnValue()); })));
}

#endif

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_readPixelsOverloadDispatcher(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    size_t argsCount = std::min<size_t>(8, callFrame->argumentCount());
    if (argsCount == 7) {
        JSValue distinguishingArg = callFrame->uncheckedArgument(6);
#if ENABLE(WEBGL)
        if (distinguishingArg.isUndefinedOrNull())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_readPixels3Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
#if ENABLE(WEBGL)
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits<JSArrayBufferView>())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_readPixels3Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
        if (distinguishingArg.isNumber())
            RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_readPixels1Body(lexicalGlobalObject, callFrame, castedThis)));
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_readPixels1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    if (argsCount == 8) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_readPixels2Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    return argsCount < 7 ? throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject)) : throwVMTypeError(lexicalGlobalObject, throwScope);
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_readPixels, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_readPixelsOverloadDispatcher>(*lexicalGlobalObject, *callFrame, "readPixels");
}

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_renderbufferStorageBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto internalformatConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (internalformatConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "renderbufferStorage"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, internalformatConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.renderbufferStorage(targetConversionResult.releaseReturnValue(), internalformatConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_renderbufferStorage, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_renderbufferStorageBody>(*lexicalGlobalObject, *callFrame, "renderbufferStorage");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_sampleCoverageBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto valueConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument0.value());
    if (valueConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto invertConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (invertConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "sampleCoverage"_s, { InspectorCanvasCallTracer::processArgument(impl, valueConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, invertConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.sampleCoverage(valueConversionResult.releaseReturnValue(), invertConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_sampleCoverage, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_sampleCoverageBody>(*lexicalGlobalObject, *callFrame, "sampleCoverage");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_scissorBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto xConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument0.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto yConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "scissor"_s, { InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.scissor(xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_scissor, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_scissorBody>(*lexicalGlobalObject, *callFrame, "scissor");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_shaderSourceBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto shaderConversionResult = convert<IDLInterface<WebGLShader>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "shader"_s, "WebGL2RenderingContext"_s, "shaderSource"_s, "WebGLShader"_s); });
    if (shaderConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto stringConversionResult = convert<IDLDOMString>(*lexicalGlobalObject, argument1.value());
    if (stringConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "shaderSource"_s, { InspectorCanvasCallTracer::processArgument(impl, shaderConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, stringConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.shaderSource(*shaderConversionResult.releaseReturnValue(), stringConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_shaderSource, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_shaderSourceBody>(*lexicalGlobalObject, *callFrame, "shaderSource");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_stencilFuncBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto funcConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (funcConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto refConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (refConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto maskConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (maskConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "stencilFunc"_s, { InspectorCanvasCallTracer::processArgument(impl, funcConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, refConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, maskConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.stencilFunc(funcConversionResult.releaseReturnValue(), refConversionResult.releaseReturnValue(), maskConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_stencilFunc, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_stencilFuncBody>(*lexicalGlobalObject, *callFrame, "stencilFunc");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_stencilFuncSeparateBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto faceConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (faceConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto funcConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (funcConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto refConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (refConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto maskConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (maskConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "stencilFuncSeparate"_s, { InspectorCanvasCallTracer::processArgument(impl, faceConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, funcConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, refConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, maskConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.stencilFuncSeparate(faceConversionResult.releaseReturnValue(), funcConversionResult.releaseReturnValue(), refConversionResult.releaseReturnValue(), maskConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_stencilFuncSeparate, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_stencilFuncSeparateBody>(*lexicalGlobalObject, *callFrame, "stencilFuncSeparate");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_stencilMaskBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto maskConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (maskConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "stencilMask"_s, { InspectorCanvasCallTracer::processArgument(impl, maskConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.stencilMask(maskConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_stencilMask, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_stencilMaskBody>(*lexicalGlobalObject, *callFrame, "stencilMask");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_stencilMaskSeparateBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto faceConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (faceConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto maskConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (maskConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "stencilMaskSeparate"_s, { InspectorCanvasCallTracer::processArgument(impl, faceConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, maskConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.stencilMaskSeparate(faceConversionResult.releaseReturnValue(), maskConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_stencilMaskSeparate, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_stencilMaskSeparateBody>(*lexicalGlobalObject, *callFrame, "stencilMaskSeparate");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_stencilOpBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto failConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (failConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto zfailConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (zfailConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto zpassConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (zpassConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "stencilOp"_s, { InspectorCanvasCallTracer::processArgument(impl, failConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, zfailConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, zpassConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.stencilOp(failConversionResult.releaseReturnValue(), zfailConversionResult.releaseReturnValue(), zpassConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_stencilOp, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_stencilOpBody>(*lexicalGlobalObject, *callFrame, "stencilOp");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_stencilOpSeparateBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto faceConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (faceConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto failConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (failConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto zfailConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (zfailConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto zpassConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument3.value());
    if (zpassConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "stencilOpSeparate"_s, { InspectorCanvasCallTracer::processArgument(impl, faceConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, failConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, zfailConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, zpassConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.stencilOpSeparate(faceConversionResult.releaseReturnValue(), failConversionResult.releaseReturnValue(), zfailConversionResult.releaseReturnValue(), zpassConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_stencilOpSeparate, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_stencilOpSeparateBody>(*lexicalGlobalObject, *callFrame, "stencilOpSeparate");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_texParameterfBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto paramConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument2.value());
    if (paramConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "texParameterf"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, paramConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.texParameterf(targetConversionResult.releaseReturnValue(), pnameConversionResult.releaseReturnValue(), paramConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_texParameterf, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_texParameterfBody>(*lexicalGlobalObject, *callFrame, "texParameterf");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_texParameteriBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto targetConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (targetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto pnameConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument1.value());
    if (pnameConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto paramConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (paramConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "texParameteri"_s, { InspectorCanvasCallTracer::processArgument(impl, targetConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, pnameConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, paramConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.texParameteri(targetConversionResult.releaseReturnValue(), pnameConversionResult.releaseReturnValue(), paramConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_texParameteri, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_texParameteriBody>(*lexicalGlobalObject, *callFrame, "texParameteri");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform1fBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform1f"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto xConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument1.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform1f"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform1f(locationConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform1f, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniform1fBody>(*lexicalGlobalObject, *callFrame, "uniform1f");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform2fBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform2f"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto xConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument1.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto yConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument2.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform2f"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform2f(locationConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform2f, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniform2fBody>(*lexicalGlobalObject, *callFrame, "uniform2f");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform3fBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform3f"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto xConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument1.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto yConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument2.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto zConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument3.value());
    if (zConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform3f"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, zConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform3f(locationConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), zConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform3f, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniform3fBody>(*lexicalGlobalObject, *callFrame, "uniform3f");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform4fBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 5) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform4f"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto xConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument1.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto yConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument2.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto zConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument3.value());
    if (zConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto wConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument4.value());
    if (wConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform4f"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, zConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, wConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform4f(locationConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), zConversionResult.releaseReturnValue(), wConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform4f, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniform4fBody>(*lexicalGlobalObject, *callFrame, "uniform4f");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform1iBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform1i"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto xConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform1i"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform1i(locationConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform1i, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniform1iBody>(*lexicalGlobalObject, *callFrame, "uniform1i");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform2iBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform2i"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto xConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto yConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform2i"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform2i(locationConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform2i, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniform2iBody>(*lexicalGlobalObject, *callFrame, "uniform2i");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform3iBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform3i"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto xConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto yConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto zConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (zConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform3i"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, zConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform3i(locationConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), zConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform3i, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniform3iBody>(*lexicalGlobalObject, *callFrame, "uniform3i");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform4iBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 5) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform4i"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto xConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto yConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto zConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (zConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto wConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (wConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform4i"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, zConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, wConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform4i(locationConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), zConversionResult.releaseReturnValue(), wConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform4i, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniform4iBody>(*lexicalGlobalObject, *callFrame, "uniform4i");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform1fv2Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform1fv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto vConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument1.value());
    if (vConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform1fv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, vConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform1fv(locationConversionResult.releaseReturnValue(), vConversionResult.releaseReturnValue()); })));
}

#endif

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform1fvOverloadDispatcher(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    size_t argsCount = std::min<size_t>(4, callFrame->argumentCount());
    if (argsCount == 2) {
#if ENABLE(WEBGL)
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniform1fv2Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
    }
    if (argsCount == 3) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniform1fv1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    if (argsCount == 4) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniform1fv1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    return argsCount < 2 ? throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject)) : throwVMTypeError(lexicalGlobalObject, throwScope);
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform1fv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniform1fvOverloadDispatcher>(*lexicalGlobalObject, *callFrame, "uniform1fv");
}

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform2fv2Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform2fv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto vConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument1.value());
    if (vConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform2fv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, vConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform2fv(locationConversionResult.releaseReturnValue(), vConversionResult.releaseReturnValue()); })));
}

#endif

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform2fvOverloadDispatcher(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    size_t argsCount = std::min<size_t>(4, callFrame->argumentCount());
    if (argsCount == 2) {
#if ENABLE(WEBGL)
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniform2fv2Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
    }
    if (argsCount == 3) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniform2fv1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    if (argsCount == 4) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniform2fv1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    return argsCount < 2 ? throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject)) : throwVMTypeError(lexicalGlobalObject, throwScope);
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform2fv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniform2fvOverloadDispatcher>(*lexicalGlobalObject, *callFrame, "uniform2fv");
}

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform3fv2Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform3fv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto vConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument1.value());
    if (vConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform3fv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, vConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform3fv(locationConversionResult.releaseReturnValue(), vConversionResult.releaseReturnValue()); })));
}

#endif

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform3fvOverloadDispatcher(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    size_t argsCount = std::min<size_t>(4, callFrame->argumentCount());
    if (argsCount == 2) {
#if ENABLE(WEBGL)
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniform3fv2Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
    }
    if (argsCount == 3) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniform3fv1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    if (argsCount == 4) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniform3fv1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    return argsCount < 2 ? throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject)) : throwVMTypeError(lexicalGlobalObject, throwScope);
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform3fv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniform3fvOverloadDispatcher>(*lexicalGlobalObject, *callFrame, "uniform3fv");
}

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform4fv2Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform4fv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto vConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument1.value());
    if (vConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform4fv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, vConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform4fv(locationConversionResult.releaseReturnValue(), vConversionResult.releaseReturnValue()); })));
}

#endif

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform4fvOverloadDispatcher(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    size_t argsCount = std::min<size_t>(4, callFrame->argumentCount());
    if (argsCount == 2) {
#if ENABLE(WEBGL)
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniform4fv2Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
    }
    if (argsCount == 3) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniform4fv1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    if (argsCount == 4) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniform4fv1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    return argsCount < 2 ? throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject)) : throwVMTypeError(lexicalGlobalObject, throwScope);
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform4fv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniform4fvOverloadDispatcher>(*lexicalGlobalObject, *callFrame, "uniform4fv");
}

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform1iv2Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform1iv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto vConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLInt32Array>, IDLSequence<IDLLong>>>(*lexicalGlobalObject, argument1.value());
    if (vConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform1iv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, vConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform1iv(locationConversionResult.releaseReturnValue(), vConversionResult.releaseReturnValue()); })));
}

#endif

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform1ivOverloadDispatcher(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    size_t argsCount = std::min<size_t>(4, callFrame->argumentCount());
    if (argsCount == 2) {
#if ENABLE(WEBGL)
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniform1iv2Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
    }
    if (argsCount == 3) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniform1iv1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    if (argsCount == 4) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniform1iv1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    return argsCount < 2 ? throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject)) : throwVMTypeError(lexicalGlobalObject, throwScope);
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform1iv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniform1ivOverloadDispatcher>(*lexicalGlobalObject, *callFrame, "uniform1iv");
}

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform2iv2Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform2iv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto vConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLInt32Array>, IDLSequence<IDLLong>>>(*lexicalGlobalObject, argument1.value());
    if (vConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform2iv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, vConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform2iv(locationConversionResult.releaseReturnValue(), vConversionResult.releaseReturnValue()); })));
}

#endif

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform2ivOverloadDispatcher(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    size_t argsCount = std::min<size_t>(4, callFrame->argumentCount());
    if (argsCount == 2) {
#if ENABLE(WEBGL)
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniform2iv2Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
    }
    if (argsCount == 3) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniform2iv1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    if (argsCount == 4) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniform2iv1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    return argsCount < 2 ? throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject)) : throwVMTypeError(lexicalGlobalObject, throwScope);
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform2iv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniform2ivOverloadDispatcher>(*lexicalGlobalObject, *callFrame, "uniform2iv");
}

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform3iv2Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform3iv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto vConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLInt32Array>, IDLSequence<IDLLong>>>(*lexicalGlobalObject, argument1.value());
    if (vConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform3iv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, vConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform3iv(locationConversionResult.releaseReturnValue(), vConversionResult.releaseReturnValue()); })));
}

#endif

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform3ivOverloadDispatcher(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    size_t argsCount = std::min<size_t>(4, callFrame->argumentCount());
    if (argsCount == 2) {
#if ENABLE(WEBGL)
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniform3iv2Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
    }
    if (argsCount == 3) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniform3iv1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    if (argsCount == 4) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniform3iv1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    return argsCount < 2 ? throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject)) : throwVMTypeError(lexicalGlobalObject, throwScope);
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform3iv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniform3ivOverloadDispatcher>(*lexicalGlobalObject, *callFrame, "uniform3iv");
}

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform4iv2Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniform4iv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto vConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLInt32Array>, IDLSequence<IDLLong>>>(*lexicalGlobalObject, argument1.value());
    if (vConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniform4iv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, vConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniform4iv(locationConversionResult.releaseReturnValue(), vConversionResult.releaseReturnValue()); })));
}

#endif

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniform4ivOverloadDispatcher(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    size_t argsCount = std::min<size_t>(4, callFrame->argumentCount());
    if (argsCount == 2) {
#if ENABLE(WEBGL)
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniform4iv2Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
    }
    if (argsCount == 3) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniform4iv1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    if (argsCount == 4) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniform4iv1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    return argsCount < 2 ? throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject)) : throwVMTypeError(lexicalGlobalObject, throwScope);
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniform4iv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniform4ivOverloadDispatcher>(*lexicalGlobalObject, *callFrame, "uniform4iv");
}

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniformMatrix2fv2Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniformMatrix2fv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto transposeConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (transposeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto arrayConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument2.value());
    if (arrayConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniformMatrix2fv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, transposeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, arrayConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniformMatrix2fv(locationConversionResult.releaseReturnValue(), transposeConversionResult.releaseReturnValue(), arrayConversionResult.releaseReturnValue()); })));
}

#endif

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniformMatrix2fvOverloadDispatcher(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    size_t argsCount = std::min<size_t>(5, callFrame->argumentCount());
    if (argsCount == 3) {
#if ENABLE(WEBGL)
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniformMatrix2fv2Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
    }
    if (argsCount == 4) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniformMatrix2fv1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    if (argsCount == 5) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniformMatrix2fv1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    return argsCount < 3 ? throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject)) : throwVMTypeError(lexicalGlobalObject, throwScope);
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniformMatrix2fv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniformMatrix2fvOverloadDispatcher>(*lexicalGlobalObject, *callFrame, "uniformMatrix2fv");
}

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniformMatrix3fv2Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniformMatrix3fv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto transposeConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (transposeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto arrayConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument2.value());
    if (arrayConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniformMatrix3fv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, transposeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, arrayConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniformMatrix3fv(locationConversionResult.releaseReturnValue(), transposeConversionResult.releaseReturnValue(), arrayConversionResult.releaseReturnValue()); })));
}

#endif

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniformMatrix3fvOverloadDispatcher(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    size_t argsCount = std::min<size_t>(5, callFrame->argumentCount());
    if (argsCount == 3) {
#if ENABLE(WEBGL)
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniformMatrix3fv2Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
    }
    if (argsCount == 4) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniformMatrix3fv1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    if (argsCount == 5) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniformMatrix3fv1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    return argsCount < 3 ? throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject)) : throwVMTypeError(lexicalGlobalObject, throwScope);
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniformMatrix3fv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniformMatrix3fvOverloadDispatcher>(*lexicalGlobalObject, *callFrame, "uniformMatrix3fv");
}

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniformMatrix4fv2Body(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto locationConversionResult = convert<IDLNullable<IDLInterface<WebGLUniformLocation>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "location"_s, "WebGL2RenderingContext"_s, "uniformMatrix4fv"_s, "WebGLUniformLocation"_s); });
    if (locationConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto transposeConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument1.value());
    if (transposeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto arrayConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument2.value());
    if (arrayConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "uniformMatrix4fv"_s, { InspectorCanvasCallTracer::processArgument(impl, locationConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, transposeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, arrayConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.uniformMatrix4fv(locationConversionResult.releaseReturnValue(), transposeConversionResult.releaseReturnValue(), arrayConversionResult.releaseReturnValue()); })));
}

#endif

static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_uniformMatrix4fvOverloadDispatcher(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    size_t argsCount = std::min<size_t>(5, callFrame->argumentCount());
    if (argsCount == 3) {
#if ENABLE(WEBGL)
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniformMatrix4fv2Body(lexicalGlobalObject, callFrame, castedThis)));
#endif
    }
    if (argsCount == 4) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniformMatrix4fv1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    if (argsCount == 5) {
        RELEASE_AND_RETURN(throwScope, (jsWebGL2RenderingContextPrototypeFunction_uniformMatrix4fv1Body(lexicalGlobalObject, callFrame, castedThis)));
    }
    return argsCount < 3 ? throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject)) : throwVMTypeError(lexicalGlobalObject, throwScope);
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_uniformMatrix4fv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_uniformMatrix4fvOverloadDispatcher>(*lexicalGlobalObject, *callFrame, "uniformMatrix4fv");
}

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_useProgramBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLNullable<IDLInterface<WebGLProgram>>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGL2RenderingContext"_s, "useProgram"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "useProgram"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.useProgram(programConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_useProgram, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_useProgramBody>(*lexicalGlobalObject, *callFrame, "useProgram");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_validateProgramBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 1) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto programConversionResult = convert<IDLInterface<WebGLProgram>>(*lexicalGlobalObject, argument0.value(), [](JSC::JSGlobalObject& lexicalGlobalObject, JSC::ThrowScope& scope) { throwArgumentTypeError(lexicalGlobalObject, scope, 0, "program"_s, "WebGL2RenderingContext"_s, "validateProgram"_s, "WebGLProgram"_s); });
    if (programConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "validateProgram"_s, { InspectorCanvasCallTracer::processArgument(impl, programConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.validateProgram(*programConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_validateProgram, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_validateProgramBody>(*lexicalGlobalObject, *callFrame, "validateProgram");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_vertexAttrib1fBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto xConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument1.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "vertexAttrib1f"_s, { InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.vertexAttrib1f(indexConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_vertexAttrib1f, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_vertexAttrib1fBody>(*lexicalGlobalObject, *callFrame, "vertexAttrib1f");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_vertexAttrib2fBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 3) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto xConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument1.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto yConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument2.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "vertexAttrib2f"_s, { InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.vertexAttrib2f(indexConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_vertexAttrib2f, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_vertexAttrib2fBody>(*lexicalGlobalObject, *callFrame, "vertexAttrib2f");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_vertexAttrib3fBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto xConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument1.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto yConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument2.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto zConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument3.value());
    if (zConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "vertexAttrib3f"_s, { InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, zConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.vertexAttrib3f(indexConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), zConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_vertexAttrib3f, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_vertexAttrib3fBody>(*lexicalGlobalObject, *callFrame, "vertexAttrib3f");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_vertexAttrib4fBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 5) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto xConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument1.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto yConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument2.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto zConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument3.value());
    if (zConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto wConversionResult = convert<IDLUnrestrictedFloat>(*lexicalGlobalObject, argument4.value());
    if (wConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "vertexAttrib4f"_s, { InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, zConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, wConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.vertexAttrib4f(indexConversionResult.releaseReturnValue(), xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), zConversionResult.releaseReturnValue(), wConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_vertexAttrib4f, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_vertexAttrib4fBody>(*lexicalGlobalObject, *callFrame, "vertexAttrib4f");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_vertexAttrib1fvBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto valuesConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument1.value());
    if (valuesConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "vertexAttrib1fv"_s, { InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, valuesConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.vertexAttrib1fv(indexConversionResult.releaseReturnValue(), valuesConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_vertexAttrib1fv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_vertexAttrib1fvBody>(*lexicalGlobalObject, *callFrame, "vertexAttrib1fv");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_vertexAttrib2fvBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto valuesConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument1.value());
    if (valuesConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "vertexAttrib2fv"_s, { InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, valuesConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.vertexAttrib2fv(indexConversionResult.releaseReturnValue(), valuesConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_vertexAttrib2fv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_vertexAttrib2fvBody>(*lexicalGlobalObject, *callFrame, "vertexAttrib2fv");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_vertexAttrib3fvBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto valuesConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument1.value());
    if (valuesConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "vertexAttrib3fv"_s, { InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, valuesConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.vertexAttrib3fv(indexConversionResult.releaseReturnValue(), valuesConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_vertexAttrib3fv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_vertexAttrib3fvBody>(*lexicalGlobalObject, *callFrame, "vertexAttrib3fv");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_vertexAttrib4fvBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 2) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indexConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indexConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto valuesConversionResult = convert<IDLUnion<IDLAllowSharedAdaptor<IDLFloat32Array>, IDLSequence<IDLUnrestrictedFloat>>>(*lexicalGlobalObject, argument1.value());
    if (valuesConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "vertexAttrib4fv"_s, { InspectorCanvasCallTracer::processArgument(impl, indexConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, valuesConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.vertexAttrib4fv(indexConversionResult.releaseReturnValue(), valuesConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_vertexAttrib4fv, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_vertexAttrib4fvBody>(*lexicalGlobalObject, *callFrame, "vertexAttrib4fv");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_vertexAttribPointerBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 6) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto indxConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument0.value());
    if (indxConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto sizeConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (sizeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto typeConversionResult = convert<IDLUnsignedLong>(*lexicalGlobalObject, argument2.value());
    if (typeConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto normalizedConversionResult = convert<IDLBoolean>(*lexicalGlobalObject, argument3.value());
    if (normalizedConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument4 = callFrame->uncheckedArgument(4);
    auto strideConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument4.value());
    if (strideConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument5 = callFrame->uncheckedArgument(5);
    auto offsetConversionResult = convert<IDLLongLong>(*lexicalGlobalObject, argument5.value());
    if (offsetConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "vertexAttribPointer"_s, { InspectorCanvasCallTracer::processArgument(impl, indxConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, sizeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, typeConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, normalizedConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, strideConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, offsetConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.vertexAttribPointer(indxConversionResult.releaseReturnValue(), sizeConversionResult.releaseReturnValue(), typeConversionResult.releaseReturnValue(), normalizedConversionResult.releaseReturnValue(), strideConversionResult.releaseReturnValue(), offsetConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_vertexAttribPointer, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_vertexAttribPointerBody>(*lexicalGlobalObject, *callFrame, "vertexAttribPointer");
}

#endif

#if ENABLE(WEBGL)
static inline JSC::EncodedJSValue jsWebGL2RenderingContextPrototypeFunction_viewportBody(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame, typename IDLOperation<JSWebGL2RenderingContext>::ClassParameter castedThis)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(throwScope);
    UNUSED_PARAM(callFrame);
    SUPPRESS_UNCOUNTED_LOCAL auto& impl = castedThis->wrapped();
    if (callFrame->argumentCount() < 4) [[unlikely]]
        return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));
    EnsureStillAliveScope argument0 = callFrame->uncheckedArgument(0);
    auto xConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument0.value());
    if (xConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument1 = callFrame->uncheckedArgument(1);
    auto yConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument1.value());
    if (yConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument2 = callFrame->uncheckedArgument(2);
    auto widthConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument2.value());
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    EnsureStillAliveScope argument3 = callFrame->uncheckedArgument(3);
    auto heightConversionResult = convert<IDLLong>(*lexicalGlobalObject, argument3.value());
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
       return encodedJSValue();
    if (impl.hasActiveInspectorCanvasCallTracer()) [[unlikely]]
        InspectorCanvasCallTracer::recordAction(impl, "viewport"_s, { InspectorCanvasCallTracer::processArgument(impl, xConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, yConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, widthConversionResult.returnValue()), InspectorCanvasCallTracer::processArgument(impl, heightConversionResult.returnValue()) });
    RELEASE_AND_RETURN(throwScope, JSValue::encode(toJS<IDLUndefined>(*lexicalGlobalObject, throwScope, [&]() -> decltype(auto) { return impl.viewport(xConversionResult.releaseReturnValue(), yConversionResult.releaseReturnValue(), widthConversionResult.releaseReturnValue(), heightConversionResult.releaseReturnValue()); })));
}

JSC_DEFINE_HOST_FUNCTION(jsWebGL2RenderingContextPrototypeFunction_viewport, (JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame))
{
    return IDLOperation<JSWebGL2RenderingContext>::call<jsWebGL2RenderingContextPrototypeFunction_viewportBody>(*lexicalGlobalObject, *callFrame, "viewport");
}

#endif

JSC::GCClient::IsoSubspace* JSWebGL2RenderingContext::subspaceForImpl(JSC::VM& vm)
{
    return WebCore::subspaceForImpl<JSWebGL2RenderingContext, UseCustomHeapCellType::No>(vm, "JSWebGL2RenderingContext"_s,
        [] (auto& spaces) { return spaces.m_clientSubspaceForWebGL2RenderingContext.get(); },
        [] (auto& spaces, auto&& space) { spaces.m_clientSubspaceForWebGL2RenderingContext = std::forward<decltype(space)>(space); },
        [] (auto& spaces) { return spaces.m_subspaceForWebGL2RenderingContext.get(); },
        [] (auto& spaces, auto&& space) { spaces.m_subspaceForWebGL2RenderingContext = std::forward<decltype(space)>(space); }
    );
}

template<typename Visitor>
void JSWebGL2RenderingContext::visitChildrenImpl(JSCell* cell, Visitor& visitor)
{
    auto* thisObject = jsCast<JSWebGL2RenderingContext*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);
    thisObject->visitAdditionalChildren(visitor);
}

DEFINE_VISIT_CHILDREN(JSWebGL2RenderingContext);

template<typename Visitor>
void JSWebGL2RenderingContext::visitOutputConstraints(JSCell* cell, Visitor& visitor)
{
    auto* thisObject = jsCast<JSWebGL2RenderingContext*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitOutputConstraints(thisObject, visitor);
    thisObject->visitAdditionalChildren(visitor);
}

template void JSWebGL2RenderingContext::visitOutputConstraints(JSCell*, AbstractSlotVisitor&);
template void JSWebGL2RenderingContext::visitOutputConstraints(JSCell*, SlotVisitor&);
void JSWebGL2RenderingContext::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSWebGL2RenderingContext*>(cell);
    analyzer.setWrappedObjectForCell(cell, &thisObject->wrapped());
    if (RefPtr context = thisObject->scriptExecutionContext())
        analyzer.setLabelForCell(cell, makeString("url "_s, context->url().string()));
    Base::analyzeHeap(cell, analyzer);
}

bool JSWebGL2RenderingContextOwner::isReachableFromOpaqueRoots(JSC::Handle<JSC::Unknown> handle, void*, AbstractSlotVisitor& visitor, ASCIILiteral* reason)
{
    SUPPRESS_UNCOUNTED_LOCAL auto* jsWebGL2RenderingContext = jsCast<JSWebGL2RenderingContext*>(handle.slot()->asCell());
    SUPPRESS_UNCOUNTED_LOCAL auto& wrapped = jsWebGL2RenderingContext->wrapped();
    if (!wrapped.isContextStopped() && wrapped.hasPendingActivity()) {
        if (reason) [[unlikely]]
            *reason = "ActiveDOMObject with pending activity"_s;
        return true;
     }
    auto& owner = jsWebGL2RenderingContext->wrapped().canvasBase();
    if (reason) [[unlikely]]
        *reason = "Reachable from CanvasBase"_s;
    return containsWebCoreOpaqueRoot(visitor, owner);
}

void JSWebGL2RenderingContextOwner::finalize(JSC::Handle<JSC::Unknown> handle, void* context)
{
    auto* jsWebGL2RenderingContext = static_cast<JSWebGL2RenderingContext*>(handle.slot()->asCell());
    auto& world = *static_cast<DOMWrapperWorld*>(context);
    uncacheWrapper(world, jsWebGL2RenderingContext->protectedWrapped().ptr(), jsWebGL2RenderingContext);
}

WTF_ALLOW_UNSAFE_BUFFER_USAGE_BEGIN
#if ENABLE(BINDING_INTEGRITY)
#if PLATFORM(WIN)
#pragma warning(disable: 4483)
extern "C" { extern void (*const __identifier("??_7WebGL2RenderingContext@WebCore@@6B@")[])(); }
#else
extern "C" { extern void* _ZTVN7WebCore22WebGL2RenderingContextE[]; }
#endif
template<std::same_as<WebGL2RenderingContext> T>
static inline void verifyVTable(WebGL2RenderingContext* ptr) 
{
    if constexpr (std::is_polymorphic_v<T>) {
        const void* actualVTablePointer = getVTablePointer<T>(ptr);
#if PLATFORM(WIN)
        void* expectedVTablePointer = __identifier("??_7WebGL2RenderingContext@WebCore@@6B@");
#else
        void* expectedVTablePointer = &_ZTVN7WebCore22WebGL2RenderingContextE[2];
#endif

        // If you hit this assertion you either have a use after free bug, or
        // WebGL2RenderingContext has subclasses. If WebGL2RenderingContext has subclasses that get passed
        // to toJS() we currently require WebGL2RenderingContext you to opt out of binding hardening
        // by adding the SkipVTableValidation attribute to the interface IDL definition
        RELEASE_ASSERT(actualVTablePointer == expectedVTablePointer);
    }
}
#endif
WTF_ALLOW_UNSAFE_BUFFER_USAGE_END

JSC::JSValue toJSNewlyCreated(JSC::JSGlobalObject*, JSDOMGlobalObject* globalObject, Ref<WebGL2RenderingContext>&& impl)
{
#if ENABLE(BINDING_INTEGRITY)
    verifyVTable<WebGL2RenderingContext>(impl.ptr());
#endif
    return createWrapper<WebGL2RenderingContext>(globalObject, WTFMove(impl));
}

JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, WebGL2RenderingContext& impl)
{
    return wrap(lexicalGlobalObject, globalObject, impl);
}

WebGL2RenderingContext* JSWebGL2RenderingContext::toWrapped(JSC::VM&, JSC::JSValue value)
{
    if (auto* wrapper = jsDynamicCast<JSWebGL2RenderingContext*>(value))
        return &wrapper->wrapped();
    return nullptr;
}

}

#endif // ENABLE(WEBGL)
