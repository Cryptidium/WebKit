/*
    This file is part of the WebKit open source project.
    This file has been generated by generate-bindings.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.
*/

#include "config.h"

#if ENABLE(WEBXR_LAYERS)

#include "JSXRQuadLayerInit.h"

#include "JSDOMConvertBoolean.h"
#include "JSDOMConvertEnumeration.h"
#include "JSDOMConvertInterface.h"
#include "JSDOMConvertNullable.h"
#include "JSDOMConvertNumbers.h"
#include "JSDOMConvertOptional.h"
#include "JSDOMGlobalObject.h"
#include "JSWebXRRigidTransform.h"
#include "JSWebXRSpace.h"
#include "JSXRLayerLayout.h"
#include "JSXRTextureType.h"
#include <JavaScriptCore/JSCInlines.h>
#include <JavaScriptCore/ObjectConstructor.h>



namespace WebCore {
using namespace JSC;

#if ENABLE(WEBXR_LAYERS)

template<> ConversionResult<IDLDictionary<XRQuadLayerInit>> convertDictionary<XRQuadLayerInit>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    bool isNullOrUndefined = value.isUndefinedOrNull();
    auto* object = isNullOrUndefined ? nullptr : value.getObject();
    if (!isNullOrUndefined && !object) [[unlikely]] {
        throwTypeError(&lexicalGlobalObject, throwScope);
        return ConversionResultException { };
    }
    XRQuadLayerInit result;
    JSValue clearOnAccessValue;
    if (isNullOrUndefined)
        clearOnAccessValue = jsUndefined();
    else {
        clearOnAccessValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "clearOnAccess"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto clearOnAccessConversionResult = convertOptionalWithDefault<IDLBoolean>(lexicalGlobalObject, clearOnAccessValue, [&]() -> ConversionResult<IDLBoolean> { return Converter<IDLBoolean>::ReturnType { true }; });
    if (clearOnAccessConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.clearOnAccess = clearOnAccessConversionResult.releaseReturnValue();
    JSValue colorFormatValue;
    if (isNullOrUndefined)
        colorFormatValue = jsUndefined();
    else {
        colorFormatValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "colorFormat"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto colorFormatConversionResult = convertOptionalWithDefault<IDLUnsignedLong>(lexicalGlobalObject, colorFormatValue, [&]() -> ConversionResult<IDLUnsignedLong> { return Converter<IDLUnsignedLong>::ReturnType { 0x1908 }; });
    if (colorFormatConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.colorFormat = colorFormatConversionResult.releaseReturnValue();
    JSValue depthFormatValue;
    if (isNullOrUndefined)
        depthFormatValue = jsUndefined();
    else {
        depthFormatValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "depthFormat"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!depthFormatValue.isUndefined()) {
        auto depthFormatConversionResult = convert<IDLNullable<IDLUnsignedLong>>(lexicalGlobalObject, depthFormatValue);
        if (depthFormatConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.depthFormat = depthFormatConversionResult.releaseReturnValue();
    }
    JSValue isStaticValue;
    if (isNullOrUndefined)
        isStaticValue = jsUndefined();
    else {
        isStaticValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "isStatic"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto isStaticConversionResult = convertOptionalWithDefault<IDLBoolean>(lexicalGlobalObject, isStaticValue, [&]() -> ConversionResult<IDLBoolean> { return Converter<IDLBoolean>::ReturnType { false }; });
    if (isStaticConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.isStatic = isStaticConversionResult.releaseReturnValue();
    JSValue layoutValue;
    if (isNullOrUndefined)
        layoutValue = jsUndefined();
    else {
        layoutValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "layout"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto layoutConversionResult = convertOptionalWithDefault<IDLEnumeration<XRLayerLayout>>(lexicalGlobalObject, layoutValue, [&]() -> ConversionResult<IDLEnumeration<XRLayerLayout>> { return Converter<IDLEnumeration<XRLayerLayout>>::ReturnType { XRLayerLayout::Mono }; });
    if (layoutConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.layout = layoutConversionResult.releaseReturnValue();
    JSValue mipLevelsValue;
    if (isNullOrUndefined)
        mipLevelsValue = jsUndefined();
    else {
        mipLevelsValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "mipLevels"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto mipLevelsConversionResult = convertOptionalWithDefault<IDLUnsignedLong>(lexicalGlobalObject, mipLevelsValue, [&]() -> ConversionResult<IDLUnsignedLong> { return Converter<IDLUnsignedLong>::ReturnType { 1 }; });
    if (mipLevelsConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.mipLevels = mipLevelsConversionResult.releaseReturnValue();
    JSValue spaceValue;
    if (isNullOrUndefined)
        spaceValue = jsUndefined();
    else {
        spaceValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "space"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (spaceValue.isUndefined()) {
        throwRequiredMemberTypeError(lexicalGlobalObject, throwScope, "space"_s, "XRQuadLayerInit"_s, "WebXRSpace"_s);
        return ConversionResultException { };
    }
    auto spaceConversionResult = convert<IDLInterface<WebXRSpace>>(lexicalGlobalObject, spaceValue);
    if (spaceConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.space = spaceConversionResult.releaseReturnValue();
    JSValue viewPixelHeightValue;
    if (isNullOrUndefined)
        viewPixelHeightValue = jsUndefined();
    else {
        viewPixelHeightValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "viewPixelHeight"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (viewPixelHeightValue.isUndefined()) {
        throwRequiredMemberTypeError(lexicalGlobalObject, throwScope, "viewPixelHeight"_s, "XRQuadLayerInit"_s, "unsigned long"_s);
        return ConversionResultException { };
    }
    auto viewPixelHeightConversionResult = convert<IDLUnsignedLong>(lexicalGlobalObject, viewPixelHeightValue);
    if (viewPixelHeightConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.viewPixelHeight = viewPixelHeightConversionResult.releaseReturnValue();
    JSValue viewPixelWidthValue;
    if (isNullOrUndefined)
        viewPixelWidthValue = jsUndefined();
    else {
        viewPixelWidthValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "viewPixelWidth"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (viewPixelWidthValue.isUndefined()) {
        throwRequiredMemberTypeError(lexicalGlobalObject, throwScope, "viewPixelWidth"_s, "XRQuadLayerInit"_s, "unsigned long"_s);
        return ConversionResultException { };
    }
    auto viewPixelWidthConversionResult = convert<IDLUnsignedLong>(lexicalGlobalObject, viewPixelWidthValue);
    if (viewPixelWidthConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.viewPixelWidth = viewPixelWidthConversionResult.releaseReturnValue();
    JSValue heightValue;
    if (isNullOrUndefined)
        heightValue = jsUndefined();
    else {
        heightValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "height"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto heightConversionResult = convertOptionalWithDefault<IDLFloat>(lexicalGlobalObject, heightValue, [&]() -> ConversionResult<IDLFloat> { return Converter<IDLFloat>::ReturnType { 1.0 }; });
    if (heightConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.height = heightConversionResult.releaseReturnValue();
    JSValue textureTypeValue;
    if (isNullOrUndefined)
        textureTypeValue = jsUndefined();
    else {
        textureTypeValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "textureType"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto textureTypeConversionResult = convertOptionalWithDefault<IDLEnumeration<XRTextureType>>(lexicalGlobalObject, textureTypeValue, [&]() -> ConversionResult<IDLEnumeration<XRTextureType>> { return Converter<IDLEnumeration<XRTextureType>>::ReturnType { XRTextureType::Texture }; });
    if (textureTypeConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.textureType = textureTypeConversionResult.releaseReturnValue();
    JSValue transformValue;
    if (isNullOrUndefined)
        transformValue = jsUndefined();
    else {
        transformValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "transform"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!transformValue.isUndefined()) {
        auto transformConversionResult = convert<IDLNullable<IDLInterface<WebXRRigidTransform>>>(lexicalGlobalObject, transformValue);
        if (transformConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.transform = transformConversionResult.releaseReturnValue();
    }
    JSValue widthValue;
    if (isNullOrUndefined)
        widthValue = jsUndefined();
    else {
        widthValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "width"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto widthConversionResult = convertOptionalWithDefault<IDLFloat>(lexicalGlobalObject, widthValue, [&]() -> ConversionResult<IDLFloat> { return Converter<IDLFloat>::ReturnType { 1.0 }; });
    if (widthConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.width = widthConversionResult.releaseReturnValue();
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const XRQuadLayerInit& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    auto clearOnAccessValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, dictionary.clearOnAccess);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "clearOnAccess"_s), clearOnAccessValue);
    auto colorFormatValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, dictionary.colorFormat);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "colorFormat"_s), colorFormatValue);
    if (!IDLNullable<IDLUnsignedLong>::isNullValue(dictionary.depthFormat)) {
        auto depthFormatValue = toJS<IDLNullable<IDLUnsignedLong>>(lexicalGlobalObject, throwScope, IDLNullable<IDLUnsignedLong>::extractValueFromNullable(dictionary.depthFormat));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "depthFormat"_s), depthFormatValue);
    }
    auto isStaticValue = toJS<IDLBoolean>(lexicalGlobalObject, throwScope, dictionary.isStatic);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "isStatic"_s), isStaticValue);
    auto layoutValue = toJS<IDLEnumeration<XRLayerLayout>>(lexicalGlobalObject, throwScope, dictionary.layout);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "layout"_s), layoutValue);
    auto mipLevelsValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, dictionary.mipLevels);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "mipLevels"_s), mipLevelsValue);
    auto spaceValue = toJS<IDLInterface<WebXRSpace>>(lexicalGlobalObject, globalObject, throwScope, dictionary.space);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "space"_s), spaceValue);
    auto viewPixelHeightValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, dictionary.viewPixelHeight);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "viewPixelHeight"_s), viewPixelHeightValue);
    auto viewPixelWidthValue = toJS<IDLUnsignedLong>(lexicalGlobalObject, throwScope, dictionary.viewPixelWidth);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "viewPixelWidth"_s), viewPixelWidthValue);
    auto heightValue = toJS<IDLFloat>(lexicalGlobalObject, throwScope, dictionary.height);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "height"_s), heightValue);
    auto textureTypeValue = toJS<IDLEnumeration<XRTextureType>>(lexicalGlobalObject, throwScope, dictionary.textureType);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "textureType"_s), textureTypeValue);
    if (!IDLNullable<IDLInterface<WebXRRigidTransform>>::isNullValue(dictionary.transform)) {
        auto transformValue = toJS<IDLNullable<IDLInterface<WebXRRigidTransform>>>(lexicalGlobalObject, globalObject, throwScope, IDLNullable<IDLInterface<WebXRRigidTransform>>::extractValueFromNullable(dictionary.transform));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "transform"_s), transformValue);
    }
    auto widthValue = toJS<IDLFloat>(lexicalGlobalObject, throwScope, dictionary.width);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "width"_s), widthValue);
    return result;
}

#endif

} // namespace WebCore


#endif // ENABLE(WEBXR_LAYERS)
