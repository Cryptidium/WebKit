/*
    This file is part of the WebKit open source project.
    This file has been generated by generate-bindings.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.
*/

#include "config.h"

#if ENABLE(WEB_RTC)

#include "JSRTCConfiguration.h"

#include "JSDOMConvertInterface.h"
#include "JSDOMConvertNumbers.h"
#include "JSDOMConvertOptional.h"
#include "JSDOMConvertSequences.h"
#include "JSDOMGlobalObject.h"
#include "JSRTCCertificate.h"
#include "JSRTCIceServer.h"
#include <JavaScriptCore/JSArray.h>
#include <JavaScriptCore/JSCInlines.h>
#include <JavaScriptCore/JSString.h>
#include <JavaScriptCore/ObjectConstructor.h>
#include <wtf/NeverDestroyed.h>
#include <wtf/SortedArrayMap.h>



namespace WebCore {
using namespace JSC;

#if ENABLE(WEB_RTC)

template<> ConversionResult<IDLDictionary<RTCConfiguration>> convertDictionary<RTCConfiguration>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    bool isNullOrUndefined = value.isUndefinedOrNull();
    auto* object = isNullOrUndefined ? nullptr : value.getObject();
    if (!isNullOrUndefined && !object) [[unlikely]] {
        throwTypeError(&lexicalGlobalObject, throwScope);
        return ConversionResultException { };
    }
    RTCConfiguration result;
    JSValue bundlePolicyValue;
    if (isNullOrUndefined)
        bundlePolicyValue = jsUndefined();
    else {
        bundlePolicyValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "bundlePolicy"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto bundlePolicyConversionResult = convertOptionalWithDefault<IDLEnumeration<RTCBundlePolicy>>(lexicalGlobalObject, bundlePolicyValue, [&]() -> ConversionResult<IDLEnumeration<RTCBundlePolicy>> { return Converter<IDLEnumeration<RTCBundlePolicy>>::ReturnType { RTCBundlePolicy::Balanced }; });
    if (bundlePolicyConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.bundlePolicy = bundlePolicyConversionResult.releaseReturnValue();
    JSValue certificatesValue;
    if (isNullOrUndefined)
        certificatesValue = jsUndefined();
    else {
        certificatesValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "certificates"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!certificatesValue.isUndefined()) {
        auto certificatesConversionResult = convert<IDLSequence<IDLInterface<RTCCertificate>>>(lexicalGlobalObject, certificatesValue);
        if (certificatesConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.certificates = certificatesConversionResult.releaseReturnValue();
    }
    JSValue iceCandidatePoolSizeValue;
    if (isNullOrUndefined)
        iceCandidatePoolSizeValue = jsUndefined();
    else {
        iceCandidatePoolSizeValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "iceCandidatePoolSize"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto iceCandidatePoolSizeConversionResult = convertOptionalWithDefault<IDLEnforceRangeAdaptor<IDLOctet>>(lexicalGlobalObject, iceCandidatePoolSizeValue, [&]() -> ConversionResult<IDLEnforceRangeAdaptor<IDLOctet>> { return Converter<IDLEnforceRangeAdaptor<IDLOctet>>::ReturnType { 0 }; });
    if (iceCandidatePoolSizeConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.iceCandidatePoolSize = iceCandidatePoolSizeConversionResult.releaseReturnValue();
    JSValue iceServersValue;
    if (isNullOrUndefined)
        iceServersValue = jsUndefined();
    else {
        iceServersValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "iceServers"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    if (!iceServersValue.isUndefined()) {
        auto iceServersConversionResult = convert<IDLSequence<IDLDictionary<RTCIceServer>>>(lexicalGlobalObject, iceServersValue);
        if (iceServersConversionResult.hasException(throwScope)) [[unlikely]]
            return ConversionResultException { };
        result.iceServers = iceServersConversionResult.releaseReturnValue();
    }
    JSValue iceTransportPolicyValue;
    if (isNullOrUndefined)
        iceTransportPolicyValue = jsUndefined();
    else {
        iceTransportPolicyValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "iceTransportPolicy"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto iceTransportPolicyConversionResult = convertOptionalWithDefault<IDLEnumeration<RTCIceTransportPolicy>>(lexicalGlobalObject, iceTransportPolicyValue, [&]() -> ConversionResult<IDLEnumeration<RTCIceTransportPolicy>> { return Converter<IDLEnumeration<RTCIceTransportPolicy>>::ReturnType { RTCIceTransportPolicy::All }; });
    if (iceTransportPolicyConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.iceTransportPolicy = iceTransportPolicyConversionResult.releaseReturnValue();
    JSValue rtcpMuxPolicyValue;
    if (isNullOrUndefined)
        rtcpMuxPolicyValue = jsUndefined();
    else {
        rtcpMuxPolicyValue = object->get(&lexicalGlobalObject, Identifier::fromString(vm, "rtcpMuxPolicy"_s));
        RETURN_IF_EXCEPTION(throwScope, ConversionResultException { });
    }
    auto rtcpMuxPolicyConversionResult = convertOptionalWithDefault<IDLEnumeration<RTCPMuxPolicy>>(lexicalGlobalObject, rtcpMuxPolicyValue, [&]() -> ConversionResult<IDLEnumeration<RTCPMuxPolicy>> { return Converter<IDLEnumeration<RTCPMuxPolicy>>::ReturnType { RTCPMuxPolicy::Require }; });
    if (rtcpMuxPolicyConversionResult.hasException(throwScope)) [[unlikely]]
        return ConversionResultException { };
    result.rtcpMuxPolicy = rtcpMuxPolicyConversionResult.releaseReturnValue();
    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const RTCConfiguration& dictionary)
{
    SUPPRESS_UNCOUNTED_LOCAL auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    auto bundlePolicyValue = toJS<IDLEnumeration<RTCBundlePolicy>>(lexicalGlobalObject, throwScope, dictionary.bundlePolicy);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "bundlePolicy"_s), bundlePolicyValue);
    if (!IDLSequence<IDLInterface<RTCCertificate>>::isNullValue(dictionary.certificates)) {
        auto certificatesValue = toJS<IDLSequence<IDLInterface<RTCCertificate>>>(lexicalGlobalObject, globalObject, throwScope, IDLSequence<IDLInterface<RTCCertificate>>::extractValueFromNullable(dictionary.certificates));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "certificates"_s), certificatesValue);
    }
    auto iceCandidatePoolSizeValue = toJS<IDLEnforceRangeAdaptor<IDLOctet>>(lexicalGlobalObject, throwScope, dictionary.iceCandidatePoolSize);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "iceCandidatePoolSize"_s), iceCandidatePoolSizeValue);
    if (!IDLSequence<IDLDictionary<RTCIceServer>>::isNullValue(dictionary.iceServers)) {
        auto iceServersValue = toJS<IDLSequence<IDLDictionary<RTCIceServer>>>(lexicalGlobalObject, globalObject, throwScope, IDLSequence<IDLDictionary<RTCIceServer>>::extractValueFromNullable(dictionary.iceServers));
        RETURN_IF_EXCEPTION(throwScope, { });
        result->putDirect(vm, JSC::Identifier::fromString(vm, "iceServers"_s), iceServersValue);
    }
    auto iceTransportPolicyValue = toJS<IDLEnumeration<RTCIceTransportPolicy>>(lexicalGlobalObject, throwScope, dictionary.iceTransportPolicy);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "iceTransportPolicy"_s), iceTransportPolicyValue);
    auto rtcpMuxPolicyValue = toJS<IDLEnumeration<RTCPMuxPolicy>>(lexicalGlobalObject, throwScope, dictionary.rtcpMuxPolicy);
    RETURN_IF_EXCEPTION(throwScope, { });
    result->putDirect(vm, JSC::Identifier::fromString(vm, "rtcpMuxPolicy"_s), rtcpMuxPolicyValue);
    return result;
}

#endif

#if ENABLE(WEB_RTC)

String convertEnumerationToString(RTCIceTransportPolicy enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 2> values {
        MAKE_STATIC_STRING_IMPL("relay"),
        MAKE_STATIC_STRING_IMPL("all"),
    };
    static_assert(static_cast<size_t>(RTCIceTransportPolicy::Relay) == 0, "RTCIceTransportPolicy::Relay is not 0 as expected");
    static_assert(static_cast<size_t>(RTCIceTransportPolicy::All) == 1, "RTCIceTransportPolicy::All is not 1 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, RTCIceTransportPolicy enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<RTCIceTransportPolicy> parseEnumerationFromString<RTCIceTransportPolicy>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, RTCIceTransportPolicy>, 2> mappings {
        std::pair<ComparableASCIILiteral, RTCIceTransportPolicy> { "all"_s, RTCIceTransportPolicy::All },
        std::pair<ComparableASCIILiteral, RTCIceTransportPolicy> { "relay"_s, RTCIceTransportPolicy::Relay },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<RTCIceTransportPolicy> parseEnumeration<RTCIceTransportPolicy>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<RTCIceTransportPolicy>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<RTCIceTransportPolicy>()
{
    return "\"relay\", \"all\""_s;
}

#endif

#if ENABLE(WEB_RTC)

String convertEnumerationToString(RTCBundlePolicy enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 3> values {
        MAKE_STATIC_STRING_IMPL("balanced"),
        MAKE_STATIC_STRING_IMPL("max-compat"),
        MAKE_STATIC_STRING_IMPL("max-bundle"),
    };
    static_assert(static_cast<size_t>(RTCBundlePolicy::Balanced) == 0, "RTCBundlePolicy::Balanced is not 0 as expected");
    static_assert(static_cast<size_t>(RTCBundlePolicy::MaxCompat) == 1, "RTCBundlePolicy::MaxCompat is not 1 as expected");
    static_assert(static_cast<size_t>(RTCBundlePolicy::MaxBundle) == 2, "RTCBundlePolicy::MaxBundle is not 2 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, RTCBundlePolicy enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<RTCBundlePolicy> parseEnumerationFromString<RTCBundlePolicy>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, RTCBundlePolicy>, 3> mappings {
        std::pair<ComparableASCIILiteral, RTCBundlePolicy> { "balanced"_s, RTCBundlePolicy::Balanced },
        std::pair<ComparableASCIILiteral, RTCBundlePolicy> { "max-bundle"_s, RTCBundlePolicy::MaxBundle },
        std::pair<ComparableASCIILiteral, RTCBundlePolicy> { "max-compat"_s, RTCBundlePolicy::MaxCompat },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<RTCBundlePolicy> parseEnumeration<RTCBundlePolicy>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<RTCBundlePolicy>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<RTCBundlePolicy>()
{
    return "\"balanced\", \"max-compat\", \"max-bundle\""_s;
}

#endif

#if ENABLE(WEB_RTC)

String convertEnumerationToString(RTCPMuxPolicy enumerationValue)
{
    static const std::array<NeverDestroyed<String>, 2> values {
        MAKE_STATIC_STRING_IMPL("negotiate"),
        MAKE_STATIC_STRING_IMPL("require"),
    };
    static_assert(static_cast<size_t>(RTCPMuxPolicy::Negotiate) == 0, "RTCPMuxPolicy::Negotiate is not 0 as expected");
    static_assert(static_cast<size_t>(RTCPMuxPolicy::Require) == 1, "RTCPMuxPolicy::Require is not 1 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < std::size(values));
    return values[static_cast<size_t>(enumerationValue)];
}

template<> JSString* convertEnumerationToJS(VM& vm, RTCPMuxPolicy enumerationValue)
{
    return jsStringWithCache(vm, convertEnumerationToString(enumerationValue));
}

template<> std::optional<RTCPMuxPolicy> parseEnumerationFromString<RTCPMuxPolicy>(const String& stringValue)
{
    static constexpr std::array<std::pair<ComparableASCIILiteral, RTCPMuxPolicy>, 2> mappings {
        std::pair<ComparableASCIILiteral, RTCPMuxPolicy> { "negotiate"_s, RTCPMuxPolicy::Negotiate },
        std::pair<ComparableASCIILiteral, RTCPMuxPolicy> { "require"_s, RTCPMuxPolicy::Require },
    };
    static constexpr SortedArrayMap enumerationMapping { mappings };
    if (auto* enumerationValue = enumerationMapping.tryGet(stringValue); enumerationValue) [[likely]]
        return *enumerationValue;
    return std::nullopt;
}

template<> std::optional<RTCPMuxPolicy> parseEnumeration<RTCPMuxPolicy>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    return parseEnumerationFromString<RTCPMuxPolicy>(value.toWTFString(&lexicalGlobalObject));
}

template<> ASCIILiteral expectedEnumerationValues<RTCPMuxPolicy>()
{
    return "\"negotiate\", \"require\""_s;
}

#endif

} // namespace WebCore


#endif // ENABLE(WEB_RTC)
